- en: 'Flapjax: Data Visualization on the Web with Plotly and Flask'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'Flapjax: 使用 Plotly 和 Flask 进行网络数据可视化'
- en: 原文：[https://towardsdatascience.com/flapjax-data-visualization-on-the-web-with-plotly-and-flask-465090fa3fba](https://towardsdatascience.com/flapjax-data-visualization-on-the-web-with-plotly-and-flask-465090fa3fba)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/flapjax-data-visualization-on-the-web-with-plotly-and-flask-465090fa3fba](https://towardsdatascience.com/flapjax-data-visualization-on-the-web-with-plotly-and-flask-465090fa3fba)
- en: Build a data visualisation web page with Plotly and Flask, and make it interactive
    with some UI components
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Plotly 和 Flask 构建一个数据可视化网页，并用一些 UI 组件使其互动
- en: '[](https://medium.com/@alan-jones?source=post_page-----465090fa3fba--------------------------------)[![Alan
    Jones](../Images/359379fab1d6685ff08080b98173e67c.png)](https://medium.com/@alan-jones?source=post_page-----465090fa3fba--------------------------------)[](https://towardsdatascience.com/?source=post_page-----465090fa3fba--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----465090fa3fba--------------------------------)
    [Alan Jones](https://medium.com/@alan-jones?source=post_page-----465090fa3fba--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@alan-jones?source=post_page-----465090fa3fba--------------------------------)[![Alan
    Jones](../Images/359379fab1d6685ff08080b98173e67c.png)](https://medium.com/@alan-jones?source=post_page-----465090fa3fba--------------------------------)[](https://towardsdatascience.com/?source=post_page-----465090fa3fba--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----465090fa3fba--------------------------------)
    [Alan Jones](https://medium.com/@alan-jones?source=post_page-----465090fa3fba--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----465090fa3fba--------------------------------)
    ·17 min read·Nov 17, 2023
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·发表于 [Towards Data Science](https://towardsdatascience.com/?source=post_page-----465090fa3fba--------------------------------)
    ·17 分钟阅读·2023年11月17日
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/d6e1e3b1af74219738061df64cef799c.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d6e1e3b1af74219738061df64cef799c.png)'
- en: Photo by [Mae Mu](https://unsplash.com/@picoftasty?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由 [Mae Mu](https://unsplash.com/@picoftasty?utm_source=medium&utm_medium=referral)
    提供，[Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: What is the best framework for building Data visualisation apps? Is it [Streamlit](https://medium.com/towards-data-science/streamlit-from-scratch-getting-started-f4baa7dd6493)
    or Dash, perhaps? Or maybe you could convert a Jupyter Notebook into a web app
    with [Mercury](https://medium.com/towards-data-science/build-a-web-app-with-jupyter-and-mercury-9d59661441b7),
    or [Voilá](https://medium.com/towards-data-science/how-to-share-your-jupyter-notebook-with-mercury-or-voil%C3%A0-2177110d2f6e)?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 构建数据可视化应用程序的最佳框架是什么？是 [Streamlit](https://medium.com/towards-data-science/streamlit-from-scratch-getting-started-f4baa7dd6493)
    还是 Dash？或者你可以用 [Mercury](https://medium.com/towards-data-science/build-a-web-app-with-jupyter-and-mercury-9d59661441b7)
    或 [Voilá](https://medium.com/towards-data-science/how-to-share-your-jupyter-notebook-with-mercury-or-voil%C3%A0-2177110d2f6e)
    将 Jupyter Notebook 转换为网络应用程序？
- en: All these are great ways of creating applications and are fairly easy to get
    started with. But what is easy to start with can often become a little more complex
    as you become a little more adventurous. So, I am going to try and persuade you
    that going back to basics and using Python server code alongside an HTML page
    for the user interface is not as daunting as it might seem.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是创建应用程序的好方法，而且相对容易入门。但通常，容易入门的东西会随着你变得更有冒险精神而变得稍微复杂一些。因此，我将试图说服你，回到基础，使用
    Python 服务器代码和 HTML 页面作为用户界面，其实并没有看起来那么令人生畏。
- en: We can build compelling interactive applications using a fair amount of boilerplate
    code and templates, and this means that you can still concentrate on your Python
    code and exposure to HTML and Javascript is minimal. I’m calling this approach
    *Flapjax* — I’ll explain why later.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用相当多的模板代码和模板构建引人入胜的交互式应用程序，这意味着你可以仍然集中精力在你的 Python 代码上，对 HTML 和 Javascript
    的接触是最小的。我称这种方法为*Flapjax*——稍后我会解释原因。
- en: One of the simplest ways of creating a web application in Python is to use Flask,
    so that is what we will do and we’ll create an app that looks like the one in
    the image below
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个简单的 Python 网络应用程序的一种最简单方法是使用 Flask，这正是我们要做的，我们将创建一个看起来像下面图片中的应用程序。
- en: '![](../Images/bf5e22fe0b4b24eb267590c0eb842f85.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/bf5e22fe0b4b24eb267590c0eb842f85.png)'
- en: An example interactive app
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例互动应用程序
- en: The Flask framework
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flask 框架
- en: Flask is a minimalist framework for developing Web applications. In a Flask
    app, the web page typically is built from a template and data supplied by the
    Python code — this data can be text or graphics that form the content of the webpage.
    The result is sent to the user for display in the browser.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 是一个用于开发 Web 应用的极简框架。在 Flask 应用中，网页通常是由模板和 Python 代码提供的数据构建的——这些数据可以是形成网页内容的文本或图形。结果会被发送给用户以在浏览器中显示。
- en: The diagram below shows the basic structure of an interactive app. When the
    app is running, the Python part executes on the server and passes data to the
    HTML which is running in the browser. The user input from the web page is passed
    back to the Python code which may then send more data to update the HTML with
    new content — a new chart that has been selected by the user, for example.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了一个交互式应用的基本结构。当应用运行时，Python 部分在服务器上执行，并将数据传递给在浏览器中运行的 HTML。网页上的用户输入会传回 Python
    代码，Python 代码可能会发送更多数据以更新 HTML 内容，例如用户选择的新图表。
- en: '![](../Images/44e68bc2cef4a95a663df7c843984269.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/44e68bc2cef4a95a663df7c843984269.png)'
- en: Is it the easiest method for creating a web application?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建 Web 应用程序的最简单方法吗？
- en: To my mind separating the user interface design from the program logic does,
    indeed, make life easier. But, if you are used to building your apps in Streamlit
    or Jupyter Notebooks, then you might find that there is a bit of a learning curve.
    However, once you have adopted a pattern for a basic application, creating a new
    one is very much easier.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，将用户界面设计与程序逻辑分离确实使生活变得更轻松。但如果你习惯于在 Streamlit 或 Jupyter Notebooks 中构建应用，你可能会发现有一定的学习曲线。然而，一旦你采用了一个基本应用的模式，创建新的应用会容易得多。
- en: So, we’ll develop a data visualisation application using Flask and we’ll also
    use Jinja templates that will define our HTML pages — although the actual data
    that appears in those pages will be defined in our Python code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将使用 Flask 开发一个数据可视化应用，并且我们还将使用 Jinja 模板来定义我们的 HTML 页面——虽然实际出现在这些页面中的数据将由我们的
    Python 代码定义。
- en: To make an interactive user interface, we’ll need some UI components and a little
    Javascript but we’ll see that this is pretty much boilerplate code that can be
    reused in future applications.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要制作一个交互式用户界面，我们需要一些 UI 组件和一点 JavaScript，但我们会看到这基本上是可以在未来应用中重用的样板代码。
- en: We’ll also use Bootstrap 5 UI components because why would you be satisfied
    with a web page that looks like the one on the left when with a bit more effort
    you could make it like the one on the right?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用 Bootstrap 5 UI 组件，因为你为什么要满足于一个看起来像左侧的网页呢，而稍加努力就可以让它像右侧的那个网页一样？
- en: '![](../Images/604849608ee775264c998086fd66c9ee.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/604849608ee775264c998086fd66c9ee.png)'
- en: 'This tutorial is in two parts: first, we create a static webpage and get our
    heads around the way Flask and HTML work together and next we’ll deal with callbacks
    to create an interactive page.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程分为两个部分：首先，我们创建一个静态网页，了解 Flask 和 HTML 如何协同工作；接下来，我们将处理回调，以创建一个交互式页面。
- en: All of the code for this article will be in my GitHub repository. I’ll link
    to this at the end shortly after publication.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本文的所有代码将存储在我的 GitHub 仓库中。我会在文章发布后的不久提供链接。
- en: Bootstrap UI
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bootstrap UI
- en: It doesn’t take a lot of effort to create attractive web pages with Bootstrap.
    Including the Bootstrap 5 files and adding some attributes to the HTML elements
    makes it easy to improve basic HTML.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Bootstrap 创建吸引人的网页并不需要太多努力。包含 Bootstrap 5 文件并为 HTML 元素添加一些属性，可以轻松改善基本 HTML。
- en: This is not a Bootstrap tutorial but let me quickly show you the difference
    between the basic HTML code that makes the header in the two webpages, above.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个 Bootstrap 教程，但让我快速向你展示上面两个网页中标题的基本 HTML 代码之间的区别。
- en: '**Basic HTML**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**基础 HTML**'
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**With added Bootstrap attributes**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**添加了 Bootstrap 属性**'
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can see that the header consists of two elements an `<h1>,` a top-level
    heading, and a paragraph `<p>`. In the Bootstrap version, those elements have
    added attributes: the header itself has a *primary* background colour with white
    text, the text is centred and padding at the top and bottom is set to 2 pixels;
    the heading tag uses the `display-4` font and the font for the paragraph is set
    to `lead`— these fonts are defined in Bootstrap with the `display` fonts being
    large and bold and the `lead` is for normal text that needs to stand out.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，头部由两个元素组成，一个 `<h1>`，即顶级标题，以及一个段落 `<p>`。在 Bootstrap 版本中，这些元素有了额外的属性：头部本身具有
    *primary* 背景色和白色文本，文本居中，上下边距设置为 2 像素；标题标签使用 `display-4` 字体，而段落的字体设置为 `lead` ——
    这些字体在 Bootstrap 中定义，其中 `display` 字体大而粗体，而 `lead` 字体用于需要突出的普通文本。
- en: These characteristics are set in an HTML `class` attribute. We’ll see more of
    these in the code that follows and they should be fairly easy to understand. I
    won’t be describing them in any detail but you can find the Bootstrap documentation
    on [their website](https://getbootstrap.com/) — this will tell you everything
    you need to know.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性是在 HTML `class` 属性中设置的。我们将在接下来的代码中看到更多这些特性，它们应该相当容易理解。我不会详细描述这些特性，但你可以在
    [他们的网站](https://getbootstrap.com/) 上找到 Bootstrap 文档 —— 这将告诉你所需了解的一切。
- en: A Flask project
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个 Flask 项目
- en: 'The Flask framework makes it easy to create web-based applications. A Flask
    application will normally consist of at least two files: a Python app and an HTML
    template.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 框架使得创建基于 web 的应用程序变得简单。一个 Flask 应用通常由至少两个文件组成：一个 Python 应用程序和一个 HTML 模板。
- en: 'The Python part contains the application logic: for example, in a data visualisation
    app, it might load the data into a Pandas dataframe, do some analysis and create
    a chart in Plotly. The HTML template defines the layout of the webpage and is
    supplied with the data to display by the Python program.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Python 部分包含应用逻辑：例如，在数据可视化应用中，它可能将数据加载到 Pandas 数据框中，进行一些分析，并在 Plotly 中创建图表。HTML
    模板定义了网页的布局，并由 Python 程序提供显示的数据。
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The directory structure for a simple app, like the one we are going to create,
    should look like the diagram above. The main Python app is in the project folder
    and the template(s) are in a sub-folder called *templates*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单应用的目录结构，如我们将要创建的那样，应该类似于上面的示意图。主 Python 应用程序位于项目文件夹中，模板文件位于名为 *templates*
    的子文件夹中。
- en: 'Of course, you will also need to install Flask:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你还需要安装 Flask：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: And you might want to create a virtual environment before doing so.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样做之前，你可能需要创建一个虚拟环境。
- en: The Python part of a Flask app defines one or more routes that the app will
    respond to. Typically one of those routes is ‘/’ the project’s root.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 应用的 Python 部分定义了一个或多个应用将响应的路由。通常其中一个路由是‘/’，即项目的根目录。
- en: Below is a minimal Python app that uses a template. The template is called *index.html*
    and must be in the *templates* folder and it is rendered as a webpage by Flask
    using the `render_template()` library function. Notice that we create a value
    for the title of the webpage and pass this to the function.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用模板的最小 Python 应用。模板名为 *index.html*，必须位于 *templates* 文件夹中，并由 Flask 使用 `render_template()`
    库函数呈现为网页。请注意，我们为网页标题创建了一个值并将其传递给函数。
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Below is the *index.html* template that expects the value `title` to be incorporated
    into it. You can see that the identifier `title` is enclosed in double curly brackets
    in the `<h1>` tag.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 *index.html* 模板，它期望 `title` 值被纳入其中。你可以看到，在 `<h1>` 标签中，标识符 `title` 被包围在双大括号中。
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Flask uses the Jinja templating engine to substitute the placeholders in the
    HTML template with the values that are passed to `render_template()`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 使用 Jinja 模板引擎来用传递给 `render_template()` 的值替换 HTML 模板中的占位符。
- en: You run the application by typing `flask run` in a terminal and you should get
    a response similar to the one below. (This assumes that you’ve called your application
    *app.py —* if you’ve called it something else you need to type `flask --app app_name
    run`. Change `app_name` to the name of your app without the `.py` extension.)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在终端中输入 `flask run` 来运行应用程序，你应该会得到类似于下面的响应。（这假设你将应用程序命名为 *app.py* —— 如果你用其他名字命名，需要输入
    `flask --app app_name run`。将 `app_name` 更改为你的应用程序名称，不包含 `.py` 扩展名。）
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Point your browser at *http://127.0.0.1:5000* or *localhost:5000* and you will
    see a simple web page that displays the text that was defined in the Python code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 将浏览器指向 *http://127.0.0.1:5000* 或 *localhost:5000*，你将看到一个简单的网页，展示了在 Python 代码中定义的文本。
- en: To find out more about Flask, you could start by looking at their [Quickstart](https://flask.palletsprojects.com/en/3.0.x/quickstart/)
    tutorial but, I hope I’ll cover everything you need to know to get started, here.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于Flask的信息，你可以从查看他们的[快速入门](https://flask.palletsprojects.com/en/3.0.x/quickstart/)教程开始，但我希望我会在这里涵盖你开始所需的所有内容。
- en: A static data visualisation application
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个静态数据可视化应用程序
- en: Our first application will build on what we have seen so far to produce a website
    that contains a Plotly chart and some supporting text. Later, we’ll go on to add
    some interactivity.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个应用程序将基于迄今为止看到的内容，创建一个包含Plotly图表和一些辅助文本的网站。稍后，我们将添加一些交互功能。
- en: 'Let’s take a look at the Python side of things. The listing is below but for
    the moment, concentrate on the section that begins with the comment `#### Simple
    template ####`. Here you can see that we have defined a route called `/simple`
    which means that we invoke the app by pointing our browser at *localhost:5000/simple*,
    and the function below the decorator, `simpleindex(),` will be executed.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们看看Python的部分。下面的代码列表中，请暂时关注以`#### Simple template ####`开头的部分。在这里，你可以看到我们定义了一个名为`/simple`的路由，这意味着我们通过将浏览器指向*localhost:5000/simple*来调用应用程序，而装饰器下方的`simpleindex(),`函数将会被执行。'
- en: In this function, we set up some text and a graph we want to display on the
    webpage. We first set some variables and then use these to create a dictionary
    of parameters that the HTML template will use. The names of the variables make
    it plain how they will be used.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们设置了一些文本和我们希望在网页上显示的图形。我们首先设置了一些变量，然后使用这些变量创建一个HTML模板将使用的参数字典。变量的名称清楚地表明了它们的使用方式。
- en: The graph parameter is set using the function `get_graph()`. This first of all
    loads the data which are global temperature anomalies from 1881 to 2022 and tracks
    the way climate change is affecting temperatures over that time (for a detailed
    view on this please see [New Data Demonstrates that 2023 was the Hottest Summer
    Ever](/new-data-demonstrates-that-2023-was-the-hottest-summer-ever-d92d500a8f01)).
    The data is shown in the table below (it’ll look better in the graph!).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_graph()`函数设置了图形参数。首先，它加载了1881年至2022年的全球温度异常数据，并追踪气候变化如何影响这段时间的温度（有关详细信息，请参见[新数据表明2023年是有记录以来最热的夏天](/new-data-demonstrates-that-2023-was-the-hottest-summer-ever-d92d500a8f01)）。这些数据在下表中显示（在图表中会更清晰！）。'
- en: '![](../Images/560ca8eb44fd84bfdd8efac6f29c0470.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/560ca8eb44fd84bfdd8efac6f29c0470.png)'
- en: Global temperature anomalies
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 全球温度异常
- en: For the static app, we will use a single column `JJA` which refers to the temperatures
    in June, July and August. The interactive app will use some of the others, too,
    so we have a default value for the `period` parameter for our current app which
    can then be changed by the interactive app, later.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于静态应用程序，我们将使用单列`JJA`，它指的是6月、7月和8月的温度。交互式应用程序也会使用其他一些列，因此我们当前应用程序的`period`参数有一个默认值，之后可以被交互式应用程序更改。
- en: The data is used to create a Plotly bar chart and the figure generated is converted
    to JSON which will be used by the webpage. So, it is this JSON data that is returned
    to set the `graph` entry in the dictionary of parameters.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 数据用于创建一个Plotly条形图，生成的图形被转换为JSON，网页将使用这些数据。因此，这些JSON数据被返回以设置字典参数中的`graph`条目。
- en: Going back to the previous function, we now need to call `render_template` with
    the parameters that we have set. To save typing, I’ve created a helper function
    called `template` that extracts the template parameter and passes all the data
    to the webpage.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 回到之前的函数，我们现在需要使用我们设置的参数调用`render_template`。为了节省输入时间，我创建了一个名为`template`的辅助函数，它提取模板参数并将所有数据传递到网页上。
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now for the HTML template. The listing is below and the good news is that you
    can ignore everything except the code within the `<body>...</body>` tags. All
    of the rest is boilerplate code that you need for a webpage that uses Bootstrap
    and Plotly, and this can be cut-and-pasted into any similar webpage. The final
    `<script>` tag is also boilerplate code that includes the Bootstrap Javascript
    code and can be safely ignored.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看HTML模板。下面的代码列表中，好消息是你可以忽略除`<body>...</body>`标签内的代码外的所有内容。其余的都是你需要的Bootstrap和Plotly网页的样板代码，可以剪切并粘贴到任何类似的网页中。最后的`<script>`标签也是样板代码，包含了Bootstrap的Javascript代码，可以安全忽略。
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If we also ignore the Bootstrap attributes that make the page look nice, we
    end up with the code below, which is much less daunting and this is what I will
    refer to from here on.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们忽略使页面看起来漂亮的 Bootstrap 属性，我们得到的代码如下，这要简单得多，这就是我从这里开始引用的内容。
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We’ve seen the use of Jinja parameters before, the only difference this time
    is that we’ve bundled a few parameters into a dictionary called `params`. So,
    we refer to them by prefixing their names with the name of the dictionary. So,
    `<h1>{{params.title}}</h1>` is simply putting the `title` parameter into a pair
    of heading tags. The other three tags for the text parameters are similar.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前见过使用 Jinja 参数，这次唯一的不同是我们将几个参数打包成一个名为 `params` 的字典。因此，我们通过在参数名称前加上字典的名称来引用它们。因此，`<h1>{{params.title}}</h1>`
    只是将 `title` 参数放入一对标题标签中。其他三个文本参数的标签也是类似的。
- en: To draw the graph we need an element in which to put it and that element must
    have an *id* attribute(`<div id='chart'></div>`). This element is positioned below
    the headings and above the description.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绘制图表，我们需要一个可以放置图表的元素，并且该元素必须有一个 *id* 属性 (`<div id='chart'></div>`)。这个元素被放置在标题下方和描述上方。
- en: 'The script element below this is again boilerplate code that invokes the Plotly
    Javascript to draw the chart. The only thing to notice here is that when we include
    the `graph` parameter, we use the keyword `safe`. This instructs Jinja not to
    try and interpret any special characters in `graph` but to treat them literally
    as they are. Hence the code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的脚本元素再次是调用 Plotly Javascript 绘制图表的样板代码。唯一需要注意的是，当我们包含 `graph` 参数时，我们使用了 `safe`
    关键字。这指示 Jinja 不要尝试解释 `graph` 中的任何特殊字符，而是将它们按字面意思对待。因此，代码如下：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, remember that the template must be in the templates folder in the project
    directory and for this code to work, the data file must be in the project directory
    itself (you can move it, of course, but you will have to change the path when
    opening it in your Python program).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请记住模板必须在项目目录中的 templates 文件夹中，并且为了使此代码正常工作，数据文件必须位于项目目录本身（当然，你可以移动它，但在 Python
    程序中打开时必须更改路径）。
- en: So run the app and point your browser at *localhost:5000/simple*, and you should
    see a webpage like the one below.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 所以运行应用程序并在浏览器中指向 *localhost:5000/simple*，你应该能看到一个如下图所示的网页。
- en: '![](../Images/026a7f8a007aa2461ecefee20a00d8f3.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/026a7f8a007aa2461ecefee20a00d8f3.png)'
- en: A static app
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一个静态应用
- en: And that is the static version of the web app.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是网页应用的静态版本。
- en: An interactive data visualisation application
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个互动数据可视化应用
- en: 'But why restrict ourselves to Summer? Wouldn’t it be nice if we were to be
    able to choose a period other than *JJA*? The data also contains columns for the
    whole year, *J-D*, and the three-month periods: *DJF*, *MAM*, *JJA* and *SON*.
    (The letters represent the month names in English: December, January, February;
    March, April, May; and so on.)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 但是为什么要限制在夏季？如果我们能够选择除 *JJA* 以外的其他时期不是很好吗？数据还包含全年的列，*J-D*，以及三个时间段：*DJF*、*MAM*、*JJA*
    和 *SON*。（这些字母代表英文中的月份名称：十二月、一月、二月；三月、四月、五月；等等。）
- en: To do this we need to incorporate a user control that can be used to select
    the appropriate period. I’ve chosen a drop-down menu that will display the various
    periods. It will look pretty similar to the previous webpage (see the image below).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要整合一个用户控件，用于选择适当的时间段。我选择了一个下拉菜单，用于显示各种时间段。它将与之前的网页非常相似（参见下图）。
- en: '![](../Images/bf5e22fe0b4b24eb267590c0eb842f85.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/bf5e22fe0b4b24eb267590c0eb842f85.png)'
- en: An interactive app
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一个互动应用
- en: The code is initially quite similar, too. The major difference comes when dealing
    with the selection of a new graph.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 代码最初也非常相似。主要区别出现在处理新图表的选择时。
- en: When a new value is selected, this will call a Javascript function that will
    send the value to a callback function on the server and wait for a response. This
    callback function will return a new chart which will then be displayed by the
    calling Javascript.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择一个新值时，这将调用一个 Javascript 函数，该函数将值发送到服务器上的回调函数并等待响应。这个回调函数将返回一个新的图表，然后由调用的
    Javascript 显示。
- en: Let’s deal with the familiar stuff first. Below is the function that implements
    the new endpoint */ddsimple*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先处理熟悉的内容。下面是实现新端点 */ddsimple* 的函数。
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see it is very similar to the /*simple* endpoint. The difference
    (apart from the names) is that there are extra parameters: a label for the menu
    and a dictionary that represents a list of entries for the menu, first a value
    that corresponds to a column in the dataframe and second a textual description
    of that value which will be displayed in the menu.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它与/*simple*端点非常相似。区别（除了名称）在于额外的参数：菜单的标签和一个表示菜单项列表的字典，首先是一个对应于数据框列的值，其次是该值的文本描述，这些描述将显示在菜单中。
- en: The HTML is a little different as it demonstrates a more sophisticated use of
    Jinja. The code is below.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: HTML稍有不同，因为它展示了Jinja的更复杂用法。代码如下。
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here we construct a form with a drop-down menu. The form also contains a label
    for the menu which is included in the double curly brackets that we have seen
    before.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们构建了一个包含下拉菜单的表单。该表单还包含一个菜单标签，这个标签包含在我们之前见过的双花括号中。
- en: The major difference from the previous example is the way the menu is constructed.
    Within the element `<select>` we need to place a list of `<option>` tags that
    represent the options given in the menu. The option tag has a value and a description
    which are what we have defined in the `params.options` dictionary. We include
    those values and descriptions by executing a Jinja loop like this `{% for opt
    in param.options %}` which iterates over the dictionary putting each element into
    a local variable `opt`. We then use this to insert the values and descriptions
    into an `<option>` tag using the values `opt.code` and `opt.desc`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的示例相比，主要区别在于菜单的构建方式。在`<select>`元素内，我们需要放置一系列代表菜单选项的`<option>`标签。`<option>`标签具有一个值和一个描述，这些值和描述是在`params.options`字典中定义的。我们通过执行类似`{%
    for opt in param.options %}`的Jinja循环来包含这些值和描述，该循环遍历字典，将每个元素放入本地变量`opt`中。然后，我们利用这些值和描述，通过使用`opt.code`和`opt.desc`将它们插入到`<option>`标签中。
- en: 'You can find simple examples and explanations of Jinja templates and the way
    they are used in [Flask Tutorial: Templates on the Pythonbasics.org website](https://pythonbasics.org/flask-tutorial-templates/).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[Flask教程：Pythonbasics.org网站上的模板](https://pythonbasics.org/flask-tutorial-templates/)中找到Jinja模板的简单示例和解释。
- en: There is another part of the form tag that is essential to our purposes here.
    Within the form tag is an attribute called `onChange` this takes a value of some
    sort of action, in this case, it is a Javascript function that is called whenever
    a value with the form changes — in this case when one of the options in the menu
    is chosen.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 表单标签中还有另一个对我们目的至关重要的部分。表单标签内有一个名为`onChange`的属性，它接受某种类型的动作值，在这种情况下，它是一个Javascript函数，每当表单中的值发生变化时——在本例中，当选择菜单中的选项时，就会调用这个函数。
- en: And that is where the fun begins.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是有趣的开始。
- en: Callbacks
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回调
- en: In order to update a web page with a new chart we use a callback mechanism and
    the chart below shows the transactions between the browser and the server. Note
    that the response to requesting a new chart is *not* to reload the page but to
    update it — this is quicker and avoids the momentary blank screen that accompanies
    a reload giving a much nicer user experience.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了用新图表更新网页，我们使用回调机制，下面的图表展示了浏览器与服务器之间的事务。请注意，响应请求新图表的方式是*不是*重新加载页面，而是更新页面——这种方式更快，并且避免了重新加载时出现的瞬时空白屏幕，从而提供了更好的用户体验。
- en: '![](../Images/017940485c124abb31584f388fec0575.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/017940485c124abb31584f388fec0575.png)'
- en: Using a callback to update a webpage
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用回调更新网页
- en: The callback is invoked by a change in the form on the web page, as we mentioned
    before. The mechanism for this is a Javascript function that is identified in
    the `onChange` attribute in the form.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 回调是通过网页上表单的变化来调用的，正如我们之前提到的。这种机制是一个在表单的`onChange`属性中标识的Javascript函数。
- en: I’m going to explain how the Javascript function works in detail shortly but
    essentially, it grabs the values from the form and sends them to a callback endpoint
    in the Flask app.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我将详细解释Javascript函数的工作原理，但基本上，它从表单中获取值，并将这些值发送到Flask应用中的回调端点。
- en: Now, if the thought of writing Javascript gives you the heebie-jeebies, don’t
    worry, you don’t really need to know how this stuff works, you can just copy it
    and it will work for any form that you might want to include on your web page.
    So, for the adventurous the explanation follows, for the rest — just skip to the
    next section.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果想到编写 Javascript 让你感到不安，不用担心，你不需要真正了解这些内容，你可以直接复制它，它适用于你可能想在网页上包含的任何表单。因此，对冒险者而言，解释如下，对于其他人——直接跳到下一部分。
- en: 'There are actually two functions: the one that grabs the values from the form
    is shown below.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上有两个函数：从表单中获取值的函数如下所示。
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'All the code uses built-in Javascript functions: the first line gets the form
    from the document (i.e. the web page); the second line retrieves a data structure
    that contains the form data; and the third line extracts all of the values from
    that structure.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 所有代码都使用内置的 Javascript 函数：第一行从文档（即网页）中获取表单；第二行检索包含表单数据的数据结构；第三行提取该结构中的所有值。
- en: Finally, those values are passed to another function `postJson`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这些值被传递给另一个函数 `postJson`。
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This function is an asynchronous function which means that after it is called,
    program execution returns immediately to the calling code and the asynchronous
    function continues in a separate execution thread. That is to say, it carries
    on doing whatever it needs to do in parallel with the execution of the web page.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是一个异步函数，这意味着在调用后，程序执行会立即返回到调用代码，而异步函数会在一个单独的执行线程中继续运行。也就是说，它会与网页的执行并行地继续执行所需的操作。
- en: '`postJSON` is given the data that needs to be sent to the Python callback code
    and it sends it using the asynchronous `fetch` function. `fetch` is given the
    endpoint to which the data should be passed and the data itself as parameters
    — we use the HTTP POST mechanism to send the data. `postJSON` waits for the fetch
    to finish, i.e. for some data to be returned from the server. That data is then
    passed to the `drawGraph` function which updates the graph on the webpage.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`postJSON` 函数接收需要发送到 Python 回调代码的数据，并使用异步 `fetch` 函数发送。`fetch` 接收数据应该传递到的端点和数据本身作为参数——我们使用
    HTTP POST 机制来发送数据。`postJSON` 等待 fetch 完成，即等待服务器返回一些数据。然后将这些数据传递给 `drawGraph` 函数，更新网页上的图表。'
- en: 'Note that the code is contained in a `try... catch...` block. This is pretty
    much the same as you would find in a Python program: if the code in the `try`
    block fails — there is no response or some other communications failure — then
    that failure is logged in the console.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，代码被包含在 `try... catch...` 块中。这与在 Python 程序中看到的基本相同：如果 `try` 块中的代码失败——没有响应或其他通信故障——那么该故障将被记录到控制台中。
- en: The Python callback
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 回调
- en: 'For all this to work, we need a callback function in the Flask code which will
    receive the data, do something with it (i.e. create a new graph) and send back
    a result. Here it is:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这一切工作，我们需要一个 Flask 代码中的回调函数，该函数将接收数据，对其进行处理（即创建新图表），并返回结果。如下所示：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first thing to do is to define the endpoint for the callback and you can
    see that we also specify that the endpoint expects data to be sent using the POST
    method.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要定义回调的端点，你可以看到我们还指定了端点期望使用 POST 方法发送数据。
- en: We also expect the data to be in JSON format and if it isn’t we return an error.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也期望数据为 JSON 格式，如果不是，则返回错误。
- en: If the data *is* JSON then we extract the value from the dropdown menu and pass
    it to the `get_graph` function which draws a graph and returns it in the JSON
    format that Plotly expects. This graph data is received by the Javascript function
    on the webpage and the page is updated.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据*是* JSON，我们从下拉菜单中提取值，并将其传递给`get_graph`函数，该函数绘制图表并以 Plotly 期望的 JSON 格式返回图表数据。这个图表数据由网页上的
    Javascript 函数接收，页面得到更新。
- en: This code will give you the interactive webpage above.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将为你提供上面显示的交互式网页。
- en: Flapjax — what’s in a name
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flapjax —— 名字中有什么
- en: 'Admittedly, it is a fairly contrived name: it stands for **Fla**sk, **P**ython,
    **J**avascript and **ax** which represents the asynchronous communication that
    enables this technique.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，这个名字有些刻意：它代表了**Fla**sk，**P**ython，**J**avascript 和 **ax**，这些代表了使这种技术得以实现的异步通信。
- en: I hope that you can see that by using pre-written templates and a chunk of boilerplate
    code, you can create useful interactive web pages whilst concentrating mostly
    on the logic of your Python code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你能看到，通过使用预先编写的模板和一段模板代码，你可以创建有用的交互式网页，同时主要集中于 Python 代码的逻辑。
- en: This app incorporates only a single graph that is updated when the user selects
    a new option but any number of values can be collected from an HTML form in this
    way which can then be processed by the Flask app before updating the webpage with
    new information (maybe we’ll explore this in a future article).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序仅包含一个图表，当用户选择新选项时，该图表会更新，但可以通过这种方式从 HTML 表单中收集任意数量的值，这些值可以由 Flask 应用程序处理，然后用新信息更新网页（也许我们会在未来的文章中探讨这个问题）。
- en: All of the code and data illustrated here can be downloaded from my [GitHub
    repo](https://github.com/alanjones2/flapjax_public) (look in the folder *jinja-article*).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 所有在这里展示的代码和数据可以从我的 [GitHub 仓库](https://github.com/alanjones2/flapjax_public)
    下载（查看 *jinja-article* 文件夹）。
- en: '*UPDATE: I’ve written a new app in the* reuse *folder of the GitHub repo that
    creates a new app with a new set of data — the HTML and Javascript remain the
    same and only the Python code and the data are changed:* [**Reusing Flapjax Templates
    and Code**](https://medium.com/codefile/reusing-flapjax-templates-and-code-0ee6db58ffc8)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*更新：我在 GitHub 仓库的* reuse *文件夹中编写了一个新应用程序，该应用程序使用一组新的数据——HTML 和 Javascript 保持不变，只有
    Python 代码和数据发生了变化：* [**重用 Flapjax 模板和代码**](https://medium.com/codefile/reusing-flapjax-templates-and-code-0ee6db58ffc8)'
- en: 'I hope you have found this useful. If you want to see more of my work, please
    visit my [website](http://alanjones2.github.io) and you can get updates when I
    publish by subscribing to my free newsletter, here:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你觉得这些内容有用。如果你想查看更多我的作品，请访问我的 [网站](http://alanjones2.github.io)，并通过订阅我的免费通讯来获取我发布的更新，点击这里：
- en: '[](https://technofile.substack.com/?source=post_page-----465090fa3fba--------------------------------)
    [## Data Visualization, Data Science and Python | Alan Jones | Substack'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[## 数据可视化、数据科学和 Python | Alan Jones | Substack'
- en: Tutorials and other articles about Data Science, Data Visualization with hands-on
    coding mostly in Python. Click to…
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于数据科学、数据可视化及主要使用 Python 进行的动手编码的教程和其他文章。点击…
- en: technofile.substack.com](https://technofile.substack.com/?source=post_page-----465090fa3fba--------------------------------)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[technofile.substack.com](https://technofile.substack.com/?source=post_page-----465090fa3fba--------------------------------)'
- en: And if Flask isn’t your thing, I’ve written an eBook [*Streamlit from Scratch*](https://alanjones.gumroad.com/l/streamlitfromscratch)based
    on my articles from Medium.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Flask 不是你的首选，我根据我在 Medium 上的文章编写了一本电子书 [*从头开始学习 Streamlit*](https://alanjones.gumroad.com/l/streamlitfromscratch)。
- en: Notes and references
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 说明和参考文献
- en: The data used in this article and the app is derived from that described in
    notes 1 and 2 below.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 本文和应用程序中使用的数据来源于下面第 1 和第 2 条说明中的描述。
- en: 'GISTEMP Team, 2023: GISS Surface Temperature Analysis (GISTEMP), version 4\.
    NASA Goddard Institute for Space Studies. Dataset accessed 2023–09–19 at data.giss.nasa.gov/gistemp/.
    *Note that there is no specific license for the use of NASA’s data sets. They
    are made freely available by NASA for non-commercial purposes but attribution
    (as above) should be given.*'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'GISTEMP 团队，2023: GISS 地表温度分析 (GISTEMP)，第 4 版。NASA 戈达德空间研究所。数据集访问日期 2023–09–19，网址：data.giss.nasa.gov/gistemp/。*请注意，NASA
    数据集的使用没有特定的许可证。NASA 将这些数据集免费提供用于非商业目的，但应给予归属（如上所述）。*'
- en: 'Lenssen, N., G. Schmidt, J. Hansen, M. Menne, A. Persin, R. Ruedy, and D. Zyss,
    2019: Improvements in the GISTEMP uncertainty model. J. Geophys. Res. Atmos.,
    124, no. 12, 6307–6326, doi:10.1029/2018JD029522.'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Lenssen, N., G. Schmidt, J. Hansen, M. Menne, A. Persin, R. Ruedy, 和 D. Zyss,
    2019: GISTEMP 不确定性模型的改进。J. Geophys. Res. Atmos., 124, no. 12, 6307–6326, doi:10.1029/2018JD029522。'
- en: All images, diagrams, screenshots and code were created by the author unless
    otherwise noted.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 除非另有说明，所有的图像、图表、截图和代码均由作者创建。
