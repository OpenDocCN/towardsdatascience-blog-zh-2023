- en: Nine Rules to Formally Validate Rust Algorithms with Dafny (Part 1)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用 Dafny 正式验证 Rust 算法的九个规则（第一部分）
- en: 原文：[https://towardsdatascience.com/nine-rules-to-formally-validate-rust-algorithms-with-dafny-part-1-5cb8c8a0bb92?source=collection_archive---------3-----------------------#2023-10-04](https://towardsdatascience.com/nine-rules-to-formally-validate-rust-algorithms-with-dafny-part-1-5cb8c8a0bb92?source=collection_archive---------3-----------------------#2023-10-04)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/nine-rules-to-formally-validate-rust-algorithms-with-dafny-part-1-5cb8c8a0bb92?source=collection_archive---------3-----------------------#2023-10-04](https://towardsdatascience.com/nine-rules-to-formally-validate-rust-algorithms-with-dafny-part-1-5cb8c8a0bb92?source=collection_archive---------3-----------------------#2023-10-04)
- en: '**Lessons from Verifying the range-set-blaze Crate**'
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**验证 range-set-blaze 木板的经验教训**'
- en: '[](https://medium.com/@carlmkadie?source=post_page-----5cb8c8a0bb92--------------------------------)[![Carl
    M. Kadie](../Images/9dbe27c76e9567136e5a7dc587f1fb15.png)](https://medium.com/@carlmkadie?source=post_page-----5cb8c8a0bb92--------------------------------)[](https://towardsdatascience.com/?source=post_page-----5cb8c8a0bb92--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----5cb8c8a0bb92--------------------------------)
    [Carl M. Kadie](https://medium.com/@carlmkadie?source=post_page-----5cb8c8a0bb92--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@carlmkadie?source=post_page-----5cb8c8a0bb92--------------------------------)[![Carl
    M. Kadie](../Images/9dbe27c76e9567136e5a7dc587f1fb15.png)](https://medium.com/@carlmkadie?source=post_page-----5cb8c8a0bb92--------------------------------)[](https://towardsdatascience.com/?source=post_page-----5cb8c8a0bb92--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----5cb8c8a0bb92--------------------------------)
    [Carl M. Kadie](https://medium.com/@carlmkadie?source=post_page-----5cb8c8a0bb92--------------------------------)'
- en: ·
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fa5e87027005f&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnine-rules-to-formally-validate-rust-algorithms-with-dafny-part-1-5cb8c8a0bb92&user=Carl+M.+Kadie&userId=a5e87027005f&source=post_page-a5e87027005f----5cb8c8a0bb92---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----5cb8c8a0bb92--------------------------------)
    ·14 min read·Oct 4, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F5cb8c8a0bb92&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnine-rules-to-formally-validate-rust-algorithms-with-dafny-part-1-5cb8c8a0bb92&user=Carl+M.+Kadie&userId=a5e87027005f&source=-----5cb8c8a0bb92---------------------clap_footer-----------)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fa5e87027005f&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnine-rules-to-formally-validate-rust-algorithms-with-dafny-part-1-5cb8c8a0bb92&user=Carl+M.+Kadie&userId=a5e87027005f&source=post_page-a5e87027005f----5cb8c8a0bb92---------------------post_header-----------)
    发表于 [Towards Data Science](https://towardsdatascience.com/?source=post_page-----5cb8c8a0bb92--------------------------------)
    ·14 min 阅读·2023 年 10 月 4 日[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F5cb8c8a0bb92&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnine-rules-to-formally-validate-rust-algorithms-with-dafny-part-1-5cb8c8a0bb92&user=Carl+M.+Kadie&userId=a5e87027005f&source=-----5cb8c8a0bb92---------------------clap_footer-----------)'
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F5cb8c8a0bb92&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnine-rules-to-formally-validate-rust-algorithms-with-dafny-part-1-5cb8c8a0bb92&source=-----5cb8c8a0bb92---------------------bookmark_footer-----------)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F5cb8c8a0bb92&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnine-rules-to-formally-validate-rust-algorithms-with-dafny-part-1-5cb8c8a0bb92&source=-----5cb8c8a0bb92---------------------bookmark_footer-----------)'
- en: By Carl M. Kadie and Divyanshu Ranjan
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Carl M. Kadie 和 Divyanshu Ranjan 撰写
- en: '![](../Images/4b175b7d615204b0c7333b51b9ec5f88.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4b175b7d615204b0c7333b51b9ec5f88.png)'
- en: 'Crab proving Pythagoras’ theorem — Source: [https://openai.com/dall-e-2/](https://openai.com/dall-e-2/)
    & [CC BY-SA 3.0](http://creativecommons.org/licenses/by-sa/3.0/) [File:Pythagorean.svg](https://commons.wikimedia.org/wiki/File:Pythagorean.svg)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 蟹证明毕达哥拉斯定理 — 源自：[https://openai.com/dall-e-2/](https://openai.com/dall-e-2/)
    & [CC BY-SA 3.0](http://creativecommons.org/licenses/by-sa/3.0/) [File:Pythagorean.svg](https://commons.wikimedia.org/wiki/File:Pythagorean.svg)
- en: My Rust crate `[range-set-blaze](https://crates.io/crates/range-set-blaze)`
    depends on a critical function named `internal_add`. The function is supposed
    to insert a range of integers into the crate’s data structure. But does it do
    so *correctly*? Of course, I test, but testing can miss bugs. Ideally, I want
    mathematical certainty of correctness.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我的Rust crate `[range-set-blaze](https://crates.io/crates/range-set-blaze)` 依赖于一个名为`internal_add`的关键函数。该函数应当将一系列整数插入到crate的数据结构中。但它是否*正确*地完成了这个任务？当然，我会进行测试，但测试可能会漏掉错误。理想情况下，我希望获得数学上的正确性保障。
- en: 'Aside: As Rust programmers, we appreciate certainty. The Rust type system guarantees
    we won’t dereference null pointers. The Rust borrow checker guarantees we won’t
    use memory after it is freed. Tools such as the [Kani Rust crate](https://medium.com/@carlmkadie/check-ai-generated-code-perfectly-and-automatically-d5b61acff741)
    guarantee — in some cases — that arithmetic will not overflow. But what if we
    want certainty that an algorithm is correct?'
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附注：作为Rust程序员，我们欣赏确定性。Rust类型系统保证我们不会解引用空指针。Rust借用检查器保证我们不会在内存被释放后继续使用它。像[Kani
    Rust crate](https://medium.com/@carlmkadie/check-ai-generated-code-perfectly-and-automatically-d5b61acff741)这样的工具在某些情况下保证算术不会溢出。但如果我们想要确定一个算法的正确性呢？
- en: To achieve this certainty, Divyanshu Ranjan and I ported `internal_add`'s algorithm
    to the Dafny language. We then validated the Dafny-version of the algorithm. (We
    chose Dafny for its combination of power and ease of use. We’ll talk a little
    more about this choice, presently.)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这种确定性，Divyanshu Ranjan和我将`internal_add`的算法移植到Dafny语言中。然后我们验证了Dafny版本的算法。（我们选择Dafny是因为它的强大和易用性。稍后我们会多谈谈这个选择。）
- en: Over the course of the validation, we learned nine rules that can help you validate
    algorithms — written in Rust or other languages — with Dafny. You may also find
    these rules interesting as a way to gauge the ease or difficulty of such verification
    using modern tools.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证过程中，我们学习了九条规则，可以帮助你使用Dafny验证算法——无论是用Rust还是其他语言编写的。你也可能会发现这些规则作为使用现代工具验证的难易程度的参考非常有趣。
- en: 'The rules are:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 规则如下：
- en: Don’t Learn Dafny.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要学习Dafny。
- en: Learn Dafny.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 学习Dafny。
- en: Define Your Algorithm’s Basic Concepts.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义你算法的基本概念。
- en: Specify Your Algorithm.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 规范你的算法。
- en: Get Help from the Dafny Community.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Dafny社区获取帮助。
- en: Validate a Different, Easier, Algorithm.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证一个不同的、更简单的算法。
- en: '*See* [*Part 2*](https://medium.com/towards-data-science/nine-rules-to-formally-validate-rust-algorithms-with-dafny-part-2-f2a279686700)
    *for these rules:*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*见* [*第2部分*](https://medium.com/towards-data-science/nine-rules-to-formally-validate-rust-algorithms-with-dafny-part-2-f2a279686700)
    *了解这些规则：*'
- en: '*7\. Port your Real Algorithm to Dafny.*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*7\. 将你的实际算法移植到Dafny。*'
- en: '*8\. Validate the Dafny Version of Your Algorithm.*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*8\. 验证你算法的Dafny版本。*'
- en: '*9\. Rework Your Validation for Reliability.*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*9\. 重新工作你的验证以确保可靠性。*'
- en: 'Aside: To avoid wishy-washiness, we call these “rules”, but they are, of course,
    just suggestions.'
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附注：为了避免模棱两可，我们称这些为“规则”，但它们当然只是建议。
- en: The `internal_add` function tries to efficiently insert a new range of integers
    into an existing list of sorted and disjoint integer ranges. For example, if we
    started with `[101..=102, 400..=402, 404..=405]` and added `402..=404`, we expect
    a result of `[101..=102, 400..=405]`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`internal_add`函数试图将一个新的整数范围高效地插入到已排序且不重叠的整数范围列表中。例如，如果我们从`[101..=102, 400..=402,
    404..=405]`开始，并添加`402..=404`，我们期望的结果是`[101..=102, 400..=405]`。'
- en: '![](../Images/a1ad08fd33646c38e30b09a37afecdb3.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a1ad08fd33646c38e30b09a37afecdb3.png)'
- en: 'Source: This and all following images by author.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：本文及所有后续图片均由作者提供。
- en: Ideally, I’d formally verify this algorithm with Rust-specific tools [[1](https://rust-formal-methods.github.io/tools.html),[2](https://alastairreid.github.io/automatic-rust-verification-tools-2021/)].
    Those tools, however, seem hard to use. Instead, I chose [Dafny](https://dafny.org/).
    Dafny is a language and verification system. It is taught to undergraduates at
    universities around the world. It is used in industry. I find it to be addictively
    interactive and programmer friendly.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我会使用Rust特定的工具[[1](https://rust-formal-methods.github.io/tools.html),[2](https://alastairreid.github.io/automatic-rust-verification-tools-2021/)]正式验证这个算法。然而，这些工具似乎难以使用。因此，我选择了[Dafny](https://dafny.org/)。Dafny是一种语言和验证系统。它在世界各地的大学本科课程中教授，也在工业界使用。我发现它具有令人上瘾的交互性和对程序员友好的特点。
- en: 'Aside: Dafny creator, Dr. Rustan Leino has a connection to Rust beyond the
    coincidence of his first name. He helped create Spec#, the first language to use
    a type system to avoid null pointers. Rust, of course, adopted this idea to great
    success.'
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附带说明：Dafny 的创始人 Rustan Leino 博士与 Rust 的联系不仅仅是名字的巧合。他帮助创建了 Spec#，这是第一个使用类型系统来避免空指针的语言。Rust
    当然采纳了这个想法，并取得了巨大成功。
- en: This article covers rules 1 to 6\. [Part 2](https://medium.com/towards-data-science/nine-rules-to-formally-validate-rust-algorithms-with-dafny-part-2-f2a279686700)
    covers rules 7 to 9.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本文涵盖规则 1 到 6。 [第 2 部分](https://medium.com/towards-data-science/nine-rules-to-formally-validate-rust-algorithms-with-dafny-part-2-f2a279686700)
    涵盖规则 7 到 9。
- en: 'Rule 1: Don’t Learn Dafny.'
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 1：不要学习 Dafny。
- en: Before trying to prove the mathematical correctness of your algorithm, decide
    if the effort is worth the benefit.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试证明算法的数学正确性之前，决定这种努力是否值得。
- en: Dafny is not Rust. Using Dafny requires porting algorithms of interest from
    Rust to Dafny. This port can miss details and introduce errors. Given this risk,
    should *you* use Dafny to verify Rust algorithms? I boldly claim that “it depends”.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Dafny 不是 Rust。使用 Dafny 需要将感兴趣的算法从 Rust 移植到 Dafny。这种移植可能会遗漏细节并引入错误。鉴于这种风险，*你*
    是否应该使用 Dafny 来验证 Rust 算法？我大胆地声称“这要看情况”。
- en: How important is your algorithm’s correctness? If you are printing a report
    and it looks right, it probably is right. The `internal_add` algorithm relates
    to a data structure that I’d like others to use with confidence, giving me extra
    motivation to verify it.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的算法的正确性有多重要？如果你正在打印报告且它看起来正确，那么它可能确实是正确的。`internal_add` 算法涉及一个数据结构，我希望其他人能够自信地使用它，这给了我额外的动机去验证它。
- en: Maybe all formal verification, with current tools, is too hard. I believe, however,
    that Dafny makes formal verification as easy as currently possible. You will find
    formally verifying code easier if you are already familiar with types (for example,
    from Rust) and recursion/induction (used infrequently in Rust). You can read this
    article and decide for yourself if/when formal verification is easy enough to
    be valuable to you.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也许所有形式验证在当前工具下都太难了。然而，我相信 Dafny 使形式验证变得尽可能简单。如果你已经熟悉类型（例如，来自 Rust）和递归/归纳（在 Rust
    中不常用），你会发现形式验证代码更容易。你可以阅读本文并自行决定何时形式验证足够简单，值得对你有价值。
- en: Maybe fuzzing (such as `[cargo-fuzz](https://github.com/rust-fuzz/cargo-fuzz)`)
    and property-based testing (such as `[QuickCheck](https://github.com/BurntSushi/quickcheck)`)
    are good enough. Although these methods do not provide mathematical certainty,
    they are clever, useful, and easy to use. (The `range-set-blaze` crate already
    uses `QuickCheck. See` [Rule 9.5 in a previous article](https://medium.com/towards-data-science/nine-rules-for-creating-fast-safe-and-compatible-data-structures-in-rust-part-2-da5e6961a0b7)
    for details).
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也许模糊测试（例如 `[cargo-fuzz](https://github.com/rust-fuzz/cargo-fuzz)`）和基于属性的测试（例如
    `[QuickCheck](https://github.com/BurntSushi/quickcheck)`）已经足够好。虽然这些方法不能提供数学上的确定性，但它们聪明、有用且易于使用。（`range-set-blaze`
    crate 已经使用了 `QuickCheck`。有关详细信息，请参见 [之前文章中的规则 9.5](https://medium.com/towards-data-science/nine-rules-for-creating-fast-safe-and-compatible-data-structures-in-rust-part-2-da5e6961a0b7)。）
- en: Maybe formal verification is and will always be doomed because writing a specification
    is as hard as writing code. I disagree. Think about [refactoring](https://en.wikipedia.org/wiki/Code_refactoring).
    I often start coding by writing something simple. I then refactor this simple
    code for efficiency. For `internal_add`, I found the specification to be simpler
    than any code. (You can judge this for yourself in Rule 4.)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也许形式验证注定是失败的，因为编写规范和编写代码一样困难。我不同意这个观点。想一想 [重构](https://en.wikipedia.org/wiki/Code_refactoring)。我通常通过编写简单的代码来开始编程。然后，我将这些简单的代码重构以提高效率。对于
    `internal_add`，我发现规范比任何代码都要简单。（你可以在规则 4 中自行判断这一点。）
- en: 'Aside: Verification then becomes a computer-checked refactoring from a simple
    specification to a final, efficient algorithm.'
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附带说明：验证变成了从简单规范到最终高效算法的计算机检查重构。
- en: Maybe formal verification is and will always be doomed because the [halting
    problem](https://en.wikipedia.org/wiki/Halting_problem) tells us formally that
    formality isn’t generally possible. The halting problem does not doom us. While
    we can’t always understand *arbitrary* code, we don’t need to. We only need to
    understand our own code, which we (hopefully) wrote to be understandable. Starting
    in Rule 2, we’ll see how Dafny easily verifies that *specific* loops and recursions
    halt.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也许形式化验证注定是失败的，因为[停机问题](https://en.wikipedia.org/wiki/Halting_problem)正式告诉我们形式化通常是不可能的。停机问题并没有注定我们的失败。虽然我们不能总是理解*任意*代码，但我们不需要这样做。我们只需要理解我们自己的代码，而我们（希望）写的代码是易于理解的。从规则
    2 开始，我们将看到 Dafny 如何轻松验证*特定*的循环和递归是否会停止。
- en: Maybe porting to Dafny is too hard. This has not been my experience. Like Rust,
    Dafny mixes and matches imperative and functional programming. I found porting
    my algorithm to be straightforward.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也许迁移到 Dafny 太困难了。这不是我的经历。像 Rust 一样，Dafny 混合了命令式和函数式编程。我发现将我的算法迁移到 Dafny 是简单的。
- en: Assuming you still want to verify your algorithm with Dafny, your next step
    is to learn Dafny.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你仍然希望用 Dafny 验证你的算法，那么下一步是学习 Dafny。
- en: 'Step 2: Learn Dafny.'
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步骤 2：学习 Dafny。
- en: Dafny is both a programming language and an interactive verification system.
    I recommend you [install it as a VS Code extension](https://marketplace.visualstudio.com/items?itemName=dafny-lang.ide-vscode).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Dafny 是一种编程语言和交互式验证系统。我推荐你[将其作为 VS Code 扩展安装](https://marketplace.visualstudio.com/items?itemName=dafny-lang.ide-vscode)。
- en: To learn it, start at [https://dafny.org/](https://dafny.org/). Of special interest
    is the [Online Tutorial](http://dafny.org/dafny/OnlineTutorial/guide.html) and
    the [Reference Manual](https://dafny.org/latest/DafnyRef/DafnyRef). I also found
    the [Verification Corner videos](https://www.youtube.com/watch?v=oLS_y842fMc&t=823s)
    on YouTube helpful. (Of possible interest is the college textbook, *Program Proofs,*
    $49 for the Kindle Edition). I found the programming language part of Dafny easier
    to learn than Rust, perhaps similar in difficulty to C#.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要学习 Dafny，从[https://dafny.org/](https://dafny.org/)开始。特别值得关注的是[在线教程](http://dafny.org/dafny/OnlineTutorial/guide.html)和[参考手册](https://dafny.org/latest/DafnyRef/DafnyRef)。我还发现
    YouTube 上的[Verification Corner 视频](https://www.youtube.com/watch?v=oLS_y842fMc&t=823s)很有帮助。（可能感兴趣的还有大学教材《*程序证明*》，Kindle
    版售价 $49）。我发现 Dafny 的编程语言部分比 Rust 更容易学习，可能与 C# 的难度相当。
- en: 'Dafny, like Rust, is fully typed. Dafny, like Python, is garbage collected.
    Here is [a “Hello World”](https://github.com/CarlKCarlK/range-set-blaze/tree/oct23/tests/formal):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Dafny 和 Rust 一样是完全类型化的。Dafny 像 Python 一样进行垃圾回收。这里有一个[“Hello World”](https://github.com/CarlKCarlK/range-set-blaze/tree/oct23/tests/formal)示例：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Dafny, also like Python, offers integers of arbitrary size. Here is [a program](https://github.com/CarlKCarlK/range-set-blaze/tree/oct23/tests/formal)
    that *provably* adds two natural numbers by repeatedly incrementing.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Dafny，像 Python 一样，提供任意大小的整数。这里有一个[程序](https://github.com/CarlKCarlK/range-set-blaze/tree/oct23/tests/formal)，它通过重复递增来*可证明*地加两个自然数。
- en: '![](../Images/65fa551d245c131a4c8f8e31020e69a1.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/65fa551d245c131a4c8f8e31020e69a1.png)'
- en: 'Some points of interest:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一些关注点：
- en: Dafny coding guidelines follow C#, not Rust. So, we name the function `SlowAdd`
    not `slow_add` (although either will run).
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dafny 编码规范遵循 C#，而不是 Rust。因此，我们将函数命名为 `SlowAdd` 而不是 `slow_add`（尽管两者都能运行）。
- en: Dafny supports subtypes. For example, any `int` that can be shown to be non-negative
    is also a `nat`.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dafny 支持子类型。例如，任何可以证明是非负的 `int` 也是一个 `nat`。
- en: Assignment is `:=` and equality is `==` . (There is no `=` .)
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值用 `:=`，等式用 `==`。（没有 `=`。）
- en: Function parameters, for example, `x` and `y` above, are immutable.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数参数，例如上面的`x`和`y`，是不可变的。
- en: Dafny uses `ensures` and `invariant` statements to verify the code at compile-type.
    It then removes these statements to finish compiling.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dafny 使用 `ensures` 和 `invariant` 语句在编译时验证代码。然后，它会移除这些语句以完成编译。
- en: 'The green check mark shows that this code verifies. Dafny’s VS Code extension
    will, by default, continuously try to validate each method. This adds an almost
    gambling-like excitement to working with Dafny. In the example above, if I make
    `y` an `int` rather than a `nat`, then validation should and will fail. (Can you
    figure out why?) Dafny will mark my function with a red X and tell me “`This postcondition
    might not hold: r == x + y`”.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绿色的对勾标记显示这段代码已通过验证。Dafny 的 VS Code 扩展默认会持续尝试验证每个方法。这为使用 Dafny 的工作增添了几乎像赌博一样的兴奋感。在上面的例子中，如果我将`y`改为`int`而不是`nat`，那么验证应该会失败。
    （你能找出原因吗？）Dafny 会用红色 X 标记我的函数，并告诉我“`这个后置条件可能不成立：r == x + y`”。
- en: Dafny knows some of the mathematics of integers, arrays, sets, maps, sequences,
    etc. This often allows it to finish the last details of validation by itself.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dafny 了解一些整数、数组、集合、映射、序列等的数学。这通常使它能够自行完成验证的最后细节。
- en: Now that you know about Dafny, you should let it know about your algorithm.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你了解了 Dafny，你应该让它了解你的算法。
- en: 'Rule 3: Define Your Algorithm’s Basic Concepts.'
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 3：定义算法的基本概念。
- en: 'The `range-set-blaze` crate represents sets of integers as sorted, disjoint
    ranges. For example, this list of three ranges:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`range-set-blaze` crate 将整数集合表示为已排序的、不重叠的范围。例如，这个包含三个范围的列表：'
- en: '`100..=2_393, 20_303..=30_239_000, 501_000_013..=501_000_016`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`100..=2_393, 20_303..=30_239_000, 501_000_013..=501_000_016`'
- en: represents a set of 30,220,996 integers.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 表示一个包含 30,220,996 个整数的集合。
- en: In Rust, the `RangeSetBlaze` struct represents this data structure internally
    with a standard `[BTreeMap](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html).`
    Recall that a `BTreeMap` represents a list of key/value pairs, sorted by key.
    Here, our keys are the ranges’ starts (for example, `100`, `20_303`, `501_000_013`)
    and the values are the ranges’ inclusive ends (for example, `2_393`, `30_239_000,
    501_000_016`. `RangeSetBlaze` stores the list with a `BTreeMap` rather than a
    `vec` to make key look up more cache friendly.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，`RangeSetBlaze` 结构体内部用标准的 `[BTreeMap](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html)`
    表示这个数据结构。请记住，`BTreeMap` 表示按键排序的键/值对列表。在这里，我们的键是范围的起始值（例如，`100`、`20_303`、`501_000_013`），值是范围的包含结束值（例如，`2_393`、`30_239_000`、`501_000_016`）。`RangeSetBlaze`
    使用 `BTreeMap` 而非 `vec` 来存储列表，以使键查找更适合缓存。
- en: '`RangeSetBlaze` depends on `BTreeMap`, so must we implement `BTreeMap` in Dafny?
    Happily, no. We can, instead, use Dafny’s `vec`-like `seq` data type. This substitution
    works because `BTreeMap`, `vec`, and `seq` can all represent sorted lists — just
    with different efficiencies. For the purpose of formal verification, we only care
    about correctness and can ignore efficiency.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`RangeSetBlaze` 依赖于 `BTreeMap`，那么我们必须在 Dafny 中实现 `BTreeMap` 吗？幸运的是，不需要。我们可以改用
    Dafny 的类似 `vec` 的 `seq` 数据类型。这个替代方案有效，因为 `BTreeMap`、`vec` 和 `seq` 都可以表示排序列表——只是效率不同。对于形式验证的目的，我们只关心正确性，可以忽略效率。'
- en: '`RangeSetBlaze` requires the list of ranges be sorted and disjoint. How do
    we say “sorted and disjoint” in Dafny? We can say it via this [*ghost predicate*
    (and related code](https://github.com/CarlKCarlK/range-set-blaze/tree/oct23/tests/formal)):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`RangeSetBlaze` 需要范围列表是已排序且互不重叠的。我们如何在 Dafny 中表示“已排序且互不重叠”？我们可以通过这个 [*幽灵谓词*（及相关代码](https://github.com/CarlKCarlK/range-set-blaze/tree/oct23/tests/formal)
    来表示：'
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A *predicate* is another name for a method that returns `bool`. A *ghost* method
    (or predicate) is one that can only be used for validation, not for running the
    final code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*谓词* 是返回 `bool` 的方法的另一种说法。*幽灵* 方法（或谓词）是只能用于验证而不能用于运行最终代码的方法。'
- en: At a high level, the `ValidSeq` predicate takes as input a sequence of non-empty
    integer ranges. It then tests that the start values are sorted and that the ranges
    don’t touch. Specifically,
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，`ValidSeq` 谓词以非空整数范围的序列作为输入。它随后测试起始值是否排序，并且范围是否不重叠。具体来说，
- en: An `IntRange` is a tuple of two `int` values.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntRange` 是一个由两个 `int` 值组成的元组。'
- en: An `IntRange` `IsEmpty` exactly when its start is greater than its end. (This
    follows [Rust’s convention](https://doc.rust-lang.org/std/ops/struct.RangeInclusive.html).)
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当且仅当 `IntRange` 的起始值大于结束值时，它才是空的。（这遵循了 [Rust 的约定](https://doc.rust-lang.org/std/ops/struct.RangeInclusive.html)）。
- en: A `NeIntRange` (non-empty integer range) is an `IntRange` that is not empty,
    for example, `(0,0)`. [All our ranges are end inclusive.]
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NeIntRange`（非空整数范围）是一个非空的 `IntRange`，例如，`(0,0)`。 [我们所有的范围都是包含结束值的。]'
- en: 'This expression tests that the start values are sorted:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个表达式测试起始值是否已排序：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It can be read as “for all natural numbers *i* and *j* — such that *i* is less
    than *j* and *j* is less than the length of the sequence — test that the start
    value at index *i* is less than the start value as index *j*”.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以被解读为“对所有自然数 *i* 和 *j* —— 使得 *i* 小于 *j* 且 *j* 小于序列的长度 —— 测试索引 *i* 处的起始值是否小于索引
    *j* 处的起始值”。
- en: 'Aside: Note that a Rust `BTreeMap` doesn’t support (random-access) indexing
    but here we are using such indexing. This is OK because `*ValidSeq*` is a ghost
    predicate and so will only be used for validation.'
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附注：注意 Rust 的 `BTreeMap` 不支持（随机访问）索引，但这里我们使用了这种索引。这是可以的，因为 `*ValidSeq*` 是一个幽灵谓词，因此仅用于验证。
- en: 'This expression tests that the ranges are disjoint:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个表达式测试范围是否互不重叠：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It can be read as “for all natural numbers *i* and *j* — such that *i* is less
    than *j* and *j* is less than the length of the sequence — test that the range
    at index *i* does not touch the range at index *j*. But what is `Touch`?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以读作“对于所有自然数*i*和*j* — 使得*i*小于*j*且*j*小于序列的长度 — 测试索引*i*的范围是否不触及索引*j*的范围。但`Touch`是什么？
- en: 'We’ll define `Touch` on two-levels. On a mathematical level, a range *i* is
    said to touch a range *j* if there exists an integer *i0* in range *i* and an
    integer *j0* in range *j* such that *i0* and *j0* are within a distance of one
    of each other. On an efficient programming level, we want to avoid definitions
    depending on “there exists”. [Here is a Dafny predicate](https://github.com/CarlKCarlK/range-set-blaze/tree/oct23/tests/formal)
    that is both mathematical and efficient:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`Touch`定义为两个层次。在数学层面，如果范围*i*中存在整数*i0*，范围*j*中存在整数*j0*，并且*i0*和*j0*彼此距离为一，那么范围*i*被认为触及范围*j*。在高效编程层面，我们希望避免依赖“存在”的定义。[这是一个Dafny谓词](https://github.com/CarlKCarlK/range-set-blaze/tree/oct23/tests/formal)，它既符合数学定义又高效：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Some points of interest:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一些关注点：
- en: '`Touch` is not a ghost. In other words, we can use it in both regular code
    and validation code.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Touch`不是幽灵。换句话说，我们可以在常规代码和验证代码中使用它。'
- en: The `assert` statements help Dafny prove that the regular code meets the mathematical
    `ensures` statement.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert`语句帮助Dafny证明常规代码符合数学`ensures`语句。'
- en: For efficiency, the Dafny prover validates the inside of a `method` separately
    from its outside. Only the `ensures` (and the yet-to-be-seen, `requires`) statements
    cross this border. In contrast to a `method`, a Dafny `function` is transparent
    to the validator. (I think of it as inlining code with respect to validation.)
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了提高效率，Dafny证明器分别验证`method`的内部和外部。只有`ensures`（以及尚未出现的`requires`）语句跨越这个边界。与`method`不同，Dafny`function`对验证器是透明的。（我认为它类似于在验证方面内联代码。）
- en: With concepts such as `ValidSeq` and `Touch` defined, we next move onto specifying
    what our algorithm is supposed to do.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了`ValidSeq`和`Touch`等概念后，我们接下来要指定我们的算法应该做什么。
- en: 'Rule 4: Specify Your Algorithm.'
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则4：指定你的算法。
- en: Ultimately, I want to prove that my specific Rust algorithm for inserting a
    new range into a `RangeSetBlaze` is correct. Before we do that, however, let’s
    define [what “correct” range insertion is](https://github.com/CarlKCarlK/range-set-blaze/tree/oct23/tests/formal).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我希望证明我的Rust算法在将新范围插入`RangeSetBlaze`中是正确的。然而，在此之前，我们先定义一下[什么是“正确”的范围插入](https://github.com/CarlKCarlK/range-set-blaze/tree/oct23/tests/formal)。
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This says that `InternalAdd` is a method that takes `xs`, a sequence of non-empty
    integer ranges, and `a`, an integer range (that could be empty). The method outputs
    `rs`, a new sequence of non-empty integer ranges.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示`InternalAdd`是一个方法，它接受`xs`，一个非空整数范围序列，以及`a`，一个整数范围（可能为空）。该方法输出`rs`，一个新的非空整数范围序列。
- en: We need to say that `xs` and `rs` must be sorted and disjoint. That is easily
    done with the `ValidSeq`’s in the `requires` and first `ensures`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要说明`xs`和`rs`必须是已排序且不重叠的。这可以通过`ValidSeq`在`requires`和第一个`ensures`中轻松完成。
- en: We also need to say that `rs` contains the right stuff. Is this hard? It is
    not. We just say that the set of integers in `rs` must equal the set of integers
    in `xs` unioned with the integers in `a`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要说明`rs`包含了正确的内容。这难吗？其实不难。我们只需说明`rs`中的整数集合必须等于`xs`中的整数集合并与`a`中的整数集合并集。
- en: 'Aside: In Dafny, “+” when applied to sets is “union”.'
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 旁注：在Dafny中，“+”应用于集合时表示“并集”。
- en: 'The set of integers in a range is:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一个范围中的整数集合是：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And the set of integers in a sequence of non-empty ranges can be define inductively
    (that is, recursively):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 非空范围序列中的整数集合可以递归定义（即递归）：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Some points of interest:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一些关注点：
- en: 'The line: `assume false; // cheat for now` [makes validation work even if it
    really shouldn’t](https://www.oxfordreference.com/display/10.1093/oi/authority.20110803095804354).
    We use it as a temporary placeholder.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这行代码：`assume false; // cheat for now` [使验证即使在实际上不应该工作时也能工作](https://www.oxfordreference.com/display/10.1093/oi/authority.20110803095804354)。我们将其用作临时占位符。
- en: We make `RangeToSet` and `SeqToSet` *ghosts* to stop us from using them in regular
    code. We make them *functions* (instead of *methods*)to inline them with respect
    to validation.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`RangeToSet`和`SeqToSet`设为*幽灵*，以防止我们在常规代码中使用它们。我们将它们设为*函数*（而不是*方法*），以便在验证时内联它们。
- en: Because Dafny knows a lot about creating and manipulating sets and sequences,
    we often profit by using sets and sequences in our specification.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为 Dafny 对创建和操作集合和序列了解颇多，我们经常通过在规格说明中使用集合和序列获益。
- en: Even if our regular code uses loops instead of recursion, our validation code
    will often use recursive-like induction.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使我们常规代码使用循环而不是递归，我们的验证代码通常会使用递归类似的归纳法。
- en: The `{:autotriggers false}` relates to avoiding a warning message. For more
    information see this [Stack Overflow answer](https://stackoverflow.com/a/50671326/5976009)
    by Prof. James Wilcox.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{:autotriggers false}` 相关于避免警告信息。更多信息请参见 Prof. James Wilcox 的[这个 Stack Overflow
    回答](https://stackoverflow.com/a/50671326/5976009)。'
- en: We now have a formal specification of `InternalAdd`. I find this specification
    short and intuitive. But what if you need help figuring out a specification or
    other Dafny code?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了 `InternalAdd` 的正式规格说明。我发现这个规格简短且直观。但如果你需要帮助理解规格说明或其他 Dafny 代码呢？
- en: 'Rule 5: Get help from the Dafny Community.'
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 5：寻求 Dafny 社区的帮助。
- en: The main forum for Dafny questions is [Stack Overflow](https://stackoverflow.com/).
    To my surprise, I actually received much useful help there.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Dafny 问题的主要论坛是 [Stack Overflow](https://stackoverflow.com/)。令我惊讶的是，我在这里实际获得了许多有用的帮助。
- en: I recommend starting your question’s title with “Dafny:”. Also, be sure to tag
    your question with `dafny` and, perhaps, `formal-verification`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议在问题标题前加上“Dafny:”。同时，确保为你的问题添加 `dafny` 标签，可能还要加上 `formal-verification` 标签。
- en: 'Aside: On the site, you can see [my 11 questions](https://stackoverflow.com/users/5976009/carl?tab=questions&sort=newest)
    and [Divyanshu Ranjan’s 48 Dafny-related answers](https://stackoverflow.com/search?q=user%3A14413069+%5Bdafny%5D).'
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附带说明：在网站上，你可以看到[我的 11 个问题](https://stackoverflow.com/users/5976009/carl?tab=questions&sort=newest)和[Divyanshu
    Ranjan 的 48 个与 Dafny 相关的回答](https://stackoverflow.com/search?q=user%3A14413069+%5Bdafny%5D)。
- en: As an open-source project on GitHub, [Dafny](https://github.com/dafny-lang)
    also hosts GitHub Discussions and Issues.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个在 GitHub 上的开源项目，[Dafny](https://github.com/dafny-lang) 也托管了 GitHub Discussions
    和 Issues。
- en: The Dafny community is small but seems enthusiastic about helping users and
    improving the project.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Dafny 社区虽然小，但似乎热衷于帮助用户和改进项目。
- en: With help at hand, we must next find an algorithm that meets the specification.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在有帮助的情况下，我们接下来必须找到一个符合规格的算法。
- en: 'Rule 6: Validate a Different, Easier, Algorithm.'
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 6：验证一个不同、更简单的算法。
- en: 'As a novice to formal verification, I decided to postpone work on the real
    `internal_add` used in my Rust code. Instead, I started work on an `InternalAdd`
    algorithm that I hoped would be easier to validate. I ended up with [this](https://github.com/CarlKCarlK/range-set-blaze/tree/oct23/tests/formal):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 作为正式验证的初学者，我决定推迟对我 Rust 代码中实际 `internal_add` 的工作。相反，我开始着手开发一个我希望更容易验证的 `InternalAdd`
    算法。最后，我得到的是[这个](https://github.com/CarlKCarlK/range-set-blaze/tree/oct23/tests/formal)：
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The idea is that if range `a` is empty, we return the input sequence unchanged.
    Otherwise, we divide the work into three steps, which we can validate independently.
    The first step, `PartitionAndMerge,` returns:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是，如果范围 `a` 为空，我们返回未更改的输入序列。否则，我们将工作分成三个步骤，我们可以独立验证。第一步，`PartitionAndMerge,`
    返回：
- en: '`notTouching`, a sequence of ranges that don’t touch range `a`, and'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notTouching` 是一个不触及范围 `a` 的范围序列，且'
- en: '`merged`, a single range created from `a` and everything it touches.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`merged` 是由 `a` 及其触及到的所有内容创建的单一范围。'
- en: 'Here is an example input and output:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例输入和输出：
- en: '![](../Images/6d57b46a89432c5cb675479012d53208.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6d57b46a89432c5cb675479012d53208.png)'
- en: '`InternalAdd` next finds where to insert `merged` and, finally, inserts it.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`InternalAdd` 接着寻找插入 `merged` 的位置，并最终插入它。'
- en: Here is the [code for](https://github.com/CarlKCarlK/range-set-blaze/tree/oct23/tests/formal)
    `[PartitionAndMerge](https://github.com/CarlKCarlK/range-set-blaze/tree/oct23/tests/formal):`
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是[代码](https://github.com/CarlKCarlK/range-set-blaze/tree/oct23/tests/formal)
    `[PartitionAndMerge](https://github.com/CarlKCarlK/range-set-blaze/tree/oct23/tests/formal)：`
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This says that `PartitionAndMerge` `requires` that `xs` be a valid sequence
    of non-empty integer ranges and that `a` be a non-empty integer range. It ensures
    that `nonTouching` is another valid sequence of non-empty integer ranges. It ensures
    that the integers in range `merged` are a superset of those in range `a`. It ensures
    that no range in `notTouching` touches range `merged`. And finally, it ensures
    that the integers in `xs` and `a` are exactly the same as the integers in `notTouching`
    and `merged`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明 `PartitionAndMerge` `要求` `xs` 是一个有效的非空整数范围序列，并且 `a` 是一个非空整数范围。它确保 `nonTouching`
    是另一个有效的非空整数范围序列。它确保 `merged` 范围中的整数是 `a` 范围中整数的超集。它确保 `notTouching` 中的任何范围都不接触
    `merged` 范围。最后，它确保 `xs` 和 `a` 中的整数与 `notTouching` 和 `merged` 中的整数完全相同。
- en: '`PartitionAndMerge` also divides the work, this time into two steps (`Partition`
    and `UnionSeq`) that can be validated independently. Those steps continue to subdivide
    their work. Where does it end? Let’s look at one example.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`PartitionAndMerge` 还将工作分为两个步骤（`Partition` 和 `UnionSeq`），这两个步骤可以独立验证。这些步骤继续将工作细分。它在哪里结束？让我们看一个例子。'
- en: 'The method `UnionSeq` calls `[UnionRange](https://github.com/CarlKCarlK/range-set-blaze/tree/oct23/tests/formal)`
    which merges two ranges:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `UnionSeq` 调用 `[UnionRange](https://github.com/CarlKCarlK/range-set-blaze/tree/oct23/tests/formal)`
    来合并两个范围：
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `UnionRange` code handles the empty cases and then returns the minimum
    bounding range. (The minimum bounding range is the range from the smaller of the
    two starts to the larger of the two ends.) But how can this be correct? In general,
    a minimum bounding range of two ranges might include extra integers. We might
    get something bigger than the union of the inputs, like so:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`UnionRange` 代码处理了空情况，然后返回最小的包围范围。（最小的包围范围是从两个开始中较小的那个到两个结束中较大的那个。）但这怎么可能正确呢？一般来说，两个范围的最小包围范围可能包含额外的整数。我们可能会得到比输入的并集更大的范围，如下所示：'
- en: '![](../Images/f643b34856c60798dac71de4a6a99ad7.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f643b34856c60798dac71de4a6a99ad7.png)'
- en: The code is correct because it `requires` that the two input ranges touch or
    are empty. This `ensures` that the union of the integers in range `x` with the
    integers in range `y` are exactly the integers in the output range.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是正确的，因为它`要求`两个输入范围相接触或为空。这`确保`了范围 `x` 中的整数与范围 `y` 中的整数的并集正好是输出范围中的整数。
- en: At compile time, Dafny proves this function correct. Beyond that, it proves
    that everything that calls this function provides inputs that are empty or touching.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译时，Dafny 证明了这个函数是正确的。除此之外，它证明了所有调用这个函数的地方都提供了空或相接触的输入。
- en: I think of this as a generalization of Rust’s borrow checker. At compile-time
    Rust checks that we are safe from many memory errors. At compile time, verification
    systems, such as Dafny, can prove almost arbitrary properties. Of course, as we
    are seeing, this ability comes at the cost of complexity.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这可以看作是 Rust 借用检查器的一个概括。在编译时，Rust 检查我们是否安全，避免了许多内存错误。在编译时，验证系统，如 Dafny，可以证明几乎任意的属性。当然，正如我们所见，这种能力是以复杂性为代价的。
- en: '[The full code for this verified algorithm](https://github.com/CarlKCarlK/range-set-blaze/blob/oct23/tests/formal/Rule6.dfy)
    is about 200 lines, organized into about a dozen methods and functions.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[这个经过验证的算法的完整代码](https://github.com/CarlKCarlK/range-set-blaze/blob/oct23/tests/formal/Rule6.dfy)大约有200行，分成大约十几个方法和函数。'
- en: This rule shows that we can verify *an* algorithm for `InternalAdd`, but it
    is not the algorithm I used in Rust. We will turn to that next.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则显示了我们可以验证*一个* `InternalAdd` 算法，但这不是我在 Rust 中使用的算法。我们将接下来讨论那个算法。
- en: '**Those are the first six rules for validating Rust algorithms with Dafny.
    See** [**Part 2**](/nine-rules-to-formally-validate-rust-algorithms-with-dafny-part-2-f2a279686700)
    **for rules 7 to 9.**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**这些是使用 Dafny 验证 Rust 算法的前六条规则。请参阅** [**第2部分**](/nine-rules-to-formally-validate-rust-algorithms-with-dafny-part-2-f2a279686700)
    **获取规则7到9。**'
- en: '*Please* [*follow Carl on Medium*](https://medium.com/@carlmkadie)*. I write
    on scientific programming in Rust and Python, machine learning, and statistics.
    I tend to write about one article per month.*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*请* [*关注 Carl 的 Medium 账号*](https://medium.com/@carlmkadie)*。我撰写关于 Rust 和 Python
    的科学编程、机器学习和统计学的文章。我通常每月写一篇文章。*'
- en: '*Read more of Divyanshu Ranjan’s work on* [*his blog*](https://rdivyanshu.github.io/)*.
    In addition to formal methods, the blog touches on geometry, statistics, and more.*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*阅读 Divyanshu Ranjan 的更多工作，访问* [*他的博客*](https://rdivyanshu.github.io/)*。除了形式化方法，博客还涉及几何学、统计学等内容。*'
