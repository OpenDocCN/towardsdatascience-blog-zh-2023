- en: Learn RabbitMQ for Event-Driven Architecture (EDA)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习 RabbitMQ 用于事件驱动架构（EDA）
- en: 原文：[https://towardsdatascience.com/learn-rabbitmq-for-event-driven-architecture-eda-e1e7377db2b](https://towardsdatascience.com/learn-rabbitmq-for-event-driven-architecture-eda-e1e7377db2b)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/learn-rabbitmq-for-event-driven-architecture-eda-e1e7377db2b](https://towardsdatascience.com/learn-rabbitmq-for-event-driven-architecture-eda-e1e7377db2b)
- en: A beginner-friendly tutorial on how RabbitMQ works and how to use RabbitMQ in
    Go, the first steps in learning EDA
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一份适合初学者的教程，介绍 RabbitMQ 的工作原理以及如何在 Go 中使用 RabbitMQ，这是学习 EDA 的第一步。
- en: '[](https://programmingpercy.medium.com/?source=post_page-----e1e7377db2b--------------------------------)[![Percy
    Bolmér](../Images/34949a468cbbb5c609807903775afddb.png)](https://programmingpercy.medium.com/?source=post_page-----e1e7377db2b--------------------------------)[](https://towardsdatascience.com/?source=post_page-----e1e7377db2b--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----e1e7377db2b--------------------------------)
    [Percy Bolmér](https://programmingpercy.medium.com/?source=post_page-----e1e7377db2b--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://programmingpercy.medium.com/?source=post_page-----e1e7377db2b--------------------------------)[![Percy
    Bolmér](../Images/34949a468cbbb5c609807903775afddb.png)](https://programmingpercy.medium.com/?source=post_page-----e1e7377db2b--------------------------------)[](https://towardsdatascience.com/?source=post_page-----e1e7377db2b--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----e1e7377db2b--------------------------------)
    [Percy Bolmér](https://programmingpercy.medium.com/?source=post_page-----e1e7377db2b--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----e1e7377db2b--------------------------------)
    ·39 min read·Apr 5, 2023
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·发表于 [Towards Data Science](https://towardsdatascience.com/?source=post_page-----e1e7377db2b--------------------------------)
    ·阅读时长39分钟·2023年4月5日
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/4e653e64d73dd82ca8b9ea9f8cdbc21e.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4e653e64d73dd82ca8b9ea9f8cdbc21e.png)'
- en: Photo by [Bradyn Trollip](https://unsplash.com/es/@bradyn?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 照片由 [Bradyn Trollip](https://unsplash.com/es/@bradyn?utm_source=medium&utm_medium=referral)
    提供，来自 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: Event-Driven architecture (EDA) is one of my favorite things in programming.
    This architecture allows us to build microservices and easily share information
    between them.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动架构（EDA）是我在编程中最喜欢的东西之一。这种架构允许我们构建微服务并轻松地在它们之间共享信息。
- en: In regular sequential software, you would have a function trigger another function
    or a recurring script that checks for certain things to do.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在常规的顺序软件中，你会有一个函数触发另一个函数，或者一个定期脚本来检查某些任务。
- en: With Event-Driven architecture, we instead leverage a Queue or a Pub/Sub schema.
    Allowing different services to notify or send information between them to trigger
    code to execute.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件驱动架构中，我们利用队列或发布/订阅模式。允许不同的服务之间通知或传送信息，以触发代码执行。
- en: Event-Driven Architecture is often used to build software that is highly flexible
    and extensible. This is a result of being able to easily add functionality or
    remove by simply listening to events with a new service.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动架构通常用于构建高度灵活和可扩展的软件。这是因为可以通过简单地监听事件来轻松添加或移除功能。
- en: It also makes it very easy to shadow deploy and test new services in parallel
    with production, since you can make the new service react to the same events without
    interfering with the running system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得影子部署和测试新服务与生产环境并行变得非常容易，因为你可以让新服务对相同事件做出反应，而不会干扰正在运行的系统。
- en: It is not all sunshine and roses however, some consider EDA systems to be a
    little bit more complex, and sometimes harder to test when considering the full
    flow of services. I’d say the testing is easier since we can easily trigger an
    event and see how the related services react, or a single service. But without
    proper documentation of the architecture, it can also be hard to understand what
    triggers what and why.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有的情况都是一帆风顺的，一些人认为事件驱动架构（EDA）系统可能略显复杂，而且在考虑到完整的服务流程时，测试有时会更困难。我认为测试其实更简单，因为我们可以轻松触发事件并查看相关服务或单个服务的反应。但如果没有适当的架构文档，也可能很难理解是什么触发了什么以及原因。
- en: This tutorial will look at how you can use RabbitMQ to build two microservices
    that communicate using events. We will look at different paradigms used in RabbitMQ,
    and while we will learn how to use RabbitMQ in Go, we will mostly focus on learning
    the concepts of RabbitMQ. Covering some common mistakes and a few best practices
    to follow.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程将探讨如何使用RabbitMQ构建两个通过事件进行通信的微服务。我们将研究RabbitMQ中使用的不同范式，虽然我们将学习如何在Go中使用RabbitMQ，但我们主要集中于学习RabbitMQ的概念。涵盖一些常见错误和一些最佳实践。
- en: RabbitMQ supports multiple protocols to send data, but in this tutorial, we
    will focus on using **AMQP**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ支持多种协议来发送数据，但在本教程中，我们将专注于使用**AMQP**。
- en: Over the course of this tutorial, we will learn the following
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习以下内容
- en: Setup RabbitMQ using Docker
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker设置RabbitMQ
- en: Virtual Hosts, users, and permissions
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟主机、用户和权限
- en: Managing RabbitmQ using CLI with [rabbitmqctl](https://www.rabbitmq.com/rabbitmqctl.8.html)
    and [rabbitmqadmin](https://www.rabbitmq.com/management-cli.html)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CLI管理RabbitMQ，通过[rabbitmqctl](https://www.rabbitmq.com/rabbitmqctl.8.html)和[rabbitmqadmin](https://www.rabbitmq.com/management-cli.html)
- en: Learn about Producers, Consumers and how to write them.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解生产者、消费者以及如何编写它们。
- en: Learn about Queues, Exchanges, and Binding
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解队列、交换机和绑定
- en: Using Work Queues (first in and first out)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工作队列（先进先出）
- en: Using Pub/Sub with RabbitMQ
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RabbitMQ进行发布/订阅
- en: Using RPC-based patterns and callbacks.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于RPC的模式和回调。
- en: Encrypting traffic with TLS
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用TLS加密流量
- en: Using Configurations to declare resources in RabbitMQ
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用配置来声明RabbitMQ中的资源
- en: A video recording of this tutorial for those who prefer Video.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 该教程的视频录制，适合喜欢视频的人。
- en: All code used in this article can be found [here](https://github.com/percybolmer/event-driven-rabbitmq).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本文中使用的所有代码可以在[这里](https://github.com/percybolmer/event-driven-rabbitmq)找到。
- en: Installing RabbitMQ —Setup User & Virtual host & Permissions
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装RabbitMQ — 设置用户、虚拟主机和权限
- en: Getting RabbitMQ up and running can be done by following the examples at [Downloading
    And Installing](https://www.rabbitmq.com/download.html). I’d recommend following
    that guide when going into production, but for this tutorial and to experiment
    we can use an easier approach.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使RabbitMQ运行可以通过[下载和安装](https://www.rabbitmq.com/download.html)中的示例完成。我建议在生产环境中遵循该指南，但为了本教程和实验，我们可以使用更简单的方法。
- en: As always, the easiest way is to run a Docker!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，最简单的方法是运行Docker！
- en: This command will download the latest RabbitMQ and start it as a background
    process, exposing ports **5672** and **15672**.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将下载最新的RabbitMQ并将其作为后台进程启动，暴露端口**5672**和**15672**。
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Port 5672** is to enable AMQP connections. [AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol)
    is the networking protocol used by RabbitMQ and many other Message brokers.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**端口 5672** 用于启用AMQP连接。[AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol)
    是RabbitMQ和许多其他消息中间件使用的网络协议。'
- en: '**Port 15672** is opened because the Admin UI And management UI are hosted
    on that port, also the API to manage RabbitMQ is on that port.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**端口 15672** 被开启，因为管理UI和管理界面托管在该端口，管理RabbitMQ的API也在该端口上。'
- en: For more details on the ports, you can refer to the [networking](https://www.rabbitmq.com/networking.html)
    guide of RabbitMQ.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有关端口的更多细节，请参阅RabbitMQ的[网络](https://www.rabbitmq.com/networking.html)指南。
- en: Once the docker is started, let's begin by visiting the Management UI hosted
    at [localhost:15672](http://localhost:15672/).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Docker启动，让我们开始访问托管在[localhost:15672](http://localhost:15672/)上的管理UI。
- en: '![](../Images/fa1e17aca41710048e248924e3550620.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/fa1e17aca41710048e248924e3550620.png)'
- en: RabbitMQ Management UI — Image by Percy Bolmer
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ管理UI — 图片由Percy Bolmer提供
- en: Whops, we need a User! Let’s create one using [RabbitMQCLI](https://www.rabbitmq.com/man/rabbitmqctl.8.html#).
    Don’t worry about installing it, it is present in the Docker Container we ran.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，我们需要一个用户！让我们使用[RabbitMQCLI](https://www.rabbitmq.com/man/rabbitmqctl.8.html#)创建一个。别担心安装问题，它已经存在于我们运行的Docker容器中。
- en: We can create a new user with the command `add_user` followed by the username
    and password. We use `docker exec rabbitmq` to execute the command inside the
    docker, replace `rabbitmq` with the name you have given the docker container.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用命令`add_user`来创建新用户，后跟用户名和密码。我们使用`docker exec rabbitmq`在docker内部执行命令，将`rabbitmq`替换为你为docker容器指定的名称。
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: I recommend giving Admin access during the exploration as well. We can do this
    by adding an administrator tag to the new user.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议在探索期间也授予管理员权限。我们可以通过给新用户添加管理员标签来实现这一点。
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Oh, one last thing, there is a `guest` user by default, I strongly recommend
    removing this user! This user is only available to users using localhost, but
    still better safe than sorry.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，最后一件事，默认情况下有一个 `guest` 用户，我强烈建议删除此用户！此用户仅对使用本地主机的用户可用，但还是安全起见比较好。
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: That’s it, back to the Management UI and log in.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，回到管理 UI 并登录。
- en: Once logged in you will see a rather old-looking UI, but it is great because
    we can really monitor RabbitMQ from here, and see what is going on. We will not
    play around with the UI yet, we need a service that actually connects and sends
    data first.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后你会看到一个看起来相当老旧的用户界面，但这非常好，因为我们可以真正从这里监控 RabbitMQ，并查看发生了什么。我们还不会玩弄这个界面，我们需要先有一个实际连接并发送数据的服务。
- en: '![](../Images/fa729b79b78b778f1fd5d9900932f8b0.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/fa729b79b78b778f1fd5d9900932f8b0.png)'
- en: Management UI displaying the running Instance metrics — Image by Percy Bolmer
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 管理 UI 显示正在运行的实例指标 — 图片由 Percy Bolmer 提供
- en: Before we start hacking, we need to fix two more things.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始操作之前，我们需要再修复两个问题。
- en: Resources in RabbitMQ, such as Queues and other things we will learn more about
    soon are separated by a logical layer, this logical layer is called a Virtual
    Host (Vhost).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ 中的资源，如队列以及我们将很快学习的其他内容，按照逻辑层进行分隔，这个逻辑层称为虚拟主机（Vhost）。
- en: The easiest way to explain Virtual Hosts would be, but probably wrong in some
    ways, to compare it to a Namespace.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 解释虚拟主机最简单的方法可能是将其与命名空间进行比较，但这可能在某些方面不完全正确。
- en: We can use these vhosts to group certain resources together and restrict access
    by adding the users who are allowed to use the vhost.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些虚拟主机将某些资源分组在一起，并通过添加允许使用虚拟主机的用户来限制访问。
- en: Let’s begin by creating the vhost using the `add_vhost` command, it accepts
    a single input which is the name of the vhost.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用 `add_vhost` 命令创建虚拟主机，它接受一个输入，即虚拟主机的名称。
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that we have a vhost, we can add permissions to the user we created earlier
    so that it is allowed to connect.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个虚拟主机，我们可以为之前创建的用户添加权限，以便它可以连接。
- en: Adding permissions is done with `set_permissions` command, we use the `-p` flag
    to specify the vhost to add permissions on. The next item in the syntax is the
    user to add permissions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 添加权限是通过 `set_permissions` 命令完成的，我们使用 `-p` 标志来指定要添加权限的虚拟主机。语法中的下一个项是要添加权限的用户。
- en: The last part of the command is the scary part, it's a regexp that defines what
    permission to add, an example to add all permissions could look like, or permissions
    on all resources beginning with `customer-` would be `"^customer-*"`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的最后部分是令人害怕的部分，它是一个定义要添加权限的正则表达式，添加所有权限的示例如下，或者对所有以 `customer-` 开头的资源的权限为 `"^customer-*"`.
- en: There will be 3 regexp slots, in order, it configures the permissions for the
    following.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 会有 3 个正则表达式槽位，按顺序配置以下权限。
- en: '**Conf** — Permission to configure resources matching regexp'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置** — 对匹配正则表达式的资源的配置权限'
- en: '**Write** — Permission to write on resources matching regexp'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**写** — 对匹配正则表达式的资源的写权限'
- en: '**Read** — Permission to read on resources matching regexp'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读取** — 对匹配正则表达式的资源的读取权限'
- en: The full command to add full access to configure, write, and read on the customer
    vhost for my user `percy` would look like this. Note that I give access to `.*`
    which is everything.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为我的用户 `percy` 添加对 customer 虚拟主机的全面配置、写入和读取权限的完整命令如下。注意，我给予了 `.*` 的访问权限，即所有权限。
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After creating this, you should see the new vhost in the top right corner of
    the management UI.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完成后，你应该能在管理 UI 的右上角看到新的虚拟主机。
- en: '![](../Images/b41f62732624137163942d85b40401e7.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b41f62732624137163942d85b40401e7.png)'
- en: Selecting the new virtual host. — Image by Percy Bolmer
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 选择新的虚拟主机。 — 图片由 Percy Bolmer 提供
- en: Basics Of RabbitMQ — Producers, Consumers, Exchanges, and Queues
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RabbitMQ 基础知识 — 生产者、消费者、交换机和队列
- en: '![](../Images/1d186c50fdf4e89cd994e08072fbf8c0.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1d186c50fdf4e89cd994e08072fbf8c0.png)'
- en: Showing how Producers, Exchanges, Queues, and Consumers work together — Image
    by Percy Bolmer
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 展示生产者、交换机、队列和消费者如何协同工作 — 图片由 Percy Bolmer 提供
- en: When we are building an Event-Driven architecture there are some terms we need
    to understand.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建事件驱动架构时，有一些术语需要理解。
- en: '**Producer** — Any software that is Sending Messages.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产者** — 任何发送消息的软件。'
- en: '**Consumer** — Any software that is Receiving Messages.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消费者** — 任何接收消息的软件。'
- en: '**Queue** — An Queue accepts a Message, outputs the message, think of it like
    a large Buffer. Queues are FIFO (First in First Out) meaning that messages are
    outputted in the order they are inserted into the queue.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**队列** — 一个队列接受一个消息，输出这个消息，可以将其视为一个大型缓冲区。队列是 FIFO（先进先出）的，这意味着消息按插入队列的顺序输出。'
- en: '**Exchange** — An Router, is the place where Producers send messages. The exchange
    accepts messages and sends them to the correct Queues depending on the type of
    Exchange and the Bindings (Rules) Applied.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交换机** — 一种路由器，是生产者发送消息的地方。交换机接受消息，并根据交换机的类型和应用的绑定（规则）将其发送到正确的队列。'
- en: The general idea is that we can use this to send and receive messages between
    Services. It is worth mentioning the Producers and the Consumers do not have to
    be on running on the same Host, allowing this to scale very well.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，我们可以使用这个来在服务之间发送和接收消息。值得一提的是，生产者和消费者不需要在同一主机上运行，这使得系统具有很好的扩展性。
- en: Begin by creating a new project with Go, If you don't have Go Installed, please
    install it from [here](https://go.dev/dl/).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个新的 Go 项目，如果你还没有安装 Go，请从[这里](https://go.dev/dl/)进行安装。
- en: In a real go Project setup I would probably use Cobra, but to avoid new users
    from being confused I will simply create two main packages.
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在实际的 Go 项目设置中，我可能会使用 Cobra，但为了避免新用户感到困惑，我将简单地创建两个主要包。
- en: Let’s build a Producer in Go that can start sending messages on a Queue.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Go 中构建一个生产者，能够开始在队列上发送消息。
- en: Begin by creating a new project for the producer and get the AMQP library that
    is officially maintained by the RabbitMQ team.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 开始为生产者创建一个新的项目，并获取由 RabbitMQ 团队官方维护的 AMQP 库。
- en: The project will have a `cmd` folder that will hold all the different services,
    each being its own runnable.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目将有一个`cmd`文件夹，包含所有不同的服务，每个服务都是一个独立的可运行程序。
- en: We will also have a `internal` folder that is used to store shared libraries
    etc.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将有一个`internal`文件夹，用于存储共享库等。
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Your folder structure should look like the following.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你的文件夹结构应该如下所示。
- en: '![](../Images/d56f2c2dba053362e913ddd9601c1c70.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d56f2c2dba053362e913ddd9601c1c70.png)'
- en: cmd folder and internal folder prepared — Image by Percy Bolmer
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmd`文件夹和`internal`文件夹已准备好 — 图片来自 Percy Bolmer'
- en: Let’s add a connection to the RabbitMQ instance first inside `internal/rabbitmq.go`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先在`internal/rabbitmq.go`中添加一个与 RabbitMQ 实例的连接。
- en: We will create a small helper function that will connect to RabbitMQ using the
    `amqp` protocol. We will allow users to specify the credentials and host, also
    the vhost to connect to.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个小的助手函数，用于通过`amqp`协议连接到 RabbitMQ。我们将允许用户指定凭证、主机以及要连接的 vhost。
- en: I will simply return pointers to the connection, which is the network connection,
    and `amqp.Channel` which is used to concurrently send messages. Leaving it up
    to the users to manage the connection.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我将简单地返回指向连接的指针，即网络连接和用于并发发送消息的`amqp.Channel`。将连接的管理留给用户。
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A really good rule of thumb is to reuse a single Connection across the whole
    application and spawn new Channels for concurrent tasks. The reason for this is
    that a Connection is a TCP connection, while a channel is a multiplexed connection
    in the assigned TCP Connection. Following that rule of thumb allows for a much
    more scalable solution.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的经验法则是，在整个应用程序中重用一个连接，并为并发任务创建新的通道。原因是连接是 TCP 连接，而通道是在分配的 TCP 连接中的多路复用连接。遵循这个经验法则可以实现更具可扩展性的解决方案。
- en: Let’s import this simple client into the `cmd/producer/main.go` and try connecting
    to see what happens.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个简单的客户端导入到`cmd/producer/main.go`中并尝试连接，看看会发生什么。
- en: For now, we will simply connect and sleep for 30 seconds before closing the
    connection.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将简单地连接并在关闭连接前休眠 30 秒。
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Once we have that in place, run the producer.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成这些设置，就运行生产者。
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Once that is running, navigate back to the management UI and see that we can
    actually see there is now 1 Connection and 1 Channel.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行，返回管理 UI 并查看我们是否可以看到现在有一个连接和一个通道。
- en: '![](../Images/0b425b3b04b7c48200a4bc00a617274d.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0b425b3b04b7c48200a4bc00a617274d.png)'
- en: We have a Connection and 1 Channel now instead of 0 — Image by Percy Bolmer
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个连接和一个通道，而不是零个 — 图片来自 Percy Bolmer
- en: Channels are a really smart way of handling the TCP layer, you can read more
    about it in the [docs](https://www.rabbitmq.com/channels.html). It allows users
    to reuse an open TCP connection with multiple Channels, instead of opening many
    TCP connections. It's a multiplexing technique.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通道是一种非常聪明的处理 TCP 层的方法，你可以在[文档](https://www.rabbitmq.com/channels.html)中阅读更多内容。它允许用户在多个通道之间重用一个打开的
    TCP 连接，而不是打开多个 TCP 连接。这是一种复用技术。
- en: It’s time to start sending data, this is done on said Channel. There is more
    to a channel than one can probably think, it's not just a dumb pipeline, there
    are some nifty options that can be configured when creating them.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是开始发送数据的时候了，这是在上述通道上完成的。通道的功能远超过你可能想象的，它不仅仅是一个简单的管道，还可以在创建时配置一些巧妙的选项。
- en: We can create Queues from the UI, but I like creating them in the Code when
    Testing things out. In a production environment, I like having a configuration
    file to declare some basic setup, we will look into that later.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从 UI 创建队列，但我喜欢在测试时通过代码创建队列。在生产环境中，我喜欢使用配置文件来声明一些基本设置，我们稍后会讨论这个问题。
- en: We can create a Queue by Calling the `amqp.QueueDeclare`, this function has
    many input parameters that we need to understand to get the wanted behavior of
    the Queue. The signature looks like this.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用 `amqp.QueueDeclare` 来创建队列，这个函数有许多输入参数，我们需要理解这些参数以获得想要的队列行为。函数签名如下所示。
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Name** — The name used to reference the Queue. This can be empty, in that
    case, the server will generate a name.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称** — 用于引用队列的名称。此项可以为空，在这种情况下，服务器将生成一个名称。'
- en: '**Durable** — If the Queue should be persisted across Broker restarts (RabbitMQ
    restart)'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久化** — 如果队列在 Broker 重启（RabbitMQ 重启）时应该被保留'
- en: '**AutoDelete** — If the Queue should be automatically deleted when the last
    Consumer leaves'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动删除** — 如果队列在最后一个消费者离开时应自动删除'
- en: '**Exclusive** — Only available for the same Connection that created the Queue.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独占** — 仅适用于创建队列的相同连接。'
- en: '**NoWait** — Assumes the Queue is created on the Server'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无等待** — 假定队列在服务器上创建'
- en: '**Arguments** — An option to provide user-provided arguments.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数** — 提供用户提供的参数的选项。'
- en: To make this a little easier, I will create a wrapper function that accepts
    the `name`, `durable` and `autodelete` parameters. I will leave the others disabled
    by default.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这件事更简单，我会创建一个接受 `name`、`durable` 和 `autodelete` 参数的包装函数。我将默认禁用其他参数。
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let’s update the `producer/main.go` to execute the new CreateQueue function,
    I will create a durable queue since I want the Queue handling new customers to
    be kept alive and persistent, I will also make auto delete set to `false`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新 `producer/main.go` 以执行新的 CreateQueue 函数，我将创建一个持久化队列，因为我希望处理新客户的队列保持活跃和持久，我还会将自动删除设置为
    `false`。
- en: I will also create a nondurable Queue named `customers_test` to showcase the
    difference.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我还会创建一个名为 `customers_test` 的非持久化队列，以展示区别。
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After adding that, make sure to execute the producer.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 添加完后，请确保执行生产者。
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can visit the UI and view the Queues that should be both available. Notice
    that once the program exists, the `customers_test` queue is NOT DELETED, this
    is because we have yet to have a Consumer connect. Only Queues that had a consumer
    connect will be deleted.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以访问 UI 并查看应该都可用的队列。请注意，一旦程序退出，`customers_test` 队列没有被删除，这是因为我们还没有消费者连接。只有连接了消费者的队列才会被删除。
- en: '![](../Images/17f2a047cdbff9a7c58cb0322e5b3e47.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/17f2a047cdbff9a7c58cb0322e5b3e47.png)'
- en: customers-test is created with auto-delete, once the program exits it will be
    removed. — Image by Percy Bolmer
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: customers-test 使用自动删除创建，一旦程序退出，它将被删除。— 图片来源：Percy Bolmer
- en: For fun, you could try to restart RabbitMQ now and see how `customers_test`
    is gone, since it was not marked as durable.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了好玩，你可以尝试现在重启 RabbitMQ，看看 `customers_test` 是如何消失的，因为它没有被标记为持久化。
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Exploring Exchanges and Bindings
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索交换机和绑定
- en: Before we can start sending messages on the Queues, we need to create an **Exchange**.
    There are a few defaults already created, but we will create our own to learn
    a little bit more about them.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始在队列上发送消息之前，我们需要创建一个**交换机**。已经创建了一些默认的交换机，但我们将创建自己的交换机以了解更多信息。
- en: The Exchange is a vital part of RabbitMQ, it is the resource to which we send
    Messages. The exchange's job is to deliver the messages to the correct Queues.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 交换机是 RabbitMQ 的一个重要部分，它是我们发送消息的资源。交换机的工作是将消息发送到正确的队列。
- en: To start receiving messages on a Queue, that queue needs to be bound to an Exchange,
    this is called **Binding**. Binding is basically a routing rule. One important
    thing to understand is that a Queue can be bound to MULTIPLE Exchanges, which
    makes it much more clear why there are different Exchange types also.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始接收队列上的消息，该队列需要绑定到一个交换上，这被称为**绑定**。绑定基本上是一个路由规则。一个重要的点是，队列可以绑定到多个交换，这也使得不同交换类型的意义更加明确。
- en: There are a few different types of exchanges, each with different behavior of
    how messages are sent.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同类型的交换，每种交换在消息发送方式上有不同的行为。
- en: First, we have the most basic one, the **Direct** exchange. This one is really
    simple, messages are routed based on their EXACT routing key. In the example image,
    we see how the message sent to `customer_created` is only routed by the exchange
    `customer_events` into that specific queue. Direct exchanges are very useful when
    you need to distribute work to a set of workers.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有最基本的**Direct**交换。这种交换非常简单，消息是基于其**确切的**路由键进行路由的。在示例图中，我们看到发送到`customer_created`的消息仅通过交换`customer_events`路由到那个特定的队列。直接交换在需要将工作分配给一组工作者时非常有用。
- en: '![](../Images/66d92b7e3d7bb700613ef8ffc855ce32.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/66d92b7e3d7bb700613ef8ffc855ce32.png)'
- en: Direct Exchange — Only direct matches to customer_created receive the match
    — Image by Percy Bolmer
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 直接交换（Direct Exchange）—— 只有直接匹配`customer_created`的消息才会收到匹配 —— 图片由Percy Bolmer提供
- en: The second type is the **Fanout** which is used to send messages to ALL bound
    Queues. Any Queue that is bound to the exchange will get the message, the routing
    key is simply ignored! This is typically used for broadcasting messages to any
    parties interested.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种类型是**Fanout**交换，它用于将消息发送到所有绑定的队列。任何绑定到交换的队列都会接收到消息，路由键会被简单地忽略！这通常用于将消息广播给任何感兴趣的方。
- en: '![](../Images/dbcf592768bda32121c1836b6598b169.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/dbcf592768bda32121c1836b6598b169.png)'
- en: Fanout Exchange — Any bound queue receives the messages — Image by Percy Bolmer
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展交换（Fanout Exchange）—— 任何绑定的队列都接收消息 —— 图片由Percy Bolmer提供
- en: Then we have **Topic** Exchanges, which once are pretty cool. They allow bindings
    to specify a rule to select subsets of the messages sent depending on their routing
    key.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有**Topic**交换，这种交换非常酷。它们允许绑定指定规则以根据路由键选择消息的子集。
- en: The routing keys are delimited `.` between each word, say `customers.eu.stockholm`.
    This might be the routing key for customers from Stockholm Sweden, then we could
    have a binding that tells the Exchange that a Queue wants those messages, but
    not `customers.us.florida` for example.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 路由键在每个词之间用`.`分隔，例如`customers.eu.stockholm`。这可能是来自瑞典斯德哥尔摩的客户的路由键，然后我们可以有一个绑定来告诉交换机某个队列想要这些消息，但不包括`customers.us.florida`。
- en: There are a few special characters, the `#` means zero or more matches, so for
    example `customers.#` would match any routing key beginning with `customers.`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个特殊字符，`#`表示零个或多个匹配，因此例如`customers.#`将匹配任何以`customers.`开头的路由键。
- en: There is also `*` which is a specific word at a specific location, for example
    `customers.*.stockholm` would only match routing keys that have the first word
    `customers` and the third word `stockholm`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`*`，它是特定位置的特定词，例如`customers.*.stockholm`将仅匹配具有第一个词`customers`和第三个词`stockholm`的路由键。
- en: This is of course very useful to have certain services only ingest messages
    that are related to a subset of the topics. The example below shows how a new
    customer is created in February, the Queue `customer_created` gets the message
    since the binding is for the `customers.created.#` rule, the Queue `customer_emailed`
    does not receive it since it does not match the binding `customers.created.march`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这对于某些服务只接收与特定主题子集相关的消息是非常有用的。下面的例子展示了如何在二月份创建一个新客户，队列`customer_created`会接收到消息，因为绑定规则是`customers.created.#`，而队列`customer_emailed`则不会接收到消息，因为它不匹配绑定`customers.created.march`。
- en: '![](../Images/bc6c90f304513314f60c0569f7badc07.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/bc6c90f304513314f60c0569f7badc07.png)'
- en: Topic Exchange — Allows a simple regexp to select subsets based on the Routing
    Key — Image by Percy Bolmer
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 主题交换（Topic Exchange）—— 允许使用简单的正则表达式根据路由键选择子集 —— 图片由Percy Bolmer提供
- en: The final exchange is the **Header** exchange, each Message we send on RabbitMQ
    has the possibility to add Headers, which is a key value field. This can be really
    handy when we need to route based on a more advanced level.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的交换是**Header**交换，每条我们在RabbitMQ上发送的消息都有可能添加头信息，这是一个键值字段。当我们需要基于更高级别的内容进行路由时，这非常有用。
- en: Say that we add a `browser` header which indicates what web browser the users
    used when registering. We could route any Linux users to a certain queue for instance.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 比如说我们添加一个`browser`头信息，指示用户在注册时使用了什么网页浏览器。例如，我们可以将所有Linux用户路由到某个特定的队列。
- en: You can either specify multiple headers and that they all have to match, or
    only that one has to match. This is done in the binding by setting `x-match` to
    either `all` or `any`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以指定多个头信息，并且它们都必须匹配，或者只需一个匹配。这通过将`x-match`设置为`all`或`any`来完成。
- en: '![](../Images/6a1551378f4499cf5018bc3627c73422.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6a1551378f4499cf5018bc3627c73422.png)'
- en: Header Exchange — Allows routing based on the extra headers that can be supplied
    in a message — Image by Percy Bolmer
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Header Exchange — 允许基于消息中可以提供的额外头信息进行路由 — 图片由 Percy Bolmer 提供
- en: Let’s stop talking and instead create an Exchange that we can use.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们停止讨论，创建一个我们可以使用的交换机。
- en: To add an exchange, we will be using the `rabbitmqadmin` CLI tool that is very
    similar to `rabbitmqcli` that we used before.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加一个交换机，我们将使用与之前使用的`rabbitmqcli`非常类似的`rabbitmqadmin` CLI 工具。
- en: We use the `declare exchange` command followed by the name of the exchange,
    and the type. For this tutorial, I will be using an `Topic` exchange.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`declare exchange`命令，后跟交换机的名称和类型。对于这个教程，我将使用`Topic`交换机。
- en: We will create an exchange named `customer-events`. We also need to specify
    the vhost and the username and password of our administrator. Remember to set
    durable to true if you want it to persist restarts.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`customer-events`的交换机。我们还需要指定虚拟主机以及管理员的用户名和密码。如果你希望交换机在重启时保持存在，记得将durable设置为true。
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We also need to give the user permission to send on this exchange. We set permissions
    on a certain topic using the `set_topic_permissions` command. The following command
    sets the user `percy` to allow posting on the vhost `customers` on the exchange
    `customer_events` on any routing key starting with `customers`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要授权用户在这个交换机上发送消息。我们使用`set_topic_permissions`命令设置特定主题上的权限。以下命令将用户`percy`设置为允许在交换机`customer_events`上的虚拟主机`customers`上发布，路由键以`customers`开头。
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Posting on this Exchange right now will not make anything happen, because we
    have no Bindings between the Queues ad the Exchange.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在这个交换机上发布将不会有任何反应，因为队列和交换机之间没有绑定。
- en: Any messages sent will be discarded.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 任何发送的消息都会被丢弃。
- en: Publishing Messages To Exchanges
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布消息到交换机
- en: To start publishing messages, we first need to create the binding between `customers_created`
    and `customers_test` queues and the `customers_events` exchange.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始发布消息，我们首先需要在`customers_created`和`customers_test`队列与`customers_events`交换机之间创建绑定。
- en: Open up `rabbitmq.go` and add a `CreateBinding` function that adds the binding.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`rabbitmq.go`并添加一个添加绑定的`CreateBinding`函数。
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Then inside `producer/main.go` we add bindings so that we connect everything.
    We will expect customers to be published on the topic `customers.created` followed
    by the country they are from. But the Binding won't care about the country, only
    that it matches the pattern.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`producer/main.go`中添加绑定，以便连接所有内容。我们预计客户会在主题`customers.created`上发布，后面跟着他们来自的国家。但是绑定不会关心国家，只要它匹配模式即可。
- en: '[PRE18]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you execute the producer once we can visit the management UI and see the
    bindings that are available.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行生产者，我们可以访问管理用户界面并查看可用的绑定。
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Then go into the UI and visit your Exchange.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后进入用户界面并访问你的交换机。
- en: '![](../Images/c815c366cba69808a3756e8e0b11bcf1.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c815c366cba69808a3756e8e0b11bcf1.png)'
- en: Exchange showing the current Bindings and their routing keys — Image by Percy
    Bolmer
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 交换机显示当前的绑定和它们的路由键 — 图片由 Percy Bolmer 提供
- en: Now that we have a binding, we can look at publishing messages. We begin with
    the easiest kind.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了绑定，可以开始查看发布消息的内容。我们从最简单的开始。
- en: We create a wrapper function called `Send` that accepts parameters about what
    exchange, and routing key to publish to. The function will also accept a context
    to use and a `amqp.Publishing` struct.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个名为`Send`的包装函数，该函数接受关于要发布到哪个交换机和路由键的参数。该函数还会接受一个上下文和一个`amqp.Publishing`
    结构体。
- en: The `amqp.Publishing` struct is essential to understand, as it allows us to
    customize the features and behavior of the message we send.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`amqp.Publishing` 结构体非常重要，因为它允许我们自定义我们发送的消息的功能和行为。'
- en: We will explore them step by step since there are quite a few of them.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一步步地探索它们，因为它们有很多。
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Go back to `producer/main.go` and we will create a message to send. We will
    send two messages, one for each queue. This is to showcase the `deliveryMode`
    parameter which is really important. If you set it to persistent the message will
    be saved until some consumer grabs it, but this comes with overhead and longer
    latency.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到`producer/main.go`，我们将创建一条消息进行发送。我们将发送两条消息，每个队列一条。这是为了展示`deliveryMode`参数，这个参数非常重要。如果将其设置为持久性，消息将被保存直到某个消费者获取它，但这会带来开销和更长的延迟。
- en: If you have things that do not need to be durable, then set them to **Transient**
    to increase performance.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有些东西不需要持久化，则将其设置为**Transient**以提高性能。
- en: Remember, if you send persistent messages, your Queue also needs to be Durable,
    no point in saving Messages across Restarts, if the Queue itself is gone.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果你发送的是持久消息，你的队列也需要是持久的；如果队列本身不存在，那么保存消息也没有意义。
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Time to execute the Producer
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是执行生产者的时候了。
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You should now see one message for each Queue in the UI under the `Queue` page.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该在UI的`Queue`页面下看到每个队列的一条消息。
- en: '![](../Images/17f239cecab1d2c4960ec0eba230237d.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/17f239cecab1d2c4960ec0eba230237d.png)'
- en: Each queue has a message sent to them — Image by Percy Bolmer
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 每个队列都有消息发送到它们 — 图片来源：Percy Bolmer
- en: If you want to, you can enter each queue and Consume the messages to view them,
    but I suggest a restart of RabbitMQ to show the difference between Transient and
    Persistent.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，可以进入每个队列并消费消息进行查看，但我建议重新启动RabbitMQ，以显示Transient和Persistent之间的区别。
- en: '[PRE23]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: After restarting try reloading the UI, you should see that the whole `customers-test`
    queue is removed, but the `customers-created` queue actually has the old message
    left.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动后尝试重新加载UI，你应该会看到整个`customers-test`队列被删除了，但`customers-created`队列实际上保留了旧消息。
- en: This is because Persistent messages are written to disk to survive crashes etc.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为持久消息会被写入磁盘，以便在崩溃等情况发生时能够保存。
- en: We will cover more advanced publishing soo.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将很快介绍更高级的发布技术。
- en: Consuming Messages, Acknowledging, Nacking & Requeues
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消费消息、确认、拒绝和重新入队
- en: We know how to publish messages, but that does us no good if we cannot Consume
    the messages in another service.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道如何发布消息，但如果我们不能在另一个服务中消费这些消息，那是没有用的。
- en: Consuming is the process of grabbing a message from a Queue.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 消费是从队列中获取消息的过程。
- en: Let’s create a new binary that we can use to consume messages.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的二进制文件，以便我们可以用来消费消息。
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Before we start consuming, we will add a `Consume` function in `Rabbitmq.go`
    that will wrap the channel consume function.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始消费之前，我们将在`Rabbitmq.go`中添加一个`Consume`函数，它将封装通道消费函数。
- en: When consuming there are a few options to consider.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 消费时有几个选项需要考虑。
- en: '**Exclusive** — If set to true will ensure that this is a SINGLE and the ONLY
    consumer on that Queue, if False the server will fairly distribute messages amongst
    consumers.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Exclusive** — 如果设置为true，将确保这是该队列上的唯一消费者；如果设置为false，服务器将公平地将消息分配给多个消费者。'
- en: '**AutoAck** — When true, will automatically acknowledge delivery, when false
    will expect the Consumer to call Acknowledge when complete. AutoAck might sound
    amazing, but it’s tricky, if your consumer fails after Acking a time-consuming
    process, the message is lost because the server thinks it''s done.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AutoAck** — 当设置为true时，将自动确认交付；当设置为false时，将期望消费者在完成时调用确认。AutoAck可能听起来很棒，但它很棘手，如果你的消费者在确认耗时的过程后失败，消息会丢失，因为服务器认为它已经完成。'
- en: '[**NoLocal**](https://www.rabbitmq.com/amqp-0-9-1-reference.html#domain.no-local)
    — Not supported in RabbitMQ, AMQP field for avoiding publishing and consuming
    from the same domain.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[**NoLocal**](https://www.rabbitmq.com/amqp-0-9-1-reference.html#domain.no-local)
    — 在RabbitMQ中不支持，这是AMQP字段，用于避免在同一领域中发布和消费。'
- en: '[**NoWait**](https://www.rabbitmq.com/amqp-0-9-1-reference.html#domain.no-wait)
    — Won’t wait for the server to confirm.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[**NoWait**](https://www.rabbitmq.com/amqp-0-9-1-reference.html#domain.no-wait)
    — 不会等待服务器确认。'
- en: Let us add the `Consume` function to `Rabbitmq.go`
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`Consume`函数添加到`Rabbitmq.go`中。
- en: '[PRE25]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now that we can consume, let’s fill in the `consumer/main.go` so that it connects
    to RabbitMQ and starts Ingesting messages from the queue.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以进行消费了，让我们填写`consumer/main.go`，使其连接到RabbitMQ并开始从队列中获取消息。
- en: '[PRE26]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Running that consumer should print out a Message coming from the publisher once
    it happens.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该消费者时，一旦发布者有消息发送，它应该会打印出一条消息。
- en: Remember, Reuse the Connection, but create a new Channel for each Parallel processing,
    in our case a second RabbitMQ Client would be created to manage the `customers-test`
    queue.
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 记住，复用连接，但为每个并行处理创建一个新的通道，在我们的例子中，将创建一个第二个RabbitMQ客户端来管理`customers-test`队列。
- en: '[PRE27]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you don't see any messages it is probably due to the fact that you need to
    run the producer first.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到任何消息，可能是因为你需要先运行生产者。
- en: '[PRE28]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It might be worth exploring the Struct that is sent over the channel, the `amqp.Delivery`
    struct, it gives a good idea of all the fields present.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 可能值得探索通过通道传递的结构体，即 `amqp.Delivery` 结构体，它提供了所有字段的良好视图。
- en: '[PRE29]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you rerun the current consumer, you will see the same message appearing again.
    This is due to the fact that we never acknowledge that the consumer used the message.
    This has to be done manually when iterating the messages or using the Auto Acknowledge
    flag.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重新运行当前的消费者，你会看到相同的消息再次出现。这是因为我们从未确认消费者已经使用了这条消息。这必须在迭代消息或使用自动确认标志时手动完成。
- en: When acknowledging we can pass in a `multiple` flag, which indicates if we acknowledge
    multiple messages at once, we can leave it to be false.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在确认时，我们可以传递一个 `multiple` 标志，指示是否一次确认多条消息，我们可以将其设为 false。
- en: We can acknowledge or NACK messages, Acknowledge means that everything was fine,
    Nack means we failed to process it and then the message will be passed back into
    the queue.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以确认或 `NACK` 消息，确认表示一切正常，`NACK` 表示我们处理失败，然后消息会被重新放回队列中。
- en: Let’s update the code that consumes messages so that It acknowledges them.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新处理消息的代码，以便确认它们。
- en: '[PRE30]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Rerun the code now, and you should see that the message is printed once again,
    but upon restarting the message is gone.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新运行代码，你应该会看到消息再次打印，但在重新启动后消息就消失了。
- en: This is really useful, to avoid having a consumer take a message, fail while
    processing it, and then that message would be gone.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常有用，以避免消费者接收一条消息，在处理时失败，然后消息就会丢失。
- en: To showcase why Auto Ack might be dangerous, here is a modified example where
    we set Auto Ack to true, but failed during the processing.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示自动确认可能是危险的，这里是一个修改后的例子，我们将自动确认设置为 true，但在处理过程中失败了。
- en: '[PRE31]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Run the consumer twice, and you will see that it is in fact only accepted at
    the first execution. This can be dangerous behavior if you don't manage it properly.
    That's why I keep mentioning it!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 运行消费者两次，你会看到它实际上只在第一次执行时接受了消息。如果你没有妥善管理，这可能是危险的行为。这就是我不断提到它的原因！
- en: To handle failures, you can use `Nack` to tell RabbitMQ that it failed, and
    you can use the `redelivered` field to avoid retrying too many times.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理失败，你可以使用 `Nack` 告诉 RabbitMQ 失败了，你可以使用 `redelivered` 字段来避免过多重试。
- en: Nack accepts a parameter for Requeuing, which is really handy!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`Nack` 接受一个重新排队的参数，这非常方便！'
- en: Here is an example where we fail the first time a message arrives, Requeue it,
    and then Ack it the next time it comes.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子，我们在消息到达第一次时失败，重新排队，然后在下一次到达时确认它。
- en: '[PRE32]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There is more to consider here, right now the handler we use is single-threaded,
    which means we can only accept one message at a time. We can fix this by implementing
    a work group that allows for a certain amount of concurrent tasks.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有更多需要考虑的，目前我们使用的处理程序是单线程的，这意味着我们一次只能处理一条消息。我们可以通过实现一个工作组来修复这一点，该工作组允许一定数量的并发任务。
- en: I will add a `errgroup`, so this approach requires Go 1.2\. Using an ErrGroup
    is super easy, and we can limit it to 10 messages per Consumer.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我将添加一个 `errgroup`，因此这种方法需要 Go 1.2。使用 ErrGroup 非常简单，我们可以将其限制为每个消费者处理 10 条消息。
- en: The errgroup is from the `golang.org/x/sync/errgroup` package.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`errgroup` 来自 `golang.org/x/sync/errgroup` 包。'
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Adding this makes the consumer a little bit better.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这个使得消费者变得稍微更好一些。
- en: The SetLimit is only used for now, there is another way to manage how many messages
    are consumed, using RabbitMQ which I Recommend called Prefetch, we cover that
    later
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`SetLimit` 目前仅用于此，还有另一种管理消费消息数量的方法，即使用 RabbitMQ，我推荐使用的叫做 Prefetch，我们稍后会讲到。'
- en: We can update the Publisher to spam a few more messages by wrapping the Send
    function in a for loop.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将 `Send` 函数包裹在 `for` 循环中来更新发布者以发送更多的消息。
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Try it out and see that the Consumer now accepts multiple messages, or even
    try spawning multiple consumers to play some.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下，看看消费者现在是否接受多条消息，或者尝试启动多个消费者来进行一些测试。
- en: Noticed that the Producer exits right away after sending the message? Currently,
    the `Send` function does not wait for any confirmation from the server. Sometimes,
    we might want to block until the server confirms that it has received the message.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到生产者在发送消息后立即退出了吗？目前，`Send` 函数不会等待来自服务器的任何确认。有时，我们可能希望阻塞，直到服务器确认它已接收到消息。
- en: Happily, we can! We need to change the `Publish` function we use in RabbitMQ
    into `PublishWithDeferredConfirmWithContext` which will return an object that
    we can use to `Wait` for the server to acknowledge.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 高兴的是，我们可以！我们需要将RabbitMQ中使用的`Publish`函数更改为`PublishWithDeferredConfirmWithContext`，这将返回一个可以用来`Wait`等待服务器确认的对象。
- en: This object will always be NIL unless the Channel is put into `Confirm` the
    mode, setting it into Confirm mode will make the server send an acknowledgment
    when it receives the published message.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象将始终是NIL，除非将通道设置为`Confirm`模式，将其设置为Confirm模式将使服务器在收到发布的消息时发送确认。
- en: Inside `Rabbitmq.go` let’s change the Publish method and add a Wait.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Rabbitmq.go`中，让我们修改发布方法并添加一个等待。
- en: '[PRE35]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Let’s also update the `NewRabbitMQClient` to always set the channel into `Confirm`
    mode.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也更新`NewRabbitMQClient`以始终将通道设置为`Confirm`模式。
- en: '[PRE36]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: A better approach to `Rabbitmq.go` could be to add a `NewChannel` function and
    then have each function accept a Channel as an input parameter.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 对`Rabbitmq.go`的一个更好方法可能是添加一个`NewChannel`函数，然后让每个函数接受一个Channel作为输入参数。
- en: Running the program now, and you should see that the `publisher.go` prints TRUE
    each time a message is confirmed by the server, notice that this is not the same
    as the Consumer `ACK`. We only wait for the server to acknowledge that the published
    message is accepted.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行程序，你应该会看到`publisher.go`在每次服务器确认消息时打印TRUE，注意这与Consumer的`ACK`不同。我们只是等待服务器确认发布的消息已被接受。
- en: Publish And Subscribe (PubSub)
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布和订阅（PubSub）
- en: '![](../Images/d1a769e3d40c94df6effe0acdb6a5dae.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d1a769e3d40c94df6effe0acdb6a5dae.png)'
- en: Pub/Sub schema in RabbitMQ Using a Fanout Exchange — Image by Percy Bolmer
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ中的Pub/Sub模式使用Fanout交换机 — 图片由Percy Bolmer提供
- en: Up until this point we have been using FIFO Queues(First in First out). This
    means each message is only sent to one Consumer.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 直到目前为止，我们一直在使用FIFO队列（先进先出）。这意味着每条消息只发送给一个消费者。
- en: In a publish and subscribe schema, you will want each consumer to receive the
    same message.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布和订阅模式中，你会希望每个消费者接收到相同的消息。
- en: Everything we learned about bindings etc is still true and used in the same
    way. We can use a Fanout exchange (which pushes messages to all Queues bound)
    regardless of the Queue name.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关于绑定等的所有知识仍然适用，使用方式相同。我们可以使用Fanout交换机（将消息推送到所有绑定的队列）而不管队列名称。
- en: The idea is that you let each Consumer create an Unnamed Queue, an unnamed queue
    will get a randomly generated unique name by the RabbitMQ server.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是让每个消费者创建一个未命名的队列，未命名的队列将由RabbitMQ服务器生成一个随机的唯一名称。
- en: This is a great example when creating queues in the code is suitable
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这是在代码中创建队列非常适合的一个好例子。
- en: It’s possible that we would want to send `customers_event` to multiple services.
    Say that we would want an email service and a logging service that logs each customer
    event.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望将`customers_event`发送到多个服务。例如，我们可能希望有一个电子邮件服务和一个日志记录服务来记录每个客户事件。
- en: Let’s build that. (Since this is a tutorial only to learn RabbitMQ we will simply
    start the Consumer up in two instances).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来构建它。（由于这是一个学习RabbitMQ的教程，我们将简单地启动两个Consumer实例。）
- en: We start by removing the exchange we have since it is the wrong **Type**. We
    also create a new one, but with **Fanout** as the type. This time we don't specify
    a certain prefix for the permission, but give it full access.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先删除现有的交换机，因为它的**类型**不正确。我们还创建一个新的交换机，但类型为**Fanout**。这一次我们没有为权限指定特定的前缀，而是给予了完全访问权限。
- en: '[PRE37]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Since we won’t know the Queue name when we create an unnamed one with the current
    code, we need to modify it. Let’s return the Queue information returned from `CreateQueue`
    in the RabbitMQ package. That object will contain the randomly created name.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在当前代码中创建一个未命名的队列时无法知道队列名称，因此需要进行修改。让我们返回来自`CreateQueue`的RabbitMQ包中的队列信息。该对象将包含随机创建的名称。
- en: '[PRE38]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Time to update the `Publisher`, earlier in the tutorial we created the Channel
    bindings in the Publisher. This doesn’t really make sense according to me, it
    was only for the purpose of not moving too fast and still showcasing the functionality.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是更新`Publisher`的时候了，在教程早些时候我们在Publisher中创建了Channel绑定。依我看这样做并不完全合理，这只是为了不走得太快，同时展示功能。
- en: It makes much more sense for the `Consumer` to declare the bindings, since it
    relates to the consumer. It makes even less sense now with Publish And Subscribes
    where the number and paths of Consumers are probably unknown. Let’s update `publisher.go`
    making it much smaller.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`Consumer` 声明绑定更有意义，因为它与消费者相关。在发布和订阅中，消费者的数量和路径可能未知，现在这更没有意义。让我们更新 `publisher.go`
    使其变得更小。'
- en: '[PRE39]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We will update the `consumer.go` to create a Queue without a name, create the
    binding, and then start consuming that Queue.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更新 `consumer.go` 以创建一个未命名的队列，创建绑定，然后开始消费该队列。
- en: '[PRE40]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This setup can be used to showcase Pub/Sub properly, we can spawn two consumers
    and then the Publisher. It will show how all Consumers see all the messages.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置可以用来正确展示 Pub/Sub，我们可以先启动两个消费者，然后是发布者。它将展示所有消费者如何看到所有消息。
- en: '![](../Images/79915ffe5e95a64145f33fb403ce4baa.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/79915ffe5e95a64145f33fb403ce4baa.png)'
- en: Multiple Consumers all receive the messages.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 所有消费者都会接收到消息。
- en: We now know how to use regular Queues and PubSub.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何使用常规队列和 PubSub。
- en: There is one more thing left, a third very common scenario is an RPC-based paradigm.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事，第三种非常常见的场景是基于 RPC 的范式。
- en: Remote Procedure Call (RPC) With RabbitMQ
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 RabbitMQ 的远程过程调用（RPC）
- en: '![](../Images/752a50ce893c27d8a0ae136bd8e16c21.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/752a50ce893c27d8a0ae136bd8e16c21.png)'
- en: RPC in RabbitMQ Using the ReplyTo header in messages. — Image by Percy Bolmer
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ 中的 RPC 使用消息中的 ReplyTo 头部。— 图片由 Percy Bolmer 提供
- en: Sometimes, we want to have some callbacks on messages. Say that the Producer
    would like to know when the customer has emailed.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望在消息上进行一些回调。比如说，生产者希望知道客户何时发送了电子邮件。
- en: This is common and easily fixed. We can set a field named `ReplyTo` in the messages,
    this can be used to tell the Consumer to reply with a response on a certain Queue.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这是常见且容易解决的问题。我们可以在消息中设置一个名为 `ReplyTo` 的字段，这可以用于告诉消费者在特定队列上回复响应。
- en: We might need to know which message the callback is related to, so we can also
    add in a `correlationID` which can be used to understand what request the response
    is related to.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要知道回调与哪个消息相关，因此我们还可以添加 `correlationID`，以便了解响应与哪个请求相关。
- en: Begin by creating a new Exchange with **Direct** type. I’ll name it `customer_callbacks`.
    The Direct type works well here.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 开始创建一个 **Direct** 类型的新交换机。我会将其命名为 `customer_callbacks`。Direct 类型在这里效果很好。
- en: '[PRE41]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The first thing we need to understand is one important best practice at this
    time.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要了解的第一件事是目前的一个重要最佳实践。
- en: Having a callback will require that the same service both Publishes and Consumes
    messages, and it is nothing wrong with that.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有回调将要求相同的服务既进行发布又进行消费，这没什么问题。
- en: One famous rule is, however, to reuse connections for multiple channels. **BUT
    NEVER PUBLISH AND CONSUME ON THE SAME CONNECTION.**
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 一个著名的规则是，**但绝不要在同一连接上进行发布和消费**。
- en: '![](../Images/4779cfaaa76b6550a1b599287a47c55c.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4779cfaaa76b6550a1b599287a47c55c.png)'
- en: Back pressure can stop ACK messages from being sent — Image by Percy Bolmer
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 压力回溯可能会阻止 ACK 消息的发送 — 图片由 Percy Bolmer 提供
- en: Imagine if you have a service that is both producing and consuming and you are
    doing it on the same connection, then imagine that the service is consuming a
    big amount of messages. If it is more messages than the service manages to handle,
    so messages start stacking up. RabbitMQ May then apply back pressure and start
    blocking TCP connections from sending, and guess what, ACK messages have to be
    sent to handle messages. All of a sudden, your code cannot ACK messages since
    the connection is blocked. This can lead to delays.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果你有一个同时进行生产和消费的服务，并且在同一个连接上进行，那么假设服务正在消费大量消息。如果消息数量超过了服务能够处理的范围，消息开始堆积。RabbitMQ
    可能会施加回压，开始阻塞 TCP 连接的发送，结果，ACK 消息必须被发送来处理消息。突然间，由于连接被阻塞，你的代码无法发送 ACK 消息。这可能会导致延迟。
- en: The golden rules are
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 黄金规则是
- en: Reuse connection in your application
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序中重用连接
- en: One Connection for Consuming, One for Publishing
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于消费，一个用于发布
- en: Spawn new Channels for each Goroutine
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个 Goroutine 创建新的通道
- en: Let’s update the `producer.go` to start two connections, one for publishing
    and one for consuming. We will also create an unnamed queue and bind it to the
    exchange, then we will consume those responses.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新 `producer.go` 来启动两个连接，一个用于发布，一个用于消费。我们还将创建一个未命名的队列并将其绑定到交换机，然后我们将消费这些响应。
- en: We will also add `replyTo` in the message, which tells the consumer where to
    reply, and the `correlationId` which explains which unique event the messages
    relate to.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在消息中添加`replyTo`，这告诉消费者回复的地址，以及`correlationId`，它解释了消息关联的唯一事件。
- en: '[PRE42]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The consumer needs to be updated so that it also uses two connections. When
    we are done processing a message, we will add it so that we send out a response
    on the `replyTo` queue. Again, we have to use two different connections, one for
    consuming and one for publishing.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者需要更新，以便它也使用两个连接。当我们完成处理消息时，我们将其添加到`replyTo`队列，以便发送响应。再次，我们必须使用两个不同的连接，一个用于消费，另一个用于发布。
- en: '[PRE43]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Go ahead and try the code, you should see that the producer receives the RPC
    responses and prints them out.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下代码，你应该看到生产者接收到RPC响应并将其打印出来。
- en: Note that this code can be cleaned up, but this tutorial focuses on how RabbitMQ
    works, not clean code.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这段代码可以进行清理，但本教程重点在于RabbitMQ的工作原理，而不是清洁代码。
- en: Prefetch Limit To Limit Amount Of Messages Sent
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预取限制——限制发送的消息数量。
- en: Remember that we limited the amount of work done by the consumer before by using
    an `errgroup`? This was a soft limit, a limit imposed by the code, but RabbitMQ
    can still send more messages out to the consumer.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们之前通过使用`errgroup`限制了消费者的工作量吗？这只是一个软限制，由代码施加，但RabbitMQ仍然可以向消费者发送更多消息。
- en: There is a better fix to this, well, a combination should probably be used if
    you want your consumer to handle messages concurrently.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更好的解决方案，实际上，如果你希望消费者并发处理消息，应该使用组合方案。
- en: The AMQP protocol allows us to apply a Prefetch limit. This tells the RabbitMQ
    server how many unacknowledged messages can be sent to the channel at a time.
    This way we can add a hard limit.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: AMQP协议允许我们应用预取限制。这告诉RabbitMQ服务器每次可以发送到频道的未确认消息数量。这样我们可以添加一个硬限制。
- en: This is done by applying a set of Quality Of Service rules (QOS). Let’s add
    a method in `rabbitmq.go` that applies the three available rules.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用一组服务质量规则（QOS）来完成这一点。让我们在`rabbitmq.go`中添加一个方法，应用这三条可用的规则。
- en: There are the following parameters
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是参数：
- en: Prefetch Count — How many unacknowledged messages the server can send.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预取计数——服务器可以发送多少未确认的消息。
- en: Prefetch Size — How many bytes of unacknowledged messages the server can send.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预取大小——服务器可以发送多少字节的未确认消息。
- en: Global — A flag that determines if the rule should be applied on the connection,
    or globally
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局——一个标志，用于确定规则是否应用于连接或全局。
- en: '[PRE44]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Then inside `consumer.go` we can simply call this and apply the number of messages
    we want to allow.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`consumer.go`中，我们可以简单地调用它并应用我们想要允许的消息数量。
- en: '[PRE45]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Securing the connection with TLS
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用TLS保护连接。
- en: It’s the year 2023, before going into production I think it is very safe to
    say that we should encrypt the traffic.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是2023年，在投入生产之前，我认为我们应该加密流量是非常安全的。
- en: RabbitMQ has a GitHub [repository](https://github.com/rabbitmq/tls-gen) to help
    us create a rootCA and the certificates we need, which is the first step in starting
    to encrypt the traffic.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ有一个GitHub [repository](https://github.com/rabbitmq/tls-gen)来帮助我们创建rootCA和所需的证书，这是加密流量的第一步。
- en: We need to clone this repository and execute the make file inside that will
    generate the files we need.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要克隆此存储库并执行内部的make文件，以生成所需的文件。
- en: '[PRE46]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: All the generated files will appear in a new folder called `result`. For this
    to work in Docker, we need to change their permissions.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 所有生成的文件将出现在一个名为`result`的新文件夹中。为使其在Docker中正常工作，我们需要更改它们的权限。
- en: '[PRE47]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We need to delete the RabbitMQ container that is running, we will need to create
    a new one with a configuration file.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要删除正在运行的RabbitMQ容器，我们需要用配置文件创建一个新的容器。
- en: '[PRE48]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The configuration file is called `rabbitmq.conf` and should be placed inside
    `/etc/rabbitmq/rabbitmq.conf` in the container.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件名为`rabbitmq.conf`，应放置在容器中的`/etc/rabbitmq/rabbitmq.conf`内。
- en: This configuration file can be used to configure much more than just TLS, but
    we will stick to TLS for now. Create a new file with the correct name in the root
    of the project.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置文件不仅可以配置TLS，但我们现在只讨论TLS。在项目根目录下创建一个具有正确名称的新文件。
- en: '[PRE49]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We need to mount the configuration file into the docker when we start the container.
    We will also mount the certificates generated from the TLS-Gen tooling into `/certs`
    so that the container can find them. Notice that both ports have been decreased
    by one, which is the standard in the RabbitMQ protocol.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在启动容器时将配置文件挂载到 Docker 中。我们还将把 TLS-Gen 工具生成的证书挂载到`/certs`，以便容器可以找到它们。请注意，这两个端口都减少了一，以符合
    RabbitMQ 协议的标准。
- en: '[PRE50]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Once that is done, we can start adding TLS configurations to this container.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，我们可以开始将 TLS 配置添加到这个容器中。
- en: In the `rabbitmq.conf` let us add the PATH to the certificates and the root
    ca. My computer is named `blackbox`, you need to replace the certs names with
    the names generated by your computer.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在`rabbitmq.conf`中添加证书和根 CA 的路径。我的计算机名为`blackbox`，你需要将证书名称替换为你计算机生成的名称。
- en: '[PRE51]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Then restart RabbitMQ
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 然后重新启动 RabbitMQ。
- en: '[PRE52]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: To verify that everything works, you can view the docker logs with `docker logs
    rabbitmq`. Search for the logs about listeners.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证一切是否正常工作，你可以使用`docker logs rabbitmq`查看 Docker 日志。搜索有关监听器的日志。
- en: '[PRE53]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now, the old programs won't work anymore. It tries to connect using without
    TLS, so let’s fix that.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，旧程序将无法再工作。它尝试在没有 TLS 的情况下进行连接，所以我们来修复一下。
- en: The programs need to be updated to use client certificates. Let’s add it as
    input to the `ConnectRabbitMQ` function.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 程序需要更新以使用客户端证书。我们将其作为输入添加到`ConnectRabbitMQ`函数中。
- en: '[PRE54]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Please notice that we now use `amqps` protocol. The certificate paths are absolute
    paths, let’s update the `consumer` and `producer` to insert these, I will use
    hard-coded values for now, but you should not do that in a real application.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们现在使用的是`amqps`协议。证书路径是绝对路径，我们需要更新`consumer`和`producer`以插入这些路径，我现在会使用硬编码的值，但在实际应用中你不应该这样做。
- en: '[PRE55]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: BAM! Amazing, we got TLS.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: BAM！太棒了，我们有了 TLS。
- en: Try running either the producer or consumer, and then watch the docker logs
    using `docker logs rabbitmq`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行生产者或消费者，然后使用`docker logs rabbitmq`查看 Docker 日志。
- en: '[PRE56]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Right, we removed the Vhost, the user, the exchange, and everything when we
    deleted the docker since we don’t persist the storage.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 对，删除 Docker 时我们删除了虚拟主机、用户、交换机以及所有内容，因为我们没有持久化存储。
- en: This is great because that brings us to the next and final step of this tutorial,
    default configurations.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，因为这将引导我们进入本教程的下一步也是最后一步，默认配置。
- en: RabbitMQ Configurations And Management
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RabbitMQ 配置与管理
- en: Trust me, you don’t want to manage a rabbitMQ for multiple users using the AdminCLI,
    because, well it is a lot of work repeating stuff if you reset the cluster for
    some reason.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 相信我，你不想使用 AdminCLI 来管理多个用户的 RabbitMQ，因为如果你因为某些原因重置集群，这将是重复的繁重工作。
- en: There is support for inserting definition files, JSON files that define users,
    vhosts, permissions, queues and exchanges, and even bindings.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 支持插入定义文件、定义用户、虚拟主机、权限、队列和交换机的 JSON 文件，甚至是绑定。
- en: They are really easy to use, let’s add my old user and give it permission to
    write and read on the `customers` vhost, and add a basic exchange.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 它们真的很容易使用，让我们添加我的旧用户，并赋予其在`customers`虚拟主机上读写权限，添加一个基本交换机。
- en: Before that, we need a password [hash](https://www.rabbitmq.com/passwords.html),
    which can be a bit trickier than imagined. It depends on the RabbitMQ setup you
    have and which algorithm you have configured. The default one is SHA256.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前，我们需要一个密码[哈希](https://www.rabbitmq.com/passwords.html)，这可能比想象的要复杂。它取决于你拥有的
    RabbitMQ 设置以及你配置的算法。默认的是 SHA256。
- en: I found a great bash script on [stackoverflow](https://stackoverflow.com/questions/41306350/how-to-generate-password-hash-for-rabbitmq-management-http-api)
    to generate it for me. Create a file named `encodepassword.sh` and replace `secret`
    with the password, you wanna encode.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[stackoverflow](https://stackoverflow.com/questions/41306350/how-to-generate-password-hash-for-rabbitmq-management-http-api)上找到了一个很棒的
    bash 脚本来为我生成它。创建一个名为`encodepassword.sh`的文件，并将`secret`替换为你要编码的密码。
- en: '[PRE57]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Run the script `bash encodepassword.sh` and store the Hash.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本`bash encodepassword.sh`并存储 Hash。
- en: Update `rabbitmq.conf` to include the field `load_definitions` which can be
    used to load definition files at start-up.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`rabbitmq.conf`以包含`load_definitions`字段，这个字段可以在启动时加载定义文件。
- en: '[PRE58]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: I will point toward a file named `/etc/rabbitmq/rabbitmq_definitions.json`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我会指向一个名为`/etc/rabbitmq/rabbitmq_definitions.json`的文件。
- en: Create a file named `rabbitmq_definitions.json` in the root of the project,
    and fill it with the following JSON. At this point, I don't think we need to cover
    the JSON fields, everything should be understandable and clear what is what. It
    is very similar to the CLI commands we ran before.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目根目录下创建一个名为 `rabbitmq_definitions.json` 的文件，并用以下 JSON 填充它。目前，我认为我们不需要详细讲解
    JSON 字段，一切应该是可以理解的。它与我们之前运行的 CLI 命令非常相似。
- en: The following definition file creates the two exchanges we have `customer_events`
    and the `customer_callbacks`. The current code will generate its own Queues, so
    we just define an in the example for fun.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 以下定义文件创建了两个交换机：`customer_events` 和 `customer_callbacks`。当前代码会生成自己的队列，因此我们仅在示例中定义一个以便于理解。
- en: '[PRE59]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Once both files are in place, delete the old docker, and restart a new one,
    but this time we add a third mount for the definitions.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦两个文件都到位，删除旧的 Docker，并重启一个新的，但这次我们为定义添加了第三个挂载点。
- en: '[PRE60]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: After running that, verify the logs that they print out creating the user.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 运行后，检查日志，确认它们打印了创建用户的相关信息。
- en: '[PRE61]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Once that's done, try running the consumer and producer and you should see that
    everything now works as expected. The only difference is that we now create the
    infrastructure in RabbitMQ using a configuration instead of using the CLI, and
    the traffic is encrypted.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，尝试运行消费者和生产者，你应该会看到一切按预期工作。唯一的不同是，我们现在使用配置在 RabbitMQ 中创建基础设施，而不是使用 CLI，并且流量是加密的。
- en: Conclusion
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: Sadly, this is the end of this long, but thrilling and exciting adventure with
    RabbitMQ.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，这个漫长但令人兴奋的 RabbitMQ 冒险到此结束。
- en: Let’s take a look at what we learned.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们学到的内容。
- en: We have learned how to configure RabbitMQ with virtual hosts, and how to create
    users with permissions on those vhosts.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何用虚拟主机配置 RabbitMQ，以及如何在这些虚拟主机上创建具有权限的用户。
- en: We have also learned how to produce and consume messages on Queues and Exchanges.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何在队列和交换机上生产和消费消息。
- en: You should be familiar with all the resources, such as Queues, Exchanges, and
    Bindings.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该对所有资源，如队列、交换机和绑定有一定了解。
- en: We have also covered how to create a Publish and Subscribe schema, an RPC pattern,
    and regular Work queues.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还涵盖了如何创建发布和订阅模式、RPC模式以及常规工作队列。
- en: Hopefully, it is clear how to use Connections and Channels and the difference
    between them. The connection is a TCP connection, and a channel is a multiplexed
    virtual channel over a connection. Reuse Connections in the same software, but
    create new channels for each parallel process.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你已经清楚如何使用连接和通道以及它们之间的区别。连接是一个 TCP 连接，而通道是在连接上的复用虚拟通道。在同一个软件中重用连接，但为每个并行进程创建新的通道。
- en: We learned never to produce and consume on the same connections.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到永远不要在同一个连接上进行生产和消费。
- en: And we have covered how to set up TLS and how to add definitions for predefined
    configurations for RabbitMQ.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还涵盖了如何设置 TLS 以及如何为 RabbitMQ 添加预定义配置的定义。
- en: I really hope you enjoyed this tutorial, and you can find all the code used
    on GitHub.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我真的希望你喜欢这个教程，你可以在 GitHub 上找到所有使用的代码。
- en: Feel free to reach out to me with any questions!
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 随时向我提问！
