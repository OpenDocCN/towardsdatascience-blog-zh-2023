- en: 'Setting up Python Projects: Part V'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Python项目：第V部分
- en: 原文：[https://towardsdatascience.com/setting-up-python-projects-part-v-206df3c1e3d3](https://towardsdatascience.com/setting-up-python-projects-part-v-206df3c1e3d3)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/setting-up-python-projects-part-v-206df3c1e3d3](https://towardsdatascience.com/setting-up-python-projects-part-v-206df3c1e3d3)
- en: 'Mastering the Art of Python Project Setup: A Step-by-Step Guide'
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 掌握Python项目设置的艺术：逐步指南
- en: '[](https://johschmidt42.medium.com/?source=post_page-----206df3c1e3d3--------------------------------)[![Johannes
    Schmidt](../Images/e0cacf7ff37f339a9bf8bd33c7c83a4d.png)](https://johschmidt42.medium.com/?source=post_page-----206df3c1e3d3--------------------------------)[](https://towardsdatascience.com/?source=post_page-----206df3c1e3d3--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----206df3c1e3d3--------------------------------)
    [Johannes Schmidt](https://johschmidt42.medium.com/?source=post_page-----206df3c1e3d3--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://johschmidt42.medium.com/?source=post_page-----206df3c1e3d3--------------------------------)[![Johannes
    Schmidt](../Images/e0cacf7ff37f339a9bf8bd33c7c83a4d.png)](https://johschmidt42.medium.com/?source=post_page-----206df3c1e3d3--------------------------------)[](https://towardsdatascience.com/?source=post_page-----206df3c1e3d3--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----206df3c1e3d3--------------------------------)
    [Johannes Schmidt](https://johschmidt42.medium.com/?source=post_page-----206df3c1e3d3--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----206df3c1e3d3--------------------------------)
    ·20 min read·Jan 14, 2023
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·发表于[Towards Data Science](https://towardsdatascience.com/?source=post_page-----206df3c1e3d3--------------------------------)
    ·阅读时间20分钟·2023年1月14日
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/c80bbfc10240ac4b4126a69759a6a36e.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c80bbfc10240ac4b4126a69759a6a36e.png)'
- en: Photo by [Zoya Loonohod](https://unsplash.com/@loonohod?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 照片由[Zoya Loonohod](https://unsplash.com/@loonohod?utm_source=medium&utm_medium=referral)拍摄，来自[Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: Whether you’re a seasoned developer or just getting started with 🐍 **Python**,
    it’s important to know how to build robust and maintainable projects. This tutorial
    will guide you through the process of setting up a Python project using some of
    the most popular and effective tools in the industry. You will learn how to use
    [GitHub](https://github.com/) and [GitHub Actions](https://github.com/features/actions)
    for version control and continuous integration, as well as other tools for testing,
    documentation, packaging and distribution. The tutorial is inspired by resources
    such as [Hypermodern Python](https://medium.com/@cjolowicz/hypermodern-python-d44485d9d769)
    and [Best Practices for a new Python project](https://mitelman.engineering/blog/python-best-practice/automating-python-best-practices-for-a-new-project/).
    However, this is not the only way to do things and you might have different preferences
    or opinions. The tutorial is intended to be beginner-friendly but also cover some
    advanced topics. In each section, you will automate some tasks and add badges
    to your project to show your progress and achievements.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是经验丰富的开发者还是刚刚开始接触🐍 **Python**，了解如何构建稳健且易于维护的项目都很重要。本教程将指导你使用一些行业内最流行且有效的工具来设置Python项目。你将学习如何使用[GitHub](https://github.com/)和[GitHub
    Actions](https://github.com/features/actions)进行版本控制和持续集成，以及其他工具进行测试、文档编写、打包和分发。本教程的灵感来源于[Hypermodern
    Python](https://medium.com/@cjolowicz/hypermodern-python-d44485d9d769)和[新Python项目的最佳实践](https://mitelman.engineering/blog/python-best-practice/automating-python-best-practices-for-a-new-project/)。然而，这并不是唯一的方法，你可能有不同的偏好或观点。教程旨在对初学者友好，同时涵盖一些高级主题。在每个部分，你将自动化一些任务，并为你的项目添加徽章，以展示你的进展和成就。
- en: The repository for this series can be found at [github.com/johschmidt42/python-project-johannes](https://github.com/johschmidt42/python-project-johannes)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 该系列的代码库可以在[github.com/johschmidt42/python-project-johannes](https://github.com/johschmidt42/python-project-johannes)找到
- en: 'This part was inspired by this blog post:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分的灵感来自于这篇博客文章：
- en: '[**Semantic release with Python, Poetry & GitHub Actions 🚀**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[**Python、Poetry与GitHub Actions的语义化发布 🚀**'
- en: '*I’m planning to add a few features to Dr. Sven thanks to some interest from
    my colleagues. Before doing so, I needed to…*](https://mestrak.com/blog/semantic-release-with-python-poetry-github-actions-20nn)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于我的同事们的兴趣，我计划向Dr. Sven添加一些功能。在此之前，我需要…*](https://mestrak.com/blog/semantic-release-with-python-poetry-github-actions-20nn)'
- en: Requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求
- en: '**OS**: Linux, Unix, macOS, Windows (WSL2 with e.g. Ubuntu 20.04 LTS)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作系统**: Linux、Unix、macOS、Windows（WSL2，例如Ubuntu 20.04 LTS）'
- en: '**Tools**: python3.10, bash, git, tree'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工具**：python3.10, bash, git, tree'
- en: '**Version Control System (VCS) Host**: [GitHub](https://github.com/)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本控制系统（VCS）主机**： [GitHub](https://github.com/)'
- en: '**Continuous Integration (CI) Tool**: [GitHub Actions](https://github.com/features/actions)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续集成（CI）工具**： [GitHub Actions](https://github.com/features/actions)'
- en: 'It is expected that you are familiar with the versioning control system (VCS)
    [git](https://git-scm.com/). If not, here’s a refresher for you: [Introduction
    to Git](https://realpython.com/python-git-github-intro/)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 预计你对版本控制系统（VCS）[git](https://git-scm.com/)有所了解。如果不了解，以下是一个复习： [Git 介绍](https://realpython.com/python-git-github-intro/)
- en: Commits will be based on [best practices for git commits](https://deepsource.io/blog/git-best-practices/)
    & [Conventional commits](https://www.conventionalcommits.org/en/v1.0.0/). There
    is the [conventional commit plugin](https://plugins.jetbrains.com/plugin/13389-conventional-commit)
    for PyCharm or a [VSCode Extension](https://github.com/vivaxy/vscode-conventional-commits)
    that help you to write commits in this format.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 提交将基于 [最佳 git 提交实践](https://deepsource.io/blog/git-best-practices/) 和 [传统提交](https://www.conventionalcommits.org/en/v1.0.0/)。你可以使用
    [PyCharm 的传统提交插件](https://plugins.jetbrains.com/plugin/13389-conventional-commit)
    或 [VSCode 扩展](https://github.com/vivaxy/vscode-conventional-commits) 来帮助你以这种格式编写提交。
- en: Overview
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: '[Part I (GitHub, IDE)](https://johschmidt42.medium.com/setting-up-python-projects-part-i-408603868c08)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第一部分（GitHub，IDE）](https://johschmidt42.medium.com/setting-up-python-projects-part-i-408603868c08)'
- en: Part II (Formatting, Linting, CI)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二部分（格式化，Linting，CI）
- en: Part III (Testing, CI)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三部分（测试，CI）
- en: '[Part IV (Documentation, CI/CD)](https://johschmidt42.medium.com/setting-up-python-projects-part-iv-82059eba4ca4)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第四部分（文档，CI/CD）](https://johschmidt42.medium.com/setting-up-python-projects-part-iv-82059eba4ca4)'
- en: '**Part V (Versioning & Releases, CI/CD)**'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第五部分（版本控制与发布，CI/CD）**'
- en: '[Part VI (Containerisation, Docker, CI/CD)](https://johschmidt42.medium.com/setting-up-python-projects-part-vi-cbdbf28eff53)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第六部分（容器化，Docker，CI/CD）](https://johschmidt42.medium.com/setting-up-python-projects-part-vi-cbdbf28eff53)'
- en: Structure
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构
- en: Git Branching Strategy (*GitHub flow*)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git 分支策略 (*GitHub 流程*)
- en: What is a release? (*zip, tar.gz*)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是发布？ (*zip, tar.gz*)
- en: Semantic Versioning (*v0.1.0*)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语义版本控制 (*v0.1.0*)
- en: Create a release manually (*git tag, GitHub*)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动创建发布 (*git tag, GitHub*)
- en: Create a release automatically (*conventional commits, semantic releases*)
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动创建发布 (*传统提交，语义发布*)
- en: CI/CD (*release.yml*)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CI/CD (*release.yml*)
- en: Create a Personal Access Token (PAT)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建个人访问令牌（PAT）
- en: GitHub Actions Flow (*Orchestrating workflows*)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub Actions 流程 (*编排工作流*)
- en: Badge (*Release*)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 徽章 (*发布*)
- en: Bonus (*Enforce conventional commits*)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 奖励 (*强制执行传统提交*)
- en: Releasing software is an important step in the software development process
    as it makes new features and bugfixes available to users. One key aspect of releasing
    software is versioning, which helps to track and communicate the changes made
    in each release. Semantic versioning is a widely used standard for versioning
    software, which uses a version number in the format of Major.Minor.Patch (e.g.
    1.2.3) to indicate the level of changes made in a release.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 发布软件是软件开发过程中的重要步骤，因为它使新功能和修复程序可供用户使用。发布软件的一个关键方面是版本控制，它有助于跟踪和传达每个发布中的变化。语义版本控制是一种广泛使用的软件版本控制标准，它使用格式为
    Major.Minor.Patch（例如 1.2.3）的版本号来指示发布中所做更改的级别。
- en: Conventional commits is a specification for adding human and machine readable
    meaning to commit messages. It’s a way to format commit messages in a consistent
    manner, which make it easy to determine the type of change made. Conventional
    commits are commonly used in conjunction with semantic versioning, as the commit
    messages can be used to automatically determine the version number of a release.
    Together, semantic versioning and conventional commits provide a clear and consistent
    way to track and communicate the changes made in each release of a software project.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 传统提交是一种为提交消息添加人类和机器可读意义的规范。它是一种以一致的方式格式化提交消息的方法，这使得确定所做更改的类型变得简单。传统提交通常与语义版本控制结合使用，因为提交消息可以用来自动确定发布的版本号。语义版本控制和传统提交一起提供了一种清晰且一致的方法来跟踪和传达每个软件项目发布中的更改。
- en: Git Branching Strategy
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git 分支策略
- en: There are many different branching strategies out there for git. Many people
    gravitate towards [GitFlow](http://datasift.github.io/gitflow/IntroducingGitFlow.html)
    (or variants), [Three Flow](https://www.nomachetejuggling.com/2017/04/09/a-different-branching-strategy/),
    or [Trunk based Flows](https://trunkbaseddevelopment.com/). Some do strategies
    in between these, such as this [one](https://brightinventions.pl/blog/how-do-we-use-git/).
    I’m using the very simple [GitHub flow](https://guides.github.com/introduction/flow/)
    branching strategy, where all bug fixes and features have their own separate branch,
    and when complete, each branch is merged to main and deployed. Simple, nice and
    easy.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: git 有许多不同的分支策略。很多人倾向于使用[GitFlow](http://datasift.github.io/gitflow/IntroducingGitFlow.html)（或变种）、[Three
    Flow](https://www.nomachetejuggling.com/2017/04/09/a-different-branching-strategy/)或[Trunk
    based Flows](https://trunkbaseddevelopment.com/)。一些人使用这些策略中的混合策略，例如这个[策略](https://brightinventions.pl/blog/how-do-we-use-git/)。我使用非常简单的[GitHub
    flow](https://guides.github.com/introduction/flow/)分支策略，其中所有的 bug 修复和功能都有各自的独立分支，完成后，每个分支都会合并到主分支并进行部署。简单、好用且易于操作。
- en: '![](../Images/9ac6ed499d8cab343bc75482579e1bed.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9ac6ed499d8cab343bc75482579e1bed.png)'
- en: GitHub Flow branching strategy
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Flow 分支策略
- en: Whatever your strategy might be, in the end you merge a pull request and (probably)
    create a release.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你的策略是什么，最终你都会合并一个拉取请求，并（可能）创建一个版本发布。
- en: What is a release?
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是版本发布？
- en: In short, a release is packing up code of a version (e.g. zip) and pushing it
    to production (whatever this might be for you).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，发布就是将一个版本的代码打包（例如压缩文件），并推送到生产环境（这对你来说可能是任何东西）。
- en: Release management can be messy. Therefore there needs to be a concise way that
    you follow (and others), that defines what a release means and what changes between
    one release and the next. If you don’t track the changes between the releases,
    then you probably won’t understand what has been changed in each release and you
    can’t identify any problems that might have been introduced with new code. Without
    a changelog, it can be difficult to understand how the software has evolved over
    time. It can also make it difficult to roll back changes if necessary.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 版本管理可能会很混乱。因此，需要有一个简明的方法（以及其他人也跟随的方法），定义什么是版本发布，以及一个版本与下一个版本之间的变化。如果你不跟踪版本之间的变化，你可能不会理解每个版本中发生了什么变化，也无法识别新代码中可能引入的任何问题。没有变更日志，很难理解软件如何随着时间的推移而发展。它也可能使回滚更改变得困难（如果必要的话）。
- en: Semantic Versioning
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语义化版本控制
- en: '[Semantic Versioning](https://semver.org/) is just a number schema and standard
    practice in the industry for software development. It indicates the level of changes
    between this version and the previous one. There are three parts to a semantic
    version number, such as **1.8.42**, that follow the pattern of :'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[语义化版本控制](https://semver.org/)只是一个编号方案和业界的标准实践。它指示了该版本与前一个版本之间的变更程度。一个语义版本号有三个部分，例如**1.8.42**，遵循以下模式：'
- en: '*MAJOR.MINOR.PATCH*'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*MAJOR.MINOR.PATCH*'
- en: Each one of them means a different degree of change. A PATCH release indicates
    bug fixes or trivial changes (e.g. from 1.0.0 to 1.0.1). A MINOR release indicates
    adding/removing functionality or backwards compatible changes of functionality
    (e.g. from 1.0.0 to 1.1.0). A MAJOR release indicates adding/removing functionality
    and potentially backwards in-compatible changes such as breaking changes (e.g.
    from 1.0.0 to 2.0.0).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 每个部分代表了不同程度的变化。PATCH 版本发布表示错误修复或微小更改（例如从 1.0.0 到 1.0.1）。MINOR 版本发布表示添加/删除功能或向后兼容的功能更改（例如从
    1.0.0 到 1.1.0）。MAJOR 版本发布表示添加/删除功能以及可能的向后不兼容的更改，例如破坏性更改（例如从 1.0.0 到 2.0.0）。
- en: I recommend a [talk](https://www.youtube.com/watch?v=4wPjo5C-v8Y) of Mike Miles,
    if you want a visual introduction into releases with semantic versioning. It’s
    a summary of what releases are and how semantic versioning with [git tags](https://git-scm.com/book/en/v2/Git-Basics-Tagging)
    allows us to create releases.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我推荐[迈克·迈尔斯](https://www.youtube.com/watch?v=4wPjo5C-v8Y)的一个讲座，如果你想要一个关于语义版本发布的视觉介绍。它总结了什么是发布，以及如何利用[git
    标签](https://git-scm.com/book/en/v2/Git-Basics-Tagging)来创建版本发布。
- en: 'About **git tags**: There are lightweight and annotated tags in git. A *lightweight*
    tag is just a pointer to a specific commit whereas an *annotated* tag is a full
    object in git.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 关于**git 标签**：git 中有轻量级标签和注释标签。一个*轻量级*标签只是指向特定提交的指针，而*注释*标签则是 git 中的一个完整对象。
- en: Create a release manually
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动创建版本发布
- en: Let’s create a release manually first and then automate it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先手动创建一个版本发布，然后再进行自动化处理。
- en: If you remember, our example_app’s `__init__.py` file contains the version
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，我们的 example_app 的 `__init__.py` 文件包含了版本信息。
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: as well as the `pyproject.toml` file
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以及 `pyproject.toml` 文件
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'So the first thing we must do is to create an annotated git tag `v0.1.0` and
    add it to the latest commit in main:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们首先必须做的是创建一个注释的 git 标签 `v0.1.0` 并将其添加到主分支的最新提交中：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Please note that if no commit hash is specified at the end of the command, then
    git will use the current commit you are on.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果在命令末尾没有指定提交哈希，则 git 会使用你当前所在的提交。
- en: 'We can get a list of tags with:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下命令获取标签列表：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'and if we want delete it again:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要再次删除它：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'and get more information about the tag with:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 并通过以下命令获取有关该标签的更多信息：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can push the newly created tag to origin with
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下命令将新创建的标签推送到 origin：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'so that this git tag is now available on GitHub:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使得这个 git 标签现在可以在 GitHub 上使用：
- en: '![](../Images/b8daad7af39ff3448a87465c2b3a98b9.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b8daad7af39ff3448a87465c2b3a98b9.png)'
- en: 'Let’s manually create a new release in GitHub with this git tag:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们手动在 GitHub 上创建一个新的版本发布，并使用这个 git 标签：
- en: '![](../Images/a3bb26a8179a416567385bbe324da5f9.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a3bb26a8179a416567385bbe324da5f9.png)'
- en: We click on `Create a new release` , select our existing tag (that is already
    bound to a commit) and then generate release notes automatically by clicking on
    the `Generate release notes` button before we finally publish the release with
    the `Publish release` button.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们点击 `Create a new release`，选择我们现有的标签（已经绑定到提交），然后通过点击 `Generate release notes`
    按钮自动生成发布说明，最后用 `Publish release` 按钮发布该版本。
- en: '![](../Images/b49c9e26d316c7dab46743f61fb54f6c.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b49c9e26d316c7dab46743f61fb54f6c.png)'
- en: 'GitHub will automatically create a `tar` and a `zip` (assets) for the source
    code, but will not build the application! The result will look like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 将自动为源代码创建 `tar` 和 `zip`（资产），但不会构建应用程序！结果将如下所示：
- en: '![](../Images/cdb1cd2658a5eac059aefc07ca7c1579.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/cdb1cd2658a5eac059aefc07ca7c1579.png)'
- en: 'To summarise, the steps for a release are:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，发布的步骤是：
- en: create a new branch from your default branch (e.g. feature or fix branch)
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从你的默认分支创建一个新分支（例如功能或修复分支）
- en: make changes and increase the version (e.g. *pyproject.toml* and *__init__.py*)
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行更改并增加版本（例如 *pyproject.toml* 和 *__init__.py*）
- en: commit the feature/bug fix to the default branch (probably through a Pull Request)
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将功能/错误修复提交到默认分支（可能通过 Pull Request）
- en: add an *annotated* git tag (semantic version) to the commit
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个 *注释的* git 标签（语义版本）到提交中
- en: publish the release on GitHub with some additional information
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 GitHub 上发布版本，并附加一些额外信息
- en: Create a release automatically
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动创建发布
- en: As programmers, we don’t like to repeat ourselves. So there are plenty of tools
    that make these steps super easy for us. Here, I will introduce [Semantic Releases](https://python-semantic-release.readthedocs.io/en/latest/),
    a tool specifically for Python Projects.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们不喜欢重复自己。因此，有很多工具可以让这些步骤变得非常简单。在这里，我将介绍[Semantic Releases](https://python-semantic-release.readthedocs.io/en/latest/)，一个专门为
    Python 项目设计的工具。
- en: It’s a tool which automatically sets a version number in your repo, tags the
    code with the version number and creates a release! And this is all done using
    the contents of **Conventional Commit** style messages.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个自动在你的仓库中设置版本号、用版本号标记代码并创建发布的工具！这一切都是基于 **约定式提交** 风格消息的内容完成的。
- en: Conventional Commits
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 约定式提交
- en: What is the connection between semantic versioning and [conventional-commits](https://www.conventionalcommits.org/en/v1.0.0/)?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 语义版本控制和 [conventional-commits](https://www.conventionalcommits.org/en/v1.0.0/)
    之间有什么联系？
- en: Certain commit types can be used to automatically determine a semantic version
    bump!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 某些提交类型可以用于自动确定语义版本的提升！
- en: A `fix` commit is a PATCH.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `fix` 提交是 PATCH。
- en: A `feat` commit is a MINOR.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `feat` 提交是 MINOR。
- en: A commit with `BREAKING CHANGE` or `!` is a MAJOR.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有 `BREAKING CHANGE` 或 `!` 的提交是 MAJOR。
- en: Other types, e.g. `build`, `chore`, `ci`, `docs`, `style`, `refactor`, `perf`,
    `test` generally don’t increase the version.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 其他类型的提交，例如 `build`、`chore`、`ci`、`docs`、`style`、`refactor`、`perf`、`test` 通常不会增加版本。
- en: Check out the bonus section at the end to find out how to enforce conventional
    commits in your project!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 查看最后的附加部分，了解如何在你的项目中强制执行约定式提交！
- en: Automatic semantic releases (locally)
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动语义版本发布（本地）
- en: 'We can add the library with:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下命令添加库：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let’s go through the configuration settings that allow us to automatically
    generate change-logs and releases. In the `pyproject.toml`, we can add *semantic_release*
    as a tool:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入配置设置，以便自动生成变更日志和发布。在 `pyproject.toml` 中，我们可以将 *semantic_release* 作为工具添加：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`branch`: specifies the branch that the release should be based on, in this
    case the "main" branch.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`branch`：指定发布应基于的分支，在这种情况下是 "main" 分支。'
- en: '`version_variable`: specifies the file path and variable name of the version
    number in the source code. In this case, the version number is stored in the `__version__`
    variable in the file `src/example_app/__init__.py`.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version_variable`：指定源代码中版本号的文件路径和变量名称。在这种情况下，版本号存储在文件 `src/example_app/__init__.py`
    中的 `__version__` 变量中。'
- en: '`version_toml`: specifies the file path and variable name of the version number
    in the `pyproject.toml` file. In this case, the version number is stored in the
    `tool.poetry.version` variable of the `pyproject.toml` file'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version_toml`：指定`pyproject.toml`文件中版本号的文件路径和变量名称。在这种情况下，版本号存储在 `pyproject.toml`
    文件的 `tool.poetry.version` 变量中。'
- en: '`version_source`: Specifies the source of the version number. In this case,
    the version number is obtained from the tag (instead of commit)'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version_source`：指定版本号的来源。在这种情况下，版本号来自标签（而不是提交）。'
- en: '`commit_version_number`: This parameter is required when `version_source =
    "tag"`. It specifies whether the version number should be committed to the repository
    or not. In this case, it is set to true, which means that version number will
    be committed.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`commit_version_number`：当`version_source = "tag"`时，此参数是必需的。它指定是否将版本号提交到仓库。在这种情况下，它设置为
    true，这意味着版本号将被提交。'
- en: '`tag_commit`: Specifies whether a new tag should be created for the release
    commit. In this case, it is set to true, which means that a new tag will be created.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tag_commit`：指定是否为发布提交创建新的标签。在这种情况下，它设置为 true，这意味着将创建一个新的标签。'
- en: '`upload_to_pypi`: Specifies whether the package should be uploaded to the PyPI
    package repository. In this case, it is set to false, which means that the package
    will not be uploaded to PyPI.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`upload_to_pypi`：指定是否将软件包上传到 PyPI 包仓库。在这种情况下，它设置为 false，这意味着软件包不会上传到 PyPI。'
- en: '`upload_to_release`: Specifies whether the package should be uploaded to the
    GitHub release page. In this case, it is set to false, which means that the package
    will not be uploaded to GitHub releases.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`upload_to_release`：指定是否将软件包上传到 GitHub 发布页面。在这种情况下，它设置为 false，这意味着软件包不会上传到
    GitHub 发布页面。'
- en: '`hvcs`: Specifies the hosting version control system of the project. In this
    case, it is set to "github", which means that the project is hosted on GitHub.
    "gitlab" is also supported.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hvcs`：指定项目的托管版本控制系统。在这种情况下，它设置为 "github"，这意味着项目托管在 GitHub 上。"gitlab" 也是支持的。'
- en: 'We can update the files where we have defined the version of the project/module.
    For this we use the variable `version_variable` for normal files and `version_toml`
    for *.toml* files. The `version_source` defines the source of truth for the version.
    Because the version in these two files is tightly coupled with the git annotated
    tags, for example we create a git tag with every release automatically (flag `tag_commit`
    is set to true), we can use the source `tag` instead of the default value `commit`
    that looks for the last version in the commit messages. To be able to update the
    files and commit the changes, we [need to set the](https://github.com/relekang/python-semantic-release/issues/104)
    `[commit_version_number](https://github.com/relekang/python-semantic-release/issues/104)`
    [flag to true](https://github.com/relekang/python-semantic-release/issues/104).
    Because we don’t want to upload anything to the Python index [PyPi](https://pypi.org/),
    the flag `upload_to_pypi` is set to false. And for now we don’t want to upload
    anything to our releases. The `hvcs` is set to `github` (default), other values
    can be: `gitlab`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更新定义项目/模块版本的文件。为此，我们使用变量`version_variable`用于普通文件，`version_toml`用于*.toml*
    文件。`version_source`定义了版本的真实性来源。由于这两个文件中的版本与 git 注释标签紧密耦合，例如我们每次发布时自动创建 git 标签（标志`tag_commit`设置为
    true），我们可以使用源`tag`，而不是默认值`commit`，后者在提交信息中查找最后一个版本。为了能够更新文件并提交更改，我们[需要设置](https://github.com/relekang/python-semantic-release/issues/104)
    `[commit_version_number](https://github.com/relekang/python-semantic-release/issues/104)`
    [标志为 true](https://github.com/relekang/python-semantic-release/issues/104)。因为我们不想将任何东西上传到
    Python 索引 [PyPi](https://pypi.org/)，所以标志`upload_to_pypi`设置为 false。现在我们也不想将任何东西上传到我们的发布页面。`hvcs`设置为`github`（默认），其他值可以是：`gitlab`。
- en: 'We can test this locally by running a few commands, that I will add directly
    to our Makefile:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行几个命令在本地测试这一点，我将直接将这些命令添加到我们的 Makefile 中：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With the command *current-version* we get the version from the last git tag
    in the git tree:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令*current-version*我们可以从 git 树中的最后一个 git 标签获取版本：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we add a few commits in conventional commit style, e.g. `feat: new cool
    feature` or `fix: nasty bug`, then the command **next-version** will compute the
    version bump for that:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们以传统提交风格添加一些提交，例如 `feat: new cool feature` 或 `fix: nasty bug`，那么命令 **next-version**
    将计算版本号的增量：'
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Right now, we don’t have a CHANGELOG file in our project, so that when we run:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的项目中没有 CHANGELOG 文件，因此当我们运行：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'the output will be empty. But based on the commits we can create the upcoming
    changelog with:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是空的。但根据提交记录，我们可以使用以下方法创建即将发布的变更日志：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we push new commits (directly to main or through a PR) we could now publish
    a new release with:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们推送新的提交（直接到主分支或通过 PR），我们现在可以发布一个新版本：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The publish command will do a sequence of things:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 发布命令将执行一系列操作：
- en: Update or create the changelog file.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新或创建变更日志文件。
- en: Run [semantic-release version](https://python-semantic-release.readthedocs.io/en/latest/index.html#cmd-version).
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 [semantic-release version](https://python-semantic-release.readthedocs.io/en/latest/index.html#cmd-version)。
- en: Push changes to git.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将更改推送到 git。
- en: Run [build_command](https://python-semantic-release.readthedocs.io/en/latest/configuration.html#config-build-command)
    and upload the distribution file to your repository.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 [build_command](https://python-semantic-release.readthedocs.io/en/latest/configuration.html#config-build-command)
    并将分发文件上传到你的仓库。
- en: Run [semantic-release changelog](https://python-semantic-release.readthedocs.io/en/latest/index.html#cmd-changelog)
    and post to your vcs provider.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 [semantic-release changelog](https://python-semantic-release.readthedocs.io/en/latest/index.html#cmd-changelog)
    并发布到你的 VCS 提供者。
- en: Attach the files created by [build_command](https://python-semantic-release.readthedocs.io/en/latest/configuration.html#config-build-command)
    to GitHub releases.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将由 [build_command](https://python-semantic-release.readthedocs.io/en/latest/configuration.html#config-build-command)
    创建的文件附加到 GitHub 发布中。
- en: Every step can be of course configured or deactivated!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 每一步当然都可以配置或禁用！
- en: CI/CD
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CI/CD
- en: Let’s build a CI pipeline with GitHub Actions that runs the publish command
    of semantic-release with every commit to the main branch.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 GitHub Actions 构建一个 CI 流水线，每次提交到主分支时运行 semantic-release 的发布命令。
- en: 'While the overall structure remains the same as in *lint.yml*, *test.yml* or
    *pages.yml*, there are a few changes that need to be mentioned. In the step `Checkout
    repository`, we add a new token that is used to checkout the branch. That is because
    the default value `GITHUB_TOKEN` does not have the required permissions to operate
    on protected branches. Therefore, we must use a secret (**GH_TOKEN**) that contains
    a [Personal Access Token](https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line)
    with permissions. I will show later how the Personal Access Token can be generated.
    We also define `fetch-depth: 0` to fetch all history for all branches and tags.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '虽然整体结构与 *lint.yml*、*test.yml* 或 *pages.yml* 相同，但有一些变化需要说明。在步骤 `Checkout repository`
    中，我们添加了一个新的 token，用于检出分支。这是因为默认值 `GITHUB_TOKEN` 没有操作受保护分支所需的权限。因此，我们必须使用一个包含 [个人访问令牌](https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line)
    权限的秘密 (**GH_TOKEN**) 。稍后我会展示如何生成个人访问令牌。我们还定义了 `fetch-depth: 0` 以提取所有分支和标签的全部历史记录。'
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We install only the dependencies that are required for the semantic-release
    tool with:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仅安装 semantic-release 工具所需的依赖项：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the last step, we change some git configurations and run the publish command
    of semantic-release:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步，我们更改一些 git 配置并运行 semantic-release 的发布命令：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: By changing the git config, the user that commits will be “github-actions”.
    We run the publish command with DEBUG logs (stdout) and set the `commit_author`
    to “github-actions” explicitly. Alternatively to this command, we could use the
    GitHub action from semantic-release directly, but the set up steps of running
    the publish command are [very few](https://github.com/relekang/python-semantic-release/blob/master/action.sh)
    and the action uses a docker container that needs to be pulled every time. Because
    of that I prefer to make a simple run step instead.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更改 git 配置，提交的用户将会是“github-actions”。我们以 DEBUG 日志（stdout）运行发布命令，并显式将 `commit_author`
    设置为“github-actions”。除了这个命令，我们还可以直接使用 semantic-release 的 GitHub action，但设置步骤 [非常少](https://github.com/relekang/python-semantic-release/blob/master/action.sh)，且该
    action 每次都需要拉取 docker 容器。因此，我更倾向于采用简单的运行步骤。
- en: Because the publish command will make a commit, you might be worried that we
    could end up in an endless loop of workflows being triggered. But do not worry,
    the resulting commit will not trigger another GitHub Actions Workflow run. This
    is due to [limitations set by GitHub](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#using-the-github_token-in-a-workflow).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因为发布命令会生成提交，您可能会担心我们会陷入触发工作流的无限循环。但请放心，生成的提交不会触发另一个 GitHub Actions 工作流运行。这是由于
    [GitHub 设定的限制](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#using-the-github_token-in-a-workflow)。
- en: Create a Personal Access Token (PAT)
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建个人访问令牌（PAT）
- en: Personal access token are an alternative to using passwords for authentication
    to GitHub Enterprise Server when using the [GitHub API](https://docs.github.com/en/enterprise-server@3.4/rest/overview/other-authentication-methods#via-oauth-and-personal-access-tokens)
    or the [command line](https://docs.github.com/en/enterprise-server@3.4/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token#using-a-token-on-the-command-line).
    Personal access tokens are intended to access GitHub resources on behalf of yourself.
    To access resources on behalf of an organization, or for long-lived integrations,
    you should use a GitHub App. For more information, see “[About apps](https://docs.github.com/en/enterprise-server@3.4/developers/apps/getting-started-with-apps/about-apps).”
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 个人访问令牌是使用密码进行 GitHub Enterprise Server 身份验证的替代方案，当使用 [GitHub API](https://docs.github.com/en/enterprise-server@3.4/rest/overview/other-authentication-methods#via-oauth-and-personal-access-tokens)
    或 [命令行](https://docs.github.com/en/enterprise-server@3.4/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token#using-a-token-on-the-command-line)
    时。个人访问令牌旨在代表您访问 GitHub 资源。要代表组织访问资源或用于长期集成，您应该使用 GitHub 应用。有关更多信息，请参见“[关于应用](https://docs.github.com/en/enterprise-server@3.4/developers/apps/getting-started-with-apps/about-apps)”。
- en: 'In other words: We can create an **P**ersonal **A**ccess **T**oken and have
    GitHub actions store and use that **secret** to perform certain operations on
    our behalf. Keep in mind, if the PAT is compromised, it could be used to perform
    malicious actions on your GitHub repositories. It is therefore recommended to
    use GitHub OAuth Apps & GitHub Apps in organisations. For the purposes of this
    tutorial, we will be using a PAT to allow the GitHub actions pipeline to operate
    on our behalf.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说：我们可以创建一个 **P**ersonal **A**ccess **T**oken，并让 GitHub Actions 存储并使用该 **secret**
    代表我们执行某些操作。请记住，如果 PAT 被泄露，可能会被用于对您的 GitHub 仓库执行恶意操作。因此，建议在组织中使用 GitHub OAuth 应用和
    GitHub 应用。为了本教程的目的，我们将使用 PAT 允许 GitHub Actions 流水线代表我们操作。
- en: 'We can create a new access token by navigating to the `Settings` section of
    your GitHub user and following the instructions summarised in [Creating a Personal
    Access Token](https://docs.github.com/en/enterprise-server@3.4/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token).
    This will give us a window that will look like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过导航到 GitHub 用户的 `Settings` 部分并按照 [创建个人访问令牌](https://docs.github.com/en/enterprise-server@3.4/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token)
    中总结的说明来创建新的访问令牌。这将给我们一个看起来像这样的窗口：
- en: '![](../Images/ebb37e91c7cf7a89d51bca5eedaadd3a.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ebb37e91c7cf7a89d51bca5eedaadd3a.png)'
- en: Personal Access Token of an admin account with push access to the repos.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 具有推送访问权限的管理员帐户的个人访问令牌。
- en: By selecting the scopes, we define what permissions the token will have. For
    our use case, we need **push access** to the repositories which why the new PAT
    `GH_TOKEN` should have the `repo` permissions scope. That scope would authorise
    pushes to protected branches, given you don't have *Include administrators* set
    in the protected branch's settings.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择作用域，我们定义令牌将具有的权限。对于我们的用例，我们需要 **push access** 权限，因此新的 PAT `GH_TOKEN` 应该具有
    `repo` 权限作用域。该作用域将授权对受保护分支的推送，前提是您没有在受保护分支的设置中启用 *包括管理员*。
- en: 'Going back to the repository overview, in the **Settings** menu, we can either
    add an environment setting or a repository setting under the **Secrets** section:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 回到代码库概览，在 **设置** 菜单中，我们可以在 **密钥** 部分添加环境设置或库设置：
- en: '![](../Images/456cd350112cf1c5a3e7c5a198412418.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/456cd350112cf1c5a3e7c5a198412418.png)'
- en: Repository secrets are specific to a single repository (and all environments
    used in there), while environment secrets are specific to an environment. The
    GitHub runner can be configured to run in a specific environment which allows
    it to access the environment’s secrets. This makes sense when thinking of different
    stages (e.g. DEV vs PROD) but for this tutorial I’m fine with a **repository secret**.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库密钥特定于单个仓库（及其中使用的所有环境），而环境密钥特定于环境。GitHub运行器可以配置为在特定环境中运行，这允许它访问该环境的密钥。这在考虑不同阶段（例如DEV与PROD）时是有意义的，但对于本教程，我对**仓库密钥**感到满意。
- en: GitHub Actions Flow
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GitHub Actions 流程
- en: Now that we a have a few pipelines (linting, testing, releasing, documentation),
    we should think about the flow of actions with a commit to main! There are a few
    things we should be aware of, some of them specific to GitHub.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了几个管道（linting、testing、releasing、documentation），我们应该考虑主分支提交的动作流程！有一些我们需要注意的事项，其中一些是特定于GitHub的。
- en: Ideally, we want that a commit to main creates a push event that trigger the
    Testing and the Linting workflow. If these are successful, we run the release
    workflow which is responsible to detect if there should be a version bump based
    on conventional commits. If so, the release workflow will directly push to main,
    bumping the versions, adding a git tag and create a release. A published release
    should then, for example, update the documentation by running the documentation
    workflow.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们希望主分支的提交创建一个推送事件，从而触发测试和linting工作流。如果这些工作流成功，我们将运行发布工作流，该工作流负责基于传统提交检测是否需要版本提升。如果是这样，发布工作流将直接推送到主分支，提升版本，添加git标签并创建发布。发布的版本应当例如通过运行文档工作流来更新文档。
- en: '![](../Images/d4523a1b24aa2afa5655c7adc014ffbf.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d4523a1b24aa2afa5655c7adc014ffbf.png)'
- en: Expected flow of actions
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的动作流程
- en: Problems & considerations
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题与考虑
- en: If you read the last paragraph carefully or looked at the FlowChart above, you
    might have noticed that there are two commits to main. One initial (i.e. from
    a PR) and a second one for the release. Because our *lint.yml* and *test.yml*
    react on push events on the main branch, they would run twice! We should avoid
    running it twice to save resources. To achieve this, we can add the `[skip ci]`
    string to our version commit message. A custom commit message can be defined in
    the *pyproject.toml* file for the tool *semantic_release*.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你仔细阅读上一段或查看上面的流程图，你可能会注意到有两个主分支的提交。一个是初始的（即来自PR），另一个是用于发布的。由于我们的*lint.yml*和*test.yml*在主分支的推送事件下会触发，因此它们会运行两次！为了节省资源，我们应该避免两次运行。为此，我们可以在版本提交消息中添加`[skip
    ci]`字符串。可以在*pyproject.toml*文件中为工具*semantic_release*定义自定义提交消息。
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '2\. The workflow *pages.yml* currently runs on a push event to main. Updating
    the documentation could be something that we only want to do if there is a new
    release (We might be referencing the version in the documentation). We can change
    the trigger in the *pages.yml* file accordingly:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 工作流*pages.yml*当前在推送到主分支时运行。更新文档可能只是我们希望在有新版本发布时做的事情（我们可能会在文档中引用版本）。我们可以相应地更改*pages.yml*文件中的触发器：
- en: '[PRE19]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Building the documentation will now require a **published release**.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，构建文档将需要**已发布的版本**。
- en: '3\. The Release workflow should depend on the success of the Linting & Testing
    workflow. Currently we don’t have defined dependencies in our workflow files.
    We could have these workflows depend on the completion of defined workflow runs
    in a specific branch with the `[workflow_run](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_run)`
    event. However, if we specify multiple `workflows` for the `workflow_run` event:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 发布工作流应该依赖于linting和testing工作流的成功。目前，我们在工作流文件中没有定义依赖关系。我们可以让这些工作流依赖于特定分支上定义的工作流运行的完成，使用`[workflow_run](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_run)`事件。然而，如果我们为`workflow_run`事件指定多个`workflows`：
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: only one of the workflows needs to completed! This is not what we want. We expect
    that all **workflows** must be completed (and successful). Only then the release
    workflow should run. This is in contrast to what we get when we define dependencies
    between **jobs** in a single workflow. Read more about this inconsistency and
    shortcoming [here](https://github.com/community/community/discussions/16059).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 仅一个工作流需要完成！这不是我们所期望的。我们期望所有**工作流**都必须完成（并成功）。只有在这种情况下，发布工作流才应运行。这与在单个工作流中定义**作业**之间的依赖关系时得到的结果相反。更多关于这种不一致和不足的内容，请阅读[这里](https://github.com/community/community/discussions/16059)。
- en: 'As an alternative, we could use a sequential execution of pipelines:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代方案，我们可以使用流水线的顺序执行：
- en: '![](../Images/88bfe140d76fef3bfe6c8622c2cd4e07.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/88bfe140d76fef3bfe6c8622c2cd4e07.png)'
- en: The big downside with this idea is that it **a)** does not allow parallel execution
    and **b)** we won’t be able to see the dependency graph in GitHub.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这种想法的一个大缺点是它 **a)** 不允许并行执行和 **b)** 我们将无法在 GitHub 中查看依赖图。
- en: Solution
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Currently, the only way I see to deal with the above mentioned problems is to
    orchestrate the workflows in an orchestrator workflow.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我认为解决上述问题的唯一方法是将工作流在一个协调器工作流中进行协调。
- en: '![](../Images/591405e03e0593cd5fde44296b4d6f2b.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/591405e03e0593cd5fde44296b4d6f2b.png)'
- en: 'Let’s create this workflow file:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建这个工作流文件：
- en: The orchestrator is triggered when we push to the branch `main` .
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们推送到 `main` 分支时，协调器被触发。
- en: '![](../Images/958201b9b29998674fbb7a9c2a87526c.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/958201b9b29998674fbb7a9c2a87526c.png)'
- en: 'Only if both workflows: Testing & Linting are successful, the release workflow
    is called. This is defined in with the `needs` keyword. If we want to have more
    granular control over job executions (workflows), consider using the `if` keyword
    as well. But be aware of the *confusing* behaviour as explained in this [article](https://samanpavel.medium.com/github-actions-conditional-job-execution-e6aa363d2867).'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在两个工作流：Testing 和 Linting 都成功时，才会调用发布工作流。这在 `needs` 关键字中定义。如果我们希望对作业执行（工作流）有更细致的控制，也可以考虑使用
    `if` 关键字。但要注意，如 [这篇文章](https://samanpavel.medium.com/github-actions-conditional-job-execution-e6aa363d2867)
    所述的*令人困惑*行为。
- en: 'To make our workflows `lint.yml` , `test.yml` & `release.yml` callable by another
    workflow, we need to update the triggers:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的工作流 `lint.yml`、`test.yml` 和 `release.yml` 可以被另一个工作流调用，我们需要更新触发器：
- en: '[PRE21]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now the new workflow (Release) should only run if the workflows for quality
    checking, in this case the linting and testing, succeed.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，新工作流（Release）应该仅在质量检查工作流成功的情况下运行，这里指的是 linting 和 testing。
- en: Badge
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 徽章
- en: To create a badge, this time, I will use the platform [shields.io](https://shields.io/).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建徽章，这次我将使用平台 [shields.io](https://shields.io/)。
- en: It’s a website that generates badges for projects, which display information
    such as version, build status, and code coverage. It offers a wide range of templates
    and allows customization of appearance and creation of custom badges. The badges
    are updated automatically, providing real-time information about the project.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个为项目生成徽章的网站，徽章显示诸如版本、构建状态和代码覆盖率等信息。它提供了广泛的模板，并允许定制外观和创建自定义徽章。徽章会自动更新，提供项目的实时信息。
- en: 'For a release badge, I selected `GitHub release (latest SemVer)` :'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于发布徽章，我选择了 `GitHub release (latest SemVer)`：
- en: '![](../Images/530966bfab9ec5c4435c88aaebcce731.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/530966bfab9ec5c4435c88aaebcce731.png)'
- en: The badge markdown can be copied and added to the *README.md:*
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 徽章的 Markdown 可以复制并添加到 *README.md* 中：
- en: 'Our landing page of the GitHub now looks like this ❤ (I’ve cleaned up a little
    and provided a description):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 GitHub 登录页面现在看起来是这样的 ❤（我稍微整理了一下，并提供了描述）：
- en: '![](../Images/03ce33d4b73c88fa3a45a80fa85f104d.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03ce33d4b73c88fa3a45a80fa85f104d.png)'
- en: Congratulations! You have completed the main part of this tutorial! You have
    learned the essential steps for managing **software releases**. We began by manually
    creating a release, and then leveraged the power of **Conventional Commits** to
    automate our release process through a **CI pipeline**, which handles versioning
    on our behalf. To finalize, we added a **badge** in our README.md file, providing
    a clear and concise display of the latest version of our project for our users.
    With these techniques in hand, you’ll be able to efficiently and effectively manage
    your software releases.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经完成了本教程的主要部分！你已经学习了管理 **软件发布** 的基本步骤。我们首先手动创建了一个发布，然后利用 **Conventional
    Commits** 的力量，通过 **CI pipeline** 自动化我们的发布过程，处理版本控制。最后，我们在 README.md 文件中添加了 **徽章**，为用户提供了项目最新版本的清晰而简洁的显示。掌握了这些技巧，你将能够高效而有效地管理你的软件发布。
- en: 'The next part will be the last part, which covers: **Containerisation**!'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 下一部分将是最后一部分，涵盖：**容器化**！
- en: '[](https://johschmidt42.medium.com/membership?source=post_page-----206df3c1e3d3--------------------------------)
    [## Join Medium with my referral link - Johannes Schmidt'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://johschmidt42.medium.com/membership?source=post_page-----206df3c1e3d3--------------------------------)
    [## 通过我的推荐链接加入 Medium - Johannes Schmidt'
- en: Read every story from Johannes Schmidt (and thousands of other writers on Medium).
    Your membership fee directly…
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阅读 Johannes Schmidt 的每一篇故事（以及 Medium 上其他数千名作者的故事）。您的会员费直接…
- en: johschmidt42.medium.com](https://johschmidt42.medium.com/membership?source=post_page-----206df3c1e3d3--------------------------------)
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[johschmidt42.medium.com](https://johschmidt42.medium.com/membership?source=post_page-----206df3c1e3d3--------------------------------)'
- en: Bonus
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 奖励
- en: Ensure Conventional Commits
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确保使用规范提交
- en: 'We have seen that commits in a defined format can help us with versioning.
    In a collaborative project, we probably want to enforce this format for all commits
    to the default branch. Two popular tools can help developers follow the conventional
    commits format:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，按照定义格式的提交可以帮助我们进行版本控制。在一个协作项目中，我们可能希望对所有提交到默认分支的提交强制执行这种格式。两个流行的工具可以帮助开发者遵循规范提交格式：
- en: '[commitizen](https://github.com/commitizen/cz-cli)'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[commitizen](https://github.com/commitizen/cz-cli)'
- en: '[commitlint](https://github.com/conventional-changelog/commitlint)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[commitlint](https://github.com/conventional-changelog/commitlint)'
- en: However, some developers feel that these tools are a little restrictive and
    and avoid using them*. So it’s probably a bad idea to just hope that there will
    always be conventional commits. Therefore, it makes sense to enforce rules, such
    as the conventional commit format, on the server side!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一些开发者觉得这些工具有点限制性，因此避免使用它们*。所以仅仅希望总是有规范提交可能不是一个好主意。因此，在服务器端强制执行规则，如规范提交格式，才是明智的！
- en: '**The same applies to* [*pre-commit*](https://pre-commit.com/) *hooks, which
    is why I excluded them in this series.*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**同样适用于* [*pre-commit*](https://pre-commit.com/) *钩子，这也是我在这一系列中排除它们的原因。*'
- en: 'Unfortunately, it is currently not possible (May 2023) to block commits based
    on rules on GitHub as the [feature for this is still open](https://github.com/github/roadmap/issues/476).
    But we can try to get as close as possible via **branch protection rules** and
    a **CI workflow**. So here are the things that we require for such a strategy
    in our repo:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，目前（2023 年 5 月）在 GitHub 上基于规则阻止提交仍然不可行，因为 [该功能仍在开发中](https://github.com/github/roadmap/issues/476)。但我们可以通过**分支保护规则**和**CI
    工作流**尽可能接近这个目标。以下是我们在仓库中需要的策略：
- en: Commits to the protected default branch (e.g. main) should be restricted to
    **pull request** (PR) commits.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对受保护的默认分支（例如 main）的提交应该限制为**拉取请求**（PR）提交。
- en: Only [squashed commits](https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/configuring-pull-request-merges/configuring-commit-squashing-for-pull-requests)
    should be allowed*
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有 [压缩提交](https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/configuring-pull-request-merges/configuring-commit-squashing-for-pull-requests)
    应该被允许*。
- en: The **default commit message** presented when merging a pull request with squash
    should be the **pull request** **title**
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并拉取请求时展示的**默认提交信息**应该是**拉取请求** **标题**。
- en: If the only way to commit to the **protected** default branch (e.g. main) is
    via a pull request ([squashed commites](https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/configuring-pull-request-merges/configuring-commit-squashing-for-pull-requests)
    only), we can use a GitHub Action, such as [amannn/action-semantic-pull-request](https://github.com/amannn/action-semantic-pull-request),
    that ensures that the pull request’s title matches the [Conventional Commits spec](https://www.conventionalcommits.org/).
    So when we `squash and merge` the PR branch (assuming all required pipelines succeed),
    the suggested commit message is the PR title which was previously checked the
    by GitHub action run.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对**受保护**的默认分支（例如 main）的唯一提交方式是通过拉取请求（[压缩提交](https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/configuring-pull-request-merges/configuring-commit-squashing-for-pull-requests)
    仅限），我们可以使用 GitHub Action，如 [amannn/action-semantic-pull-request](https://github.com/amannn/action-semantic-pull-request)，确保拉取请求的标题符合
    [规范提交规范](https://www.conventionalcommits.org/)。这样，当我们 `squash and merge` PR 分支（假设所有必需的流水线成功）时，建议的提交信息就是
    PR 标题，该标题之前由 GitHub action 运行检查过。
- en: '**The squash and merge strategy is a popular method for merging code changes
    from a feature branch into the main branch, which involves condensing multiple
    commits in a feature branch into a single commit. This creates a linear and consistent
    git history, where each commit represents a specific change. However, this method
    does have its downsides, as it discards granular commit history, which can be
    valuable for understanding the development process. While it is possible to use
    rebase merging to retain this information, it can introduce complexity to the
    workflow. In this sense, the squash and merge strategy is favoured for its simplicity.*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**Squash and merge 策略是一种流行的代码合并方法，它将功能分支中的多个提交合并为一个提交。这种方法创建了一个线性的、一致的 git
    历史记录，其中每个提交代表一个特定的更改。然而，这种方法也有其缺点，因为它丢弃了详细的提交历史记录，这对于理解开发过程是有价值的。虽然可以使用 rebase
    合并来保留这些信息，但这可能会给工作流带来复杂性。从这个角度来看，squash and merge 策略因其简单性而受到青睐。*'
- en: Workflow
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作流
- en: 'Let’s create the GitHub Actions workflow for this strategy:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为这个策略创建 GitHub Actions 工作流：
- en: The **trigger event** `pull_request_target` is explained [here](https://github.com/amannn/action-semantic-pull-request#event-triggers).
    I use the suggested types `opened` , `edited` , `synchronize` . The `GITHUB_TOKEN`
    is passed as `env` to the action. So, whenever the title is changed in a PR, the
    pipeline is triggered. It only succeeds if the PR’s title is in the conventional
    commit format.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**触发事件** `pull_request_target` 的解释见 [这里](https://github.com/amannn/action-semantic-pull-request#event-triggers)。我使用了建议的类型
    `opened` 、`edited` 、`synchronize` 。`GITHUB_TOKEN` 被作为 `env` 传递给 action。因此，每当 PR
    的标题发生变化时，管道就会触发。只有当 PR 的标题符合约定的提交格式时，管道才会成功。'
- en: Please note that
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意
- en: you need to have this configuration in the main branch for the action to run
    at all (e.g. it won’t run within a PR that adds the action initially). Also if
    you change the configuration in a PR, the changes will not be reflected for the
    current PR — only subsequent ones after the changes are in the main branch.
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你需要在主分支中拥有此配置，以便 action 能够运行（例如，它不会在初次添加 action 的 PR 中运行）。此外，如果你在 PR 中更改配置，当前
    PR 中的更改将不会被反映 —— 只有在更改被合并到主分支后，随后的 PR 才会反映这些更改。
- en: So we must have this workflow in our default branch `main` first, only then
    we can see it in action.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们必须首先在默认分支 `main` 中拥有这个工作流，只有这样我们才能看到它的实际效果。
- en: Branch protection rules
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分支保护规则
- en: 'Next, in the *Settings* section of the GitHub repository we can create a **branch
    protection rule** for the *main* branch:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 GitHub 仓库的 *设置* 部分，我们可以为 *main* 分支创建一个 **分支保护规则**：
- en: '![](../Images/e0aa5515ece7b094d0198da1bbe2a40d.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e0aa5515ece7b094d0198da1bbe2a40d.png)'
- en: Branch Protection Rule for the main branch — Image by author
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 主要分支的分支保护规则 — 作者提供的图片
- en: Now a commit requires a PR with passing status checks (required workflow) before
    merging*.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一个提交需要一个通过状态检查（必需工作流）的 PR 才能合并*。
- en: A [required workflow](https://docs.github.com/en/actions/using-workflows/required-workflows)
    is triggered by pull request events and appears as a required status check, which
    blocks the ability to merge the pull request until the required workflow succeeds.
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个 [必需的工作流](https://docs.github.com/en/actions/using-workflows/required-workflows)
    由拉取请求事件触发，并作为必需的状态检查出现，这会阻止合并拉取请求，直到必需的工作流成功。
- en: '![](../Images/5ca948e901b844e9bae4e91b52018506.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5ca948e901b844e9bae4e91b52018506.png)'
- en: Required workflows — Image by author
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 所需工作流 — 作者提供的图片
- en: Organization owners have the ability to enforce specific workflows within their
    organisation, such as requiring a status check on pull requests. Unfortunately,
    this feature is only available for organisations and cannot be activated for individual
    accounts, therefore it is not possible to block merging.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 组织所有者有能力在其组织内强制执行特定的工作流，例如要求对拉取请求进行状态检查。不幸的是，这个功能仅对组织可用，个人账户无法激活，因此无法阻止合并。
- en: '**Please note that the rules won’t be enforced on a private repository until
    it is* [*moved to a GitHub Team or Enterprise organization account*](https://github.com/move_work/new)*!*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**请注意，规则不会在私有仓库中生效，直到它被* [*迁移到 GitHub Team 或 Enterprise 组织账户*](https://github.com/move_work/new)*！*'
- en: Squash & merge strategy
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Squash & merge 策略
- en: 'Finally, we can configure the PR options to use the PR’s title as the default
    commit message when we select the squash and merge button:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以配置 PR 选项，以便在选择 squash and merge 按钮时使用 PR 的标题作为默认提交消息：
- en: '![](../Images/3017b59691e8c5f4d4327784972535c0.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3017b59691e8c5f4d4327784972535c0.png)'
- en: Default commit message when squash and merge — Image by author
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的提交消息在“压缩和合并”时 — 图片由作者提供
- en: 'This way, we see a window like this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们会看到一个类似这样的窗口：
- en: '![](../Images/fe2a3f501d7814b92691932795f1f9a9.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/fe2a3f501d7814b92691932795f1f9a9.png)'
- en: Sqash & merge dialog in a PR — Image by author
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PR 中的“压缩和合并”对话框 — 图片由作者提供
- en: '*Be aware that a developer might alter the title’s name during the merge, which
    would bypass the strategy!*'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*请注意，开发者可能会在合并过程中更改标题名称，这将绕过策略！*'
- en: Even though we can’t completely ensure conventional commits on GitHub yet, we
    should try to get as close as we can.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们还不能完全确保在 GitHub 上使用传统的提交方式，但我们应尽量做到尽可能接近。
