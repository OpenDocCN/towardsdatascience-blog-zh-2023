- en: 'Unsupervised Learning with K-Means Clustering: Generate Color Palettes from
    Images'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ— ç›‘ç£å­¦ä¹ ä¸ K-Means èšç±»ï¼šä»å›¾åƒç”Ÿæˆé¢œè‰²è°ƒè‰²æ¿
- en: åŸæ–‡ï¼š[https://towardsdatascience.com/unsupervised-learning-with-k-means-clustering-generate-color-palettes-from-images-94bb8e6a1416](https://towardsdatascience.com/unsupervised-learning-with-k-means-clustering-generate-color-palettes-from-images-94bb8e6a1416)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://towardsdatascience.com/unsupervised-learning-with-k-means-clustering-generate-color-palettes-from-images-94bb8e6a1416](https://towardsdatascience.com/unsupervised-learning-with-k-means-clustering-generate-color-palettes-from-images-94bb8e6a1416)
- en: A comprehensive guide to unsupervised ML and the K-Means algorithm with a demo
    of a clustering use case for grouping image pixels by color
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è¿™æ˜¯å…³äºæ— ç›‘ç£æœºå™¨å­¦ä¹ å’Œ K-Means ç®—æ³•çš„å…¨é¢æŒ‡å—ï¼ŒåŒ…å«äº†ä¸€ä¸ªåŸºäºé¢œè‰²å¯¹å›¾åƒåƒç´ è¿›è¡Œåˆ†ç»„çš„èšç±»ç”¨ä¾‹çš„æ¼”ç¤º
- en: '[](https://nroy0110.medium.com/?source=post_page-----94bb8e6a1416--------------------------------)[![Nabanita
    Roy](../Images/83ab7766a28c79371ebf9517e1f273d2.png)](https://nroy0110.medium.com/?source=post_page-----94bb8e6a1416--------------------------------)[](https://towardsdatascience.com/?source=post_page-----94bb8e6a1416--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----94bb8e6a1416--------------------------------)
    [Nabanita Roy](https://nroy0110.medium.com/?source=post_page-----94bb8e6a1416--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://nroy0110.medium.com/?source=post_page-----94bb8e6a1416--------------------------------)[![Nabanita
    Roy](../Images/83ab7766a28c79371ebf9517e1f273d2.png)](https://nroy0110.medium.com/?source=post_page-----94bb8e6a1416--------------------------------)[](https://towardsdatascience.com/?source=post_page-----94bb8e6a1416--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----94bb8e6a1416--------------------------------)
    [Nabanita Roy](https://nroy0110.medium.com/?source=post_page-----94bb8e6a1416--------------------------------)'
- en: Â·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----94bb8e6a1416--------------------------------)
    Â·13 min readÂ·Apr 14, 2023
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Â·å‘è¡¨äº [Towards Data Science](https://towardsdatascience.com/?source=post_page-----94bb8e6a1416--------------------------------)
    Â·é˜…è¯»æ—¶é—´13åˆ†é’ŸÂ·2023å¹´4æœˆ14æ—¥
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/cf06c65cce12f976b12ba19ea8fc1473.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/cf06c65cce12f976b12ba19ea8fc1473.png)'
- en: Photo by [Billy Huynh](https://unsplash.com/@billy_huy?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[Billy Huynh](https://unsplash.com/@billy_huy?utm_source=medium&utm_medium=referral)
    çš„ç…§ç‰‡ï¼Œæ¥è‡ª [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)'
- en: Unsupervised learning is a method in which underlying patterns in data can be
    discovered without providing extra information (or labels/targets) to a machine
    learning algorithm. In this article, I have documented a pretty cool application
    of the K-Means clustering algorithm that I recently found out while reading some
    image-processing articles along with an introduction to unsupervised clustering
    approaches in machine learning.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: æ— ç›‘ç£å­¦ä¹ æ˜¯ä¸€ç§æ–¹æ³•ï¼Œåœ¨è¿™ç§æ–¹æ³•ä¸­ï¼Œå¯ä»¥å‘ç°æ•°æ®ä¸­çš„æ½œåœ¨æ¨¡å¼ï¼Œè€Œæ— éœ€å‘æœºå™¨å­¦ä¹ ç®—æ³•æä¾›é¢å¤–çš„ä¿¡æ¯ï¼ˆæˆ–æ ‡ç­¾/ç›®æ ‡ï¼‰ã€‚åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘è®°å½•äº†æœ€è¿‘åœ¨é˜…è¯»ä¸€äº›å›¾åƒå¤„ç†æ–‡ç« æ—¶å‘ç°çš„ä¸€ä¸ªç›¸å½“é…·çš„
    K-Means èšç±»ç®—æ³•åº”ç”¨ï¼Œä»¥åŠæ— ç›‘ç£èšç±»æ–¹æ³•åœ¨æœºå™¨å­¦ä¹ ä¸­çš„ä»‹ç»ã€‚
- en: '**Key Takeaways from this Article:**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**æœ¬æ–‡çš„å…³é”®è¦ç‚¹ï¼š**'
- en: '1ï¸âƒ£ Unsupervised ML: Introduction, Classifications, and Applications'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 1ï¸âƒ£ æ— ç›‘ç£æœºå™¨å­¦ä¹ ï¼šä»‹ç»ã€åˆ†ç±»å’Œåº”ç”¨
- en: 2ï¸âƒ£ Comprehensive Understanding of KMeans Clustering
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 2ï¸âƒ£ K-Means èšç±»çš„å…¨é¢ç†è§£
- en: 3ï¸âƒ£ A Step-by-Step K-Means Clustering Application using Scikit Learn Python
    Libary to Generate Color Palette from a Given Image
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 3ï¸âƒ£ ä½¿ç”¨ Scikit Learn Python åº“è¿›è¡Œé€æ­¥çš„ K-Means èšç±»åº”ç”¨ï¼Œä»¥ä»ç»™å®šå›¾åƒç”Ÿæˆé¢œè‰²è°ƒè‰²æ¿
- en: 4ï¸âƒ£ Read and process Images using Pillow, Requests and Numpy
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 4ï¸âƒ£ ä½¿ç”¨ Pillowã€Requests å’Œ Numpy è¯»å–å’Œå¤„ç†å›¾åƒ
- en: Letâ€™s Dive into Unsupervised Learning First
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬é¦–å…ˆæ·±å…¥äº†è§£æ— ç›‘ç£å­¦ä¹ 
- en: Machine Learning (ML), a technique in which machines can be trained to assimilate
    and learn from given data, can be broadly classified into supervised, unsupervised,
    and reinforcement learning.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: æœºå™¨å­¦ä¹ ï¼ˆMLï¼‰ï¼Œä¸€ç§é€šè¿‡ç»™å®šæ•°æ®æ¥è®­ç»ƒæœºå™¨ä»¥å¸æ”¶å’Œå­¦ä¹ çš„æŠ€æœ¯ï¼Œé€šå¸¸å¯ä»¥åˆ†ä¸ºç›‘ç£å­¦ä¹ ã€æ— ç›‘ç£å­¦ä¹ å’Œå¼ºåŒ–å­¦ä¹ ã€‚
- en: '![](../Images/4bc9157e3b35d7f16017be6ea7e05b91.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4bc9157e3b35d7f16017be6ea7e05b91.png)'
- en: 'Image Source: Author'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡æ¥æºï¼šä½œè€…
- en: '**âœ… *Supervised learning*** is where the machine is taught to learn by providing
    samples with metadata (which in ML terminology is called labels) to help the identification
    process. For example, in fraud detection use-cases, transactions are labeled fraud
    or genuine manually by analysts and then they are used to train an ML model. This
    ML model learns from examples of patterns or behaviors in fraudulent transactions
    and is enabled to apply the learning to a new transaction and assess if it matches
    the patterns of the fraud or genuine transactions that were used for learning.
    Then, the model associates the new transaction with either of the classes, fraud
    or genuine, depending on the identified patterns, and makes a prediction. Often,
    these predictions are associated with a confidence interval or probability to
    scores to indicate how well the pattern matched with the unseen sample. Higher
    scores indicate the ML model thinks that the prediction is likely to be correct.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**âœ… *ç›‘ç£å­¦ä¹ ***æ˜¯é€šè¿‡æä¾›å¸¦æœ‰å…ƒæ•°æ®ï¼ˆåœ¨æœºå™¨å­¦ä¹ æœ¯è¯­ä¸­ç§°ä¸ºæ ‡ç­¾ï¼‰çš„æ ·æœ¬æ¥æ•™æœºå™¨å­¦ä¹ çš„è¿‡ç¨‹ï¼Œä»¥å¸®åŠ©è¯†åˆ«è¿‡ç¨‹ã€‚ä¾‹å¦‚ï¼Œåœ¨æ¬ºè¯ˆæ£€æµ‹ç”¨ä¾‹ä¸­ï¼Œäº‹åŠ¡ç”±åˆ†æå¸ˆæ‰‹åŠ¨æ ‡è®°ä¸ºæ¬ºè¯ˆæˆ–çœŸå®ï¼Œç„¶åç”¨äºè®­ç»ƒæœºå™¨å­¦ä¹ æ¨¡å‹ã€‚è¿™ä¸ªæœºå™¨å­¦ä¹ æ¨¡å‹ä»æ¬ºè¯ˆäº‹åŠ¡çš„æ¨¡å¼æˆ–è¡Œä¸ºç¤ºä¾‹ä¸­å­¦ä¹ ï¼Œå¹¶èƒ½å¤Ÿå°†å­¦ä¹ åº”ç”¨åˆ°æ–°çš„äº‹åŠ¡ä¸­ï¼Œè¯„ä¼°å®ƒæ˜¯å¦ç¬¦åˆç”¨äºå­¦ä¹ çš„æ¬ºè¯ˆæˆ–çœŸå®äº‹åŠ¡çš„æ¨¡å¼ã€‚ç„¶åï¼Œæ¨¡å‹å°†æ–°äº‹åŠ¡ä¸æ¬ºè¯ˆæˆ–çœŸå®ç±»åˆ«ä¹‹ä¸€å…³è”ï¼Œæ ¹æ®è¯†åˆ«çš„æ¨¡å¼è¿›è¡Œé¢„æµ‹ã€‚é€šå¸¸ï¼Œè¿™äº›é¢„æµ‹ä¼šä¸ç½®ä¿¡åŒºé—´æˆ–æ¦‚ç‡å¾—åˆ†ç›¸å…³ï¼Œä»¥æŒ‡ç¤ºæ¨¡å¼ä¸æœªè§æ ·æœ¬çš„åŒ¹é…ç¨‹åº¦ã€‚è¾ƒé«˜çš„å¾—åˆ†è¡¨ç¤ºæœºå™¨å­¦ä¹ æ¨¡å‹è®¤ä¸ºé¢„æµ‹å¯èƒ½æ˜¯æ­£ç¡®çš„ã€‚'
- en: '**âœ… *Unsupervised learning*** also finds such patterns hidden in the provided
    sample. The difference is that there are no labels/classes associated. Unsupervised
    techniques are great for exploring data and understanding behaviors that are otherwise
    difficult to recognize by humans from a huge dataset. *They are widely used for
    text categorization (like news articles), anomaly detection, satellite & spatial
    image processing, medical image analysis, customer segmentation, and recommendation
    engines to name a few.*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**âœ… *æ— ç›‘ç£å­¦ä¹ ***ä¹Ÿä¼šå‘ç°æ ·æœ¬ä¸­éšè—çš„è¿™äº›æ¨¡å¼ã€‚ä¸åŒä¹‹å¤„åœ¨äºæ²¡æœ‰æ ‡ç­¾/ç±»åˆ«ã€‚æ— ç›‘ç£æŠ€æœ¯éå¸¸é€‚åˆäºæ¢ç´¢æ•°æ®å’Œç†è§£é‚£äº›ä»åºå¤§çš„æ•°æ®é›†ä¸­éš¾ä»¥è¢«äººç±»è¯†åˆ«çš„è¡Œä¸ºã€‚*å®ƒä»¬å¹¿æ³›åº”ç”¨äºæ–‡æœ¬åˆ†ç±»ï¼ˆå¦‚æ–°é—»æ–‡ç« ï¼‰ã€å¼‚å¸¸æ£€æµ‹ã€å«æ˜Ÿä¸ç©ºé—´å›¾åƒå¤„ç†ã€åŒ»å­¦å›¾åƒåˆ†æã€å®¢æˆ·ç»†åˆ†å’Œæ¨èå¼•æ“ç­‰ã€‚*'
- en: Unsupervised learning is used for three main tasksâ€” *clustering, association,
    and dimensionality reduction.*
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: æ— ç›‘ç£å­¦ä¹ ç”¨äºä¸‰ä¸ªä¸»è¦ä»»åŠ¡â€”â€” *èšç±»ã€å…³è”å’Œé™ç»´ã€‚*
- en: '***Clustering*** is a technique in which samples are grouped automatically.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***èšç±»***æ˜¯ä¸€ç§è‡ªåŠ¨å°†æ ·æœ¬åˆ†ç»„çš„æŠ€æœ¯ã€‚'
- en: '***Association*** is a technique used to find relationships between features
    in a dataset.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***å…³è”***æ˜¯ä¸€ç§ç”¨äºå‘ç°æ•°æ®é›†ä¸­ç‰¹å¾ä¹‹é—´å…³ç³»çš„æŠ€æœ¯ã€‚'
- en: '***Dimensionality Reduction*** is a technique used to reduce the number of
    features in the dataset when it is high.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***é™ç»´***æ˜¯ä¸€ç§ç”¨äºå‡å°‘æ•°æ®é›†ä¸­é«˜ç»´ç‰¹å¾æ•°é‡çš„æŠ€æœ¯ã€‚'
- en: In this article, I will focus on clustering as a grouping technique.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘å°†é‡ç‚¹å…³æ³¨èšç±»ä½œä¸ºä¸€ç§åˆ†ç»„æŠ€æœ¯ã€‚
- en: Clustering in Machine Learning
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æœºå™¨å­¦ä¹ ä¸­çš„**èšç±»**
- en: Clustering could be performed for multiple applications, for example, assessing
    how similar or dissimilar are data-points from each other, how dense are the data
    points in a vector space, extracting topics, and so on. Primarily, there are four
    types of clustering techniques -
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: èšç±»å¯ä»¥ç”¨äºå¤šä¸ªåº”ç”¨ï¼Œä¾‹å¦‚è¯„ä¼°æ•°æ®ç‚¹ä¹‹é—´çš„ç›¸ä¼¼æˆ–ä¸åŒã€æ•°æ®ç‚¹åœ¨å‘é‡ç©ºé—´ä¸­çš„å¯†é›†ç¨‹åº¦ã€æå–ä¸»é¢˜ç­‰ã€‚ä¸»è¦æœ‰å››ç§ç±»å‹çš„èšç±»æŠ€æœ¯â€”â€”
- en: '![](../Images/0b9ff0506563862bd8a58b3abf33dc44.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0b9ff0506563862bd8a58b3abf33dc44.png)'
- en: 'Image Source: Author'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡æ¥æºï¼šä½œè€…
- en: '***Centroid-based Clustering*** is where groups of data points are identified
    by the average distance from a centroid. There could be multiple centroids and
    an initial centroid is optimized over multiple passes. This technique is simple,
    efficient, and effective, however, it is sensitive to initial hyperparameter configurations.
    **K-Means clustering is the most-popular clustering algorithm that belongs to
    this school of techniques.**'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***åŸºäºä¸­å¿ƒç‚¹çš„èšç±»***æ˜¯é€šè¿‡è®¡ç®—æ•°æ®ç‚¹åˆ°ä¸­å¿ƒç‚¹çš„å¹³å‡è·ç¦»æ¥è¯†åˆ«æ•°æ®ç‚¹çš„ç»„ã€‚å¯ä»¥æœ‰å¤šä¸ªä¸­å¿ƒç‚¹ï¼Œå¹¶ä¸”åˆå§‹ä¸­å¿ƒç‚¹ä¼šåœ¨å¤šä¸ªè¿­ä»£ä¸­è¿›è¡Œä¼˜åŒ–ã€‚è¿™ç§æŠ€æœ¯ç®€å•ã€é«˜æ•ˆä¸”æœ‰æ•ˆï¼Œä½†å¯¹åˆå§‹è¶…å‚æ•°é…ç½®æ•æ„Ÿã€‚**Kå‡å€¼èšç±»æ˜¯æœ€å—æ¬¢è¿çš„å±äºè¿™ç§æŠ€æœ¯çš„èšç±»ç®—æ³•ã€‚**'
- en: '***Density-based Clustering*** groups high-density areas into clusters. These
    are useful for spatial data processing. For example, this technique could be used
    to locate areas with a high concentration of COVID-19-infected households, locate
    densely populated areas, or deforestation. **DBSCAN (Density-Based Spatial Clustering
    of Applications with Noise) is the most common algorithm that is used for detecting
    density-based clusters.** Usually, these algorithms ignore outliers.'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***åŸºäºå¯†åº¦çš„èšç±»*** å°†é«˜å¯†åº¦åŒºåŸŸåˆ†ç»„ä¸ºç°‡ã€‚è¿™å¯¹äºç©ºé—´æ•°æ®å¤„ç†éå¸¸æœ‰ç”¨ã€‚ä¾‹å¦‚ï¼Œè¿™ç§æŠ€æœ¯å¯ä»¥ç”¨æ¥å®šä½COVID-19æ„ŸæŸ“å®¶åº­çš„é«˜å¯†åº¦åŒºåŸŸã€å®šä½äººå£å¯†é›†åŒºæˆ–è¿›è¡Œæ£®æ—ç ä¼åˆ†æã€‚**DBSCANï¼ˆåŸºäºå¯†åº¦çš„ç©ºé—´èšç±»ä¸å™ªå£°ï¼‰æ˜¯æœ€å¸¸ç”¨äºæ£€æµ‹åŸºäºå¯†åº¦çš„ç°‡çš„ç®—æ³•ã€‚**
    é€šå¸¸ï¼Œè¿™äº›ç®—æ³•ä¼šå¿½ç•¥å¼‚å¸¸å€¼ã€‚'
- en: '***Distribution-based Clustering*** is used for detecting if the data has a
    particular distribution (probability distribution e.g. Gaussian) embedded subsets
    of the dataset. This technique is recommended if a particular type of distribution
    is known to be embedded in the data.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***åŸºäºåˆ†å¸ƒçš„èšç±»*** ç”¨äºæ£€æµ‹æ•°æ®ä¸­æ˜¯å¦åµŒå…¥äº†ç‰¹å®šçš„åˆ†å¸ƒï¼ˆä¾‹å¦‚é«˜æ–¯åˆ†å¸ƒï¼‰ã€‚å¦‚æœå·²çŸ¥æ•°æ®ä¸­åµŒå…¥äº†æŸç§ç‰¹å®šç±»å‹çš„åˆ†å¸ƒï¼Œæ¨èä½¿ç”¨è¿™ç§æŠ€æœ¯ã€‚'
- en: '***Hierarchical Clustering*** is used to detect if there are hierarchical relationships
    or taxonomies embedded in the data. This technique can be further classified into
    â€˜top-downâ€™ and â€˜bottom-upâ€™ approaches. **Dendrograms** are a data visualization
    technique that helps in the interpretation of the results of hierarchical clustering
    by creating taxonomy maps. Applications of hierarchical clustering are in understanding
    and charting evolution in life-sciences use-cases using DNA sequences, and tracking
    infected clusters during Covid 19, modeled into regions and drilled down into
    sub-regions.'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***å±‚æ¬¡èšç±»*** ç”¨äºæ£€æµ‹æ•°æ®ä¸­æ˜¯å¦å­˜åœ¨å±‚æ¬¡å…³ç³»æˆ–åˆ†ç±»æ³•ã€‚è¿™ç§æŠ€æœ¯å¯ä»¥è¿›ä¸€æ­¥åˆ†ä¸ºâ€œè‡ªä¸Šè€Œä¸‹â€å’Œâ€œè‡ªä¸‹è€Œä¸Šâ€æ–¹æ³•ã€‚**æ ‘çŠ¶å›¾** æ˜¯ä¸€ç§æ•°æ®å¯è§†åŒ–æŠ€æœ¯ï¼Œé€šè¿‡åˆ›å»ºåˆ†ç±»åœ°å›¾æ¥å¸®åŠ©è§£é‡Šå±‚æ¬¡èšç±»çš„ç»“æœã€‚å±‚æ¬¡èšç±»çš„åº”ç”¨åŒ…æ‹¬ä½¿ç”¨DNAåºåˆ—ç†è§£å’Œç»˜åˆ¶ç”Ÿå‘½ç§‘å­¦é¢†åŸŸçš„è¿›åŒ–è¿‡ç¨‹ï¼Œä»¥åŠåœ¨Covid-19æœŸé—´è·Ÿè¸ªæ„ŸæŸ“ç°‡ï¼Œå°†å…¶å»ºæ¨¡ä¸ºåŒºåŸŸå¹¶ç»†åŒ–ä¸ºå­åŒºåŸŸã€‚'
- en: There are other approaches and definitions to types of clustering including
    **Partitional/Exclusive Clustering** (where every data point is assigned to exactly
    one cluster), **Overlapping/Non-exclusive Clustering** (where a data point can
    be assigned to multiple clusters), **Fuzzy or Non-Fuzzy** Approaches as well as
    **Partial** (where a data point might not have any cluster assigned)or **Complete
    Clustering techniques** (where all data points have one or more clusters assigned).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: èšç±»çš„å…¶ä»–æ–¹æ³•å’Œå®šä¹‰åŒ…æ‹¬**åˆ’åˆ†/æ’ä»–æ€§èšç±»**ï¼ˆæ¯ä¸ªæ•°æ®ç‚¹è¢«åˆ†é…åˆ°ä¸€ä¸ªä¸”åªæœ‰ä¸€ä¸ªç°‡ï¼‰ã€**é‡å /éæ’ä»–æ€§èšç±»**ï¼ˆä¸€ä¸ªæ•°æ®ç‚¹å¯ä»¥è¢«åˆ†é…åˆ°å¤šä¸ªç°‡ï¼‰ã€**æ¨¡ç³Šæˆ–éæ¨¡ç³Š**
    æ–¹æ³•ä»¥åŠ**éƒ¨åˆ†**ï¼ˆæ•°æ®ç‚¹å¯èƒ½æ²¡æœ‰è¢«åˆ†é…åˆ°ä»»ä½•ç°‡ï¼‰æˆ–**å®Œå…¨èšç±»æŠ€æœ¯**ï¼ˆæ‰€æœ‰æ•°æ®ç‚¹éƒ½æœ‰ä¸€ä¸ªæˆ–å¤šä¸ªç°‡åˆ†é…ï¼‰ã€‚
- en: In the next section, I will focus on elaborating more on the K-Means clustering
    technique, the scikit-learn implementation, and the pros-cons of the algorithm.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸‹ä¸€éƒ¨åˆ†ï¼Œæˆ‘å°†é‡ç‚¹è®²è§£Kå‡å€¼èšç±»æŠ€æœ¯ã€scikit-learnå®ç°ä»¥åŠè¯¥ç®—æ³•çš„ä¼˜ç¼ºç‚¹ã€‚
- en: Introduction to K-Means Clustering
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kå‡å€¼èšç±»ä»‹ç»
- en: K-Means clustering is one of the most popular centroid-based clustering methods
    with partitioned clusters. The number of clusters is predefined, usually denoted
    by *k*. All data points are assigned to one and exactly one of these *k* clusters.
    Below is a demonstration of how (random) data points in a 2-dimensional space
    are clustered into 4 groups after 3 iterations (as set on the right-hand side).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Kå‡å€¼èšç±»æ˜¯æœ€å—æ¬¢è¿çš„åŸºäºä¸­å¿ƒç‚¹çš„èšç±»æ–¹æ³•ä¹‹ä¸€ï¼Œå…¶å…·æœ‰åˆ’åˆ†ç°‡ã€‚ç°‡çš„æ•°é‡æ˜¯é¢„å®šä¹‰çš„ï¼Œé€šå¸¸ç”¨ *k* è¡¨ç¤ºã€‚æ‰€æœ‰æ•°æ®ç‚¹éƒ½è¢«åˆ†é…åˆ°è¿™ *k* ä¸ªç°‡ä¸­çš„ä¸€ä¸ªä¸”ä»…ä¸€ä¸ªã€‚ä¸‹é¢æ¼”ç¤ºäº†åœ¨äºŒç»´ç©ºé—´ä¸­ï¼ˆéšæœºï¼‰æ•°æ®ç‚¹åœ¨ç»è¿‡3æ¬¡è¿­ä»£ï¼ˆå¦‚å³ä¾§æ‰€è®¾å®šï¼‰åè¢«åˆ’åˆ†æˆ4ç»„çš„è¿‡ç¨‹ã€‚
- en: '![](../Images/04645a77bdb5ee6eb23a40e08a3e3927.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04645a77bdb5ee6eb23a40e08a3e3927.png)'
- en: 'A KMeans Clustering Simulator by [METU â€” Middle East Technical University](https://www.metu.edu.tr/)
    | Image Source & Simulator Link: [https://user.ceng.metu.edu.tr/~akifakkus/courses/ceng574/k-means/](https://user.ceng.metu.edu.tr/~akifakkus/courses/ceng574/k-means/)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±[ä¸­ä¸œæŠ€æœ¯å¤§å­¦ï¼ˆMETUï¼‰](https://www.metu.edu.tr/)æä¾›çš„Kå‡å€¼èšç±»æ¨¡æ‹Ÿå™¨ | å›¾ç‰‡æ¥æºä¸æ¨¡æ‹Ÿå™¨é“¾æ¥ï¼š[https://user.ceng.metu.edu.tr/~akifakkus/courses/ceng574/k-means/](https://user.ceng.metu.edu.tr/~akifakkus/courses/ceng574/k-means/)
- en: Each cluster obtained from training a K-Means model contains a centroid (marked
    by the larger circle markers in the image above) and each data point is assigned
    to the cluster with the closest centroid. The centroid of a cluster is the mean
    of all the data points in that cluster. In short, the K-Means algorithm groups
    the data points into *k* clusters by minimizing the distance between the centroid
    and each data point in an iterative manner. Commonly, [Euclidean Distance](https://en.wikipedia.org/wiki/Euclidean_distance)
    is used to measure the distance between the centroid and the data point.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ä»è®­ç»ƒKå‡å€¼æ¨¡å‹è·å¾—çš„æ¯ä¸ªç°‡åŒ…å«ä¸€ä¸ªè´¨å¿ƒï¼ˆåœ¨ä¸Šå›¾ä¸­ç”±è¾ƒå¤§çš„åœ†åœˆæ ‡è®°ï¼‰å¹¶ä¸”æ¯ä¸ªæ•°æ®ç‚¹è¢«åˆ†é…åˆ°è·ç¦»æœ€è¿‘çš„è´¨å¿ƒçš„ç°‡ä¸­ã€‚ç°‡çš„è´¨å¿ƒæ˜¯è¯¥ç°‡ä¸­æ‰€æœ‰æ•°æ®ç‚¹çš„å‡å€¼ã€‚ç®€è€Œè¨€ä¹‹ï¼ŒKå‡å€¼ç®—æ³•é€šè¿‡è¿­ä»£åœ°æœ€å°åŒ–è´¨å¿ƒä¸æ¯ä¸ªæ•°æ®ç‚¹ä¹‹é—´çš„è·ç¦»ï¼Œå°†æ•°æ®ç‚¹åˆ†æˆ*k*ä¸ªç°‡ã€‚é€šå¸¸ï¼Œ[æ¬§å‡ é‡Œå¾—è·ç¦»](https://en.wikipedia.org/wiki/Euclidean_distance)ç”¨äºæµ‹é‡è´¨å¿ƒä¸æ•°æ®ç‚¹ä¹‹é—´çš„è·ç¦»ã€‚
- en: If you are familiar with the Cost Functions in ML, you would know that evaluation
    of this function estimates the error in the predictions made by an ML model, and
    enhancing a modelâ€™s performance incorporates strategies to minimize this function
    for optimal impact. In clustering, the cost function sums the distortions of the
    clusters.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ ç†Ÿæ‚‰æœºå™¨å­¦ä¹ ä¸­çš„æˆæœ¬å‡½æ•°ï¼Œä½ ä¼šçŸ¥é“è¿™ä¸ªå‡½æ•°çš„è¯„ä¼°ä¼°è®¡äº†æœºå™¨å­¦ä¹ æ¨¡å‹é¢„æµ‹çš„è¯¯å·®ï¼Œå¹¶ä¸”æå‡æ¨¡å‹æ€§èƒ½åŒ…æ‹¬äº†æœ€å°åŒ–è¯¥å‡½æ•°çš„ç­–ç•¥ä»¥å®ç°æœ€ç»ˆæ•ˆæœã€‚åœ¨èšç±»ä¸­ï¼Œæˆæœ¬å‡½æ•°æ±‚å’Œäº†å„ä¸ªç°‡çš„æ‰­æ›²åº¦ã€‚
- en: In terms of K-Means clustering, the distortion is the squared distance (given
    that Euclidean Distance is being used) between all the points to their closest
    cluster center. To obtain optimal clusters, the distortion function needs to be
    minimized.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: å°±Kå‡å€¼èšç±»è€Œè¨€ï¼Œæ‰­æ›²åº¦æ˜¯æ‰€æœ‰ç‚¹åˆ°å…¶æœ€è¿‘ç°‡ä¸­å¿ƒçš„å¹³æ–¹è·ç¦»ï¼ˆå‡è®¾ä½¿ç”¨äº†æ¬§å‡ é‡Œå¾—è·ç¦»ï¼‰ã€‚ä¸ºäº†è·å¾—æœ€ä½³ç°‡ï¼Œæ‰­æ›²å‡½æ•°éœ€è¦è¢«æœ€å°åŒ–ã€‚
- en: '![](../Images/f7c53036ed985aa61edeef71c3cec7c6.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f7c53036ed985aa61edeef71c3cec7c6.png)'
- en: 'Distortion Function | Image Source: Author | Reference: [http://cs229.stanford.edu/notes2020spring/cs229-notes7a.pdf](http://cs229.stanford.edu/notes2020spring/cs229-notes7a.pdf)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰­æ›²å‡½æ•° | å›¾åƒæ¥æºï¼šä½œè€… | å‚è€ƒæ–‡çŒ®ï¼š[http://cs229.stanford.edu/notes2020spring/cs229-notes7a.pdf](http://cs229.stanford.edu/notes2020spring/cs229-notes7a.pdf)
- en: The K-Means algorithm minimizes *J* with respect to *c* keeping *Âµ* fixed (when
    the data points are (re)distributed to the fixed centroids based on the distance)
    and then minimizes J with respect to *Âµ* keeping *c* fixed (when the centroids
    are (re)updated after (re)distributing the data points based on the distance).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Kå‡å€¼ç®—æ³•æœ€å°åŒ–*J*å…³äº*c*ï¼Œä¿æŒ*Âµ*å›ºå®šï¼ˆå½“æ•°æ®ç‚¹æ ¹æ®è·ç¦»è¢«ï¼ˆé‡æ–°ï¼‰åˆ†é…åˆ°å›ºå®šçš„è´¨å¿ƒæ—¶ï¼‰ï¼Œç„¶åæœ€å°åŒ–*J*å…³äº*Âµ*ï¼Œä¿æŒ*c*å›ºå®šï¼ˆå½“è´¨å¿ƒåœ¨æ ¹æ®è·ç¦»ï¼ˆé‡æ–°ï¼‰åˆ†é…æ•°æ®ç‚¹ä¹‹åï¼ˆé‡æ–°ï¼‰æ›´æ–°æ—¶ï¼‰ã€‚
- en: A variant of K-Means is K-Median which relies on the [Manhattan distance](https://wikipedia.org/wiki/Taxicab_geometry)
    from the centroid to a data point.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Kå‡å€¼çš„ä¸€ä¸ªå˜ä½“æ˜¯K-ä¸­ä½æ•°ï¼Œå®ƒä¾èµ–äºä»è´¨å¿ƒåˆ°æ•°æ®ç‚¹çš„[æ›¼å“ˆé¡¿è·ç¦»](https://wikipedia.org/wiki/Taxicab_geometry)ã€‚
- en: '**The K-Means Algorithm:**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kå‡å€¼ç®—æ³•ï¼š**'
- en: '![](../Images/19d93d1f18899400d852df3e48e17053.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/19d93d1f18899400d852df3e48e17053.png)'
- en: 'Image Source: Author'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾åƒæ¥æºï¼šä½œè€…
- en: '*Step 1:* Randomly initialize centroids for each of the *k* clusters'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*æ­¥éª¤1:* éšæœºåˆå§‹åŒ–æ¯ä¸ª*k*ç°‡çš„è´¨å¿ƒ'
- en: '*Step 2:* Assign each point to the closest centroid to group data points to
    the initial *k* clusters.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*æ­¥éª¤2:* å°†æ¯ä¸ªç‚¹åˆ†é…ç»™æœ€è¿‘çš„è´¨å¿ƒï¼Œå°†æ•°æ®ç‚¹åˆ†ç»„åˆ°åˆå§‹çš„*k*ç°‡ä¸­ã€‚'
- en: '*Step 3:* Recompute the centroid by getting the average of all points in each
    of the *k* clusters. Since the centroids are recomputed and therefore have been
    updated, the data points are also reassigned to the closest centroid thereafter.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*æ­¥éª¤3:* é€šè¿‡è®¡ç®—æ¯ä¸ª*k*ç°‡ä¸­æ‰€æœ‰ç‚¹çš„å¹³å‡å€¼æ¥é‡æ–°è®¡ç®—è´¨å¿ƒã€‚ç”±äºè´¨å¿ƒè¢«é‡æ–°è®¡ç®—å¹¶å› æ­¤è¢«æ›´æ–°ï¼Œæ•°æ®ç‚¹éšåä¹Ÿä¼šè¢«é‡æ–°åˆ†é…åˆ°æœ€è¿‘çš„è´¨å¿ƒã€‚'
- en: '*Step 4:* Recompute centroids and reassign data points to updated centroids
    *(i.e. repeat step 3)* until the points stop changing clusters.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*æ­¥éª¤4:* é‡æ–°è®¡ç®—è´¨å¿ƒå¹¶å°†æ•°æ®ç‚¹é‡æ–°åˆ†é…åˆ°æ›´æ–°åçš„è´¨å¿ƒï¼ˆå³é‡å¤æ­¥éª¤3ï¼‰ï¼Œç›´åˆ°ç‚¹ä¸å†æ”¹å˜ç°‡ã€‚'
- en: '**Scikit-Learnâ€™s K-Means Implementation:**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**Scikit-Learnçš„Kå‡å€¼å®ç°ï¼š**'
- en: '![](../Images/435d8bee27dd7ce1b3f6323f9394aa71.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/435d8bee27dd7ce1b3f6323f9394aa71.png)'
- en: 'Image Source: [https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html](https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾åƒæ¥æºï¼š[https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html](https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html)
- en: '[**K-Means implementation**](https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html)
    **in Scikit-Learn has the following key hyperparameters:**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[**Kå‡å€¼å®ç°**](https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html)
    **åœ¨Scikit-Learnä¸­çš„å…³é”®è¶…å‚æ•°åŒ…æ‹¬ï¼š**'
- en: '*n_clusters*: The number of clusters that the user has to provide'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*n_clusters*: ç”¨æˆ·å¿…é¡»æä¾›çš„ç°‡çš„æ•°é‡'
- en: '*init*: The strategy to initialize the centroids. Even though they are randomly
    chosen, to speed up convergence and obtain optimal clusters, strategies like the
    K-means++ technique could be applied. Otherwise, â€˜randomâ€™ uses randomly initiated
    clusters. K-Means++ selects a centroid at random and then places the remaining
    *kâˆ’1* centroids such that they are maximally far away from another. [Hereâ€™s the
    paper for delving further into K-Means++.](https://dl.acm.org/doi/10.5555/1283383.1283494)'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*init*: åˆå§‹åŒ–è´¨å¿ƒçš„ç­–ç•¥ã€‚å°½ç®¡è¿™äº›è´¨å¿ƒæ˜¯éšæœºé€‰æ‹©çš„ï¼Œä¸ºäº†åŠ é€Ÿæ”¶æ•›å¹¶è·å¾—æœ€ä½³çš„èšç±»ï¼Œå¯ä»¥åº”ç”¨åƒ K-means++ æŠ€æœ¯è¿™æ ·çš„ç­–ç•¥ã€‚å¦åˆ™ï¼Œâ€˜randomâ€™
    ä½¿ç”¨éšæœºåˆå§‹åŒ–çš„èšç±»ã€‚K-Means++ éšæœºé€‰æ‹©ä¸€ä¸ªè´¨å¿ƒï¼Œç„¶åå°†å‰©ä½™çš„ *kâˆ’1* ä¸ªè´¨å¿ƒæ”¾ç½®åœ¨å½¼æ­¤å°½å¯èƒ½è¿œçš„ä½ç½®ã€‚[è¿™é‡Œæœ‰ä¸€ç¯‡æ·±å…¥æ¢è®¨ K-Means++
    çš„è®ºæ–‡ã€‚](https://dl.acm.org/doi/10.5555/1283383.1283494)'
- en: '*n_init*: Number of times the k-means algorithm is run with different centroid
    seeds. If this is set to 1, then the clusters might emerge highly imbalanced for
    sparse data. To mitigate this issue, *n_init* number of times the clustering algorithm
    is applied and the cluster distributions with the best inertia (performance evaluation
    metric for clustering) are returned.'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*n_init*: K-means ç®—æ³•è¿è¡Œçš„æ¬¡æ•°ï¼Œæ¯æ¬¡ä½¿ç”¨ä¸åŒçš„è´¨å¿ƒç§å­ã€‚å¦‚æœè®¾ç½®ä¸º 1ï¼Œåˆ™å¯¹äºç¨€ç–æ•°æ®ï¼Œç°‡å¯èƒ½ä¼šå‡ºç°é«˜åº¦ä¸å¹³è¡¡ã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œ*n_init*
    æ¬¡æ•°çš„èšç±»ç®—æ³•è¢«åº”ç”¨ï¼Œå¹¶è¿”å›å…·æœ‰æœ€ä½³æƒ¯æ€§ï¼ˆç”¨äºèšç±»çš„æ€§èƒ½è¯„ä¼°æŒ‡æ ‡ï¼‰çš„ç°‡åˆ†å¸ƒã€‚'
- en: '*max_iter*: Maximum number of times the centroids can be recomputed. This comes
    in handy for large datasets where the time taken to process is high but a low
    max_iter can also result in sub-optimal clusters when the algorithm is terminated
    before convergence is reached.'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*max_iter*: è´¨å¿ƒå¯ä»¥è¢«é‡æ–°è®¡ç®—çš„æœ€å¤§æ¬¡æ•°ã€‚è¿™å¯¹äºå¤„ç†æ—¶é—´è¾ƒé•¿çš„å¤§æ•°æ®é›†éå¸¸æœ‰ç”¨ï¼Œä½†ä½çš„ max_iter ä¹Ÿå¯èƒ½å¯¼è‡´åœ¨ç®—æ³•æ”¶æ•›ä¹‹å‰è¢«ç»ˆæ­¢ï¼Œä»è€Œå¯¼è‡´äºšæœ€ä½³ç°‡ã€‚'
- en: '*algorithm*: A choice between Lloyd or Elkan. The â€˜Lloydâ€™s algorithmâ€™ is generally
    used for K-Means. In Wikipedia, it is stated that this algorithm (by [Stuart P.
    Lloyd, Bell Labs, 1957](https://en.wikipedia.org/wiki/Lloyd%27s_algorithm)) is
    used for finding evenly spaced sets of points in subsets of [Euclidean spaces](https://en.wikipedia.org/wiki/Euclidean_space)
    (i.e. establish centroids) and partitions of these subsets into well-shaped and
    uniformly sized convex cells (assignment and clustering data points related to
    the centroids).'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*algorithm*: é€‰æ‹© Lloyd æˆ– Elkanã€‚â€˜Lloydâ€™s algorithmâ€™ é€šå¸¸ç”¨äº K-Meansã€‚åœ¨ç»´åŸºç™¾ç§‘ä¸­æŒ‡å‡ºï¼Œè¿™ç§ç®—æ³•ï¼ˆç”±
    [Stuart P. Lloyd, Bell Labs, 1957](https://en.wikipedia.org/wiki/Lloyd%27s_algorithm)ï¼‰ç”¨äºåœ¨
    [æ¬§å‡ é‡Œå¾—ç©ºé—´](https://en.wikipedia.org/wiki/Euclidean_space) çš„å­é›†ï¼ˆå³å»ºç«‹è´¨å¿ƒï¼‰ä¸­å¯»æ‰¾å‡åŒ€åˆ†å¸ƒçš„ç‚¹é›†ï¼Œå¹¶å°†è¿™äº›å­é›†åˆ’åˆ†ä¸ºå½¢çŠ¶è‰¯å¥½ä¸”å¤§å°å‡åŒ€çš„å‡¸å•å…ƒï¼ˆåˆ†é…å’Œèšç±»ä¸è´¨å¿ƒç›¸å…³çš„æ•°æ®ç‚¹ï¼‰ã€‚'
- en: '**Now, letâ€™s look at the key attributes available for training:**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**ç°åœ¨ï¼Œè®©æˆ‘ä»¬æ¥çœ‹çœ‹è®­ç»ƒä¸­å¯ç”¨çš„å…³é”®å±æ€§ï¼š**'
- en: '*cluster_centers_* : array of co-ordinates of centroids'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*cluster_centers_* : è´¨å¿ƒçš„åæ ‡æ•°ç»„'
- en: '*labels_* : labels for each data point'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*labels_* : æ¯ä¸ªæ•°æ®ç‚¹çš„æ ‡ç­¾'
- en: '*inertia_*: sum of squared distances of samples to their closest cluster center,
    weighted by the sample weights if provided. This is often used for assessing how
    well the clusters are formed.'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*inertia_*: æ ·æœ¬åˆ°å…¶æœ€è¿‘ç°‡ä¸­å¿ƒçš„å¹³æ–¹è·ç¦»ä¹‹å’Œï¼Œå¦‚æœæä¾›äº†æ ·æœ¬æƒé‡ï¼Œåˆ™æŒ‰æ ·æœ¬æƒé‡åŠ æƒã€‚è¿™é€šå¸¸ç”¨äºè¯„ä¼°ç°‡çš„å½¢æˆæƒ…å†µã€‚'
- en: Note that, unlike supervised approaches, the model is fitted on only the training
    data. Therefore, the *fit*, *fit_transform*, and *fit_predict* methods will only
    take one argument, that is, the dataset under observation.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œä¸ç›‘ç£å­¦ä¹ æ–¹æ³•ä¸åŒï¼Œæ¨¡å‹ä»…åœ¨è®­ç»ƒæ•°æ®ä¸Šè¿›è¡Œæ‹Ÿåˆã€‚å› æ­¤ï¼Œ*fit*ã€*fit_transform* å’Œ *fit_predict* æ–¹æ³•å°†åªæ¥å—ä¸€ä¸ªå‚æ•°ï¼Œå³è§‚å¯Ÿçš„æ•°æ®é›†ã€‚
- en: A detailed overview of all the available hyperparameters, attributes, and methods
    is [here](https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€æœ‰å¯ç”¨è¶…å‚æ•°ã€å±æ€§å’Œæ–¹æ³•çš„è¯¦ç»†æ¦‚è¿°è§[æ­¤å¤„](https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html)ã€‚
- en: '**âœ… Why is the K-Means algorithm so popular?**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**âœ… ä¸ºä»€ä¹ˆ K-Means ç®—æ³•å¦‚æ­¤å—æ¬¢è¿ï¼Ÿ**'
- en: Simple, fast, efficient, and explainable
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç®€å•ã€å¿«é€Ÿã€é«˜æ•ˆä¸”æ˜“äºè§£é‡Š
- en: Scales easily for large datasets
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¯¹äºå¤§æ•°æ®é›†ï¼Œæ˜“äºæ‰©å±•
- en: Convergence for the common similarity measures like Euclidean distance, correlations,
    and cosine similarity is guaranteed
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¯¹äºå¸¸è§çš„ç›¸ä¼¼æ€§åº¦é‡ï¼Œå¦‚æ¬§å‡ é‡Œå¾—è·ç¦»ã€ç›¸å…³æ€§å’Œä½™å¼¦ç›¸ä¼¼æ€§ï¼Œæ”¶æ•›æ˜¯æœ‰ä¿è¯çš„
- en: Flexible and can be generalized to suit a variety of cluster sizes, shapes,
    and density
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: çµæ´»ä¸”å¯ä»¥æ¨å¹¿ä»¥é€‚åº”å„ç§ç°‡å¤§å°ã€å½¢çŠ¶å’Œå¯†åº¦
- en: '**âš ï¸Challenges:**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**âš ï¸ æŒ‘æˆ˜ï¼š**'
- en: Manually set the number of clusters (*k*)
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æ‰‹åŠ¨è®¾ç½®ç°‡çš„æ•°é‡ (*k*)
- en: Centroids are susceptible to outliers
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: è´¨å¿ƒå®¹æ˜“å—åˆ°å¼‚å¸¸å€¼çš„å½±å“
- en: K-means finds roughly circular clusters and performs poorly for varying sizes
    and densities. However, this can be eliminated by applying generalizing strategies.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: K-means èšç±»ç®—æ³•ä¸»è¦é€‚ç”¨äºå¤§è‡´åœ†å½¢çš„èšç±»ï¼Œå¯¹äºå¤§å°å’Œå¯†åº¦å˜åŒ–è¾ƒå¤§çš„æ•°æ®è¡¨ç°è¾ƒå·®ã€‚ç„¶è€Œï¼Œé€šè¿‡åº”ç”¨æ³›åŒ–ç­–ç•¥ï¼Œå¯ä»¥æ¶ˆé™¤è¿™ä¸€é—®é¢˜ã€‚
- en: Color Palette Generator
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: è‰²å½©è°ƒè‰²æ¿ç”Ÿæˆå™¨
- en: 'A typical clustering process includes:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªå…¸å‹çš„èšç±»è¿‡ç¨‹åŒ…æ‹¬ï¼š
- en: â¡ï¸ preparing the data â¡ï¸ vectorizing them (for example similarity scores embeddings
    for texts or RGB values in the case of images) â¡ï¸ running the chosen clustering
    algorithm â¡ï¸ interpreting the results â¡ï¸ making adjustments by retraining the
    model with updated data or hyperparameters.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: â¡ï¸ å‡†å¤‡æ•°æ® â¡ï¸ å‘é‡åŒ–æ•°æ®ï¼ˆä¾‹å¦‚æ–‡æœ¬çš„ç›¸ä¼¼æ€§è¯„åˆ†åµŒå…¥æˆ–å›¾åƒçš„ RGB å€¼ï¼‰ â¡ï¸ è¿è¡Œæ‰€é€‰æ‹©çš„èšç±»ç®—æ³• â¡ï¸ è§£é‡Šç»“æœ â¡ï¸ é€šè¿‡ä½¿ç”¨æ›´æ–°çš„æ•°æ®æˆ–è¶…å‚æ•°é‡æ–°è®­ç»ƒæ¨¡å‹æ¥è¿›è¡Œè°ƒæ•´ã€‚
- en: '**ğŸ’¡ *In this project, given an image, the objective is to cluster the pixel
    RGB values, apply the clustering algorithm and obtain the cluster centers that
    represent the palette colors. Bonus: Sort palette colors & use them in Pythonâ€™s
    data visualization libraries.***'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**ğŸ’¡ *åœ¨è¿™ä¸ªé¡¹ç›®ä¸­ï¼Œç»™å®šä¸€å¼ å›¾ç‰‡ï¼Œç›®æ ‡æ˜¯å¯¹åƒç´  RGB å€¼è¿›è¡Œèšç±»ï¼Œåº”ç”¨èšç±»ç®—æ³•å¹¶è·å¾—ä»£è¡¨è°ƒè‰²æ¿é¢œè‰²çš„èšç±»ä¸­å¿ƒã€‚é™„åŠ ä»»åŠ¡ï¼šå¯¹è°ƒè‰²æ¿é¢œè‰²è¿›è¡Œæ’åºï¼Œå¹¶åœ¨
    Python çš„æ•°æ®å¯è§†åŒ–åº“ä¸­ä½¿ç”¨å®ƒä»¬ã€‚***'
- en: '![](../Images/a0c81ce5b5518b3362f04aec00ed6163.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a0c81ce5b5518b3362f04aec00ed6163.png)'
- en: 'Image Source: Author'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡æ¥æºï¼šä½œè€…
- en: '**Letâ€™s beginğŸ‘**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**è®©æˆ‘ä»¬å¼€å§‹å§ğŸ‘**'
- en: '**Step 1: Get the image data**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**æ­¥éª¤ 1ï¼šè·å–å›¾åƒæ•°æ®**'
- en: 'First and foremost, we need an image and get the RGB values for each pixel.
    To represent a color on the screen, each pixel actually consists of three color
    components: **red (R), green (G), and blue (B)**. These are frequently referred
    to as the pixelâ€™s RGB value.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦ä¸€å¼ å›¾ç‰‡å¹¶è·å–æ¯ä¸ªåƒç´ çš„ RGB å€¼ã€‚ä¸ºäº†åœ¨å±å¹•ä¸Šè¡¨ç¤ºé¢œè‰²ï¼Œæ¯ä¸ªåƒç´ å®é™…ä¸Šç”±ä¸‰ä¸ªé¢œè‰²ç»„ä»¶ç»„æˆï¼š**çº¢è‰² (R)ã€ç»¿è‰² (G) å’Œè“è‰² (B)**ã€‚è¿™äº›é€šå¸¸è¢«ç§°ä¸ºåƒç´ çš„
    RGB å€¼ã€‚
- en: '**Some Notes:**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**ä¸€äº›æ³¨æ„äº‹é¡¹ï¼š**'
- en: ğŸ”´RGB value of (255, 0, 0) is a red pixel
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ”´RGB å€¼ (255, 0, 0) æ˜¯ä¸€ä¸ªçº¢è‰²åƒç´ 
- en: ğŸŸ¢RGB value of (0, 255, 0) is a green pixel
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸŸ¢RGB å€¼ (0, 255, 0) æ˜¯ä¸€ä¸ªç»¿è‰²åƒç´ 
- en: ğŸ”µRGB value of (0, 0, 255) is a blue pixel
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ”µRGB å€¼ (0, 0, 255) æ˜¯ä¸€ä¸ªè“è‰²åƒç´ 
- en: âšªRGB of (255, 255, 255) is a white pixel
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: âšªRGB å€¼ (255, 255, 255) æ˜¯ä¸€ä¸ªç™½è‰²åƒç´ 
- en: âš«RGB of (0, 0, 0) is a black pixel
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: âš«RGB å€¼ (0, 0, 0) æ˜¯ä¸€ä¸ªé»‘è‰²åƒç´ 
- en: Here is how it is done in Python using Pillow Python Library. In *line 5*, I
    read an image using ***Image.open()*** and in *line 15*, I converted the image
    into a [Numpy array](https://numpy.org/doc/stable/reference/generated/numpy.array.html)
    of RGB codes and finally, put the values into a [Pandas DataFrame](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html)
    in *line 18*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯å¦‚ä½•ä½¿ç”¨ Pillow Python åº“åœ¨ Python ä¸­å®Œæˆè¿™é¡¹å·¥ä½œçš„ã€‚åœ¨ *ç¬¬ 5 è¡Œ*ï¼Œæˆ‘ä½¿ç”¨ ***Image.open()*** è¯»å–äº†å›¾ç‰‡ï¼Œåœ¨
    *ç¬¬ 15 è¡Œ*ï¼Œæˆ‘å°†å›¾ç‰‡è½¬æ¢ä¸º [Numpy array](https://numpy.org/doc/stable/reference/generated/numpy.array.html)
    çš„ RGB ä»£ç ï¼Œæœ€ååœ¨ *ç¬¬ 18 è¡Œ*ï¼Œå°†è¿™äº›å€¼æ”¾å…¥ [Pandas DataFrame](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html)
    ä¸­ã€‚
- en: 'Image Source: Author'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡æ¥æºï¼šä½œè€…
- en: You can simply use the ***image_variable_name*** (img in my case) to view the
    image or use **display(img)** or **img.show()** to show the image.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯ä»¥ç®€å•åœ°ä½¿ç”¨ ***image_variable_name***ï¼ˆåœ¨æˆ‘çš„ä¾‹å­ä¸­æ˜¯ imgï¼‰æ¥æŸ¥çœ‹å›¾åƒï¼Œæˆ–è€…ä½¿ç”¨ **display(img)** æˆ–
    **img.show()** æ¥æ˜¾ç¤ºå›¾åƒã€‚
- en: '![](../Images/f0634a8b9eddfbf3315ef9e6b4561f84.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0634a8b9eddfbf3315ef9e6b4561f84.png)'
- en: 'Image Source: Author'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡æ¥æºï¼šä½œè€…
- en: 'Here is how the RGB DataFrame turned out:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: RGB DataFrame çš„ç»“æœå¦‚ä¸‹ï¼š
- en: '![](../Images/6a59006d249a30a8f5cc09e190dc384f.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6a59006d249a30a8f5cc09e190dc384f.png)'
- en: 'Image Source: Author'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡æ¥æºï¼šä½œè€…
- en: Besides, to read images from an URL, hereâ€™s the implementation where I used
    the [requests](https://pypi.org/project/requests/) library to fetch the image.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: æ­¤å¤–ï¼Œä¸ºäº†ä» URL è¯»å–å›¾ç‰‡ï¼Œä¸‹é¢æ˜¯æˆ‘ä½¿ç”¨ [requests](https://pypi.org/project/requests/) åº“æ¥è·å–å›¾ç‰‡çš„å®ç°ã€‚
- en: 'Image Source: Author'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡æ¥æºï¼šä½œè€…
- en: Next, follow the previous steps to get the RGB values and convert them to a
    DataFrame to proceed.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: æ¥ä¸‹æ¥ï¼ŒæŒ‰ç…§ä¹‹å‰çš„æ­¥éª¤è·å– RGB å€¼å¹¶å°†å…¶è½¬æ¢ä¸º DataFrame ä»¥ç»§ç»­å¤„ç†ã€‚
- en: '**Step 2: Clustering using SkLearnâ€™s K-Means Implementation**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**æ­¥éª¤ 2ï¼šä½¿ç”¨ SkLearn çš„ K-Means å®ç°è¿›è¡Œèšç±»**'
- en: 'Now that I have the RGB values, I am using [K-Means clustering algorithm in
    scikit-learn](https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html).
    The parameters I have used are as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘å·²ç»æœ‰äº† RGB å€¼ï¼Œæˆ‘æ­£åœ¨ä½¿ç”¨ [scikit-learn ä¸­çš„ K-Means èšç±»ç®—æ³•](https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html)ã€‚æˆ‘ä½¿ç”¨çš„å‚æ•°å¦‚ä¸‹ï¼š
- en: '*n_cluster*: integer indicating the number of clusters. I have used 6\. This
    is also indicative of the number of colors in the palette since we will be picking
    out the cluster centers (~ RGB values) to represent the colors in the palette.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n_cluster*ï¼šè¡¨ç¤ºèšç±»æ•°é‡çš„æ•´æ•°ã€‚æˆ‘ä½¿ç”¨äº† 6ã€‚è¿™ä¸ªæ•°é‡ä¹Ÿè¡¨ç¤ºè°ƒè‰²æ¿ä¸­çš„é¢œè‰²æ•°é‡ï¼Œå› ä¸ºæˆ‘ä»¬å°†é€‰æ‹©èšç±»ä¸­å¿ƒï¼ˆ~ RGB å€¼ï¼‰æ¥ä»£è¡¨è°ƒè‰²æ¿ä¸­çš„é¢œè‰²ã€‚'
- en: '*random_state*: random seed for centroid initialization. I have used 0.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*random_state*ï¼šç”¨äºè´¨å¿ƒåˆå§‹åŒ–çš„éšæœºç§å­ã€‚æˆ‘ä½¿ç”¨äº† 0ã€‚'
- en: '*init*: centroid initialization method. I have used k-mean++ which selects
    initial cluster centroids using sampling based on an empirical probability distribution
    of the pointsâ€™ contribution to the overall inertia and then makes several trials
    at each sampling step to choose the best centroid among them.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*init*ï¼šè´¨å¿ƒåˆå§‹åŒ–æ–¹æ³•ã€‚æˆ‘ä½¿ç”¨äº†k-means++ï¼Œå®ƒé€šè¿‡åŸºäºç‚¹å¯¹æ•´ä½“æƒ¯æ€§çš„è´¡çŒ®çš„ç»éªŒæ¦‚ç‡åˆ†å¸ƒæ¥é€‰æ‹©åˆå§‹ç°‡è´¨å¿ƒï¼Œç„¶ååœ¨æ¯ä¸ªé‡‡æ ·æ­¥éª¤è¿›è¡Œå¤šæ¬¡è¯•éªŒï¼Œä»¥é€‰æ‹©æœ€ä½³çš„è´¨å¿ƒã€‚'
- en: '*n_init*: Number of times the k-means algorithm is run with different centroid
    seeds. Since I selected *init*: *K-means++*, *n_init* is automatically set to
    1.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n_init*ï¼šk-meansç®—æ³•ç”¨ä¸åŒçš„è´¨å¿ƒç§å­è¿è¡Œçš„æ¬¡æ•°ã€‚ç”±äºæˆ‘é€‰æ‹©äº†*init*: *K-means++*ï¼Œ*n_init*è¢«è‡ªåŠ¨è®¾ç½®ä¸º1ã€‚'
- en: Besides, I have used the defaults for *max_iter (300)* and *algorithm(Lloyd)*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: æ­¤å¤–ï¼Œæˆ‘ä½¿ç”¨äº†*max_iter (300)*å’Œ*algorithm(Lloyd)*çš„é»˜è®¤å€¼ã€‚
- en: Next, I used ***fit()*** method to fit the model on the RGB DataFrame in *line
    9*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: æ¥ä¸‹æ¥ï¼Œæˆ‘ä½¿ç”¨äº†***fit()***æ–¹æ³•å°†æ¨¡å‹æ‹Ÿåˆåˆ°*line 9*ä¸­çš„RGB DataFrameã€‚
- en: On successful training for the model, I accessed the *cluster_centers_* attribute*,*
    converted them to integers, and put them in *list*. This nested list is the paletteâ€™s
    colorâ€™s RGB values where each element is a list of R, G, and B values of the color
    it represents.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: æ¨¡å‹æˆåŠŸè®­ç»ƒåï¼Œæˆ‘è®¿é—®äº†*cluster_centers_*å±æ€§ï¼Œå°†å…¶è½¬æ¢ä¸ºæ•´æ•°ï¼Œå¹¶æ”¾å…¥*list*ä¸­ã€‚è¿™ä¸ªåµŒå¥—åˆ—è¡¨æ˜¯è°ƒè‰²æ¿é¢œè‰²çš„RGBå€¼ï¼Œå…¶ä¸­æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªåŒ…å«Rã€Gå’ŒBå€¼çš„åˆ—è¡¨ã€‚
- en: 'Image Source: Author'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾åƒæ¥æºï¼šä½œè€…
- en: '**Step 3 (optional): Reorder the cluster centers i.e. your palette colors**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**æ­¥éª¤3ï¼ˆå¯é€‰ï¼‰ï¼šé‡æ–°æ’åºç°‡è´¨å¿ƒï¼Œå³ä½ çš„è°ƒè‰²æ¿é¢œè‰²**'
- en: This is an optional step where I have ordered the colors based on the Value
    in their HSV representatives where H â€” Hue, S â€” Saturation, and V â€” Value. By
    accessing the last element of the [h, s, v] list after conversion using [colorsysâ€™s](https://docs.python.org/3/library/colorsys.html)
    rgb_to_hsv() method, I chose to order the list by the â€œValueâ€ which describes
    the brightness or intensity of the color. It is expressed by an integer between
    0 to 100 (percent), where 0 is completely black, and 100 is the brightest and
    reveals the most color.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ä¸ªå¯é€‰æ­¥éª¤ï¼Œæˆ‘æ ¹æ®å…¶HSVè¡¨ç¤ºä¸­çš„å€¼å¯¹é¢œè‰²è¿›è¡Œäº†æ’åºï¼Œå…¶ä¸­H â€” è‰²è°ƒï¼ŒS â€” é¥±å’Œåº¦ï¼ŒV â€” å€¼ã€‚é€šè¿‡ä½¿ç”¨[colorsys](https://docs.python.org/3/library/colorsys.html)çš„rgb_to_hsv()æ–¹æ³•è½¬æ¢åï¼Œè®¿é—®[h,
    s, v]åˆ—è¡¨çš„æœ€åä¸€ä¸ªå…ƒç´ ï¼Œæˆ‘é€‰æ‹©æŒ‰â€œå€¼â€æ’åºï¼Œè¯¥å€¼æè¿°äº†é¢œè‰²çš„äº®åº¦æˆ–å¼ºåº¦ã€‚å®ƒç”±0åˆ°100ï¼ˆç™¾åˆ†æ¯”ï¼‰ä¹‹é—´çš„æ•´æ•°è¡¨ç¤ºï¼Œå…¶ä¸­0æ˜¯å®Œå…¨é»‘è‰²ï¼Œ100æ˜¯æœ€äº®çš„ï¼Œæ˜¾ç¤ºå‡ºæœ€ä¸°å¯Œçš„é¢œè‰²ã€‚
- en: 'Image Source: Author'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾åƒæ¥æºï¼šä½œè€…
- en: Here is a summary to compare the palette before and after sorting.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ä¸ªæ€»ç»“ï¼Œç”¨äºæ¯”è¾ƒæ’åºå‰åçš„è°ƒè‰²æ¿ã€‚
- en: '![](../Images/06f4b38e027140ee70fe902282a01f76.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/06f4b38e027140ee70fe902282a01f76.png)'
- en: 'Image Source: Author'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾åƒæ¥æºï¼šä½œè€…
- en: The detailed code is in the notebook but here below is how I used Plotly to
    generate the palette.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: è¯¦ç»†ä»£ç åœ¨ç¬”è®°æœ¬ä¸­ï¼Œä½†ä¸‹é¢æ˜¯æˆ‘å¦‚ä½•ä½¿ç”¨Plotlyç”Ÿæˆè°ƒè‰²æ¿çš„ã€‚
- en: 'Image Source: Author'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾åƒæ¥æºï¼šä½œè€…
- en: '**Step 4: Cluster Analysis**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**æ­¥éª¤4ï¼šç°‡åˆ†æ**'
- en: In case you are curious about the pixels that were grouped together in the image,
    hereâ€™s how you can visualize them. Use the ***predict()*** method to predict the
    closest cluster to each sample in your data. Since this can be performed on your
    training data because we are not evaluating the performance, but rather assessing
    patterns in the data â€” the unlabelled training or unseen set, hence, to assign
    the data points in the RGB DataFrame, I passed it to the ***predict()*** in *line
    1*. Then, added the predicted array of cluster numbers back to the dataset.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ å¯¹å›¾åƒä¸­åˆ†ç»„åœ¨ä¸€èµ·çš„åƒç´ æ„Ÿåˆ°å¥½å¥‡ï¼Œè¿™é‡Œæœ‰ä¸€ç§å¯è§†åŒ–å®ƒä»¬çš„æ–¹æ³•ã€‚ä½¿ç”¨***predict()***æ–¹æ³•é¢„æµ‹æ•°æ®ä¸­æ¯ä¸ªæ ·æœ¬æœ€æ¥è¿‘çš„ç°‡ã€‚ç”±äºæˆ‘ä»¬ä¸æ˜¯åœ¨è¯„ä¼°æ€§èƒ½ï¼Œè€Œæ˜¯åœ¨è¯„ä¼°æ•°æ®ä¸­çš„æ¨¡å¼ï¼Œæ‰€ä»¥å¯ä»¥åœ¨è®­ç»ƒæ•°æ®ä¸Šæ‰§è¡Œæ­¤æ“ä½œ
    â€”â€” å³æœªæ ‡è®°çš„è®­ç»ƒæ•°æ®æˆ–æœªè§è¿‡çš„æ•°æ®é›†ï¼Œå› æ­¤ï¼Œæˆ‘å°†å…¶ä¼ é€’ç»™äº†*line 1*ä¸­çš„***predict()***ã€‚ç„¶åï¼Œå°†é¢„æµ‹çš„ç°‡ç¼–å·æ•°ç»„æ·»åŠ å›æ•°æ®é›†ã€‚
- en: 'Image Source: Author'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾åƒæ¥æºï¼šä½œè€…
- en: In *line 3*, I used the lambda function to map the individual R, G, and B values
    in each column of the RGB DataFrame and convert the RGB value to the corresponding
    Hex code since it is easier to plot using [Seabornâ€™s color_palette() method](https://seaborn.pydata.org/generated/seaborn.color_palette.html)
    in a single line of code. Below, is the function that is used to convert from
    RGB to Hex.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨*line 3*ä¸­ï¼Œæˆ‘ä½¿ç”¨äº†lambdaå‡½æ•°æ¥æ˜ å°„RGB DataFrameä¸­æ¯åˆ—çš„å•ä¸ªRã€Gå’ŒBå€¼ï¼Œå¹¶å°†RGBå€¼è½¬æ¢ä¸ºç›¸åº”çš„Hexä»£ç ï¼Œå› ä¸ºä½¿ç”¨[Seabornçš„color_palette()æ–¹æ³•](https://seaborn.pydata.org/generated/seaborn.color_palette.html)ç»˜åˆ¶èµ·æ¥æ›´ç®€å•ã€‚ä¸‹é¢æ˜¯ç”¨äºå°†RGBè½¬æ¢ä¸ºHexçš„å‡½æ•°ã€‚
- en: 'Image Source: Author'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾åƒæ¥æºï¼šä½œè€…
- en: Finally, I wrapped the visualizing process of each cluster in a for loop (*lines
    4 to 6*) where for each cluster number, beginning from 0 to the palette size/number
    of clusters ([exclusive](https://www.geeksforgeeks.org/python-range-function/)),
    the corresponding Hex codes (up to 10 as specified with [:10])are shown using
    ***seaborn.color_palette()*** method in *line 6*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œæˆ‘å°†æ¯ä¸ªç°‡çš„å¯è§†åŒ–è¿‡ç¨‹åŒ…è£¹åœ¨ä¸€ä¸ª for å¾ªç¯ä¸­ï¼ˆ*ç¬¬ 4 åˆ°ç¬¬ 6 è¡Œ*ï¼‰ï¼Œå¯¹äºæ¯ä¸ªç°‡ç¼–å·ï¼Œä» 0 åˆ°è°ƒè‰²æ¿å¤§å°/ç°‡æ•°ï¼ˆ[æ’é™¤](https://www.geeksforgeeks.org/python-range-function/)ï¼‰ï¼Œä½¿ç”¨
    ***seaborn.color_palette()*** æ–¹æ³•åœ¨ *ç¬¬ 6 è¡Œ* æ˜¾ç¤ºç›¸åº”çš„ Hex ä»£ç ï¼ˆæœ€å¤š 10 ä¸ªï¼Œå¦‚ [:10] æŒ‡å®šçš„ï¼‰ã€‚
- en: 'Hereâ€™s the color palette or cluster centers to compare & associate with the
    clusters:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯é¢œè‰²è°ƒè‰²æ¿æˆ–ç°‡ä¸­å¿ƒï¼Œç”¨äºæ¯”è¾ƒå’Œå…³è”ç°‡ï¼š
- en: '![](../Images/04488d97005621b1c43a6f8bc982c2d8.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04488d97005621b1c43a6f8bc982c2d8.png)'
- en: 'Image Source: Author'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡æ¥æºï¼šä½œè€…
- en: Below are the colors in each cluster. *Note that the palette is sorted as shown
    before and they correspond to clusters 3, 0, 5, 2, 4, and 1, respectively.*
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹é¢æ˜¯æ¯ä¸ªç°‡ä¸­çš„é¢œè‰²ã€‚ *è¯·æ³¨æ„ï¼Œè°ƒè‰²æ¿æŒ‰ä¹‹å‰æ˜¾ç¤ºçš„é¡ºåºæ’åºï¼Œå®ƒä»¬åˆ†åˆ«å¯¹åº”äºç°‡ 3ã€0ã€5ã€2ã€4 å’Œ 1ã€‚*
- en: '![](../Images/214f643ccb7c1de868daa3ddb43316b9.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/214f643ccb7c1de868daa3ddb43316b9.png)'
- en: 'Image Source: Author'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡æ¥æºï¼šä½œè€…
- en: '**Step 5: Using Palette with the Popular Visualization Libraries**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**ç¬¬ 5 æ­¥ï¼šä½¿ç”¨æµè¡Œçš„å¯è§†åŒ–åº“ä¸­çš„è°ƒè‰²æ¿**'
- en: 'To do so, I converted the RGB values to a list of Hex values which can directly
    be passed as a list of colors in the visualization methods. Hereâ€™s the code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºæ­¤ï¼Œæˆ‘å°† RGB å€¼è½¬æ¢ä¸ºå¯ä»¥ç›´æ¥ä½œä¸ºé¢œè‰²åˆ—è¡¨ä¼ é€’åˆ°å¯è§†åŒ–æ–¹æ³•ä¸­çš„ Hex å€¼åˆ—è¡¨ã€‚ä»¥ä¸‹æ˜¯ä»£ç ï¼š
- en: 'Image Source: Author'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡æ¥æºï¼šä½œè€…
- en: '**Seaborn**'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Seaborn**'
- en: Hereâ€™s an example of using the palette on a Seaborn barplot. In Seaborn, we
    can set the palette as in *line 3* or directly pass the *list_hex*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯åœ¨ Seaborn æ¡å½¢å›¾ä¸Šä½¿ç”¨è°ƒè‰²æ¿çš„ç¤ºä¾‹ã€‚åœ¨ Seaborn ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥åƒåœ¨ *ç¬¬ 3 è¡Œ* ä¸­é‚£æ ·è®¾ç½®è°ƒè‰²æ¿ï¼Œæˆ–è€…ç›´æ¥ä¼ é€’ *list_hex*ã€‚
- en: 'Image Source: Author'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡æ¥æºï¼šä½œè€…
- en: '![](../Images/9cf3f9daebb0da658e5058b719e359e8.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9cf3f9daebb0da658e5058b719e359e8.png)'
- en: 'Image Source: Author'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡æ¥æºï¼šä½œè€…
- en: '**2\. Plotly**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**2\. Plotly**'
- en: Hereâ€™s an example of using the palette on a Plotly barplot. I have used the
    *list_hex* for the parameter color_discrete_sequence as in *line 3.*
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯åœ¨ Plotly æ¡å½¢å›¾ä¸Šä½¿ç”¨è°ƒè‰²æ¿çš„ç¤ºä¾‹ã€‚æˆ‘ä½¿ç”¨äº† *list_hex* ä½œä¸ºå‚æ•° color_discrete_sequenceï¼Œå¦‚ *ç¬¬ 3
    è¡Œ* æ‰€ç¤ºã€‚
- en: 'Image Source: Author'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡æ¥æºï¼šä½œè€…
- en: 'Image Source: Author'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡æ¥æºï¼šä½œè€…
- en: '**3\. Matplotlib**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**3\. Matplotlib**'
- en: Hereâ€™s an example of using the palette on a Matplotlib barplot where I passed
    the *list_hex* for the parameter color in *line 8*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯åœ¨ Matplotlib æ¡å½¢å›¾ä¸Šä½¿ç”¨è°ƒè‰²æ¿çš„ç¤ºä¾‹ï¼Œå…¶ä¸­æˆ‘å°† *list_hex* ä½œä¸ºå‚æ•° color ä¼ é€’åœ¨ *ç¬¬ 8 è¡Œ*ã€‚
- en: 'Image Source: Author'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡æ¥æºï¼šä½œè€…
- en: '![](../Images/16164744f9378348eabe81173227da41.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/16164744f9378348eabe81173227da41.png)'
- en: 'Image Source: Author'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡æ¥æºï¼šä½œè€…
- en: Hope you enjoyed this clustering exercise ğŸ™‚. ***Hereâ€™s the complete*** [***Notebook***](https://github.com/royn5618/Medium_Blog_Codes/blob/master/color_palette_generator/color_palette_generator.ipynb)
    ***and a demo below!***
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: å¸Œæœ›ä½ å–œæ¬¢è¿™ä¸ªèšç±»ç»ƒä¹  ğŸ™‚ã€‚ ***è¿™æ˜¯å®Œæ•´çš„*** [***ç¬”è®°æœ¬***](https://github.com/royn5618/Medium_Blog_Codes/blob/master/color_palette_generator/color_palette_generator.ipynb)
    ***å’Œä¸‹é¢çš„æ¼”ç¤ºï¼***
- en: 'Video Source: Author'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: è§†é¢‘æ¥æºï¼šä½œè€…
- en: 'References:'
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å‚è€ƒæ–‡çŒ®ï¼š
- en: '[Clustering Algorithms](https://developers.google.com/machine-learning/clustering/clustering-algorithms)
    | Google'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[èšç±»ç®—æ³•](https://developers.google.com/machine-learning/clustering/clustering-algorithms)
    | Google'
- en: '[What is unsupervised learning? | IBM](https://www.ibm.com/topics/unsupervised-learning#:~:text=the%20next%20step-,What%20is%20unsupervised%20learning%3F,the%20need%20for%20human%20intervention)'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[ä»€ä¹ˆæ˜¯æ— ç›‘ç£å­¦ä¹ ï¼Ÿ | IBM](https://www.ibm.com/topics/unsupervised-learning#:~:text=the%20next%20step-,What%20is%20unsupervised%20learning%3F,the%20need%20for%20human%20intervention)'
- en: '[The HSV Color Model in Graphic Design](https://www.lifewire.com/what-is-hsv-in-design-1078068)'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[å›¾å½¢è®¾è®¡ä¸­çš„ HSV é¢œè‰²æ¨¡å‹](https://www.lifewire.com/what-is-hsv-in-design-1078068)'
- en: '[Digital Image Basics](https://www.shsu.edu/~csc_dsb/DigitalImage/DigitalImages.html)'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[æ•°å­—å›¾åƒåŸºç¡€](https://www.shsu.edu/~csc_dsb/DigitalImage/DigitalImages.html)'
- en: '[What does the parameter n_init actually do?](https://stackoverflow.com/questions/46359490/python-scikit-learn-k-means-what-does-the-parameter-n-init-actually-do)
    | StackOverFlow'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[n_init å‚æ•°å®é™…ä¸Šåšäº†ä»€ä¹ˆï¼Ÿ](https://stackoverflow.com/questions/46359490/python-scikit-learn-k-means-what-does-the-parameter-n-init-actually-do)
    | StackOverFlow'
- en: '[How Could One Implement the K-Means++ Algorithm?](https://stackoverflow.com/questions/5466323/how-could-one-implement-the-k-means-algorithm)
    | StackOverFlow'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[å¦‚ä½•å®ç° K-Means++ ç®—æ³•ï¼Ÿ](https://stackoverflow.com/questions/5466323/how-could-one-implement-the-k-means-algorithm)
    | StackOverFlow'
- en: '[Lecture 2 â€” The k-means clustering problem](https://cseweb.ucsd.edu/~dasgupta/291-unsup/lec2.pdf)
    | University of California San Diego'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[è®²åº§ 2 â€” k-means èšç±»é—®é¢˜](https://cseweb.ucsd.edu/~dasgupta/291-unsup/lec2.pdf)
    | åŠ å·å¤§å­¦åœ£åœ°äºšå“¥åˆ†æ ¡'
- en: '[Lecture 10: k-means clustering](http://www.cs.yale.edu/homes/el327/datamining2013aFiles/10_k_means_clustering.pdf)
    | Yale'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[ç¬¬10è®²ï¼šk-means èšç±»](http://www.cs.yale.edu/homes/el327/datamining2013aFiles/10_k_means_clustering.pdf)
    | è€¶é²å¤§å­¦'
- en: '[CS229 Lecture notes | Andrew Ng](http://cs229.stanford.edu/notes2020spring/cs229-notes7a.pdf)'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[CS229 è®²ä¹‰ | Andrew Ng](http://cs229.stanford.edu/notes2020spring/cs229-notes7a.pdf)'
- en: ğŸ”Looking for Supervised Machine Learning Articles?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ” å¯»æ‰¾ç›‘ç£å­¦ä¹ ç›¸å…³æ–‡ç« ï¼Ÿ
- en: '[](/a-simplified-explanation-of-supervised-machine-learning-for-electrical-and-electronics-engineers-6d533cdedc6d?source=post_page-----94bb8e6a1416--------------------------------)
    [## A Simplified Explanation of Supervised Machine Learning for Electrical and
    Electronics Engineers'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[](/a-simplified-explanation-of-supervised-machine-learning-for-electrical-and-electronics-engineers-6d533cdedc6d?source=post_page-----94bb8e6a1416--------------------------------)
    [## ç”µæ°”å’Œç”µå­å·¥ç¨‹å¸ˆçš„ç›‘ç£å­¦ä¹ ç®€åŒ–è§£é‡Š'
- en: If you landed up in Electrical or Electronics engineering domain (like I was
    once myself), you are probably dealingâ€¦
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: å¦‚æœä½ è¿›å…¥äº†ç”µæ°”æˆ–ç”µå­å·¥ç¨‹é¢†åŸŸï¼ˆå°±åƒæˆ‘æ›¾ç»ä¸€æ ·ï¼‰ï¼Œä½ å¯èƒ½æ­£åœ¨å¤„ç†â€¦â€¦
- en: 'towardsdatascience.com](/a-simplified-explanation-of-supervised-machine-learning-for-electrical-and-electronics-engineers-6d533cdedc6d?source=post_page-----94bb8e6a1416--------------------------------)
    [](/predicting-hazardous-seismic-bumps-using-supervised-classification-algorithms-part-i-2c5d21f379bc?source=post_page-----94bb8e6a1416--------------------------------)
    [## Predicting Hazardous Seismic Bumps Part I : EDA, Feature Engineering & Splitting
    Unbalanced Dataset'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: towardsdatascience.com](/a-simplified-explanation-of-supervised-machine-learning-for-electrical-and-electronics-engineers-6d533cdedc6d?source=post_page-----94bb8e6a1416--------------------------------)
    [](/predicting-hazardous-seismic-bumps-using-supervised-classification-algorithms-part-i-2c5d21f379bc?source=post_page-----94bb8e6a1416--------------------------------)
    [## é¢„æµ‹å±é™©çš„åœ°éœ‡çªå‘ Part Iï¼šæ¢ç´¢æ€§æ•°æ®åˆ†æã€ç‰¹å¾å·¥ç¨‹ä¸ä¸å¹³è¡¡æ•°æ®é›†æ‹†åˆ†
- en: This article demonstrates exploratory data analysis (EDA), feature engineering,
    and splitting strategies for unbalancedâ€¦
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: æœ¬æ–‡å±•ç¤ºäº†æ¢ç´¢æ€§æ•°æ®åˆ†æï¼ˆEDAï¼‰ã€ç‰¹å¾å·¥ç¨‹ä»¥åŠä¸å¹³è¡¡æ•°æ®é›†çš„æ‹†åˆ†ç­–ç•¥â€¦â€¦
- en: 'towardsdatascience.com](/predicting-hazardous-seismic-bumps-using-supervised-classification-algorithms-part-i-2c5d21f379bc?source=post_page-----94bb8e6a1416--------------------------------)
    [](/predicting-hazardous-seismic-bumps-part-ii-training-supervised-classifier-models-and-8b9104b611b0?source=post_page-----94bb8e6a1416--------------------------------)
    [## Predicting Hazardous Seismic Bumps Part II: Training & Tuning Supervised ML
    Classifiers and Modelâ€¦'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: towardsdatascience.com](/predicting-hazardous-seismic-bumps-using-supervised-classification-algorithms-part-i-2c5d21f379bc?source=post_page-----94bb8e6a1416--------------------------------)
    [](/predicting-hazardous-seismic-bumps-part-ii-training-supervised-classifier-models-and-8b9104b611b0?source=post_page-----94bb8e6a1416--------------------------------)
    [## é¢„æµ‹å±é™©çš„åœ°éœ‡çªå‘ Part IIï¼šè®­ç»ƒä¸è°ƒä¼˜ç›‘ç£æœºå™¨å­¦ä¹ åˆ†ç±»å™¨å’Œæ¨¡å‹â€¦â€¦
- en: This article demonstrates predicting hazardous seismic bumps using binary classifiers,
    tuning model hyperparametersâ€¦
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: æœ¬æ–‡å±•ç¤ºäº†ä½¿ç”¨äºŒåˆ†ç±»å™¨é¢„æµ‹å±é™©çš„åœ°éœ‡çªå‘ï¼Œè°ƒæ•´æ¨¡å‹è¶…å‚æ•°â€¦â€¦
- en: towardsdatascience.com](/predicting-hazardous-seismic-bumps-part-ii-training-supervised-classifier-models-and-8b9104b611b0?source=post_page-----94bb8e6a1416--------------------------------)
    [](/predicting-fake-news-using-nlp-and-machine-learning-scikit-learn-glove-keras-lstm-7bbd557c3443?source=post_page-----94bb8e6a1416--------------------------------)
    [## Predicting Fake News using NLP and Machine Learning | Scikit-Learn | GloVe
    | Keras | LSTM
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: towardsdatascience.com](/predicting-hazardous-seismic-bumps-part-ii-training-supervised-classifier-models-and-8b9104b611b0?source=post_page-----94bb8e6a1416--------------------------------)
    [](/predicting-fake-news-using-nlp-and-machine-learning-scikit-learn-glove-keras-lstm-7bbd557c3443?source=post_page-----94bb8e6a1416--------------------------------)
    [## ä½¿ç”¨ NLP å’Œæœºå™¨å­¦ä¹ é¢„æµ‹å‡æ–°é—» | Scikit-Learn | GloVe | Keras | LSTM
- en: towardsdatascience.com](/predicting-fake-news-using-nlp-and-machine-learning-scikit-learn-glove-keras-lstm-7bbd557c3443?source=post_page-----94bb8e6a1416--------------------------------)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: towardsdatascience.com](/predicting-fake-news-using-nlp-and-machine-learning-scikit-learn-glove-keras-lstm-7bbd557c3443?source=post_page-----94bb8e6a1416--------------------------------)
- en: '*Thanks for visiting!*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*æ„Ÿè°¢è®¿é—®ï¼*'
- en: '**My Links:** [Medium](https://medium.com/@nroy0110) | [LinkedIn](https://www.linkedin.com/in/nabanita-roy/)
    | [GitHub](https://github.com/royn5618)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**æˆ‘çš„é“¾æ¥ï¼š** [Medium](https://medium.com/@nroy0110) | [LinkedIn](https://www.linkedin.com/in/nabanita-roy/)
    | [GitHub](https://github.com/royn5618)'
