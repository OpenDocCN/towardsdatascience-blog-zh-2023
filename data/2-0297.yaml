- en: An Introduction to OpenAI Function Calling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenAIå‡½æ•°è°ƒç”¨ç®€ä»‹
- en: åŸæ–‡ï¼š[https://towardsdatascience.com/an-introduction-to-openai-function-calling-e47e7cd7680e](https://towardsdatascience.com/an-introduction-to-openai-function-calling-e47e7cd7680e)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://towardsdatascience.com/an-introduction-to-openai-function-calling-e47e7cd7680e](https://towardsdatascience.com/an-introduction-to-openai-function-calling-e47e7cd7680e)
- en: No more unstructured data outputs; turn ChatGPTâ€™s completions into structured
    JSON!
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ä¸å†è¾“å‡ºæ— ç»“æ„çš„æ•°æ®ï¼›å°†ChatGPTçš„å®Œæˆå†…å®¹è½¬åŒ–ä¸ºç»“æ„åŒ–çš„JSONï¼
- en: '[](https://dkhundley.medium.com/?source=post_page-----e47e7cd7680e--------------------------------)[![David
    Hundley](../Images/1779ef96ec3d338f8fe4a9567ba7b194.png)](https://dkhundley.medium.com/?source=post_page-----e47e7cd7680e--------------------------------)[](https://towardsdatascience.com/?source=post_page-----e47e7cd7680e--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----e47e7cd7680e--------------------------------)
    [David Hundley](https://dkhundley.medium.com/?source=post_page-----e47e7cd7680e--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://dkhundley.medium.com/?source=post_page-----e47e7cd7680e--------------------------------)[![David
    Hundley](../Images/1779ef96ec3d338f8fe4a9567ba7b194.png)](https://dkhundley.medium.com/?source=post_page-----e47e7cd7680e--------------------------------)[](https://towardsdatascience.com/?source=post_page-----e47e7cd7680e--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----e47e7cd7680e--------------------------------)
    [David Hundley](https://dkhundley.medium.com/?source=post_page-----e47e7cd7680e--------------------------------)'
- en: Â·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----e47e7cd7680e--------------------------------)
    Â·16 min readÂ·Jul 9, 2023
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Â·å‘è¡¨äº [Towards Data Science](https://towardsdatascience.com/?source=post_page-----e47e7cd7680e--------------------------------)
    Â·é˜…è¯»æ—¶é—´16åˆ†é’ŸÂ·2023å¹´7æœˆ9æ—¥
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/14ae6814c08319c738cd14cdd99e5771.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/14ae6814c08319c738cd14cdd99e5771.png)'
- en: Title card created by the author
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œè€…åˆ¶ä½œçš„æ ‡é¢˜å¡
- en: 'A few months ago, OpenAI released their API to the general public, which excited
    many developers who wanted to make use of ChatGPTâ€™s outputs in a systematic way.
    As exciting has this has been, itâ€™s equally been a bit of a nightmare since we
    programmers tend to work in the realm of **structured data types**. We like integers,
    booleans, and lists. The unstructured string can be unwieldy to deal with, and
    in order to get consistent results, a programmer is required to face their worst
    nightmare: developing a regular expression (Regex) for proper parsing. ğŸ¤¢'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: å‡ ä¸ªæœˆå‰ï¼ŒOpenAIå‘å…¬ä¼—å‘å¸ƒäº†ä»–ä»¬çš„APIï¼Œè¿™è®©è®¸å¤šå¸Œæœ›ä»¥ç³»ç»ŸåŒ–æ–¹å¼åˆ©ç”¨ChatGPTè¾“å‡ºçš„å¼€å‘è€…æ„Ÿåˆ°å…´å¥‹ã€‚å°½ç®¡è¿™å¾ˆæ¿€åŠ¨äººå¿ƒï¼Œä½†ä¹ŸåŒæ ·æœ‰äº›ä»¤äººå¤´ç—›ï¼Œå› ä¸ºæˆ‘ä»¬ç¨‹åºå‘˜é€šå¸¸å·¥ä½œåœ¨**ç»“æ„åŒ–æ•°æ®ç±»å‹**çš„é¢†åŸŸã€‚æˆ‘ä»¬å–œæ¬¢æ•´æ•°ã€å¸ƒå°”å€¼å’Œåˆ—è¡¨ã€‚æ— ç»“æ„çš„å­—ç¬¦ä¸²å¤„ç†èµ·æ¥å¯èƒ½å¾ˆéº»çƒ¦ï¼Œä¸ºäº†è·å¾—ä¸€è‡´çš„ç»“æœï¼Œç¨‹åºå‘˜å¿…é¡»é¢å¯¹ä»–ä»¬æœ€å¯æ€•çš„å™©æ¢¦ï¼šå¼€å‘ç”¨äºæ­£ç¡®è§£æçš„æ­£åˆ™è¡¨è¾¾å¼ï¼ˆRegexï¼‰ã€‚ğŸ¤¢
- en: 'Of course, prompt engineering can actually help quite a bit here, but itâ€™s
    still not perfect. For example, if you want to have ChatGPT analyze the sentiment
    of a movie review for positivity or negativity, you might structure a prompt that
    looks like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œæç¤ºå·¥ç¨‹ç¡®å®å¯ä»¥åœ¨è¿™é‡Œæä¾›å¾ˆå¤§å¸®åŠ©ï¼Œä½†ä»ç„¶ä¸å®Œç¾ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä½ æƒ³è®©ChatGPTåˆ†æç”µå½±è¯„è®ºçš„ç§¯ææ€§æˆ–æ¶ˆææ€§ï¼Œä½ å¯èƒ½ä¼šæ„é€ å¦‚ä¸‹æç¤ºï¼š
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This prompt honestly does pretty decently, but the results arenâ€™t precisely
    consistent. For example, I have seen ChatGPT produce outputs that look like the
    following in terms of the movie sentiment example:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªæç¤ºå®é™…ä¸Šåšå¾—ç›¸å½“ä¸é”™ï¼Œä½†ç»“æœå¹¶ä¸å®Œå…¨ä¸€è‡´ã€‚ä¾‹å¦‚ï¼Œæˆ‘çœ‹åˆ°ChatGPTåœ¨ç”µå½±æƒ…æ„Ÿç¤ºä¾‹ä¸­äº§ç”Ÿçš„è¾“å‡ºå¯èƒ½å¦‚ä¸‹ï¼š
- en: '`Positive`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Positive`'
- en: '`positive`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`positive`'
- en: '`Positive.`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Positive.`'
- en: This might not seem like a big deal, but in the world of programming, those
    are NOT equal. Again, you can get around a simpler example like this with a bit
    of Regex, but beyond the fact that most people (including myself) are terrible
    at writing regular expressions, there are simply some instances where even Regex
    canâ€™t parse the information correctly.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™çœ‹èµ·æ¥å¯èƒ½ä¸æ˜¯å¤§é—®é¢˜ï¼Œä½†åœ¨ç¼–ç¨‹ä¸–ç•Œä¸­ï¼Œè¿™äº›æ˜¯ä¸ç›¸ç­‰çš„ã€‚å†è¯´ï¼Œä½ å¯ä»¥é€šè¿‡ä¸€äº›æ­£åˆ™è¡¨è¾¾å¼æ¥å¤„ç†è¿™æ ·çš„ç®€å•ç¤ºä¾‹ï¼Œä½†è¶…å‡ºè¿™ä¸€ç‚¹ï¼Œå¤§å¤šæ•°äººï¼ˆåŒ…æ‹¬æˆ‘è‡ªå·±ï¼‰åœ¨ç¼–å†™æ­£åˆ™è¡¨è¾¾å¼æ–¹é¢éƒ½å¾ˆç³Ÿç³•ï¼Œæœ‰äº›æƒ…å†µä¸‹å³ä½¿æ˜¯æ­£åˆ™è¡¨è¾¾å¼ä¹Ÿæ— æ³•æ­£ç¡®è§£æä¿¡æ¯ã€‚
- en: 'As you can tell, programmers have been hoping that OpenAI would add functionality
    to support structured JSON outputs, and OpenAI has delivered in the form of **function
    calling**. [Function calling](https://openai.com/blog/function-calling-and-other-api-updates)
    is exactly as it sounds: it allows ChatGPT to produce arguments that can interact
    with a custom function in a manner that uses structured data types. Yup, no more
    fancy prompt engineering and Regex to cross your fingers and hope you get the
    right outcome. In this post, weâ€™ll cover how to make use of this new functionality,
    but first, letâ€™s start with an example of how we used to attempt to produce structured
    data outputs with prompt engineering and Regex.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚ä½ æ‰€çœ‹åˆ°çš„ï¼Œç¨‹åºå‘˜ä»¬ä¸€ç›´å¸Œæœ› OpenAI å¢åŠ æ”¯æŒç»“æ„åŒ– JSON è¾“å‡ºçš„åŠŸèƒ½ï¼Œè€Œ OpenAI ä»¥ **å‡½æ•°è°ƒç”¨** çš„å½¢å¼å®ç°äº†è¿™ä¸€ç‚¹ã€‚[å‡½æ•°è°ƒç”¨](https://openai.com/blog/function-calling-and-other-api-updates)
    çš„æ„æ€å°±æ˜¯å®ƒå…è®¸ ChatGPT ç”Ÿæˆå¯ä»¥ä¸è‡ªå®šä¹‰å‡½æ•°äº¤äº’çš„å‚æ•°ï¼Œä»¥ä½¿ç”¨ç»“æ„åŒ–æ•°æ®ç±»å‹ã€‚ä¸å†éœ€è¦èŠ±å“¨çš„æç¤ºå·¥ç¨‹å’Œæ­£åˆ™è¡¨è¾¾å¼æ¥ç¥ˆç¥·ä½ èƒ½å¾—åˆ°æ­£ç¡®çš„ç»“æœã€‚åœ¨è¿™ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬å°†ä»‹ç»å¦‚ä½•åˆ©ç”¨è¿™ä¸€æ–°åŠŸèƒ½ï¼Œä½†é¦–å…ˆï¼Œè®©æˆ‘ä»¬ä»ä¸€ä¸ªä¾‹å­å¼€å§‹ï¼Œå±•ç¤ºæˆ‘ä»¬è¿‡å»å¦‚ä½•å°è¯•é€šè¿‡æç¤ºå·¥ç¨‹å’Œæ­£åˆ™è¡¨è¾¾å¼ç”Ÿæˆç»“æ„åŒ–æ•°æ®è¾“å‡ºã€‚
- en: Before we jump into the bulk of our post, please allow me to [share a link to
    this Jupyter notebook in my GitHub](https://github.com/dkhundley/openai-api-tutorial/blob/main/notebooks/function-calling.ipynb).
    This notebook contains all the code I will be running (and more) as part of this
    blog post. Additionally, I would encourage you to [check out OpenAIâ€™s official
    function calling documentation](https://platform.openai.com/docs/guides/gpt/function-calling)
    for anything that I may not cover here.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬è¿›å…¥æ–‡ç« çš„ä¸»è¦å†…å®¹ä¹‹å‰ï¼Œè¯·å…è®¸æˆ‘ [åˆ†äº«è¿™ä¸ª Jupyter notebook åœ¨æˆ‘çš„ GitHub ä¸Šçš„é“¾æ¥](https://github.com/dkhundley/openai-api-tutorial/blob/main/notebooks/function-calling.ipynb)ã€‚è¿™ä¸ª
    notebook åŒ…å«äº†æˆ‘å°†åœ¨è¿™ç¯‡åšå®¢æ–‡ç« ä¸­è¿è¡Œçš„æ‰€æœ‰ä»£ç ï¼ˆä»¥åŠæ›´å¤šï¼‰ã€‚æ­¤å¤–ï¼Œæˆ‘å»ºè®®ä½  [æŸ¥çœ‹ OpenAI å®˜æ–¹çš„å‡½æ•°è°ƒç”¨æ–‡æ¡£](https://platform.openai.com/docs/guides/gpt/function-calling)ï¼Œä»¥è·å–æˆ‘å¯èƒ½æ²¡æœ‰æ¶µç›–çš„å†…å®¹ã€‚
- en: The Pre-Function Calling Days
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å‡½æ•°è°ƒç”¨å‰çš„æ—¶ä»£
- en: 'To demonstrate what we used to do in the â€œpre-function calling daysâ€, I wrote
    a small bit of text about myself, and weâ€™ll be using the OpenAPI to extract bits
    of information from this text. Here is the â€œAbout Meâ€ text weâ€™ll be working with:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†å±•ç¤ºæˆ‘ä»¬åœ¨â€œå‡½æ•°è°ƒç”¨å‰çš„æ—¶ä»£â€æ˜¯å¦‚ä½•åšçš„ï¼Œæˆ‘å†™äº†ä¸€å°æ®µå…³äºè‡ªå·±çš„æ–‡æœ¬ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ OpenAPI ä»è¿™æ®µæ–‡æœ¬ä¸­æå–ä¿¡æ¯ã€‚ä»¥ä¸‹æ˜¯æˆ‘ä»¬å°†è¦ä½¿ç”¨çš„â€œå…³äºæˆ‘â€çš„æ–‡æœ¬ï¼š
- en: Hello! My name is David Hundley. I am a principal machine learning engineer
    at State Farm. I enjoy learning about AI and teaching what I learn back to others.
    I have two daughters. I drive a Tesla Model 3, and my favorite video game series
    is The Legend of Zelda.
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ å¥½ï¼æˆ‘å«å¤§å«Â·äº¨å¾·åˆ©ã€‚æˆ‘æ˜¯ State Farm çš„é¦–å¸­æœºå™¨å­¦ä¹ å·¥ç¨‹å¸ˆã€‚æˆ‘å–œæ¬¢å­¦ä¹  AI å¹¶å°†æ‰€å­¦çš„çŸ¥è¯†ä¼ æˆç»™ä»–äººã€‚æˆ‘æœ‰ä¸¤ä¸ªå¥³å„¿ã€‚æˆ‘å¼€ä¸€è¾†ç‰¹æ–¯æ‹‰ Model
    3ï¼Œæˆ‘æœ€å–œæ¬¢çš„è§†é¢‘æ¸¸æˆç³»åˆ—æ˜¯ã€Šå¡å°”è¾¾ä¼ è¯´ã€‹ã€‚
- en: 'Letâ€™s say I want to extract the following bits of information from that text:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘æƒ³ä»è¿™æ®µæ–‡æœ¬ä¸­æå–ä»¥ä¸‹ä¿¡æ¯ï¼š
- en: Name
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å§“å
- en: Job title
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: èŒä¸šå¤´è¡”
- en: Company
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å…¬å¸
- en: Number of children *as an integer (This is important!)*
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å­å¥³æ•°é‡ *ä»¥æ•´æ•°å½¢å¼ï¼ˆè¿™å¾ˆé‡è¦ï¼ï¼‰*
- en: Car make
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è½¦è¾†å“ç‰Œ
- en: Car model
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è½¦è¾†å‹å·
- en: Favorite video game series
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æœ€å–œæ¬¢çš„è§†é¢‘æ¸¸æˆç³»åˆ—
- en: 'Hereâ€™s how I would engineer a few-shot prompt in order to produce a structured
    JSON output:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯æˆ‘å¦‚ä½•è®¾è®¡ä¸€ä¸ªå°‘é‡ç¤ºä¾‹æç¤ºä»¥ç”Ÿæˆç»“æ„åŒ– JSON è¾“å‡ºï¼š
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Letâ€™s check out how ChatGPT returned this completion to me:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æ¥çœ‹çœ‹ ChatGPT æ˜¯å¦‚ä½•è¿”å›è¿™ä¸ªå®Œæˆçš„ï¼š
- en: '![](../Images/3c5674a1a303f8dab4da738c821fea48.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3c5674a1a303f8dab4da738c821fea48.png)'
- en: The â€œPre-Function Callingâ€ Days (Captured by the author)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: â€œå‡½æ•°è°ƒç”¨å‰â€çš„æ—¶ä»£ï¼ˆä½œè€…æ•æ‰ï¼‰
- en: 'As you can see, this actually isnâ€™t bad. But itâ€™s not ideal and could prove
    to be risky for the following reasons:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚ä½ æ‰€è§ï¼Œè¿™å…¶å®è¿˜ä¸é”™ã€‚ä½†å®ƒä¸æ˜¯ç†æƒ³çš„ï¼Œå¹¶ä¸”ç”±äºä»¥ä¸‹åŸå› å¯èƒ½ä¼šæœ‰é£é™©ï¼š
- en: We are not guaranteed that OpenAIâ€™s response will provide a clean JSON output.
    It could have produced something like â€œHere is your JSON:â€ followed by the JSON
    output, meaning that in order to use `json.loads()` to parse the string into a
    JSON object, weâ€™d first have to strip out that little bit of text that opens the
    response.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¸èƒ½ä¿è¯ OpenAI çš„å›åº”ä¼šæä¾›å¹²å‡€çš„ JSON è¾“å‡ºã€‚å®ƒå¯èƒ½ä¼šç”Ÿæˆç±»ä¼¼äºâ€œè¿™æ˜¯ä½ çš„ JSONï¼šâ€åè·Ÿ JSON è¾“å‡ºçš„å†…å®¹ï¼Œè¿™æ„å‘³ç€ä¸ºäº†ä½¿ç”¨
    `json.loads()` å°†å­—ç¬¦ä¸²è§£æä¸º JSON å¯¹è±¡ï¼Œæˆ‘ä»¬å¿…é¡»å…ˆå»æ‰å“åº”å¼€å¤´çš„é‚£ä¸€å°æ®µæ–‡æœ¬ã€‚
- en: We are not guaranteed that the keys in the key-value pairs of the JSON object
    will be consistent from API call to API call. Recall the example from above of
    the 3 instances of the word `Positive`. This is precisely the same risk you run
    trying to have ChatGPT parse out keys through few-shot prompt engineering. The
    only way you could maybe lock this down is with Regex, which comes with its own
    baggage as we already discussed.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¸èƒ½ä¿è¯ JSON å¯¹è±¡ä¸­çš„é”®å€¼å¯¹çš„é”®åœ¨ API è°ƒç”¨ä¸­æ˜¯ä¸€è‡´çš„ã€‚å›å¿†ä¸€ä¸‹ä¸Šé¢æåˆ°çš„3ä¸ª `Positive` å®ä¾‹ã€‚è¿™æ­£æ˜¯ä½ åœ¨å°è¯•é€šè¿‡å°‘é‡æç¤ºå·¥ç¨‹è§£æé”®æ—¶æ‰€é¢ä¸´çš„é£é™©ã€‚ä½ å¯èƒ½å”¯ä¸€èƒ½å›ºå®šè¿™ä¸ªé—®é¢˜çš„æ–¹æ³•æ˜¯ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼ï¼Œä½†æ­£å¦‚æˆ‘ä»¬ä¹‹å‰è®¨è®ºè¿‡çš„ï¼Œè¿™ä¹Ÿæœ‰è‡ªå·±çš„éº»çƒ¦ã€‚
- en: We are not guaranteed to receive our responses in the proper data type format.
    While our prompt engineering to extract number of children did parse into a proper
    integer, weâ€™re at the mercy of crossing our fingers and hoping we get that consistent
    result for every API call.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¸èƒ½ä¿è¯æ”¶åˆ°çš„å“åº”æ˜¯æ­£ç¡®çš„æ•°æ®ç±»å‹æ ¼å¼ã€‚è™½ç„¶æˆ‘ä»¬æå–å­©å­æ•°é‡çš„æç¤ºå·¥ç¨‹è§£ææˆäº†ä¸€ä¸ªåˆé€‚çš„æ•´æ•°ï¼Œä½†æˆ‘ä»¬ä»ç„¶åªèƒ½ç¥ˆç¥·æ¯æ¬¡ API è°ƒç”¨éƒ½èƒ½è·å¾—ä¸€è‡´çš„ç»“æœã€‚
- en: 'We could summarize these issues into a single statement: **Without function
    calling, we are not guaranteed to get consistent results that are important for
    the precision required for systematic implementation.** Itâ€™s a nontrivial issue
    that can be very challenging to remedy through prompt engineering and regular
    expressions.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥å°†è¿™äº›é—®é¢˜æ€»ç»“ä¸ºä¸€å¥è¯ï¼š**æ²¡æœ‰åŠŸèƒ½è°ƒç”¨ï¼Œæˆ‘ä»¬ä¸èƒ½ä¿è¯è·å¾—å¯¹ç³»ç»ŸåŒ–å®ç°æ‰€éœ€ç²¾åº¦çš„é‡è¦ä¸€è‡´ç»“æœã€‚** è¿™æ˜¯ä¸€ä¸ªéå¹³å‡¡çš„é—®é¢˜ï¼Œé€šè¿‡æç¤ºå·¥ç¨‹å’Œæ­£åˆ™è¡¨è¾¾å¼è§£å†³èµ·æ¥å¯èƒ½éå¸¸å…·æœ‰æŒ‘æˆ˜æ€§ã€‚
- en: Enter Function Calling
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: è¿›å…¥åŠŸèƒ½è°ƒç”¨
- en: Now that weâ€™ve built an intuition around why getting structured outputs from
    ChatGPT was formerly problematic, letâ€™s move into looking at the new function
    calling capability introduced by OpenAI.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å·²ç»å¯¹ä¸ºä»€ä¹ˆä» ChatGPT è·å¾—ç»“æ„åŒ–è¾“å‡ºæ›¾ç»å­˜åœ¨é—®é¢˜æœ‰äº†ä¸€å®šçš„ç›´è§‰ï¼Œè®©æˆ‘ä»¬æ¥çœ‹çœ‹ OpenAI å¼•å…¥çš„æ–°åŠŸèƒ½è°ƒç”¨èƒ½åŠ›ã€‚
- en: Function calling is actually a bit of a misnomer. OpenAI is not actually running
    your code in a true function call. Rather, itâ€™s simply setting up the structured
    arguments youâ€™d need to execute your own custom functions, and Iâ€™d argue this
    is preferred behavior. While you might be thinking that it doesnâ€™t make sense
    that the OpenAI API isnâ€™t executing your custom function, consider that in order
    to do that, youâ€™d have to pass that function code into ChatGPT. This function
    code probably contains proprietary information that you would NOT want to expose
    to anybody, hence why itâ€™s good that you donâ€™t actually have to pass this code
    to make use of OpenAIâ€™s function calling.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: åŠŸèƒ½è°ƒç”¨å®é™…ä¸Šæœ‰ç‚¹è¯¯å¯¼ã€‚OpenAI å®é™…ä¸Šå¹¶æ²¡æœ‰åœ¨çœŸæ­£çš„å‡½æ•°è°ƒç”¨ä¸­è¿è¡Œä½ çš„ä»£ç ã€‚ç›¸åï¼Œå®ƒåªæ˜¯è®¾ç½®äº†ä½ æ‰§è¡Œè‡ªå®šä¹‰å‡½æ•°æ‰€éœ€çš„ç»“æ„åŒ–å‚æ•°ï¼Œæˆ‘è®¤ä¸ºè¿™æ˜¯æ›´å¥½çš„è¡Œä¸ºã€‚è™½ç„¶ä½ å¯èƒ½ä¼šè§‰å¾—
    OpenAI API ä¸æ‰§è¡Œä½ çš„è‡ªå®šä¹‰å‡½æ•°ä¸åˆç†ï¼Œä½†è€ƒè™‘åˆ°è¦åšåˆ°è¿™ä¸€ç‚¹ï¼Œä½ å¿…é¡»å°†å‡½æ•°ä»£ç ä¼ é€’ç»™ ChatGPTã€‚è¿™æ®µå‡½æ•°ä»£ç å¯èƒ½åŒ…å«ä½ ä¸æƒ³æš´éœ²ç»™ä»»ä½•äººçš„ä¸“æœ‰ä¿¡æ¯ï¼Œå› æ­¤ä¸éœ€è¦ä¼ é€’è¿™äº›ä»£ç æ¥åˆ©ç”¨
    OpenAI çš„åŠŸèƒ½è°ƒç”¨æ˜¯ä»¶å¥½äº‹ã€‚
- en: 'Letâ€™s jump into an example of how to enable function calling with a single
    custom function. Using our â€œAbout Meâ€ sample text from the previous section, letâ€™s
    create a custom function called `extract_person_info`. This function needs just
    three bits of information: person name, job title, and number of children. (Weâ€™ll
    revisit extracting the rest of the information in the next section; I just want
    to start simpler for now.) This custom function is intentionally very simple and
    will simply take our arguments and print them together in a single string. Hereâ€™s
    the code for this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æ¥çœ‹ä¸€ä¸ªå¦‚ä½•ä½¿ç”¨å•ä¸ªè‡ªå®šä¹‰å‡½æ•°å¯ç”¨åŠŸèƒ½è°ƒç”¨çš„ç¤ºä¾‹ã€‚ä½¿ç”¨æˆ‘ä»¬å‰ä¸€èŠ‚çš„â€œå…³äºæˆ‘â€æ ·æœ¬æ–‡æœ¬ï¼Œåˆ›å»ºä¸€ä¸ªåä¸º`extract_person_info`çš„è‡ªå®šä¹‰å‡½æ•°ã€‚è¿™ä¸ªå‡½æ•°åªéœ€è¦ä¸‰é¡¹ä¿¡æ¯ï¼šä¸ªäººå§“åã€èŒä½åç§°å’Œå­©å­æ•°é‡ã€‚ï¼ˆæˆ‘ä»¬å°†åœ¨ä¸‹ä¸€èŠ‚é‡æ–°è®¿é—®æå–å…¶ä½™ä¿¡æ¯çš„éƒ¨åˆ†ï¼›æˆ‘ç°åœ¨åªæ˜¯æƒ³ä»ç®€å•å¼€å§‹ã€‚ï¼‰è¿™ä¸ªè‡ªå®šä¹‰å‡½æ•°æ•…æ„è®¾è®¡å¾—éå¸¸ç®€å•ï¼Œå®ƒå°†æ¥å—æˆ‘ä»¬çš„å‚æ•°ï¼Œå¹¶å°†å®ƒä»¬åˆå¹¶ä¸ºä¸€ä¸ªå­—ç¬¦ä¸²ã€‚ä»¥ä¸‹æ˜¯ä»£ç ï¼š
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In order to make use of function calling, we need to set up a JSON object in
    a specific way that notes the name of our custom function and what data elements
    we are hoping ChatGPT will extract from the body of the text. Because of the specificity
    on how this JSON object should look, I would encourage you reference OpenAIâ€™s
    developer documentation if you want to know any details that I donâ€™t cover here.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†åˆ©ç”¨åŠŸèƒ½è°ƒç”¨ï¼Œæˆ‘ä»¬éœ€è¦ä»¥ç‰¹å®šçš„æ–¹å¼è®¾ç½®ä¸€ä¸ª JSON å¯¹è±¡ï¼Œè¯´æ˜æˆ‘ä»¬è‡ªå®šä¹‰å‡½æ•°çš„åç§°ä»¥åŠæˆ‘ä»¬å¸Œæœ› ChatGPT ä»æ–‡æœ¬æ­£æ–‡ä¸­æå–çš„æ•°æ®å…ƒç´ ã€‚ç”±äº
    JSON å¯¹è±¡åº”æœ‰çš„å…·ä½“æ ¼å¼ï¼Œå¦‚æœä½ æƒ³äº†è§£æˆ‘æœªæ¶‰åŠçš„è¯¦ç»†ä¿¡æ¯ï¼Œå»ºè®®å‚è€ƒ OpenAI çš„å¼€å‘è€…æ–‡æ¡£ã€‚
- en: '(Note: In the OpenAI documentation, I noticed one element in the JSON object
    called `required` that seemingly indicates that a parameter must be present for
    ChatGPT to properly recognize the function. I tried testing this out, and either
    this isnâ€™t how this functionality works or I did something wrong. Either way,
    I transparently have no idea what this `required` parameter indicates. ğŸ˜…)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ï¼ˆæ³¨æ„ï¼šåœ¨OpenAIæ–‡æ¡£ä¸­ï¼Œæˆ‘æ³¨æ„åˆ°JSONå¯¹è±¡ä¸­æœ‰ä¸€ä¸ªåä¸º`required`çš„å…ƒç´ ï¼Œä¼¼ä¹è¡¨ç¤ºå‚æ•°å¿…é¡»å­˜åœ¨ï¼Œä»¥ä¾¿ChatGPTèƒ½å¤Ÿæ­£ç¡®è¯†åˆ«å‡½æ•°ã€‚æˆ‘å°è¯•è¿‡æµ‹è¯•ï¼Œä½†æ— è®ºå¦‚ä½•ï¼Œè¿™å¯èƒ½ä¸æ˜¯è¿™ç§åŠŸèƒ½çš„å·¥ä½œæ–¹å¼ï¼Œæˆ–è€…æˆ‘åšé”™äº†ä»€ä¹ˆã€‚æ— è®ºå¦‚ä½•ï¼Œæˆ‘ç¡®å®ä¸æ¸…æ¥šè¿™ä¸ª`required`å‚æ•°çš„æ„ä¹‰ã€‚ğŸ˜…ï¼‰
- en: 'Here is how we need to structure our JSON object to make use of our custom
    function:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯æˆ‘ä»¬éœ€è¦å¦‚ä½•æ„å»ºæˆ‘ä»¬çš„JSONå¯¹è±¡ä»¥åˆ©ç”¨è‡ªå®šä¹‰å‡½æ•°ï¼š
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Youâ€™re probably already familiar with JSON syntax, although let me draw attention
    for a moment to the data type associated to each property. If you are a Python
    developer like myself, be aware that the data typing for this JSON structure is
    NOT directly equivalent to how we define data structures in Python. Generally
    speaking, we can find equivalencies that work out alright, but if you want to
    know more about the specific data types associated with this JSON structure, [check
    out this documentation](https://json-schema.org/understanding-json-schema/reference/object.html).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯èƒ½å·²ç»å¯¹JSONè¯­æ³•å¾ˆç†Ÿæ‚‰äº†ï¼Œä¸è¿‡è®©æˆ‘ç¨å¾®æä¸€ä¸‹ä¸æ¯ä¸ªå±æ€§ç›¸å…³çš„æ•°æ®ç±»å‹ã€‚å¦‚æœä½ åƒæˆ‘ä¸€æ ·æ˜¯Pythonå¼€å‘äººå‘˜ï¼Œè¯·æ³¨æ„ï¼Œè¿™ç§JSONç»“æ„çš„æ•°æ®ç±»å‹ä¸æˆ‘ä»¬åœ¨Pythonä¸­å®šä¹‰çš„æ•°æ®ç»“æ„å¹¶ä¸å®Œå…¨ç›¸åŒã€‚ä¸€èˆ¬æ¥è¯´ï¼Œæˆ‘ä»¬å¯ä»¥æ‰¾åˆ°ä¸€äº›å·¥ä½œå¾—ä¸é”™çš„ç­‰æ•ˆç±»å‹ï¼Œä½†å¦‚æœä½ æƒ³äº†è§£æ›´å¤šå…³äºè¿™ç§JSONç»“æ„çš„å…·ä½“æ•°æ®ç±»å‹ï¼Œ[è¯·æŸ¥çœ‹è¿™ä¸ªæ–‡æ¡£](https://json-schema.org/understanding-json-schema/reference/object.html)ã€‚
- en: 'Now weâ€™re ready to make our API call to get the results! Using the Python client,
    youâ€™ll notice the syntax is very similar to how we obtain completions in general.
    Weâ€™re just going to add some additional arguments into this call that represent
    our function calling:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å‡†å¤‡è¿›è¡ŒAPIè°ƒç”¨ä»¥è·å–ç»“æœï¼ä½¿ç”¨Pythonå®¢æˆ·ç«¯ï¼Œä½ ä¼šæ³¨æ„åˆ°è¯­æ³•éå¸¸ç±»ä¼¼äºæˆ‘ä»¬é€šå¸¸è·å–å®Œæˆçš„æ–¹å¼ã€‚æˆ‘ä»¬åªæ˜¯è¦åœ¨æ­¤è°ƒç”¨ä¸­æ·»åŠ ä¸€äº›é¢å¤–çš„å‚æ•°ï¼Œä»£è¡¨æˆ‘ä»¬çš„å‡½æ•°è°ƒç”¨ï¼š
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, we simply pass in our list of custom functions (or in our case
    for now, our singular custom function) as the `functions` parameter, and youâ€™ll
    also notice an additional parameter called `function_call` that weâ€™ve set to `auto`.
    Donâ€™t worry about this for now as weâ€™ll revisit what this `auto` piece is doing
    in the next section.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚ä½ æ‰€è§ï¼Œæˆ‘ä»¬åªæ˜¯å°†è‡ªå®šä¹‰å‡½æ•°åˆ—è¡¨ï¼ˆåœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­æ˜¯å•ä¸ªè‡ªå®šä¹‰å‡½æ•°ï¼‰ä½œä¸º`functions`å‚æ•°ä¼ é€’ï¼Œå¹¶ä¸”ä½ ä¼šæ³¨æ„åˆ°ä¸€ä¸ªåä¸º`function_call`çš„é¢å¤–å‚æ•°ï¼Œæˆ‘ä»¬å°†å…¶è®¾ç½®ä¸º`auto`ã€‚ç›®å‰ä¸å¿…æ‹…å¿ƒè¿™ä¸ª`auto`ï¼Œå› ä¸ºæˆ‘ä»¬å°†åœ¨ä¸‹ä¸€èŠ‚å›é¡¾è¿™ä¸ª`auto`çš„ä½œç”¨ã€‚
- en: Letâ€™s run this code and take a look at the full API response from ChatGPT
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬è¿è¡Œè¿™æ®µä»£ç ï¼Œçœ‹çœ‹ChatGPTçš„å®Œæ•´APIå“åº”
- en: '![](../Images/28cfd91d92c922e97466bb09a518c43c.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/28cfd91d92c922e97466bb09a518c43c.png)'
- en: Function calling with a single function (Captured by the author)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨å•ä¸ªå‡½æ•°çš„å‡½æ•°è°ƒç”¨ï¼ˆç”±ä½œè€…æ•æ‰ï¼‰
- en: 'For the most part, this response looks the same as a non-function call response,
    but now thereâ€™s an additional field in the response called `function_call`, and
    nested under this dictionary are two additional items: `name` and `arguments`.
    `name` indicates the name of our custom function that we will be calling with
    ChatGPTâ€™s output, and `arguments` contains a string that we can load using `json.loads()`
    to load our custom function arguments as a JSON object.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œè¿™ä¸ªå“åº”çœ‹èµ·æ¥ä¸éå‡½æ•°è°ƒç”¨å“åº”ç›¸åŒï¼Œä½†ç°åœ¨å“åº”ä¸­å¤šäº†ä¸€ä¸ªé¢å¤–çš„å­—æ®µï¼Œå«åš`function_call`ï¼Œåœ¨è¿™ä¸ªå­—å…¸ä¸‹åµŒå¥—äº†ä¸¤ä¸ªé¢å¤–çš„é¡¹ç›®ï¼š`name`å’Œ`arguments`ã€‚`name`è¡¨ç¤ºæˆ‘ä»¬å°†ç”¨ChatGPTçš„è¾“å‡ºè°ƒç”¨çš„è‡ªå®šä¹‰å‡½æ•°çš„åç§°ï¼Œè€Œ`arguments`åŒ…å«ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨`json.loads()`å°†å…¶åŠ è½½ä¸ºJSONå¯¹è±¡ï¼Œä»è€ŒåŠ è½½æˆ‘ä»¬çš„è‡ªå®šä¹‰å‡½æ•°å‚æ•°ã€‚
- en: Notice now that weâ€™re getting much more consistency than we were in our pre-function
    calling methodology. Now we can be guaranteed that the keys of the key-value pairs
    WILL be consistent, and the data types WILL be consistent. No need for fancy prompt
    engineering or regular expressions!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œç°åœ¨æˆ‘ä»¬è·å¾—çš„ç»“æœæ¯”ä¹‹å‰å‡½æ•°è°ƒç”¨æ–¹æ³•çš„ç»“æœè¦ä¸€è‡´å¾—å¤šã€‚ç°åœ¨æˆ‘ä»¬å¯ä»¥ä¿è¯é”®å€¼å¯¹çš„é”®å’Œå€¼çš„æ•°æ®ç±»å‹å°†æ˜¯ä¸€è‡´çš„ã€‚æ— éœ€å¤æ‚çš„æç¤ºå·¥ç¨‹æˆ–æ­£åˆ™è¡¨è¾¾å¼ï¼
- en: Thatâ€™s the core of OpenAIâ€™s function calling! Of course, this was a very simplistic
    example to get you going, but you probably have additional questions. Letâ€™s cover
    those in this next section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°±æ˜¯OpenAIå‡½æ•°è°ƒç”¨çš„æ ¸å¿ƒï¼å½“ç„¶ï¼Œè¿™åªæ˜¯ä¸€ä¸ªéå¸¸ç®€å•çš„ç¤ºä¾‹æ¥å¸®åŠ©ä½ å…¥é—¨ï¼Œä½†ä½ å¯èƒ½è¿˜æœ‰å…¶ä»–é—®é¢˜ã€‚æˆ‘ä»¬å°†åœ¨ä¸‹ä¸€èŠ‚è®¨è®ºè¿™äº›é—®é¢˜ã€‚
- en: But What Aboutâ€¦?
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: é‚£ä¹ˆâ€¦æ€ä¹ˆåŠå‘¢ï¼Ÿ
- en: The previous section covered a very simple example of how to enable function
    calling, but if youâ€™re like me, you probably have some additional questions beyond
    this point. Naturally, I canâ€™t cover all these questions, but I do want to cover
    two big ones that are slightly more advanced than what we covered in the previous
    section.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸Šä¸€éƒ¨åˆ†ä»‹ç»äº†å¦‚ä½•å¯ç”¨å‡½æ•°è°ƒç”¨çš„ä¸€ä¸ªéå¸¸ç®€å•çš„ç¤ºä¾‹ï¼Œä½†å¦‚æœä½ åƒæˆ‘ä¸€æ ·ï¼Œå¯èƒ½ä¼šæœ‰ä¸€äº›é¢å¤–çš„é—®é¢˜ã€‚è‡ªç„¶ï¼Œæˆ‘ä¸èƒ½æ¶µç›–æ‰€æœ‰è¿™äº›é—®é¢˜ï¼Œä½†æˆ‘ç¡®å®æƒ³è¦æ¢è®¨ä¸¤ä¸ªæ¯”ä¸Šä¸€éƒ¨åˆ†ç¨å¾®å¤æ‚ä¸€äº›çš„é—®é¢˜ã€‚
- en: What if the prompt I submit doesnâ€™t contain the information I want to extract
    per my custom function?
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘æäº¤çš„æç¤ºä¸­ä¸åŒ…å«æˆ‘è‡ªå®šä¹‰å‡½æ•°æ‰€éœ€çš„ä¿¡æ¯ä¼šæ€æ ·ï¼Ÿ
- en: In our original example, our custom function sought to extract three very specific
    bits of information, and we demonstrated that this worked successfully by passing
    in my custom â€œAbout Meâ€ text as a prompt. But you might be wondering, what happens
    if you pass in any other prompt that doesnâ€™t contain that information?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬çš„åŸå§‹ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬çš„è‡ªå®šä¹‰å‡½æ•°æ—¨åœ¨æå–ä¸‰ä¸ªéå¸¸å…·ä½“çš„ä¿¡æ¯ç‚¹ï¼Œæˆ‘ä»¬é€šè¿‡ä¼ å…¥æˆ‘çš„è‡ªå®šä¹‰â€œå…³äºæˆ‘â€æ–‡æœ¬ä½œä¸ºæç¤ºæ¥æˆåŠŸæ¼”ç¤ºäº†è¿™ä¸€ç‚¹ã€‚ä½†ä½ å¯èƒ½ä¼šæƒ³ï¼Œå¦‚æœä½ ä¼ å…¥ä»»ä½•å…¶ä»–ä¸åŒ…å«è¿™äº›ä¿¡æ¯çš„æç¤ºä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ
- en: Recall that we set a parameter in our API client call called `function_call`
    that we set to `auto`. Weâ€™ll explore this even deeper in the next subsection,
    but what this parameter is essentially doing is telling ChatGPT to use its best
    judgment in figuring out when to structure the output for one of our custom functions.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: è®°ä½ï¼Œæˆ‘ä»¬åœ¨ API å®¢æˆ·ç«¯è°ƒç”¨ä¸­è®¾ç½®äº†ä¸€ä¸ªåä¸º `function_call` çš„å‚æ•°ï¼Œæˆ‘ä»¬å°†å…¶è®¾ç½®ä¸º `auto`ã€‚æˆ‘ä»¬å°†åœ¨ä¸‹ä¸€å°èŠ‚ä¸­æ›´æ·±å…¥åœ°æ¢è®¨è¿™ä¸ªé—®é¢˜ï¼Œä½†è¿™ä¸ªå‚æ•°çš„æœ¬è´¨ä½œç”¨æ˜¯å‘Šè¯‰
    ChatGPT åœ¨ä½•æ—¶ä½¿ç”¨è‡ªå®šä¹‰å‡½æ•°æ¥æ„å»ºè¾“å‡ºã€‚
- en: 'So what happens when we submit a prompt that doesnâ€™t match any of our custom
    functions? Simply put, it defaults to typical behavior as if function calling
    doesnâ€™t exist. Letâ€™s test this out with an arbitrary prompt: â€œHow tall is the
    Eiffel Tower?â€'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: é‚£ä¹ˆï¼Œå½“æˆ‘ä»¬æäº¤ä¸€ä¸ªä¸åŒ¹é…ä»»ä½•è‡ªå®šä¹‰å‡½æ•°çš„æç¤ºæ—¶ä¼šå‘ç”Ÿä»€ä¹ˆå‘¢ï¼Ÿç®€å•æ¥è¯´ï¼Œå®ƒå°†é»˜è®¤é‡‡ç”¨å…¸å‹è¡Œä¸ºï¼Œå¥½åƒå‡½æ•°è°ƒç”¨ä¸å­˜åœ¨ä¸€æ ·ã€‚æˆ‘ä»¬ç”¨ä¸€ä¸ªä»»æ„æç¤ºæ¥æµ‹è¯•ä¸€ä¸‹ï¼šâ€œåŸƒè²å°”é“å¡”æœ‰å¤šé«˜ï¼Ÿâ€
- en: '![](../Images/051335d6f9aa49a57801d18b5d99372a.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/051335d6f9aa49a57801d18b5d99372a.png)'
- en: Function calling but with a prompt that doesnâ€™t match the function (Captured
    by the author)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: å‡½æ•°è°ƒç”¨ï¼Œä½†æç¤ºä¸åŒ¹é…å‡½æ•°ï¼ˆä½œè€…æ‹æ‘„ï¼‰
- en: As you can see, we are getting a typical â€œCompletionsâ€ output though we passed
    in our custom function. Naturally, this makes sense since this arbitrary Eiffel
    Towel prompt contains none of the specific information we are looking for.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚ä½ æ‰€è§ï¼Œæˆ‘ä»¬å¾—åˆ°äº†å…¸å‹çš„â€œå®Œæˆâ€è¾“å‡ºï¼Œå°½ç®¡æˆ‘ä»¬ä¼ å…¥äº†è‡ªå®šä¹‰å‡½æ•°ã€‚è‡ªç„¶ï¼Œè¿™ä¹Ÿå¾ˆåˆç†ï¼Œå› ä¸ºè¿™ä¸ªä»»æ„çš„åŸƒè²å°”é“å¡”æç¤ºä¸­ä¸åŒ…å«æˆ‘ä»¬æ‰€å¯»æ‰¾çš„å…·ä½“ä¿¡æ¯ã€‚
- en: What if I want to pass multiple custom functions and some of them have overlapping
    parameters?
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘æƒ³ä¼ é€’å¤šä¸ªè‡ªå®šä¹‰å‡½æ•°ï¼Œè€Œå…¶ä¸­ä¸€äº›å‡½æ•°å…·æœ‰é‡å çš„å‚æ•°æ€ä¹ˆåŠï¼Ÿ
- en: 'In short, ChatGPT intelligently handles this without a problem. Where we previously
    passed in one custom function as essentially a list of Python dictionaries, we
    just need to keep adding additional Python dictionaries to this same list, each
    representing its own distinct function. Letâ€™s add two new functions: one called
    `extract_vehicle_info` and another called `extract_all_info`. Hereâ€™s what our
    adjusted syntax looks like:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ç®€è€Œè¨€ä¹‹ï¼ŒChatGPT èƒ½å¤Ÿæ™ºèƒ½åœ°å¤„ç†è¿™ä¸ªé—®é¢˜ã€‚æˆ‘ä»¬ä¹‹å‰å°†ä¸€ä¸ªè‡ªå®šä¹‰å‡½æ•°ä½œä¸º Python å­—å…¸åˆ—è¡¨ä¼ å…¥ï¼Œç°åœ¨æˆ‘ä»¬åªéœ€ç»§ç»­å‘è¿™ä¸ªåˆ—è¡¨ä¸­æ·»åŠ æ›´å¤š Python
    å­—å…¸ï¼Œæ¯ä¸ªå­—å…¸è¡¨ç¤ºä¸€ä¸ªä¸åŒçš„å‡½æ•°ã€‚æˆ‘ä»¬æ¥æ·»åŠ ä¸¤ä¸ªæ–°å‡½æ•°ï¼šä¸€ä¸ªå«åš `extract_vehicle_info`ï¼Œå¦ä¸€ä¸ªå«åš `extract_all_info`ã€‚è°ƒæ•´åçš„è¯­æ³•å¦‚ä¸‹ï¼š
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Notice specifically how the `extract_all_info` covers some of the same parameters
    as our original `extract_person_info` function, so how does ChatGPT know which
    one to select? Simply put, ChatGPT looks for the best match. If we pass in a prompt
    that contains all the arguments needed for the `extract_all_info` function, thatâ€™s
    the one itâ€™ll select. But if we just pass in a prompt that contains either just
    simple information about me or a prompt about my vehicle, itâ€™ll leverage the respective
    functions that do that. Letâ€™s execute that in code here with a few samples:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ç‰¹åˆ«æ³¨æ„ `extract_all_info` å¦‚ä½•è¦†ç›–ä¸æˆ‘ä»¬åŸå§‹çš„ `extract_person_info` å‡½æ•°ä¸€äº›ç›¸åŒçš„å‚æ•°ï¼Œé‚£ä¹ˆ ChatGPT
    å¦‚ä½•çŸ¥é“é€‰æ‹©å“ªä¸ªå‡½æ•°ï¼Ÿç®€å•æ¥è¯´ï¼ŒChatGPT å¯»æ‰¾æœ€ä½³åŒ¹é…ã€‚å¦‚æœæˆ‘ä»¬ä¼ å…¥çš„æç¤ºåŒ…å«äº† `extract_all_info` å‡½æ•°æ‰€éœ€çš„æ‰€æœ‰å‚æ•°ï¼Œå®ƒå°±ä¼šé€‰æ‹©è¿™ä¸ªå‡½æ•°ã€‚ä½†å¦‚æœæˆ‘ä»¬ä»…ä¼ å…¥åŒ…å«ç®€å•çš„ä¸ªäººä¿¡æ¯æˆ–å…³äºè½¦è¾†çš„æç¤ºï¼Œå®ƒå°†åˆ©ç”¨ç›¸åº”çš„å‡½æ•°æ¥å¤„ç†ã€‚æˆ‘ä»¬åœ¨è¿™é‡Œç”¨ä¸€äº›ç¤ºä¾‹ä»£ç æ¥æ‰§è¡Œè¿™ä¸ªæ“ä½œï¼š
- en: 'Sample 1: The original â€œAbout Meâ€ text. (See above.)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç¤ºä¾‹ 1ï¼šåŸå§‹çš„â€œå…³äºæˆ‘â€æ–‡æœ¬ã€‚ï¼ˆè§ä¸Šæ–‡ã€‚ï¼‰
- en: 'Sample 2: *â€œMy name is David Hundley. I am a principal machine learning engineer,
    and I have two daughters.â€*'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç¤ºä¾‹ 2ï¼š*â€œæˆ‘çš„åå­—æ˜¯ David Hundleyã€‚æˆ‘æ˜¯ä¸€åé¦–å¸­æœºå™¨å­¦ä¹ å·¥ç¨‹å¸ˆï¼Œæˆ‘æœ‰ä¸¤ä¸ªå¥³å„¿ã€‚â€*
- en: 'Sample 3: *â€œShe drives a Kia Sportage.â€*'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç¤ºä¾‹ 3ï¼š*â€œå¥¹å¼€çš„æ˜¯ä¸€è¾†èµ·äºšæ™ºè·‘ã€‚â€*
- en: '![](../Images/b7fb9578c9fc406ec2389c960695b2e6.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b7fb9578c9fc406ec2389c960695b2e6.png)'
- en: 'Sample #1â€™s Results (Captured by the author)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç¤ºä¾‹ #1 çš„ç»“æœï¼ˆä½œè€…æ•è·ï¼‰'
- en: '![](../Images/4ca85cd4c01fe31f567aedb45838fbfd.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4ca85cd4c01fe31f567aedb45838fbfd.png)'
- en: 'Sample #2â€™s Results (Captured by the author)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç¤ºä¾‹ #2 çš„ç»“æœï¼ˆä½œè€…æ•è·ï¼‰'
- en: '![](../Images/6f10796afa0b3dd7f8c45034501135b0.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6f10796afa0b3dd7f8c45034501135b0.png)'
- en: 'Sample #3â€™s results:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç¤ºä¾‹ #3 çš„ç»“æœï¼š'
- en: 'With each of the respective prompts, ChatGPT selected the correct custom function,
    and we can specifically note that in the `name` value under `function_call` in
    the APIâ€™s response object. In addition to this being a handy way to identify which
    function to use the arguments for, we can programmatically map our actual custom
    Python function to this value to run the correct code appropriately. If that doesnâ€™t
    make sense, perhaps looking at this in code would make this more clear:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ¯ä¸ªç›¸åº”çš„æç¤ºä¸­ï¼ŒChatGPTé€‰æ‹©äº†æ­£ç¡®çš„è‡ªå®šä¹‰å‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥ç‰¹åˆ«æ³¨æ„åˆ°APIå“åº”å¯¹è±¡ä¸­`function_call`ä¸‹çš„`name`å€¼ã€‚é™¤äº†è¿™æ˜¯è¯†åˆ«å“ªä¸ªå‡½æ•°ä½¿ç”¨å‚æ•°çš„ä¾¿æ·æ–¹å¼å¤–ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥å°†å®é™…çš„è‡ªå®šä¹‰Pythonå‡½æ•°ç¨‹åºåŒ–åœ°æ˜ å°„åˆ°è¿™ä¸ªå€¼ä¸Šï¼Œä»¥æ­£ç¡®åœ°è¿è¡Œä»£ç ã€‚å¦‚æœè¿™ä¸å¤ªæ¸…æ¥šï¼Œä¹Ÿè®¸æŸ¥çœ‹ä»£ç ä¼šæ›´æ˜ç™½ï¼š
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![](../Images/d881eb31c35582412985e4f3e656dba7.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d881eb31c35582412985e4f3e656dba7.png)'
- en: Final programmatic results! (Captured by the author)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€ç»ˆç¨‹åºç»“æœï¼ï¼ˆä½œè€…æ•è·ï¼‰
- en: '****Beware one thing****: In the spirit of full transparency, I had to run
    that code there multiple times to get it to produce like that. The trouble is
    that because the `extract_person_info` and `extract_all_info` are more similar
    in nature, ChatGPT kept confusing those for one another. I guess the lesson to
    be learned here is that your functions should be extracting distinct information.
    I also only tested using `gpt-3.5-turbo`, so itâ€™s possible that a more powerful
    model like GPT-4 could have handled that better.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '****æ³¨æ„äº‹é¡¹****ï¼šä¸ºäº†å®Œå…¨é€æ˜ï¼Œæˆ‘å¿…é¡»å¤šæ¬¡è¿è¡Œé‚£æ®µä»£ç æ‰èƒ½ä½¿å…¶äº§ç”Ÿè¿™æ ·çš„ç»“æœã€‚é—®é¢˜åœ¨äºï¼Œå› ä¸º`extract_person_info`å’Œ`extract_all_info`çš„æ€§è´¨è¾ƒä¸ºç›¸ä¼¼ï¼ŒChatGPTç»å¸¸æŠŠå®ƒä»¬æ··æ·†åœ¨ä¸€èµ·ã€‚æˆ‘çŒœè¿™é‡Œçš„æ•™è®­æ˜¯ï¼Œä½ çš„å‡½æ•°åº”è¯¥æå–ä¸åŒçš„ä¿¡æ¯ã€‚æˆ‘ä¹Ÿä»…ä½¿ç”¨äº†`gpt-3.5-turbo`è¿›è¡Œæµ‹è¯•ï¼Œå› æ­¤å¯èƒ½åƒGPT-4è¿™æ ·æ›´å¼ºå¤§çš„æ¨¡å‹å¯èƒ½å¤„ç†å¾—æ›´å¥½ã€‚'
- en: '*****Friday, 7/28/23 Update**: I added a new section on how this works with
    LangChain!***'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*****2023å¹´7æœˆ28æ—¥æ›´æ–°**ï¼šæˆ‘æ·»åŠ äº†ä¸€ä¸ªå…³äºå¦‚ä½•ä¸LangChainé…åˆä½¿ç”¨çš„æ–°éƒ¨åˆ†ï¼***'
- en: OpenAI Function Calling with LangChain
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenAIå‡½æ•°è°ƒç”¨ä¸LangChain
- en: Given the popular usage of LangChain, I thought it might be useful for how you
    might use this same function calling capability within that framework. Now, for
    folks familiar with LangChain, you might already be aware that LangChain offers
    its own parsing capabilities, and these parsing capabilities are largely enabled
    through advanced prompt engineering.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: é‰´äºLangChainçš„å¹¿æ³›ä½¿ç”¨ï¼Œæˆ‘è®¤ä¸ºäº†è§£å¦‚ä½•åœ¨è¯¥æ¡†æ¶å†…ä½¿ç”¨ç›¸åŒçš„å‡½æ•°è°ƒç”¨èƒ½åŠ›å¯èƒ½ä¼šæœ‰ç”¨ã€‚å¯¹äºç†Ÿæ‚‰LangChainçš„äººï¼Œä½ å¯èƒ½å·²ç»çŸ¥é“LangChainæä¾›äº†è‡ªå·±çš„è§£æèƒ½åŠ›ï¼Œè¿™äº›è§£æèƒ½åŠ›ä¸»è¦é€šè¿‡å…ˆè¿›çš„æç¤ºå·¥ç¨‹å®ç°ã€‚
- en: If you are already making use of these LangChain parsers, you might be wondering,
    â€œShould I pivot to use OpenAI function calling for better performance?â€ Unfortunately,
    thereâ€™s not a clean way to answer this question as OpenAI has abstracted away
    what itâ€™s actually doing to enable function calling. (Trust me, I dug through
    the OpenAI client source code, and [this line here](https://github.com/openai/openai-python/blob/main/openai/api_resources/abstract/engine_api_resource.py#L156)
    shows that it is indeed abstracted away!) If youâ€™re already making use of LangChainâ€™s
    parsers, I would probably recommend you stick with those, especially since they
    are portable for other LLMs beyond OpenAI.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ å·²ç»åœ¨ä½¿ç”¨è¿™äº›LangChainè§£æå™¨ï¼Œä½ å¯èƒ½ä¼šæƒ³ï¼Œâ€œæˆ‘æ˜¯å¦åº”è¯¥è½¬å‘ä½¿ç”¨OpenAIå‡½æ•°è°ƒç”¨ä»¥è·å¾—æ›´å¥½çš„æ€§èƒ½ï¼Ÿâ€ ä¸å¹¸çš„æ˜¯ï¼Œæ²¡æœ‰ä¸€ä¸ªæ˜ç¡®çš„ç­”æ¡ˆï¼Œå› ä¸ºOpenAIå·²ç»æŠ½è±¡åŒ–äº†å®ç°å‡½æ•°è°ƒç”¨çš„æ–¹å¼ã€‚ï¼ˆç›¸ä¿¡æˆ‘ï¼Œæˆ‘æ·±å…¥æŒ–æ˜äº†OpenAIå®¢æˆ·ç«¯æºä»£ç ï¼Œ[è¿™ä¸€è¡Œ](https://github.com/openai/openai-python/blob/main/openai/api_resources/abstract/engine_api_resource.py#L156)æ˜¾ç¤ºå®ƒç¡®å®è¢«æŠ½è±¡åŒ–äº†ï¼ï¼‰å¦‚æœä½ å·²ç»åœ¨ä½¿ç”¨LangChainçš„è§£æå™¨ï¼Œæˆ‘å¯èƒ½å»ºè®®ä½ ç»§ç»­ä½¿ç”¨è¿™äº›è§£æå™¨ï¼Œç‰¹åˆ«æ˜¯å› ä¸ºå®ƒä»¬å¯¹äºå…¶ä»–LLMä¹Ÿå…·æœ‰å¯ç§»æ¤æ€§ã€‚
- en: The good news is that if you want to make use of OpenAI function calling in
    tandem with other LangChain functionality (and are okay with only being able to
    pass in one function calling template), you can absolutely do that! Iâ€™m not going
    to cover LangChain in depth in this post, but I would like to show the quick code
    to enable this. Itâ€™s essentially going to involve us importing some LangChain
    objects and using those as â€œwrappersâ€ around what weâ€™ve already created.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: å¥½æ¶ˆæ¯æ˜¯ï¼Œå¦‚æœä½ æƒ³åŒæ—¶åˆ©ç”¨ OpenAI çš„å‡½æ•°è°ƒç”¨å’Œå…¶ä»– LangChain åŠŸèƒ½ï¼ˆå¹¶ä¸”å¯ä»¥æ¥å—åªä¼ å…¥ä¸€ä¸ªå‡½æ•°è°ƒç”¨æ¨¡æ¿ï¼‰ï¼Œä½ å®Œå…¨å¯ä»¥åšåˆ°è¿™ä¸€ç‚¹ï¼æˆ‘ä¸ä¼šåœ¨è¿™ç¯‡æ–‡ç« ä¸­æ·±å…¥ä»‹ç»
    LangChainï¼Œä½†æˆ‘ä¼šå±•ç¤ºå¦‚ä½•å¿«é€Ÿå¯ç”¨å®ƒçš„ä»£ç ã€‚è¿™æœ¬è´¨ä¸Šæ¶‰åŠåˆ°å¯¼å…¥ä¸€äº› LangChain å¯¹è±¡ï¼Œå¹¶å°†å®ƒä»¬ä½œä¸ºæˆ‘ä»¬å·²ç»åˆ›å»ºçš„å†…å®¹çš„â€œåŒ…è£…å™¨â€ã€‚
- en: 'Before we proceed forward, thereâ€™s also another issue with LangChainâ€™s implementationâ€¦
    it doesnâ€™t seem to allow us to submit multiple function calling templates at once.
    Additionally, we will have to reformat the JSON schema for this specific implementation.
    It looks very similar. Letâ€™s do a back-to-back comparison. Hereâ€™s the original
    JSON schema for native OpenAI function calling:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ç»§ç»­ä¹‹å‰ï¼Œè¿˜æœ‰ä¸€ä¸ªé—®é¢˜æ˜¯ LangChain çš„å®ç°â€¦â€¦å®ƒä¼¼ä¹ä¸å…è®¸æˆ‘ä»¬ä¸€æ¬¡æäº¤å¤šä¸ªå‡½æ•°è°ƒç”¨æ¨¡æ¿ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬è¿˜éœ€è¦é‡æ–°æ ¼å¼åŒ– JSON æ¶æ„ä»¥é€‚åº”è¿™ä¸ªç‰¹å®šçš„å®ç°ã€‚å®ƒçœ‹èµ·æ¥éå¸¸ç›¸ä¼¼ã€‚æˆ‘ä»¬æ¥åšä¸€ä¸ªé€å¯¹æ¯”ã€‚ä»¥ä¸‹æ˜¯åŸç”Ÿ
    OpenAI å‡½æ•°è°ƒç”¨çš„ JSON æ¶æ„ï¼š
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And here is what the reformatted version looks like:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯é‡æ–°æ ¼å¼åŒ–åçš„ç‰ˆæœ¬çš„æ ·å­ï¼š
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This little code snippet will show you how to perform the exact same functionality
    that weâ€™ve done above, except now with LangChain!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªå°ä»£ç ç‰‡æ®µå°†å±•ç¤ºå¦‚ä½•æ‰§è¡Œä¸ä¸Šè¿°ç›¸åŒçš„åŠŸèƒ½ï¼Œåªä¸è¿‡è¿™æ¬¡æ˜¯ä½¿ç”¨ LangChainï¼
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see in the screenshot below, we get the exact same results as we
    did before.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œæˆ‘ä»¬å¾—åˆ°çš„ç»“æœä¸ä¹‹å‰å®Œå…¨ç›¸åŒã€‚
- en: '![](../Images/cbe2a02e8c06b602a9fa94b3e014ca38.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/cbe2a02e8c06b602a9fa94b3e014ca38.png)'
- en: Output of the LangChain call (Screenshot captured by the author)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: LangChain è°ƒç”¨çš„è¾“å‡ºï¼ˆæˆªå›¾ç”±ä½œè€…æ•è·ï¼‰
- en: Wrapping Up
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ€»ç»“
- en: I hope you can see now why function calling can be so powerful! When it comes
    to building applications that leverage Generative AI, this kind of function calling
    is a godsend for programmers. By not having to worry so much now about the output
    JSON structure, we can now focus our time on building out other parts of the application.
    Itâ€™s an awesome time to be working in this space
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘å¸Œæœ›ä½ ç°åœ¨èƒ½ç†è§£ä¸ºä»€ä¹ˆå‡½æ•°è°ƒç”¨ä¼šå¦‚æ­¤å¼ºå¤§ï¼åœ¨æ„å»ºåˆ©ç”¨ç”Ÿæˆå¼ AI çš„åº”ç”¨ç¨‹åºæ—¶ï¼Œè¿™ç§å‡½æ•°è°ƒç”¨å¯¹ç¨‹åºå‘˜æ¥è¯´æ˜¯ä¸€ä¸ªç¦éŸ³ã€‚ç”±äºç°åœ¨ä¸å¿…è¿‡å¤šæ‹…å¿ƒè¾“å‡ºçš„ JSON
    ç»“æ„ï¼Œæˆ‘ä»¬å¯ä»¥å°†æ—¶é—´é›†ä¸­åœ¨æ„å»ºåº”ç”¨ç¨‹åºçš„å…¶ä»–éƒ¨åˆ†ã€‚ç°åœ¨åœ¨è¿™ä¸ªé¢†åŸŸå·¥ä½œæ˜¯ä¸€ä¸ªç»å¦™çš„æ—¶æœºã€‚
