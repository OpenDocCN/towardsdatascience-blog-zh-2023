- en: Nine Rules for SIMD Acceleration of Your Rust Code (Part 1)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust代码SIMD加速的九条规则（第一部分）
- en: 原文：[https://towardsdatascience.com/nine-rules-for-simd-acceleration-of-your-rust-code-part-1-c16fe639ce21?source=collection_archive---------2-----------------------#2023-12-12](https://towardsdatascience.com/nine-rules-for-simd-acceleration-of-your-rust-code-part-1-c16fe639ce21?source=collection_archive---------2-----------------------#2023-12-12)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/nine-rules-for-simd-acceleration-of-your-rust-code-part-1-c16fe639ce21?source=collection_archive---------2-----------------------#2023-12-12](https://towardsdatascience.com/nine-rules-for-simd-acceleration-of-your-rust-code-part-1-c16fe639ce21?source=collection_archive---------2-----------------------#2023-12-12)
- en: General Lessons from Boosting Data Ingestion in the `range-set-blaze` Crate
    by 7x
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过将数据摄入在`range-set-blaze`库中提升7倍的一般经验教训。
- en: '[](https://medium.com/@carlmkadie?source=post_page-----c16fe639ce21--------------------------------)[![Carl
    M. Kadie](../Images/9dbe27c76e9567136e5a7dc587f1fb15.png)](https://medium.com/@carlmkadie?source=post_page-----c16fe639ce21--------------------------------)[](https://towardsdatascience.com/?source=post_page-----c16fe639ce21--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----c16fe639ce21--------------------------------)
    [Carl M. Kadie](https://medium.com/@carlmkadie?source=post_page-----c16fe639ce21--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@carlmkadie?source=post_page-----c16fe639ce21--------------------------------)[![Carl
    M. Kadie](../Images/9dbe27c76e9567136e5a7dc587f1fb15.png)](https://medium.com/@carlmkadie?source=post_page-----c16fe639ce21--------------------------------)[](https://towardsdatascience.com/?source=post_page-----c16fe639ce21--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----c16fe639ce21--------------------------------)
    [Carl M. Kadie](https://medium.com/@carlmkadie?source=post_page-----c16fe639ce21--------------------------------)'
- en: ·
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fa5e87027005f&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnine-rules-for-simd-acceleration-of-your-rust-code-part-1-c16fe639ce21&user=Carl+M.+Kadie&userId=a5e87027005f&source=post_page-a5e87027005f----c16fe639ce21---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----c16fe639ce21--------------------------------)
    ·17 min read·Dec 12, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fc16fe639ce21&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnine-rules-for-simd-acceleration-of-your-rust-code-part-1-c16fe639ce21&user=Carl+M.+Kadie&userId=a5e87027005f&source=-----c16fe639ce21---------------------clap_footer-----------)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[关注](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fa5e87027005f&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnine-rules-for-simd-acceleration-of-your-rust-code-part-1-c16fe639ce21&user=Carl+M.+Kadie&userId=a5e87027005f&source=post_page-a5e87027005f----c16fe639ce21---------------------post_header-----------)
    发布于[Towards Data Science](https://towardsdatascience.com/?source=post_page-----c16fe639ce21--------------------------------)
    ·17 min read·Dec 12, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fc16fe639ce21&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnine-rules-for-simd-acceleration-of-your-rust-code-part-1-c16fe639ce21&user=Carl+M.+Kadie&userId=a5e87027005f&source=-----c16fe639ce21---------------------clap_footer-----------)'
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fc16fe639ce21&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnine-rules-for-simd-acceleration-of-your-rust-code-part-1-c16fe639ce21&source=-----c16fe639ce21---------------------bookmark_footer-----------)![](../Images/03b7cab4f40a89f2f1582704fd509bdd.png)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fc16fe639ce21&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnine-rules-for-simd-acceleration-of-your-rust-code-part-1-c16fe639ce21&source=-----c16fe639ce21---------------------bookmark_footer-----------)![](../Images/03b7cab4f40a89f2f1582704fd509bdd.png)'
- en: 'A crab delegating calculations to little crabs — Source: [https://openai.com/dall-e-2/](https://openai.com/dall-e-2/).
    All other figures from the author.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 蟹通过小蟹委派进行计算 — 来源：[https://openai.com/dall-e-2/](https://openai.com/dall-e-2/)。所有其他数据来自作者。
- en: Thanks to Ben Lichtman (B3NNY) at the Seattle Rust Meetup for pointing me in
    the right direction on SIMD.
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 感谢Ben Lichtman（B3NNY）在西雅图Rust Meetup中为我指明了SIMD的正确方向。
- en: '[SIMD](https://en.wikipedia.org/wiki/Single_instruction,_multiple_data) (Single
    Instruction, Multiple Data) operations have been a feature of Intel/AMD and ARM
    CPUs since the early 2000s. These operations enable you to, for example, add an
    array of eight `i32` to another array of eight `i32` with just one CPU operation
    **on a single core**. Using SIMD operations greatly speeds up certain tasks. If
    you’re not using SIMD, you may not be fully using your CPU’s capabilities.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[SIMD](https://en.wikipedia.org/wiki/Single_instruction,_multiple_data)（单指令、多数据）操作自
    2000 年代初以来一直是 Intel/AMD 和 ARM CPU 的一个特性。这些操作使你可以，例如，只用一个 CPU 操作 **在单核** 上将八个 `i32`
    的数组加到另一个八个 `i32` 的数组上。使用 SIMD 操作大大加快了某些任务的速度。如果你没有使用 SIMD，你可能没有充分利用你 CPU 的能力。'
- en: Is this “Yet Another Rust and SIMD” article? Yes and no. Yes, I did apply SIMD
    to a programming problem and then feel compelled to write an article about it.
    No, I hope that this article also goes into enough depth that it can guide you
    through *your* project. It explains the newly available SIMD capabilities and
    settings in Rust nightly. It includes a Rust SIMD cheatsheet. It shows how to
    make your SIMD code generic without leaving safe Rust. It gets you started with
    tools such as Godbolt and Criterion. Finally, it introduces new cargo commands
    that make the process easier.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这篇文章是“另一个 Rust 和 SIMD”文章吗？是的，也不是。是的，我确实将 SIMD 应用于一个编程问题，然后觉得有必要写一篇文章。不是，我希望这篇文章也能深入到足以指导你完成*你的*项目。它解释了
    Rust nightly 中新提供的 SIMD 功能和设置。它包括一个 Rust SIMD 速查表。它展示了如何在不离开安全 Rust 的情况下使你的 SIMD
    代码通用。它让你开始使用如 Godbolt 和 Criterion 等工具。最后，它介绍了简化过程的新 cargo 命令。
- en: The `[range-set-blaze](https://crates.io/crates/range-set-blaze)` crate uses
    its `RangeSetBlaze::from_iter` method to ingest potentially long sequences of
    integers. When the integers are “clumpy”, it can do this [30 times faster](https://github.com/CarlKCarlK/range-set-blaze/blob/main/docs/bench.md)
    than Rust’s standard `HashSet::from_iter`. Can we do even better if we use SIMD
    operations? Yes!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`[range-set-blaze](https://crates.io/crates/range-set-blaze)` crate 使用其 `RangeSetBlaze::from_iter`
    方法来处理可能很长的整数序列。当整数是“clumpy”时，它可以比 Rust 的标准 `HashSet::from_iter` [快 30 倍](https://github.com/CarlKCarlK/range-set-blaze/blob/main/docs/bench.md)。如果我们使用
    SIMD 操作，能做到更好吗？是的！'
- en: See [this documentation](https://docs.rs/range-set-blaze/latest/range_set_blaze/struct.RangeSetBlaze.html#constructor-performance)
    for the definition of “clumpy”. Also, what happens if the integers are not clumpy?
    `RangeSetBlaze` is [2 to 3 times *slower*](https://github.com/CarlKCarlK/range-set-blaze/blob/main/docs/bench.md)
    than `HashSet`.
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 查看 [此文档](https://docs.rs/range-set-blaze/latest/range_set_blaze/struct.RangeSetBlaze.html#constructor-performance)
    了解“clumpy”的定义。此外，当整数不不规则时会发生什么？`RangeSetBlaze` 比 `HashSet` [慢 2 到 3 倍](https://github.com/CarlKCarlK/range-set-blaze/blob/main/docs/bench.md)。
- en: On clumpy integers, `RangeSetBlaze::from_slice` — a new method based on SIMD
    operations — is 7 times faster than `RangeSetBlaze::from_iter.` That makes it
    more than 200 times faster than `HashSet::from_iter`. (When the integers are not
    clumpy, it is still 2 to 3 times slower than `HashSet`.)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不规则整数，`RangeSetBlaze::from_slice` — 基于 SIMD 操作的新方法 — 比 `RangeSetBlaze::from_iter`
    快 7 倍。这使它比 `HashSet::from_iter` 快超过 200 倍。（当整数不不规则时，它仍然比 `HashSet` 慢 2 到 3 倍。）
- en: Over the course of implementing this speed up, I learned nine rules that can
    help you accelerate your projects with SIMD operations.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现这一加速的过程中，我学到了九条规则，这些规则可以帮助你使用 SIMD 操作加速你的项目。
- en: 'The rules are:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则是：
- en: Use nightly Rust and `core::simd`, Rust’s experimental standard SIMD module.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 nightly Rust 和 `core::simd`，Rust 的实验性标准 SIMD 模块。
- en: 'CCC: Check, Control, and Choose your computer’s SIMD capabilities.'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'CCC: 检查、控制并选择你计算机的 SIMD 能力。'
- en: Learn `core::simd`, but selectively.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 学习 `core::simd`，但要有选择地。
- en: Brainstorm candidate algorithms.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 头脑风暴候选算法。
- en: Use Godbolt and AI to understand your code’s assembly, even if you don’t know
    assembly language.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Godbolt 和 AI 来理解你代码的汇编，即使你不懂汇编语言。
- en: Generalize to all types and LANES with in-lined generics, (and when that doesn’t
    work) macros, and (when that doesn’t work) traits.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用内联泛型（当这不起作用时）宏，（当宏不起作用时）特性，将其推广到所有类型和 LANES。
- en: 'See [Part 2](/nine-rules-for-simd-acceleration-of-your-rust-code-part-2-6a104b3be6f3)
    for these rules:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [第 2 部分](/nine-rules-for-simd-acceleration-of-your-rust-code-part-2-6a104b3be6f3)
    以获取这些规则：
- en: '*7\. Use Criterion benchmarking to pick an algorithm and to discover that LANES
    should (almost) always be 32 or 64.*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*7\. 使用 Criterion 基准测试来选择算法，并发现 LANES 应该（几乎）始终为 32 或 64。*'
- en: '*8\. Integrate your best SIMD algorithm into your project with* `*as_simd*`*,
    special code for* `*i128*`*/*`*u128*`*, and additional in-context benchmarking.*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*8\. 将您的最佳SIMD算法集成到您的项目中，并使用* `*as_simd*` *特别的代码处理* `*i128*` */* `*u128*` *，并额外进行上下文基准测试。*'
- en: '*9\. Extricate your best SIMD algorithm from your project (for now) with an
    optional cargo feature.*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*9\. 从项目中提取出您的最佳SIMD算法（目前）并选择一个可选的cargo特性。*'
- en: '*Aside: To avoid wishy-washiness, I call these “rules”, but they are, of course,
    just suggestions.*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*旁注：为了避免含糊其辞，我称这些为“规则”，但它们当然只是建议。*'
- en: 'Rule 1: Use nightly Rust and `core::simd`, Rust’s experimental standard SIMD
    module.'
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则1：使用nightly Rust和 `core::simd`，Rust的实验性标准SIMD模块。
- en: 'Rust can access SIMD operations either via the stable `[core::arch](https://doc.rust-lang.org/core/arch/index.html)`
    module or via nighty’s `[core::simd](https://doc.rust-lang.org/nightly/core/simd/struct.Simd.html)`
    module. Let’s compare them:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Rust可以通过稳定的 `[core::arch](https://doc.rust-lang.org/core/arch/index.html)` 模块或nightly的
    `[core::simd](https://doc.rust-lang.org/nightly/core/simd/struct.Simd.html)` 模块访问SIMD操作。让我们比较一下它们：
- en: '`**core::arch**`'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`**core::arch**`'
- en: Stable
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 稳定
- en: '[“[N]ot the easiest thing in the world](https://doc.rust-lang.org/core/arch/index.html#ergonomics)”'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“[这并非世界上最容易的事情](https://doc.rust-lang.org/core/arch/index.html#ergonomics)”]'
- en: Offers high-performance to downstream users of your crate. For example, because
    [regex](https://github.com/BurntSushi/regex) and `[memchr](https://github.com/BurntSushi/memchr)`
    went this route, over 100,000 other crates got stable SIMD acceleration for free.
    [[Reddit discussion](https://www.reddit.com/r/rust/comments/18hj1m6/comment/kdbfktb/?utm_source=share&utm_medium=web2x&context=3),
    [some relevant](https://github.com/BurntSushi/memchr/blob/master/src/arch/x86_64/memchr.rs)
    `[memchr](https://github.com/BurntSushi/memchr/blob/master/src/arch/x86_64/memchr.rs)`
    [code](https://github.com/BurntSushi/memchr/blob/master/src/arch/x86_64/memchr.rs)]
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的crate的下游用户提供高性能。例如，因为[regex](https://github.com/BurntSushi/regex)和[`memchr`](https://github.com/BurntSushi/memchr)采用了这种方法，超过100,000个其他crate免费获得了稳定的SIMD加速。[[Reddit讨论](https://www.reddit.com/r/rust/comments/18hj1m6/comment/kdbfktb/?utm_source=share&utm_medium=web2x&context=3)，[一些相关的](https://github.com/BurntSushi/memchr/blob/master/src/arch/x86_64/memchr.rs)
    [`memchr`](https://github.com/BurntSushi/memchr/blob/master/src/arch/x86_64/memchr.rs)
    [代码](https://github.com/BurntSushi/memchr/blob/master/src/arch/x86_64/memchr.rs)]
- en: '`**core::simd**`'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`**core::simd**`'
- en: Nightly
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nightly
- en: Delightfully easy and portable.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 令人愉快的简单和可移植。
- en: Limits downstream users to nightly.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制了向下游用户只能使用nightly版。
- en: I decided to go with “easy”. If you decide to take the harder road, starting
    first with the easier path may still be worthwhile.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我决定选择“简单”。如果您决定选择更难的路线，首先从更简单的路径开始可能仍然是值得的。
- en: 'In either case, before we try to use SIMD operations in a larger project, let’s
    make sure we can get them working at all. Here are the steps:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种情况，在我们尝试在一个更大的项目中使用SIMD操作之前，让我们确保我们能够完全使用它们。以下是步骤：
- en: 'First, create a project called `simd_hello`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个名为 `simd_hello` 的项目：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Edit `src/main.rs` to contain ([Rust playground](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2021&gist=e39aa876c0abed9915d389fe73687839)):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '编辑 `src/main.rs` 以包含 ([Rust playground](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2021&gist=e39aa876c0abed9915d389fe73687839)):'
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next — full SIMD capabilities require the nightly version of Rust. Assuming
    you have Rust installed, install nightly (`rustup install nightly`). Make sure
    you have the latest nightly version (`rustup update nightly`). Finally, set this
    project to use nightly (`rustup override set nightly`).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来 —— 全面的SIMD功能需要Rust的nightly版本。假设您已安装了Rust，请安装nightly版 (`rustup install nightly`)。确保您有最新的nightly版本
    (`rustup update nightly`)。最后，设置此项目使用nightly版 (`rustup override set nightly`)。
- en: You can now run the program with `cargo run`. The program applies [ROT13 decryption](https://en.wikipedia.org/wiki/ROT13)
    to 32 bytes of upper-case letters. With SIMD, the program can decrypt all 32 bytes
    simultaneously.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以使用 `cargo run` 运行程序。该程序对32个大写字母的ROT13解密。通过SIMD，程序可以同时解密所有32个字节。
- en: 'Let’s look at each section of the program to see how it works. It starts with:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看程序的每个部分是如何工作的。它从以下开始：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Rust nightly offers its extra capabilities (or “features”) only on request.
    The `#![feature(portable_simd)]` statement requests that Rust nightly make available
    the new experimental `core::simd` module. The `use` statement then imports the
    module’s most important types and traits.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Rust nightly仅在请求时提供其额外的功能（或“特性”）。 `#![feature(portable_simd)]` 语句请求Rust nightly可用新的实验性
    `core::simd` 模块。然后，`use` 语句导入了模块的最重要的类型和特征。
- en: 'In the code’s next section, we define useful constants:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的下一部分中，我们定义了一些有用的常量：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Simd` struct is a special kind of Rust array. (It is, for example, always
    memory aligned.) The constant `LANES` tells the length of the `Simd` array. The
    `from_array` constructor copies a regular Rust array to create a `Simd`. In this
    case, because we want `const` `Simd`’s, the arrays we construct from must also
    be `const`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`Simd`结构体是一种特殊类型的Rust数组。（例如，它始终是内存对齐的。）常量`LANES`告诉了`Simd`数组的长度。`from_array`构造函数复制一个常规的Rust数组来创建一个`Simd`。在这种情况下，因为我们需要`const`
    `Simd`，所以我们构造的数组也必须是`const`。'
- en: The next two lines copy our encrypted text into `data` and then adds 13 to each
    letter.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两行将我们加密的文本复制到`data`，然后对每个字母添加13。
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What if you make an error and your encrypted text isn’t exactly length `LANES`
    (32)? Sadly, the compiler won’t tell you. Instead, when you run the program, `from_slice`
    will panic. What if the encrypted text contains non-upper-case letters? In this
    example program, we’ll ignore that possibility.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您出错了，您的加密文本长度不正好为`LANES`（32）怎么办？遗憾的是，编译器不会告诉您。相反，在运行程序时，`from_slice`将会崩溃。如果加密文本包含非大写字母怎么办？在本示例程序中，我们将忽略这种可能性。
- en: The `+=` operator does element-wise addition between the `Simd` `data` and `Simd`
    `THIRTEENS`. It puts the result in `data`. Recall that debug builds of regular
    Rust addition check for overflows. Not so with SIMD. Rust defines SIMD arithmetic
    operators to always wrap. Values of type `u8` wrap after 255.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`+=`操作符在`Simd` `data`和`Simd` `THIRTEENS`之间进行逐元素加法。它将结果放入`data`中。请记住，常规Rust加法的调试构建会检查溢出。但SIMD不会这样做。Rust定义了SIMD算术运算符总是进行包装。类型为`u8`的值在255之后会包装。'
- en: Coincidentally, Rot13 decryption also requires wrapping, but after ‘Z’ rather
    than after 255\. Here is one approach to coding the needed Rot13 wrapping. It
    subtracts 26 from any values [on beyond ‘Z](https://en.wikipedia.org/wiki/On_Beyond_Zebra!)’.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 巧合的是，Rot13解密也需要包装，但是在‘Z’之后而不是在255之后。这里有一种编码所需Rot13包装的方法。它从任何值中减去26，超出了‘Z’。
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This says to find the element-wise places beyond ‘Z’. Then, subtract 26 from
    all values. At the places of interest, use the subtracted values. At the other
    places, use the original values. Does subtracting from all values and then using
    only some seem wasteful? With SIMD, this takes no extra computer time and avoids
    jumps. This strategy is, thus, efficient and common.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要求找到逐个元素的超过‘Z’的位置。然后，从所有值中减去26。在感兴趣的位置，使用减去的值。在其他位置，使用原始值。从所有值中减去然后只使用一些看起来是不是浪费了？使用SIMD，这不需要额外的计算机时间并且避免了跳转。因此，这种策略是高效且常见的。
- en: 'The program ends like so:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 程序以此方式结束：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice the `.as_array()` method. It safely transmutes a `Simd` struct into a
    regular Rust array without copying.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`.as_array()`方法。它安全地将`Simd`结构体转换为常规的Rust数组而不复制。
- en: Surprisingly to me, this program runs fine on computers without SIMD extensions.
    Rust nightly compiles the code to regular (non-SIMD) instructions. But we don’t
    just want to run “fine”, we want to run *faster*. That requires us to turn on
    our computer’s SIMD power.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 令我惊讶的是，这个程序在没有SIMD扩展的计算机上运行良好。Rust nightly将代码编译成常规（非SIMD）指令。但我们不仅仅想要运行“良好”，我们想要运行*更快*。这需要我们打开计算机的SIMD性能。
- en: 'Rule 2: CCC: Check, Control, and Choose your computer’s SIMD capabilities.'
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则2：CCC：检查，控制和选择您计算机的SIMD能力。
- en: To make SIMD programs run faster on your machine, you must first discover which
    SIMD extensions your machine supports. If you have an Intel/AMD machine, you can
    use my `[simd-detect](https://github.com/CarlKCarlK/cargo-simd-detect)` cargo
    command.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要使SIMD程序在您的计算机上运行得更快，您必须首先发现您的计算机支持哪些SIMD扩展。如果您有Intel/AMD计算机，可以使用我的`[simd-detect](https://github.com/CarlKCarlK/cargo-simd-detect)`
    cargo命令。
- en: 'Run with:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 运行：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'On my machine, it outputs:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的计算机上，输出如下：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This says that my machine supports the `sse2`, `avx2`, and `avx512f` SIMD extensions.
    Of those, by default, Rust enables the ubiquitous twenty-year-old `sse2` extension.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明我的计算机支持`sse2`，`avx2`和`avx512f` SIMD扩展。在其中，默认情况下，Rust启用了普遍存在已有二十年历史的`sse2`扩展。
- en: The SIMD extensions form a hierarchy with `avx512f` above `avx2` above `sse2`.
    Enabling a higher-level extension also enables the lower-level extensions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: SIMD扩展形成一个层次结构，`avx512f`在`avx2`之上，在`sse2`之上。启用更高级别的扩展也会启用较低级别的扩展。
- en: 'Most Intel/AMD computers also support the ten-year-old `avx2` extension. You
    enable it by setting an environment variable:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Intel/AMD计算机也支持十年历史的`avx2`扩展。您可以通过设置环境变量来启用它：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: “Force install” and run `simd-detect` again and you should see that `avx2` is
    enabled.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: “强制安装”并再次运行`simd-detect`，您应该看到启用了`avx2`。
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Alternatively, you can turn on every SIMD extension that your machine supports:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以打开你的机器支持的每一个 SIMD 扩展：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: On my machine this enables `avx512f`, a newer SIMD extension supported by some
    Intel computers and a few AMD computers.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的机器上，这启用了 `avx512f`，这是一种新的 SIMD 扩展，由一些英特尔计算机和少数 AMD 计算机支持。
- en: 'You can set SIMD extensions back to their default (`sse2` on Intel/AMD) with:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 SIMD 扩展设置回它们的默认值（在英特尔/AMD 上是 `sse2`）：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You may wonder why `target-cpu=native` isn’t Rust’s default. The problem is
    that binaries created using `avx2` or `avx512f` won’t run on computers missing
    those SIMD extensions. So, if you are compiling only for your own use, use `target-cpu=native`.
    If, however, you are compiling for others, choose your SIMD extensions thoughtfully
    and let people know which SIMD extension level you are assuming.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么 `target-cpu=native` 不是 Rust 的默认值。问题在于使用 `avx2` 或 `avx512f` 创建的二进制文件不能在缺少这些
    SIMD 扩展的计算机上运行。因此，如果只为自己使用编译，请使用 `target-cpu=native`。然而，如果为其他人编译，请慎重选择 SIMD 扩展，并告知人们你所假设的
    SIMD 扩展级别。
- en: Happily, whatever level of SIMD extension you pick, Rust’s SIMD support is so
    flexible you can easily change your decision later. Let’s next learn details of
    programming with SIMD in Rust.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 令人高兴的是，无论你选择哪种 SIMD 扩展级别，Rust 的 SIMD 支持都非常灵活，你可以轻松更改你的决策。接下来让我们详细了解在 Rust 中使用
    SIMD 编程的细节。
- en: 'Rule 3: Learn `core::simd`, but selectively.'
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 3：学习 `core::simd`，但要有选择性。
- en: To build with Rust’s new `[core::simd](https://doc.rust-lang.org/nightly/core/simd/index.html)`
    module you should learn selected building blocks. Here is a [cheatsheet](https://github.com/CarlKCarlK/range-set-blaze/blob/nov23/examples/simd/rust_simd_cheatsheet.md)
    with the structs, methods, etc., that I’ve found most useful. Each item includes
    a link to its [documentation](https://doc.rust-lang.org/nightly/core/simd/index.html).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Rust 的新 `[core::simd](https://doc.rust-lang.org/nightly/core/simd/index.html)`
    模块，你应该学习选择的构建模块。这里有一个[速查表](https://github.com/CarlKCarlK/range-set-blaze/blob/nov23/examples/simd/rust_simd_cheatsheet.md)，包含我发现最有用的结构体、方法等。每个项目都包含到其[文档](https://doc.rust-lang.org/nightly/core/simd/index.html)的链接。
- en: Structs
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构体
- en: '`[Simd](https://doc.rust-lang.org/nightly/core/simd/struct.Simd.html)` - a
    special, aligned, fixed-length array of `[SimdElement](https://doc.rust-lang.org/std/simd/trait.SimdElement.html)`.
    We refer to a position in the array and the element stored at that position as
    a “lane”. By default, we copy `Simd` structs rather than reference them.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[Simd](https://doc.rust-lang.org/nightly/core/simd/struct.Simd.html)` - 一个特殊的、对齐的、固定长度的数组，由`[SimdElement](https://doc.rust-lang.org/std/simd/trait.SimdElement.html)`组成。我们将数组中的位置及其存储的元素称为“lane”。默认情况下，我们复制
    `Simd` 结构体而不是引用它们。'
- en: '`[Mask](https://doc.rust-lang.org/nightly/core/simd/struct.Mask.html)` - a
    special Boolean array showing inclusion/exclusion on a per-lane basis.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[Mask](https://doc.rust-lang.org/nightly/core/simd/struct.Mask.html)` - 一种特殊的布尔数组，显示每个
    lane 的包含/排除情况。'
- en: SimdElements
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SimdElements
- en: 'Floating-Point Types: `f32`, `f64`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点类型：`f32`、`f64`
- en: 'Integer Types: `i8`, `u8`, `i16`, `u16`, `i32`, `u32`, `i64`, `u64`, `isize`,
    `usize`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数类型：`i8`、`u8`、`i16`、`u16`、`i32`、`u32`、`i64`、`u64`、`isize`、`usize`
- en: — [*but not*](https://github.com/rust-lang/portable-simd/issues/108) `[*i128*](https://github.com/rust-lang/portable-simd/issues/108)`[*,*](https://github.com/rust-lang/portable-simd/issues/108)
    `[*u128*](https://github.com/rust-lang/portable-simd/issues/108)`
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: — [*但不包括*](https://github.com/rust-lang/portable-simd/issues/108) `[*i128*](https://github.com/rust-lang/portable-simd/issues/108)`[*,*](https://github.com/rust-lang/portable-simd/issues/108)
    `[*u128*](https://github.com/rust-lang/portable-simd/issues/108)`
- en: '`**Simd**` **constructors**'
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`**Simd**` **构造函数**'
- en: '`[Simd::from_array](https://doc.rust-lang.org/nightly/core/simd/struct.Simd.html#method.from_array)`
    - creates a `Simd` struct by copying a fixed-length array.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[Simd::from_array](https://doc.rust-lang.org/nightly/core/simd/struct.Simd.html#method.from_array)`
    - 通过复制固定长度数组创建一个 `Simd` 结构体。'
- en: '`[Simd::from_slice](https://doc.rust-lang.org/nightly/core/simd/struct.Simd.html#method.from_slice)`
    - creates a `Simd<T,LANE>` struct by copying the first `LANE` elements of a slice.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[Simd::from_slice](https://doc.rust-lang.org/nightly/core/simd/struct.Simd.html#method.from_slice)`
    - 通过复制切片的前 `LANE` 个元素创建一个 `Simd<T,LANE>` 结构体。'
- en: '`[Simd::splat](https://doc.rust-lang.org/nightly/core/simd/struct.Simd.html#method.splat)`
    - replicates a single value across all lanes of a `Simd` struct.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[Simd::splat](https://doc.rust-lang.org/nightly/core/simd/struct.Simd.html#method.splat)`
    - 将单个值复制到 `Simd` 结构的所有 lane 中。'
- en: '`[slice::as_simd](https://doc.rust-lang.org/nightly/core/simd/struct.Simd.html#method.to_simd)`
    - without copying, safely transmutes a regular slice into an aligned slice of
    `Simd` (plus unaligned leftovers).'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[slice::as_simd](https://doc.rust-lang.org/nightly/core/simd/struct.Simd.html#method.to_simd)`
    - 安全地将常规切片转换为对齐的 `Simd` 切片（加上不对齐的剩余部分），而不进行复制。'
- en: '`**Simd**` **conversion**'
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`**Simd**` **转换**'
- en: '`[Simd::as_array](https://doc.rust-lang.org/nightly/core/simd/struct.Simd.html#method.as_array)`
    - without copying, safely transmutes an `Simd` struct into a regular array reference.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[Simd::as_array](https://doc.rust-lang.org/nightly/core/simd/struct.Simd.html#method.as_array)`
    - 在不复制的情况下，将`Simd`结构体安全地转换为普通数组引用。'
- en: '`**Simd**` **methods and operators**'
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**Simd** **方法和运算符**'
- en: '`[simd[i]](https://doc.rust-lang.org/nightly/core/simd/struct.Simd.html#method.index)`
    - extract a value from a lane of a `Simd`.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[simd[i]](https://doc.rust-lang.org/nightly/core/simd/struct.Simd.html#method.index)`
    - 从`Simd`的一个通道中提取一个值。'
- en: '`[simd + simd](https://doc.rust-lang.org/core/simd/struct.Simd.html#impl-Add%3C%26''rhs+Simd%3CT,+LANES%3E%3E-for-%26''lhs+Simd%3CT,+LANES%3E)`
    - performs element-wise addition of two `Simd` structs. Also, supported `-`, `*`,
    `/`, `%`, remainder, bitwise-and, -or, xor, -not, -shift.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[simd + simd](https://doc.rust-lang.org/core/simd/struct.Simd.html#impl-Add%3C%26''rhs+Simd%3CT,+LANES%3E%3E-for-%26''lhs+Simd%3CT,+LANES%3E)`
    - 执行两个`Simd`结构体的元素级加法。同时支持`-`、`*`、`/`、`%`、余数、按位与、按位或、异或、按位非、位移。'
- en: '`[simd += simd](https://doc.rust-lang.org/core/simd/struct.Simd.html#impl-AddAssign%3CU%3E-for-Simd%3CT,+LANES%3E)`
    - adds another `Simd` struct to the current one, in place. Other operators supported,
    too.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[simd += simd](https://doc.rust-lang.org/core/simd/struct.Simd.html#impl-AddAssign%3CU%3E-for-Simd%3CT,+LANES%3E)`
    - 将另一个`Simd`结构体加到当前结构体上，进行就地操作。其他运算符也受支持。'
- en: '`[Simd::simd_gt](https://doc.rust-lang.org/nightly/core/simd/struct.Simd.html#method.simd_gt)`
    - compares two `Simd` structs, returning a `Mask` indicating which elements of
    the first are greater than those of the second. Also, supported `simd_lt`, `simd_le`,
    `simd_ge`, `simd_lt`, `simd_eq`, `simd_ne`.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[Simd::simd_gt](https://doc.rust-lang.org/nightly/core/simd/struct.Simd.html#method.simd_gt)`
    - 比较两个`Simd`结构体，返回一个`Mask`，指示第一个结构体的哪些元素大于第二个结构体的元素。同时支持`simd_lt`、`simd_le`、`simd_ge`、`simd_lt`、`simd_eq`、`simd_ne`。'
- en: '`[Simd::rotate_elements_left](https://doc.rust-lang.org/nightly/core/simd/struct.Simd.html#method.rotate_elements_left)`
    - rotates the elements of a `Simd` struct to the left by a specified amount. Also,
    `rotate_elements_right`.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[Simd::rotate_elements_left](https://doc.rust-lang.org/nightly/core/simd/struct.Simd.html#method.rotate_elements_left)`
    - 将`Simd`结构体的元素向左旋转指定的数量。同时支持`rotate_elements_right`。'
- en: '`[simd_swizzle!(simd, indexes)](https://doc.rust-lang.org/std/simd/prelude/macro.simd_swizzle.html)`
    - rearranges the elements of a `Simd` struct based on the specified const indexes.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[simd_swizzle!(simd, indexes)](https://doc.rust-lang.org/std/simd/prelude/macro.simd_swizzle.html)`
    - 根据指定的常量索引重新排列`Simd`结构体的元素。'
- en: '`[simd == simd](https://doc.rust-lang.org/nightly/core/simd/struct.Simd.html#impl-Eq-for-Simd%3CT,+N%3E)`
    - checks for equality between two `Simd` structs, returning a regular `bool` result.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[simd == simd](https://doc.rust-lang.org/nightly/core/simd/struct.Simd.html#impl-Eq-for-Simd%3CT,+N%3E)`
    - 检查两个`Simd`结构体之间的相等性，返回一个普通的`bool`结果。'
- en: '`[Simd::reduce_and](https://doc.rust-lang.org/nightly/core/simd/struct.Simd.html#method.reduce_and)`
    - performs a bitwise AND reduction across all lanes of a `Simd` struct. Also,
    supported: `reduce_or`, `reduce_xor`, `reduce_max`, `reduce_min`, `reduce_sum`
    (but no`reduce_eq`).'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[Simd::reduce_and](https://doc.rust-lang.org/nightly/core/simd/struct.Simd.html#method.reduce_and)`
    - 执行`Simd`结构体所有通道的按位与归约。同时支持：`reduce_or`、`reduce_xor`、`reduce_max`、`reduce_min`、`reduce_sum`（但不支持`reduce_eq`）。'
- en: '`**Mask**` **methods and operators**'
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**掩码** **方法和运算符**'
- en: '`[Mask::select](https://doc.rust-lang.org/nightly/core/simd/struct.Mask.html#method.select)`
    - selects elements from two `Simd` struct based on a mask.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[Mask::select](https://doc.rust-lang.org/nightly/core/simd/struct.Mask.html#method.select)`
    - 根据掩码从两个`Simd`结构体中选择元素。'
- en: '`[Mask::all](https://doc.rust-lang.org/nightly/core/simd/struct.Mask.html#method.all)`
    - tells if the mask is all `true`.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[Mask::all](https://doc.rust-lang.org/nightly/core/simd/struct.Mask.html#method.all)`
    - 指示掩码是否全为`true`。'
- en: '`[Mask::any](https://doc.rust-lang.org/nightly/core/simd/struct.Mask.html#method.all)`
    - tells if the mask contains any `true`.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[Mask::any](https://doc.rust-lang.org/nightly/core/simd/struct.Mask.html#method.all)`
    - 指示掩码是否包含任何`true`。'
- en: '**All about lanes**'
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**关于通道的一切**'
- en: '`[Simd::LANES](https://doc.rust-lang.org/nightly/core/simd/struct.Simd.html#associatedconstant.LANES)`
    - a constant indicating the number of elements (lanes) in a `Simd` struct.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[Simd::LANES](https://doc.rust-lang.org/nightly/core/simd/struct.Simd.html#associatedconstant.LANES)`
    - 一个常量，表示`Simd`结构体中的元素（通道）数量。'
- en: '`[SupportedLaneCount](https://doc.rust-lang.org/nightly/core/simd/trait.SupportedLaneCount.html)`
    - tells the allowed values of `LANES`. Use by generics.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[SupportedLaneCount](https://doc.rust-lang.org/nightly/core/simd/trait.SupportedLaneCount.html)`
    - 指示允许的`LANES`值。通过泛型使用。'
- en: '`[simd.lanes](https://doc.rust-lang.org/core/simd/struct.Simd.html#method.lanes)`
    - const method that tells a `Simd` struct’s number of lanes.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[simd.lanes](https://doc.rust-lang.org/core/simd/struct.Simd.html#method.lanes)`
    - 常量方法，告诉`Simd`结构体的通道数量。'
- en: '**Low-level alignment, offsets, etc.**'
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**低级对齐、偏移量等**'
- en: '*When possible, use* `[*to_simd*](https://doc.rust-lang.org/nightly/core/simd/struct.Simd.html#method.to_simd)`
    *instead.*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽可能使用* `[*to_simd*](https://doc.rust-lang.org/nightly/core/simd/struct.Simd.html#method.to_simd)`
    *代替。*'
- en: '`[mem::size_of](https://doc.rust-lang.org/std/mem/fn.size_of.html)`, `[mem::align_of](https://doc.rust-lang.org/std/mem/fn.align_of.html)`,
    `[mem::align_to](https://doc.rust-lang.org/std/mem/fn.align_to.html)`, `[intrinsics::offset](https://doc.rust-lang.org/std/intrinsics/fn.offset.html)`,
    `[pointer::read_unaligned](https://doc.rust-lang.org/std/primitive.pointer.html#method.read_unaligned)`
    (unsafe), `[pointer::write_unaligned](https://doc.rust-lang.org/std/primitive.pointer.html#method.write_unaligned)`
    (unsafe), `[mem::transmute](https://doc.rust-lang.org/std/mem/fn.transmute.html)`
    (unsafe, const)'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[mem::size_of](https://doc.rust-lang.org/std/mem/fn.size_of.html)`，`[mem::align_of](https://doc.rust-lang.org/std/mem/fn.align_of.html)`，`[mem::align_to](https://doc.rust-lang.org/std/mem/fn.align_to.html)`，`[intrinsics::offset](https://doc.rust-lang.org/std/intrinsics/fn.offset.html)`，`[pointer::read_unaligned](https://doc.rust-lang.org/std/primitive.pointer.html#method.read_unaligned)`（不安全），`[pointer::write_unaligned](https://doc.rust-lang.org/std/primitive.pointer.html#method.write_unaligned)`（不安全），`[mem::transmute](https://doc.rust-lang.org/std/mem/fn.transmute.html)`（不安全，const）'
- en: '**More, perhaps of interest**'
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**更多，也许感兴趣的**'
- en: '`[deinterleave](https://doc.rust-lang.org/nightly/core/simd/struct.Simd.html#method.deinterleave)`,
    `[gather_or](https://doc.rust-lang.org/nightly/core/simd/struct.Simd.html#method.gather_or)`,
    `[reverse](https://doc.rust-lang.org/nightly/core/simd/struct.Simd.html#method.reverse)`,
    `[scatter](https://doc.rust-lang.org/nightly/core/simd/struct.Simd.html#method.scatter)`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[deinterleave](https://doc.rust-lang.org/nightly/core/simd/struct.Simd.html#method.deinterleave)`，`[gather_or](https://doc.rust-lang.org/nightly/core/simd/struct.Simd.html#method.gather_or)`，`[reverse](https://doc.rust-lang.org/nightly/core/simd/struct.Simd.html#method.reverse)`，`[scatter](https://doc.rust-lang.org/nightly/core/simd/struct.Simd.html#method.scatter)`'
- en: With these building blocks at hand, it’s time to build something.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些构建模块，现在是时候创造一些东西了。
- en: 'Rule 4: Brainstorm candidate algorithms.'
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 4：头脑风暴候选算法。
- en: What do *you* want to speed up? You won’t know ahead of time which SIMD approach
    (of any) will work best. You should, therefore, create many algorithms that you
    can then analyze (Rule 5) and benchmark (Rule 7).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你想加速什么？你事先不会知道哪种 SIMD 方法（如果有的话）最好。因此，你应该创建许多算法，然后分析（规则 5）和基准测试（规则 7）它们。
- en: I wanted to speed up `[range-set-blaze](https://crates.io/crates/range-set-blaze)`,
    a crate for manipulating sets of “clumpy” integers. I hoped that creating `is_consecutive`,
    a function to detect blocks of consecutive integers, would be useful.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望加速 `[range-set-blaze](https://crates.io/crates/range-set-blaze)`，一个用于操作“clumpy”整数集的
    crate。我希望创建 `is_consecutive`，一个用于检测连续整数块的函数，会很有用。
- en: '**Background:** Crate `*range-set-blaze*` *works on “clumpy” integers. “C*lumpy”,
    here, means that the number of ranges needed to represent the data is small compared
    to the number of input integers. For example, these 1002 input integers'
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**背景：** Crate `*range-set-blaze*` *用于处理“clumpy”整数。这里的“clumpy”意味着用于表示数据的范围数量与输入整数的数量相比较少。例如，这些
    1002 个输入整数'
- en: ''
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`100, 101,` ..., `489, 499, 501, 502,` ..., `998, 999, 999, 100, 0`'
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`100, 101,` ..., `489, 499, 501, 502,` ..., `998, 999, 999, 100, 0`'
- en: ''
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Ultimately become three Rust ranges:'
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最终变成三个 Rust 范围：
- en: ''
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`0..=0, 100..=499, 501..=999`.'
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`0..=0, 100..=499, 501..=999`。'
- en: ''
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (Internally, the `[*RangeSetBlaze*](https://docs.rs/range-set-blaze/latest/range_set_blaze/struct.RangeSetBlaze.html#)`
    struct represents a set of integers as a sorted list of disjoint ranges stored
    in a cache efficient BTreeMap.)
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: （在内部，`[*RangeSetBlaze*](https://docs.rs/range-set-blaze/latest/range_set_blaze/struct.RangeSetBlaze.html#)`
    结构将整数集表示为存储在高效缓存 BTreeMap 中的排序不相交范围列表。）
- en: ''
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although the input integers are allowed to be unsorted and redundant, we expect
    them to often be “nice”. RangeSetBlaze’s `from_iter` constructor already exploits
    this expectation by grouping up adjacent integers. For example, `from_iter` first
    turns the 1002 input integers into four ranges
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管允许输入整数是无序和冗余的，但我们期望它们通常是“好的”。RangeSetBlaze 的 `from_iter` 构造函数已经利用这一期望通过组合相邻整数来分组。例如，`from_iter`
    首先将这 1002 个输入整数转换为四个范围
- en: ''
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`*100..=499, 501..=999, 100..=100, 0..=0.*`'
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`*100..=499, 501..=999, 100..=100, 0..=0.*`'
- en: ''
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: with minimal, constant memory usage, independent of input size. It then sorts
    and merges these reduced ranges.
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在最小的恒定内存使用下，独立于输入大小。然后，它对这些减少的范围进行排序和合并。
- en: ''
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I wondered if a new `from_slice` method could speed construction from array-like
    inputs by quickly finding (some) consecutive integers. For example, could it—
    with minimal, constant memory — turn the 1002 inputs integers *into five Rust
    ranges:*
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我想知道是否可以通过快速找到（一些）连续整数来加速从类似数组的输入构建的 `from_slice` 方法。例如，是否可以在最小的恒定内存下，将 1002
    个输入整数 *转换为五个 Rust 范围：*
- en: ''
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`*100..=499, 501..=999, 999..=999, 100..=100, 0..=0.*`'
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`*100..=499, 501..=999, 999..=999, 100..=100, 0..=0.*`'
- en: ''
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If so,* `*from_iter*` *could then quickly finish the processing.*'
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*如果是这样，* `*from_iter*` *可以快速完成处理。*'
- en: 'Let’s start by writing `is_consecutive` with regular Rust:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先用常规 Rust 编写 `is_consecutive`：
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The algorithm just loops through the array sequentially, checking that each
    value is one more than its predecessor. It also avoids overflow.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 算法只是顺序遍历数组，检查每个值是否比前一个值多 1。它还避免了溢出。
- en: 'Looping over the items seemed so easy, I wasn’t sure if SIMD could do any better.
    Here was my first attempt:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历这些项似乎很简单，我不确定 SIMD 是否能做得更好。这是我的第一次尝试：
- en: Splat0
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Splat0
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here is an outline of its calculations:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是它的计算概要：
- en: '![](../Images/420908b8497341c078410b9436eaa6d1.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/420908b8497341c078410b9436eaa6d1.png)'
- en: 'Source: This and all following images by author.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：这张图及所有后续图片均由作者提供。
- en: It first (needlessly) checks that the first and last items are 15 apart. It
    then creates `added` by adding 15 to the 0th item, 14 to the next, etc. Finally,
    to see if all items in `added` are the same, it creates a new `Simd` based on
    `added`’s 0th item and then compares. Recall that `splat` creates a `Simd` struct
    from one value.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 它首先（不必要地）检查第一个和最后一个项目是否相隔 15。然后，它通过将 15 加到第 0 项，将 14 加到下一个项，以此类推来创建 `added`。最后，为了查看
    `added` 中的所有项是否相同，它基于 `added` 的第 0 项创建一个新的 `Simd`，然后进行比较。请记住，`splat` 从一个值创建一个
    `Simd` 结构。
- en: Splat1 & Splat2
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Splat1 & Splat2
- en: 'When I mentioned the `is_consecutive` problem to Ben Lichtman, he independently
    came up with this, Splat1:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当我向 Ben Lichtman 提到 `is_consecutive` 问题时，他独立地提出了这个，即 Splat1：
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Splat1 subtracts the comparison value from `chunk` and checks if the result
    is the same as the first element of `chunk`, splatted.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Splat1 从 `chunk` 中减去比较值，并检查结果是否与 `chunk` 的第一个元素相同，经过 splat。
- en: '![](../Images/074c54b0d26c8842f648e64d7246ad79.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/074c54b0d26c8842f648e64d7246ad79.png)'
- en: He also came up with a variation called Splat2 that splats the first element
    of `subtracted` rather than `chunk`. That would seemingly avoid one memory access.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 他还提出了一个变体，称为 Splat2，它 splat `subtracted` 的第一个元素，而不是 `chunk`。这似乎可以避免一次内存访问。
- en: I’m sure you are wondering which of these is best, but before we discuss that
    let’s look at two more candidates.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你一定在想这些方法中哪一个最好，但在我们讨论这个问题之前，让我们再看两个候选者。
- en: Swizzle
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Swizzle
- en: Swizzle is like Splat2 but uses `simd_swizzle!` instead of `splat`. Macro `simd_swizzle!`
    creates a new `Simd` by rearranging the lanes of an old `Simd` according to an
    array of indexes.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Swizzle 类似于 Splat2，但使用 `simd_swizzle!` 而不是 `splat`。宏 `simd_swizzle!` 通过根据索引数组重新排列旧
    `Simd` 的通道来创建一个新的 `Simd`。
- en: '[PRE17]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Rotate
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rotate
- en: This one is different. I had high hopes for it.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法不同。我对它寄予厚望。
- en: '[PRE18]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The idea is to rotate all the elements one to the right. We then subtract the
    original `chunk` from `rotated`. If the input is consecutive, the result should
    be “-15” followed by all 1’s. (Using wrapped subtraction, -15 is `4294967281u32`.)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是将所有元素向右旋转一个位置。然后，我们从 `rotated` 中减去原始的 `chunk`。如果输入是连续的，结果应该是“−15”后跟所有 1。
    （使用包装减法，-15 是 `4294967281u32`。）
- en: '![](../Images/9d8b9ae021da7778af8e11f6ed860b16.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9d8b9ae021da7778af8e11f6ed860b16.png)'
- en: Now that we have candidates, let’s start to evaluate them.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了候选者，让我们开始评估它们。
- en: 'Rule 5: Use Godbolt and AI to understand your code’s assembly, even if you
    don’t know assembly language.'
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 5：使用 Godbolt 和 AI 来理解你的代码的汇编语言，即使你不知道汇编语言。
- en: We’ll evaluate the candidates in two ways. First, in this rule, we’ll look at
    the assembly language generated from our code. Second, in Rule 7, we’ll benchmark
    the code’s speed.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过两种方式评估这些候选者。首先，在这个规则中，我们将查看从代码生成的汇编语言。其次，在规则 7 中，我们将基准测试代码的速度。
- en: Don’t worry if you don’t know assembly language, you can still get something
    out of looking at it.
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你不知道汇编语言，也不要担心，你仍然可以从中获得一些信息。
- en: 'The easiest way to see the generated assembly language is with the [Compiler
    Explorer, AKA Godbolt](https://godbolt.org/z/j5GdGah89). It works best on short
    bits of code that don’t use outside crates. It looks like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 查看生成的汇编语言的最简单方法是使用 [Compiler Explorer, AKA Godbolt](https://godbolt.org/z/j5GdGah89)。它在不使用外部
    crate 的简短代码片段上效果最佳。它看起来像这样：
- en: '![](../Images/1013810e2972f3eb9449156e4404a98f.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1013810e2972f3eb9449156e4404a98f.png)'
- en: 'Referring to the numbers in the figure above, follow these steps to use Godbolt:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 参考上图中的数字，按照以下步骤使用 Godbolt：
- en: Open [godbolt.org](https://godbolt.org/z/odrPv5WcG) with your web browser.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你的网页浏览器打开 [godbolt.org](https://godbolt.org/z/odrPv5WcG)。
- en: Add a new source editor.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的源编辑器。
- en: Select Rust as your language.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 Rust 作为你的语言。
- en: Paste in the code of interest. Make the functions of interest public (`pub fn`).
    Do not include a main or unneeded functions. The tool doesn’t support external
    crates.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 粘贴感兴趣的代码。将感兴趣的函数设为公共（`pub fn`）。不包括主函数或不需要的函数。该工具不支持外部包（external crates）。
- en: Add a new compiler.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加新的编译器。
- en: Set the compiler version to nightly.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将编译器版本设置为nightly。
- en: Set options (for now) to `-C opt-level=3 -C target-feature=+avx512f.`
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置选项（暂时）为`-C opt-level=3 -C target-feature=+avx512f.`
- en: If there are errors, look at the output.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有错误，请查看输出。
- en: If you want to share or save the state of the tool, click “Share”
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想分享或保存工具的状态，请点击“分享”。
- en: From the image above, you can see that Splat2 and Sizzle are exactly the same,
    so we can remove Sizzle from consideration. If you [open up a copy of my Godbolt
    session](https://godbolt.org/z/j5GdGah89), you’ll also see that most of the functions
    compile to about the same number of assembly operations. The exceptions are Regular
    — which is much longer — and Splat0 — which includes the early check.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的图像可以看出，Splat2和Sizzle完全相同，因此我们可以将Sizzle从考虑中删除。如果您[打开我的Godbolt会话的副本](https://godbolt.org/z/j5GdGah89)，您还会看到大多数函数编译为大致相同数量的汇编操作。例外是Regular
    ——它更长——和Splat0——它包括早期检查。
- en: 'In the assembly, 512-bit registers start with ZMM. 256-bit registers start
    YMM. 128-bit registers start with XMM. If you want to better understand the generated
    assembly, use AI tools to generate annotations. For example, here I ask [Bing
    Chat](https://www.bing.com/search?q=Bing+AI&showconv=1&FORM=hpcodx) about Splat2:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编中，512位寄存器以ZMM开头。256位寄存器以YMM开头。128位寄存器以XMM开头。如果您想更好地理解生成的汇编，请使用AI工具生成注释。例如，我在这里向[Bing
    Chat](https://www.bing.com/search?q=Bing+AI&showconv=1&FORM=hpcodx)询问关于Splat2的问题：
- en: '![](../Images/813f956f0e22302edb254812fa60f303.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/813f956f0e22302edb254812fa60f303.png)'
- en: Try different compiler settings, including `-C target-feature=+avx2` and then
    leaving `target-feature` completely off.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试不同的编译器设置，包括`-C target-feature=+avx2`，然后完全不使用`target-feature`。
- en: Fewer assembly operations don’t necessarily mean faster speed. Looking at the
    assembly does, however, give us a sanity check that the compiler is at least trying
    to use SIMD operations, inlining const references, etc. Also, as with Splat1 and
    Swizzle, it can sometimes let us know when two candidates are the same.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 较少的汇编操作不一定意味着更快的速度。然而，查看汇编代码确实让我们确认编译器至少尝试使用SIMD操作、内联常量引用等。同样，像Splat1和Swizzle一样，有时它可以让我们知道两个候选项何时相同。
- en: You may need disassembly features beyond what Godbolt offers, for example, the
    ability to work with code the uses external crates. B3NNY recommended the cargo
    tool `[cargo-show-asm](https://github.com/pacak/cargo-show-asm)` to me. I tried
    it and found it reasonably easy to use.
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您可能需要比Godbolt提供的反汇编功能更多的功能，例如处理使用外部包的代码能力。B3NNY推荐给我cargo工具 `[cargo-show-asm](https://github.com/pacak/cargo-show-asm)`。我试过了，发现使用起来相当容易。
- en: The `range-set-blaze` crate must handle integer types beyond `u32`. Moreover,
    we must pick a number of LANES, but we have no reason to think that 16 LANES is
    always best. To address these needs, in the next rule we’ll generalize the code.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`range-set-blaze`包必须处理超出`u32`的整数类型。此外，我们必须选择一定数量的LANES，但我们没有理由认为16 LANES总是最好的。为了满足这些需求，在下一条规则中我们将概括代码。'
- en: 'Rule 6: Generalize to all types and LANES with in-lined generics, (and when
    that doesn’t work) macros, and (when that doesn’t work) traits.'
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 6：广义应用于所有类型和LANES，包括内联泛型（in-lined generics），（当它不起作用时）宏（macros），以及（当它不起作用时）特性（traits）。
- en: Let’s first generalize Splat1 with generics.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先用泛型概括Splat1。
- en: '[PRE19]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: First, note the `#[inline]` attribute. It’s important for efficiency and we’ll
    use it on pretty much every one of these small functions.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 首先注意`#[inline]`属性。对效率很重要，我们将几乎在所有这些小函数上使用它。
- en: The function defined above, `is_consecutive_splat1_gen`, looks great except
    that it needs a second input, called `comparison_value`, that we have yet to define.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 上面定义的函数`is_consecutive_splat1_gen`看起来很棒，除了它需要第二个输入，称为`comparison_value`，我们尚未定义。
- en: If you don’t need a generic const `comparison_value`, I envy you. You can skip
    to the next rule if you like. Likewise, if you are reading this in the future
    and creating a generic const `comparison_value` is as effortless as having your
    personal robot do your household chores, then I doubly envy you.
  id: totrans-199
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您不需要通用常量`comparison_value`，我羡慕您。如果您愿意，您可以跳过下一条规则。同样地，如果您正在未来阅读此内容，并且创建通用常量`comparison_value`就像您个人机器人做家务一样轻松，那我就双倍羡慕您。
- en: 'We can try to create a `comparison_value_splat_gen` that is generic and const.
    Sadly, neither `From<usize>` nor alterative `T::One` are const, so this doesn’t
    work:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试创建一个`comparison_value_splat_gen`，它是通用的和const的。不幸的是，`From<usize>`和替代的`T::One`都不是const，所以这个方法行不通：
- en: '[PRE20]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Macros are the last refuge of scoundrels.** So, let’s use macros:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**宏是无赖的最后避难所**。因此，让我们使用宏：'
- en: '[PRE21]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This lets us run on any particular element type and all number of LANES ([Rust
    Playground](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2021&gist=f5a6fbac31d64f3ae79440d5613e44ec)):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够在任何特定元素类型和所有LANES上运行（[Rust Playground](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2021&gist=f5a6fbac31d64f3ae79440d5613e44ec)）：
- en: '[PRE22]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Sadly, this still isn’t enough for `range-set-blaze`. It needs to run on *all*
    element types (not just one) and (ideally) all LANES (not just one).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，对于`range-set-blaze`来说还不够。它需要在*所有*元素类型（而不仅仅是一种）和（理想情况下）所有LANES（而不仅仅是一个LANE）上运行。
- en: 'Happily, there’s a workaround, that again depends on macros. It also exploits
    the fact that we only need to support a finite list of types, namely: `i8`, `i16`,
    `i32`, `i64`, `isize`, `u8`, `u16`, `u32`, `u64`, and `usize`. If you need to
    also (or instead) support `f32` and `f64`, that’s fine.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个解决方法，再次依赖于宏。它还利用了我们只需要支持有限类型列表的事实，即：`i8`、`i16`、`i32`、`i64`、`isize`、`u8`、`u16`、`u32`、`u64`和`usize`。如果您需要同时（或者替代地）支持`f32`和`f64`，那也没问题。
- en: If, on the other hand, you need to support `i128` and `u128`, you may be out
    of luck. The `core::simd` module doesn’t support them. We’ll see in Rule 8 how
    `range-set-blaze` gets around that at a performance cost.
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一方面，如果您需要支持`i128`和`u128`，那可能就没有办法了。`core::simd`模块不支持它们。在第8条规则中，我们将看到`range-set-blaze`如何通过牺牲性能来解决这个问题。
- en: The workaround defines a new trait, here called `IsConsecutive`. We then use
    a macro (that calls a macro, that calls a macro) to implement the trait on the
    10 types of interest.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方法定义了一个新的trait，这里称为`IsConsecutive`。然后，我们使用一个宏（调用一个宏，再调用一个宏）来在这10种感兴趣的类型上实现这个trait。
- en: '[PRE23]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can now call fully generic code (Rust Playground):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以调用完全通用的代码（Rust Playground）：
- en: '[PRE24]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: With this technique, we can create multiple candidate algorithms that are fully
    generic over type and LANES. Next, it is time to benchmark and see which algorithms
    are fastest.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术，我们可以创建多个完全通用于类型和LANES的候选算法。接下来，是时候进行基准测试，看看哪些算法最快。
- en: Those are the first six rules for adding SIMD code to Rust. In [Part 2](/nine-rules-for-simd-acceleration-of-your-rust-code-part-2-6a104b3be6f3),
    we look at rules 7 to 9\. These rules will cover how to pick an algorithm and
    set LANES. Also, how to integrate SIMD operations into your existing code and
    (importantly) how to make it optional. Part 2 concludes with a discussion of when/if
    you should use SIMD and ideas for improving Rust’s SIMD experience. I hope to
    see you [there](/nine-rules-for-simd-acceleration-of-your-rust-code-part-2-6a104b3be6f3).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是向Rust添加SIMD代码的前六条规则。在[第2部分](/nine-rules-for-simd-acceleration-of-your-rust-code-part-2-6a104b3be6f3)中，我们将看到第7到第9条规则。这些规则将涵盖如何选择算法和设置LANES，以及如何将SIMD操作集成到现有代码中（重要的是），如何使其可选。第2部分结束时将讨论何时/如果应该使用SIMD以及改进Rust的SIMD体验的想法。我希望能在[那里](/nine-rules-for-simd-acceleration-of-your-rust-code-part-2-6a104b3be6f3)见到你。
- en: '*Please* [*follow Carl on Medium*](https://medium.com/@carlmkadie)*. I write
    on scientific programming in Rust and Python, machine learning, and statistics.
    I tend to write about one article per month.*'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*请* [*关注Carl在Medium上的文章*](https://medium.com/@carlmkadie)*。我写关于Rust和Python中的科学编程，机器学习和统计学的文章。我倾向于每个月写一篇文章。*'
