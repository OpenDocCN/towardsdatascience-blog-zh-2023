- en: Removing Clouds from Landsat Satellite Images with Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用Python去除Landsat卫星图像中的云层
- en: 原文：[https://towardsdatascience.com/removing-clouds-from-landsat-satellite-images-with-python-246e73494bc](https://towardsdatascience.com/removing-clouds-from-landsat-satellite-images-with-python-246e73494bc)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/removing-clouds-from-landsat-satellite-images-with-python-246e73494bc](https://towardsdatascience.com/removing-clouds-from-landsat-satellite-images-with-python-246e73494bc)
- en: Calculating cloud cover in your area of interest, removing clouds and inpainting
    them using another satellite image
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算你感兴趣区域的云量，去除云层并使用另一张卫星图像修补它们
- en: '[](https://conorosullyds.medium.com/?source=post_page-----246e73494bc--------------------------------)[![Conor
    O''Sullivan](../Images/2dc50a24edb12e843651d01ed48a3c3f.png)](https://conorosullyds.medium.com/?source=post_page-----246e73494bc--------------------------------)[](https://towardsdatascience.com/?source=post_page-----246e73494bc--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----246e73494bc--------------------------------)
    [Conor O''Sullivan](https://conorosullyds.medium.com/?source=post_page-----246e73494bc--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://conorosullyds.medium.com/?source=post_page-----246e73494bc--------------------------------)[![Conor
    O''Sullivan](../Images/2dc50a24edb12e843651d01ed48a3c3f.png)](https://conorosullyds.medium.com/?source=post_page-----246e73494bc--------------------------------)[](https://towardsdatascience.com/?source=post_page-----246e73494bc--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----246e73494bc--------------------------------)
    [Conor O''Sullivan](https://conorosullyds.medium.com/?source=post_page-----246e73494bc--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----246e73494bc--------------------------------)
    ·14 min read·May 29, 2023
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·发布于[Towards Data Science](https://towardsdatascience.com/?source=post_page-----246e73494bc--------------------------------)
    ·14分钟阅读·2023年5月29日
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/139abceec02d150bde92512b5d84aa21.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/139abceec02d150bde92512b5d84aa21.png)'
- en: '(source: author)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: （来源：作者）
- en: Our technology has progressed to conquer the vastness of space. We’ve launched
    satellites, armed with state-of-the-art sensors, to monitor our changing planets.
    Yet, one adversary has humbled these advanced systems — clouds.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的技术已经发展到征服浩瀚的太空。我们已经发射了配备最先进传感器的卫星，用于监测我们变化的星球。然而，一个对手却让这些先进系统感到困扰——云层。
- en: 'Whether you want to compare the value of spectral indices or train machine
    learning models on satellite images, clouds are a problem. So, we’ll explore how
    to use a cloud mask to:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是想比较光谱指数的值还是在卫星图像上训练机器学习模型，云层都是一个问题。因此，我们将探索如何使用云掩膜来：
- en: Calculate the **percentage of cloud cover** in your area of interest
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算你感兴趣区域的**云量百分比**
- en: '**Remove** clouds from the image'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从图像中去除**云层'
- en: '**Inpaint** cloud pixels using an image taken on a different day'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用另一张日期不同的图像修补**云像素'
- en: 'When it comes to the actual mask we’ll explore two options:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 关于实际的掩膜，我们将探索两个选项：
- en: The one provided in the **Landsat QA file** (QA_PIXEL.tif)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**Landsat QA文件**（QA_PIXEL.tif）中提供的方法
- en: An alternative **machine learning approach**
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种替代的**机器学习方法**
- en: We’ll explain the Python code used to do this and you can find the full project
    on [GitHub](https://github.com/conorosully/medium-articles/blob/master/src/remote%20sensing/landsat_clouds.ipynb).
    Let's clear those skies!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将解释用于完成此任务的Python代码，你可以在[GitHub](https://github.com/conorosully/medium-articles/blob/master/src/remote%20sensing/landsat_clouds.ipynb)上找到完整的项目。让我们清除这些天空吧！
- en: Downloading a satellite image
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载卫星图像
- en: 'The methods we discuss will work with any raster data. In this article, we
    will specifically be working with Landsat satellite imagery. You can download
    a Landsat scene using the [EarthExplorer](https://earthexplorer.usgs.gov/) portal.
    Alternatively, if you want to use Python, the article below takes you through
    the process:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的方法适用于任何栅格数据。在这篇文章中，我们将专门处理Landsat卫星图像。你可以使用[EarthExplorer](https://earthexplorer.usgs.gov/)门户下载Landsat场景。或者，如果你想使用Python，下面的文章将带你完成这一过程：
- en: '[](/downloading-landsat-satellite-images-with-python-a2d2b5183fb7?source=post_page-----246e73494bc--------------------------------)
    [## Downloading Landsat Satellite Images with Python'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[](/downloading-landsat-satellite-images-with-python-a2d2b5183fb7?source=post_page-----246e73494bc--------------------------------)
    [## 使用Python下载Landsat卫星图像'
- en: Streamline Landsat scene downloads with the landsatxplore Python package
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用landsatxplore Python包简化Landsat场景下载
- en: towardsdatascience.com](/downloading-landsat-satellite-images-with-python-a2d2b5183fb7?source=post_page-----246e73494bc--------------------------------)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: towardsdatascience.com](/downloading-landsat-satellite-images-with-python-a2d2b5183fb7?source=post_page-----246e73494bc--------------------------------)
- en: In the end, you should have a folder like **Figure 1**. These are all the files
    available for a [Landsat level 2 science product](https://www.usgs.gov/landsat-missions/landsat-collection-2-level-2-science-products).
    We’ll be working with the highlighted files. These are the 3 visible light bands
    and the QA_PIXEL file.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你应该会有一个像**图 1**一样的文件夹。这些都是[ Landsat 2 级科学产品](https://www.usgs.gov/landsat-missions/landsat-collection-2-level-2-science-products)中可用的文件。我们将处理高亮显示的文件。这些是
    3 个可见光波段和 QA_PIXEL 文件。
- en: '![](../Images/b845ab3da664b3198809738ea990de2d.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b845ab3da664b3198809738ea990de2d.png)'
- en: 'Figure 1: Landsat level-2 science product files (source: author)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1：Landsat 二级科学产品文件（来源：作者）
- en: This particular scene was taken above Cape Town, South Africa. To see this we
    visualise the visible light bands using the **get_RGB** function. This takes the
    file name/ ID as a parameter. It will then load the bands (lines 7–9), stack them
    (line 12), [scale them](https://www.usgs.gov/faqs/how-do-i-use-scale-factor-landsat-level-2-science-products)
    (line 13) and [clip them](/visualising-the-rgb-channels-of-satellite-images-with-python-6d541af1f98d)
    (line 16).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定场景拍摄于南非开普敦上空。为了查看这一点，我们使用**get_RGB**函数可视化可见光波段。这个函数以文件名/ID 作为参数。然后它会加载波段（第
    7–9 行），将它们堆叠（第 12 行），[缩放](https://www.usgs.gov/faqs/how-do-i-use-scale-factor-landsat-level-2-science-products)（第
    13 行）和[剪裁](/visualising-the-rgb-channels-of-satellite-images-with-python-6d541af1f98d)（第
    16 行）。
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We use this function to get an RGB visualisation for the scene we downloaded
    in **Figure 1** (lines 3–4). You can see the resulting image in **Figure 2**.
    Notice all the clouds! Let’s see if we can deal with them using the Landsat cloud
    mask.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个功能来获取**图 1**（第 3–4 行）中下载场景的 RGB 可视化。你可以在**图 2**中看到结果图像。注意所有的云！让我们看看能否利用
    Landsat 云掩膜来处理这些云。
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![](../Images/89908ec1b1269cf93dc7accc1c6ca975.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/89908ec1b1269cf93dc7accc1c6ca975.png)'
- en: 'Figure 2: RGB visualisation of Landsat scene (source: author)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2：Landsat 场景的 RGB 可视化（来源：作者）
- en: Landsat cloud masks
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Landsat 云掩膜
- en: What is a cloud mask?
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是云掩膜？
- en: A cloud mask is a segmentation map that separates clouds from other features
    on the earth’s surface. The map classifies each pixel in an image as either cloud
    or non-cloud. It can also include other similar features like cloud shadows. They
    are important in remote sensing as isolating cloud pixels leads to more accurate
    measurements and interpretations of land cover analysis.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 云掩膜是一种分割图，将云与地球表面的其他特征分开。该图将图像中的每个像素分类为云或非云。它还可以包括其他类似的特征，如云影。它们在遥感中很重要，因为隔离云像素能更准确地测量和解释土地覆盖分析。
- en: There are various methods used to classify cloud pixels. Landsat uses an algorithm
    called [CFMask](https://www.usgs.gov/landsat-missions/cfmask-algorithm). This
    uses a combination of various statistics based on spectral indices. It has a classification
    accuracy of 89% for cloud pixels and 96% for cloud shadows [1]. Later, we will
    discuss an alternative machine-learning approach to creating cloud masks.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 用于分类云像素的方法有很多种。Landsat 使用一种叫做[CFMask](https://www.usgs.gov/landsat-missions/cfmask-algorithm)的算法。该算法使用基于光谱指数的各种统计数据的组合。它在云像素的分类准确率为
    89%，在云影的分类准确率为 96% [1]。稍后，我们将讨论一种替代的机器学习方法来创建云掩膜。
- en: Understanding the quality assurance (QA) band
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解质量保证（QA）波段
- en: The CFMask algorithm is run for every Landsat scene and the results can be found
    in the QA band. This file is an array with the same height and width as the solar
    reflection bands (e.g. visible light bands). Every pixel in the band is a 16-bit
    integer that contains the classification for that pixel. You can find more information
    on this encoding in the [Data Format Control Book](https://www.usgs.gov/media/files/landsat-8-9-olitirs-collection-2-level-2-data-format-control-book).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: CFMask 算法在每个 Landsat 场景上运行，结果可以在 QA 波段中找到。该文件是一个与太阳反射波段（例如可见光波段）具有相同高度和宽度的数组。波段中的每个像素都是一个
    16 位整数，包含该像素的分类。你可以在[数据格式控制手册](https://www.usgs.gov/media/files/landsat-8-9-olitirs-collection-2-level-2-data-format-control-book)中找到有关这种编码的更多信息。
- en: For example, suppose one of the pixels in the QA file has the value **22280**.
    To understand what this integer means we first convert it to a 16-bit binary number
    — **0101011100001000**. Every bit in this number then maps to a flag seen in **Figure
    3**. Bit 3 has a value of 1 indicating that this pixel is classified as cloud.
    Going forward, we will consider cover types for bits 1 to 4 for our cloud mask.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设 QA 文件中的一个像素值为**22280**。为了理解这个整数的含义，我们首先将其转换为 16 位二进制数——**0101011100001000**。这个数字中的每一位映射到**图
    3**中看到的标志。第 3 位的值为 1，表示该像素被分类为云。接下来，我们将考虑云掩码中位 1 到 4 的覆盖类型。
- en: '![](../Images/bc422ce67a78418a67fa3204c49036b9.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/bc422ce67a78418a67fa3204c49036b9.png)'
- en: 'Figure 3: Landsat QA band bit description and example (source: author)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3：Landsat QA 波段位描述和示例（来源：作者）
- en: We use this information to create the **get_mask** function. It will return
    the classification of an individual pixel for the 4 cover types — cloud, shadow,
    dilated cloud and cirrus. A pixel will have a value of 0 if it is classified as
    the given cover type and 1 otherwise. Later, we will see that this allows us to
    remove unwanted pixels by multiplying the satellite image by the mask.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这些信息来创建**get_mask**函数。它将返回 4 种覆盖类型中每个像素的分类——云、阴影、扩张云和卷云。如果一个像素被分类为给定的覆盖类型，它的值将为
    0，否则为 1。稍后，我们将看到这使我们能够通过将卫星图像与掩码相乘来去除不需要的像素。
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To apply this function, we start by loading our QA band (line 2). We apply **get_mask**
    to every pixel in the band for each of the 4 cover types (lines 6–9). Instead
    of looping over every pixel, we speed things up using **np.vectorize()**. Each
    mask will be an array with the same dimensions as the scene where every element
    has a value of 0 or 1.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应用此功能，我们首先加载 QA 波段（第 2 行）。我们对波段中的每个像素应用**get_mask**，以获得 4 种覆盖类型中的每一种（第 6–9
    行）。我们使用**np.vectorize()**来加速，而不是对每个像素进行循环处理。每个掩码将是一个与场景具有相同维度的数组，每个元素的值为 0 或 1。
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can see these masks in action in **Figure 4**. Here we have overlayed the
    image we saw **Figure 2** with different colours depending on the classifications
    in the 4 masks. Zooming in on one area, we can get a better understanding of each
    cover type:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在**图 4**中看到这些掩码的实际效果。这里我们将看到**图 2**中看到的图像与 4 种掩码的分类结果以不同颜色叠加。放大一个区域，我们可以更好地理解每种覆盖类型：
- en: '**Shadows** are the darker areas below clouds'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阴影**是云下的较暗区域'
- en: '**Dilated clouds** are the edges around pixels classified as clouds'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩张云**是被分类为云的像素周围的边缘'
- en: '**Cirrus** are “wispy” clouds'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卷云**是“细丝状”的云'
- en: If a pixel is classified as cirrus it will also be classified as cloud.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个像素被分类为卷云，它也会被分类为云。
- en: '![](../Images/339af0757a3c4b210063d4c002ba2122.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/339af0757a3c4b210063d4c002ba2122.png)'
- en: 'Figure 4: Landsat segmentation mask with 4 cover types — cloud, shadow, dilated
    cloud and cirrus (source: author)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4：Landsat 分割掩码包含 4 种覆盖类型——云、阴影、扩张云和卷云（来源：作者）
- en: The code below is used to create **Figure 4**. We add a layer for each of the
    masks to the original RGB image (lines 15–22). This is done using the **cv2.addWeighted()**
    function (line 22). Every mask layer is given a different color (lines 8–11) with
    50% transparency. The area of interest (AOI) is cropped by taking pixels within
    a given range (line 43). Next, we will take a closer look at this area.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用于创建**图 4**。我们将每个掩码的图层添加到原始 RGB 图像中（第 15–22 行）。这通过使用**cv2.addWeighted()**函数（第
    22 行）来完成。每个掩码图层都有不同的颜色（第 8–11 行），透明度为 50%。通过提取像素范围来裁剪感兴趣区域（AOI）（第 43 行）。接下来，我们将对该区域进行更详细的查看。
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Assessing area of interest
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估感兴趣区域
- en: The percentage cloud cover of the entire scene is given as part of the scene’s
    metadata. In our case, we have a value of **59%**. With the cloud mask, we can
    calculate this figure for a particular AOI. This is useful as it allows us to
    programmatically search for scenes where our AOI is cloud-free. That is even if
    the rest of the scene is cloudy.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 整个场景的云覆盖百分比作为场景的元数据的一部分提供。在我们的案例中，这个值是**59%**。通过云掩码，我们可以计算特定 AOI 的这一数据。这很有用，因为它允许我们以编程方式搜索那些
    AOI 无云的场景。即使场景的其他部分有云也无妨。
- en: To see this, we select the same area of interest as **Figure 4** (line 2). Keep
    in mind, the cloud mask has a value of 0 for no clouds and 1 otherwise. We invert
    this and take the average (line 5). This gives us a value of **69%**. Unfortunately,
    our AOI is more cloudy than the scene in general!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看这一点，我们选择与**图 4**（第 2 行）相同的感兴趣区域。请记住，云掩码的值为 0 表示没有云，否则为 1。我们将其取反并计算平均值（第
    5 行）。这给我们一个**69%**的值。不幸的是，我们的 AOI 比场景总体更有云！
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Removing clouds
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 去除云层
- en: Once we have a mask, removing unwanted pixels is straightforward. We simply
    have to multiply the RGB image by the mask. The code below will remove pixels
    classified as cloud (line 2). Keep in mind that the RGB image is a 3D array. In
    comparison, the **cloud_mask** is a 2D array. This is why we use **np.newaxis**
    to add an additional dimension.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了掩膜，去除不需要的像素就很简单。我们只需将RGB图像与掩膜相乘。下面的代码将去除被标记为云层的像素（第2行）。请记住，RGB图像是一个3D数组。相比之下，**cloud_mask**是一个2D数组。这就是为什么我们使用**np.newaxis**来添加额外的维度。
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can see the result in **Figure 5**. Cloud pixels are now all replaced with
    values of [0,0,0]. This is the same value used for the bounding box. This means
    the pixels have “no data” and can be ignored in further analysis. Ultimately,
    the results of this analysis rely on the accuracy of the cloud mask. This is why
    researchers continuously seek to improve these masks.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在**图5**中看到结果。云层像素现在全部被值[0,0,0]替代。这与用于边界框的值相同。这意味着这些像素“没有数据”，可以在进一步分析中忽略。最终，这些分析的结果依赖于云掩膜的准确性。这就是为什么研究人员不断寻求改进这些掩膜。
- en: '![](../Images/9173baae6d2167f736c2041563575f9b.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9173baae6d2167f736c2041563575f9b.png)'
- en: 'Figure 5: clouds removed from satellite image using Landsat cloud mask (source:
    author)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：使用Landsat云掩膜从卫星图像中去除云层（来源：作者）
- en: Machine learning approach to cloud masks
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云掩膜的机器学习方法
- en: We mentioned that Landsat uses an algorithm called [CFMask](https://www.usgs.gov/landsat-missions/cfmask-algorithm).
    It is based on remote sensing and meteorological knowledge of how cloud pixels
    are represented in satellite images. Alternatively, we can use machine learning.
    This requires training images where all cloud pixels have been manually labelled.
    An ML algorithm then learns the relationship between spectral bands and the labels.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到Landsat使用一种称为[CFMask](https://www.usgs.gov/landsat-missions/cfmask-algorithm)的算法。该算法基于遥感和气象知识，了解云层像素在卫星图像中的表现。另一种方法是使用机器学习。这需要训练图像，其中所有云层像素都被手动标记。然后，机器学习算法学习光谱波段和标签之间的关系。
- en: '[One approach](https://medium.com/sentinel-hub/clouds-segmentation-in-landsat-8-images-da370815235)
    uses a genetic algorithm trained on the Coastal Aerosol (B1), Red (B4) and Shortwave
    Infrared 2 (B7) bands. The resulting algorithm is given in **cloud_pred** function.
    The **pred** formula (lines 4-10) gives a weighting of the 3 bands. If the weighted
    value is greater than the B7 band the pixel is labelled as cloud (line 12).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[一种方法](https://medium.com/sentinel-hub/clouds-segmentation-in-landsat-8-images-da370815235)使用在海岸气溶胶（B1）、红色（B4）和短波红外2（B7）波段上训练的遗传算法。得到的算法在**cloud_pred**函数中给出。**pred**公式（第4-10行）给出了三个波段的加权。如果加权值大于B7波段，则像素被标记为云层（第12行）。'
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To use this function, we start by loading the 3 necessary bands (lines 4–6).
    We get the cloud mask by passing these bands into the **cloud_pred** function
    (line 9). We can then use this mask to remove clouds in the same way as before
    (line 12). You can see the resulting image in **Figure 6**.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此功能，我们首先加载三个必要的波段（第4-6行）。通过将这些波段传递给**cloud_pred**函数（第9行），我们获得云掩膜。然后，我们可以像以前一样使用这个掩膜去除云层（第12行）。你可以在**图6**中看到结果图像。
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![](../Images/6d63b900d94333d487b6dbdf8a96167e.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6d63b900d94333d487b6dbdf8a96167e.png)'
- en: 'Figure 6: clouds removed from satellite image using a machine learning approach
    (source: author)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图6：使用机器学习方法从卫星图像中去除云层（来源：作者）
- en: The researchers state the accuracy of the above approach was **89%** — similar
    to CFMask. As mentioned, improving the accuracy of algorithms is an active area
    of research. State-of-the-art approaches use deep learning algorithms for image
    segmentation such as [U-Net](/u-net-explained-understanding-its-image-segmentation-architecture-56e4842e313a).
    The downside to these approaches, over CFMask, is the need for accurately labelled
    training data.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 研究人员表示上述方法的准确度为**89%**——与CFMask相似。如前所述，提升算法的准确度是一个活跃的研究领域。最先进的方法使用深度学习算法进行图像分割，如[U-Net](/u-net-explained-understanding-its-image-segmentation-architecture-56e4842e313a)。这些方法的缺点是需要准确标记的训练数据。
- en: Inpainting clouds
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云层修复
- en: For some applications, it may be enough to simply remove clouds from your image.
    For others, we want to replace or “inpaint” the clouds. For example, to create
    a visualisation of a landscape without clouds.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些应用，仅仅从图像中去除云层可能就足够了。对于其他应用，我们希望替换或“修复”云层。例如，为了创建没有云层的景观可视化。
- en: In **Figure 7**, we can see the same cloudy image that we’ve been working with.
    This was taken on 10/04/2023\. Thankfully, 8 days later a clear image was taken
    over the same area. We’ll explore how to replace the pixels in the cloudy image
    (line 6) with the ones in the clear image (line 7).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在**图7**中，我们可以看到我们一直在处理的有云图像。这张图像拍摄于2023年10月4日。幸运的是，8天后在同一区域拍摄了一张清晰图像。我们将探讨如何用清晰图像中的像素（第7行）替换有云图像中的像素（第6行）。
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![](../Images/ab15da8c8131f201d2cd2ecbbed7d753.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ab15da8c8131f201d2cd2ecbbed7d753.png)'
- en: 'Figure 7: a cloudy and clear image taken 8 days apart (source: author).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图7：拍摄于8天前的有云图像和清晰图像（来源：作者）。
- en: 'We will do this for both the **AOI** and the **entire scene**. In both cases,
    it is important to consider the *geolocations* of the pixels. Even though the
    cloudy and clear images are taken above the same area, the pixels will not align
    perfectly. In other words, the UTM coordinates of the pixel in array position
    [x,y] will be different in each image. Hence, if we relied on array positions
    alone we would end up replacing pixels with the wrong area of land. To deal with
    this, we build on methods used in this article:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对**关注区域**和**整个场景**执行此操作。在这两种情况下，考虑像素的*地理位置*非常重要。即使有云和清晰图像拍摄于相同区域，像素也不会完全对齐。换句话说，数组位置
    [x,y] 的像素的UTM坐标在每个图像中都会有所不同。因此，如果仅依赖数组位置，我们将替换错误区域的像素。为了解决这个问题，我们基于本文中使用的方法：
- en: '[](/how-to-plot-coordinates-on-landsat-satellite-images-with-python-5671613887aa?source=post_page-----246e73494bc--------------------------------)
    [## How to Plot Coordinates on Landsat Satellite Images with Python'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[如何在Landsat卫星图像上用Python绘制坐标](/how-to-plot-coordinates-on-landsat-satellite-images-with-python-5671613887aa?source=post_page-----246e73494bc--------------------------------)'
- en: Mapping pixel positions to geographic coordinates using Landsat metadata and
    Rasterio
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Landsat元数据和Rasterio将像素位置映射到地理坐标
- en: towardsdatascience.com](/how-to-plot-coordinates-on-landsat-satellite-images-with-python-5671613887aa?source=post_page-----246e73494bc--------------------------------)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[towardsdatascience.com](/how-to-plot-coordinates-on-landsat-satellite-images-with-python-5671613887aa?source=post_page-----246e73494bc--------------------------------)'
- en: Area of interest
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关注区域
- en: First, we will see how to inpaint an AOI. We start by creating a mask using
    all 4 cover types (line 2) and remove the unwanted pixels from the cloudy image
    (line 5). We then crop the resulting image around our AOI (lines 8–9). We take
    (x,y) as the centre of the AOI in the cloudy image.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将学习如何修复一个**关注区域**（AOI）。我们从创建一个包含所有4种覆盖类型的掩码开始（第2行），并从有云图像中移除不需要的像素（第5行）。然后，我们围绕我们的**关注区域**裁剪得到的图像（第8-9行）。我们将
    (x,y) 视为有云图像中**关注区域**的中心。
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As mentioned, we need to consider the geolocations of the pixels. We use the
    rasterio package to help with this. We load the red band for both the cloudy (line
    4) and clear (line 5) images.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们需要考虑像素的地理位置。我们使用rasterio包来帮助实现这一点。我们加载有云图像（第4行）和清晰图像（第5行）的红色波段。
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We find the UTM coordinates, in the **cloudy image**, of the centre of our AOI
    (line 2). We then find the array positions for these UTM coordinates in the **clear
    image** (line 5). Printing these gives a value of **(4430, 4510)**. You can see
    how this is different to the original centre of **(4500,4500).**
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在**有云图像**中找到**关注区域**中心的UTM坐标（第2行）。然后，我们在**清晰图像**中找到这些UTM坐标的数组位置（第5行）。打印这些坐标得到**(4430,
    4510)**。你可以看到这与原始中心**(4500,4500)**不同。
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We crop the AOI from the **clear image** (line 2) using the new centre. We then
    crop the cloud mask (from the cloudy image) using the original centre (line 5).
    The UTM coordinates of **crop_clear** and **crop_mask** will align perfectly.
    So, we create our **fill** by multiplying the clear image by the inverse of the
    mask (line 6). The final step is to add the **fill** to the cloudy image with
    no clouds (line 9).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用新中心从**清晰图像**（第2行）裁剪**关注区域**。然后，我们使用原始中心（第5行）裁剪有云图像的云掩码。**crop_clear**和**crop_mask**的UTM坐标将完美对齐。因此，我们通过将清晰图像与掩码的反向相乘（第6行）来创建**填充**。最后一步是将**填充**添加到无云的有云图像中（第9行）。
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can see the result in **Figure 8**. It looks good! For the most part, the
    landscape looks continuous. Although, there are a few issues which we discuss
    at the end.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在**图8**中看到结果。效果不错！大部分景观看起来是连贯的。不过，也有一些问题，我们将在最后讨论。
- en: '![](../Images/53f10e3ef571aedc757d7e62ab9a29e6.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/53f10e3ef571aedc757d7e62ab9a29e6.png)'
- en: 'Figure 8: area of interest inpainted using clear image (source: author)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图8：使用清晰图像修复的关注区域（来源：作者）
- en: The entire image
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整个图像
- en: Inpainting the entire scene is more complicated. To do this we need to align
    the bounding box of the cloudy and clear scenes. The bound box is the outer black
    border of the scene. We align the UTM coordinates of the boxes by adding and removing
    some pixels from the clear image.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对整个场景进行修复更加复杂。为此，我们需要对齐多云和晴朗场景的边界框。边界框是场景的外部黑色边框。我们通过从晴朗图像中添加和移除一些像素来对齐这些框的UTM坐标。
- en: '![](../Images/efe597bd3cedb66ab980f4d360a7f699.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/efe597bd3cedb66ab980f4d360a7f699.png)'
- en: 'Figure 9: adding and removing pixels to align the bounding boxes'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9：添加和移除像素以对齐边界框
- en: We start by calculating the number of pixels to add/remove from the top, bottom,
    left and right of the clear image. We get array positions for the upper left (UL)
    (line 3) and lower right (LR) corners (line 4) of the **clear image**. These are
    based on the dimensions of the clear image (line 2).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先计算从晴朗图像的顶部、底部、左侧和右侧添加/移除的像素数量。我们获取**晴朗图像**的左上角（UL）（第3行）和右下角（LR）（第4行）的位置。这些位置基于晴朗图像的尺寸（第2行）。
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Next, we get the bounds from the **cloudy image** (line 2). These give the UTM
    coordinates of the cloudy image’s bounding box. We then get array positions for
    these coordinates from the **clear image** (lines 3–4). Note these positions can
    fall outside the dimensions of the clear image.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从**多云图像**中获取边界（第2行）。这些边界提供了多云图像边界框的UTM坐标。然后，我们从**晴朗图像**中获取这些坐标的数组位置（第3–4行）。请注意，这些位置可能会超出晴朗图像的尺寸。
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The difference between the original and new corner positions will tell us how
    we need to adjust the clear image to align the UTM coordinates. Printing the adjustments
    (line 8) gives us -10 0 70 -70\. This means we have to adjust the clear image
    by:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 原始和新角落位置之间的差异将告诉我们如何调整晴朗图像以对齐UTM坐标。打印调整量（第8行）给出 -10 0 70 -70。这意味着我们必须将晴朗图像调整为：
- en: Removing 10 pixels from the top
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从顶部移除 10 像素
- en: No adjustment to the bottom
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 底部无调整
- en: Adding 70 pixels to the left
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向左添加 70 像素
- en: Removing 70 pixels from the right
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从右侧移除 70 像素
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: After calculating the adjustments, we can use the **adjust_rgb** function. This
    will add black pixels in the case of positive adjustments (lines 6–17). It will
    then crop pixels for negative adjustments (lines 20–27).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算调整量后，我们可以使用**adjust_rgb**函数。这会在正调整情况下添加黑色像素（第6–17行）。然后，它会在负调整情况下裁剪像素（第20–27行）。
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We use this function to adjust our clear image (line 6). We remove the unwanted
    pixels from the cloudy image (line 12) and then get the replacement pixels from
    the adjusted clear image (line 13). As they have been aligned, we add can simply
    add them together (line 14).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用此函数来调整我们的晴朗图像（第6行）。我们从多云图像中移除不需要的像素（第12行），然后从调整后的晴朗图像中获取替换像素（第13行）。由于它们已经对齐，我们可以简单地将它们叠加在一起（第14行）。
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can see the results in **Figure 10**. Overall the landscape looks good.
    If we zoom in our area of interest you can see that it is exactly the same as
    in **Figure 8**. However, as mentioned, there are some issues.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在**图 10**中查看结果。总体来看，景观效果不错。如果我们放大关注区域，你会发现它与**图 8**完全相同。然而，如前所述，还是存在一些问题。
- en: '![](../Images/ae783822cc05e00bd08c1cd1b6d35dbc.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ae783822cc05e00bd08c1cd1b6d35dbc.png)'
- en: 'Figure 10: entire scene inpainted using clear image (source: author)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10：使用晴朗图像修复的整个场景（来源：作者）
- en: We can see this if we zoom in on another AOI. The transparent white pixels are
    those that were replaced by pixels in the clear image. Notice that some of the
    shadow pixels have not been replaced. This may cause discontinuities in the landscape
    where the brightness changes drastically.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在另一个兴趣区域放大，我们可以看到这一点。透明的白色像素是被晴朗图像中的像素替换的。注意，一些阴影像素尚未被替换。这可能会导致景观中亮度变化剧烈的地方出现不连续性。
- en: '![](../Images/27bcbd3ed109499fbdb85ac11834e684.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/27bcbd3ed109499fbdb85ac11834e684.png)'
- en: 'Figure 11: cloud shadows that have not been successfully inpainted (source:
    author)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11：未成功修复的云影（来源：作者）
- en: The problem is that cloud masks are not perfect. We cannot completely replace
    all clouds if we cannot identify them with 100% accuracy. Discontinuities can
    also be caused by changes in the landscape over time. Rivers move and tides will
    rise. To create the best possible visualisations, select replacement images that
    were taken close to the time of your cloudy image.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于云掩模并不完美。如果我们无法以100%的准确度识别所有云层，就无法完全替换所有云层。景观随时间变化也可能导致不连续性。河流会移动，潮汐会上涨。为了创建最佳的可视化效果，选择拍摄时间接近你的多云图像的替换图像。
- en: I hope you enjoyed this article! You can find me on [Mastodon](https://sigmoid.social/@conorosully)
    | [Twitter](https://twitter.com/conorosullyDS) | [YouTube](https://www.youtube.com/channel/UChsoWqJbEjBwrn00Zvghi4w)
    | [Newsletter](https://mailchi.mp/aa82a5ce1dc0/signup) — sign up for FREE access
    to a [Python SHAP course](https://adataodyssey.com/courses/shap-with-python/)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你喜欢这篇文章！你可以在[Mastodon](https://sigmoid.social/@conorosully) | [Twitter](https://twitter.com/conorosullyDS)
    | [YouTube](https://www.youtube.com/channel/UChsoWqJbEjBwrn00Zvghi4w) | [Newsletter](https://mailchi.mp/aa82a5ce1dc0/signup)
    上找到我 — 注册即可免费获取[Python SHAP 课程](https://adataodyssey.com/courses/shap-with-python/)
- en: '[](https://conorosullyds.medium.com/membership?source=post_page-----246e73494bc--------------------------------)
    [## Join Medium with my referral link — Conor O’Sullivan'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://conorosullyds.medium.com/membership?source=post_page-----246e73494bc--------------------------------)
    [## 使用我的推荐链接加入 Medium — Conor O’Sullivan'
- en: As a Medium member, a portion of your membership fee goes to writers you read,
    and you get full access to every story…
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作为 Medium 会员，你的一部分会费将用于支持你阅读的作者，你将能完全访问所有故事……
- en: conorosullyds.medium.com](https://conorosullyds.medium.com/membership?source=post_page-----246e73494bc--------------------------------)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[conorosullyds.medium.com](https://conorosullyds.medium.com/membership?source=post_page-----246e73494bc--------------------------------)'
- en: References
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[1] Steve Foga, et. al., **Cloud detection algorithm comparison and validation
    for operational Landsat data products**, [https://www.sciencedirect.com/science/article/pii/S0034425717301293?via%3Dihub](https://www.sciencedirect.com/science/article/pii/S0034425717301293?via%3Dihub=)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] Steve Foga 等，**云检测算法比较与验证，用于操作 Landsat 数据产品**，[https://www.sciencedirect.com/science/article/pii/S0034425717301293?via%3Dihub](https://www.sciencedirect.com/science/article/pii/S0034425717301293?via%3Dihub=)'
- en: '**Landsat 8–9 OLI/TIRS Collection 2 Level 2 Data Format Control Book** [https://www.usgs.gov/media/files/landsat-8-9-olitirs-collection-2-level-2-data-format-control-book](https://www.usgs.gov/media/files/landsat-8-9-olitirs-collection-2-level-2-data-format-control-book)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**Landsat 8–9 OLI/TIRS 集合 2 级 2 数据格式控制手册** [https://www.usgs.gov/media/files/landsat-8-9-olitirs-collection-2-level-2-data-format-control-book](https://www.usgs.gov/media/files/landsat-8-9-olitirs-collection-2-level-2-data-format-control-book)'
- en: Leah Wasser **Lesson 3\. Clean Remote Sensing Data in Python — Clouds, Shadows
    & Cloud Masks** [https://www.earthdatascience.org/courses/use-data-open-source-python/multispectral-remote-sensing/landsat-in-Python/remove-clouds-from-landsat-data/](https://www.earthdatascience.org/courses/use-data-open-source-python/multispectral-remote-sensing/landsat-in-Python/remove-clouds-from-landsat-data/)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Leah Wasser **第 3 课：在 Python 中清理遥感数据 — 云、阴影与云掩模** [https://www.earthdatascience.org/courses/use-data-open-source-python/multispectral-remote-sensing/landsat-in-Python/remove-clouds-from-landsat-data/](https://www.earthdatascience.org/courses/use-data-open-source-python/multispectral-remote-sensing/landsat-in-Python/remove-clouds-from-landsat-data/)
- en: Leah Wasser **Lesson 4\. How to Replace Raster Cell Values with Values from
    A Different Raster Data Set in Python** [https://www.earthdatascience.org/courses/use-data-open-source-python/multispectral-remote-sensing/landsat-in-Python/replace-raster-cell-values-in-remote-sensing-images-in-python/](https://www.earthdatascience.org/courses/use-data-open-source-python/multispectral-remote-sensing/landsat-in-Python/replace-raster-cell-values-in-remote-sensing-images-in-python/)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Leah Wasser **第 4 课：如何在 Python 中用不同的栅格数据集的值替换栅格单元值** [https://www.earthdatascience.org/courses/use-data-open-source-python/multispectral-remote-sensing/landsat-in-Python/replace-raster-cell-values-in-remote-sensing-images-in-python/](https://www.earthdatascience.org/courses/use-data-open-source-python/multispectral-remote-sensing/landsat-in-Python/replace-raster-cell-values-in-remote-sensing-images-in-python/)
- en: Landsat Missions **CFMask Algorithm** [https://www.usgs.gov/landsat-missions/cfmask-algorithm](https://www.usgs.gov/landsat-missions/cfmask-algorithm)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Landsat 任务 **CFMask 算法** [https://www.usgs.gov/landsat-missions/cfmask-algorithm](https://www.usgs.gov/landsat-missions/cfmask-algorithm)
- en: '[Ing Grenet](https://medium.com/u/1f2c139115b6?source=post_page-----246e73494bc--------------------------------)
    **Cloud Segmentation in Landsat-8 Images** [https://medium.com/sentinel-hub/clouds-segmentation-in-landsat-8-images-da370815235](https://medium.com/sentinel-hub/clouds-segmentation-in-landsat-8-images-da370815235)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[Ing Grenet](https://medium.com/u/1f2c139115b6?source=post_page-----246e73494bc--------------------------------)
    **Landsat-8 图像中的云分割** [https://medium.com/sentinel-hub/clouds-segmentation-in-landsat-8-images-da370815235](https://medium.com/sentinel-hub/clouds-segmentation-in-landsat-8-images-da370815235)'
- en: SentinelHub **Landsat 8 Clouds Segmentation Script** [https://custom-scripts.sentinel-hub.com/custom-scripts/landsat-8/clouds_segmentation/](https://custom-scripts.sentinel-hub.com/custom-scripts/landsat-8/clouds_segmentation/)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: SentinelHub **Landsat 8 云分割脚本** [https://custom-scripts.sentinel-hub.com/custom-scripts/landsat-8/clouds_segmentation/](https://custom-scripts.sentinel-hub.com/custom-scripts/landsat-8/clouds_segmentation/)
