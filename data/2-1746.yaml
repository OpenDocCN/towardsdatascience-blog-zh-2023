- en: Python Type Hinting with Literal
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 类型提示与字面量
- en: 原文：[https://towardsdatascience.com/python-type-hinting-with-literal-03c60ce42750](https://towardsdatascience.com/python-type-hinting-with-literal-03c60ce42750)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/python-type-hinting-with-literal-03c60ce42750](https://towardsdatascience.com/python-type-hinting-with-literal-03c60ce42750)
- en: PYTHON PROGRAMMING
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PYTHON 编程
- en: 'More powerful than it seems: use typing.Literal to create literal types'
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比看起来更强大：使用`typing.Literal`创建字面类型
- en: '[](https://medium.com/@nyggus?source=post_page-----03c60ce42750--------------------------------)[![Marcin
    Kozak](../Images/d7faf62e48ed81dab5d8ad92819fff54.png)](https://medium.com/@nyggus?source=post_page-----03c60ce42750--------------------------------)[](https://towardsdatascience.com/?source=post_page-----03c60ce42750--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----03c60ce42750--------------------------------)
    [Marcin Kozak](https://medium.com/@nyggus?source=post_page-----03c60ce42750--------------------------------)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@nyggus?source=post_page-----03c60ce42750--------------------------------)[![Marcin
    Kozak](../Images/d7faf62e48ed81dab5d8ad92819fff54.png)](https://medium.com/@nyggus?source=post_page-----03c60ce42750--------------------------------)[](https://towardsdatascience.com/?source=post_page-----03c60ce42750--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----03c60ce42750--------------------------------)
    [Marcin Kozak](https://medium.com/@nyggus?source=post_page-----03c60ce42750--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----03c60ce42750--------------------------------)
    ·15 min read·Nov 28, 2023
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: ·发布于 [Towards Data Science](https://towardsdatascience.com/?source=post_page-----03c60ce42750--------------------------------)
    ·15 min read·Nov 28, 2023
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/0bdd431c39d954c0d9226fc02679e589.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0bdd431c39d954c0d9226fc02679e589.png)'
- en: typing.Literal creates a type with selected choices. Photo by [Caleb Jones](https://unsplash.com/@gcalebjones?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`typing.Literal`创建具有选定选项的类型。图片由[Caleb Jones](https://unsplash.com/@gcalebjones?utm_source=medium&utm_medium=referral)提供，来源于[Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)'
- en: 'I’ll admit it: I wasn’t always a fan of `typing.Literal`, a form of creating
    literal types in Python. In fact, I not only undervalued literal types, but I
    completely ignored them, refusing to use them at all. For some reason, which remains
    unclear to me even today, I couldn’t find much practical value in literal types.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我承认：我并不总是喜欢`typing.Literal`，这是在 Python 中创建字面类型的一种形式。实际上，我不仅低估了字面类型，还完全忽视了它们，拒绝使用它们。出于某种原因，即使今天我也不太明白，我找不到字面类型的实际价值。
- en: How wrong I was. I was blind to the power of this simple tool, and my code suffered
    as a result. If you’ve been ignoring literal types like I did, I urge you to read
    this article. I hope to convince you that despite its simplicity, `typing.Literal`
    can be a very useful tool in your Python coding arsenal.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我有多么错误。我没有认识到这个简单工具的强大，我的代码因此受到了影响。如果你像我一样忽略了字面类型，我敦促你阅读这篇文章。我希望说服你，尽管它很简单，`typing.Literal`可以成为你
    Python 编程工具库中的一个非常有用的工具。
- en: Even if you’ve already recognized the value of literal types, don’t stop reading.
    While we won’t delve into all the intricacies of `typing.Literal`, this article
    will provide a more comprehensive introduction than the official Python documentation,
    without getting as bogged down in details as [PEP 586](https://peps.python.org/pep-0586/).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你已经认识到字面类型的价值，也不要停止阅读。虽然我们不会深入探讨`typing.Literal`的所有细节，但这篇文章将提供比官方 Python 文档更全面的介绍，而不会像[PEP
    586](https://peps.python.org/pep-0586/)那样陷入细节。
- en: Literal types are so straightforward that they can make code clearer and more
    readable than code without them. This simplicity is their both a strength and
    a weakness of `typing.Literal`, as it doesn’t offer any additional functionalities.
    However, I’ll show you how to implement additional functionality yourself.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 字面类型非常直接，可以使代码比没有字面类型的代码更清晰、更易读。这种简单性既是`typing.Literal`的优点，也是其缺点，因为它不提供任何额外的功能。然而，我将向你展示如何自行实现附加功能。
- en: The goal of this article is to introduce `typing.Literal` and discuss its value
    in Python coding. Along the way, we’ll explore when to use `typing.Literal` —
    and, just as importantly, when not to.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这篇文章的目标是介绍`typing.Literal`并讨论其在 Python 编程中的价值。在过程中，我们将探讨何时使用`typing.Literal`——同样重要的是，何时不要使用它。
- en: Literal types
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字面类型
- en: Literal types were introduced to the Python typing system by [PEP 586](https://peps.python.org/pep-0586/).
    This PEP provides a comprehensive exploration of the proposal behind literal types,
    serving as a rich source of information on the subject. In contrast, the official
    documentation for the `typing.Literal` type is intentionally concise, reflecting
    its straightforward nature. This article bridges the gap between these two resources,
    providing fundamental information about literal types while also delving into
    details that I consider crucial for the use cases discussed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 字面量类型是通过[PEP 586](https://peps.python.org/pep-0586/)引入到Python类型系统中的。这个PEP提供了对字面量类型提案的全面探讨，是一个丰富的信息来源。相比之下，`typing.Literal`类型的官方文档故意简洁，反映了它的直接性质。本文弥补了这两个资源之间的差距，提供了关于字面量类型的基本信息，同时深入探讨了我认为对所讨论用例至关重要的细节。
- en: As explained in [PEP 586](https://peps.python.org/pep-0586/), literal types
    are particularly useful in scenarios where APIs return different types based on
    the value of an argument. I would broaden this statement by saying that literal
    types allow for the creation of a type that encompasses specific values, not necessarily
    all of the same type. This does not preclude the possibility of all values having
    the same type.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如[PEP 586](https://peps.python.org/pep-0586/)中所述，字面量类型在API根据参数值返回不同类型的场景中特别有用。我会进一步扩展这一说法，指出字面量类型允许创建一个涵盖特定值的类型，这些值不一定都是同一类型的。这并不排除所有值具有相同类型的可能性。
- en: Literal types provide a remarkably simple approach to defining and utilizing
    a type with specific values as the only possible values. This simplicity far surpasses
    any alternative methods. While it’s true that you can achieve the same outcome
    using other methods, these alternatives often come with more complex implementations
    and potentially richer functionality. For instance, creating your own type (class)
    requires careful consideration of both design and implementation — something you
    can ignore altogether when creating a literal type instead.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 字面量类型提供了一种极其简单的方法来定义和利用具有特定值的类型，这些值是唯一可能的值。这种简单性远远超过任何替代方法。虽然确实可以使用其他方法实现相同的结果，但这些替代方案通常会带来更复杂的实现和潜在的更丰富功能。例如，创建你自己的类型（类）需要仔细考虑设计和实现，而创建字面量类型时可以完全忽略这些问题。
- en: Employing `typing.Literal` invariably presents a simpler solution, often significantly
    simpler, but at the expense of reduced functionality. Therefore, before making
    a decision, it’s essential to carefully weigh the advantages and disadvantages
    of both approaches. This article can assist you in making an informed choice.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`typing.Literal`通常提供了一个更简单的解决方案，往往简单得多，但功能可能有所减少。因此，在做出决定之前，必须仔细权衡两种方法的优缺点。本文可以帮助你做出明智的选择。
- en: Acceptable types in literals
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字面量中可接受的类型
- en: 'To create a `typing.Literal` type, you can use the following values:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个`typing.Literal`类型，可以使用以下值：
- en: a literal value of `int`, `bool`, `str` or `bytes`
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`int`、`bool`、`str`或`bytes`的字面量值
- en: an enum value
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个枚举值
- en: '`None`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`None`'
- en: Such types as `float` or instances of a custom (non-enum) class are unacceptable.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 像`float`或自定义（非枚举）类的实例是不接受的。
- en: 'Literal types: Use cases'
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字面量类型：用例
- en: We’ll now explore several use cases where I consider literal types to be an
    excellent choice, often the best option. We’ll also examine situations where alternative
    solutions may be more suitable. Each use case assumes the need for a type that
    accepts only specific values, not necessarily of the same type. `typing.Literal`
    does not create empty types, so `Literal[]` is not valid. It can, however, create
    literal types with a single value.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将探讨几个我认为字面量类型是绝佳选择（往往是最佳选择）的用例。我们还将检视一些可能更合适的替代解决方案。每个用例都假设需要一个只接受特定值的类型，这些值不一定都是同一类型的。`typing.Literal`不会创建空类型，因此`Literal[]`是无效的。然而，它可以创建具有单一值的字面量类型。
- en: The use cases discussed below do not constitute an exhaustive list of scenarios.
    Instead, they serve as examples, and some may overlap. This non-exclusive list
    aims to showcase the range of opportunities that `typing.Literal` offers and to
    enhance understanding of this intriguing and valuable tool.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下述讨论的用例并不构成情境的详尽列表，而是作为示例，其中一些可能会重叠。这个非排他性列表旨在展示`typing.Literal`提供的机会范围，并增强对这个有趣且有价值工具的理解。
- en: 'Example 1: One value only'
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例1：仅一个值
- en: 'As previously mentioned, you can employ a literal type when a variable accepts
    only a single value. While this might seem counterintuitive at first glance, [the](https://docs.python.org/3/library/typing.html#typing.Literal)
    `[typing.Literal](https://docs.python.org/3/library/typing.html#typing.Literal)`
    [documentation](https://docs.python.org/3/library/typing.html#typing.Literal)
    provides a relevant example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当变量只接受单一值时，可以使用字面量类型。虽然这乍一看可能不符合直觉，[文档](https://docs.python.org/3/library/typing.html#typing.Literal)提供了相关示例：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This function is designed for data validation and always returns `True`. In
    other words, if the validation fails, the function raises an error; otherwise,
    it returns `True`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数旨在进行数据验证，并始终返回 `True`。换句话说，如果验证失败，函数会引发错误；否则，它会返回 `True`。
- en: 'Theoretically, a type signature with a return value of the `bool` type, as
    shown below, would be acceptable to static checkers:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，如下所示的 `bool` 类型的返回值类型签名，对于静态检查器来说是可以接受的：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: However, the function never returns `False`, making this type hint misleading
    and inaccurate. Using `bool` implies that the function can, depending on the situation,
    return either of the two Boolean values. When a function consistently returns
    only one of these values and never the other, using `bool` is misleading.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，该函数从未返回 `False`，使得这个类型提示具有误导性和不准确性。使用 `bool` 表示函数根据情况可以返回两个布尔值中的任意一个。当函数始终只返回其中一个值而从不返回另一个时，使用
    `bool` 是误导性的。
- en: This is precisely where a literal type comes into play. Not only does it satisfy
    static checkers, but it also provides valuable information to users.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是字面量类型发挥作用的地方。它不仅满足静态检查器的要求，还为用户提供了有价值的信息。
- en: 'Example 2: In a need of a static type'
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 2：需要静态类型
- en: When runtime type checking is not required, static types often provide the most
    effective solution. Therefore, if you need a type that accepts one or more specific
    values and your primary goal is to inform static checkers, creating the corresponding
    literal type is an excellent approach.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行时类型检查不需要时，静态类型通常提供最有效的解决方案。因此，如果你需要一个接受一个或多个特定值的类型，并且你的主要目标是通知静态检查器，创建相应的字面量类型是一个极好的方法。
- en: 'Example 3: A number of strings'
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 3：多个字符串
- en: 'This use case encompasses a range of strings, such as modes, products, or colors.
    Here are some examples:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此用例包含了一系列字符串，例如模式、产品或颜色。以下是一些示例：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, literal types in this use case can hold two or more strings.
    Importantly, using `Literal` does not allow us to establish relationships between
    the individual values. For instance, we could create the following literal type:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，此用例中的字面量类型可以包含两个或更多的字符串。重要的是，使用 `Literal` 不允许我们建立个别值之间的关系。例如，我们可以创建以下字面量类型：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Does the order in which the values are provided matters? Before Python 3.9.1,
    it did:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 值的提供顺序是否重要？在 Python 3.9.1 之前，是的：
- en: '![](../Images/ce3b836d0deb910e815dfa8758489018.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ce3b836d0deb910e815dfa8758489018.png)'
- en: Before Python 3.9.1, the order of values in a literal type mattered. Image by
    author
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 3.9.1 之前，字面量类型中的值的顺序是重要的。图片由作者提供
- en: 'but ever since it doesn’t:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 但自那以后就不再重要了：
- en: '![](../Images/ac0450355fd1cf468b1b434a124fb7b2.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ac0450355fd1cf468b1b434a124fb7b2.png)'
- en: As of Python 3.9.1, the order of values in a literal type doesn’t matter. Image
    by author
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Python 3.9.1 开始，字面量类型中值的顺序不再重要。图片由作者提供
- en: Consequently, what matters are the possible choices, not their relationships.
    If utilizing the order of values is essential, consider employing a different
    type, not a literal one. One solution is to leverage an enumeration type, utilizing
    the `enum.Enum` class; we’ll delve into this concept soon, in a dedicated article.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，重要的是可能的选择，而不是它们之间的关系。如果利用值的顺序是关键，考虑使用其他类型，而不是字面量类型。一个解决方案是利用枚举类型，使用 `enum.Enum`
    类；我们将很快在专门的文章中深入探讨这个概念。
- en: '***A word of caution***: Python 3.11 and newer introduce `typing.LiteralString`.
    This constitutes a distinct tool, as unlike `typing.Literal`, it serves as a type
    itself, not a tool for creating types. In this article, we’re exploring the creation
    of literal types, and I wouldn’t want to introduce confusion with this slightly
    different yet related tool. If you’re interested in learning more, visit the Appendix
    at the end of the article. However, let’s set this topic aside for now. The key
    takeaway is that `typing.LiteralString` is not a substitute for `typing.Literal`
    for strings.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '***谨慎提醒***：Python 3.11及更新版本引入了`typing.LiteralString`。这是一个不同的工具，因为与`typing.Literal`不同，它作为一种类型存在，而不是创建类型的工具。在本文中，我们探讨了字面量类型的创建，我不希望引入与这个略有不同但相关的工具的混淆。如果你有兴趣了解更多，访问文章末尾的附录。不过，让我们现在将这个话题搁置。关键是，`typing.LiteralString`不是`typing.Literal`的字符串替代品。'
- en: '`typing.LiteralString` is *not* a replacement for `typing.Literal` for strings.'
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`typing.LiteralString` *不是* `typing.Literal`的字符串替代品。'
- en: 'Example 4: Multiple values of the same type'
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 4：相同类型的多个值
- en: 'This example extends the previous one to encompass a broader range of data
    types. Just as we employed literal types for strings, we can apply them to most
    other data types as well. Here are some examples:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例扩展了前一个示例，涵盖了更广泛的数据类型。就像我们为字符串使用字面量类型一样，我们也可以将它们应用于大多数其他数据类型。这里是一些示例：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As mentioned above, you can use a literal value of `int`, `bool`, `str` or `bytes`,
    an enum value and `None.`
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，你可以使用`int`、`bool`、`str`或`bytes`的字面量值、枚举值和`None`。
- en: 'Example 5: Combining values of various types'
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 5：组合各种类型的值
- en: This represents the most general form of a literal type. You can combine objects
    of any type, and it will function correctly. This bears some resemblance to using
    the `typing.Union` type, but unlike the typical `Union` use case, we are combining
    objects rather than types.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这代表了字面量类型的最通用形式。你可以组合任何类型的对象，它将正常工作。这有些类似于使用`typing.Union`类型，但与典型的`Union`使用情况不同，我们是在组合对象而不是类型。
- en: 'Note the difference: A common Union use case might look like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意区别：一个常见的 Union 使用案例可能如下所示：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'while a literal type combining objects of `int` and `str` types could be as
    follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 而一个组合了`int`和`str`类型对象的字面量类型可能如下：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here are some other examples:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些其他示例：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can create the following type: `Literal[True, False, None]`. It’s similar
    to the `OptionalBool` type described here:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建以下类型：`Literal[True, False, None]`。它类似于这里描述的`OptionalBool`类型。
- en: '[](https://medium.com/pythoniq/an-optionalbool-type-for-python-none-false-or-true-7667e9cc6dd8?source=post_page-----03c60ce42750--------------------------------)
    [## An OptionalBool Type for Python: None, False or True'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[## An OptionalBool Type for Python: None, False or True](https://medium.com/pythoniq/an-optionalbool-type-for-python-none-false-or-true-7667e9cc6dd8?source=post_page-----03c60ce42750--------------------------------)'
- en: Use OptionalBool instead of Optional[bool].
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用OptionalBool而不是Optional[bool]。
- en: medium.com](https://medium.com/pythoniq/an-optionalbool-type-for-python-none-false-or-true-7667e9cc6dd8?source=post_page-----03c60ce42750--------------------------------)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[medium.com](https://medium.com/pythoniq/an-optionalbool-type-for-python-none-false-or-true-7667e9cc6dd8?source=post_page-----03c60ce42750--------------------------------)'
- en: The `OptionalBool` type described in the above article is far more complex than
    the corresponding one based on `Literal`, the latter being both easier to use
    and understand but also having significantly poorer functionality.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 上述文章中描述的`OptionalBool`类型比基于`Literal`的对应类型要复杂得多，后者既易于使用和理解，又具有显著较差的功能。
- en: 'The next three examples from the code block above are also interesting. They
    show that you can create combinations of two (or more, for that matter) literal
    types. Here, `YesOrNo` is a literal type that joins two other literal types, that
    is, `Positives` and `Negatives`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码块中的三个例子也很有趣。它们显示了你可以创建两个（或更多）字面量类型的组合。这里，`YesOrNo`是一个将两个其他字面量类型，即`Positives`和`Negatives`组合在一起的字面量类型：
- en: '![](../Images/2427259b1f9dc32dd8a2761dcfd8c163.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2427259b1f9dc32dd8a2761dcfd8c163.png)'
- en: Joining two literal types in Python 3.9.1 and newer. Imagine by author
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3.9.1及更高版本中连接两个字面量类型。作者想象
- en: 'Do remember, however, that this wouldn’t work the same way before Python 3.9.1
    (we saw it before, where we discussed the order of literals in type definition):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住，这在 Python 3.9.1 之前的版本中不会以相同的方式工作（我们之前讨论了类型定义中字面量的顺序）：
- en: '![](../Images/935bad7f39f0d05985f7503d3600c7c7.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/935bad7f39f0d05985f7503d3600c7c7.png)'
- en: Joining two literal types before Python 3.9.1\. Imagine by author
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 3.9.1 之前连接两个字面量类型。作者想象
- en: 'Example 6: Runtime m**embershi**p checking'
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 6：运行时 m**embershi**p 检查
- en: In the preceding examples, we focused exclusively on static applications of
    literal types. However, this does not preclude their use during runtime, even
    though this deviates from the intended purpose of Python type hints. Here, I’ll
    demonstrate that you can perform runtime membership checks for literal types when
    the need arises. In other words, you can verify whether a given value belongs
    to the set of possible choices for a literal type.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们专注于字面量类型的静态应用。然而，这并不排除它们在运行时的使用，即使这偏离了 Python 类型提示的原意。在这里，我将演示当需要时，你可以对字面量类型进行运行时成员检查。换句话说，你可以验证一个给定的值是否属于字面量类型的可能选择集合。
- en: 'Frankly, I believe this single capability elevates `typing.Literal` to a much
    more powerful tool. While it strays from the conventional usage of literal types
    (static code checking), it isn’t a hack. It’s a legitimate function of the typing
    module: `typing.get_args()`.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 坦白说，我认为这一单一能力使 `typing.Literal` 成为一个更强大的工具。虽然它偏离了字面量类型的传统用法（静态代码检查），但这并不是一种黑客行为。这是类型模块的一个合法功能：`typing.get_args()`。
- en: 'An example will best illustrate this concept. First, let’s define a literal
    type:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子将最好地说明这个概念。首先，让我们定义一个字面量类型：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `Tens` type encompasses various representations of the number `10`. Now,
    let’s define a function that validates whether an object has the type of `Tens`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tens` 类型涵盖了数字 `10` 的各种表示形式。现在，让我们定义一个函数来验证一个对象是否具有 `Tens` 类型：'
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A few remarks about the function:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个函数的几点说明：
- en: It accepts any object and returns `Optional[Tens]`, indicating that if `obj`
    is a valid member of `Tens`, the function will return it; otherwise, it will return
    `None`. This is why `typing.Optional` is used (see [this article](/python-types-optional-can-mean-mandatory-8e3b7ac2e805)).
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它接受任何对象，并返回 `Optional[Tens]`，这表明如果 `obj` 是 `Tens` 的有效成员，函数将返回它；否则，将返回 `None`。这就是为什么使用
    `typing.Optional`（参见 [这篇文章](/python-types-optional-can-mean-mandatory-8e3b7ac2e805)）。
- en: The check is performed using the `typing.get_args()` function. For a literal
    type, it returns all its possible values.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `typing.get_args()` 函数进行检查。对于字面量类型，它返回所有可能的值。
- en: Here’s where it gets interesting. From a dynamic perspective, the last line
    of the function (`return None`) is redundant, as an absent `None` return is implicitly
    interpreted as a `None` return. However, `mypy` does not accept [implicit None
    returns](https://mypy.readthedocs.io/en/stable/kinds_of_types.html#optional-types-and-the-none-type),
    as illustrated in the image below.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里情况变得有趣。从动态的角度来看，函数的最后一行（`return None`）是多余的，因为缺少的 `None` 返回值会被隐式解释为 `None`
    返回值。然而，`mypy` 不接受 [隐式 None 返回值](https://mypy.readthedocs.io/en/stable/kinds_of_types.html#optional-types-and-the-none-type)，如下图所示。
- en: '![](../Images/89b9afea9174de2519a6b06455018775.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/89b9afea9174de2519a6b06455018775.png)'
- en: Mypy does not accept an implicit None return. Screenshots from Visual Studio
    Code. Image by author
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Mypy 不接受隐式的 None 返回值。截图来自 Visual Studio Code。图片由作者提供
- en: According to [the](https://mypy.readthedocs.io/en/stable/kinds_of_types.html#disabling-strict-optional-checking)
    `[mypy](https://mypy.readthedocs.io/en/stable/kinds_of_types.html#disabling-strict-optional-checking)`
    [documentation](https://mypy.readthedocs.io/en/stable/kinds_of_types.html#disabling-strict-optional-checking),
    you can disable strict `None` checking using the `[--no-strict-optional](https://mypy.readthedocs.io/en/stable/command_line.html#cmdoption-mypy-no-strict-optional)`
    command-line option. Think twice if you want to use this option. I prefer to always
    explicitly declare whether a particular type accepts `None` or not. Disabling
    strict checking means that any type is assumed to accept `None`, which can lead
    to unexpected behavior and make code more difficult to understand and maintain.
    While I am not a great fan of very thorough type hints, using the `[--no-strict-optional](https://mypy.readthedocs.io/en/stable/command_line.html#cmdoption-mypy-no-strict-optional)`
    flag is in my eyes an oversimplification, because `None` is too important a sentinel
    value to ignore it just like that.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[官方文档](https://mypy.readthedocs.io/en/stable/kinds_of_types.html#disabling-strict-optional-checking)中的`[mypy](https://mypy.readthedocs.io/en/stable/kinds_of_types.html#disabling-strict-optional-checking)`，你可以使用`[--no-strict-optional](https://mypy.readthedocs.io/en/stable/command_line.html#cmdoption-mypy-no-strict-optional)`命令行选项来禁用严格的`None`检查。如果你打算使用这个选项，请三思。我更倾向于明确声明某种类型是否接受`None`。禁用严格检查意味着任何类型都假定接受`None`，这可能导致意外行为，使代码更难以理解和维护。虽然我不是非常喜欢非常详细的类型提示，但在我看来，使用`[--no-strict-optional](https://mypy.readthedocs.io/en/stable/command_line.html#cmdoption-mypy-no-strict-optional)`标志是一种过于简化的做法，因为`None`是一个非常重要的哨兵值，不应如此轻忽。
- en: If you do need to disable strict checking in specific situations, remember that
    when you do so but someone else doesn’t, they may encounter many static errors
    throughout the code. Maintaining consistent type checking settings throughout
    a codebase is a good general practice.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实需要在特定情况下禁用严格检查，请记住，当你这样做而其他人没有时，他们可能会在代码中遇到许多静态错误。在整个代码库中保持一致的类型检查设置是一个好的实践。
- en: Literals versus enumerations
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字面量与枚举
- en: While reading the previous section, did you notice that some literal types resemble
    enumerations types? Indeed, they do share some similarities, but literal types
    lack the natural order of values inherent in enumerations.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读前一部分时，你是否注意到一些字面量类型与枚举类型相似？确实，它们确实有一些相似之处，但字面量类型缺乏枚举固有的自然值顺序。
- en: 'Compare these two type definitions:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 比较这两种类型定义：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you primarily noticed the difference in syntax, be aware that you can also
    define enumeration types using static factory methods:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你主要注意到的是语法差异，要知道你也可以使用静态工厂方法来定义枚举类型：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: So, the definition syntax isn’t the key distinction between literal types and
    enumerations. Firstly, literal types are static types with minor dynamic functionality,
    while enumeration types offer both static and dynamic capabilities, making them
    more versatile. If you require more than what literal types provide, enumerations
    are likely the better choice.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，定义语法并不是字面量类型和枚举类型之间的关键区别。首先，字面量类型是具有少量动态功能的静态类型，而枚举类型则提供了静态和动态能力，使其更加多功能。如果你需要的功能超出了字面量类型的范围，枚举类型可能是更好的选择。
- en: This article doesn’t delve into the intricacies of Python enumerations. However,
    the following table compares the two tools. Before proceeding, analyze the table
    and observe that `typing.literal` offers a subset of `enum.Enum`'s features.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 本文不会深入探讨 Python 枚举的复杂性。然而，以下表格比较了这两种工具。在继续之前，请分析表格并观察`typing.literal`提供了`enum.Enum`的一部分功能。
- en: '![](../Images/c1da3eae32e0978110d2f4ad2870d549.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c1da3eae32e0978110d2f4ad2870d549.png)'
- en: Comparison of enum.Enum and typing.Literal. Image by author
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum.Enum`与`typing.Literal`的比较。图片由作者提供'
- en: Despite their versatility, literal types excel in simplicity, brevity, and readability.
    While Python enumerations are also straightforward and readable, literal types
    offer an even higher level of clarity and conciseness.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管字面量类型在简洁性、简短性和可读性方面表现优异。虽然 Python 枚举类型也很简单和可读，但字面量类型提供了更高水平的清晰性和简洁性。
- en: Conclusion
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: The central message of this article is that `typing.Literal` and literal types
    are powerful tools that offer more capabilities than one might initially assume.
    Their simplicity conceals their depth and versatility. As I mentioned at the beginning
    of the article, I had underestimated the value of this tool for quite some time.
    However, today I recognize it — and literal types in general — as a powerful yet
    straightforward mechanism for enhancing Python code conciseness while maintaining
    static correctness.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 本文的核心信息是 `typing.Literal` 和字面量类型是强大的工具，提供的功能超出了最初的假设。它们的简单性掩盖了它们的深度和多功能性。正如我在文章开头提到的，我曾经低估了这个工具的价值。然而，今天我认识到它——以及一般的字面量类型——是增强
    Python 代码简洁性同时保持静态正确性的强大而简单的机制。
- en: 'In fact, using other type hints to express the same concept as a literal type
    can lead to confusion, even if static checkers don’t raise any errors. When all
    you need is a static type to be checked by static checkers, `typing.Literal` should
    be your go-to choice. Its usage is straightforward and doesn’t require excessive
    code: just the type definition, which typically takes one or more lines depending
    on the number of literals included in the type.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，使用其他类型提示来表达与字面量类型相同的概念可能会导致混淆，即使静态检查器没有报错。当你只需要静态类型供静态检查器检查时，`typing.Literal`
    应该是你的首选。它的使用方法很简单，不需要过多的代码：只需类型定义，这通常需要一行或多行，具体取决于类型中包含的字面量数量。
- en: For scenarios requiring more advanced dynamic functionality, enumerations may
    be a better fit. They provide an additional layer of safety at runtime by preventing
    invalid value assignments. Literal types, on the other hand, do not offer this
    inherent safeguard, although it can be implemented as demonstrated with the `is_ten()`
    function above. However, this safeguard would need to be applied every time a
    user provides a value of this type.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要更多高级动态功能的场景，枚举可能是更好的选择。它们通过防止无效值分配，在运行时提供了额外的安全层。另一方面，字面量类型并没有提供这种固有的保护，尽管可以像上述
    `is_ten()` 函数演示的那样实现。然而，这种保护需要在每次用户提供该类型的值时应用。
- en: In essence, remember about literal types and `typing.Literal`. Incorporate them
    into your Python code to achieve simplicity and readability. I’d say that in Python,
    `typing.Literal` achieves one of the highest usefulness-to-complexity ratios,
    making it simultaneously highly useful and remarkably simple.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，记住字面量类型和 `typing.Literal`。将它们融入你的 Python 代码中，以实现简洁和可读性。我认为在 Python 中，`typing.Literal`
    实现了最高的实用性与复杂性的比率之一，使其既非常有用又极其简单。
- en: Appendix 1
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 1
- en: typing.LiteralString
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: typing.LiteralString
- en: Python 3.11 and newer introduced the `typing.LiteralString` type. Despite its
    name, it is not a direct replacement for `typing.Literal` for strings. To avoid
    unnecessary confusion, let’s not delve into this type in detail here. Instead,
    let’s briefly outline the fundamental aspects of this type.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.11 及更高版本引入了 `typing.LiteralString` 类型。尽管其名称如此，但它并不是 `typing.Literal`
    在字符串方面的直接替代品。为了避免不必要的混淆，我们在这里不深入探讨此类型。相反，我们简要概述一下此类型的基本方面。
- en: 'Unlike `typing.Literal`, which serves as a mechanism for creating literal types,
    `typing.LiteralString` is a type itself. It can be used to specify that a variable
    should hold a literal string, as demonstrated in the following example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与用作创建字面量类型机制的 `typing.Literal` 不同，`typing.LiteralString` 本身就是一个类型。它可以用来指定变量应持有一个字面量字符串，如下例所示：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note what the documentation says:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意文档中的说明：
- en: Any string literal is compatible with `*LiteralString*`, as is another `*LiteralString*`.
    However, an object typed as just `*str*` is not.
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 任何字符串字面量都与 `*LiteralString*` 兼容，另一个 `*LiteralString*` 也是如此。然而，单独标记为 `*str*`
    的对象则不兼容。
- en: And
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 而且
- en: '`*LiteralString*` is useful for sensitive APIs where arbitrary user-generated
    strings could generate problems. For example, the two cases above that generate
    type checker errors could be vulnerable to an SQL injection attack.'
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`*LiteralString*` 对于敏感 API 很有用，在这些 API 中，任意用户生成的字符串可能会产生问题。例如，上述生成类型检查器错误的两个情况可能会受到
    SQL 注入攻击的威胁。'
- en: This brief overview should suffice for our current discussion. If you’re interested
    in exploring this type further, refer to [PEP 675](https://peps.python.org/pep-0675/),
    which introduced this literal type.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简要概述应该足以满足我们当前的讨论。如果你有兴趣进一步探索此类型，请参阅 [PEP 675](https://peps.python.org/pep-0675/)，该
    PEP 介绍了这个字面量类型。
- en: Appendix 2
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 2
- en: Defining literal types using iterables
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用可迭代对象定义字面量类型
- en: '***Warning***: This section presents a hack that does not work statically.
    So, if your only aim is to create a static type, do *not* use this hack. It’s
    rather an interesting piece of information than something to be used in production
    code.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '***警告***：本节展示了一个静态无法工作的技巧。因此，如果你的唯一目标是创建静态类型，请*不要*使用这个技巧。这更多的是一个有趣的信息，而非生产代码中的内容。'
- en: 'If you are not familiar with `typing.Literal`, `Literal[]` might resemble indexing,
    and `Literal[1, 2, 3]` might appear similar to a list. As a result, you might
    be tempted to use a list comprehension, as shown here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉`typing.Literal`，`Literal[]`可能类似于索引，而`Literal[1, 2, 3]`可能类似于列表。因此，你可能会被诱导使用列表推导式，如下所示：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The error message indicates that this is not valid syntax. This is because `typing.Literal`
    is not meant to be used as a list comprehension. Instead, it is used to specify
    particular values the type accepts.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 错误消息表明这不是有效的语法。这是因为`typing.Literal`不应该用作列表推导式。相反，它用于指定类型接受的特定值。
- en: 'But look here:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 但看看这里：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: No error? So, we’re fine, aren’t we?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 没有错误？那么，我们没问题，对吧？
- en: 'No, we aren’t. Look at what `OneToTen` is:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 不，我们不是。看看`OneToTen`是什么：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see, this definition worked but not in the way we intended. `OneToTen`
    is a literal type with only one value: a list of integers from 1 to 10\. Not only
    is a list not an acceptable literal type, this is also not quite what we were
    hoping for!'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个定义有效，但并不是我们想要的方式。`OneToTen`是一个字面量类型，只有一个值：一个从1到10的整数列表。列表不仅不是一个可接受的字面量类型，这也不是我们期望的！
- en: 'But don’t worry, we’re not done here. There’s a trick that will help us achieve
    the desired outcome. We can access the possible values of a literal type in two
    ways. One method, which we’ve already seen in action, is the `get_args()` function.
    Another method is to use the `.__args__` attributeof the type:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 但别担心，我们还没完成。还有一个技巧可以帮助我们实现预期结果。我们可以通过两种方式访问字面量类型的可能值。一种方法是我们已经看到的`get_args()`函数。另一种方法是使用类型的`.__args__`属性：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'While `get_args()` allows us to get a literal type’s values, we can leverage
    the `.__args__` attribute to update the type. Look:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`get_args()`允许我们获取字面量类型的值，但我们可以利用`.__args__`属性来更新类型。看看：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Ha! This is the trick I mentioned above. We can call it the `.__args__` trick.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 哈！这就是我之前提到的技巧。我们可以称之为`.__args__`技巧。
- en: 'Above, I used a list, but it doesn’t matter what type of iterable you’ll use:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 上面我使用了一个列表，但你使用什么类型的可迭代对象并不重要：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'I assigned a list literal to `OneToTen.__args__`, but you can do the same in
    any other way, like using a list comprehension or [another comprehension](https://medium.com/towards-data-science/a-guide-to-python-comprehensions-4d16af68c97e):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我将一个列表字面量赋值给了`OneToTen.__args__`，但你可以用其他方式实现，比如使用列表推导式或[另一种推导式](https://medium.com/towards-data-science/a-guide-to-python-comprehensions-4d16af68c97e)：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You do have to be careful, however, as not always will `Literal` behave in
    a predictable way. For instance, it will work like above with `range()` but won’t
    work with a generator expression:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你确实需要小心，因为`Literal`并不总是表现得可预测。例如，它在`range()`中像上面那样有效，但在生成器表达式中则不行：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Actually, while experimenting with generator expressions used with `Literal`,
    I noticed that it did work several times… I don’t know why: normally it doesn’t
    work that way, so out of say two dozen times I tried it, it worked only 2 or 3
    times. That’s something I’m worried about as I hate situations in which a programming
    language behaves in an unpredictable way — even if in a hack.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在使用`Literal`进行生成器表达式实验时，我发现它确实有几次有效……我不知道为什么：通常它不这样工作，所以在我尝试的二十多次中，只有效了2或3次。这让我担心，因为我讨厌编程语言表现出不可预测的行为——即使是在技巧中。
- en: 'Having troubles believing this? Look at this screenshot from Python 3.11:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 难以相信这一点？看看这张来自Python 3.11的截图：
- en: '![](../Images/1be1895fe7235dfc28f471268039feb2.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1be1895fe7235dfc28f471268039feb2.png)'
- en: Unpredictable behavior of typing.Literal.__args__ used with generator expressions.
    Screenshot from Python 3.11\. Image by author
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用生成器表达式时`typing.Literal.__args__`的不可预测行为。截图来自Python 3.11。图片由作者提供
- en: 'Just so you know, `A` was not used before, but `OneToTen` was — on the other
    hand, this should not change a thing. Besides, the next time I tried this, this
    time for a new name, `B`, it didn’t work:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 仅供参考，之前没有使用`A`，但使用过`OneToTen`——不过，这应该不影响结果。此外，下次我尝试这个时，换了个新名称`B`，结果也没有成功：
- en: '![](../Images/adc7cd43e146f24e89630055329c7534.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/adc7cd43e146f24e89630055329c7534.png)'
- en: A different behavior of typing.Literal.__args__ with a generator expression
    than before. Screenshot from Python 3.11\. Image by author
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`typing.Literal.__args__` 与生成器表达式的行为不同于之前。截图来自 Python 3.11。图像由作者提供'
- en: Hence, unless you’re ready to accept unpredictable behavior of Python, don’t
    use `typing.Literal` with generator expressions before this issue is solved. But
    there’s nothing to worry about, as generator expressions are typically used to
    overcome memory issues — and creating a literal type doesn’t seem like something
    that should lead to such problems. Hence, instead of using a generator to create
    a literal type, you can make a list out of it and use it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除非你准备好接受 Python 的不可预测行为，否则在这个问题解决之前，不要将 `typing.Literal` 与生成器表达式一起使用。不过没什么好担心的，因为生成器表达式通常用于克服内存问题——创建字面量类型似乎不会导致这样的问题。因此，你可以将其转化为一个列表并使用，而不是用生成器创建字面量类型。
- en: As mentioned at the beginning of this section, you should avoid using the `.__args__`
    hack. It will work dynamically, but `mypy` will not accept it. It’s good to know
    this, as it extends your knowledge of `typing` type hints, but it’s not something
    you should use in production code.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节开头所述，你应该避免使用 `.__args__` hack。它会动态工作，但 `mypy` 不会接受它。了解这一点是好的，因为它扩展了你对 `typing`
    类型提示的知识，但这不是你应该在生产代码中使用的东西。
- en: 'Thanks for reading. If you enjoyed this article, you may also enjoy other articles
    I wrote; you will see them [here](https://medium.com/@nyggus). And if you want
    to join Medium, please use my referral link below:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢阅读。如果你喜欢这篇文章，你也可能喜欢我写的其他文章；你可以在[这里](https://medium.com/@nyggus)查看。如果你想加入 Medium，请使用下面我的推荐链接：
- en: '[](https://medium.com/@nyggus/membership?source=post_page-----03c60ce42750--------------------------------)
    [## Join Medium with my referral link - Marcin Kozak'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@nyggus/membership?source=post_page-----03c60ce42750--------------------------------)
    [## 使用我的推荐链接加入 Medium - Marcin Kozak'
- en: As a Medium member, a portion of your membership fee goes to writers you read,
    and you get full access to every story…
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作为 Medium 会员，你的一部分会员费用将会分配给你阅读的作者，并且你可以完全访问每一个故事……
- en: medium.com](https://medium.com/@nyggus/membership?source=post_page-----03c60ce42750--------------------------------)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: medium.com](https://medium.com/@nyggus/membership?source=post_page-----03c60ce42750--------------------------------)
