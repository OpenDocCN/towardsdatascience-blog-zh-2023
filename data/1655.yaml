- en: 'Rust Polars: Unlocking High-Performance Data Analysis — Part 2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust Polars：解锁高性能数据分析 — 第二部分
- en: 原文：[https://towardsdatascience.com/rust-polars-unlocking-high-performance-data-analysis-part-2-7c58a3cb7a1f?source=collection_archive---------3-----------------------#2023-05-18](https://towardsdatascience.com/rust-polars-unlocking-high-performance-data-analysis-part-2-7c58a3cb7a1f?source=collection_archive---------3-----------------------#2023-05-18)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/rust-polars-unlocking-high-performance-data-analysis-part-2-7c58a3cb7a1f?source=collection_archive---------3-----------------------#2023-05-18](https://towardsdatascience.com/rust-polars-unlocking-high-performance-data-analysis-part-2-7c58a3cb7a1f?source=collection_archive---------3-----------------------#2023-05-18)
- en: Exploring Rust’s Polars DataFrames, Aggregation Functions, and Beyond
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索 Rust 的 Polars 数据框架、聚合函数及更多
- en: '[](https://wiseai.medium.com/?source=post_page-----7c58a3cb7a1f--------------------------------)[![Mahmoud
    Harmouch](../Images/d61617549d25565399975debaad5908f.png)](https://wiseai.medium.com/?source=post_page-----7c58a3cb7a1f--------------------------------)[](https://towardsdatascience.com/?source=post_page-----7c58a3cb7a1f--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----7c58a3cb7a1f--------------------------------)
    [Mahmoud Harmouch](https://wiseai.medium.com/?source=post_page-----7c58a3cb7a1f--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://wiseai.medium.com/?source=post_page-----7c58a3cb7a1f--------------------------------)[![Mahmoud
    Harmouch](../Images/d61617549d25565399975debaad5908f.png)](https://wiseai.medium.com/?source=post_page-----7c58a3cb7a1f--------------------------------)[](https://towardsdatascience.com/?source=post_page-----7c58a3cb7a1f--------------------------------)[![数据科学前沿](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----7c58a3cb7a1f--------------------------------)
    [Mahmoud Harmouch](https://wiseai.medium.com/?source=post_page-----7c58a3cb7a1f--------------------------------)'
- en: ·
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fb15db3da5667&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Frust-polars-unlocking-high-performance-data-analysis-part-2-7c58a3cb7a1f&user=Mahmoud+Harmouch&userId=b15db3da5667&source=post_page-b15db3da5667----7c58a3cb7a1f---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----7c58a3cb7a1f--------------------------------)
    ·24 min read·May 18, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F7c58a3cb7a1f&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Frust-polars-unlocking-high-performance-data-analysis-part-2-7c58a3cb7a1f&user=Mahmoud+Harmouch&userId=b15db3da5667&source=-----7c58a3cb7a1f---------------------clap_footer-----------)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[关注](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fb15db3da5667&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Frust-polars-unlocking-high-performance-data-analysis-part-2-7c58a3cb7a1f&user=Mahmoud+Harmouch&userId=b15db3da5667&source=post_page-b15db3da5667----7c58a3cb7a1f---------------------post_header-----------)
    发表在 [数据科学前沿](https://towardsdatascience.com/?source=post_page-----7c58a3cb7a1f--------------------------------)
    ·24分钟阅读·2023年5月18日[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F7c58a3cb7a1f&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Frust-polars-unlocking-high-performance-data-analysis-part-2-7c58a3cb7a1f&user=Mahmoud+Harmouch&userId=b15db3da5667&source=-----7c58a3cb7a1f---------------------clap_footer-----------)'
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F7c58a3cb7a1f&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Frust-polars-unlocking-high-performance-data-analysis-part-2-7c58a3cb7a1f&source=-----7c58a3cb7a1f---------------------bookmark_footer-----------)![](../Images/700d954aea76580261342f38363b4daf.png)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F7c58a3cb7a1f&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Frust-polars-unlocking-high-performance-data-analysis-part-2-7c58a3cb7a1f&source=-----7c58a3cb7a1f---------------------bookmark_footer-----------)![](../Images/700d954aea76580261342f38363b4daf.png)'
- en: Image by [Alan](https://pixabay.com/users/ad_images-6663717/?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=3348777)
    from [Pixabay](https://pixabay.com//?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=3348777)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图片来源：[艾伦](https://pixabay.com/users/ad_images-6663717/?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=3348777)
    来自 [Pixabay](https://pixabay.com//?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=3348777)
- en: TL;DR
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TL;DR
- en: The Rust programming language has been making waves in the industry and is now
    gaining momentum within data science. Its remarkable speed and strong security
    features are highly sought after by developers who need to manage large datasets
    effectively. The Polars library takes full advantage of Rust’s capabilities, providing
    fast and efficient methods for manipulating complex data sets. With its outstanding
    performance, it proves to be an appealing choice for those working on complicated
    projects that require quick processing abilities.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 编程语言在业界掀起了波澜，并且在数据科学领域逐渐获得关注。它卓越的速度和强大的安全特性受到需要有效管理大型数据集的开发者的高度追捧。Polars
    库充分利用了 Rust 的能力，提供了快速高效的复杂数据集处理方法。凭借其卓越的性能，对于那些从事需要快速处理能力的复杂项目的工作者来说，它是一个极具吸引力的选择。
- en: This write-up acts as a continuum in this series where we demystify the world
    of Polars. [**In the first part of this series**](/rust-polars-unlocking-high-performance-data-analysis-part-1-ce42af370ece),
    we learned about Rust’s Polars series object, its use cases, and much more. In
    this part of the series, we will explore another Polars’s fundamental data structure,
    namely the **DataFrame** object. Through hands-on exercises and code snippets,
    you’ll acquire crucial skills such as executing diverse operations on DataFrames
    among other things.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本文作为该系列的延续，旨在揭开 Polars 世界的神秘面纱。[**在系列的第一部分**](/rust-polars-unlocking-high-performance-data-analysis-part-1-ce42af370ece)中，我们学习了
    Rust 的 Polars 系列对象及其应用等内容。在这一部分中，我们将探索另一个 Polars 的基本数据结构，即 **DataFrame** 对象。通过实际操作和代码片段，你将获得执行各种
    DataFrame 操作等重要技能。
- en: '**Note:** This article assumes that you have a fairly basic understanding of
    the Rust programming language.'
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意：** 本文假设你对 Rust 编程语言有相当基础的了解。'
- en: ''
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The notebook named [**4-polars-tutorial-part-2.ipynb**](https://github.com/wiseaidev/rust-data-analysis/blob/main/4-polars-tutorial-part-2.ipynb)wasdeveloped
    for this article which can be found in the following repository:'
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了本文而开发的笔记本名为 [**4-polars-tutorial-part-2.ipynb**](https://github.com/wiseaidev/rust-data-analysis/blob/main/4-polars-tutorial-part-2.ipynb)，可以在以下仓库中找到：
- en: '[](https://github.com/wiseaidev/rust-data-analysis?source=post_page-----7c58a3cb7a1f--------------------------------)
    [## GitHub - wiseaidev/rust-data-analysis: The ultimate data analysis with Rust
    course.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://github.com/wiseaidev/rust-data-analysis?source=post_page-----7c58a3cb7a1f--------------------------------)
    [## GitHub - wiseaidev/rust-data-analysis: 终极 Rust 数据分析课程。]'
- en: This repository is a collection of Jupyter notebooks, all powered by a Rust
    kernel. With these notebooks, you'll be…
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本仓库包含了一系列 Jupyter 笔记本，所有笔记本都由 Rust 内核支持。通过这些笔记本，你将能够…
- en: github.com](https://github.com/wiseaidev/rust-data-analysis?source=post_page-----7c58a3cb7a1f--------------------------------)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: github.com](https://github.com/wiseaidev/rust-data-analysis?source=post_page-----7c58a3cb7a1f--------------------------------)
- en: Table of Contents(TOC)
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目录（TOC）
- en: ∘ [DataFrame Object](#6752)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [DataFrame 对象](#6752)
- en: ∘ [Indexing & Slicing](#5a00)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [索引与切片](#5a00)
- en: ∘ [Data Cleaning](#bf0b)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [数据清理](#bf0b)
- en: ∘ [Measures of central tendency](#406b)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [集中趋势测量](#406b)
- en: ∘ [Ndarray](#b0f8)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [Ndarray](#b0f8)
- en: ∘ [Aggregation Functions](#6902)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [聚合函数](#6902)
- en: ∘ [Merging DataFrames](#b011)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [合并 DataFrame](#b011)
- en: ∘ [Conclusion](#4c07)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [结论](#4c07)
- en: ∘ [Closing Note](#7e8f)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [结束语](#7e8f)
- en: ∘ [Resources](#7546)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [资源](#7546)
- en: DataFrame Object
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DataFrame 对象
- en: '![](../Images/042a84b685ff0191afef47ee5ecb0fb1.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/042a84b685ff0191afef47ee5ecb0fb1.png)'
- en: Polars dataframe representation (Image by author)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Polars 数据框表示（作者提供的图片）
- en: At the heart of the Polars library lies an essential component that serves as
    its foundation; The [**DataFrame**](https://docs.rs/polars/latest/polars/prelude/struct.DataFrame.html#)
    structure. This ingenious **two-dimensional data** representation is organized
    in **rows and columns**, similar to a series object but with added dimensions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Polars 库的核心是一个重要的组件，它作为其基础；即 [**DataFrame**](https://docs.rs/polars/latest/polars/prelude/struct.DataFrame.html#)
    结构。这一巧妙的 **二维数据** 表示以 **行和列** 组织，类似于系列对象，但增加了维度。
- en: DataFrame Initialization
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DataFrame 初始化
- en: 'In Polars, initializing a data frame is as simple as using the powerful [**DataFrame**](https://docs.rs/polars/latest/polars/prelude/struct.DataFrame.html)
    Struct. To illustrate the incredible simplicity of DataFrame initialization, let’s
    consider the following snippet of code to create an empty data frame:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Polars 中，初始化数据框和使用强大的 [**DataFrame**](https://docs.rs/polars/latest/polars/prelude/struct.DataFrame.html)
    结构一样简单。为了说明 DataFrame 初始化的简单性，下面是创建一个空数据框的代码片段：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, let us explore the flexibility of the Polars library in depth. Take a look
    at this code snippet where series are effortlessly converted into a **2-D DataFrame:**
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入探讨 Polars 库的灵活性。看看这段代码片段，其中 series 轻松转换为**二维 DataFrame**：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The Polars DataFrame initialization process is straightforward, as evident
    from its effortless implementation. Moreover, the `[**df!**](https://docs.rs/polars/latest/polars/prelude/macro.df.html)`
    macro enables you to create data frames easily. Take the following as an example
    of utilizing this macro:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Polars DataFrame 的初始化过程非常简单，从其轻松实现中可以明显看出。此外，`[**df!**](https://docs.rs/polars/latest/polars/prelude/macro.df.html)`
    宏使您能够轻松创建数据框架。以下是利用此宏的示例：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Describe
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: The `[**describe**](https://docs.rs/polars/latest/polars/frame/struct.DataFrame.html#method.describe)`
    method in Polars is a highly utilized technique that provides **an overview of
    statistical measures** for datasets. This method creates a comprehensive table
    consisting of the **count**, **mean**, **standard deviation**, **minimum** and
    **maximum** values, and the **25th** **percentile** to **75th** **percentile**
    **range** (**median**) for each column within the dataset. By employing this method,
    you can acquire valuable insights into your data’s characteristics, such as identifying
    potential outliers while comprehending its distribution pattern effectively.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Polars 中的 `[**describe**](https://docs.rs/polars/latest/polars/frame/struct.DataFrame.html#method.describe)`
    方法是一个广泛使用的技术，为数据集提供**统计指标概述**。该方法创建了一个详尽的表格，包括每列的**计数**、**平均值**、**标准差**、**最小值**和**最大值**，以及**第
    25** 到**第 75** 百分位数范围（**中位数**）。通过使用此方法，您可以获取有关数据特征的宝贵洞察，例如识别潜在的异常值并有效理解其分布模式。
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Head
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 头部
- en: 'Like the series object, the `[**head**](https://docs.rs/polars/latest/polars/frame/struct.DataFrame.html#method.head)`
    method lets us quickly preview the first few rows of a DataFrame object. This
    method saves time and effort as it eliminates the need for scrolling through numerous
    records, which can be tedious and overwhelming. When called upon, this function
    returns a new DataFrame containing n number of rows from the original dataset
    based on user-defined parameters. **By default, ten (10) rows** are displayed
    when `**None**` is passed into this method. Let’s consider the following example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与 series 对象类似，`[**head**](https://docs.rs/polars/latest/polars/frame/struct.DataFrame.html#method.head)`
    方法允许我们快速预览 DataFrame 对象的前几行。此方法节省时间和精力，因为它消除了滚动查看大量记录的需求，这可能会很繁琐和压倒性。当调用时，此函数根据用户定义的参数从原始数据集中返回包含
    n 行的新 DataFrame。当传入`**None**`时，默认显示十（10）行。让我们考虑以下示例：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By default, the `**head**` method displays **the first ten rows** but can be
    customized to show any number using its argument. For instance, `**df.head(Some(3))**`
    would return only the first three rows of data. This feature enables us to verify
    column names and content while providing an overview of what’s inside before diving
    deeper into the analysis.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`**head**` 方法显示**前十行**，但可以通过其参数自定义显示任意数量。例如，`**df.head(Some(3))**` 将仅返回数据的前三行。此功能使我们能够在深入分析之前验证列名和内容，并提供内容概述。
- en: Tail
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尾部
- en: Just like series, the `[**tail**](https://docs.rs/polars/latest/polars/frame/struct.DataFrame.html#method.tail)`
    function in Polars is a powerful method that lets you preview **the last few rows**
    of any DataFrame object. For instance, if your DataFrame contains information
    about employees, such as their names, ages, and heights; using this method will
    allow you to verify column data and structure quickly.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 series 一样，Polars 中的 `[**tail**](https://docs.rs/polars/latest/polars/frame/struct.DataFrame.html#method.tail)`
    函数是一个强大的方法，允许您预览任何 DataFrame 对象的**最后几行**。例如，如果您的 DataFrame 包含有关员工的信息，如姓名、年龄和身高；使用此方法可以快速验证列数据和结构。
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'By default, the `**tail**` method displays the last ten rows of your dataset,
    but it can be customized by specifying an argument for how many rows should be
    displayed instead. To illustrate further: `**df.tail(Some(3))**` would display
    only the last three rows from our example employees’ data frame.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`**tail**` 方法显示数据集的最后十行，但可以通过指定参数来自定义显示行数。为了进一步说明：`**df.tail(Some(3))**`
    将仅显示示例员工数据框的最后三行。
- en: In essence, utilizing `**tail**` on DataFrames helps save time when verifying
    contents or getting insights into its overall layout. It provides valuable information
    at a glance without having to go through every single row manually!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，使用`**tail**`对DataFrames进行操作有助于在验证内容或获取其整体布局时节省时间。它提供了一目了然的信息，而无需手动逐行查看！
- en: Indexing & Slicing
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 索引与切片
- en: 'Unlike series, a DataFrame object can be indexed using square brackets `**[]**`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与系列不同，DataFrame对象可以使用方括号`**[]**`进行索引：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, we have constructed a data frame that consists of four columns-
    “Name”, “Age”, “Gender” and “Salary”. We then showcased various techniques to
    index the data frame by using brackets. To extract a single column based on its
    name, we utilized `**df[‘Name’]**`. This method returns a Polars Series consisting
    of all values belonging to the specified column — in our case, it was the ‘Name’
    column. Employing such methods is highly beneficial when one requires specific
    information from their respective data frames.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们构建了一个包含四列的DataFrame——“Name”、“Age”、“Gender”和“Salary”。然后，我们展示了使用方括号对数据框进行索引的各种技术。为了根据名称提取单列，我们使用了`**df[‘Name’]**`。该方法返回一个包含指定列所有值的Polars
    Series——在我们的例子中是‘Name’列。采用这种方法在需要从数据框中提取特定信息时非常有用。
- en: 'Subsequently, through slicing with **df[..2]**, we chose only certain subsets
    of columns, which resulted in creating **another** **new** **DataFrame** containing
    **the first two columns solely**: namely `**Name**` and `**Age**`. Such quick
    yet efficient ways are ideal for selecting multiple desired attributes from any
    given data frame effortlessly. Likewise, we can select a subset of columns using
    the select method and, for example, calling `[**df.select([“Name”, “Age”])**](https://docs.rs/polars/latest/polars/prelude/struct.DataFrame.html#method.select)`will
    return only the ‘**Name**’ and ‘**Gender**’ columns.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，通过使用**df[..2]**进行切片，我们仅选择了某些列的子集，从而创建了**另一个** **新的** **DataFrame**，只包含**前两列**：即`**Name**`和`**Age**`。这种快速而高效的方法非常适合轻松选择数据框中的多个所需属性。同样，我们可以使用select方法选择列的子集，例如，调用`[**df.select([“Name”,
    “Age”])**](https://docs.rs/polars/latest/polars/prelude/struct.DataFrame.html#method.select)`将仅返回‘**Name**’和‘**Gender**’列。
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Alternatively, we can also use the `[**column**](https://docs.rs/polars/latest/polars/frame/struct.DataFrame.html#method.column)`
    method to retrieve a specific column, like so:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以使用`[**column**](https://docs.rs/polars/latest/polars/frame/struct.DataFrame.html#method.column)`方法来检索特定的列，如下所示：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can also select rows using **boolean indexing**, known as **masking**.
    Consider the following example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用**布尔索引**来选择行，这被称为**掩码**。考虑以下示例：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Additionally, the `[**slice**](https://docs.rs/polars/latest/polars/frame/struct.DataFrame.html#method.slice)`
    method allows us to select specific subsets of rows and columns from a data frame
    object. For instance, if we use **df.slice(2,3)**, three rows will be returned
    starting at index two (using zero-based indexing). Furthermore, this selection
    would include all columns resulting in an entirely new data frame consisting of
    three rows, if exists, by four columns.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`[**slice**](https://docs.rs/polars/latest/polars/frame/struct.DataFrame.html#method.slice)`方法允许我们从数据框对象中选择特定的行和列子集。例如，如果我们使用**df.slice(2,3)**，将从索引2开始返回三行（使用零基索引）。此外，此选择将包括所有列，从而产生一个完全由三行（如果存在）和四列组成的新数据框。
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: An alternative is utilizing the `[**transpose**](https://docs.rs/polars/latest/polars/prelude/struct.DataFrame.html#method.transpose)`
    function, which flips the rows and columns of the matrix. This allows us to access
    a single row as a series through indexing on its transpose form.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用`[**transpose**](https://docs.rs/polars/latest/polars/prelude/struct.DataFrame.html#method.transpose)`函数，该函数翻转矩阵的行和列。这使我们能够通过对其转置形式进行索引来访问单行作为系列。
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that this is a very expensive operation as mentioned in the docs.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如文档中所述，这是一项非常昂贵的操作。
- en: Data Cleaning
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据清理
- en: '![](../Images/406554a8f993a79109604500e3583878.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/406554a8f993a79109604500e3583878.png)'
- en: Photo by [Towfiqu barbhuiya](https://unsplash.com/@towfiqu999999?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 照片由 [Towfiqu barbhuiya](https://unsplash.com/@towfiqu999999?utm_source=medium&utm_medium=referral)
    提供，来自 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: The process of cleaning your data involves a critical step that entails detecting
    and resolving missing information. The presence of null values can significantly
    affect the precision when analyzing or making decisions based on this material.
    Fortunately, Rust’s Polars library provides numerous robust techniques for managing
    these gaps effectively.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 数据清理的过程涉及一个关键步骤，即检测和解决缺失信息。空值的存在会显著影响分析或决策的精确性。幸运的是，Rust 的 Polars 库提供了许多强大的技术来有效地管理这些空白。
- en: Nulls Count
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空值计数
- en: The process of counting the number of null or missing values in a given data
    frame is essential to create another data frame that displays the count of such
    occurrences per column. This data proves extremely useful as it enables fast identification
    of columns with missing information and quantifies how much data is missing. Based
    on this knowledge, we can make informed decisions about eliminating those rows
    containing incomplete entries or adopting imputation methods for filling up these
    values instead.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 计算给定数据帧中空值或缺失值的数量是创建另一个数据帧的重要步骤，该数据帧显示每列此类事件的计数。这些数据极其有用，因为它可以快速识别包含缺失信息的列，并量化缺失的数据量。基于这些信息，我们可以做出明智的决策，比如删除那些包含不完整条目的行，或采用插补方法来填补这些值。
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Duplicates
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重复项
- en: Utilizing this method can obtain a boolean mask that pinpoints all the replicated
    rows in your DataFrame. This particular mask serves as an effective tool to filter
    out these duplicates and get a new data frame with precision. To use the [**is_duplicated**](https://docs.rs/polars/latest/polars/frame/struct.DataFrame.html#method.is_duplicated)
    function, invoke it on your DataFrame and allocate the resulting mask to a new
    variable. Subsequently, apply this same filter to your original data frame to
    eliminate those replicas.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法可以获得一个布尔掩码，指明数据帧中所有的重复行。这个掩码作为一个有效工具，可以过滤掉这些重复项，并精准地得到一个新的数据帧。要使用 `[**is_duplicated**](https://docs.rs/polars/latest/polars/frame/struct.DataFrame.html#method.is_duplicated)`
    函数，在你的数据帧上调用它，并将结果掩码分配给一个新变量。随后，将相同的过滤器应用于你的原始数据帧，以消除这些副本。
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Unique Values
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 唯一值
- en: The `[**is_unique**](https://docs.rs/polars/latest/polars/frame/struct.DataFrame.html#method.is_unique)`
    method provides a way to determine if each row in your DataFrame contains unique
    values. This method enables you to obtain a mask of all the distinct rows present
    within your dataset, which can be especially advantageous when working with extensive
    data or conducting complex operations on it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`[**is_unique**](https://docs.rs/polars/latest/polars/frame/struct.DataFrame.html#method.is_unique)`
    方法提供了一种确定数据帧中每一行是否包含唯一值的方法。这个方法使你能够获得数据集中所有独特行的掩码，这在处理大量数据或进行复杂操作时尤为有利。'
- en: To apply this technique, just invoke the `**is_unique**` function on a **DataFrame**
    object. It will generate a boolean array that highlights those rows containing
    unique elements. You may then utilize this array as a filter mechanism for extracting
    only the unique rows from your original **DataFrame** efficiently.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用这个技术，只需在 **DataFrame** 对象上调用 `**is_unique**` 函数。它将生成一个布尔数组，突出显示那些包含唯一元素的行。然后，你可以利用这个数组作为过滤机制，高效地从原始
    **DataFrame** 中提取唯一行。
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Drop
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除
- en: Removing unnecessary information from a data frame or series is essential in
    data analysis. Luckily, Polars offers multiple ways to do so effectively. One
    such method involves using the `[**drop**](https://docs.rs/polars/latest/polars/frame/struct.DataFrame.html#method.drop)`
    function, which allows you to eliminate specific rows or columns.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据帧或序列中删除不必要的信息在数据分析中至关重要。幸运的是，Polars 提供了多种有效的方法来做到这一点。其中一种方法是使用 `[**drop**](https://docs.rs/polars/latest/polars/frame/struct.DataFrame.html#method.drop)`
    函数，该函数允许你删除特定的行或列。
- en: 'To use this method, specify the name/label of your target column as an argument
    for the `**drop**` method. It’s worth noting that by default, this function returns
    a new **DataFrame** object with only specified rows removed — leaving the original
    **DataFrame** intact. This can be especially helpful for beginners who may expect
    their initial dataset to change permanently after running specific functions.
    For instance, let’s take an example of a **Fruit** and **Color**-based **DataFrame**
    object where the column “**Color**” is no longer needed in further analyses:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此方法，请指定目标列的名称/标签作为`**drop**`方法的参数。值得注意的是，默认情况下，此函数返回一个新的**DataFrame**对象，其中仅删除了指定的行——原始**DataFrame**保持不变。这对于期望初始数据集在运行特定函数后永久改变的初学者特别有帮助。例如，考虑一个基于**Fruit**和**Color**的**DataFrame**对象，其中列“**Color**”在进一步分析中不再需要：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can use the `**drop**` function to remove the column with the label “**Color**”
    from this DataFrame:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`**drop**`函数从此数据框中删除标签为“**Color**”的列：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A new DataFrame object, **df_remain**, now holds identical data to the original
    except for the “**Color**” column. Upon inspection of the initial data frame,
    we can confirm its information remains unaltered.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个新的数据框对象**df_remain**持有与原始数据相同的数据，除了“**Color**”列。经过检查初始数据框，我们可以确认其信息保持不变。
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you wish to make changes directly to the original **DataFrame**, consider
    using the `[**drop_in_place**](https://docs.rs/polars/latest/polars/prelude/struct.DataFrame.html#method.drop_in_place)`
    function instead of `**drop**`. This method operates similarly to `**drop**`,
    but it alters the data frame without generating a new object.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望直接对原始**DataFrame**进行更改，考虑使用`[**drop_in_place**](https://docs.rs/polars/latest/polars/prelude/struct.DataFrame.html#method.drop_in_place)`函数，而不是`**drop**`。此方法的操作类似于`**drop**`，但它在不生成新对象的情况下修改数据框。
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In addition, you can also remove multiple columns by specifying their names
    as the arguments for the `[**drop_many**](https://docs.rs/polars/latest/polars/prelude/struct.DataFrame.html#method.drop_many)`
    function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还可以通过指定列名作为`[**drop_many**](https://docs.rs/polars/latest/polars/prelude/struct.DataFrame.html#method.drop_many)`函数的参数来删除多个列：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we can use the `[**drop_nulls**](https://docs.rs/polars/latest/polars/prelude/struct.DataFrame.html#method.drop_nulls)`
    function to remove any rows that contain null or missing values:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用`[**drop_nulls**](https://docs.rs/polars/latest/polars/prelude/struct.DataFrame.html#method.drop_nulls)`函数来删除包含空值或缺失值的任何行：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'By utilizing the `[**is_not_null**](https://docs.rs/polars/latest/polars/prelude/fn.is_not_null.html)`method,
    we can create a non-null mask for any column in our **DataFrame**. This method
    returns a boolean mask that distinguishes between values containing null and those
    without. Once applied to a specific column, this creates a filter where each value
    corresponds with its respective row’s status as either **null** or **not null**.
    By using this effective technique to extract only rows meeting certain criteria,
    we can remove all instances of missing data from our new DataFrame with ease.
    For example, to create a null mask for the “**Salary**” column of a **DataFrame**,
    we can use the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`[**is_not_null**](https://docs.rs/polars/latest/polars/prelude/fn.is_not_null.html)`方法，我们可以为**DataFrame**中的任何列创建一个非空掩码。此方法返回一个布尔掩码，用于区分包含空值和不包含空值的值。应用于特定列后，这会创建一个过滤器，其中每个值与其各自行的**null**或**not
    null**状态对应。通过使用这种有效的技术来提取仅符合特定标准的行，我们可以轻松地从新数据框中移除所有缺失数据。例如，要为**DataFrame**中的“**Salary**”列创建一个空值掩码，我们可以使用以下代码：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The code snippet creates an empty mask for the “**Salary**” column in the **df**
    **DataFrame** object. It also displays some initial values of the Boolean mask
    produced as output. This filter can be applied to extract data only from rows
    where there are non-null entries within the “**Salary**” column.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段为**df** **DataFrame**对象的“**Salary**”列创建了一个空的掩码。它还显示了布尔掩码生成的一些初始值。此过滤器可以应用于仅提取“**Salary**”列中存在非空条目的行的数据。
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Utilizing a null mask grants greater precision in managing the filtering process.
    This method proves beneficial when we aim to filter based on various conditions
    or combinations of null values across distinct columns. Nevertheless, it entails
    writing more code than simply using the `**drop_nulls**` function and may not
    be as efficient for large datasets.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用空值掩码可以在管理过滤过程时提供更高的精度。当我们希望基于不同列中的各种条件或空值组合进行过滤时，此方法尤其有用。然而，它需要编写比仅使用`**drop_nulls**`函数更多的代码，并且对于大型数据集可能不够高效。
- en: To summarize this section, dropping rows is a common and handy operation for
    removing rows or columns from a data frame in Polars. There are several options
    for modifying the original data or dropping null values.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 总结这一部分，丢弃行是从 Polars 数据框中删除行或列的常见且方便的操作。修改原始数据或删除空值有几种选项。
- en: Fill
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 填充
- en: 'Polars presents a valuable method for handling absent data — the `[**fill_null**](https://docs.rs/polars/latest/polars/prelude/struct.DataFrame.html#method.fill_null)`
    method. This function allows us to substitute null or missing values in a **DataFrame**
    or **Series** object with an assigned method or value. A frequent application
    of `**fill_null**` is replacing all bad entries within a **DataFrame** or **Series**
    with one single value. You can accomplish this by passing a scalar parameter into
    `**fill_null**`. For example, if you want to replace every missing entry in your
    DataFrame with previous values, simply use `**fill_null**` as demonstrated below:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Polars 提供了处理缺失数据的有价值的方法——`[**fill_null**](https://docs.rs/polars/latest/polars/prelude/struct.DataFrame.html#method.fill_null)`
    方法。此函数允许我们用指定的方法或值替代**DataFrame**或**Series**对象中的空值或缺失值。`**fill_null**`的一个常见应用是用一个单一的值替换**DataFrame**或**Series**中的所有坏项。你可以通过将标量参数传递给`**fill_null**`来实现。例如，如果你想用前面的值替换
    DataFrame 中的每个缺失项，只需使用如下所示的`**fill_null**`：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It’s essential to note that statistical functions typically ignore any missing
    values present within **DataFrame** by default when analyzing data. However, it
    is crucial to understand why these gaps exist because they may affect your analysis
    results significantly. Moreover, determining whether or not imputing/filling-in
    those absent entries would be appropriate depends on various factors like reasons
    behind their occurrence- intentional vs accidental errors during collection, etc.,
    and accuracy required for further processing tasks at hand, among others.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，统计函数在分析数据时通常会默认忽略**DataFrame**中的任何缺失值。然而，理解这些缺失的原因至关重要，因为它们可能会显著影响你的分析结果。此外，是否对这些缺失项进行填充或插补是否合适，取决于多种因素，如其出现的原因——故意的还是收集过程中的偶然错误等，以及进一步处理任务所需的准确性等。
- en: In essence, carefully considering all aspects surrounding missing data before
    deciding how best to approach handling them will ensure accurate analyses without
    compromising quality outcomes!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，在决定如何处理缺失数据之前，仔细考虑所有相关方面，将确保准确分析而不影响质量结果！
- en: Measures of central tendency
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集中趋势的度量
- en: Mean
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 均值
- en: Just like Series, we can compute the mean of each individual column in a given
    data frame.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Series 类似，我们可以计算给定数据框中每个单独列的均值。
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Median
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中位数
- en: We can also compute the median of each individual column in a given data frame.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以计算给定数据框中每个单独列的中位数。
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Measures of Spread
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 离散度量
- en: Std
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Std
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: var
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方差
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Ndarray
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ndarray
- en: You can convert a data frame to ndarray, as we saw in [**the first article**](https://wiseai.medium.com/rust-the-next-big-thing-in-data-science-319a03305883)of
    this series. This method creates a 2D `**ndarray::Array**` object from a **DataFrame**
    object. This requires all columns in the DataFrame to be non-null and numeric.
    They will be cast to the same data type (if they aren’t already). It will implicitly
    convert **None** to **NaN** without failure for floating point data.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[**第一篇文章**](https://wiseai.medium.com/rust-the-next-big-thing-in-data-science-319a03305883)中所见，你可以将数据框转换为
    ndarray。这种方法从**DataFrame**对象创建一个二维`**ndarray::Array**`对象。要求 DataFrame 中的所有列都不能为空且为数字类型。它们将被强制转换为相同的数据类型（如果尚未）。它会隐式地将**None**转换为**NaN**，对于浮点数据不会失败。
- en: '[PRE28]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, you can apply different operations on this array discussed in a previous
    article titled: [The Ultimate Ndarray Handbook: Mastering the Art of Scientific
    Computing with Rust](/the-ultimate-ndarray-handbook-mastering-the-art-of-scientific-computing-with-rust-ef5ab767212a).'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以对这个数组应用在上一篇文章中讨论的不同操作，标题为：[**终极 Ndarray 手册：掌握 Rust 科学计算的艺术**](/the-ultimate-ndarray-handbook-mastering-the-art-of-scientific-computing-with-rust-ef5ab767212a)。
- en: Aggregation Functions
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聚合函数
- en: '![](../Images/2b919c5d4ef5da4f0a51f0cc20e9c348.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2b919c5d4ef5da4f0a51f0cc20e9c348.png)'
- en: Photo by [Nicolas COMTE](https://unsplash.com/@rotor_?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[Nicolas COMTE](https://unsplash.com/@rotor_?utm_source=medium&utm_medium=referral)
    拍摄的照片，来源于 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)。'
- en: When working with large amounts of data, it’s crucial to categorize and comprehend
    aggregated data on a group level. Fortunately, Polars provides an excellent solution
    through its `[**groupby**](https://docs.rs/polars/latest/polars/prelude/struct.DataFrame.html#method.groupby)`
    function. This method splits the data frame into chunks based on specific key
    values before applying computations and combining results back together in another
    data frame — known as a [**split-apply-combine**](https://www.jstatsoft.org/article/view/v040i01)
    pattern.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理大量数据时，分类和理解分组数据是至关重要的。幸运的是，Polars 通过其 `[**groupby**](https://docs.rs/polars/latest/polars/prelude/struct.DataFrame.html#method.groupby)`
    函数提供了一个出色的解决方案。该方法根据特定的键值将数据框拆分成多个块，然后应用计算，并将结果合并回另一个数据框中，这种模式被称为 [**split-apply-combine**](https://www.jstatsoft.org/article/view/v040i01)。
- en: 'With aggregation functions in place, we can perform various operations such
    as **count**, **sum**, or **mean** within these groups quickly; this significantly
    speeds up computation time when dealing with massive datasets efficiently. Other
    common examples of aggregation functions include **variance**, and **std**. Here
    are a few examples of the use of `**.groupby**`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用聚合函数，我们可以在这些组内快速执行**count**、**sum**或**mean**等各种操作；这在处理大型数据集时显著提高了计算速度和效率。其他常见的聚合函数包括**variance**和**std**。以下是`**.groupby**`使用的一些示例：
- en: A retail company uses the `**groupby**` method to analyze sales data by region
    and product category. This analysis enables them to determine which products are
    selling well in which regions and make more informed decisions regarding inventory
    management and product promotions.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一家零售公司使用`**groupby**`方法按地区和产品类别分析销售数据。这种分析使他们能够确定哪些产品在哪些地区销售良好，并就库存管理和产品促销做出更明智的决策。
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Utilising the `**groupby**` method, a healthcare organization can analyze patient
    data based on age group and medical condition.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用`**groupby**`方法，医疗组织可以根据年龄组和病情分析患者数据。
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: A transportation enterprise can utilize the `**groupby**` technique to analyze
    their vehicle’s fuel usage based on driver and vehicle category. This analysis
    empowers them to pinpoint inefficiencies in gas consumption, allowing for prompt
    corrective actions that enhance fuel efficiency.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运输企业可以利用`**groupby**`技术，根据司机和车辆类别分析其车辆的燃油使用情况。这种分析使他们能够发现燃油消耗中的低效环节，从而采取及时的纠正措施，提高燃油效率。
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: By utilizing the `**groupby**` method, an insurance company can effectively
    analyse claims data based on policy type and customer demographics. This analysis
    enables them to pinpoint high-risk customers while crafting policies that cater
    to their individual requirements.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过利用`**groupby**`方法，保险公司可以有效地分析基于保单类型和客户人口统计数据的索赔数据。这种分析使他们能够识别高风险客户，同时制定符合其个人需求的保单。
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In summary, the `**.groupby**` method is a powerful tool for data analysis that
    allows you to group your data in any way imaginable and apply any type of function
    independently to each group before returning a single dataset.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，`**.groupby**`方法是一个强大的数据分析工具，允许您以任何想象得到的方式对数据进行分组，并对每个组独立应用任何类型的函数，然后返回单一的数据集。
- en: Aggregation Example
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聚合示例
- en: '![](../Images/645783e9fe9a381fdaf1ab40cb839e39.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/645783e9fe9a381fdaf1ab40cb839e39.png)'
- en: Photo by [Alexander Schimmeck](https://unsplash.com/@alschim?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 照片由 [Alexander Schimmeck](https://unsplash.com/@alschim?utm_source=medium&utm_medium=referral)
    提供，拍摄于 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: Let us delve into a[**flights dataset**](https://www.kaggle.com/datasets/deepak007chaubey/flight-on-time-dataset?select=Flight_on_time_HIX.csv)
    hosted on Kaggle and carry out a basic aggregation that involves just one grouping
    column, one aggregating column, and an individual aggregating function. Our aim
    is to determine the average arrival delay for each airline. Polars offers various
    syntaxes for creating such an aggregation, which we will explore in this section.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入研究一个在 Kaggle 上托管的 [**flights dataset**](https://www.kaggle.com/datasets/deepak007chaubey/flight-on-time-dataset?select=Flight_on_time_HIX.csv)，并进行一个基本的聚合操作，涉及一个分组列、一个聚合列和一个单独的聚合函数。我们的目标是确定每家航空公司的平均到达延误时间。Polars
    提供了多种语法来创建这样的聚合，我们将在本节中探讨。
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: To effectively group data in a DataFrame, it is important to define the grouping
    columns such as `**Airline**`, and choose an aggregating function like the `**mean**`
    for `**Arrival_Delay_Minutes**` column. Once this is done, simply place the grouping
    column within `**groupby**` method and select your desired display column before
    applying an aggregation function to it. This will generate a new DataFrame.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地在 DataFrame 中对数据进行分组，重要的是定义分组列，如 `**Airline**`，并选择像 `**mean**` 这样的聚合函数来处理
    `**Arrival_Delay_Minutes**` 列。一旦完成这些操作，只需将分组列放在 `**groupby**` 方法中，并选择你想要显示的列，然后对其应用聚合函数。这将生成一个新的
    DataFrame。
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'With multiple columns, **grouping** and **aggregating** are achievable. However,
    the syntax varies from that of a single-column operation. To ensure smooth execution
    during any type of group function process, it’s important to identify three key
    components: aggregation functions, grouping columns, and aggregated columns. For
    instance; in this example, we are calculating **Airline-wise** average departure
    delay per **Origin Airport**.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通过多个列，可以实现 **分组** 和 **聚合**。然而，语法与单列操作有所不同。为了确保在任何类型的分组函数过程中顺利执行，重要的是识别三个关键组件：聚合函数、分组列和聚合列。例如；在这个例子中，我们正在计算
    **按航空公司** 统计的每个 **起始机场** 的平均出发延迟。
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If you are familiar with Python pandas, then the use of `**groupby**` will result
    in a [**MultiIndex**](https://pandas.pydata.org/docs/reference/api/pandas.MultiIndex.html#pandas.MultiIndex)object.
    The occurrence of **MultiIndexes** can be found both within the index and columns
    themselves. However, **Polars** eliminates this issue altogether by not requiring
    any such operations from developers, making it an advantageous alternative over
    Pandas for data handling purposes.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 Python pandas，那么使用 `**groupby**` 会导致一个 [**MultiIndex**](https://pandas.pydata.org/docs/reference/api/pandas.MultiIndex.html#pandas.MultiIndex)
    对象。**MultiIndexes** 的出现可以在索引和列中找到。然而，**Polars** 通过不要求开发者进行此类操作，完全消除了这一问题，使其成为数据处理方面比
    Pandas 更具优势的替代方案。
- en: Merging DataFrames
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并 DataFrames
- en: '![](../Images/9bb2f0879cd6130877721f8c0c3ccc0e.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9bb2f0879cd6130877721f8c0c3ccc0e.png)'
- en: Different Polars join methods (Image by author)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的 Polars 连接方法（图像作者提供）
- en: Polars offers an array of data manipulation tools for executing tasks like merging
    datasets. One such tool is the join method which facilitates joining different
    DataFrame objects. To execute this operation, you need to call upon the [**join**](https://docs.rs/polars/latest/polars/prelude/trait.DataFrameJoinOps.html#method.join)
    function on any one of the DataFrames and specify other parameters along with
    it. To better understand how this works in practice, consider the following code
    example.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Polars 提供了一系列数据操作工具，用于执行诸如合并数据集之类的任务。其中一个工具是 join 方法，它便于连接不同的 DataFrame 对象。要执行此操作，你需要在任意一个
    DataFrame 上调用 [**join**](https://docs.rs/polars/latest/polars/prelude/trait.DataFrameJoinOps.html#method.join)
    函数，并指定其他参数。为了更好地理解其实际操作，考虑以下代码示例。
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When performing a merge operation, the `**how**` parameter plays an important
    role in determining what type of merging will take place. You have several options
    to choose from including inner, left, right and outer joins.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行合并操作时，`**how**` 参数在决定将进行何种类型的合并中起着重要作用。你有几种选项可供选择，包括内连接、左连接、右连接和外连接。
- en: To determine the exact variables that will serve as join keys for each DataFrame,
    utilize the `**left_on**` and `**right_on**` parameters accordingly. These specific
    values facilitate linking corresponding rows from both DataFrames with ease.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定将作为每个 DataFrame 连接键的确切变量，按需使用 `**left_on**` 和 `**right_on**` 参数。这些具体值使得将两个
    DataFrame 中的对应行轻松连接起来。
- en: If there is another data frame that needs to be merged with your first one then
    simply use the `**other**` parameter to indicate this second dataset. This new
    information can either be added on top of your existing data set or appended onto
    it depending on how you want things organized!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有另一个数据框需要与第一个数据框合并，只需使用 `**other**` 参数来指示这个第二个数据集。根据你希望如何组织数据，这些新信息可以被添加到现有数据集的顶部或追加到其上！
- en: 'Finally, if two columns share identical names within separate datasets being
    merged together then using suffixes can differentiate them easily by appending
    unique strings at the end of their respective column titles. Here is an exmaple
    on how to use the `**join**` function:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果两个列在被合并的不同数据集中具有相同的名称，那么使用后缀可以通过在各自列标题的末尾附加唯一字符串来轻松区分它们。以下是如何使用 `**join**`
    函数的示例：
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When merging DataFrames in Polars, it’s important to understand the different
    types of joins available. **Inner joins** only keep rows that are **common** between
    both DataFrames while **left** and **right** joins retain **all** rows from one
    DataFrame and add relevant data from the other based on matching values.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Polars 中合并 DataFrames 时，了解不同类型的连接是很重要的。**内连接** 仅保留两个 DataFrames 中 **共同** 的行，而
    **左连接** 和 **右连接** 则保留一个 DataFrame 中的 **所有** 行，并根据匹配的值从另一个 DataFrame 添加相关数据。
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If there is no corresponding data for a row in either DataFrame, null or missing
    values will be filled accordingly. Right join works similarly but retains all
    rows from the right DataFrame instead.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个 DataFrame 中的行没有对应的数据，则会相应地填充空值或缺失值。右连接的工作方式类似，但保留的是右侧 DataFrame 中的所有行。
- en: Merging DataFrames can greatly enhance your ability to analyze data effectively
    with Polars’ convenient **join** method.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 合并 DataFrames 可以极大地提高你用 Polars 的 **join** 方法有效分析数据的能力。
- en: Conclusion
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: '![](../Images/baa60e628868134899f091005f89931b.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/baa60e628868134899f091005f89931b.png)'
- en: Photo by [Adeolu Eletu](https://unsplash.com/@adeolueletu?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由 [Adeolu Eletu](https://unsplash.com/@adeolueletu?utm_source=medium&utm_medium=referral)
    提供，发布于 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: This article has familiarized you with a fundamental data structure in Polars
    —**DataFrame**. Additionally, we have explored basic concepts of querying, modifying,
    and joining data frames in Polars. As a result, this should give you confidence
    when working with DataFrames going forward. It will be an integral component throughout
    the rest of this series of articles.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 本文让你熟悉了 Polars 中的一个基础数据结构 —— **DataFrame**。此外，我们还探讨了 Polars 中查询、修改和连接数据框的基本概念。因此，这应该能让你在处理
    DataFrames 时更有信心。它将成为本系列文章中一个重要的组成部分。
- en: 'Throughout this article, we have covered the following topics:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们讨论了以下主题：
- en: Polars’s DataFrame object.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Polars 的 DataFrame 对象。
- en: Exploring different aggregation functions available in Polars.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Polars 中不同的聚合函数。
- en: How to merge DataFrames in Polars and how it is different from Pandas.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Polars 中合并 DataFrames 以及这与 Pandas 有何不同。
- en: And much more. As we progress through the upcoming articles, your knowledge
    of Polars will expand to encompass more advanced features and techniques. By mastering
    this library, you’ll gain rock-solid and valuable skills that empower you to easily
    tackle complex data analysis tasks while handling massive datasets effortlessly.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多。在接下来的文章中，你对 Polars 的知识将扩展到更高级的功能和技巧。通过掌握这个库，你将获得坚实而有价值的技能，使你能够轻松处理复杂的数据分析任务，同时轻松处理大量数据集。
- en: Closing Note
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结束语
- en: '![](../Images/c732ae653e11e63222cc5fd9bc49b0e4.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c732ae653e11e63222cc5fd9bc49b0e4.png)'
- en: Photo by [Aaron Burden](https://unsplash.com/@aaronburden?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由 [Aaron Burden](https://unsplash.com/@aaronburden?utm_source=medium&utm_medium=referral)
    提供，发布于 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: As we conclude this tutorial, I would like to express my sincere appreciation
    to all those who have dedicated their time and energy to completing it. It has
    been an absolute pleasure to demonstrate the extraordinary capabilities of Rust
    programming language with you.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们结束本教程时，我想向所有投入时间和精力完成它的人员表示诚挚的感谢。与您一起展示 Rust 编程语言的非凡能力，真是我的荣幸。
- en: As always, being passionate about data science, I promise you that I will keep
    writing at least one comprehensive article every week or so on related topics
    from now on. If staying updated with my work interests you, consider connecting
    with me on various social media platforms or reach out directly if anything else
    needs assistance.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，作为对数据科学充满热情的我，承诺从现在开始，每周至少会撰写一篇关于相关主题的综合文章。如果你对我工作的最新动态感兴趣，可以考虑在各种社交媒体平台上与我联系，或者直接联系我，如果有其他需要帮助的地方。
- en: Thank You!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢！
- en: Resources
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源
- en: '[](https://github.com/wiseaidev/rust-data-analysis?source=post_page-----7c58a3cb7a1f--------------------------------)
    [## GitHub - wiseaidev/rust-data-analysis: The ultimate data analysis with Rust
    course.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://github.com/wiseaidev/rust-data-analysis?source=post_page-----7c58a3cb7a1f--------------------------------)
    [## GitHub - wiseaidev/rust-data-analysis: 终极 Rust 数据分析课程]'
- en: This repository is a collection of Jupyter notebooks, all powered by a Rust
    kernel. With these notebooks, you'll be…
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 这个代码库包含了一系列 Jupyter 笔记本，所有笔记本都由 Rust 内核驱动。通过这些笔记本，你将会...
- en: github.com](https://github.com/wiseaidev/rust-data-analysis?source=post_page-----7c58a3cb7a1f--------------------------------)  [##
    DataFrame in polars::prelude - Rust
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[github.com](https://github.com/wiseaidev/rust-data-analysis?source=post_page-----7c58a3cb7a1f--------------------------------)
    [## polars::prelude 中的DataFrame - Rust'
- en: A contiguous growable collection of `Series` that have the same length.
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一组长度相同的`Series`的连续可增长集合。
- en: docs.rs](https://docs.rs/polars/latest/polars/prelude/struct.DataFrame.html?source=post_page-----7c58a3cb7a1f--------------------------------)  [##
    Rust By Example
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[docs.rs](https://docs.rs/polars/latest/polars/prelude/struct.DataFrame.html?source=post_page-----7c58a3cb7a1f--------------------------------)
    [## Rust By Example'
- en: Rust is a modern systems programming language focusing on safety, speed, and
    concurrency. It accomplishes these goals…
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Rust是一种现代系统编程语言，专注于安全性、速度和并发性。它实现这些目标的方式…
- en: doc.rust-lang.org](https://doc.rust-lang.org/rust-by-example/?source=post_page-----7c58a3cb7a1f--------------------------------)  [##
    The Rust Programming Language
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[文档](https://doc.rust-lang.org/rust-by-example/?source=post_page-----7c58a3cb7a1f--------------------------------)
    [## Rust编程语言'
- en: by Steve Klabnik and Carol Nichols, with contributions from the Rust Community
    This version of the text assumes you're…
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 由Steve Klabnik和Carol Nichols编写，Rust社区贡献者参与。本版本的文本假设您…
- en: doc.rust-lang.org](https://doc.rust-lang.org/book/?source=post_page-----7c58a3cb7a1f--------------------------------)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[文档](https://doc.rust-lang.org/book/?source=post_page-----7c58a3cb7a1f--------------------------------)'
