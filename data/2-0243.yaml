- en: A Tableau Calculus for the Analysis of Experiments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验分析的表格微积分
- en: 原文：[https://towardsdatascience.com/a-tableau-calculus-for-the-analysis-of-experiments-53655dd04eb8](https://towardsdatascience.com/a-tableau-calculus-for-the-analysis-of-experiments-53655dd04eb8)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/a-tableau-calculus-for-the-analysis-of-experiments-53655dd04eb8](https://towardsdatascience.com/a-tableau-calculus-for-the-analysis-of-experiments-53655dd04eb8)
- en: Unravelling the Fundamental Data Structure of Experimental Analysis
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解开实验分析的基本数据结构
- en: '[](https://dataneversleeps.medium.com/?source=post_page-----53655dd04eb8--------------------------------)[![Jared
    M. Maruskin, PhD](../Images/771dcac046565d4760077afecb3fadef.png)](https://dataneversleeps.medium.com/?source=post_page-----53655dd04eb8--------------------------------)[](https://towardsdatascience.com/?source=post_page-----53655dd04eb8--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----53655dd04eb8--------------------------------)
    [Jared M. Maruskin, PhD](https://dataneversleeps.medium.com/?source=post_page-----53655dd04eb8--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://dataneversleeps.medium.com/?source=post_page-----53655dd04eb8--------------------------------)[![Jared
    M. Maruskin, PhD](../Images/771dcac046565d4760077afecb3fadef.png)](https://dataneversleeps.medium.com/?source=post_page-----53655dd04eb8--------------------------------)[](https://towardsdatascience.com/?source=post_page-----53655dd04eb8--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----53655dd04eb8--------------------------------)
    [Jared M. Maruskin, PhD](https://dataneversleeps.medium.com/?source=post_page-----53655dd04eb8--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----53655dd04eb8--------------------------------)
    ·21 min read·Oct 3, 2023
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·发布在[Towards Data Science](https://towardsdatascience.com/?source=post_page-----53655dd04eb8--------------------------------)
    ·21 min read·2023年10月3日
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/b26caa5a37392803d3b6c958678d500a.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b26caa5a37392803d3b6c958678d500a.png)'
- en: Photo by [Markus Spiske](https://unsplash.com/@markusspiske?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 照片由[Markus Spiske](https://unsplash.com/@markusspiske?utm_source=medium&utm_medium=referral)拍摄，发布在[Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: Experimental analysis often involves analyzing groups containing varying numbers
    of elements; for example, a different number of units for each treatment assignment
    within each stratum. We therefore encounter objects that are *like matrices*,
    except they are not perfect rectangular blocks; i.e., they are not always “filled.”
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 实验分析通常涉及分析包含不同数量元素的组；例如，每个层次中的每种处理分配的单位数量不同。因此，我们遇到的对象*类似于矩阵*，但它们不是完美的矩形块；即，它们并不总是“填满”。
- en: 'In this note, we define a new structure, called a *tableau*, which can be regarded
    as a partially filled matrix, and seek to formalize the operations on tableaus
    that are used in the analysis of experiment. We then show how *tableau notation*
    can be used to express the key equations in a variety of statistical contexts,
    including stratification, clustering, and the sum-of-squares decomposition. Moreover,
    we express these equations in both an *invariant* and *index* form:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇笔记中，我们定义了一种新的结构，称为*表格*，它可以被视为部分填充的矩阵，并寻求形式化在实验分析中使用的表格操作。我们然后展示了如何在各种统计背景中使用*表格符号*来表达关键方程，包括分层、聚类和平方和分解。此外，我们将这些方程以*不变*和*索引*形式表达：
- en: '*invariant notation (coordinate-free form)* — defined in terms of *objects*
    and *operators*, much like the matrix-vector product A⋅x, and'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*不变符号（无坐标形式）* — 以*对象*和*运算符*的形式定义，就像矩阵-向量积A⋅x一样，'
- en: '*index notation (coordinate form)* — defined explicitly in terms of indexed
    arrays and summation of multiple indices, much like expressing the matrix-vector
    product as *∑ⱼAᵢⱼ xⱼ.*'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*索引符号（坐标形式）* — 明确以索引数组和多重索引的求和形式定义，就像将矩阵-向量积表示为*∑ⱼAᵢⱼ xⱼ*一样。'
- en: Outline
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大纲
- en: 'This post consists of four main sections:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本文由四个主要部分组成：
- en: Review of classic notation, the pros and cons;
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 经典符号的回顾，优缺点；
- en: Theoretical development of the Tableau Calculus;
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表格微积分的理论发展；
- en: Application to Experiments (completely randomized, block-randomized, adjustment
    formula, cluster-randomized, block-cluster, and ANOVA sum of squares decomposition);
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实验的应用（完全随机化、块随机化、调整公式、集群随机化、块集群和ANOVA平方和分解）；
- en: Python implementation
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python实现
- en: 'Classic Notation: Pros and Cons'
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 经典符号：优缺点
- en: 'In experimental analysis, there are three main styles of notation that are
    commonly used:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在实验分析中，常用的符号风格有三种：
- en: '*classic notation —* treatment assignment is explicitly enumerated: unit *(ijk)*
    describes the *k*th unit in the *j*th stratum of the *i*th treatment group (see
    [1], [2], and [5]);'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*经典记号* — 处理分配被明确列出：单元*(ijk)*描述了第*i*个处理组第*j*层中的第*k*个单元（见 [1]，[2] 和 [5]）；'
- en: '*assignment notation* — the assignment mechanism is treated as an independent
    variable, and we consider sums over quantities like *ZᵢYᵢ* or *Zᵢⱼ Yᵢⱼ* (see [2],
    [3], and [4]); and'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*分配记号* — 分配机制被视为一个独立变量，我们考虑对 *ZᵢYᵢ* 或 *Zᵢⱼ Yᵢⱼ* 等量的求和（见 [2]，[3] 和 [4]）；和'
- en: '*set notation* — explicit variables referring to treatment and control sets;
    *Yᵗ* and *Yᶜ*, or *Y⁺ⱼ* for the aggregate sums of the *j*th cluster, and then
    *Y⁺ₜ and Y⁺_c* for the set of aggregate sums for treatment and control clusters,
    etc. (see [5]).'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*集合记号* — 显式变量指代处理和对照集合；*Yᵗ* 和 *Yᶜ*，或者 *Y⁺ⱼ* 用于第 *j* 个簇的总和，然后 *Y⁺ₜ* 和 *Y⁺_c*
    用于处理和对照簇的总和集合，等等（见 [5]）。'
- en: Classic notation allows one to express formula in the most compact manner, as
    treatment assignment is directly indexed in the response array, which is useful
    in describing stratification, multi-level experiments, and ANOVA. However, this
    notation is philosophically unsettling as the enumeration of units directly depends
    on the treatment assignment.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 经典记号允许以最紧凑的方式表达公式，因为处理分配在响应数组中直接索引，这在描述分层、多层实验和方差分析中非常有用。然而，这种记号在哲学上令人不安，因为单元的列举直接依赖于处理分配。
- en: Assignment notation, on the other hand, enumerates units without regard to treatment
    assignment, but requires an auxiliary assignment mechanism *Z* and a doubling
    of the number of multi-summations, with one set of sums containing a factor *Z*
    and the other a factor *(1-Z)*. This has the shortcoming that it is not amenable
    to multi-level design.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，分配记号列举了单元而不考虑处理分配，但需要一个辅助的分配机制 *Z* 和双倍的多重求和，其中一组求和包含因子 *Z*，另一组则包含因子 *(1-Z)*。这一点的不足之处在于不适用于多层次设计。
- en: 'Finally, set notation simplifies things a great deal, but requires special
    definitions for every different set: in clustering, *Y⁺ⱼ* is the aggregate sum
    for the *j*th cluster, and *Y⁺ₜ={Y⁺ⱼ : zⱼ=1}*, but these are not used in block
    design, etc; i.e., we have to keep defining different notation to refer to different
    groups, subgroups, or sums of a single fundamental underlying object.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，集合记号大大简化了问题，但需要为每个不同的集合提供特殊定义：在聚类中，*Y⁺ⱼ* 是第 *j* 个簇的总和，*Y⁺ₜ={Y⁺ⱼ : zⱼ=1}*，但这些在区组设计中未使用；即我们必须不断定义不同的记号来指代不同的组、子组或单一基本对象的总和。'
- en: 'Tableau notation seeks the best of each world: its basic worldview is consistent
    with assignment notation, but we define a structure called a tableau and a set
    of operations that allows one to write equations in an invariant form, which can
    be understood across contexts without having to define specific sets each time.
    Moreover, we take the novel interpretation of the assignment mechanism as a *mask*,
    such that we may consider the *subtableaus* consisting of treatment and control
    assignments, and then apply our basic operations on these subtableaus to express
    key statistical formula.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Tableau 记号力求兼具各方面优点：其基本世界观与分配记号一致，但我们定义了一种称为 tableau 的结构以及一组操作，这使得可以以不变的形式书写方程，这样可以在不同背景下理解而无需每次定义特定集合。此外，我们将分配机制的全新解释视为*掩码*，从而可以考虑包含处理和对照分配的*子表格*，然后在这些子表格上应用基本操作以表达关键统计公式。
- en: Tableau Notation
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tableau 记号
- en: 'Getting Started: Tableaus, Shapes, and Index Spaces'
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入门：表格、形状和索引空间
- en: Recall that an *l*-dimensional matrix is a rectangular array structure specified
    by its side lengths *(n₁, …, nₗ).* Its *n₁…nₗ* components are indexed by an index
    space
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，*l* 维矩阵是由其边长*(n₁, …, nₗ)*指定的矩形数组结构。其 *n₁…nₗ* 组件由一个索引空间索引。
- en: An *l*-dimensional *tableau* *T* is an *l*-dimensional array indexed by values
    in a bounded set *I ⊂ ℤˡ₊* of positive integer arrays called the index space.
    So a tableau is just a partially filled matrix.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *l* 维 *tableau* *T* 是一个由正整数数组的有限集合 *I ⊂ ℤˡ₊* 中的值索引的 *l* 维数组。所以 tableau 只是一个部分填充的矩阵。
- en: We say that a tableau *T* is in *standard form* if each index ranges from 1
    to some terminal integer (without skipping) and if the range of index *iₖ* depends
    only on the values of the *(k-1)* preceding indices. An *l*-dimensional tableau
    in standard form may be described by its *shape ηˡ*, which is itself an *(l-1)*-dimensional
    standard tableau, defined such that *ι=(i₁,…,iₗ)∈I* if and only if *(i₁,…,iₗ₋₁)∈I(ηˡ)*
    and *iₗ ∈ {1,…, ηˡ_{i₁,…,iₗ₋₁}}*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说一个表格 *T* 是 *标准形式* 如果每个索引的范围从 1 到某个终端整数（没有跳过），并且索引 *iₖ* 的范围仅依赖于 *（k-1）* 个前面的索引的值。一个
    *l*-维标准形式的表格可以由其 *形状 ηˡ* 描述，*ηˡ* 本身是一个 *(l-1)*-维标准表格，定义为当且仅当 *ι=(i₁,…,iₗ)∈I* 当且仅当
    *(i₁,…,iₗ₋₁)∈I(ηˡ)* 且 *iₗ ∈ {1,…, ηˡ_{i₁,…,iₗ₋₁}}*。
- en: Alternatively, the shape is given by a sequence of tableaus *⟨η¹,…,ηˡ⟩*, such
    that *ηᵏ* is a *(k-1)*-dimensional tableau defined inductively as the shape of
    *ηᵏ⁺¹*, for *k=(l-1),…,1*. The tableau *ηᵏ* thus determines the range of the index
    *iₖ*, as it depends on the preceding indices. This defines the index space inductively
    by the relations *i₁∈{1,…η¹}* and
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，形状由一系列表格 *⟨η¹,…,ηˡ⟩* 给出，其中 *ηᵏ* 是一个 *(k-1)*-维表格，通过递归地定义为 *ηᵏ⁺¹* 的形状，适用于 *k=(l-1),…,1*。因此，表格
    *ηᵏ* 确定了索引 *iₖ* 的范围，因为它依赖于前面的索引。这通过关系 *i₁∈{1,…η¹}* 递归地定义了索引空间。
- en: for *k=2, …, l*. Notice how the range of each index may depend on the values
    of the preceding indices.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *k=2, …, l*。注意每个索引的范围可能依赖于前面的索引的值。
- en: In experimentation, we always *start* in standard form; i.e., the standard form
    is the enumeration of the experimental units within clusters, strata, etc. Our
    definition of tableau is, however, more general, to accommodate other structures
    we will encounter in a bit (namely, *masked tableaus*, which, in the context of
    experimentation, are the subset of components assigned to treatment or control;
    more on this later).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在实验中，我们总是 *从标准形式开始*；即，标准形式是对集群、层次等中的实验单元的枚举。然而，我们的表格定义更为一般，以适应我们稍后将遇到的其他结构（即
    *掩蔽表格*，在实验的背景下，它们是分配给处理或对照的组件的子集；更多内容稍后介绍）。
- en: '**Example 1\.** As a simple example, consider a 3-dimensional tableau *T*,
    with shape *η³* as shown below.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例 1\.** 作为一个简单的例子，考虑一个形状为 *η³* 的三维表格 *T*，如下所示。'
- en: '![](../Images/502b5e5f593bcaa06d553475ccafd9bf.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/502b5e5f593bcaa06d553475ccafd9bf.png)'
- en: Table 1\. The shape η³ of a 3-dimensional tableau T; Image by the Author.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1\. 三维表格 T 的形状 η³；图像由作者提供。
- en: Here, *η¹=5*, and *η²=⟨ 5, 2, 3, 2, 4 ⟩* represents the number of elements in
    each row. For example, when *i=3* and *j=2*, the component *k* would range *k=1,…,
    22*, and so forth.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*η¹=5*，而 *η²=⟨ 5, 2, 3, 2, 4 ⟩* 表示每行中的元素数量。例如，当 *i=3* 和 *j=2* 时，组件 *k* 的范围是
    *k=1,…, 22*，依此类推。
- en: p-Cells; Outer and Inner Index Spaces
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: p-单元格；外部和内部索引空间
- en: For any *p=1, …, l*, a *p*-cell of a tableau *T* is a subtableau consisting
    of all units that share the first *p* components; i.e., an individual *p*-cell
    is specified by *ιₚ = (i₁, …, iₚ)*, which we shall denote *T_[i₁, …, iₚ]*. In
    the context of experimentation, the *cells*, without reference to a *p*, are typically
    assumed to be the *penultimate cells* with *p=l-1*. A *p*-cell is a *q*-dimensional
    tableau, with *q=l-p*, indexed over the space
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何 *p=1, …, l*，一个表格 *T* 的 *p*-单元格是一个子表格，包含所有共享前 *p* 个组件的单元；即，单个 *p*-单元格由 *ιₚ
    = (i₁, …, iₚ)* 指定，我们称之为 *T_[i₁, …, iₚ]*。在实验的背景下，*cells*，不参考 *p*，通常被假定为 *倒数第二单元格*，其中
    *p=l-1*。一个 *p*-单元格是一个 *q*-维表格，*q=l-p*，在空间上进行索引。
- en: which we refer to as the *outer index space* at *ιₚ*. The set of all *p*-cells
    is indexed by the *inner index space*
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其称为 *外部索引空间* 在 *ιₚ*。所有 *p*-单元格的集合由 *内部索引空间* 进行索引。
- en: where *Πₚ* is the projection operator. In this way, for any *p*, we may *loosely*
    think of the index space as the *bundle structure*
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *Πₚ* 是投影算子。这样，对于任何 *p*，我们可以 *loosely* 将索引空间看作 *bundle structure*
- en: 'where the fibers *I_[ιₚ]* vary based on the location *ιₚ* of the base. (*Note:
    I use the word* loosely*, as the fibers, though of the same dimension, are in
    general of different shape as we vary location in the base space, which is why
    they depend on ιₚ*.)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *I_[ιₚ]* 的纤维根据基点 *ιₚ* 的位置而变化。(*注意：我使用这个词* loosely*，因为这些纤维虽然维度相同，但在基空间中位置变化时形状通常不同，这就是它们依赖于
    ιₚ* 的原因。)
- en: In continuing the example from the previous section, the cell at *(3,2)* would
    consist of the (unseen) 1-dimensional array of 22 components, whereas the cell
    at *(3,1)* would only contain 10 components. The inner space *I₂* would consist
    of the 16 permutations of *(ij)* defined in the the shape tableau shown in the
    table.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续前一节的例子时，*(3,2)* 处的单元将包含未显示的 22 个组件的一维数组，而 *(3,1)* 处的单元仅包含 10 个组件。内部空间 *I₂*
    包含表中显示的 *(ij)* 的 16 种排列。
- en: 'Similarly, the 1-cell at *i=4* would consist of the 2-dimensional tableau indexed
    by the outer space at *i=4* given by {*1}* × *{1,…,5} ∪ {2} × {1,…,15}*. The inner
    space *I₁* is just the enumeration of the rows: *I₁={1,2,3,4,5}*.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，*i=4* 处的 1-单元将是一个 2-维表，由外部空间 *i=4* 索引，给出 {*1}* × *{1,…,5} ∪ {2} × {1,…,15}*。内部空间
    *I₁* 只是行的枚举：*I₁={1,2,3,4,5}*。
- en: Total and Partial Sums
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总和与部分和
- en: The *total sum* of a tableau *T*, denoted *T*∘, is the sum of all its components.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一个表 *T* 的 *总和*，记作 *T*∘，是其所有组件的总和。
- en: The total sum of a given *p*-cell *(i₁…iₚ)* is referred to as a *q*-partial
    sum of *T*, as it requires a total of *q=l-p* summations, and is defined by
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的 *p*-单元 *(i₁…iₚ)* 的总和称为 *q*-部分和的 *T*，因为它需要 *q=l-p* 次求和，并由以下定义
- en: where the second equality holds whenever *T* is in standard form.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个等式在 *T* 处于标准形式时成立。
- en: For a given *p*, we may therefore construct a *p*-tableau consisting of all
    *q*-partial sums of *T*, denoted by *⊕_q T* or *T_(q)*, such that the *ιₚ* component
    is defined as
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于给定的 *p*，我们可以构造一个由所有 *q*-部分和组成的 *p*-表，用 *⊕_q T* 或 *T_(q)* 表示，其中 *ιₚ* 组件被定义为
- en: for all *ιₚ ∈ I*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有 *ιₚ ∈ I*。
- en: 'In summary, for *p+q=l*:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，对于 *p+q=l*：
- en: a *p*-cell at *ιₚ* is a *q*-dimensional subtableau *T_[ιₚ]* defined over the
    outer index space *I[ιₚ]*, for which the first *p* indices are held fixed; and
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *p*-单元在 *ιₚ* 处是一个定义在外部索引空间 *I[ιₚ]* 上的 *q*-维子表 *T_[ιₚ]*，其中前 *p* 个索引保持固定；并且
- en: the *q*th partial sum *⊕_qT* or *T_(q)* is a *p*-dimensional tableau defined
    on the inner index space *Iₚ*, as the total sum of the individual *p*-cells.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 *q* 个部分和 *⊕_qT* 或 *T_(q)* 是一个定义在内部索引空间 *Iₚ* 上的 *p*-维表，作为单个 *p*-单元的总和。
- en: In general, whenever we have an operator *𝒪* acting on a *p*-cell, it acts on
    the *q*-dimensional *outer index space* (i.e., the fibers), and the result varies
    over the *p*-dimensional *inner index space* (i.e., the base); so that, for instance,
    we would regard the quantity *𝒪(T_{[ιₚ]})* as a *p*-tableau over *Iₚ*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，每当我们有一个操作符 *𝒪* 对一个 *p*-单元进行作用时，它会作用于 *q*-维的 *外部索引空间*（即，纤维），而结果则在 *p*-维的
    *内部索引空间*（即，基）中变化；例如，我们会将量 *𝒪(T_{[ιₚ]})* 视作 *Iₚ* 上的 *p*-表。
- en: Unity Tableaus and Counts
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单位表和计数
- en: 'A *unity tableau* is a constant tableau with value 1\. Given a tableau *T*,
    its associated unity tableau *U* is just a unity tableau with the same shape.
    The partial sums of *U* are the counts of the corresponding *p*-cells:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *单位表* 是一个常数表，值为 1。给定一个表 *T*，其关联的单位表 *U* 只是一个具有相同形状的单位表。*U* 的部分和是对应的 *p*-单元的计数：
- en: We will refer to this tableau as *nᵖ* when we wish to refer to it in invariant
    form.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们希望以不变形式引用此表时，我们将其称为 *nᵖ*。
- en: Average and Variance
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平均值和方差
- en: For any tableau *T* with *n=|T|* components, we may define its average as
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何具有 *n=|T|* 组件的表 *T*，我们可以将其平均值定义为
- en: and its weighted average as
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 及其加权平均值为
- en: 'Note that the *squares* *(T — μ(T))²* constitute a tableau with the same shape
    as *T*. We therefore define the following *sums of squares*:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，*平方* *(T — μ(T))²* 形成了一个与 *T* 具有相同形状的表。因此，我们定义以下 *平方和*：
- en: '(standard and weighted; note that, unlike in the definition of the weighted
    average, weights here are *not* automatically normalized). And, finally, the sample
    variance and variance:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: （标准和加权；请注意，与加权平均的定义不同，这里的权重*不是*自动归一化的）。最后，样本方差和方差：
- en: When applying any of these operations to individual *p*-cells, we think of the
    *p*-cell as fixed, for the purpose of the operation, but then allow the *p*-cell
    to vary through *Iₚ* once the operation is complete. For instance, *SS(T_[i₁ …
    iₚ])* should be regarded as a *p*-tableau over the inner space *Iₚ*, though the
    actual sum-of-squares operations are carried out over the individual outer spaces
    *I_[i₁…iₚ]*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当对单独的 *p*-单元应用这些操作时，我们将 *p*-单元视为固定，作为操作的目的，但在操作完成后允许 *p*-单元通过 *Iₚ* 变化。例如，*SS(T_[i₁
    … iₚ])* 应被视为在内部空间 *Iₚ* 上的 *p*-表，尽管实际的平方和操作是在单个外部空间 *I_[i₁…iₚ]* 上进行的。
- en: 'Addition and Multiplication of Tableaus: Special Cases'
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表的加法和乘法：特殊情况
- en: Addition and multiplication are typically defined componentwise (which, in the
    special case of matrices, reduces to matrix sums and Hadamard products). There
    are, however, two special cases.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 加法和乘法通常按组件定义（在特殊的矩阵情况下，减少为矩阵和及 Hadamard 乘积）。然而，有两个特殊情况。
- en: Consider two tableaus *T* and *S*, with index spaces *I_T* and *I_S*. Then the
    *outer sum T+S* is defined over the union index space *I_T ∪ I_S*, using the convention
    that *x +* **null** *= x.*
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑两个 tableaus *T* 和 *S*，它们的索引空间分别为 *I_T* 和 *I_S*。那么 *外部和 T+S* 在联合索引空间 *I_T ∪
    I_S* 上定义，采用的约定是 *x +* **null** *= x*。
- en: 'If *A* is a *p*-tableau defined over the inner index space *Iₚ* of a second
    tableau *T*, of greater dimension, then the (outer-cast) product *AT* is defined
    in the natural way:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *A* 是在一个更高维度的第二个 tableau *T* 的内部索引空间 *Iₚ* 上定义的 *p*-tableau，那么 (外部投影) 乘积 *AT*
    按自然方式定义：
- en: i.e., the tableau *A* is “cast” to the higher space, and then multiplication
    is carried out componentwise. (This will be useful in the context of cluster randomization,
    where the assignment is done at the cluster level, and thus represents a lower-dimensional
    tableau than the full response tableau.)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 即，tableau *A* 被“投射”到更高的空间，然后按组件进行乘法。（这在群体随机化的背景下会很有用，因为分配是在群体级别进行的，因此表示一个比完整响应
    tableau 更低维度的 tableau。）
- en: Masks
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 掩码
- en: A *mask M* of a tableau *T* is a binary tableau of the same shape, or the shape
    of any inner index space. Its complement is also a mask, defined by *Mᶜ=1-M =
    ¬M*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: tableau *T* 的 *掩码 M* 是具有相同形状的二进制 tableau，或任何内部索引空间的形状。其补集也是一个掩码，由 *Mᶜ=1-M =
    ¬M* 定义。
- en: A mask and its complement sum to the unity tableau and therefore create a partition.
    In general, we say that the set of masks *{M₁, …, Mₘ}* forms a partition of *I*
    if *M₁+…+Mₘ = U*, where *U* is the unity tableau over *I*. (Notice the use of
    the *outer sum*, as the masks are defined over mutually exclusive subsets of the
    index space.)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一个掩码及其补集的和构成单位 tableau，从而创建一个分区。一般来说，如果 *{M₁, …, Mₘ}* 形成 *I* 的一个分区，当且仅当 *M₁+…+Mₘ
    = U*，其中 *U* 是 *I* 上的单位 tableau。（注意使用*外部和*，因为掩码定义在索引空间的互斥子集上。）
- en: The *masked tableau* *MT* (alternatively *T[M]*) is the subtableau of *T* formed
    by restricting the index space to the set
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*掩码 tableau* *MT*（也可写作 *T[M]*）是通过将索引空间限制为集合形成的 *T* 的子tableau'
- en: 'Unlike componentwise multiplication, the magnitude of a masked tableau is not
    the magnitude of the original tableau, but the magnitude of the reduced space,
    which is equivalent to the total sum of the mask: *|MT| = M∘*.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与逐项乘法不同，掩码 tableau 的大小不是原始 tableau 的大小，而是缩减空间的大小，这等同于掩码的总和：*|MT| = M∘*。
- en: '*Note: in our definition, the Truth values of a mask select the “active” components
    of the underlying tableau, which is the opposite convention used in numpy masked
    arrays*.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意：在我们的定义中，掩码的真值选择了底层 tableau 的“活动”组件，这与 numpy 掩码数组使用的相反约定不同*。'
- en: Tableau Notation for Experiments
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tableau 试验的记号
- en: In relation to experiments,
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 关于实验，
- en: experimental design consists of determining a shape *η* and randomization procedure
    for selecting an assignment mechanism *Z*, often constrained by its fixed partial
    sums, which we will denote using *a*;
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实验设计包括确定形状 *η* 和选择分配机制 *Z* 的随机化程序，通常由其固定的部分和约束，我们将用 *a* 表示；
- en: the responses of individual units are stored in a tableau *Y* with shape *η*;
    and
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 各个单元的反应存储在形状为 *η* 的 tableau *Y* 中；以及
- en: the assignment mechanism *Z* is a mask over *Y*.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配机制 *Z* 是 *Y* 上的一个掩码。
- en: If we consider the *potential outcomes* Y(1)=Y(Z=1) and Y(0)=Y(Z=0), the actual
    response is given by
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑 *潜在结果* Y(1)=Y(Z=1) 和 Y(0)=Y(Z=0)，实际反应由下式给出
- en: '*Y = ZY(1) + (1-Z)Y(0).*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*Y = ZY(1) + (1-Z)Y(0)。*'
- en: 'Notice the difference in interpretation provided here: *ZY(1)* and *(1-Z)Y(0)*
    are the *masked* potential outcomes, and are therefore defined on their corresponding
    non-overlapping subtableaus.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里提供的解释差异：*ZY(1)* 和 *(1-Z)Y(0)* 是 *掩码* 潜在结果，因此它们在各自不重叠的子tableaux 上定义。
- en: 'In general, the goal of experimentation is to estimate the *total treatment
    effect* (which I will refer to as either *Δ* or *τ*):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，实验的目标是估计 *总处理效应*（我将称之为 *Δ* 或 *τ*）：
- en: This is, however, unobservable, as we may only know the response under treatment
    or the response under control for any single experimental unit.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种情况是不可观察的，因为我们只能知道任何单一实验单元下的处理反应或对照反应。
- en: For multi-level experiments with *m* possible treatment assignments (including
    control), we instead let *Z* be a *categorical tableau*, with categories enumerated
    *1, …, m*, and then define the set of masks
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有 *m* 种可能处理分配（包括对照）的多级实验，我们让 *Z* 为一个 *分类表格*，其中类别编号为 *1, …, m*，然后定义掩码集
- en: for *z=1,…, m*, such that we may express the potential outcomes formula as
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *z=1,…, m*，我们可以将潜在结果公式表示为
- en: Completely Randomized Design
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完全随机设计
- en: In a completely randomized design, we consider a set of *n* units, of which
    we will randomly assign *a* to the treatment group. The response *Y* is a 1-dimensional
    tableau ranging *i=1,…, n*, and the assignment mechanism *Z* is a 1-dimensional
    mask of the same size, chosen at random from the space *𝔹ⁿ*, subject to the constraint
    *||Z||₁ = a*. If we define the masked tableaus for treatment and control as
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在完全随机设计中，我们考虑一组 *n* 单元，其中我们将随机分配 *a* 到处理组。响应 *Y* 是一个范围为 *i=1,…, n* 的一维表格，分配机制
    *Z* 是一个相同大小的一维掩码，从空间 *𝔹ⁿ* 随机选择，满足约束 *||Z||₁ = a*。如果我们定义处理和对照的掩码表格为
- en: 'we may express the classic *difference-in-means estimator* as:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将经典的 *均值差异估计量* 表示为：
- en: Note our interpretation of *Yᵗ* and *Yᶜ* as subtableaus of the response tableau.
    Thus, the treatment and control averages may be expressed in index notation as
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们对 *Yᵗ* 和 *Yᶜ* 的解释为响应表格的子表格。因此，处理和对照平均值可以用索引符号表示为
- en: Because of our interpretation of *ZY* as a masked tableau, we divide by *a=Z∘*,
    the number of treatment units, and not *n*; similarly for *(1-Z)Y*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将 *ZY* 解释为掩码表格，我们除以 *a=Z∘*，即处理单元的数量，而不是 *n*；对 *(1-Z)Y* 也是类似。
- en: The *T* statistic is defined by
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*T* 统计量定义为'
- en: where the within-group mean squared error is defined by
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 其中组内均方误差定义为
- en: Note we are just applying the sum-of-squares operator over the treatment and
    control subtableaus obtained by the assignment mask and its complement. In coordinates,
    this is may be expressed as
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只是对通过分配掩码及其补充获得的处理和对照子表格应用平方和操作。在坐标中，这可以表达为
- en: Under the null hypothesis of no effect, the test statistic *T* is distributed
    as a *t* distribution with *n-2* degrees of freedom.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在无效假设下，检验统计量 *T* 服从自由度为 *n-2* 的 *t* 分布。
- en: Block-Randomized Design
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 块随机设计
- en: In a block-randomized design, we first partition the experimental units into
    a collection of *s* strata. We then index the units by *(ij)*, where *i=1,…,s*
    refers to the stratum and *j=1,…,nᵢ* refers to the *j*th element in the *i*th
    stratum. Next, we impose the constraint that we will randomly assign *aᵢ* units
    to treatment for the *i*th stratum, subject to the *balancing property*, which
    requires each stratum to contain the same fraction of treatment units; i.e., the
    propensity *πᵢ=aᵢ/nᵢ* is independent of *i*. (This is necessary for the difference-in-means
    estimator, as defined above, to be unbiased.)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在块随机设计中，我们首先将实验单元划分为 *s* 个层次。然后，我们通过 *(ij)* 索引这些单元，其中 *i=1,…,s* 表示层次，*j=1,…,nᵢ*
    表示第 *i* 个层次中的第 *j* 个元素。接下来，我们施加约束，随机分配 *aᵢ* 单元到第 *i* 个层次的处理组，满足 *平衡属性*，要求每个层次包含相同比例的处理单元；即，倾向
    *πᵢ=aᵢ/nᵢ* 与 *i* 独立。（这对于上述定义的均值差异估计量是无偏的。）
- en: Our arrangement of units defines an *l*-shape *η=⟨s, nᵢ⟩*, and so our assignment
    mechanism *Z* is chosen at random over two dimensional tableaus with shape *η*,
    subject to the constraint that *aᵢ=Zᵢ∘= π nᵢ* are fixed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的单元安排定义了一个 *l*-形 *η=⟨s, nᵢ⟩*，因此我们的分配机制 *Z* 是在形状为 *η* 的二维表格上随机选择的，满足 *aᵢ=Zᵢ∘=
    π nᵢ* 是固定的。
- en: The formula for the *T*-statistic is unchanged, except now the treatment and
    control averages are given by
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*T* 统计量的公式保持不变，只是现在处理和对照的平均值由以下给出'
- en: and the MSW is given by
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: MSW 由以下给出
- en: Note that the sum of squares operate on the 1-cells, fixed for each stratum,
    and masked by the assignment mechanism (treatment) or its complement (control).
    In index notation, this is equivalent to
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，平方和操作作用于1-单元，在每个层次上固定，并被分配机制（处理）或其补充（对照）掩盖。在索引符号中，这等价于
- en: 'The treatment and control stratum averages are defined in the obvious way:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 处理和对照层次的平均值以明显的方式定义：
- en: 'Note what we mentioned before: the operation of averaging is carried out over
    the *outer index space*, as it is acting on the 1-cells at *i*. The result is
    then free to vary over the *inner index space*, defined by *I_1={1, …, s}.*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们之前提到的：平均操作在 *外部索引空间* 上进行，因为它作用于 *i* 的 1-单元。结果可以在 *内部索引空间* 上变化，由 *I_1={1,
    …, s}* 定义。
- en: Under the null hypothesis of no effect, the test statistic *T* is distributed
    as a *t*-distribution with *n-2s* degrees of freedom.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在无效假设下，测试统计量*T*的分布为具有*n-2s*自由度的*t*分布。
- en: The Adjustment Formula
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整公式
- en: 'When the *balancing property* does not hold, which is often the case in observational
    studies (*natural experiments*), we replace the difference-in-means estimator
    defined above with the *adjustment formula*:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当*平衡属性*不成立时，这在观察性研究（*自然实验*）中常见，我们用*调整公式*替代上述定义的均值差异估计量：
- en: The adjustment formula is obtained by taking the *weighted* average of each
    stratum’s observed classic *difference-in-means* estimator, using the number *nᵢ*
    of units in each stratum as weights.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 调整公式是通过取每个层次观察到的经典*均值差异*估计量的*加权*平均来获得的，使用每个层次中单位数*nᵢ*作为权重。
- en: Cluster-Randomized Design
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集群随机化设计
- en: Cluster-randomization is similar to block design, except the assignment is done
    *at the cluster level*, not at individual unit level within each stratum. This
    is common in quasi-experiments, where individual level randomization is impractical
    or impossible; for example, with *out-of-home (OOH)* marketing efforts, where
    randomization may be conducted at the *city* level.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 集群随机化类似于区组设计，只不过分配是在*集群级别*进行的，而不是在每个层次内的单独单位级别。这在准实验中很常见，当个体级别的随机化不切实际或不可能时；例如，在*户外（OOH）*市场推广活动中，随机化可能在*城市*级别进行。
- en: In this case, our response is a 2-tableau *Y*, ranging *i=1,…, c* and *j=1,…,
    nᵢ*, where there are *nᵢ* units in the *i*th cluster, for each of *c* clusters.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的响应是一个2维表格*Y*，范围为*i=1,…, c*和*j=1,…, nᵢ*，其中*i*个集群中有*nᵢ*个单位，每个*c*个集群。
- en: The assignment mechanism, however, is a 1-tableau *Z,* defined at random over
    the innder index space *I₁={1,…,c}*, subject to the constraint *||Z||₁=a.* Note
    the importance of the “outer-cast” multiplication rule, as our masked responses
    can still be described by *Yᵗ = ZY* and *Yᶜ = (1-Z)Y*. Note also that the variable
    *a=Z∘* represents the total *number of clusters* assigned to the treatment group.
    This is logical, as the treatment units are the *clusters*, not the individuals.
    The estimator for the total treatment effect is then given in its invariant form
    by
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，分配机制是一个1维表格*Z*，在内索引空间*I₁={1,…,c}*上随机定义，受约束*||Z||₁=a*。注意“外部乘法”规则的重要性，因为我们的掩蔽响应仍然可以通过*Yᵗ
    = ZY*和*Yᶜ = (1-Z)Y*来描述。还要注意，变量*a=Z∘*表示分配到治疗组的*集群总数*。这是合理的，因为治疗单位是*集群*，而不是个体。总体治疗效果的估计量以其不变形式给出
- en: Note the partial sums are carried out first, followed by averaging over the
    treatment and control clusters. (The version on the right may seem more intuitive
    here, though the left is the “most” invariant form.)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，部分和首先计算，然后在治疗和对照集群之间平均。（右侧版本在这里可能更直观，尽管左侧是“最”不变形式。）
- en: This is just an application of the Thompson-Horwitz estimator, using propensities
    *a/c* for the treatment clusters and *(a-c)/a* for the control clusters. In index
    notation, this is equivalent to
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是使用治疗集群的*a/c*倾向和对照集群的*(a-c)/a*倾向的汤普森-霍维茨估计量的一个应用。在索引符号中，这等同于
- en: Block-Cluster Randomized Design
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 区组集群随机化设计
- en: In a block-cluster design, the clusters are first grouped into strata. This
    may be useful, for example, in grouping similarly sized cities together within
    a country, to ensure there is balance in the treatment assignment.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在区组-集群设计中，集群首先被分组到层次中。这在例如将类似大小的城市分组到一个国家内时可能是有用的，以确保治疗分配的平衡。
- en: The individual at *(ijk)* is the *k*th unit in cluster *(ij)*, which is the
    *j*th cluster in stratum *i,* for *i=1,…,s*, *j=1,…,cᵢ*, and *k=1,…,nᵢⱼ*. Thus
    the response is described by a 3-tableau *Y* of shape *η=⟨s, cᵢ, nᵢⱼ⟩*. The assignment
    mechanism *Z* is a 2-tableau of shape *η=⟨s, cᵢ⟩*; i.e., over the inner space
    *I₂*, selected at random subject to the constraint that *aᵢ* clusters within the
    *i*th stratum be assigned to treatment, yielding a propensity of *πᵢ=aᵢ/cᵢ*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*(ijk)*处的个体是集群*(ij)*中的*k*个单位，集群*(ij)*是层次*i*中的*j*个集群，其中*i=1,…,s*，*j=1,…,cᵢ*，*k=1,…,nᵢⱼ*。因此，响应由形状为*η=⟨s,
    cᵢ, nᵢⱼ⟩*的3维表格*Y*描述。分配机制*Z*是形状为*η=⟨s, cᵢ⟩*的2维表格；即，在内空间*I₂*上随机选择，受限于在*i*层次内的*aᵢ*集群被分配到治疗组，产生*πᵢ=aᵢ/cᵢ*的倾向。'
- en: The masked quantities *Yᵗ=ZY* and *Yᶜ=(1-Z)Y* still make sense, given our outer-case
    product rule.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 给定我们的外部案例乘法规则，掩蔽量*Yᵗ=ZY*和*Yᶜ=(1-Z)Y*仍然是有意义的。
- en: The estimate of total treatment effect is given by
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 总体治疗效果的估计由下式给出
- en: Note the similarity between this formula, the simple cluster formula, and the
    adjustment formula. We start by performing the first partial sum within each cluster
    *before* averaging; we next average over the clusters within each stratum (hence
    dividing by *aᵢ* and *cᵢ-aᵢ*, respectively), and then, finally, we apply the adjustment
    formula to average across strata.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个公式、简单簇公式和调整公式之间的相似性。我们首先在每个簇内执行第一次部分和*before*平均；接下来，在每个层内对簇进行平均（因此分别除以*aᵢ*和*cᵢ-aᵢ*），最后，我们应用调整公式以在层间进行平均。
- en: 'To break-down these operations in detail:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 详细分解这些操作：
- en: '*Yᵗ=ZY* is the masked subtableau consisting of treatment units, a 3-dimensional
    tableau still enumerated by *(ijk)*;'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*Yᵗ=ZY* 是掩蔽的子表格，由处理单元组成，一个3维表格仍然按*(ijk)*枚举；'
- en: '*⊕₁Yᵗ* is the first partial sum, obtained by summing the response of all treated
    units within the *(ij)*th cluster, thus yielding a 2-dimensional tableau of *aggregated
    responses*;'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*⊕₁Yᵗ* 是第一次部分和，通过对*(ij)*簇内所有处理单元的响应求和得到，从而得到一个*聚合响应*的2维表格；'
- en: '*⊕₁Yᵗ_[i]* is the 1-cell (indexed by *j*), comprised of the aggregated responses
    for each treatment cluster within the cell;'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*⊕₁Yᵗ_[i]* 是1-单元（由*j*索引），由每个处理簇内的聚合响应组成；'
- en: '*μ(⊕₁Yᵗ_[i])* is obtained by averaging the cluster-level aggregated responses
    over each stratum, yielding a 1-dimensional tableau indexed by stratum *i*;'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*μ(⊕₁Yᵗ_[i])* 是通过对每层的簇级聚合响应进行平均得到的，得到一个按层* i* 索引的1维表格；'
- en: the final average is the weighted stratum averages of the difference *μ(⊕₁Yᵗ_[i])
    — μ(⊕₁Yᶜ_[i]).*
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终平均值是加权的层平均值，计算公式为*μ(⊕₁Yᵗ_[i]) — μ(⊕₁Yᶜ_[i])*。
- en: In index notation, this is equivalent to
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在索引符号中，这等价于
- en: It’s kinda magic.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点像魔法。
- en: ANOVA Sum of Squares Decomposition
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方差分析平方和分解
- en: In ANOVA, we are interested in the decomposition of the total sum of squares
    into the between-group and within-group sums of squares. Here, we have *m* groups,
    where the *i*th group has *nᵢ* units. The response *Y* is indexed by *(ij)* over
    this range.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在方差分析（ANOVA）中，我们关心的是总平方和的分解，分为组间平方和和组内平方和。这里，我们有*m*组，其中第*i*组有*nᵢ*个单元。响应*Y*按*(ij)*的范围进行索引。
- en: The total sum of squares (SST) is given by
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 总平方和（SST）由以下公式给出
- en: The decomposition rule shows that this is equivalent to the sum of the between-group
    (SSB) and within-group sums (SSW) of squares. The SSW is given by
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 分解规则表明这等同于组间平方和（SSB）和组内平方和（SSW）的总和。SSW由以下公式给出
- en: (Note this matches the formula we obtained for MSW in the block-randomized design.)
    The sum of squares is applied to the individual 1-cells (groups), and the result
    is totaled across groups.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: （注意这与我们在块随机设计中获得的MSW公式相匹配。）平方和应用于各个1-单元（组），结果在组间汇总。
- en: The SSB is given by
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: SSB由以下公式给出
- en: Here, the group averages are computed first, and then a (weighted) sum-of-squares
    is performed across the group averages.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，首先计算组平均值，然后在组平均值上进行（加权）平方和操作。
- en: Expressed in tableau notation, the sum of squares decomposition is given by
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 用表格符号表示，平方和分解由以下公式给出
- en: Python Implementation
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 实现
- en: 'A Python implementation is provided below. This consits of three classes: a
    Tableau class, which is then subclassed to a CountTableau and a Mask class. A
    CountTableau object is constructed for every Tableau object, which can be used
    to obtain the cell counts. The Mask class overwrites the __init__ method, to assert
    all values passed in are Boolean, and the __mul__ method, to modify the count
    of the masked return object.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下提供了Python实现。它由三个类组成：一个Tableau类，接着是CountTableau和Mask类的子类。每个Tableau对象构造一个CountTableau对象，用于获取单元计数。Mask类重写了__init__方法，以断言传入的所有值都是布尔值，并重写了__mul__方法，以修改被掩蔽的返回对象的计数。
- en: '[PRE0]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The __iter__ method uses recursion to iterate through the tableau, in the style
    of key, value pairs (much like enumerate(some_list) or k, v in some_dict.items()).
    Moreover, we implement a __call__ method, which can be used in conjunction with
    iteration, such that **for k, v in T(2):** would iterate through the inner index
    space *I₂*, returning the fibers *T_{ιₚ}*, for each *ιₚ∈ I₂*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: __iter__方法使用递归遍历表格，以键值对的形式（类似于enumerate(some_list)或k, v in some_dict.items()）。此外，我们实现了__call__方法，可以与迭代结合使用，这样**for
    k, v in T(2):** 就会遍历内层索引空间*I₂*，返回每个*ιₚ∈ I₂*的纤维*T_{ιₚ}*。
- en: Similarly, both the *mean* and *sumSquares* methods take an optional argument
    *p*, for which the calculation would be conducted over the fibers, and a *p*-dimensional
    tableau over the inner index space returned.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，*mean*和*sumSquares*方法都接受一个可选的参数*p*，计算将会在纤维上进行，并返回一个在内索引空间上的*p*-维tableau。
- en: Addition is defined for *A+B* if *A* is higher-dimensional than *B*, which is
    required for sum of squares computation. Multiplication is the opposite, *AB*
    is defined as long as *A* is lower-dimensional than *B*. This is required for
    compatibility with left-multiplying by a lower-dimensional mask, as required for
    cluster analysis.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*A*的维度高于*B*，则定义*A+B*，这对于平方和计算是必需的。乘法则相反，只要*A*的维度低于*B*，则定义*AB*。这对于与低维掩码的左乘兼容性是必需的，这在聚类分析中是必需的。
- en: We also implemented the __getitem__ and __setitem__. The former has some coolness,
    unlike nested arrays, we can use notation T[1,2,3] to get the *p*-cell at *(1,2,3)*.
    (We don’t even need to fill the remaining dimensions with *:*s; e.g., *T[1,2,3]*
    will do, for a 5-dimensional tableau, without needing to write *T[1,2,3,:,:]*!
    And this is better than working with the original nested arrays, which require
    A[1][2][3].) The __setitem__ uses recursion to set values, and you can even pass
    a subtableau of the appropriate shape here.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还实现了__getitem__和__setitem__。前者有一些酷炫的地方，与嵌套数组不同，我们可以使用符号T[1,2,3]来获取位于*(1,2,3)*的*p*-单元。（我们甚至不需要用*:*填充其余维度；例如，对于5维的tableau，*T[1,2,3]*就可以，而无需写*T[1,2,3,:,:]*！这比处理原始嵌套数组更好，后者需要A[1][2][3]。）__setitem__使用递归设置值，您甚至可以在这里传递一个适当形状的子tableau。
- en: Basic operations are illustrated below.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 基本操作如下所示。
- en: '[PRE1]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A simulation of a block design is given below. We used 5 strata, with a treatment
    propensity of 30%. In our simulation, the treatment effect was a constant 10;
    strata responses were normally distributed with std 10, and strata means were
    separated in increments of 10\. Each strata contained a random number of units
    between 400 and 500\. We measured a difference-in-means of 9.7 and rejected the
    null hypothesis with 95% confidence.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 下面给出了一个块设计的模拟。我们使用了5个层次，处理倾向为30%。在我们的模拟中，处理效应是一个恒定的10；层次响应服从标准差为10的正态分布，层次均值按10的增量分隔。每个层次包含400到500之间的随机单位。我们测量了均值差异为9.7，并以95%的置信度拒绝了原假设。
- en: '[PRE2]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Finally, an example of cluster design is given.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，给出了一个聚类设计的示例。
- en: '[PRE3]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A few notes about the cluster example. First, we made the cluster means super
    close together. The variance of the estimator for stratification depends primarily
    upon the within strata variance, whereas in the case of clustering, it depends
    on the between cluster variance. Since we only simulated a small number of clusters,
    this is a very low power result. Finally, note that the formula for tau_hat only
    works because of the *if not any* logic towards the end of the *sum* method of
    our *Tableau* class; otherwise the partial sum would reset the count tableau,
    and this would result in dividing by the total number of clusters, not the masked
    number of clusters.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 关于聚类示例的一些说明。首先，我们让聚类均值非常接近。层次化的估计量方差主要依赖于层次内的方差，而在聚类的情况下，它依赖于聚类间的方差。由于我们仅模拟了少量聚类，这是一项非常低功效的结果。最后，请注意，`tau_hat`的公式之所以有效，是因为我们*Tableau*类的*sum*方法末尾的*if
    not any*逻辑；否则部分和会重置计数表，这会导致除以总聚类数，而不是被掩盖的聚类数。
- en: But could we resist doing an example of a block-cluster design? Here we let
    the cluster means vary by strata, and we show how to implement the block-cluster
    formula.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们能否抵挡住做一个块聚类设计的示例？在这里，我们让聚类均值按层次变化，并展示如何实现块聚类公式。
- en: '[PRE4]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Conclusion
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: We defined an explicit algebraic structure called a *tableau,* which is essentially
    a partially filled matrix, and various operations on it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个显式的代数结构叫做*tableau*，它本质上是一个部分填充的矩阵，并对其进行了各种操作。
- en: For a given dimension *p*, we defined the inner and outer index spaces, and
    showed how operators applied to *p*-cells should operate over the outer index
    space, returning quantities that vary over the inner index space.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定维度*p*，我们定义了内外索引空间，并展示了如何在外索引空间上应用操作符对*p*-单元进行操作，返回在内索引空间上变化的量。
- en: We showed how these basic operations proliferate experimental analysis, by examining
    a variety of key statistical formula (difference-in-means, *T*-statistics, estimated
    treatment effect for cluster randomization, within-group and between-group sums
    of squares) and casting them into both invariant and index forms.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过检查各种关键统计公式（均值差异、*T*统计量、集群随机化的估计处理效果、组内和组间平方和），展示了这些基本操作如何促进实验分析，并将其转化为不变形式和指数形式。
- en: Finally, we provided a Python implementation of our Tableau data structure,
    and showed how key formula can be executed using a few lines of code.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们提供了我们的Tableau数据结构的Python实现，并展示了如何使用几行代码执行关键公式。
- en: References
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[1] P.D. Berger, R.E. Mauer, and G.B. Celli, *Experimental Design: With Applications
    in Management, Engineering, and the Sciences* (2018), 2nd ed., Springer.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] P.D. Berger, R.E. Mauer, 和 G.B. Celli, *实验设计：在管理、工程和科学中的应用*（2018年），第2版，Springer。'
- en: '[2] J. Maruskin, [*Fundamentals of Data Science Trilogy: Experiment, Model,
    Learn*](https://www.amazon.com/Fundamentals-Data-Science-Trilogy-Experiment-Model-Learn/dp/1941043038/ref=sr_1_5?crid=23E5N6RECFXJF&keywords=jared+maruskin&qid=1695921221&sprefix=jared+maruski%2Caps%2C245&sr=8-5)(2022),
    Cayenne Canyon Press.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[2] J. Maruskin, [*数据科学三部曲：实验、模型、学习*](https://www.amazon.com/Fundamentals-Data-Science-Trilogy-Experiment-Model-Learn/dp/1941043038/ref=sr_1_5?crid=23E5N6RECFXJF&keywords=jared+maruskin&qid=1695921221&sprefix=jared+maruski%2Caps%2C245&sr=8-5)（2022年），Cayenne
    Canyon Press。'
- en: '[3] P.R. Rosenbaum, *Observational Studies* (2002), 2nd ed., Springer.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[3] P.R. Rosenbaum, *观察研究*（2002年），第2版，Springer。'
- en: '[4] P.D. Rosenbaum, *Design of Observational Studies* (2020), 2nd ed., Springer.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[4] P.D. Rosenbaum, *观察研究的设计*（2020年），第2版，Springer。'
- en: '[5] M. Saveski, J. Pouget-Abadie, G. Saint-Jacques, W. Duan, S. Ghosh, Y. Xu,
    E.M. Airoldi, [Detecting Network Effects: Randomizing Over Randomized Experiments](https://www.kdd.org/kdd2017/papers/view/detecting-network-effects-randomizing-over-randomized-experiments)
    (2017), KDD Research Paper, Halifax, NS, Canada.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[5] M. Saveski, J. Pouget-Abadie, G. Saint-Jacques, W. Duan, S. Ghosh, Y. Xu,
    E.M. Airoldi, [检测网络效应：在随机化实验中随机化](https://www.kdd.org/kdd2017/papers/view/detecting-network-effects-randomizing-over-randomized-experiments)（2017年），KDD研究论文，哈利法克斯，加拿大。'
- en: '[6] D. Selvamutha and D. Das, *Introduction to Statistical Methods, Design
    of Experiments, and Statistical Quality Control* (2018) Springer.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[6] D. Selvamutha 和 D. Das, *统计方法、实验设计和统计质量控制导论*（2018年），Springer。'
- en: '*Unless otherwise noted, all images by the Author.*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*除非另有说明，所有图片均由作者提供。*'
