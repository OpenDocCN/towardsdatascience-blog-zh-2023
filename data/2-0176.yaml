- en: A Comprehensive Guide on Common Table Expression in SQL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 《SQL中公共表表达式的全面指南》
- en: 原文：[https://towardsdatascience.com/a-comprehensive-guide-on-common-table-expression-in-sql-8c892ffda2f5](https://towardsdatascience.com/a-comprehensive-guide-on-common-table-expression-in-sql-8c892ffda2f5)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/a-comprehensive-guide-on-common-table-expression-in-sql-8c892ffda2f5](https://towardsdatascience.com/a-comprehensive-guide-on-common-table-expression-in-sql-8c892ffda2f5)
- en: Back To Basics | Simplifying Complex Queries and Enhancing Readability
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回到基础 | 简化复杂查询并提高可读性
- en: '[](https://iffatm.medium.com/?source=post_page-----8c892ffda2f5--------------------------------)[![Iffat
    Malik](../Images/7be3b651053507de2077b3c3c9d3a408.png)](https://iffatm.medium.com/?source=post_page-----8c892ffda2f5--------------------------------)[](https://towardsdatascience.com/?source=post_page-----8c892ffda2f5--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----8c892ffda2f5--------------------------------)
    [Iffat Malik](https://iffatm.medium.com/?source=post_page-----8c892ffda2f5--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://iffatm.medium.com/?source=post_page-----8c892ffda2f5--------------------------------)[![Iffat
    Malik](../Images/7be3b651053507de2077b3c3c9d3a408.png)](https://iffatm.medium.com/?source=post_page-----8c892ffda2f5--------------------------------)[](https://towardsdatascience.com/?source=post_page-----8c892ffda2f5--------------------------------)[![数据科学前沿](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----8c892ffda2f5--------------------------------)
    [Iffat Malik](https://iffatm.medium.com/?source=post_page-----8c892ffda2f5--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----8c892ffda2f5--------------------------------)
    ·14 min read·Aug 22, 2023
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·发表于 [数据科学前沿](https://towardsdatascience.com/?source=post_page-----8c892ffda2f5--------------------------------)
    ·14分钟阅读·2023年8月22日
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/b150ba7dccc63bf4a565984c86a8b0aa.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b150ba7dccc63bf4a565984c86a8b0aa.png)'
- en: Image by author
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由作者提供
- en: In programming, it’s a common practice to group instructions or statements in
    smaller and more manageable code blocks. This practice is usually referred as
    [*code block organisation*](https://en.wikipedia.org/wiki/Block_(programming)).
    It’s basically breaking down a program or a large section of a program into smaller
    and logically connected blocks. These blocks are designed to perform a specific
    task or just to group related functionalities. This approach not only improves
    code readability but also makes the code more organised and maintainable. Various
    programming constructs such as functions, methods, try-catch blocks, loops, and
    conditional statements are commonly used for this purpose.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，将指令或语句分组到更小、更易于管理的代码块中是一种常见做法。这种做法通常被称为 [*代码块组织*](https://en.wikipedia.org/wiki/Block_(programming))。它基本上是将程序或程序的大块分解成更小且逻辑上相关的块。这些块旨在执行特定任务或仅仅是将相关功能分组。这种方法不仅提高了代码的可读性，还使代码更有组织和更易于维护。各种编程结构，如函数、方法、try-catch
    块、循环和条件语句，通常用于此目的。
- en: In *SQL*, one of the ways to achieve the same is by using *Common Table Expression
    (CTE)*. In this article, we’ll explore how *CTEs* can significantly simplify and
    optimise complex SQL queries.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在*SQL*中，实现相同效果的一种方法是使用*公共表表达式（CTE）*。在本文中，我们将探讨*CTE*如何显著简化和优化复杂的SQL查询。
- en: What is CTE?
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是CTE？
- en: CTE, Common Table Expression, is a query that **temporarily** stores the result
    set so that it can be referenced and used in another query. The CTE remains available
    as long as it is within the **same execution scope.**
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: CTE（公共表表达式）是一个**临时**存储结果集的查询，以便在另一条查询中引用和使用。只要在**同一执行范围**内，CTE 就会保持可用。
- en: In simple terms, a *CTE* acts like a temporary table that holds the intermediate
    results of a query, allowing you to use those results later in another *SQL* query.
    It is also referred as *Subquery Refactoring*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，*CTE* 像是一个临时表，它保存查询的中间结果，允许你在另一条*SQL*查询中使用这些结果。它也被称为*子查询重构*。
- en: Here, there are two key points to note,
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，有两个关键点需要注意，
- en: '***‘temporary result set’***, which means the output of the *CTE* is stored
    temporarily and does not create a permanent table in the database.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***‘临时结果集’***，意味着*CTE*的输出会被暂时存储，而不会在数据库中创建一个永久表。'
- en: '***‘same execution scope’****,* thisrefers to the fact that it can only be
    utilised within the same *SQL* statements where it is defined. Once that *SQL*
    statement is completed, the *CTE* is no longer accessible, making it confined
    to its defined scope.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***‘同一执行范围’***，指的是它只能在定义它的相同*SQL*语句中使用。一旦该*SQL*语句完成，*CTE*将不再可用，使其局限于定义的范围内。'
- en: The motive of *CTE* is to simplify long and complex queries. By breaking down
    the long queries into simple, smaller and manageable blocks of code, it reduces
    the complexity while increasing the readability and in some databases, reusability
    as well.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*CTE*的目的是简化长而复杂的查询。通过将长查询拆分成简单、小而可管理的代码块，它降低了复杂性，同时提高了可读性，在某些数据库中，也增加了可重用性。'
- en: It is defined by using a ***WITH*** clause. The common syntax of a *CTE* is,
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用***WITH***子句来定义。*CTE*的常见语法是，
- en: '![](../Images/82d67437deb3018e0fe736cb0f592e5f.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/82d67437deb3018e0fe736cb0f592e5f.png)'
- en: 'Image by author: Common syntax of a CTE'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 作者提供的图像：*CTE*的常见语法
- en: You can define multiple *CTEs* as well, the common syntax of defining multiple
    *CTEs* is,
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以定义多个*CTEs*，定义多个*CTEs*的常见语法是，
- en: '![](../Images/f84a2cd2774a2df317e9814ad280ff56.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f84a2cd2774a2df317e9814ad280ff56.png)'
- en: 'Image by author: Common syntax of using multiple CTEs'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 作者提供的图像：使用多个*CTE*的常见语法
- en: '*CTEs* can be used in the following *SQL* statements,'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*CTEs*可以在以下*SQL*语句中使用，'
- en: SELECT
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择
- en: INSERT
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入
- en: UPDATE
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新
- en: DELETE
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除
- en: A *CTE* can be referenced in another *CTE* too. When a *CTE* refers to itself,
    it becomes a *Recursive CTE*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*CTE*也可以在另一个*CTE*中被引用。当一个*CTE*引用自身时，它就成为了*递归CTE*。
- en: Now that we have a fair background on a *CTE*, let’s begin the action. Here,
    we will be using data from a dummy vehicle retailer company, you can find source
    data in my [GitHub Repo](https://github.com/PhoenixIM/All_Things_SQL/tree/main/Common%20Table%20Expression),
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对*CTE*有了基本了解，让我们开始实际操作。在这里，我们将使用来自虚拟车辆零售公司数据，你可以在我的[GitHub Repo](https://github.com/PhoenixIM/All_Things_SQL/tree/main/Common%20Table%20Expression)中找到源数据，
- en: '![](../Images/f3d790d884d1a5855d4484a2af9b1bc9.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f3d790d884d1a5855d4484a2af9b1bc9.png)'
- en: 'Image by author: ER diagram of vehicle retailer company'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 作者提供的图像：车辆零售公司ER图
- en: Let’s say we need to generate a report that ranks the products based on their
    total revenue. This report should provide key information such as product ID,
    product names, the total quantity sold, total revenue, and the sales rank based
    on total revenue.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要生成一个基于总收入排名的产品报告。这个报告应提供关键的信息，如产品ID、产品名称、总销售数量、总收入以及基于总收入的销售排名。
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![](../Images/b3044d4a46ea4b4fc6ae8811d6ae2559.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b3044d4a46ea4b4fc6ae8811d6ae2559.png)'
- en: GIF by author
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 作者提供的GIF
- en: 'In the query above, we calculated two important metrics for each product in
    the *CTE, ‘PRODUCTSALES’*:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述查询中，我们为每个产品计算了两个重要指标，在*CTE, ‘PRODUCTSALES’*中：
- en: The total quantity of items sold (*‘TOTAL_QUANTITY_SOLD’* ) and
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销售的总数量（*‘TOTAL_QUANTITY_SOLD’*）和
- en: The total revenue (*‘TOTAL_REVENUE’* ) generated from those sales.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从这些销售中产生的总收入（*‘TOTAL_REVENUE’*）。
- en: In the main *SQL* query, we put these metrics to use. Additionally, we used
    the *RANK()* function. This *Window Function* assigns a unique sequential number
    to each row of data in a table, or within a specified partition, while maintaining
    the same rank for rows with identical values.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在主要的*SQL*查询中，我们使用了这些指标。此外，我们使用了*RANK()*函数。这个*窗口函数*为表中每一行数据分配一个唯一的顺序编号，或在指定的分区内保持相同的排名，针对具有相同值的行。
- en: You can refer more details on *Window Functions* here,
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里查看更多关于*窗口函数*的细节，
- en: '[](/window-functions-a-must-know-for-data-engineers-and-data-scientists-4dd3e4ad0d2?source=post_page-----8c892ffda2f5--------------------------------)
    [## Window Functions — A must know for Data Engineers and Data Scientists'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[](/window-functions-a-must-know-for-data-engineers-and-data-scientists-4dd3e4ad0d2?source=post_page-----8c892ffda2f5--------------------------------)
    [## 窗口函数 — 数据工程师和数据科学家必须了解的'
- en: Back To Basics | SQL fundamentals for beginners
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回到基础 | SQL初学者基础
- en: towardsdatascience.com](/window-functions-a-must-know-for-data-engineers-and-data-scientists-4dd3e4ad0d2?source=post_page-----8c892ffda2f5--------------------------------)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: towardsdatascience.com](/window-functions-a-must-know-for-data-engineers-and-data-scientists-4dd3e4ad0d2?source=post_page-----8c892ffda2f5--------------------------------)
- en: In our case, we used *RANK()* based on the *‘TOTAL_REVENUE’* andarranged the
    results in descending order. It’s like having a report that helps us understand
    which products are the most successful in terms of sales and revenue.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们根据*‘TOTAL_REVENUE’*使用了*RANK()*，并按降序排列结果。这就像拥有一个报告，帮助我们理解哪些产品在销售和收入方面最成功。
- en: Practice Exercise
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实践练习
- en: I have created some practice exercises to get comfortable with utilising the
    *CTE*. Feel free to post your answers in the response section of this article.
    If you need any help, don’t hesitate to leave a comment.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了一些实践练习，以便熟悉使用*CTE*。欢迎在本文的回复部分发布你的答案。如果你需要任何帮助，随时留言。
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can refer the following article more details about aggregate functions,
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考以下文章以获取有关聚合函数的更多详细信息，
- en: '[](/how-to-use-sql-aggregate-functions-92f7244a07cb?source=post_page-----8c892ffda2f5--------------------------------)
    [## SQL Aggregate Functions for your next Data Science interview'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[](/how-to-use-sql-aggregate-functions-92f7244a07cb?source=post_page-----8c892ffda2f5--------------------------------)
    [## SQL 聚合函数，为您的下一个数据科学面试'
- en: Back To Basics | SQL fundamentals for beginners
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回基础知识 | SQL 基础知识
- en: towardsdatascience.com](/how-to-use-sql-aggregate-functions-92f7244a07cb?source=post_page-----8c892ffda2f5--------------------------------)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: towardsdatascience.com](/how-to-use-sql-aggregate-functions-92f7244a07cb?source=post_page-----8c892ffda2f5--------------------------------)
- en: Recursive CTE
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归 CTE
- en: Now that we are comfortable using CTEs, let’s understand *recursive CTE*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了 CTE，让我们了解一下*递归 CTE*。
- en: A *recursive CTE* is a special kind of *CTE* that refers back to **itself**
    and builds the result set in an iterative manner. It’s like using a loop in SQL.
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*递归 CTE* 是一种特殊的*CTE*，它会引用**自身**并以迭代的方式构建结果集。它就像在 SQL 中使用循环一样。'
- en: 'It consists of two parts which are combined by [***UNION ALL***](https://www.mssqltips.com/sqlservertip/1387/union-vs-union-all-in-sql-server/):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 它由两个部分组成，通过[***UNION ALL***](https://www.mssqltips.com/sqlservertip/1387/union-vs-union-all-in-sql-server/)连接：
- en: The first part, often referred as a ***base part*** as well. This part provides
    the initial data or you can say it provides the starting point for the recursion.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一部分，通常也称为***基本部分***。这一部分提供初始数据或可以说提供递归的起始点。
- en: The second part is the ***recursive part***, it builds the result set based
    on the first part(base part) and then adds more data in each iteration. This process
    continues until there is no more data to add or until a specific condition is
    met.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二部分是***递归部分***，它根据第一部分（基本部分）构建结果集，然后在每次迭代中添加更多数据。这个过程会继续，直到没有更多数据可添加或满足特定条件为止。
- en: For beginners, a common question is when to use it? Well! *Recursive* *CTEs*
    are very helpful when working with data which can be represented in the form of
    parent-child relationship such as family tree, nested categories, organisational
    hierarchy, etc. It is also used in generating sequential date series.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于初学者来说，一个常见的问题是何时使用它？好吧！*递归* *CTEs* 在处理可以表示为父子关系的数据时非常有用，比如家谱、嵌套分类、组织层级等。它也用于生成顺序日期系列。
- en: The common syntax of a *recursive CTE* is,
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*递归 CTE* 的常见语法是，'
- en: '![](../Images/71945a030904e7d5d94df50a0af29ba8.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/71945a030904e7d5d94df50a0af29ba8.png)'
- en: 'Image by author: Common syntax of recursive CTE'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 作者提供的图片：递归 CTE 的常见语法
- en: Here is the sample data from the *‘EMPLOYEES’* table which we will be using
    to create a *recursive CTE* for generating employee hierarchy*,*
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自*‘EMPLOYEES’*表的示例数据，我们将使用这些数据创建一个*递归 CTE*来生成员工层级*。
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![](../Images/499e54d69314e8fb9395b47da5fe4a6b.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/499e54d69314e8fb9395b47da5fe4a6b.png)'
- en: Image by author
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 作者提供的图片
- en: Let’s say we want to retrieve the entire employee hierarchy to track the depth
    or the level of each employee within the company’s hierarchical structure.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，我们想要检索整个员工层级，以跟踪公司层级结构中每个员工的深度或级别。
- en: First, we will select a starting point as a specific employee, *‘Joyce Duffy’*
    who hold the ‘*JOBTITLE’* as the *‘Chief Executive Office’* and her *‘EMPLOYEEID’*
    is *‘EMP100’,*
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将选择一个起始点，特定的员工*‘Joyce Duffy’*，她的‘*JOBTITLE’*是*‘首席执行官’*，她的*‘EMPLOYEEID’*是*‘EMP100’*。
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](../Images/291008b02e3f36d17577911c116d4ac7.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/291008b02e3f36d17577911c116d4ac7.png)'
- en: 'Image by author: output of the query'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 作者提供的图片：查询结果
- en: In the code block above, we created a *CTE*, ‘*EMPLOYEEHIERARCHY’*. Now let’s
    focus on the **base part**. As mentioned earlier, we chose employee *‘Joyce Duffy’*
    as our base point or starting point to build the employee hierarchy column *‘EMPHIERARCHYDEPTH’*
    and we assigned the depth of it as *‘1’.* This means she is at the topmost level
    of the hierarchy.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码块中，我们创建了一个*CTE*，‘*EMPLOYEEHIERARCHY’*。现在让我们关注**基本部分**。如前所述，我们选择了员工*‘Joyce
    Duffy’*作为我们的基点或起始点来构建员工层级列*‘EMPHIERARCHYDEPTH’*，并将其深度设定为*‘1’*。这意味着她处于层级结构的最顶层。
- en: '![](../Images/405e19593c3b6e094d499fae0b8fdaf4.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/405e19593c3b6e094d499fae0b8fdaf4.png)'
- en: Image by author
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 作者提供的图片
- en: Higher levels(e.g. 3,4 etc.) representing employees managed by other employees,
    forming a tree-like structure. The ‘*EMPHIERARCHYDEPTH’* column is useful for
    visualising and understanding the hierarchical relationships among employees in
    the organisation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 更高层级（例如3、4等）表示由其他员工管理的员工，形成树状结构。‘*EMPHIERARCHYDEPTH*’列对可视化和理解组织中员工之间的层级关系非常有用。
- en: '![](../Images/fc1f093a002c74f1c9edb40d02000e56.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/fc1f093a002c74f1c9edb40d02000e56.png)'
- en: 'Image by author: Employee hierarchy'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 作者提供的图片：员工层级
- en: Now the second part, the **recursive part** is the place where actual magic
    happens. It refers back to the *CTE* ‘*EMPLOYEEHIERARCHY’* and repeatedly joins
    the *‘EMPLOYEES’* table with the previous result(from the base part) of the *CTE*
    using the join condition *‘EMP.MANAGER = EH.EMPLOYEEID’.* This means it looks
    for employees whose manager’s ID matches the current employee’s ID, creating a
    chain of parent-child relationships.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在第二部分，即**递归部分**是实际发生“魔法”的地方。它回溯到*CTE* ‘*EMPLOYEEHIERARCHY*’并重复将*‘EMPLOYEES’*表与*CTE*的前一个结果（来自基础部分）连接，使用连接条件*‘EMP.MANAGER
    = EH.EMPLOYEEID’*。这意味着它会查找经理的ID与当前员工的ID匹配的员工，从而创建父子关系链。
- en: To understand the recursive part**,** let’s take the dataset containing information
    about individuals within the Marketing division only,
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解**递归部分**，我们以仅包含市场部员工的信息的数据集为例，
- en: '![](../Images/693b94ed83fa77608137b89e0d21d214.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/693b94ed83fa77608137b89e0d21d214.png)'
- en: 'Image by author: Marketing division employee hierarchy'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 作者提供的图片：市场部员工层级
- en: Below is the visual representation of the above dataset. Notice how it enhances
    clarity and facilitates comprehension quickly, doesn’t it?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述数据集的可视化表示。注意它如何增强清晰度并快速促进理解，是不是？
- en: '![](../Images/bbe8ac28a66b31dd1162fc1d2cabcfff.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/bbe8ac28a66b31dd1162fc1d2cabcfff.png)'
- en: 'Image by author: Employee hierarchy of marketing division'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 作者提供的图片：市场部员工层级
- en: Back to our recursive logic, we joined the *‘EMPLOYEES’* (aliased as *‘EMP’*)
    table with the recursive *CTE* *‘EMPLOYEEHIERARCHY’* (aliased as ‘*EH*’) using
    the condition *‘EMP.MANAGER = EH.EMPLOYEEID’.* This condition simply meansthat
    the employee’s *‘MANAGER’* must match the previous iteration’s *‘EMPLOYEEID’.*
    (This join helps us find the employees with their corresponding managers in the
    hierarchical structure.)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的递归逻辑，我们将*‘EMPLOYEES’*（别名为*‘EMP’*）表与递归*CTE* *‘EMPLOYEEHIERARCHY’*（别名为*‘EH’*）连接，使用条件*‘EMP.MANAGER
    = EH.EMPLOYEEID’*。此条件意味着员工的*‘MANAGER’*必须与前一个迭代的*‘EMPLOYEEID’*匹配。（此连接帮助我们在层级结构中找到员工及其对应的经理。）
- en: From the base part, we already know,
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从基础部分，我们已经知道，
- en: '![](../Images/405e19593c3b6e094d499fae0b8fdaf4.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/405e19593c3b6e094d499fae0b8fdaf4.png)'
- en: Image by author
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 作者提供的图片
- en: Now, during the first round of the recursive step, the join condition is evaluated
    for *‘EH.EMPLOYEEID = EMP100’,* which means it will check if *‘EMP.MANAGER = EMP100’
    (‘EMP.MANAGER = EH.EMPLOYEEID’)* This helps us find all the employees who are
    managed by *‘EMP100’*. This gets us 2 results, To simplify our demonstration,
    we’ll concentrate on understanding the marketing division’s hierarchy only,
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在递归步骤的第一轮中，连接条件被评估为*‘EH.EMPLOYEEID = EMP100’*，这意味着它将检查*‘EMP.MANAGER = EMP100’（‘EMP.MANAGER
    = EH.EMPLOYEEID’）*。这帮助我们找到所有由*‘EMP100’*管理的员工。这得到了2个结果，为了简化演示，我们将集中于理解市场部的层级结构，
- en: '![](../Images/1a2e35b61a6693834311b34fb92d6419.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1a2e35b61a6693834311b34fb92d6419.png)'
- en: Image by author
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 作者提供的图片
- en: For *‘Mrs. Hilary Richardson’,* who is *‘VP Marketing’,* the *‘EMPHIERARCHYDEPTH’*
    increases to *2.* This is achieved by adding *1* to *‘EMPHIERARCHYDEPTH + 1’*
    *(1 + 1 = 2)*. This denotes that we are moving down *1* level in the hierarchy.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于*‘Mrs. Hilary Richardson’*，她是*‘VP Marketing’*，*‘EMPHIERARCHYDEPTH’*增加到*2*。这是通过将*1*加到*‘EMPHIERARCHYDEPTH
    + 1’*（*1 + 1 = 2*）实现的。这表示我们在层级中向下移动了*1*级别。
- en: Moving to the second round of recursion, the join condition now checks if *‘EH.EMPLOYEEID
    = EMP101’.* This will list out all the employees whose manager is *‘EMP101 - Mrs
    Hilary Richardson’,*
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转到递归的第二轮，连接条件现在检查*‘EH.EMPLOYEEID = EMP101’*。这将列出所有经理是*‘EMP101 - Mrs Hilary Richardson’*的员工，
- en: '![](../Images/ed19846ff7cbed100e62e48391a6e1e5.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ed19846ff7cbed100e62e48391a6e1e5.png)'
- en: Image by author
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 作者提供的图片
- en: In the similar manner, the query keeps iterating and adding rows to the result
    set until no more matches are found for the condition *‘EMP.MANAGER = EH.EMPLOYEEID’*,
    indicating that there are no more levels in the hierarchy to traverse. The recursion
    ends when there are no more child employees to connect with their managers.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，查询不断迭代并将行添加到结果集中，直到找不到满足条件 *‘EMP.MANAGER = EH.EMPLOYEEID’* 的匹配项，表明层次结构中没有更多的级别可以遍历。当没有更多的子员工与他们的经理连接时，递归结束。
- en: One important point to note is that each iteration of the recursive part operates
    only on the rows produced by the previous iteration.
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个重要的点是，每次递归部分的迭代只在由前一次迭代产生的行上操作。
- en: CTE vs Subquery
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CTE 与子查询
- en: '*Subquery* in *SQL* is essentially a *‘query inside another query’*. It is
    sometimes referred to as a *nested query* or an *inner query*.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*SQL* 中的 *子查询* 实质上是 *“查询中的查询”*。有时也称为 *嵌套查询* 或 *内部查询*。'
- en: 'So, here comes the million-dollar question: which approach is better, *CTEs*
    or S*ubqueries*? Well! There’s no one-size-fits-all answer. It depends on several
    factors like your table layout, data content, indexing strategies, etc. A single
    approach or solution cannot be universally applied to all the use cases. There
    are 3 major differences between *Subqueries* and *CTEs*,'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，百万美元的问题来了：哪种方法更好，*CTEs* 还是 *子查询*？好吧！没有一刀切的答案。这取决于多个因素，如你的表布局、数据内容、索引策略等。单一的方法或解决方案不能普遍适用于所有用例。*子查询*
    和 *CTEs* 之间有 3 个主要区别，
- en: '***CTEs* can be recursive** One significant advantage of *CTEs* is their ability
    to be recursive. It can reference itself as we have already discussed previously,
    making it suitable for creating hierarchical data structures. *Subqueries*, however,
    lack this inherent recursive capability.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***CTEs* 可以递归** *CTEs* 的一个重要优点是其递归能力。它可以像我们之前讨论的那样引用自身，使其适用于创建层次结构数据结构。然而，*子查询*
    缺乏这种内在的递归能力。'
- en: '**Readability and Maintenance** In the professional realm, *SQL* isn’t always
    seen as a programming language. Unfortunately as a result, you often encounter
    nested messier queries compared to other programming languages. In such scenarios,
    *CTEs* step in to enhance the readability by neatly encapsulating logic when compared
    to *Subqueries*; however, they may not always provide the performance optimisation.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可读性和维护性** 在专业领域，*SQL* 并不总被视为编程语言。遗憾的是，结果通常会遇到比其他编程语言更混乱的嵌套查询。在这种情况下，*CTEs*
    通过整洁地封装逻辑来增强可读性，相比于 *子查询*；然而，它们可能不会始终提供性能优化。'
- en: '**Reusability** You can refer to a *CTE* multiple times in a single *SQL* query,
    which is useful for complex calculations or transformations. However, this reusability
    varies by database. While subqueries must be rewritten every time they’re used.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性** 你可以在一个 *SQL* 查询中多次引用 *CTE*，这对于复杂的计算或转换非常有用。然而，这种可重用性因数据库而异。而 *子查询*
    每次使用时都必须重写。'
- en: Let’s quickly query the total quantity of products ordered by each customer,
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速查询每个客户所订购的产品总数量，
- en: '**Using Subquery:**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用子查询：**'
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Using CTE:**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 CTE：**'
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Both the approaches will produce the same result set,
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法将产生相同的结果集，
- en: '![](../Images/f628ff435d6678353612a74662f382e2.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f628ff435d6678353612a74662f382e2.png)'
- en: GIF by author
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 作者提供的 GIF
- en: In the real world scenarios, there is no crystal ball, you have to test and
    measure the performance on the dataset you are working with. It’s essential to
    consider the specific use case, query complexity, and database engine optimisation
    when choosing between them.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的场景中，没有水晶球，你必须在你正在使用的数据集上测试和测量性能。选择它们之间的方案时，考虑具体的使用情况、查询复杂性和数据库引擎优化是至关重要的。
- en: CTE vs Derived Table
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CTE 与派生表
- en: Often the terms *Derived Table* and *Subquery* are used interchangeably. But
    there is a distinction. When a *Subquery* is capable of running independently
    from the outer query, it becomes a *Derived Table.* Unlike *Subqueries*, *Derived
    Tables* require an alias to be specified. Also, *Subqueries* are defined in *‘WHERE’*
    clause, while *Derived Tables* are defined in *‘FROM’* clause.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*派生表* 和 *子查询* 的术语经常互换使用。但它们之间有区别。当 *子查询* 能够独立于外部查询运行时，它就成为了 *派生表*。与 *子查询* 不同，*派生表*
    需要指定一个别名。此外，*子查询* 定义在 *‘WHERE’* 子句中，而 *派生表* 定义在 *‘FROM’* 子句中。'
- en: '*MySQL* treats a derived table as an intermediate result that is calculated
    or materialised before executing the main query. The database engine generates
    an execution plan that first calculates the derived table and then uses it in
    the main query.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*MySQL* 将派生表视为在执行主查询之前计算或实现的中间结果。数据库引擎生成一个执行计划，首先计算派生表，然后在主查询中使用它。'
- en: Coming back to *CTE* vs *Derived Table,* both techniques are used to encapsulate
    and simplify the complex queries. However, there are differences in the syntax
    and usage,
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 回到*CTE*与*派生表*，这两种技术用于封装和简化复杂查询。不过，它们在语法和使用上存在差异，
- en: '**Syntax**'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**'
- en: As we already know *CTEs* are defined using a *‘WITH’* clause; whereas *Derived
    Tables* are created within the *‘FROM’* clause of the main query using subqueries.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如我们已经知道的，*CTE* 是通过*‘WITH’*子句定义的；而*派生表*是在主查询的*‘FROM’*子句中通过子查询创建的。
- en: '**Readability**'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可读性**'
- en: Both *CTEs* and *Derived Tables* enhance readability by breaking down the complex
    queries into smaller ones. However, I personally find *CTEs* a bit more easier
    to read since it is defined at the beginning of the statement rather than embedded
    within the query.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*CTE*和*派生表*通过将复杂查询分解为较小的查询来提高可读性。然而，我个人认为*CTE*稍微容易阅读一些，因为它在语句的开头定义，而不是嵌入在查询中。'
- en: '**Recursiveness** A *CTE* can be self-referencing *(recursive)*, as we have
    already discussed while *Derived Table* lacks this ability.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**递归性** *CTE* 可以自我引用*（递归）*，正如我们之前讨论的，而*派生表*则不具备这种能力。'
- en: '**Performance**'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**'
- en: '*Derived Tables* are commonly regarded as virtual tables within the main query
    across different databases, which might introduce slight performance overhead.
    *PostgreSQL* can optimise their execution, while *MySQL* might treat them as materialised
    subqueries. On the other hand, with *CTEs*, specific databases optimise their
    execution, though this isn’t universally true. For example, *SQL Server* often
    optimises the execution of *CTEs*, while *MySQL*’s behaviour in this regard can
    be less consistent.'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*派生表*通常被认为是主查询中的虚拟表，在不同的数据库中可能会引入轻微的性能开销。*PostgreSQL* 可以优化它们的执行，而*MySQL*可能将它们视为实现的子查询。另一方面，*CTE*，某些数据库可以优化它们的执行，尽管这并不普遍适用。例如，*SQL
    Server* 通常优化*CTE*的执行，而*MySQL*在这方面的行为可能较不一致。'
- en: Both, *CTEs* and *Derived Tables* offer more or less similar advantages in terms
    of readability and simplifying complex queries. The choice between them relies
    on the specific use case and the database system you are working with.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*CTE*和*派生表*在可读性和简化复杂查询方面提供了或多或少类似的优势。选择它们之间的使用取决于具体的用例和你使用的数据库系统。'
- en: Let’s find out the total quantity in stock vs total quantity sold for each product,
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找出每个产品的库存总量与销售总量，
- en: '**Using Derived Table:**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用派生表：**'
- en: '[PRE8]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Using CTE:**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用CTE：**'
- en: '[PRE9]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Both will produce the same result set.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 两者将产生相同的结果集。
- en: '![](../Images/3e92ccdbfde994deda35c475bb065a1f.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3e92ccdbfde994deda35c475bb065a1f.png)'
- en: GIF by author
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 作者提供的GIF
- en: CTE vs Temp Table
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CTE与临时表
- en: '*Temporary Tables* are special kinds of tables in a database where you can
    put data temporarily while you work on it. These tables are session-specific,
    meaning they are visible only during the ongoing session and are automatically
    removed when the session ends. Dropping a database does not automatically drop
    any *Temporary Tables* created within that database.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*临时表* 是数据库中的特殊类型表，你可以在处理数据时临时存放数据。这些表是会话特定的，意味着它们仅在当前会话中可见，并在会话结束时自动删除。删除数据库不会自动删除在该数据库中创建的任何*临时表*。'
- en: The main difference between a *CTE* and a *Temporary Table* is,
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*CTE*与*临时表*之间的主要区别是，'
- en: '**Storage and Visibility**'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储和可见性**'
- en: '*Temporary Tables* are physically stored in a database. They exist beyond the
    scope of a single query and remain available until they are explicitly dropped
    or the session ends.'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*临时表*在数据库中物理存储。它们超出单个查询的范围，并且在明确删除或会话结束之前保持可用。'
- en: While, *CTEs* are virtual and not physically stored in a database. They are
    part of the query execution and only exist for the duration of that query.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 而*CTE* 是虚拟的，并且不会在数据库中物理存储。它们是查询执行的一部分，只存在于该查询的持续时间内。
- en: '**Reusability**'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性**'
- en: Some databases do permit *CTEs* to be reused by multiple queries within the
    same session.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一些数据库确实允许*CTE*在同一会话中被多个查询重用。
- en: '*Temporary Tables* can be reused across multiple queries within the same session,
    making them suitable for scenarios where the same data needs to be referenced
    multiple times.'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*临时表* 可以在同一会话中的多个查询之间重用，非常适合需要多次引用相同数据的场景。'
- en: '**Indexing and Optimisation**'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**索引与优化**'
- en: '*CTEs* do not allow to create indexes as they are part of the query execution
    plan.'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*CTE* 不允许创建索引，因为它们是查询执行计划的一部分。'
- en: '*Temporary Tables* can be indexed and their data can be optimised to improve
    query performance.'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*临时表* 可以被索引，其数据可以优化以提高查询性能。'
- en: '**Performance**'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**'
- en: Since *Temporary Tables* are physically stored, they can sometimes lead to disk
    I/O and storage overhead. They are useful when managing large volumes of data
    and need to reference that data across multiple queries within the same session.
    However, depending on data size, they might impact performance. On the other hand,
    *CTEs* are often optimised by the query optimiser, and their data could reside
    in memory, reducing disk I/O and enhancing performance. *CTEs* are preferred when
    the goal is to simplify complex queries for better query readability.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于*临时表*是物理存储的，它们有时可能会导致磁盘I/O和存储开销。它们在管理大量数据时非常有用，并且需要在同一会话中跨多个查询引用这些数据。然而，根据数据大小，它们可能会影响性能。另一方面，*CTE*通常由查询优化器优化，它们的数据可以驻留在内存中，从而减少磁盘I/O并提高性能。当目标是简化复杂查询以提高查询可读性时，*CTE*是首选。
- en: Suppose we want to find out the total sales revenue for each product category,
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要找出每个产品类别的总销售收入，
- en: '**Using Temporary Table:**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用临时表：**'
- en: '[PRE10]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Using CTE:**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 CTE：**'
- en: '[PRE11]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Both the queries produce the similar result,
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 两个查询产生类似的结果，
- en: '![](../Images/d41123f693884dea1df22cf74ecb5c6d.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d41123f693884dea1df22cf74ecb5c6d.png)'
- en: Image by author
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由作者提供
- en: Final Challenge
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最终挑战
- en: '[PRE12]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Share your answer in the response section and feel free to leave a comment in
    case you need help!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在回复部分分享你的答案，如果需要帮助，随时留下评论！
- en: Conclusion
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: No matter if you are a beginner or a seasoned *SQL* practitioner, writing queries
    is a bit like being a chef in the kitchen. Your favourite chef knife might work
    wonders for slicing vegetables but that same knife might not be a good choice
    for tenderising meat.(Credit for this analogy goes to my Masterchef binge-watching.)
    Similarly, your go to technique might excel in some situations, but not in others.
    It’s all about assessing the use case and choosing the right technique for the
    best solution. Make sure to refer to the official documentation of the database
    you are using.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是初学者还是经验丰富的*SQL*从业者，编写查询有点像在厨房里做菜。你最喜欢的厨师刀可能在切菜时表现出色，但同样的刀可能不适合嫩化肉类。（这个比喻的出处归功于我对《顶级厨师》的狂热追看。）同样，你常用的技术在某些情况下可能表现优异，但在其他情况下可能效果不佳。这完全是关于评估用例并选择合适的技术以获得最佳解决方案。请务必参考你正在使用的数据库的官方文档。
- en: Here are some useful resources to get started with *CTE*,
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些有用的资源可以帮助你入门*CTE*，
- en: '[CTE in MySQL](https://dev.mysql.com/doc/refman/8.0/en/with.html)'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[MySQL 中的 CTE](https://dev.mysql.com/doc/refman/8.0/en/with.html)'
- en: '[Temporary Tables in MySQL](https://dev.mysql.com/doc/refman/8.0/en/create-temporary-table.html)'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[MySQL 中的临时表](https://dev.mysql.com/doc/refman/8.0/en/create-temporary-table.html)'
- en: '[Derived Tables in MySQL](https://dev.mysql.com/doc/refman/8.0/en/derived-tables.html)'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[MySQL 中的派生表](https://dev.mysql.com/doc/refman/8.0/en/derived-tables.html)'
- en: '[Subqueries in MySQL](https://dev.mysql.com/doc/refman/8.0/en/subqueries.html)'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[MySQL 中的子查询](https://dev.mysql.com/doc/refman/8.0/en/subqueries.html)'
- en: '*The source data, code file used in this article, and solutions to the practice
    exercise can be located in my* [*GitHub Repository*](https://github.com/PhoenixIM/All_Things_SQL/tree/main/Common%20Table%20Expression)*.*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*本文使用的源数据、代码文件和练习题的解决方案可以在我的* [*GitHub 仓库*](https://github.com/PhoenixIM/All_Things_SQL/tree/main/Common%20Table%20Expression)*.* '
- en: '[*Become a member and read every story on Medium*](https://medium.com/@iffatm/membership)*.*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[*成为会员并阅读 Medium 上的所有故事*](https://medium.com/@iffatm/membership)*.*'
- en: Happy Learning!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 学习愉快！
