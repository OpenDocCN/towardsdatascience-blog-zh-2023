- en: Building a Conversational Agent with Memory Microservice with OpenAI and FastAPI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OpenAI 和 FastAPI 构建记忆微服务的对话代理
- en: 原文：[https://towardsdatascience.com/building-a-conversational-agent-with-memory-microservice-with-openai-and-fastapi-5d0102bc8df9?source=collection_archive---------1-----------------------#2023-08-17](https://towardsdatascience.com/building-a-conversational-agent-with-memory-microservice-with-openai-and-fastapi-5d0102bc8df9?source=collection_archive---------1-----------------------#2023-08-17)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/building-a-conversational-agent-with-memory-microservice-with-openai-and-fastapi-5d0102bc8df9?source=collection_archive---------1-----------------------#2023-08-17](https://towardsdatascience.com/building-a-conversational-agent-with-memory-microservice-with-openai-and-fastapi-5d0102bc8df9?source=collection_archive---------1-----------------------#2023-08-17)
- en: '![](../Images/2cd55f0d3ad54800a9951729f2d331c1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2cd55f0d3ad54800a9951729f2d331c1.png)'
- en: A conversation full of memories, Photo by [Juri Gianfrancesco](https://unsplash.com/@jurigianfra?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 充满记忆的对话，照片由 [Juri Gianfrancesco](https://unsplash.com/@jurigianfra?utm_source=medium&utm_medium=referral)
    在 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral) 提供。
- en: 'Crafting Context-Aware Conversational Agents: A Deep Dive into OpenAI and FastAPI
    Integration'
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作上下文感知的对话代理：深入探讨 OpenAI 和 FastAPI 的集成
- en: '[](https://medium.com/@cfloressuazo?source=post_page-----5d0102bc8df9--------------------------------)[![Cesar
    Flores](../Images/4345d9053171db08f1afbedcb32a1006.png)](https://medium.com/@cfloressuazo?source=post_page-----5d0102bc8df9--------------------------------)[](https://towardsdatascience.com/?source=post_page-----5d0102bc8df9--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----5d0102bc8df9--------------------------------)
    [Cesar Flores](https://medium.com/@cfloressuazo?source=post_page-----5d0102bc8df9--------------------------------)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@cfloressuazo?source=post_page-----5d0102bc8df9--------------------------------)[![Cesar
    Flores](../Images/4345d9053171db08f1afbedcb32a1006.png)](https://medium.com/@cfloressuazo?source=post_page-----5d0102bc8df9--------------------------------)[](https://towardsdatascience.com/?source=post_page-----5d0102bc8df9--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----5d0102bc8df9--------------------------------)
    [Cesar Flores](https://medium.com/@cfloressuazo?source=post_page-----5d0102bc8df9--------------------------------)'
- en: ·
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: ·
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F37afeaaf9b9a&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-a-conversational-agent-with-memory-microservice-with-openai-and-fastapi-5d0102bc8df9&user=Cesar+Flores&userId=37afeaaf9b9a&source=post_page-37afeaaf9b9a----5d0102bc8df9---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----5d0102bc8df9--------------------------------)
    ·30 min read·Aug 17, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F5d0102bc8df9&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-a-conversational-agent-with-memory-microservice-with-openai-and-fastapi-5d0102bc8df9&user=Cesar+Flores&userId=37afeaaf9b9a&source=-----5d0102bc8df9---------------------clap_footer-----------)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[关注](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F37afeaaf9b9a&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-a-conversational-agent-with-memory-microservice-with-openai-and-fastapi-5d0102bc8df9&user=Cesar+Flores&userId=37afeaaf9b9a&source=post_page-37afeaaf9b9a----5d0102bc8df9---------------------post_header-----------)
    发表在 [Towards Data Science](https://towardsdatascience.com/?source=post_page-----5d0102bc8df9--------------------------------)
    · 30 分钟阅读 · 2023年8月17日 [](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F5d0102bc8df9&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-a-conversational-agent-with-memory-microservice-with-openai-and-fastapi-5d0102bc8df9&user=Cesar+Flores&userId=37afeaaf9b9a&source=-----5d0102bc8df9---------------------clap_footer-----------)'
- en: --
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F5d0102bc8df9&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-a-conversational-agent-with-memory-microservice-with-openai-and-fastapi-5d0102bc8df9&source=-----5d0102bc8df9---------------------bookmark_footer-----------)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F5d0102bc8df9&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-a-conversational-agent-with-memory-microservice-with-openai-and-fastapi-5d0102bc8df9&source=-----5d0102bc8df9---------------------bookmark_footer-----------)'
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this tutorial, we will explore the process of creating a Conversational Agent
    with a memory microservice using OpenAI and FastAPI. Conversational Agents have
    become a crucial component in various applications, including customer support,
    virtual assistants, and information retrieval systems. However, many traditional
    chatbot implementations lack the ability to retain context during a conversation,
    resulting in limited capabilities and frustrating user experiences. This is challenging,
    especially when building agent services following a microservice architecture.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将探索使用 OpenAI 和 FastAPI 创建具有内存微服务的对话代理的过程。对话代理已成为各种应用程序中的关键组件，包括客户支持、虚拟助手和信息检索系统。然而，许多传统的聊天机器人实现缺乏在对话过程中保留上下文的能力，导致功能有限和令人沮丧的用户体验。这在遵循微服务架构构建代理服务时尤其具有挑战性。
- en: The link to the GitHub repository is at the bottom of the article.
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: GitHub 仓库的链接在文章底部。
- en: Motivation
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: The motivation behind this tutorial is to address the limitation of traditional
    chatbot implementations and create a Conversational Agent with a memory microservice,
    which becomes especially crucial when deploying agents within complex environments
    like Kubernetes. In Kubernetes or similar container orchestration systems, microservices
    are subject to frequent restarts, updates, and scaling operations. During these
    events, the state of the conversation in traditional buffers for chatbots would
    be lost, leading to disjointed interactions and poor user experiences.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程的动机是解决传统聊天机器人实现的局限性，并创建一个具有内存微服务的对话代理，这在将代理部署到像 Kubernetes 这样的复杂环境中时尤为重要。在
    Kubernetes 或类似的容器编排系统中，微服务经常经历重启、更新和扩展操作。在这些事件中，传统聊天机器人的对话状态将丢失，导致断裂的互动和糟糕的用户体验。
- en: By building a Conversational Agent with a memory microservice, we can ensure
    that crucial conversation context is preserved even in the face of microservice
    restarts or updates or when interactions are not continuous. This preservation
    of state allows the agent to seamlessly pick up conversations where they left
    off, maintaining continuity and providing a more natural and personalized user
    experience. Furthermore, this approach aligns with the best practices of modern
    application development, where containerized microservices often interact with
    other components, making the memory microservice a valuable addition to the conversational
    agent’s architecture in such distributed setups.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通过构建具有内存微服务的对话代理，我们可以确保在微服务重启或更新时，甚至在交互不连续的情况下，重要的对话上下文得以保留。这种状态的保存使代理能够无缝地继续之前的对话，保持连贯性，并提供更自然和个性化的用户体验。此外，这种方法符合现代应用开发的最佳实践，其中容器化的微服务通常与其他组件交互，使得内存微服务在这种分布式设置中成为对话代理架构中的有价值的补充。
- en: The Stack We Will Be Using
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们将使用的技术栈
- en: 'For this project, we will primarily work with the following technologies and
    tools:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将主要使用以下技术和工具：
- en: 'OpenAI GPT-3.5: We will leverage OpenAI’s GPT-3.5 language model, which is
    capable of performing various natural language processing tasks, including text
    generation, conversation management, and context retention. We will need to generate
    an OpenAI API Key, make sure you visit this [URL](https://platform.openai.com/account/api-keys)
    to manage your keys.'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenAI GPT-3.5：我们将利用 OpenAI 的 GPT-3.5 语言模型，该模型能够执行各种自然语言处理任务，包括文本生成、对话管理和上下文保留。我们需要生成一个
    OpenAI API 密钥，请确保访问此 [URL](https://platform.openai.com/account/api-keys) 以管理您的密钥。
- en: 'FastAPI: FastAPI will serve as the backbone of our microservice, providing
    the infrastructure for handling HTTP requests, managing conversation states, and
    integrating with the OpenAI API. FastAPI is great for building microservices with
    Python.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FastAPI：FastAPI 将作为我们微服务的骨干，提供处理 HTTP 请求、管理对话状态和与 OpenAI API 集成的基础设施。FastAPI
    非常适合用 Python 构建微服务。
- en: The Development Cycle
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发周期
- en: 'In this section, we will dive into the step-by-step process of building our
    Conversational Agent with a memory microservice. The development cycle will include:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入探讨构建具有内存微服务的对话代理的逐步过程。开发周期将包括：
- en: 'Environment Setup: We’ll create a virtual environment and install the necessary
    dependencies, including OpenAI’s Python library and FastAPI.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 环境设置：我们将创建一个虚拟环境并安装必要的依赖项，包括 OpenAI 的 Python 库和 FastAPI。
- en: 'Designing the Memory Microservice: We’ll outline the architecture and design
    of the memory microservice, which will be responsible for storing and managing
    conversation context.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计记忆微服务：我们将概述记忆微服务的架构和设计，该服务将负责存储和管理对话上下文。
- en: 'Integrating OpenAI: We’ll integrate OpenAI’s GPT-3.5 model into our application
    and define the logic for processing user messages and generating responses.'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集成OpenAI：我们将把OpenAI的GPT-3.5模型集成到我们的应用中，并定义处理用户消息和生成响应的逻辑。
- en: 'Testing: We’ll gradually test our conversational agent.'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试：我们将逐步测试我们的对话代理。
- en: Environment Setup
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境设置
- en: For this setup, we will use the following structure to build the microservice.
    This is convenient for more expansions of other services under the same project,
    and I personally like this structure.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个设置，我们将使用以下结构来构建微服务。这对于在同一个项目下扩展其他服务非常方便，而且我个人喜欢这种结构。
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will need to craft in the project a folder named `src` which will contain
    the Python code for the services; in our case `agents` contains all the code associated
    with our conversational agents and the API, and `agentsfwrk` is our common framework
    for usage across services.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在项目中创建一个名为`src`的文件夹，其中将包含服务的Python代码；在我们的例子中，`agents`包含与对话代理和API相关的所有代码，`agentsfwrk`是我们用于跨服务的通用框架。
- en: The `Dockerfile` contains the instructions to build the image, once the code
    is ready, the `requirements.txt` contains the libraries to use in our project
    and the `setup.py` contains the instructions to build and distribute our project.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile`包含构建镜像的指令，一旦代码准备好，`requirements.txt`包含我们项目中使用的库，`setup.py`包含构建和分发项目的指令。'
- en: For now, just create the services folders along with the `__init__.py` files
    and add the following to the `requirements.txt` and `setup.py` to the root of
    the project, leave the `Dockerfile` empty, as we will come back to it in the Deployment
    Cycle section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，只需创建服务文件夹以及`__init__.py`文件，并将以下内容添加到项目根目录的`requirements.txt`和`setup.py`中，`Dockerfile`保持空白，我们将在部署周期部分回到它。
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let’s activate the virtual environment, and we will run `pip install -r requirements.txt`
    in the terminal. We will not run the setup file yet, so let’s get into the next
    section.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们激活虚拟环境，并在终端运行`pip install -r requirements.txt`。我们暂时不会运行setup文件，所以接下来进入下一部分。
- en: Designing the Common Framework
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计通用框架
- en: We will design our common framework, so we can use it across all the microservices
    built-in the project. This is not strictly necessary for small projects, but thinking
    about the future, you can expand it to use multiple LLM providers, add other libraries
    to interact with your own data (i.e. [LangChain](https://python.langchain.com/),
    [VoCode](https://docs.vocode.dev/what-is-vocode)), and other common capabilities
    such as voice and image services, without the need of implementing them in each
    microservice.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设计我们的通用框架，以便在项目中构建的所有微服务中使用。这对小型项目来说不是严格必要的，但考虑到未来，你可以扩展它以使用多个LLM提供商，添加与自己数据交互的其他库（例如[LangChain](https://python.langchain.com/)，[VoCode](https://docs.vocode.dev/what-is-vocode)），以及其他通用功能，如语音和图像服务，而无需在每个微服务中实现它们。
- en: 'Create the folder and the files following the `agentsfwrk` structure. Each
    file and its description are below:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 创建文件夹和文件时请遵循`agentsfwrk`结构。每个文件及其描述如下：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The logger is a very basic utility to set up a common logging module, and you
    can define it as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录器是一个非常基础的工具，用于设置通用日志模块，你可以按如下方式定义它：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Next, our integration layer is done via the integration module. This file acts
    as a middleman between the microservices logic and OpenAI, and it’s designed to
    expose LLM providers in a common manner for our application. Here, we can implement
    common ways to handle exceptions, errors, retries, and timeouts in requests or
    in responses. I learned from a very good manager to always place an integration
    layer between external services/APIs and the inside world of our application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们的集成层通过集成模块完成。此文件充当微服务逻辑与OpenAI之间的中介，并设计为以统一的方式向我们的应用程序公开LLM提供商。在这里，我们可以实现处理异常、错误、重试和请求或响应超时的通用方法。我从一位非常优秀的经理那里学到，要始终在外部服务/API和我们应用的内部世界之间放置一个集成层。
- en: 'The integration code is defined below:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 集成代码定义如下：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Some notes about the integration module:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 关于集成模块的一些说明：
- en: The OpenAI Key is defined as an environment variable named “OPENAI_API_KEY”,
    we should download this key and define it in our terminal or using the [python-dotenv](https://pypi.org/project/python-dotenv/)
    library.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenAI密钥被定义为名为“OPENAI_API_KEY”的环境变量，我们应该下载这个密钥并在终端中定义它，或使用[python-dotenv](https://pypi.org/project/python-dotenv/)库。
- en: There are two methods to integrate with GPT models, one for the chat endpoint
    (`answer_to_prompt`) and one for the completion endpoint (`answer_to_simple_prompt`).
    We will focus on the usage of the first one.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有两种方法可以与GPT模型集成，一种用于聊天端点（`answer_to_prompt`），另一种用于完成端点（`answer_to_simple_prompt`）。我们将专注于第一个的使用。
- en: There is a method to check the goal of a conversation — `verify_goal_conversation`,
    which simply follows the instructions of agents and creates a summary of it.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一种方法来检查对话的目标——`verify_goal_conversation`，它简单地遵循代理的指示并生成总结。
- en: Designing the (Memory) Microservice
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计（内存）微服务
- en: 'The best exercise is to design and consequentially draw a diagram to visualize
    what the service needs to do, including the actors and their actions when interacting with it.
    Let’s start by describing our application in simple terms:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳练习是设计并绘制一个图表来可视化服务需要做的事情，包括参与者及其在与服务交互时的行动。我们从简单地描述我们的应用程序开始：
- en: Our microservice is a provider of artificially intelligent agents, which are
    experts on a subject and are expected to have conversations in response to an
    outbound message and following prompts.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的微服务是一个人工智能代理的提供者，这些代理在某一主题上是专家，预计会根据外部消息和后续提示进行对话。
- en: Our agents can hold multiple conversations and are packed with memory that is
    to be persisted, which means they must be able to retain the conversation history
    regardless of the session of the client who is interacting with the agents.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的代理可以进行多次对话，并且包含需要持久化的内存，这意味着它们必须能够保留对话历史记录，无论与代理交互的客户端会话如何。
- en: The agents should receive, at creation, clear instructions on how to handle
    a conversation and respond accordingly during the course of it.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理在创建时应接收清晰的指示，说明如何处理对话并在对话过程中做出相应响应。
- en: For programmatic integration, the agents should also follow an expected response
    shape.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于程序化集成，代理也应遵循预期的响应格式。
- en: 'Our design looks like the following diagram:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的设计如下图所示：
- en: '![](../Images/066900bb9a87cfd3c504036ad45705be.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/066900bb9a87cfd3c504036ad45705be.png)'
- en: Conversational Agents Design — Image by author
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对话代理设计——作者提供的图像
- en: 'With this simple diagram, we know that our microservice needs to implement
    methods that are responsible for these specific tasks:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个简单的图表，我们知道我们的微服务需要实现负责这些特定任务的方法：
- en: Creation of agents & definition of instructions
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代理的创建 & 指令的定义
- en: Conversation starter & preservation of conversation history
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对话启动器 & 对话历史记录的保存
- en: Chat with agents
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与代理聊天
- en: We will code these functionalities in their order, and before we dive into that
    we will build the skeleton of our application
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照顺序编写这些功能，在此之前我们将构建应用程序的骨架。
- en: Application Skeleton
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序骨架
- en: To kickstart the development, we begin by building the FastAPI app skeleton.
    The app skeleton consists of essential components, including the main application
    script, database configuration, processing script, and routing modules. The main
    script serves as the entry point for the application, where we set up the FastAPI
    instance.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动开发，我们首先构建FastAPI应用程序骨架。应用程序骨架包括基本组件，如主要应用程序脚本、数据库配置、处理脚本和路由模块。主要脚本作为应用程序的入口点，我们在此处设置FastAPI实例。
- en: '**Main File**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**主要文件**'
- en: Let’s create/open the `main.py` file in your `agents` folder and type the following
    code, which simply defines a root endpoint.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`agents`文件夹中创建/打开`main.py`文件并输入以下代码，该代码简单地定义了一个根端点。
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Database Configuration**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据库配置**'
- en: We then create/open the database configuration script called `database.py`,
    which establishes the connection to our local database for storing and retrieving
    conversation context. We will start by using a local SQLite for simplicity, but
    feel free to try other databases for your environment.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建/打开名为`database.py`的数据库配置脚本，该脚本建立与本地数据库的连接，用于存储和检索对话上下文。我们将首先使用本地SQLite以简化操作，但可以根据你的环境尝试其他数据库。
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**API Routes**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**API 路由**'
- en: Finally, we define routing modules that handle incoming HTTP requests, encompassing
    endpoints responsible for processing user interactions. Let’s create the `api`folder
    and create/open the `routes.py` file and paste the following code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义处理传入HTTP请求的路由模块，涵盖处理用户交互的端点。让我们创建`api`文件夹，创建/打开`routes.py`文件，并粘贴以下代码。
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With this structured skeleton, we are ready to start coding the application
    we designed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个结构化的骨架，我们已经准备好开始编写我们设计的应用程序。
- en: Create Agents and Assign Instructions
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建代理并分配指令
- en: 'In this section, we will focus on implementing the “**Create Agent”** endpoint.
    This endpoint enables users to initiate new conversations and interact with agents,
    providing a context and a set of instructions for the agent to follow throughout
    the rest of the conversation. We will start by introducing two Data Models for
    this process: One for the Database and another one for the API. We will be using
    [Pydantic](https://docs.pydantic.dev/latest/) for our data models. Create/Open
    the `schemas.py` file in the `api` folder, and define the Agent base, Agent Create,
    and Agent data model.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重点实现“**创建代理**”端点。此端点使用户能够启动新的对话并与代理互动，提供上下文和一组指令，以便代理在整个对话过程中遵循。我们将首先介绍两个数据模型：一个用于数据库，另一个用于API。我们将使用[Pydantic](https://docs.pydantic.dev/latest/)来创建数据模型。创建/打开`schemas.py`文件，并定义Agent
    base、Agent Create和Agent数据模型。
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The fields in the agent’s data model are detailed below:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: agent数据模型中的字段如下所述：
- en: '**Context**: This is an overall context of what the agent is.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文**：这是代理的整体背景。'
- en: '**First message**: Our agents are intended to start a conversation with the
    users. This can be as simple as “Hello, how can I help you?” or something like
    “Hi, you requested an agent to help you find information about stocks, is that
    correct?”.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**首条消息**：我们的代理旨在与用户开始对话。这可以简单到“你好，我可以帮你做什么？”或者类似“嗨，你请求一个代理来帮助你找到有关股票的信息，对吗？”。'
- en: '**Response shape**: This field is mainly used for specifying the output format
    of our agent’s response and should be used for transforming the text output of
    our LLM to a desired shape for programmatic communication. For example, we may
    want to specify that our agent should wrap the response in a JSON format with
    a key named `response`, i.e. `{''response'': "string"}`.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应格式**：该字段主要用于指定代理响应的输出格式，并应用于将LLM的文本输出转换为所需的格式，以便进行程序化通信。例如，我们可能希望指定我们的代理应该将响应包装在一个名为`response`的JSON格式中，即`{''response'':
    "string"}`。'
- en: '**Instructions:** This field holds the instructions and guidelines each agent
    should follow during the whole conversation, such as “Gather the following entities
    *[e1, e2, e3, …]* during each interaction” or “Reply to the user until he is no
    longer interested in the conversation” or “Don’t deviate from the main topic and
    drive the conversation back to the main goal when needed”.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指令**：该字段包含每个代理在整个对话过程中应遵循的指令和指南，例如“在每次交互中收集以下实体 *[e1, e2, e3, …]*”或“回复用户直到他不再对对话感兴趣”或“不要偏离主题，并在必要时将对话引导回主要目标”。'
- en: We now proceed to open the `models.py` file, where we will code our database
    table that belongs to the agent's entity.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在继续打开`models.py`文件，在其中编写属于agent实体的数据库表。
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code is pretty similar to the Pydantic model, it defines the table of the
    agent in our database.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与Pydantic模型非常相似，它定义了我们数据库中的代理表。
- en: 'With our two data models in place, we are ready to implement the creation of
    the Agent. For this, we will start by modifying the `routes.py` file and adding
    the endpoint:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们有了两个数据模型后，我们准备好实现代理的创建。为此，我们将首先修改`routes.py`文件，添加端点：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We need to create a new function that receives an Agent object from the request
    and creates it into the database. For this, we will create/open the `crud.py`
    file which will hold all the interactions to the database **(CREATE, READ, UPDATE,
    DELETE).**
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个新函数，该函数接收来自请求的Agent对象，并将其保存到数据库中。为此，我们将创建/打开`crud.py`文件，该文件将包含所有与数据库的交互**（创建、读取、更新、删除）**。
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With our function created, we can now go back to the`routes.py`, import the
    `crud` module, and use it in the endpoint’s method.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完函数后，我们现在可以回到`routes.py`，导入`crud`模块，并在端点方法中使用它。
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now let’s go back to the `main.py` file and add the “agents” router. The modifications
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到`main.py`文件，添加“agents”路由。修改
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let’s test this functionality. First, we will need to install our services as
    a Python package, secondly, start the application on port 8000.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下这个功能。首先，我们需要将我们的服务安装为 Python 包，其次，在 8000 端口启动应用程序。
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Navigate to [http://0.0.0.0:8000/docs](http://0.0.0.0:8000/docs), where you
    will see the Swagger UI with the endpoint to test. Submit your payload and check
    the output.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [http://0.0.0.0:8000/docs](http://0.0.0.0:8000/docs)，你将看到带有测试端点的 Swagger
    UI。提交你的负载并检查输出。
- en: '![](../Images/fccecb2f4b76bfdbc7bd9b27f97f9044.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/fccecb2f4b76bfdbc7bd9b27f97f9044.png)'
- en: create-agent endpoint from Swagger UI — Image by author
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: create-agent 端点来自 Swagger UI — 图片由作者提供
- en: We will continue developing our application, but testing the first endpoint
    is a good sign of progress.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续开发我们的应用程序，但测试第一个端点是进展的良好标志。
- en: Create Conversations & Preserve Conversation History
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建对话 & 保留对话历史
- en: 'Our next step is to allow users to interact with our agents. We want users
    to interact with specific agents, so we will need to pass the ID of the agent
    along with the first interaction message from the user. Let’s make some modifications
    to the Agent data model so each agent can have multiple conversations by introducing
    the `Conversation` entity. Open the `schemas.py` file and add the following models:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是允许用户与我们的代理进行交互。我们希望用户能够与特定的代理进行互动，因此我们需要传递代理的 ID 以及用户的第一次互动消息。让我们对 Agent
    数据模型进行一些修改，通过引入 `Conversation` 实体，使每个代理能够进行多个对话。打开 `schemas.py` 文件并添加以下模型：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that we have modified the `Agent` data model and added conversations to
    it, this is so each agent can hold multiple conversations as designed in our diagram.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经修改了 `Agent` 数据模型，并添加了对话功能，以便每个代理可以根据我们的图表设计进行多个对话。
- en: 'We have to modify our database object and include the conversation table in
    the database model script. We will open the `models.py` file and modify the code
    as follow:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改我们的数据库对象，并在数据库模型脚本中包含对话表。我们将打开 `models.py` 文件，并按如下方式修改代码：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note how we added the relationship between the conversations per each agent
    in the `agents` table, and also the relationship between a conversation with an
    agent in the `conversations` table.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们在 `agents` 表中为每个代理添加了对话之间的关系，以及在 `conversations` 表中对话与代理之间的关系。
- en: 'We will now create a set of CRUD functions to retrieve the agent and conversations
    by their IDs, which will help us to craft our process of creating a conversation
    and preserving its history. Let’s open the `crud.py` file and add the following
    functions:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建一组 CRUD 函数，以通过它们的 ID 检索代理和对话，这将帮助我们制定创建对话和保留对话历史的过程。让我们打开 `crud.py` 文件并添加以下函数：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: These new functions will help us during the normal workflow of our application,
    we can now get an agent by its ID, get a conversation by its ID, and create a
    conversation by providing an ID as optional, and the agent ID that should hold
    the conversation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新函数将帮助我们在应用程序的正常工作流程中，现在我们可以通过 ID 获取代理，通过 ID 获取对话，并通过提供可选的 ID 和应持有对话的代理 ID
    来创建对话。
- en: 'We can go ahead and create an endpoint that creates a conversation. Open the
    `routes.py` and add the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续创建一个创建对话的端点。打开 `routes.py` 并添加以下代码：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With this method ready we are still one step away from having an actual conversational
    endpoint, which we will review next.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法准备好后，我们仍然离拥有实际的对话端点还差一步，我们将在下一节中进行回顾。
- en: It is important to make a distinction here when we initialize an agent, we can
    create a conversation without triggering a two-way exchange of messages or another
    way is to trigger the creation of a conversation when the “**Chat with an agent**”
    endpoint is called. This provides some flexibility in orchestrating the workflows
    outside the microservice, in some cases you may want to initialize the agents,
    pre kick-off conversations to clients and as messages start to come in, you start
    preserving the history of the messages.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化代理时，重要的是要做出区分，我们可以创建一个对话而不触发双向消息交换，另一种方式是当调用“**与代理聊天**”端点时触发对话的创建。这为在微服务外部组织工作流提供了一些灵活性，在某些情况下，你可能想初始化代理，提前启动与客户的对话，并随着消息的到来开始保留消息的历史记录。
- en: '![](../Images/3d0777673ee2498ca60aac063e7d35d5.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3d0777673ee2498ca60aac063e7d35d5.png)'
- en: create-conversation endpoint from Swagger UI — Image by author
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: create-conversation 端点来自 Swagger UI — 图片由作者提供
- en: '**Important Note:** if you are following step by step this guide and see an
    error related to the database schema in this step, it is because we are not applying
    migrations to the database with each modification of the schemas, so make sure
    you close the application (exit the terminal command) and delete the `agents.db`
    file that is created at runtime. You will need to run each endpoint again and
    take notes of the IDs.'
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示：** 如果您按照本指南逐步操作，并且在此步骤中看到与数据库模式相关的错误，请注意，这是因为我们在每次修改模式时都未将迁移应用到数据库，因此请确保关闭应用程序（退出终端命令）并删除在运行时创建的`agents.db`文件。
    您需要重新运行每个端点并记录ID。'
- en: Chat with an agent
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与代理人聊天
- en: 'We are going to introduce the last entity type in our application which is
    the `Message` entity. This one is responsible for modeling the interaction between
    a client’s message and an agent’s message (two-way exchange of messages). We will
    also add API data models that are used to define the structure of the response
    of our endpoints. Let’s go ahead and create the data models and API response types
    first; open the `schemas.py` file, and modify the code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在要介绍我们应用程序中的最后一个实体类型，即`Message`实体。 这个实体负责建模客户消息和代理消息之间的交互（消息的双向交换）。 我们还将添加用于定义端点响应结构的API数据模型。
    让我们先创建数据模型和API响应类型; 打开`schemas.py`文件，并修改代码：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We now have to add the data model in our database models script which represents
    the table in our database. Open the `models.py` file and modify as below:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须在代表数据库中表的数据库模型脚本中添加数据模型。 打开`models.py`文件并修改如下：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that we have modified our `Conversations` table to define the relationship
    between messages and conversation and we created a new table that represents the
    interactions (exchange of messages) that should belong to a conversation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已修改了`Conversations`表以定义消息与会话之间的关系，并创建了一个新表，表示应属于对话的交互（消息交换）。
- en: 'We are now going to add a new CRUD function to interact with the database and
    create a message for a conversation. Let’s open the `crud.py` file and add the
    following function:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将向数据库添加一个新的CRUD函数，以与数据库交互并为对话创建消息。 打开`crud.py`文件并添加以下函数：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now we are ready to build the final and most interesting endpoint, the **chat-agent**
    endpoint. Let’s open the `routes.py` file and follow the code along as we will
    be implementing some processing functions on the way.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备构建最终和最有趣的端点，**chat-agent**端点。 打开`routes.py`文件，并按照代码进行操作，因为我们将在途中实施一些处理函数。
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '{'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: '"conversation_id": "string",'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`"conversation_id": "string",'
- en: '"response": "string"'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`"response": "string"'
- en: '}'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE24]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this section of the endpoint, we are making sure to create or raise an exception
    if the conversation does not exist. The next step is to prepare the data that
    will be sent to OpenAI via our integration, for this we will create a set of processing
    functions in the `processing.py` file that will craft the context, first message,
    instructions, and expected response shape from the LLM.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在端点的这一部分中，我们确保在对话不存在时创建或引发异常。 下一步是准备数据，将其通过我们的集成发送到OpenAI，为此，我们将在`processing.py`文件中创建一组处理函数，这些函数将从LLM中制作上下文，第一条消息，说明和预期的响应形状。
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note the last function that expects the `response_shape` defined during the
    creation of the agent, this input will be appended to the LLM during the course
    of a conversation and will guide the agent to follow the guidelines and return
    the response as a JSON object.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意最后一个函数期望在代理人创建过程中定义的`response_shape`，此输入将在对话过程中附加到LLM，并指导代理人遵循指南并将响应作为JSON对象返回。
- en: 'Let’s go back to the `routes.py` file and finish our endpoint implementation:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们返回`routes.py`文件并完成我们的端点实现：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '{'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: '"conversation_id": "string",'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`"conversation_id": "string",'
- en: '"response": "string"'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`"response": "string"'
- en: '}'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE27]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Voilà! This is our final endpoint implementation, if we look at the **Notes**
    added to the code, we see that the process is quite straightforward:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Voilà！ 这是我们最终的端点实现，如果我们查看代码中添加的**Notes**，我们会发现这个过程非常简单：
- en: We make sure the conversation exists in our database (or we create one)
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们确保在我们的数据库中存在对话（或者我们创建一个）
- en: We craft the context and instructions to the agent from our database
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从数据库中制作上下文和指导代理人
- en: We make use of the “memory” of the agent by pulling the conversation history
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过获取代理人的对话历史来利用代理人的“记忆”
- en: Finally, we request the agent response through OpenAI’s GPT-3.5 Turbo model
    and return the response to the client.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们通过 OpenAI 的 GPT-3.5 Turbo 模型请求代理的响应，并将响应返回给客户端。
- en: Local Testing Our Agents
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地测试我们的代理
- en: 'Now we are ready to test the complete workflow of our microservice, we will
    start by going to our terminal and typing `uvicorn agents.main:app — host 0.0.0.0
    — port 8000 — reload` to launch the app. Next, we will navigate to our Swagger
    UI by going to [http://0.0.0.0:8000/docs](http://0.0.0.0:8000/docs) and we will
    submit the following requests:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备测试微服务的完整工作流，我们将首先进入终端，输入 `uvicorn agents.main:app — host 0.0.0.0 — port
    8000 — reload` 启动应用程序。接下来，我们将通过访问 [http://0.0.0.0:8000/docs](http://0.0.0.0:8000/docs)
    进入 Swagger UI 并提交以下请求：
- en: 'Create the agent: Give a payload that you’d like to test. I will submit the
    following:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建代理：提供你想测试的有效负载。我将提交以下内容：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create the conversation: assign the conversation to the `agent_id` one that
    you have gotten from the previous response.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建对话：将对话分配给从上一个响应中获取的 `agent_id`。
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let’s chat with our agent through the outbound message: Our agent will initialize
    the conversation by asking us a question or approaching us with a message. We
    will follow the conversation by submitting a message back — I’ll use this one:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们通过外发消息与我们的代理聊天：我们的代理将通过提问或发送消息来初始化对话。我们将通过回复消息来继续对话 — 我将使用以下消息：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![](../Images/ab0c299002e37eaffcb9d1cc4e592c31.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ab0c299002e37eaffcb9d1cc4e592c31.png)'
- en: chat-agent endpoint response from Swagger UI — Image by author
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: chat-agent 端点响应来自 Swagger UI — 图片由作者提供
- en: Our agent replied to us with a response and we can continue this conversation
    by replying in a natural way.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代理给我们回复了响应，我们可以通过自然的方式继续这个对话。
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Go ahead and play around with the code and your new agents. In the next section,
    I will focus on the deployment of this service.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 继续尝试代码和新的代理。在下一部分，我将重点介绍服务的部署。
- en: The Deployment Cycle
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署周期
- en: 'We will deploy our application under a container environment in the cloud such
    as Kubernetes, Azure Container Service, or AWS Elastic Container Service. Here
    is where we create a docker image and upload our code so we can run it in one
    of these environments, go ahead and open the `Dockerfile` one we created at the
    start and paste the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在云的容器环境中部署应用程序，例如 Kubernetes、Azure Container Service 或 AWS Elastic Container
    Service。在这里，我们创建一个 docker 镜像并上传代码，以便在这些环境中的一个中运行，继续打开我们一开始创建的 `Dockerfile`，并粘贴以下代码：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The Dockerfile installs the app and then it runs it via the CMD which is commented
    out. You should uncomment the command if you want to run it locally as a standalone,
    but for other services such as Kubernetes, this is defined when defining the deployment
    or pods in the command section of the manifest.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 安装应用程序，然后通过 CMD 运行它，但 CMD 被注释掉了。如果你想作为独立应用本地运行，应该取消注释该命令，但对于 Kubernetes
    等其他服务，这在定义部署或清单中的 pods 时已经定义。
- en: 'Build the image, wait until the build is completed, and then test it by running
    the run command, which is below:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 构建镜像，等待构建完成，然后通过运行下面的运行命令进行测试：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Great you are ready to start using the application in your deployment environment.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，你准备好在你的部署环境中开始使用应用程序了。
- en: Finally, we will try to integrate this microservice with a front-end application
    that will serve the agents and the conversations by calling the endpoints internally,
    which is the common way of building and interacting between services using this
    architecture.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将尝试将这个微服务与前端应用程序集成，通过内部调用端点来服务代理和对话，这是使用这种架构构建和交互服务的常见方式。
- en: The Usage Cycle
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用周期
- en: We can use this new service in multiple ways, and I will only focus on building
    a front-end application that calls the endpoints from our agents and makes it
    possible for users to interact via a UI. We will use [Streamlit](https://streamlit.io/)
    for this, as it is a simple way to spin up a front-end using Python.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以多种方式使用这个新服务，我将重点关注构建一个前端应用程序，该应用程序调用我们的代理端点，使用户能够通过 UI 进行交互。我们将使用 [Streamlit](https://streamlit.io/)
    来实现，因为它是使用 Python 快速搭建前端的简单方法。
- en: '**Important Note:** There are additional utilities that I added to our agents’
    service that you can copy directly from the repository. Search for `get_agents()`
    ,`get_conversations()`, `get_messages()` from the `crud.py` module and the `api/routes.py`
    routes.'
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要说明：** 我在我们的代理服务中添加了额外的工具，你可以直接从代码库中复制这些工具。搜索 `get_agents()`、`get_conversations()`、`get_messages()`
    这几个函数，分别在 `crud.py` 模块和 `api/routes.py` 路由中查找。'
- en: '**Install Streamlit** and add it to our requirements.txt.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安装 Streamlit** 并将其添加到我们的 requirements.txt 文件中。'
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '**Create the application** by creating first a folder in our `src` folder with
    the name `frontend`. Create a new file named `main.py` and place the following
    code.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建应用程序** 首先在我们的 `src` 文件夹中创建一个名为 `frontend` 的文件夹。创建一个名为 `main.py` 的新文件，并放入以下代码。'
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The code below connects to our agent's microservice via API calls and allows
    the user to select the Agent and the Conversations and chat with the agent, similar
    to what ChatGPT provides. Let’s run this app by opening another terminal (make
    sure you have the agents microservice up and running on port 8000) and type `$
    streamlit run src/frontend/main.py` and you are ready to go!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码通过 API 调用连接到我们的代理微服务，并允许用户选择代理和对话，与代理聊天，类似于 ChatGPT 提供的功能。让我们通过打开另一个终端来运行这个应用程序（确保你的代理微服务在
    8000 端口上运行），然后输入 `$ streamlit run src/frontend/main.py`，你就可以开始了！
- en: '![](../Images/0419fd4efca131f9a2bcf34f395b163d.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0419fd4efca131f9a2bcf34f395b163d.png)'
- en: AI Chat Streamlit App — Image by author
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: AI 聊天 Streamlit 应用程序 — 作者提供的图片
- en: Future Improvements and Conclusion
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未来改进和总结
- en: Future Improvements
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未来改进
- en: There are several exciting opportunities for enhancing our Conversational Agent
    with a memory microservice. These improvements introduce advanced capabilities
    that can extend user interactions and expand the scope of our applications or
    overall system.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个令人兴奋的机会可以通过引入记忆微服务来增强我们的对话代理。这些改进引入了先进的功能，可以延长用户交互的时间，并扩展我们应用程序或整体系统的范围。
- en: '**Enhanced Error Handling:** To ensure robust and reliable conversations, we
    could implement code to gracefully handle unexpected user inputs, API failures
    — dealing with OpenAI or other services, and potential issues that could arise
    during real-time interactions.'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**增强的错误处理：** 为了确保对话的稳健性和可靠性，我们可以实现代码来优雅地处理意外的用户输入、API 失败——处理 OpenAI 或其他服务的问题，以及在实时交互中可能出现的潜在问题。'
- en: '**Integrated Buffers and Conversation Summaries:** The integration of buffers
    implemented by the LangChain framework, offers the potential to optimize token
    management, enabling conversations to span more extended periods without running
    into token limitations. Additionally, incorporating conversation summaries allows
    users to review the ongoing discussion, aiding in context retention and improving
    the overall user experience. *Take note of the agent instructions and the response
    shape to extend this easily in our code*.'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**集成缓冲区和对话总结：** 由 LangChain 框架实现的缓冲区集成，有可能优化令牌管理，使对话能够在更长的时间内进行而不会遇到令牌限制。此外，集成对话总结可以让用户回顾正在进行的讨论，帮助保持上下文，并改善整体用户体验。*请注意代理指令和响应形状，以便在我们的代码中轻松扩展此功能*。'
- en: '**Data-aware Applications:** We could create agents with unique and internal
    knowledge by connecting our agents’ models to other sources of data such as internal
    databases. This involves training or integrating models that can understand and
    respond to complex queries based on an understanding of your organization’s unique
    data and information — Check [LangChain’s data connection](https://python.langchain.com/docs/modules/data_connection/)
    modules.'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据感知应用：** 我们可以通过将我们的代理模型连接到其他数据源，例如内部数据库，来创建具有独特内部知识的代理。这涉及到训练或集成能够理解和响应基于对组织独特数据和信息理解的复杂查询的模型——请查看
    [LangChain 的数据连接](https://python.langchain.com/docs/modules/data_connection/)
    模块。'
- en: '**Model Diversification:** While we’ve only used OpenAI’s GPT-3.5 model, the
    landscape of language model providers is expanding rapidly. Testing models from
    other providers can lead to comparative analysis, uncovering strengths and weaknesses,
    and enabling us to choose the best fit for specific use cases — Try playing with
    different LLM integrations such as [HuggingFace](https://huggingface.co/models?other=LLM),
    [Cohere](https://cohere.com/), [Google’s](https://developers.generativeai.google/products/palm),
    etc.'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模型多样化：** 虽然我们只使用了 OpenAI 的 GPT-3.5 模型，但语言模型提供商的格局正在迅速扩展。测试其他提供商的模型可以进行比较分析，揭示优缺点，并使我们能够选择最适合特定用例的模型——尝试不同的
    LLM 集成，例如 [HuggingFace](https://huggingface.co/models?other=LLM)、[Cohere](https://cohere.com/)、[Google’s](https://developers.generativeai.google/products/palm)
    等。'
- en: Conclusion
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: We have developed a microservice that provides intelligent agents powered by
    OpenAI GPT models and have proven how these agents can be packed with memory that
    lives outside of the client’s session. By adopting this architecture, we have
    unlocked a world of possibilities. From context-aware conversations to seamlessly
    integrating with sophisticated language models, our stack has become capable of
    providing new features to our products.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开发了一个微服务，提供由 OpenAI GPT 模型驱动的智能代理，并证明了这些代理可以携带存储在客户端会话之外的记忆。通过采用这种架构，我们解锁了无限的可能性。从上下文感知对话到与复杂语言模型的无缝集成，我们的技术栈已经能够为我们的产品提供新功能。
- en: This implementation and the tangible benefits of it, make it clear that using
    AI is at the hands of anyone with the right tools and approach. The use of **AI-powered
    agents is not only about prompt engineering** but how we build tools and engage
    with them more effectively, offering personalized experiences, and tackling complex
    tasks with the finesse and precision that AI and software engineering can provide.
    So, whether you’re building a customer support system, a sales virtual assistant,
    a personal chef, or something entirely new, remember that the journey starts with
    a touch of code and an abundance of imagination — The possibilities are limitless.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现及其实际好处表明，使用 AI 的关键在于拥有合适的工具和方法。**AI 驱动的代理不仅仅是关于提示工程**，还在于我们如何构建工具并更有效地与它们互动，提供个性化体验，并以
    AI 和软件工程所能提供的精细和精准处理复杂任务。因此，无论你是在构建客户支持系统、销售虚拟助手、个人厨师还是其他全新事物，请记住，旅程始于一段代码和丰富的想象力——可能性是无限的。
- en: '*The whole code for this article is in* [*GitHub*](https://github.com/cfloressuazo/conversational-ai)
    *— You can find me on* [*LinkedIn*](https://www.linkedin.com/in/cfloressuazo/)*,
    feel free to connect!*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*本文的完整代码在* [*GitHub*](https://github.com/cfloressuazo/conversational-ai) *上——你可以在*
    [*LinkedIn*](https://www.linkedin.com/in/cfloressuazo/)*上找到我，欢迎随时联系！*'
