- en: 'Python Classes Made Easy: The Definitive Guide to Object-Oriented Programming'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 《Python 类简易入门：面向对象编程的权威指南》
- en: 原文：[https://towardsdatascience.com/python-classes-made-easy-the-definitive-guide-to-object-oriented-programming-881ed609fb6](https://towardsdatascience.com/python-classes-made-easy-the-definitive-guide-to-object-oriented-programming-881ed609fb6)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/python-classes-made-easy-the-definitive-guide-to-object-oriented-programming-881ed609fb6](https://towardsdatascience.com/python-classes-made-easy-the-definitive-guide-to-object-oriented-programming-881ed609fb6)
- en: Boost your Python skills with this comprehensive class reference
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过这本全面的类参考书提升你的 Python 技能
- en: '[](https://federicotrotta.medium.com/?source=post_page-----881ed609fb6--------------------------------)[![Federico
    Trotta](../Images/e997e3a96940c16ab5071629016d82fd.png)](https://federicotrotta.medium.com/?source=post_page-----881ed609fb6--------------------------------)[](https://towardsdatascience.com/?source=post_page-----881ed609fb6--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----881ed609fb6--------------------------------)
    [Federico Trotta](https://federicotrotta.medium.com/?source=post_page-----881ed609fb6--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://federicotrotta.medium.com/?source=post_page-----881ed609fb6--------------------------------)[![Federico
    Trotta](../Images/e997e3a96940c16ab5071629016d82fd.png)](https://federicotrotta.medium.com/?source=post_page-----881ed609fb6--------------------------------)[](https://towardsdatascience.com/?source=post_page-----881ed609fb6--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----881ed609fb6--------------------------------)
    [Federico Trotta](https://federicotrotta.medium.com/?source=post_page-----881ed609fb6--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----881ed609fb6--------------------------------)
    ·18 min read·Mar 13, 2023
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·发布于 [Towards Data Science](https://towardsdatascience.com/?source=post_page-----881ed609fb6--------------------------------)
    ·阅读时间 18 分钟·2023年3月13日
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/243dd67262bbc8d50ada6050e9cb8725.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/243dd67262bbc8d50ada6050e9cb8725.png)'
- en: Image by [Lukas Bieri](https://pixabay.com/it/users/lukasbieri-4664461/?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=2838945)
    on [Pixabay](https://pixabay.com/it//?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=2838945)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由 [Lukas Bieri](https://pixabay.com/it/users/lukasbieri-4664461/?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=2838945)
    提供，来源于 [Pixabay](https://pixabay.com/it//?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=2838945)
- en: When it comes to classes, many Python developers struggle, for a lot of reasons.
    Firstly — in my opinion — because the concept of Object Oriented Programming is
    not always clear. Secondly, because the ideas behind classes and Object Oriented
    Programming (OOP) are a lot and the explanations we may find here and there (mainly,
    online) may be superficial.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到类时，许多 Python 开发者会遇到困难，原因有很多。首先——在我看来——因为面向对象编程的概念并不总是清晰。其次，因为类和面向对象编程（OOP）背后的想法有很多，我们可能在网上找到的解释（主要是在线的）可能是肤浅的。
- en: In this article, I want to cover the most important concepts behind Python classes,
    and how to use them (with coding examples).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇文章中，我想讨论 Python 类背后的最重要概念，以及如何使用它们（附带编码示例）。
- en: But, firstly, we’ll start this article by discussing Object Oriented Programming.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将通过讨论面向对象编程来开始这篇文章。
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Object Oriented Programming
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: 'Quoting and paraphrasing reference [1], we can say that, as Humans, we are
    perfectly aware of what objects are: they are everything tangible that can be
    felt with our senses and that can be manipulated. During our growth, we learn
    the power of abstraction and objects become models. In other words, we use our
    imagination, developed in years of experience, to simplify complex problems using
    simple concepts: this is the process of abstraction using models.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 引用和改写参考文献 [1]，我们可以说，作为人类，我们完全知道对象是什么：它们是所有可以用我们的感官感受到并且可以被操控的实物。在我们的成长过程中，我们学习了抽象的力量，对象变成了模型。换句话说，我们利用在多年的经验中培养出的想象力，通过简单的概念来简化复杂的问题：这就是使用模型进行抽象的过程。
- en: For example, we may model the Earth as a sphere (even if it is not a sphere!)
    to perform some calculations (for example, to determine its orbit).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，我们可以将地球建模为一个球体（即使它不是一个球体！）以进行一些计算（例如，确定它的轨道）。
- en: This is not so much different from what we do in software development. In fact,
    for us developers, an object is not something that we can touch or feel, but it
    is a model of something that performs some software tasks.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在软件开发中所做的并没有太大不同。实际上，对我们开发者来说，对象并不是我们可以触摸或感受到的东西，而是执行一些软件任务的模型。
- en: More precisely, for us, we can say that an “**object is a collection of data
    with associated behaviors”**. [1]
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 更准确地说，我们可以说“**对象是具有相关行为的数据集合**”。[1]
- en: Let’s make an example to clarify the concept (we paraphrase reference [1] for
    the following example).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个例子来澄清这个概念（我们将参考文献[1]进行改述）。
- en: We want to create an object called “Apple”. In this case, the data associated
    with it can be the color (for example, red). The behavior associated with it can
    be the fact that we want to put the apple in a basket.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想创建一个名为“Apple”的对象。在这种情况下，与之相关的数据可以是颜色（例如，红色）。与之相关的行为可以是我们想把苹果放进篮子里。
- en: '![](../Images/e2889484a0f35e62ba4d355c627d85c1.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e2889484a0f35e62ba4d355c627d85c1.png)'
- en: An object in software development. Image by Author.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发中的一个对象。图片由作者提供。
- en: 'Now, what if we encounter a green apple? It is still an apple, but with a different
    color: can we use this concept? Here’s where classes come into help!'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们遇到一个绿色的苹果怎么办？它仍然是苹果，只是颜色不同：我们可以使用这个概念吗？这就是类发挥作用的地方！
- en: A class is a “template” that defines the structure of an object. This means
    that an object has its own particular set of attributes, regarding a certain class.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 类是定义对象结构的“模板”。这意味着对象有自己特定的一组属性，涉及某个类。
- en: 'To use the example of the apple, we can say that the class Apple can have:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以苹果为例，我们可以说类Apple可以包含：
- en: Data → the color
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据 → 颜色
- en: Behavior → where to put the apple
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为 → 苹果放置的位置
- en: With this template, we can create how many objects we want. For example, we
    can create the object `Apple_green`that uses the class apple with `color=green`
    as data, and that puts the apples in the basket on the table.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个模板，我们可以创建任意多个对象。例如，我们可以创建对象`Apple_green`，它使用了带有`color=green`的数据的类apple，并把苹果放到桌上的篮子里。
- en: We can also have an object called `Apple_red` that uses the class apple with
    `color=red` as data and that puts the apples back on the shelf.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以有一个名为`Apple_red`的对象，它使用了带有`color=red`的数据的类apple，并把苹果放回到货架上。
- en: '![](../Images/207782f109e88953cecbec06ec522b17.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/207782f109e88953cecbec06ec522b17.png)'
- en: The difference between an object and a class. Image by Author.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对象与类之间的区别。图片由作者提供。
- en: So, as we can understand with the example of the apples, we can say that data
    represent a specific characteristic of a certain object.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，正如我们通过苹果的例子所理解的那样，我们可以说数据代表了某个对象的特定特征。
- en: Behaviors, on the other hand, represent actions; these actions are expressed
    as methods of the class, in Python. And, as we’ll see later, a method of a class
    is defined the same way we define a function.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 行为则代表动作；这些动作在Python中作为类的方法表达。正如我们稍后会看到的，类的方法的定义方式与定义函数的方式相同。
- en: 'So: what is Object Oriented Programming?'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 那么：什么是面向对象编程？
- en: OOP is “the practice of writing code towards modeling object” [1].
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: OOP是“将代码编写为建模对象的实践” [1]。
- en: In other words, it means creating a series of interacting objects through their
    data and behaviors.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这意味着通过数据和行为创建一系列交互的对象。
- en: 'This does not mean that we’ll always have to create classes when we program
    in Python. Here we have to understand a simple concept: the power of Python relies
    on the fact that **everything** in this programming language **is an object**.
    In fact, even if we can’t see it, we are working with objects and classes under
    the hood in Python.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着在Python编程时我们总是需要创建类。这里我们需要理解一个简单的概念：Python的强大之处在于**一切**在这个编程语言中**都是对象**。实际上，即使我们看不到，我们在Python中实际上是在处理对象和类。
- en: 'For example, let’s say we define a variable`a = 3`. If we want to see its type
    we can write the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们定义一个变量`a = 3`。如果我们想查看它的类型，可以写以下代码：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have used the built-in function `type()` to determine the properties of the
    variable `a` and it told us that this is an `int` (that is to say, an integer).
    But `int` is a Python built-in class; this means that in Python we can define
    an integer variable, as we have seen above, without creating an actual class because
    Python does so for us (in other programming languages, we’d actually have to create
    a class for such a simple example).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了内置函数`type()`来确定变量`a`的属性，它告诉我们这是一个`int`（也就是整数）。但`int`是Python内置类；这意味着在Python中，我们可以定义一个整数变量，如上所示，而无需创建实际的类，因为Python为我们做了这件事（在其他编程语言中，我们实际上需要为如此简单的示例创建一个类）。
- en: 'So, let’s remember: whenever we program in Python, we always have to deal with
    objects and classes even if we don''t explicitly declare them because Python,
    under the hood, does the work to invoke built-in classes.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们记住：无论何时编程 Python，我们总是必须处理对象和类，即使我们没有显式声明它们，因为 Python 在后台会完成调用内置类的工作。
- en: Classes in Python
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 中的类
- en: 'In Python, classes must be defined with a capital letter. Here’s how we can
    define a simple class:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，类必须以大写字母定义。下面是如何定义一个简单类的示例：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We have created a simple class that sets `a=15`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个简单的类，它设置了`a=15`。
- en: 'Now, let’s make a class that actually does something more useful by adding
    a method (note: the class `Point` we’ll use throughout this article is taken from
    reference [1], and is modified as per my taste and needs):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过添加一个方法来创建一个实际做些有用工作的类（注：本文中使用的`Point`类取自参考文献[1]，并根据我的口味和需求进行了修改）：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So, we’ve created a class called `Point`with a method, called `origin`, that
    does a simple thing: it gets a point in 2D to `x=0`and `y=0` (the origin).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们创建了一个名为`Point`的类，并有一个名为`origin`的方法，它做了一件简单的事情：将二维坐标点设为`x=0`和`y=0`（原点）。
- en: 'Now, as we can see, the method passes one argument called `self`. This can
    be called as we want but, as a standard, the community of Python developers calls
    it `self`: we’ll explain more details later on how it works.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如我们所见，该方法传递了一个名为`self`的参数。我们可以按需调用它，但作为标准，Python 开发者社区称之为`self`：我们稍后会更详细地解释它是如何工作的。
- en: 'Now, if we want to invoke the class, we can define a point `p` and do the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想调用类，我们可以定义一个点`p`并执行以下操作：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we can access the method defined in the class by writing:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过编写以下内容来访问类中定义的方法：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'So, now our point has gone to the origin. To be sure, we can do the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们的点已经到了原点。为了确保，我们可以做以下操作：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The “self” Parameter
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “self”参数
- en: Now, let’s explain what the previously introduced `self` argument is, and how
    to use it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们解释一下之前介绍的`self`参数是什么，以及如何使用它。
- en: 'The `self` argument serves to invoke the method. This is why we call it `self`
    as a standard: because we are invoking the method. It’s like we are telling Python:
    “Ehy! This method is self-invoked”.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`self`参数用于调用方法。这就是为什么我们将其称为`self`作为标准的原因：因为我们在调用方法。这就像我们在告诉 Python：“嘿！这个方法是自我调用的”。'
- en: 'When we need to pass multiple arguments to a method, `self` must be the first
    one: otherwise, another parameter will invoke the method (as we said, there is
    no need to call it `self`: this name is just a convention between developers).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要将多个参数传递给方法时，`self`必须是第一个参数：否则，另一个参数将调用该方法（正如我们所说，不需要将其命名为`self`：这个名字只是开发者之间的惯例）。
- en: Let’s see an example where we use `self` and compare it to another where we
    don’t use it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个使用`self`的示例，并与另一个不使用它的示例进行比较。
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'So, we’ve created a simple class that, when we invoke the method `printing`,
    prints “this is a test”:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们创建了一个简单的类，当我们调用`printing`方法时，它会打印“this is a test”：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let’s see the example without `self`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看没有`self`的示例：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'So, in this case, Python returns an error that is telling us a simple thing:
    the method can’t be invoked because it has no arguments.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在这种情况下，Python 返回一个错误，告诉我们一个简单的事情：方法不能被调用，因为它没有参数。
- en: This is why we need `self`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要`self`的原因。
- en: 'Now, let’s create a function with multiple arguments:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个具有多个参数的函数：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We have created a class that:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个类，该类：
- en: moves two coordinates (`x`and `y`). As we can see, `self` invokes the method.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动两个坐标（`x`和`y`）。正如我们所见，`self`调用了该方法。
- en: gets the coordinates to the origin. When we invoke the `origin` method, in fact,
    it will move both the coordinates (its only argument is `self`) to the origin
    ( `self.move(0, 0)`), and returns the coordinates.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将坐标移到原点。当我们调用`origin`方法时，它实际上会将两个坐标（它唯一的参数是`self`）移动到原点（`self.move(0, 0)`），并返回坐标。
- en: 'So, we can invoke the class and move the coordinates to the origin:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们可以调用类并将坐标移动到原点：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: And the coordinates have gone to the origin.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 而且坐标已经移到了原点。
- en: 'Now, let’s read some lines back: we said that the `move`method moves the coordinates,
    but this is not true. The actual movement is done by the method `origin`.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下之前的几行：我们说`move`方法移动了坐标，但这并不准确。实际的移动是由`origin`方法完成的。
- en: 'In fact, the `move` method does just a simple thing: it invokes the needed
    values. This is why the first method of a class has a special nomenclature.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`move` 方法只做了一件简单的事情：它调用了所需的值。这就是为什么一个类的第一个方法有特殊命名规则的原因。
- en: The “__init__” Method
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “__init__”方法
- en: So far, we have created a class that moves the coordinates of a point (`x` and
    `y`) to the origin. But what if we want to move the point to any particular position
    we may want?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们创建了一个将点的坐标（`x`和`y`）移动到原点的类。但如果我们想将点移动到任何特定位置怎么办？
- en: 'To do so, we have to create another class. For our first try, let’s create
    it with the same logic used before. It can be something like that:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要创建另一个类。第一次尝试时，让我们用之前使用的相同逻辑创建它。可以是这样的：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let’s invoke the class and the method:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们调用类和方法：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: And…we’ve got an error! And it tells us that the class `Point`takes no argument.
    How is that possible? We have specified to pass `self`, `x`, and `y`; so, apart
    from `self` that invokes the method, the class should accept two values!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后……我们遇到一个错误！它告诉我们`Point`类不接受任何参数。这怎么可能？我们已经指定了传递`self`、`x`和`y`；所以，除了`self`调用方法之外，类应该接受两个值！
- en: 'The error is in the first method. As we’ve said in the previous paragraph,
    the first method does only one thing: it invokes the needed values. It doesn’t
    move the point to a specific location.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 错误在于第一个方法。正如我们在上一段中所说，第一个方法只做一件事：它调用所需的值。它不会将点移动到特定位置。
- en: 'This is the reason why the first method of a class must be a specific method
    called `__init__`. So, to properly invoke the needed values, we have to create
    the `Point`class as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么一个类的第一个方法必须是一个叫做`__init__`的特殊方法的原因。因此，为了正确调用所需的值，我们必须按如下方式创建`Point`类：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, let’s invoke it:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们调用它：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: And here we are!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If __name__ == ”__main__”
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果 __name__ == ”__main__”
- en: Now, at the end of some classes, we may have found `if __name__ == "__main__"`.
    If you don’t know what it is, here is a wide explanation.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在某些类的末尾，我们可能会看到`if __name__ == "__main__"`。如果你不知道这是什么，这里有一个详细的解释。
- en: 'Quoting and paraphrasing from [2]:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 引用并改述自[2]：
- en: '`__name__` is a special built-in variable we have to use when we create interactable
    modules because it allows us to make a distinction between the modules we import
    and the modules we don’t.'
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`__name__`是一个特殊的内置变量，我们在创建可交互模块时必须使用它，因为它允许我们区分我们导入的模块和我们没有导入的模块。'
- en: ''
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: By module, in Python, we intend packages and libraries, but even any piece of
    code that is separable from other code and that can work on its own. Given that
    classes (but even functions, or even any Python file) can work on their own, they
    can be considered modules.
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在Python中，模块指的是包和库，甚至是任何可以与其他代码分离并独立运行的代码片段。鉴于类（甚至函数，或任何Python文件）可以独立运行，它们可以被认为是模块。
- en: ''
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`__main__`, on the other hand, is a special module that represents the name
    of the top-level code in a script or program.'
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`__main__`另一方面是一个特殊的模块，表示脚本或程序中的顶级代码的名称。'
- en: ''
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So, basically, if we execute `if __name__ = "__main__"` we are checking if the
    code we are executing is top-level or not.
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 基本上，如果我们执行`if __name__ = "__main__"`，我们是在检查我们执行的代码是否是顶级代码。
- en: So, what is top-level code?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是顶级代码？
- en: 'We take a very explanatory example from [this thread](https://stackoverflow.com/questions/18138166/what-is-a-top-level-statement-in-python)
    in StackOverflow:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从[这个线程](https://stackoverflow.com/questions/18138166/what-is-a-top-level-statement-in-python)中取一个非常说明性的例子：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Well, as we can see, the problem is related to the Python interpreter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，正如我们所看到的，问题与Python解释器有关。
- en: Let me explain.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我解释一下。
- en: 'If a module is been executed on its own, then there is no problem. The problems
    arrive **when a module is imported into another Python file**. Suppose that the
    above script is imported in another file: when we import it, it immediately executes
    all the top-level code and all the code that is part of an `if`or a class statement,
    as the comments in the above snippet of code tell us.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个模块是独立执行的，那么没有问题。当一个模块被导入到另一个Python文件中时，问题就会出现。假设上述脚本被导入到另一个文件中：当我们导入它时，它会立即执行所有顶级代码以及属于`if`或类声明的代码，正如上述代码片段中的注释所述。
- en: Let’s see it in more detail, with an example.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地查看它，举个例子。
- en: 'Let’s create a Python file called `package_1.py` like so:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`package_1.py`的Python文件，如下所示：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we execute it via terminal, we get:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过终端执行它，我们得到：
- en: '![](../Images/12f52336e1c663c6204b14da38236b55.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/12f52336e1c663c6204b14da38236b55.png)'
- en: The execution of the package_1.py file. Image by Author.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`package_1.py`文件。图片由作者提供。
- en: So, it perfectly works.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，它完全有效。
- en: 'Now, let’s create a Python file called `main.py` and import into it the `package_1.py`
    file, then run `main.py`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个名为`main.py`的Python文件，并将`package_1.py`文件导入其中，然后运行`main.py`：
- en: '![](../Images/6c622d96b060618fda2c0d990cb0e78a.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6c622d96b060618fda2c0d990cb0e78a.png)'
- en: The execution of the main.py file. Image by Author.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: main.py 文件的执行。图像来源：作者。
- en: 'As we can see, when `main.py`is run, the module `package_1.py`is immediately
    executed! This is something we don’t want for a simple reason: we want to use
    the code we import from a module when we actually call the code. In other words:
    if a whole module executes the code immediately after it is imported, it’s not
    useful at all.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，当 `main.py` 运行时，模块 `package_1.py` 会立即执行！这是我们不希望发生的情况，原因很简单：我们希望在实际调用代码时使用从模块中导入的代码。换句话说，如果整个模块在导入后立即执行代码，那就完全没有用。
- en: 'To avoid that, we use `if __name__ = "__main__"` in our `package_1.py` and,
    after it, we invoke the `print_hello()` function:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，我们在 `package_1.py` 中使用了 `if __name__ = "__main__"`，并在其后调用 `print_hello()`
    函数：
- en: '![](../Images/d58134082df75c4f8647567414572901.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d58134082df75c4f8647567414572901.png)'
- en: The execution of the main.py file using ‘if __name__ == “__main__”’. Image by
    Author.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用‘if __name__ == “__main__”’执行 main.py 文件。图像来源：作者。
- en: 'So, as [2] tells us:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [2] 所述：
- en: '`if __name__ = "__main__"` prevents the automatic execution of the top-level
    code when a module is executed.'
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`if __name__ = "__main__"` 防止了在模块执行时顶层代码的自动执行。'
- en: Also, previously we invoked the `print_hello()` function in the `package_1.py`
    file because we wanted the function to actually work when we run the program on
    its own. Now, invoking `print_hello()` after `if __name__ = "__main__"` will invoke
    the function when `package_1.py` is run on its own.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，之前我们在 `package_1.py` 文件中调用了 `print_hello()` 函数，因为我们希望函数在程序独立运行时能够实际工作。现在，在
    `if __name__ = "__main__"` 后调用 `print_hello()` 将在 `package_1.py` 独立运行时调用该函数。
- en: 'So, to recap and clarify using this example, if we invoke `print_hello()`after
    `if __name__ = "__main__"` in `package_1.py` :'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，为了回顾和澄清这个例子，如果我们在 `package_1.py` 中的 `if __name__ = "__main__"` 后调用 `print_hello()`：
- en: '`print_hello()` will be executed when `package_1.py` is run on its own (i.e.,
    via terminal).'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 `package_1.py` 独立运行（即，通过终端）时，`print_hello()` 将被执行。
- en: '`print_hello()` will not be executed when we run `main.py`.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们运行 `main.py` 时，`print_hello()` 将不会被执行。
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Type Hints
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型提示
- en: Starting from Python 3, “[PEP 484 — Type Hints](https://peps.python.org/pep-0484/)”
    has introduced type hints in Python.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Python 3 开始，“[PEP 484 — 类型提示](https://peps.python.org/pep-0484/)” 引入了 Python
    中的类型提示。
- en: Hitting a type means suggesting the type to pass to a function (or to a method,
    in the case of classes). We all know that comments and docstrings must do their
    work, but typing hints really help us understand what to expect in functions.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示是建议传递给函数（或在类的情况下传递给方法）的类型。我们都知道注释和文档字符串必须发挥作用，但类型提示确实有助于我们理解函数的预期。
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let’s make a simple example. Let’s create a function that returns a value:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一个简单的例子。创建一个返回值的函数：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'So, we have created a function that takes one argument (called `variable`)
    and the type hints tell us that:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们创建了一个接受一个参数（称为 `variable`）的函数，类型提示告诉我们：
- en: the type of variable can be any. A string, an integer, etc…
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`variable` 的类型可以是任何类型，例如字符串、整数等……'
- en: the function returns any type (and, in fact, it returns `variable`)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数返回任何类型（实际上，它返回 `variable`）
- en: Don’t you find it useful? Well, I discovered it some weeks ago and find it amazing!
    Especially, this becomes interesting with more complicated examples.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你觉得这有用吗？好吧，我几周前发现了这个功能，觉得非常惊艳！特别是，当示例更复杂时，这就变得非常有趣。
- en: 'For example, let’s say we want a function that gets a list as an argument and
    returns the count of how many elements are in the list. The function can be like
    the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们需要一个函数，该函数接收一个列表作为参数，并返回列表中元素的数量。该函数可以如下所示：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: So, here our function takes `element` as the only argument, and we know that
    it must be a list of any type, thanks to type hints. Then, the function returns
    an integer as type; in fact, it counts the number of elements in the list.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的函数仅接受 `element` 作为参数，并且由于类型提示，我们知道它必须是任何类型的列表。然后，函数返回一个整数类型；实际上，它计算列表中元素的数量。
- en: So, we believe the point is clear. This is a very good implementation for improving
    the readability of our code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们认为这个观点很清楚。这是一个非常好的实现，能够提高我们代码的可读性。
- en: Docstrings (and how to invoke them)
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档字符串（以及如何调用它们）
- en: 'Documentation is the most important part of every software project for a simple
    reason: in the next two months we’ll barely remember what we have done, and why.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 文档是每个软件项目中最重要的部分，原因很简单：在接下来的两个月里，我们几乎不会记得我们做了什么以及为什么做。
- en: For this reason, writing notes and explanations of our code is very important.
    Unfortunately, comments are not enough because they have to be very short (but
    explanative).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，编写代码的注释和解释是非常重要的。不幸的是，注释是不够的，因为它们必须非常简短（但要有解释性）。
- en: 'So, what we can do is use docstrings. [PEP 257](https://peps.python.org/pep-0257/)
    specifies that:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们可以做的是使用 docstrings。 [PEP 257](https://peps.python.org/pep-0257/) 规定：
- en: A docstring is a string literal that occurs as the first statement in a module,
    function, class, or method definition. Such a docstring becomes the `__doc__`
    special attribute of that object.
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: docstring 是在模块、函数、类或方法定义中的第一个语句出现的字符串文字。这样的 docstring 成为该对象的 `__doc__` 特殊属性。
- en: ''
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: All modules should normally have docstrings, and all functions and classes exported
    by a module should also have docstrings. Public methods (including the `__init__`
    constructor) should also have docstrings. A package may be documented in the module
    docstring of the `__init__.py` file in the package directory.
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 所有模块通常都应该有 docstrings，而模块导出的所有函数和类也应有 docstrings。公共方法（包括 `__init__` 构造函数）也应有
    docstrings。一个包的文档可以在包目录中的 `__init__.py` 文件的模块 docstring 中进行记录。
- en: In other words, in software development, a docstring is a string type in the
    code that documents the code itself. As reference [1] tells us, “unlike comments,
    docstrings are available at runtime, simplifying code inspection and providing
    help or metadata during execution”.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，在软件开发中，docstring 是一种在代码中用于记录代码本身的字符串类型。正如参考文献 [1] 所述，“与注释不同，docstrings
    在运行时可用，简化了代码检查，并在执行过程中提供帮助或元数据”。
- en: 'Let’s see how to use docstrings in a Python class:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在 Python 类中使用 docstrings：
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To access the documentation (aka, the docstrings) we type the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问文档（即 docstrings），我们输入以下内容：
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: So, this is how we can access the docstrings related to a class. What if we
    want to access the docstring of a particular method of a class?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这就是我们如何访问与类相关的 docstrings。如果我们想访问类中特定方法的 docstring 呢？
- en: 'Let’s see it:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And to access the documentation of the `position` method:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问 `position` 方法的文档：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: And here we are.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到了。
- en: 'But we actually can (and should!) do better. For example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们实际上可以（并且应该！）做得更好。例如：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This may seem redundant since we have used type hints, but it is not because:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来有些冗余，因为我们已经使用了类型提示，但实际上并不是因为：
- en: we may need, in a first attempt, to just invoke the documentation of our class
    (maybe because we have imported it as a module in another file).
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可能需要在第一次尝试中，仅调用我们类的文档（也许因为我们在另一个文件中将其作为模块导入）。
- en: we may use tools (like [Sphinx](https://www.sphinx-doc.org/en/master/), for
    example) to create the documentation in HTML; these tools use directly the docstrings.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用工具（例如 [Sphinx](https://www.sphinx-doc.org/en/master/)）来创建 HTML 格式的文档；这些工具直接使用
    docstrings。
- en: This is why using very explanatory docstrings is very important.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么使用非常解释性的 docstrings 是非常重要的。
- en: Inheritance
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: 'Here we want to talk about a Python magic: **inheritance**.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们想讨论 Python 的一个魔法：**继承**。
- en: As we’ve said before, OOP is the methodology to develop code with objects interacting
    between them. This means that when we create classes in Python we often have to
    make them interact.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，面向对象编程（OOP）是用对象之间相互作用的方法来开发代码。这意味着当我们在 Python 中创建类时，我们经常需要让它们相互作用。
- en: When interacting, classes inherit the properties and functionalities of other
    classes.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在交互时，类会继承其他类的属性和功能。
- en: 'Yes: it’s like your old aunt decides to leave you her 21 billion $ (who hasn’t
    such an aunt?!).'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 是的：就像你的老姑姑决定把她的 210 亿美元留给你一样（谁没有这样的姑姑？！）。
- en: Now, firstly we have to say that every class we create uses inheritance. This
    happens because, as we’ve said before, Python uses built-in classes. So, when
    we invoke built-in classes, our code is inheriting the properties of the invoked
    built-in class or object.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须说明，我们创建的每个类都使用了继承。这是因为，正如我们之前所说，Python 使用内置类。所以，当我们调用内置类时，我们的代码会继承调用的内置类或对象的属性。
- en: 'Now, let’s see inheritance in action, with a practical example (note: I have
    taken the following classes from reference [1], and modified them as per my taste
    and needs).'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看继承在实际中的应用（注意：我从参考文献 [1] 中取出了以下类，并根据我的口味和需求进行了修改）。
- en: 'We want to create a class that stores the name and the surname of some contacts,
    populating an empty list. We can create something like that:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想创建一个存储一些联系人的名字和姓氏的类，填充一个空列表。我们可以创建类似这样的东西：
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, let’s try it:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试一下：
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, suppose we want to collect the email of the contacts but, for any reason,
    we want to create a separate class. We can create a class like the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想收集联系人的电子邮件，但由于某种原因，我们想创建一个单独的类。我们可以创建一个如下的类：
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, let’s add an email like the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个如下的电子邮件：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, if we invoke `Contact.all_contacts` we get:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们调用 `Contact.all_contacts`，我们会得到：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: So, since our class `Email` has the class `Contact` as an argument, **it inherits
    its properties**. For example, the arguments passed to the `Email` class are appended
    to the list in the class `Contact`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，由于我们的 `Email` 类将 `Contact` 类作为参数，**它继承了其属性**。例如，传递给 `Email` 类的参数会附加到 `Contact`
    类中的列表。
- en: 'Also, this class inherits the fact that the `__init()__` method requires two
    arguments. In fact, this is what we get with just one argument:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，这个类继承了 `__init()__` 方法需要两个参数的事实。实际上，这就是我们只用一个参数所得到的：
- en: '[PRE34]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: But, hey, wait!!! We haven’t used the `__init()__` method in the class `Email`,
    so what happened?
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，等一下！！！我们在 `Email` 类中没有使用 `__init()__` 方法，那发生了什么？
- en: It happened that the class `Email` inherited the `__init()__` method, so there
    is no need to use it again!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是 `Email` 类继承了 `__init()__` 方法，所以不需要再次使用它！
- en: 'If we want to use another `__init()__` method in the child class (`Email` is
    a child class), we must make some adjustments like the following ones:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在子类中使用另一个 `__init()__` 方法（`Email` 是一个子类），我们必须做出一些调整，例如以下几点：
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And it works exactly like the previous one:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作方式与之前的完全相同：
- en: '[PRE36]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: So, the classes `Email` and `General` work exactly the same way and give us
    exactly the same results, but the power of inheritance shows us that without using
    the `__init()__`, method as we did with `Email`, the code is simplified.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Email` 类和 `General` 类的工作方式完全相同，结果也完全相同，但继承的强大之处在于，没有像我们在 `Email` 中使用 `__init()__`
    方法一样，代码会更简洁。
- en: 'Also, as we can see, in the case of the `General` class, we have used the `super.__init()__`
    method: we must use it in the case of a child class, because it initializes the
    inherited attributes of the parent class (`Contact`).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，正如我们所见，在 `General` 类的情况下，我们使用了 `super.__init()__` 方法：在子类中我们必须使用它，因为它初始化了父类（`Contact`）的继承属性。
- en: Pro tip on how to use Python classes
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于如何使用 Python 类的专业提示
- en: 'If you came across this article because you struggle understanding classes,
    chances are that you don’t have a clear idea of why you should use them. If it
    is so, welcome to the club: I had the same struggle.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现这篇文章是因为你在理解类时遇到困难，那么你可能不清楚为什么应该使用它们。如果是这样，欢迎加入俱乐部：我曾经也有同样的困惑。
- en: 'I mean: I understood that classes (and, of course, functions) help us automatize
    our code, but the fact that we have to invoke them created some difficulties for
    me.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我的意思是：我明白类（当然，还有函数）帮助我们自动化代码，但必须调用它们给我带来了一些困难。
- en: This happened to me because I’ve started studying Python for Data Science (and
    here’re are my tips on how to properly do so) and, saying the truth, in many cases,
    there is no reason to use classes when we use Python for Data Science.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这发生在我身上，因为我开始学习 Python 用于数据科学（这是我如何正确做这件事的提示），说实话，在许多情况下，当我们用 Python 做数据科学时，使用类并没有理由。
- en: 'So, my advice to properly understand the need to use classes is to treat them
    as modules. This means that, when you want to start a new Python project, a piece
    of very good advice is to create a `main.py` file where you invoke all the classes
    you need; anyway, these classes shouldn''t be created in the `main.py`: they should
    be created in separate Python files (usually, we create one Python file for each
    class) and imported in the `main.py` where we use them.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我的建议是，正确理解使用类的必要性是将它们视为模块。这意味着，当你想开始一个新的 Python 项目时，一个很好的建议是创建一个 `main.py`
    文件，在其中调用所有你需要的类；无论如何，这些类不应该在 `main.py` 中创建：它们应该在单独的 Python 文件中创建（通常，我们为每个类创建一个
    Python 文件）并在 `main.py` 中导入使用。
- en: 'Also, so far we’ve talked about modules. Here’s an article I’ve written to
    cover this topic:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，到目前为止我们谈论了模块。这是我写的一篇关于这个话题的文章：
- en: '[](/mastering-modular-programming-how-to-take-your-python-skills-to-the-next-level-ba14339e8429?source=post_page-----881ed609fb6--------------------------------)
    [## Mastering Modular Programming: How to Take Your Python Skills to the Next
    Level'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[](/mastering-modular-programming-how-to-take-your-python-skills-to-the-next-level-ba14339e8429?source=post_page-----881ed609fb6--------------------------------)
    [## 掌握模块化编程：如何将你的 Python 技能提升到下一个层次'
- en: Best Practices for Writing Modular Python Code
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写模块化 Python 代码的最佳实践
- en: towardsdatascience.com](/mastering-modular-programming-how-to-take-your-python-skills-to-the-next-level-ba14339e8429?source=post_page-----881ed609fb6--------------------------------)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: towardsdatascience.com](/mastering-modular-programming-how-to-take-your-python-skills-to-the-next-level-ba14339e8429?source=post_page-----881ed609fb6--------------------------------)
- en: Conclusions
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: In this article, we’ve seen a comprehensive guide on classes, hoping it clarifies
    the main topics on it.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇文章中，我们看到了一个关于类的综合指南，希望它能阐明相关的主要主题。
- en: The only thing that you have to do now is to practice a lot with classes, hoping
    this guide will help you when you need it.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在唯一需要做的就是多加练习，希望这个指南在你需要时能帮助到你。
- en: '**FREE PYTHON EBOOK:**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**免费 Python 电子书：**'
- en: 'Started learning Python Data Science but struggling with it? [***Subscribe
    to my newsletter and get my free ebook: this will give you the right learning
    path to follow to learn Python for Data Science with hands-on experience.***](https://federico-trotta.ck.page/a3970f33f4)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 开始学习 Python 数据科学但遇到困难？ [***订阅我的通讯，获取我的免费电子书：这将为你提供正确的学习路径，以便通过动手实践学习 Python
    数据科学。***](https://federico-trotta.ck.page/a3970f33f4)
- en: 'Enjoyed the story? Become a Medium member for 5$/month [through my referral
    link](https://medium.com/@federicotrotta/membership): I’ll earn a small commission
    to no additional fee to you:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 喜欢这个故事吗？通过我的推荐链接成为 Medium 会员，每月 5 美元 [点击这里](https://medium.com/@federicotrotta/membership)：我将获得一小笔佣金，对你没有额外费用：
- en: '[](https://medium.com/@federicotrotta/membership?source=post_page-----881ed609fb6--------------------------------)
    [## Join Medium with my referral link — Federico Trotta'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@federicotrotta/membership?source=post_page-----881ed609fb6--------------------------------)
    [## 使用我的推荐链接加入 Medium — Federico Trotta'
- en: Read every story from Federico Trotta (and thousands of other writers on Medium).
    Your membership fee directly supports…
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阅读 Federico Trotta 的每一个故事（以及 Medium 上成千上万的其他作家的故事）。您的会员费直接支持…
- en: medium.com](https://medium.com/@federicotrotta/membership?source=post_page-----881ed609fb6--------------------------------)
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: medium.com](https://medium.com/@federicotrotta/membership?source=post_page-----881ed609fb6--------------------------------)
- en: '*Bibliography and videography:*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*参考文献和视频资料：*'
- en: '[1] Python Object-Oriented Programming — S.F. Lott, D. Phillips'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] Python 面向对象编程 — S.F. Lott, D. Phillips'
- en: '[2] If __name__ == “__main__” for Python Developers ([video](https://www.youtube.com/watch?v=NB5LGzmSiCs))'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[2] 如果 __name__ == “__main__” 对于 Python 开发者 ([视频](https://www.youtube.com/watch?v=NB5LGzmSiCs))'
