- en: Nine Rules to Formally Validate Rust Algorithms with Dafny (Part 2)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Dafny 正式验证 Rust 算法的九条规则（第2部分）
- en: 原文：[https://towardsdatascience.com/nine-rules-to-formally-validate-rust-algorithms-with-dafny-part-2-f2a279686700?source=collection_archive---------5-----------------------#2023-10-21](https://towardsdatascience.com/nine-rules-to-formally-validate-rust-algorithms-with-dafny-part-2-f2a279686700?source=collection_archive---------5-----------------------#2023-10-21)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/nine-rules-to-formally-validate-rust-algorithms-with-dafny-part-2-f2a279686700?source=collection_archive---------5-----------------------#2023-10-21](https://towardsdatascience.com/nine-rules-to-formally-validate-rust-algorithms-with-dafny-part-2-f2a279686700?source=collection_archive---------5-----------------------#2023-10-21)
- en: Lessons from Verifying the range-set-blaze Crate
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证 range-set-blaze Crate 的经验教训
- en: '[](https://medium.com/@carlmkadie?source=post_page-----f2a279686700--------------------------------)[![Carl
    M. Kadie](../Images/9dbe27c76e9567136e5a7dc587f1fb15.png)](https://medium.com/@carlmkadie?source=post_page-----f2a279686700--------------------------------)[](https://towardsdatascience.com/?source=post_page-----f2a279686700--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----f2a279686700--------------------------------)
    [Carl M. Kadie](https://medium.com/@carlmkadie?source=post_page-----f2a279686700--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@carlmkadie?source=post_page-----f2a279686700--------------------------------)[![Carl
    M. Kadie](../Images/9dbe27c76e9567136e5a7dc587f1fb15.png)](https://medium.com/@carlmkadie?source=post_page-----f2a279686700--------------------------------)[](https://towardsdatascience.com/?source=post_page-----f2a279686700--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----f2a279686700--------------------------------)
    [Carl M. Kadie](https://medium.com/@carlmkadie?source=post_page-----f2a279686700--------------------------------)'
- en: ·
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fa5e87027005f&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnine-rules-to-formally-validate-rust-algorithms-with-dafny-part-2-f2a279686700&user=Carl+M.+Kadie&userId=a5e87027005f&source=post_page-a5e87027005f----f2a279686700---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----f2a279686700--------------------------------)
    ·14 min read·Oct 21, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Ff2a279686700&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnine-rules-to-formally-validate-rust-algorithms-with-dafny-part-2-f2a279686700&user=Carl+M.+Kadie&userId=a5e87027005f&source=-----f2a279686700---------------------clap_footer-----------)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[关注](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fa5e87027005f&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnine-rules-to-formally-validate-rust-algorithms-with-dafny-part-2-f2a279686700&user=Carl+M.+Kadie&userId=a5e87027005f&source=post_page-a5e87027005f----f2a279686700---------------------post_header-----------)
    发表在 [Towards Data Science](https://towardsdatascience.com/?source=post_page-----f2a279686700--------------------------------)
    ·14 分钟阅读·2023年10月21日[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Ff2a279686700&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnine-rules-to-formally-validate-rust-algorithms-with-dafny-part-2-f2a279686700&user=Carl+M.+Kadie&userId=a5e87027005f&source=-----f2a279686700---------------------clap_footer-----------)'
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Ff2a279686700&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnine-rules-to-formally-validate-rust-algorithms-with-dafny-part-2-f2a279686700&source=-----f2a279686700---------------------bookmark_footer-----------)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Ff2a279686700&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnine-rules-to-formally-validate-rust-algorithms-with-dafny-part-2-f2a279686700&source=-----f2a279686700---------------------bookmark_footer-----------)'
- en: By Carl M. Kadie and Divyanshu Ranjan
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 作者：**Carl M. Kadie** 和 **Divyanshu Ranjan**
- en: '![](../Images/ce250f929d2fc998fb6b5fe42dfd5933.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ce250f929d2fc998fb6b5fe42dfd5933.png)'
- en: 'Crab proving Pythagoras’ theorem — Source: [https://openai.com/dall-e-3/](https://openai.com/dall-e-3/)
    & [CC BY-SA 3.0](http://creativecommons.org/licenses/by-sa/3.0/) [File:Pythagorean.svg](https://commons.wikimedia.org/wiki/File:Pythagorean.svg)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 蟹证明毕达哥拉斯定理 — 来源：[https://openai.com/dall-e-3/](https://openai.com/dall-e-3/)
    & [CC BY-SA 3.0](http://creativecommons.org/licenses/by-sa/3.0/) [文件:Pythagorean.svg](https://commons.wikimedia.org/wiki/File:Pythagorean.svg)
- en: 'This is Part 2 of an article formally verifying a Rust algorithm using Dafny.
    We look at rules 7 to 9:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关于使用 Dafny 正式验证 Rust 算法的文章第2部分。我们查看第7至第9条规则：
- en: 7\. Port your Real Algorithm to Dafny.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7\. 将你的真实算法迁移到 Dafny。
- en: 8\. Validate the Dafny Version of Your Algorithm.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 8\. 验证你算法的 Dafny 版本。
- en: 9\. Rework Your Validation for Reliability.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 9\. 重新审视你的验证以确保可靠性。
- en: 'See [Part 1](/nine-rules-to-formally-validate-rust-algorithms-with-dafny-part-1-5cb8c8a0bb92)
    for rules 1 to 6:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 参见 [第 1 部分](/nine-rules-to-formally-validate-rust-algorithms-with-dafny-part-1-5cb8c8a0bb92)
    的规则 1 到 6：
- en: Don’t Learn Dafny.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要学习 Dafny。
- en: Learn Dafny.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 学习 Dafny。
- en: Define Your Algorithm’s Basic Concepts.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义你的算法的基本概念。
- en: Specify Your Algorithm.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定你的算法。
- en: Get Help from the Dafny Community.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 Dafny 社区寻求帮助。
- en: Validate a Different, Easier, Algorithm.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证不同的、更简单的算法。
- en: The rules are informed by our experience validating an algorithm from `[range-set-blaze](https://crates.io/crates/range-set-blaze)`,
    a Rust crate for manipulating sets of “clumpy” integers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则来自我们验证一个来自 `[range-set-blaze](https://crates.io/crates/range-set-blaze)`
    的算法的经验，这个 Rust crate 用于处理“分散”整数的集合。
- en: Recall that Rule 6, from [Part 1](/nine-rules-to-formally-validate-rust-algorithms-with-dafny-part-1-5cb8c8a0bb92),
    shows that we can verify *an* algorithm for `InternalAdd`, but it is not *the*
    algorithm used in the Rust crate. We turn to that algorithm next.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 记住第 6 规则，来自 [第 1 部分](/nine-rules-to-formally-validate-rust-algorithms-with-dafny-part-1-5cb8c8a0bb92)，显示我们可以验证
    *一个* 算法的 `InternalAdd`，但它不是 Rust crate 中使用的 *那个* 算法。接下来我们转向那个算法。
- en: 'Rule 7: Port your Real Algorithm to Dafny.'
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 7：将你的真实算法移植到 Dafny。
- en: 'Here is the Rust function of interest with some code excluded for now:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是感兴趣的 Rust 函数，部分代码暂时省略：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And here is the start of the Dafny port:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Dafny 移植版的开始部分：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Some points of possible interest:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一些可能感兴趣的点：
- en: The Rust code uses `self` and object-oriented-like encapsulation. Dafny supports
    this coding style, but — for simplicity — I don’t use it here. Specifically, the
    Rust code mutates `self`. I chose to write the Dafny code more functionally —
    it takes an immutable sequence and returns a new immutable sequence.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust 代码使用 `self` 和类似面向对象的封装。Dafny 支持这种编码风格，但为了简便，我在这里没有使用。具体来说，Rust 代码会改变 `self`。我选择了用更函数式的方式编写
    Dafny 代码——它接受一个不可变的序列并返回一个新的不可变序列。
- en: The Rust code manages memory with the borrow checker. This leads to expressions
    such as `range.clone()`. Dafny manages memory with a garbage collector. In either
    case, memory safety will be taken care of. We, therefore, ignore it in this validation.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust 代码通过借用检查器来管理内存。这导致了诸如 `range.clone()` 的表达式。Dafny 通过垃圾回收器来管理内存。在这两种情况下，内存安全都会得到保证。因此，我们在此验证中忽略它。
- en: The Rust code is generic over `T` which I elsewhere define to include all the
    standard Rust integer types, for example, `u8`, `isize`, `i128`. The Dafny code
    is defined on `int`, a single type that represents integers of arbitrary size.
    This means this Dafny port need not check for integer overflows. [See a [previous
    article](https://medium.com/@carlmkadie/check-ai-generated-code-perfectly-and-automatically-d5b61acff741)
    for formally proving overflow safety with the Kani Rust verifier.]
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust 代码对 `T` 是泛型的，我在其他地方定义它包括所有标准的 Rust 整数类型，例如 `u8`、`isize`、`i128`。Dafny 代码定义在
    `int` 上，这是一个表示任意大小整数的单一类型。这意味着这个 Dafny 移植版不需要检查整数溢出。 [参见 [上一篇文章](https://medium.com/@carlmkadie/check-ai-generated-code-perfectly-and-automatically-d5b61acff741)
    了解如何用 Kani Rust 验证器正式证明溢出安全。]
- en: 'The Rust code includes a run-time `assert!` that is needed in Rust to forbid
    one special case: inserting `u128::max_value` into a `RangeSetBlaze<u128>`. Because
    Dafny uses the arbitrary-sized `int`, it ignores this special case.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust 代码包含一个运行时的 `assert!`，这是 Rust 中用于禁止一种特殊情况的：将 `u128::max_value` 插入到 `RangeSetBlaze<u128>`
    中。由于 Dafny 使用任意大小的 `int`，它忽略了这种特殊情况。
- en: 'Aside: What is the length of the Rust *inclusive range* `*0..=u128::max_value*`*?
    The answer is* `*u128::max_value*`*+1, a value too large to represent with any
    standard Rust integer type. The* `*range-set-blaze*` *crate limits ranges to*
    `*0..=u128::max_value*`*-1, so that lengths can be represented with a* `*u128*`*.*'
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附注：Rust 的 *包含范围* `*0..=u128::max_value*`* 的长度是多少？答案是* `*u128::max_value*`*+1，这个值太大，无法用任何标准
    Rust 整数类型表示。* `*range-set-blaze*` *crate 将范围限制为* `*0..=u128::max_value*`*-1，以便长度可以用*
    `*u128*` *表示。*
- en: Let’s next consider the rest of the `internal_add` algorithm. Recall that we
    have some list of sorted disjoint ranges and some non-empty new range that we
    want to insert. For example
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们考虑 `internal_add` 算法的其余部分。记住，我们有一些排序好的不相交的范围和一些非空的新范围，我们想要插入。例如
- en: '![](../Images/bdd7995a92e3e0f289594d16677a8f0e.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/bdd7995a92e3e0f289594d16677a8f0e.png)'
- en: 'Credit: This and following figures by author.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 致谢：此处和以下的图表由作者提供。
- en: 'The algorithm has us find which (if any) existing range is before (or at) the
    start of the new range. Call this the “before” range. We then consider four cases:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 算法要求我们找出哪个（如果有的话）现有范围在新范围的开始之前（或正好在开始）。称之为“之前”范围。然后我们考虑四种情况：
- en: 'Case 1: The new range doesn’t touch its before range, so we insert the new
    range while checking to see if it touches any other ranges.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 案例1：新范围不触及之前的范围，因此我们在检查是否触及任何其他范围时插入新范围。
- en: 'Case 2: The new range touches the before range and extends beyond it, so we
    extend the end of the before range while checking to see if it touches any other
    ranges. (When no other ranges are touched, this will be very fast.)'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 案例2：新范围触及之前的范围并超出它，因此在检查是否触及任何其他范围时扩展之前范围的末尾。（当没有其他范围被触及时，这将非常快。）
- en: '![](../Images/a6c54954fb5c963daa94f9d07f2213d3.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a6c54954fb5c963daa94f9d07f2213d3.png)'
- en: 'Case 3: The new range touches the before range but does not extend beyond it,
    so do nothing. (This will always be very, very fast.)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 案例3：新范围触及之前的范围但没有超出它，因此不做任何操作。（这将总是非常非常快。）
- en: '![](../Images/caca986ea7085c4078b89526376051b6.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/caca986ea7085c4078b89526376051b6.png)'
- en: 'Case 4: The new range starts before any range, so add it while checking to
    see if it touches any other ranges.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 案例4：新范围在任何范围之前开始，因此在检查是否触及任何其他范围时添加它。
- en: '![](../Images/98ba8a777a19b7e377230cf25bc791b9.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/98ba8a777a19b7e377230cf25bc791b9.png)'
- en: 'Here is [the algorithm in Rust](https://github.com/CarlKCarlK/range-set-blaze/blob/f181c3fab31c8b215122402c24a5a7783189187a/src/lib.rs#L1003C2-L1003C59):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是[Rust中的算法](https://github.com/CarlKCarlK/range-set-blaze/blob/f181c3fab31c8b215122402c24a5a7783189187a/src/lib.rs#L1003C2-L1003C59)：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And here it is in Dafny:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是Dafny中的算法：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Some points of possible interest:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 可能感兴趣的一些要点：
- en: The Rust code manipulates a `BTreeMap` via keys and values. The Dafny code manipulates
    a sorted `seq` with (random-access) indexes. I made the Dafny operations mirror
    the Rust operations although this makes the Dafny code less natural.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust代码通过键和值操作`BTreeMap`。Dafny代码则通过（随机访问）索引操作排序后的`seq`。我让Dafny操作镜像Rust操作，尽管这使得Dafny代码不那么自然。
- en: The Rust code also updates `self.len`, the number of individual integers in
    the RangeSetBlaze. The Dafny code ignores this. (Updating `len` is a feature that
    could be added to the Dafny code in the future.)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust代码还更新了`self.len`，即RangeSetBlaze中的整数数量。Dafny代码忽略了这一点。（更新`len`是一个将来可能会添加到Dafny代码中的功能。）
- en: As before, the Rust version includes code to avoid overflow that Dafny ignores.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 和之前一样，Rust版本包含了Dafny忽略的防止溢出的代码。
- en: I continued the port by writing a Dafny version of `internal_add2` and `delete_extra`,
    the two functions that `internal_add` calls. I finished the port by writing the
    methods these two methods call, etc. The full port is about 185 lines of code.
    You can see it [here](https://github.com/CarlKCarlK/range-set-blaze/blob/oct23/tests/formal/Rule7.dfy).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我继续通过编写`internal_add2`和`delete_extra`的Dafny版本来完成移植，这两个函数是`internal_add`调用的。我通过编写这两个方法调用的其他方法等完成了移植。完整的移植代码约185行。你可以在[这里](https://github.com/CarlKCarlK/range-set-blaze/blob/oct23/tests/formal/Rule7.dfy)查看。
- en: It does not validate. We’ll work on validation next.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 它没有验证。接下来我们将处理验证。
- en: 'Rule 8: Validate the Dafny Version of Your Algorithm.'
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则8：验证Dafny版本的算法。
- en: In this step, you will add validation hints to your code, for example, in the
    form of `assert` statements. Dafny uses these hints to try to validate your code.
    As a Dafny novice, I (Carl) found adding hints harder than coding. In part, because
    I didn’t know when (or if) Dafny would be satisfied and I could stop.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步，你将向代码中添加验证提示，例如，形式为`assert`语句。Dafny使用这些提示来尝试验证你的代码。作为Dafny初学者，我（Carl）发现添加提示比编写代码更困难。部分原因是因为我不知道Dafny何时（或是否）会满足条件，然后我可以停止。
- en: 'I did, however, learn how I should start. For example, the code above for `InternalAdd`
    produces two verification errors. First, The Dafny verifier reports that one of
    the `ensures` may not hold:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我确实学会了如何开始。例如，上述`InternalAdd`的代码产生了两个验证错误。首先，Dafny验证器报告说一个`ensures`可能不成立：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Aside: “Postcondition” corresponds to `*ensures*`. “Precondition” corresponds
    to `*requires*`.'
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附注：“后置条件”对应于`*ensures*`。“前置条件”对应于`*requires*`。
- en: Second, the Dafny verifier complains that a precondition (that is one of the
    `requires`) for `DeleteExtra` can’t be proved.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，Dafny验证器抱怨`DeleteExtra`的前置条件（即`requires`之一）无法证明。
- en: We will focus on the first problem first by adding an `assert` to the bottom
    of the method. We write it to mirror the `ensures`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先关注第一个问题，通过在方法底部添加`assert`。我们写它是为了反映`ensures`。
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We’ll explicitly ignore the `DeleteExtra` problem, for now, with an `assume`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将明确忽略`DeleteExtra`问题，暂时用`assume`来处理。
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The Dafny validator now only complains about our new final `assert`. It says
    “assertion might not hold.”
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Dafny验证器现在仅对我们的最终`assert`提出抱怨。它说“断言可能不成立。”
- en: 'Recall that the `InternalAdd` code uses nested `if` statements to divide its
    work into five cases. We’ll next move our assert from the end of the method to
    the end of each case. Look for the lines ending with a `// case` comment in the
    result:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`InternalAdd` 代码使用嵌套的 `if` 语句将其工作分成五种情况。接下来，我们将 `assert` 从方法的末尾移动到每个情况的末尾。请在结果中寻找以
    `// case` 注释结尾的行：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Dafny now tells us that cases 0, 1, and 4 validate. Case 2 fails (and contains
    that `assume` that we’ll need to eventually remove). For now, however, let’s work
    on case 3.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Dafny 现在告诉我们情况0、1和4已验证。情况2失败（并包含我们最终需要删除的 `assume`）。不过，现在让我们处理情况3。
- en: Recall from this article’s Rule 7, that case 3 is when we add a new range (red)
    that is completely covered by an existing range (the blue “before” range), so
    the code need do nothing.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 回忆一下这篇文章的规则7，情况3是当我们添加一个新的范围（红色），该范围完全被现有范围（蓝色的“之前”范围）覆盖时，因此代码无需做任何操作。
- en: '![](../Images/caca986ea7085c4078b89526376051b6.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/caca986ea7085c4078b89526376051b6.png)'
- en: 'So, thinking logically, what do we know? We know that the integers covered
    by the before range are a superset of the integers covered by the new range. We
    also know that the before range is part of our original sorted and disjoint list
    of ranges (the blue ranges). We’ll add these two hints to our code via `assert`
    statements:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，从逻辑上讲，我们知道什么？我们知道之前范围覆盖的整数是新范围覆盖的整数的超集。我们还知道之前范围是我们原始的排序且不重叠的范围列表（蓝色范围）的一部分。我们将通过
    `assert` 语句将这两个提示添加到我们的代码中：
- en: '![](../Images/3328b3e08fbdd1f1638f5c1b9e297c2a.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3328b3e08fbdd1f1638f5c1b9e297c2a.png)'
- en: Dafny agrees these two hints are true (green check marks), but it still doesn’t
    accept the `assert` of interest (red mark).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Dafny 同意这两个提示是正确的（绿色勾号），但它仍然不接受关注的 `assert`（红色标记）。
- en: We seem to need one more hint. Specifically, we need to convince Dafny that
    the integers covered by the before range are a subset of the integers covered
    by the list of all sorted and disjoint ranges. Intuitively, this is true because
    the before range is one of the ranges in the list.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们似乎需要再一个提示。具体来说，我们需要说服 Dafny 认为之前范围覆盖的整数是所有排序且不重叠范围列表中整数的子集。直观上，这是真的，因为之前范围是列表中的一个范围。
- en: We write this hint as a lemma with no body. Dafny accepts it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个提示写成一个没有主体的引理。Dafny 接受了它。
- en: '![](../Images/5ed147cca5272a75f1e140e098d1e87e.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5ed147cca5272a75f1e140e098d1e87e.png)'
- en: 'Aside: Why does Dafny accept this lemma with nothing in its body? I don’t know
    and don’t have a good intuition. This just worked. If it didn’t, I would have
    tried adding asserts to its body.'
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附录：为什么 Dafny 会接受这个主体为空的引理？我不知道，也没有很好的直觉。这只是有效。如果无效，我会尝试在其主体中添加断言。
- en: 'Using the lemma, case 3 now validates:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用引理，情况3现在已验证：
- en: '![](../Images/a7542cff758d2f9c8a9427b959465d0b.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a7542cff758d2f9c8a9427b959465d0b.png)'
- en: This means we have validated cases 0, 1, 3, and 4\. We would next move on to
    case 2\. In addition, some of the methods mentioned, for example, `DeleteExtra`,
    don’t yet validate and we would need to work on those. [You can see the code up
    to this point, [here](https://github.com/CarlKCarlK/range-set-blaze/blob/oct23/tests/formal/Rule8a.dfy).]
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们已验证情况0、1、3和4。接下来我们将处理情况2。此外，一些提到的方法，例如 `DeleteExtra`，尚未验证，我们需要对其进行处理。
    [您可以看到截至目前的代码，[在这里](https://github.com/CarlKCarlK/range-set-blaze/blob/oct23/tests/formal/Rule8a.dfy)。]
- en: For general advice on verification debugging, refer to [this section of the
    Dafny User’s Guide](https://dafny.org/latest/DafnyRef/DafnyRef#sec-verification-debugging).
    I also recommend this [Stack Overflow answer](https://stackoverflow.com/a/76925258/5976009)
    and mini-tutorial by Prof. James Wilcox.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有关验证调试的一般建议，请参阅 [Dafny 用户指南的这一部分](https://dafny.org/latest/DafnyRef/DafnyRef#sec-verification-debugging)。我还推荐
    [这个 Stack Overflow 答案](https://stackoverflow.com/a/76925258/5976009) 和 James Wilcox
    教授的迷你教程。
- en: Overall, the idea is to divide the task of validating your algorithm into many
    smaller validation tasks. I found this harder than programming, but not too hard
    and still fun.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，想法是将验证算法的任务分解成许多更小的验证任务。我发现这比编程更困难，但并不太难，仍然很有趣。
- en: I ended up adding about 200 validation lines to the 185 regular code lines ([full
    code here](https://github.com/CarlKCarlK/range-set-blaze/blob/oct23/tests/formal/Rule8b.dfy)).
    When I finally validated the last method, I wrongly thought I was finished.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我最终在185行常规代码中添加了大约200行验证代码（[完整代码在这里](https://github.com/CarlKCarlK/range-set-blaze/blob/oct23/tests/formal/Rule8b.dfy)）。当我最后验证完最后一个方法时，我错误地认为自己已经完成了。
- en: To my surprise (and disappointment) the work doesn’t end the first time that
    everything validates. You must also ensure that your project will validate again
    and validate for others. We’ll discuss this rule, next.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 令我惊讶（也是失望）的是，第一次所有内容验证通过并不意味着工作结束。你还必须确保你的项目将再次验证并且能为其他人验证。接下来，我们将讨论这一规则。
- en: 'Rule 9: Rework Your Validation for Reliability.'
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 9：重新审视你的验证以确保可靠性。
- en: I thought I was done. Then, I moved the six-line definition of the math `Min`
    function from the [Dafny standard library](https://github.com/dafny-lang/libraries)
    to my code. This caused my validation to fail, for no logical reason (literally!).
    Later, after I thought I’d fixed that, I deleted a method that wasn’t used. Again,
    validation started to fail for no logical reason.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我以为我完成了。然后，我将数学 `Min` 函数的六行定义从[Dafny 标准库](https://github.com/dafny-lang/libraries)移动到我的代码中。这导致我的验证失败，没有逻辑原因（字面上！）。后来，在我以为已经修复了之后，我删除了一个未使用的方法。再次，验证因没有逻辑原因而开始失败。
- en: 'What’s going on? Dafny works heuristically via a random search. Changing code
    superficially (or changing random seeds) can change how much time the search needs.
    Sometimes, the amount of time changes drastically. If the new time goes beyond
    a user-set time limit, the validation will fail. [We’ll talk more about the time
    limit in tip #3, below.]'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '发生了什么？Dafny 通过随机搜索进行启发式工作。表面上更改代码（或更改随机种子）可以改变搜索所需的时间。有时，时间的变化非常剧烈。如果新的时间超过了用户设置的时间限制，验证将失败。[我们将在下面的提示
    #3 中进一步讨论时间限制。]'
- en: You should test the reliability of your validation by trying different random
    seeds. Here are the commands I used (on Windows) to validate a file with 10 random
    seeds.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该通过尝试不同的随机种子来测试验证的可靠性。以下是我在 Windows 上使用的命令来验证一个具有 10 个随机种子的文件。
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The result is a *.csv file that you can open as a spreadsheet and then look
    for failures:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个 *.csv 文件，你可以将其打开为电子表格，然后寻找失败：
- en: '![](../Images/0a9b3603cc057c1b94c598e28984c45b.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0a9b3603cc057c1b94c598e28984c45b.png)'
- en: 'Aside: For more ideas on measuring Dafny’s validation reliability, see this
    Stack Overflow answer about [analyzing *.csv files](https://stackoverflow.com/a/77153753/5976009)
    and this GitHub discussion [recommending the dafny-reportgenerator tool](https://github.com/dafny-lang/ide-vscode/discussions/437#discussioncomment-7074719).'
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附注：有关测量 Dafny 验证可靠性的更多想法，请参见这个关于[分析 *.csv 文件](https://stackoverflow.com/a/77153753/5976009)的
    Stack Overflow 答案以及这个[推荐 dafny-reportgenerator 工具](https://github.com/dafny-lang/ide-vscode/discussions/437#discussioncomment-7074719)的
    GitHub 讨论。
- en: Having found the problem spots, I brought in co-author Divyanshu Ranjan to help.
    Divyanshu Ranjan used his experience with Dafny to fix the project’s validation
    problems.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在找到问题点后，我请来合著者 Divyanshu Ranjan 帮忙。Divyanshu Ranjan 利用他在 Dafny 上的经验来修复项目的验证问题。
- en: 'Here are his tips, with examples from the project:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是他的提示，以及来自项目的示例：
- en: 'Tip #1: When possible, remove r`equire` statements involving “forall” and “exists”.'
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '提示 #1：尽可能移除涉及“forall”和“exists”的 `require` 语句。'
- en: 'Recall from Rule 4 that ghost function `SeqToSet` returns the set of integers
    covered by a sorted and disjoint list of non-empty ranges. We define “sorted and
    disjoint” with function `ValidSeq`, which internally uses two `forall` expressions.
    We can remove the requirement that the list must be sorted and disjoint, like
    so:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾规则 4，幽灵函数 `SeqToSet` 返回由排序且不相交的非空范围列表覆盖的整数集合。我们用函数 `ValidSeq` 定义“排序且不相交”，该函数内部使用了两个
    `forall` 表达式。我们可以像这样移除列表必须排序和不相交的要求：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: From our point of view, we have the same useful function. From Dafny’s point
    of view, the function avoids two `forall` expressions and is easier to apply.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的角度来看，我们有相同的有用函数。从 Dafny 的角度来看，该函数避免了两个 `forall` 表达式，并且更容易应用。
- en: 'Tip #2 Use calc to avoid guess work by Dafny.'
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '提示 #2 使用 calc 避免 Dafny 的猜测工作。'
- en: 'With a Dafny `calc` statement, you list the exact steps needed to arrive at
    a conclusion. For example, here is a `calc` from the `DeleteExtra` method:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Dafny `calc` 语句，你列出了得出结论所需的确切步骤。例如，这是 `DeleteExtra` 方法中的一个 `calc`：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'At this point in the code, `xs` is a sequence of ranges, but it may not be
    sorted and disjoint. The `calc` asserts that:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的这一点，`xs` 是一个范围序列，但它可能不是排序的或不相交的。`calc` 断言：
- en: the integers covered by the two parts of `xs`, equals
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`xs` 的两部分覆盖的整数等于'
- en: the integers covered by the concatenation of its two parts, equals
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两部分拼接覆盖的整数等于
- en: the integers covered by `xs`, equals
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`xs` 覆盖的整数等于'
- en: '`rs`.'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rs`。'
- en: 'For each step, we are allowed to include lemmas or asserts to help prove that
    step. For example, this assert helps prove the move from step 3 to 4:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一步，我们可以包含引理或断言来帮助证明这一步骤。例如，这个断言有助于证明从第 3 步到第 4 步的过渡：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For efficiency and control, these lemmas and asserts will not be visible to
    the validator beyond their step. This keeps Dafny focused.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高效率和控制，这些引理和断言在它们的步骤之外对验证器不可见。这使得 Dafny 集中注意力。
- en: 'Tip #3: Use `timeLimit` to provide computation where needed.'
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '提示 #3：使用 `timeLimit` 提供所需的计算。'
- en: 'Dafny stops trying to validate a method at a user-settable `timeLimit`. Limits
    of 10, 15, or 30 seconds are common because, as users, we generally want never-going-to-happen
    validations to fail fast. However, if we know that a validation will happen eventually,
    we can set a method-specific time limit. For example, Divyanshu Ranjan noticed
    that `DeleteExtra` usually does validate, but takes more time than the other methods,
    so he added a method-specific time limit:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Dafny 在用户设置的 `timeLimit` 下停止尝试验证方法。10、15 或 30 秒的限制很常见，因为作为用户，我们通常希望那些不可能发生的验证能快速失败。然而，如果我们知道验证最终会发生，我们可以设置一个特定于方法的时间限制。例如，Divyanshu
    Ranjan 发现 `DeleteExtra` 通常会验证，但比其他方法花费更多时间，因此他添加了一个特定于方法的时间限制：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Aside: `*timeLimit*` doesn’t account for the difference in speed between computers,
    so set it a bit generously.'
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附注：`*timeLimit*` 并未考虑计算机之间速度的差异，因此请设置得稍微宽松些。
- en: 'Tip #4: Use split_here to divide a validation problem in two.'
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '提示 #4：使用 split_here 将验证问题分为两部分。'
- en: As the [Dafny FAQs](http://dafny.org/dafny/HowToFAQ/FAQSplitHere.html) explain,
    sometimes validating a set of asserts together is faster and sometimes validating
    them one-at-a-time is faster.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如[Dafny 常见问题解答](http://dafny.org/dafny/HowToFAQ/FAQSplitHere.html)所述，有时一起验证一组断言更快，有时逐一验证更快。
- en: 'Use an `assert {:split_here} true;` statement to split a sequence of asserts
    into two parts for the purpose of validation. For example, even with the `timeLimit`,
    `DeleteExtra` timed out until Divyanshu Ranjan added this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `assert {:split_here} true;` 语句将一系列断言拆分为两部分以进行验证。例如，即使有 `timeLimit`，`DeleteExtra`
    也会超时，直到 Divyanshu Ranjan 添加了这个：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Tip #5: Keep lemmas small. If needed, split ensures across lemmas.'
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '提示 #5：保持引理简小。如有需要，跨引理拆分 `ensures`。'
- en: Sometimes lemmas try to do too much at once. Consider the `SetsEqualLemma`.
    It is related to deleting redundant ranges. For example, if we insert `a` into
    `xs`, the ranges marked with “X” become redundant.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有时引理会试图一次做太多事情。考虑一下 `SetsEqualLemma`。它与删除冗余范围相关。例如，如果我们将 `a` 插入到 `xs` 中，标记为“X”的范围将变得冗余。
- en: '![](../Images/7538b2447575a35ce87e121e19e8c9b7.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7538b2447575a35ce87e121e19e8c9b7.png)'
- en: 'The original version of `SetsEqualLemma` contained 12 `requires` and 3 `ensures`.
    Divyanshu Ranjan split it into two lemmas: `RDoesntTouchLemma` (11 `requires`
    and 2 `ensures`) and `SetsEqualLemma` (3 `requires` and 1 `ensures`). With this
    change, the project validated more reliably.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetsEqualLemma` 的原始版本包含 12 个 `requires` 和 3 个 `ensures`。Divyanshu Ranjan 将其拆分为两个引理：`RDoesntTouchLemma`（11
    个 `requires` 和 2 个 `ensures`）和 `SetsEqualLemma`（3 个 `requires` 和 1 个 `ensures`）。通过这一变化，项目的验证更加可靠。'
- en: Applying these tips will improve the reliability of our proof. Can we make validation
    100% reliable? Sadly, no. There is always a chance that with an unlucky seed Dafny
    will fail to validate. So, when do you stop trying to improve validation?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 应用这些技巧将提高我们证明的可靠性。我们能否使验证 100% 可靠？遗憾的是，不能。总有可能由于不幸的种子，Dafny 无法验证。因此，当你什么时候停止尝试改进验证？
- en: On this project, Divyanshu Ranjan and I improved the validation code until the
    chance of a validation error on any single run fell below 33%. So, over 10 random
    runs, we saw no more than 2 or 3 failures. We even tried 100 random runs. With
    100 runs, we saw 30 failures.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，Divyanshu Ranjan 和我改进了验证代码，直到任何单次运行中验证错误的概率降到 33% 以下。因此，在 10 次随机运行中，我们看到的失败不超过
    2 或 3 次。我们甚至尝试了 100 次随机运行。在 100 次运行中，我们看到了 30 次失败。
- en: Conclusion
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: 'So, there you have it: nine rules to prove a Rust algorithm’s correctness with
    Dafny. You may be discouraged that the process is not easier or more automatic.
    I, however, am encouraged that the process is possible at all.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，您看到了：九条规则来证明 Rust 算法的正确性。您可能会对这个过程不够简单或自动感到沮丧。然而，我反而感到鼓舞，因为这个过程完全是可能的。
- en: 'Aside: Since geometry class — in high school — I’ve found math proofs fascinating
    and frustrating. “Fascinating” because a math theorem once proven is known true
    forever. (Euclid’s geometry is still considered true. Aristotle’s physics is not.)
    “Frustrating” because my math classes always seemed vague about which axioms I
    could assume and how big of steps my proof could take. Dafny and similar systems
    remove this vagueness with automatic proof checking. Even better, from my point
    of view, they help us create proofs about an area for which I care deeply: algorithms.'
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附注：自高中几何课以来，我发现数学证明既迷人又令人沮丧。 “迷人” 是因为一旦证明的数学定理被认为永远正确。（欧几里得的几何仍被认为是正确的，而亚里士多德的物理学则不是。）
    “令人沮丧” 是因为我的数学课总是对我可以假设哪些公理以及我的证明可以迈出多大步伐感到模糊。Dafny 和类似的系统通过自动证明检查消除了这种模糊性。从我的角度来看，更好的是，它们帮助我们创建关于我深切关心的领域：算法的证明。
- en: When is it worth doing a formal proof of an algorithm? Given the work involved,
    I will only do this again when the algorithm is some combination of tricky, important,
    or easy-to-prove.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 什么时候值得对算法进行正式证明？考虑到所涉及的工作，只有当算法在某种程度上复杂、重要或容易证明时，我才会再次进行这种证明。
- en: 'How might the process improve in the future? I’d love to see:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 未来这个过程可能如何改进？我希望看到：
- en: '**Interchange between systems —** A geometry theorem once proven need never
    be proven again. I’d love if the systems checking algorithmic proofs could use
    each other’s proofs.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统间的互换 —** 一旦证明的几何定理就不需要再证明。我希望检查算法证明的系统能够互相使用对方的证明。'
- en: '**An all-Rust system as easy to use as Dafny** — For work in this direction,
    see [[1](https://rust-formal-methods.github.io/tools.html),[2](https://alastairreid.github.io/automatic-rust-verification-tools-2021/)].'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个像 Dafny 一样易于使用的全 Rust 系统** — 有关这方面的工作，请参见 [[1](https://rust-formal-methods.github.io/tools.html),[2](https://alastairreid.github.io/automatic-rust-verification-tools-2021/)]。'
- en: 'Aside: Do you know of an easy-to-use Rust validation system? Please consider
    applying it to the validation of `internal_add`. This would let us compare the
    Rust system’s easy-of-use and power to Dafny’s.'
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附注：你知道有一个易于使用的 Rust 验证系统吗？请考虑将其应用于 `internal_add` 的验证。这将使我们能够比较 Rust 系统的易用性和功能与
    Dafny 的。
- en: '**The proof analog of Rust’s** `**Cargo.lock**` **files** — In Rust, we use
    the `Cargo.lock` to lock in a known-good combination of project dependencies.
    I wish when Dafny found a way to prove, for example, a method, that it would lock
    in the proof steps it found. This could make validation more reliable.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rust 的证明类 `**Cargo.lock**` 文件** — 在 Rust 中，我们使用 `Cargo.lock` 来锁定项目依赖的已知良好组合。我希望当
    Dafny 找到一种方法来证明，例如，一个方法时，它能锁定找到的证明步骤。这可以使验证更可靠。'
- en: '**Better AI for validation** — My intuition is that ChatGPT, slightly improved,
    could be good at creating 90% of needed validation code. I find current ChatGPT
    4 poor with Dafny, I assume for lack of Dafny training examples.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的 AI 验证** — 我的直觉是，经过一些改进的 ChatGPT 可能擅长创建 90% 需要的验证代码。我发现当前的 ChatGPT 4 在
    Dafny 上表现较差，我认为是因为缺乏 Dafny 的训练示例。'
- en: '**Better validation for AI** —When an AI generates code, we worry about the
    code’s correctness. Formal validation could help by proving correctness. (For
    a small example of this, see my article [Check AI-Generated Code Perfectly and
    Automatically](https://medium.com/@carlmkadie/check-ai-generated-code-perfectly-and-automatically-d5b61acff741).)'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的 AI 验证** — 当 AI 生成代码时，我们担心代码的正确性。形式化验证可以通过证明正确性来提供帮助。（有关此的小示例，请参见我的文章
    [Check AI-Generated Code Perfectly and Automatically](https://medium.com/@carlmkadie/check-ai-generated-code-perfectly-and-automatically-d5b61acff741)。）'
- en: Thank you for joining our journey into program correctness. We hope that if
    you have an algorithm for which you would like a proof, these steps will help
    you find that proof.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢你加入我们对程序正确性的探索。我们希望如果你有一个需要证明的算法，这些步骤将帮助你找到该证明。
- en: '*Please* [*follow Carl on Medium*](https://medium.com/@carlmkadie)*. I write
    on scientific programming in Rust and Python, machine learning, and statistics.
    I tend to write about one article per month.*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*请* [*关注 Carl 在 Medium 上*](https://medium.com/@carlmkadie)*。我在 Rust 和 Python
    的科学编程、机器学习和统计学方面写作。我倾向于每月写一篇文章。*'
- en: '*Read more of Divyanshu Ranjan’s work on* [*his blog*](https://rdivyanshu.github.io/)*.
    In addition to formal methods, the blog touches on geometry, statistics, and more.*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*阅读 Divyanshu Ranjan 更多的工作，见* [*他的博客*](https://rdivyanshu.github.io/)*。除了形式化方法，博客还涉及几何、统计学等主题。*'
