- en: 34% Faster Integer to String Conversion Algorithm
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 34% 更快的整数到字符串转换算法
- en: 原文：[https://towardsdatascience.com/34-faster-integer-to-string-conversion-algorithm-c72453d25352?source=collection_archive---------0-----------------------#2023-12-04](https://towardsdatascience.com/34-faster-integer-to-string-conversion-algorithm-c72453d25352?source=collection_archive---------0-----------------------#2023-12-04)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[原文](https://towardsdatascience.com/34-faster-integer-to-string-conversion-algorithm-c72453d25352?source=collection_archive---------0-----------------------#2023-12-04)'
- en: '*Are we printing integers fast enough?*'
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*我们打印整数的速度够快吗？*'
- en: '[](https://medium.com/@tigran.cs?source=post_page-----c72453d25352--------------------------------)[![Tigran
    Hayrapetyan](../Images/5e046cbad20b2a418b6b98fe8ec61e19.png)](https://medium.com/@tigran.cs?source=post_page-----c72453d25352--------------------------------)[](https://towardsdatascience.com/?source=post_page-----c72453d25352--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----c72453d25352--------------------------------)
    [Tigran Hayrapetyan](https://medium.com/@tigran.cs?source=post_page-----c72453d25352--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[![Tigran Hayrapetyan](../Images/5e046cbad20b2a418b6b98fe8ec61e19.png)](https://medium.com/@tigran.cs?source=post_page-----c72453d25352--------------------------------)
    [![Towards Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----c72453d25352--------------------------------)
    [Tigran Hayrapetyan](https://medium.com/@tigran.cs?source=post_page-----c72453d25352--------------------------------)'
- en: ·
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F36e8a35f28b3&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2F34-faster-integer-to-string-conversion-algorithm-c72453d25352&user=Tigran+Hayrapetyan&userId=36e8a35f28b3&source=post_page-36e8a35f28b3----c72453d25352---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----c72453d25352--------------------------------)
    ·14 min read·Dec 4, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fc72453d25352&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2F34-faster-integer-to-string-conversion-algorithm-c72453d25352&user=Tigran+Hayrapetyan&userId=36e8a35f28b3&source=-----c72453d25352---------------------clap_footer-----------)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[关注](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F36e8a35f28b3&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2F34-faster-integer-to-string-conversion-algorithm-c72453d25352&user=Tigran+Hayrapetyan&userId=36e8a35f28b3&source=post_page-36e8a35f28b3----c72453d25352---------------------post_header-----------)
    发表在 [Towards Data Science](https://towardsdatascience.com/?source=post_page-----c72453d25352--------------------------------)
    ·14 min read·2023年12月4日'
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fc72453d25352&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2F34-faster-integer-to-string-conversion-algorithm-c72453d25352&source=-----c72453d25352---------------------bookmark_footer-----------)![](../Images/cf81d98991f4797ff0a2e3ad2560806a.png)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](../Images/cf81d98991f4797ff0a2e3ad2560806a.png)](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fc72453d25352&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2F34-faster-integer-to-string-conversion-algorithm-c72453d25352&source=-----c72453d25352---------------------bookmark_footer-----------)'
- en: 1\. Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1. 介绍
- en: In computer programming, converting given integer to a string is a common operation,
    which should be done for example before printing the integer to the screen, or
    printing it to any kind of textual file, such as *.xml, *.json, *.csv, *.txt,
    etc…
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机编程中，将给定的整数转换为字符串是一项常见操作，例如在将整数打印到屏幕上或任何文本文件（如 *.xml, *.json, *.csv, *.txt
    等）之前需要进行此操作。
- en: 'It is well known that integers (as well as everything else) are stored in computer
    memory in binary format — as sequences of 0s and 1s. For example:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，整数（以及其他所有内容）在计算机内存中以二进制格式存储——即 0 和 1 的序列。例如：
- en: number 12 is represented in memory as “1100”,
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字 12 在内存中的表示为“1100”。
- en: and number 29 is represented as “11101”.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字 29 被表示为“11101”。
- en: This is the reason why such a conversion is needed every time, when we want
    to bring it into human-readable, decimal format.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么每次我们想要将其转换为人类可读的十进制格式时，需要进行这样的转换。
- en: 'In this story I am going to:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个故事中，我将要：
- en: make an overview of the standard algorithm used for such conversion,
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对用于这种转换的标准算法进行概述，
- en: observe its existing optimizations,
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察其现有的优化，
- en: propose my algorithm, and
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提出我的算法，并且
- en: present their experimental comparison.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示他们的实验比较。
- en: We will see that on average, my algorithm runs **25–38%** faster for 32-bit
    integers, and **40–58%** faster for 64-bit integers, than the optimized standard
    algorithm. Its implementation in C++ language can be found on GitHub, as referenced
    at the end.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到，我的算法对于32位整数运行**25–38%**更快，对于64位整数运行**40–58%**更快，相比于优化的标准算法。其在C++语言中的实现可以在GitHub上找到，如文末引用。
- en: Of course, if the application prints only a few integers during its lifetime,
    the algorithm which is responsible for converting them to strings will never be
    the bottleneck. But for cases when the application prints tons of data into text
    files, the efficiency of the converting algorithm starts playing role. When working
    in fields such as Data Science or Machine Learning, the need for converting lots
    of integers into strings arises e.g. when exporting a dataset into a text file,
    such as *.csv or *.json.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果应用在其生命周期内只打印少量整数，那么负责将它们转换为字符串的算法不会成为瓶颈。但是，对于那些将大量数据打印到文本文件中的情况，转换算法的效率就开始发挥作用。在数据科学或机器学习等领域，转换大量整数为字符串的需求很常见，例如在将数据集导出到文本文件时，如*.csv或*.json。
- en: 2\. The standard conversion algorithm
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. 标准转换算法
- en: As converting integers to strings is a common operation, an algorithm for that
    is implemented in any modern programming language, either as part of the language
    itself or as part of its standard library. And the algorithm is almost everywhere
    the same — the one which is based on repeatedly obtaining and picking out the
    last digit of the integer, and continuing with its remaining part.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将整数转换为字符串是一个常见操作，任何现代编程语言中都有实现这样的算法，无论是作为语言的一部分还是作为标准库的一部分。而且这个算法几乎在所有地方都是相同的——基于反复获取并提取整数的最后一个数字，然后继续处理剩余部分。
- en: 'In order to obtain the last digit of given integer *N*, it just calculates
    the remainder of its division upon 10:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得给定整数*N*的最后一位数字，它只是计算其除以10的余数：
- en: “digit := N mod 10”,
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “digit := N mod 10”,
- en: 'and in order to pick it out, it performs the integer division itself:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 并且为了提取它，执行整数除法：
- en: “N := N / 10”.
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “N := N / 10”。
- en: '![](../Images/8591b0f1155421879f34154e22b1c275.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8591b0f1155421879f34154e22b1c275.png)'
- en: '*Given an integer N, how its last digit'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*给定一个整数N，它的最后一位数字'
- en: and the remaining part are being computed.*
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 其余部分正在计算中。*
- en: Note, in this story, when dividing 2 integers, we will assume that only the
    whole part of result is taken.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个故事中，当除以两个整数时，我们将假设只取结果的整数部分。
- en: 'As an example of complete algorithm, when printing number “*N* = 2''167”, the
    following operations will be made:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 作为完整算法的示例，当打印数字“*N* = 2'167”时，将执行以下操作：
- en: '![](../Images/7b254cfdf91782f79cf083dffefb1a3f.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7b254cfdf91782f79cf083dffefb1a3f.png)'
- en: '*Operations for printing number “2167”:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*打印数字“2167”的操作：'
- en: 'Step 1: 2167 % 10 = 7 (storing digit “7”) , 2167 / 10 = 216 (continuing with
    216),'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步：2167 % 10 = 7（存储数字“7”），2167 / 10 = 216（继续处理216），
- en: 'Step 2: 216 % 10 = 6 (storing digit “6”) , 216 / 10 = 21 (continuing with 21),'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步：216 % 10 = 6（存储数字“6”），216 / 10 = 21（继续处理21），
- en: 'Step 3: 21 % 10 = 1 (storing digit “1”) , 21 / 10 = 2 (continuing with 2),'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步：21 % 10 = 1（存储数字“1”），21 / 10 = 2（继续处理2），
- en: 'Step 4: As “2 < 10”, just storing the last digit “2”.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第四步：由于“2 < 10”，只存储最后一个数字“2”。
- en: 'Step 5: (not illustrated) reversing order of stored digits and printing them.*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第五步：（未示例）反转存储的数字的顺序并打印它们。*
- en: Note, when we are dealing with 1-digit integer (i.e. from range [0..9]), we
    can directly send it for print, as corresponding characters are already fixed
    for each of those 10 digits. And a remainder of division upon 10 is always 1-digit
    integer.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们处理1位整数（即范围为[0..9]）时，我们可以直接发送进行打印，因为这些10个数字中的每一个对应的字符已经固定。且除以10的余数总是1位整数。
- en: Also we can note that this algorithm reports digits of *N* in reverse order
    (here we got sequence of digits ‘7’, ‘6’, ‘1’, ‘2’, instead of having ‘2’, ‘1’,
    ‘6’, ‘7’), so there is need to reverse the produced sequence at the end.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以注意到，这个算法报告的* N *的数字是倒序的（这里我们得到的数字序列是‘7’，‘6’，‘1’，‘2’，而不是‘2’，‘1’，‘6’，‘7’），所以在最后需要将生成的序列进行反转。
- en: 'Summarizing that, its pseudo-code will be like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，它的伪代码如下：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The described algorithm is simple, and we can easily implement it in 3–4 lines
    of code. But its bottleneck is that it uses 2 relatively expensive operations
    — integer division and integer remainder calculation, for every digit of *N*’s
    decimal notation. It is well known that integer division and remainder calculation
    on average take 4–5 times longer, than addition, subtraction or even multiplication
    of 2 integers. Here we can observe time benchmarking of mentioned arithmetical
    operations:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 描述的算法很简单，我们可以用 3–4 行代码轻松实现。但它的瓶颈在于对*N*的每一位小数表示使用了两个相对昂贵的操作——整数除法和整数余数计算。众所周知，整数除法和余数计算平均花费的时间比两个整数的加法、减法甚至乘法要长
    4–5 倍。这里我们可以观察到上述算术操作的时间基准：
- en: '![](../Images/e29e76171e0c7934e274679a56150872.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e29e76171e0c7934e274679a56150872.png)'
- en: '*Experimental comparison of time (in nanoseconds) spent to perform the 5 types
    of'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*时间（以纳秒为单位）花费的实验比较，用于执行 5 种类型的'
- en: arithmetical operations (each operation is run 200 times on random data).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 算术操作（每个操作在随机数据上运行 200 次）。
- en: We can see that the last 2 operations (integer division and remainder calculation)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到最后两个操作（整数除法和余数计算）
- en: are taking significantly more time. Also, we see that integer multiplication
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 花费的时间显著更多。此外，我们看到整数乘法
- en: is performed almost as fast as addition or subtraction.*
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 执行的速度几乎与加法或减法一样快。*
- en: 'The experiments were made with Google Benchmark, under the following system:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 实验是在以下系统下使用 Google Benchmark 进行的：
- en: '*CPU: Intel Core i7–11800H @ 2.30GHz'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*CPU: Intel Core i7–11800H @ 2.30GHz'
- en: 'RAM: 16.0 GB'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 内存：16.0 GB
- en: 'OS: Windows 11 Home, 64-bit'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统：Windows 11 Home，64 位
- en: 'Compiler: MSVC 2022 ( /O2 /Ob2 /MD /GR /Gd )*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器：MSVC 2022 (/O2 /Ob2 /MD /GR /Gd)*
- en: Let’s see if faster methods for integer printing exist…
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看是否存在更快的整数打印方法…
- en: 3\. Existing optimizations
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3\. 现有优化
- en: Optimization 1
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化 1
- en: One common optimization for the described algorithm is in eliminating the last
    step of reversing produced sequence of digits. The trick is well presented for
    example in [1]. Within this optimization we will write digits in the buffer straightaway
    in their proper order. And as the algorithm itself reports digits of given integer
    *N* from right to left, so we also will write them in the buffer from right to
    left.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于描述的算法，一个常见的优化是消除最后一步反转生成的数字序列。这个技巧在例如 [1] 中有很好的介绍。在这个优化中，我们将数字直接按正确的顺序写入缓冲区。由于算法本身从右到左报告给定整数*N*的数字，所以我们也将它们从右到左写入缓冲区。
- en: '![](../Images/5e40d834500e2762bacc6ff457b9b769.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5e40d834500e2762bacc6ff457b9b769.png)'
- en: '*Filling produced digits into result array from right to left,'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*将生成的数字从右到左填入结果数组，'
- en: directly in the order they should have at the end.*
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 直接以它们在最终位置的顺序。*
- en: 'Pseudo-code with this optimization will look as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 伪代码将如下所示：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Note, in this and all other pseudo-codes within this story we are not handling
    the case of printing number “0”. According to all written algorithms, “0” will
    result as a sequence with no digits at all, and that is why in almost all printing
    algorithms, printing “0” is made in a separate branch. We will just skip that
    branch here for compactness.*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意，在本故事的此处和所有其他伪代码中，我们没有处理打印数字“0”的情况。根据所有编写的算法，“0”将显示为没有任何位的序列，因此在几乎所有打印算法中，打印“0”都在一个单独的分支中完成。我们这里只是为了简洁跳过了这个分支。*'
- en: Another small advantage of this optimization is that we are not required to
    write the terminating null-character after every conversion. Instead, we can write
    it only once in the last position of the buffer, as physically position of *N*’s
    last digit is fixed in advance, and it will always be the one-before-last position
    in the buffer.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个优化的另一个小优点是我们不需要在每次转换后都写入终止的空字符。相反，我们只需在缓冲区的最后一个位置写入一次，因为*N*的最后一位的物理位置是预先固定的，它将始终是缓冲区中倒数第二个位置。
- en: The drawback of this optimization is that the position of the first character
    becomes variable, as it becomes dependent on number of digits that integer *N*
    has.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这种优化的缺点是第一个字符的位置变得可变，因为它取决于整数*N*的位数。
- en: '![](../Images/79d34baef347509c42bd06c1ebbb6a7b.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/79d34baef347509c42bd06c1ebbb6a7b.png)'
- en: '*Drawback of optimization 1: numbers with different'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*优化 1 的缺点：不同'
- en: digits count will start in the output array from different positions.*
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 位数计数将在输出数组中从不同的位置开始。*
- en: However, practically, this does not become a problem, because the converted
    integers are often promptly sent to a text file or to the screen, thus not remaining
    in memory for long. And for such purposes we do not need for the converted digits
    to be written starting from some exactly in advance specified position of the
    memory.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，实际上这不会成为问题，因为转换后的整数通常会立即发送到文本文件或屏幕上，因此不会在内存中停留太久。对于这样的目的，我们不需要转换的数字从内存中某个精确指定的位置开始写入。
- en: Optimization 2
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化 2
- en: Next optimization is about using integer division and remainder calculation
    operations to obtain 2 digits of *N* in a single step. This trick is also well
    documented in [1] and [2]. For this purpose, instead of repeatedly calculating
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下一项优化是通过使用整数除法和余数计算操作来在单一步骤中获取*N*的2位数字。这个技巧在[1]和[2]中也有详细记录。为此，我们不再重复计算
- en: “digit := N mod 10”, followed by
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “digit := N mod 10”，接着
- en: “N := N / 10”,
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “N := N / 10”，
- en: 'we will calculate:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将计算：
- en: “digits := N mod 100”, followed by
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “digits := N mod 100”，接着
- en: “N := N / 100”,
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “N := N / 100”，
- en: which will give us the last 2 digits of *N*, and then will cut them both off.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们*N*的最后2位数字，然后将它们都剪掉。
- en: '![](../Images/ff4b7b909f5925ce5822cdecf056b8bc.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ff4b7b909f5925ce5822cdecf056b8bc.png)'
- en: '*Operations for printing number “5174092” with second optimization enabled:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*启用第二个优化的数字“5174092”打印操作：'
- en: 'Step 1: 5174092 % 100 = 92 (storing digits “92”) , 5174092 / 100 = 51740 (continuing
    with 51740),'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤 1：5174092 % 100 = 92（存储数字“92”），5174092 / 100 = 51740（继续处理51740），
- en: 'Step 2: 51740 % 100 = 40 (storing digits “40”) , 51740 / 100 = 517 (continuing
    with 517),'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤 2：51740 % 100 = 40（存储数字“40”），51740 / 100 = 517（继续处理517），
- en: 'Step 3: 517 % 100 = 17 (storing digits “17”) , 517 / 100 = 5 (continuing with
    5),'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤 3：517 % 100 = 17（存储数字“17”），517 / 100 = 5（继续处理5），
- en: 'Step 4: As “5 < 100”, just storing the last digit “5”.*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤 4：由于“5 < 100”，只存储最后一位数字“5”。*
- en: Note, in order to eventually and efficiently print those obtained 2 digits,
    here we should have prepared an array of length 100 (with indexes from 0 to 99
    — thus corresponding to all possible remainders “*N* mod 100”), where values will
    be pairs of characters, starting from “00”, “01”, “02”, … till “98”, “99”.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了最终高效地打印这些获得的2位数字，我们应该准备一个长度为100的数组（索引从0到99——因此对应所有可能的余数“*N* mod 100”），其中的值将是一对字符，从“00”，“01”，“02”，……一直到“98”，“99”。
- en: Within this optimization, count of integer division and remainder operations
    is reduced by almost 2 times.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在此优化中，整数除法和余数操作的数量减少了近2倍。
- en: Finalizing this part, I want to grab your attention to the fact that even with
    the described both optimizations enabled, we still do number of integer division
    and remainder calculation operations, proportional to the count of digits in given
    integer *N*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这部分后，我想引起你们的注意，即使启用了上述两个优化，我们仍然会进行与给定整数*N*中的数字数量成正比的整数除法和余数计算操作。
- en: 4\. My algorithm
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 我的算法
- en: I am going to propose another algorithm, which will accelerate integer printing
    by around **25–38%** for 32-bit integers, and around **40–58%** for 64-bit integers.
    The idea is — what if we pick digits out of given integer *N* not from right to
    left, but from left to right? So at first we will obtain its most significant
    digit, then the next significant digit, and so on, until only the least significant
    digit remains. Doing this becomes a bit difficult if we don’t know the count of
    digits of *N* in advance, but let us put that question aside for now, and assume
    that we already know that there are *L* digits in *N*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我打算提出另一种算法，这将使32位整数的整数打印加速约**25–38%**，64位整数的加速约**40–58%**。其思想是——如果我们从给定整数*N*中提取数字时不是从右到左，而是从左到右呢？所以首先我们会获得最重要的数字，然后是下一个重要的数字，依此类推，直到只剩下最不重要的数字。如果我们事先不知道*N*的位数，这会变得有点困难，但现在让我们暂时搁置这个问题，假设我们已经知道*N*中有*L*位数字。
- en: '![](../Images/22c9fdeb4133cfa5492899a06ec3ad2d.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/22c9fdeb4133cfa5492899a06ec3ad2d.png)'
- en: '*Example of an input number N which has L=7 digits.*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*具有L=7位的输入数字N的示例。*'
- en: 'How are we going to obtain the most significant digit then? Again using integer
    division, but this time as:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何获得最重要的数字呢？再次使用整数除法，但这次为：
- en: “digit := N / 10^(L-1)”
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “digit := N / 10^(L-1)”
- en: '![](../Images/fa94d37a7ab8097b8acb97d7440cf8de.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/fa94d37a7ab8097b8acb97d7440cf8de.png)'
- en: '*Examples of obtaining left-most digits of given integers.*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*获取给定整数的最左侧数字的示例。*'
- en: 'And how are we going to pick it out of *N*, in order to be able to continue
    with the remaining part? After knowing the value of the most significant digit
    is ‘*d*’, we can do the following subtraction:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何从 *N* 中提取它，以便能够继续处理剩余部分？在知道最重要的数字是‘*d*’后，我们可以进行以下减法操作：
- en: “N := N — d*10^(L-1)”
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “N := N — d*10^(L-1)”
- en: '![](../Images/bd48919c6a34696d2371b84e1c434434.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/bd48919c6a34696d2371b84e1c434434.png)'
- en: '*Examples of picking left-most digits out of given integers.*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*从给定整数中提取最左边数字的示例。*'
- en: 'Later we will repeat the division and subtraction operations, until *N* will
    become 1-digit integer (i.e. in range [0..9]), and finally will print that digit
    too. Let us view how the algorithm will work for case “*N* = 6''129”. Note, it
    has 4 digits, so here we start with “*L*=4”:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 后续我们将重复除法和减法操作，直到 *N* 变为 1 位整数（即范围 [0..9]），最终也会打印该数字。让我们看看算法在“*N* = 6'129”情况中的表现。请注意，它有
    4 位数字，所以这里我们从“*L*=4”开始。
- en: '![](../Images/c694fb85d20b3df719b7f8987ce71a67.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c694fb85d20b3df719b7f8987ce71a67.png)'
- en: '*Operations for printing number “6129” with my algorithm:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用我的算法打印数字“6129”的操作：'
- en: 'Step 1: 6129 / 1000 = 6 (printing digit ‘6’) , 6129–6*1000 = 129 (continuing
    with 129),'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤 1：6129 / 1000 = 6（打印数字‘6’），6129–6*1000 = 129（继续处理 129），
- en: 'Step 2: 129 / 100 = 1 (printing digit ‘1’) , 129–1*100 = 29 (continuing with
    29),'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤 2：129 / 100 = 1（打印数字‘1’），129–1*100 = 29（继续处理 29），
- en: 'Step 3: 29 / 10 = 2 (printing digit ‘2’) , 29–2*10 = 9 (continuing with 9),'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤 3：29 / 10 = 2（打印数字‘2’），29–2*10 = 9（继续处理 9），
- en: 'Step 4: As “9 < 10” just printing the last digit ‘9’.*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤 4：由于“9 < 10”，只需打印最后一位数字‘9’。*
- en: 'You might argue that calculating different powers of 10 is more time consuming
    than doing integer division or remainder calculation. And that will be absolutely
    correct except for one detail: we can precalculate all necessary powers of 10
    and use them during program’s entire execution. For 32-bit integers, there are
    only 10 different powers of 10, and for 64-bit integers, there are 20 powers of
    10\. So keeping them all precalculated in memory will not be an issue.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会争辩说，计算不同的 10 的幂比进行整数除法或取余计算更耗时。这绝对正确，除了一个细节：我们可以预计算所有必要的 10 的幂，并在程序的整个执行过程中使用它们。对于
    32 位整数，只有 10 个不同的 10 的幂，对于 64 位整数，有 20 个 10 的幂。因此，将它们全部预计算并保存在内存中不会成为问题。
- en: 'So what do we have in overall? In order to print one digit of *N* with my algorithm
    we do:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 那么总体上我们有什么？为了用我的算法打印一个 *N* 的数字，我们做：
- en: 1 integer division,
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1 次整数除法，
- en: 1 multiplication, and
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1 次乘法，以及
- en: 1 subtraction,
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1 次减法，
- en: 'compared to standard algorithm’s:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准算法相比：
- en: 1 remainder calculation and
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1 次取余计算以及
- en: 1 integer division.
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1 次整数除法。
- en: In the next section we will see that my approach is actually better, because
    multiplication and subtraction together take less CPU time than remainder calculation.
    Experimental comparison of time-consumption of those arithmetical operations was
    presented in chapter 2.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到我的方法实际上更好，因为乘法和减法加起来比取余计算消耗的 CPU 时间更少。这些算术操作的时间消耗实验比较在第2章中介绍过。
- en: 'Pseudo-code of the main part of my algorithm might look like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我算法的主要部分的伪代码可能如下所示：
- en: '[PRE2]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As my algorithm prints digits of *N* from left to right, I want to call it “Left-to-right
    printer” or shortly “LR printer”.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我的算法从左到右打印 *N* 的数字，我想称之为“左到右打印机”或简短为“LR 打印机”。
- en: The one thing which remains yet is to efficiently find *L* — count of decimal
    digits of *N*. And luckily for us, the precalculated array of powers of 10 will
    help here too. We can just iterate over that array from small powers to the larger
    ones, until finding such power 10^*L* which will be greater than *N*. Then the
    exponent *L* will itself represent the count of digits in *N*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事需要高效找到 *L* — *N* 的十进制数字计数。幸运的是，预计算的 10 的幂数组在这里也会有帮助。我们只需从小的幂次迭代到较大的幂次，直到找到比
    *N* 大的幂 10^*L*。然后，指数 *L* 本身将表示 *N* 中的数字计数。
- en: 'For example, obtaining count of digits for “*N* = 23''504” will look as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，获取“*N* = 23'504”的数字计数如下所示：
- en: '![](../Images/57dc41e4f0e3ee32110640fd157ad198.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/57dc41e4f0e3ee32110640fd157ad198.png)'
- en: '*How the count of digits L is being calculated for number N = 23''504.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*如何计算数字 N = 23''504 的数字计数 L。*'
- en: We sequentially compare N to powers of 10, until N becomes less.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们依次将 N 与 10 的幂比较，直到 N 变小。
- en: That happens on power 100'000 which is 10⁵, so we conclude that L=5.*
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这发生在 100'000 的幂次上，即 10⁵，因此我们得出结论 L=5。*
- en: 'Pseudo-code of that function might look like:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的伪代码可能如下所示：
- en: '[PRE3]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With this 2 parts we are providing complete algorithm for converting integers
    to strings.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这两个部分，我们提供了将整数转换为字符串的完整算法。
- en: Note, as “LR printer” reports digits of *N* from left to right, there is no
    need to do any reversing at the end. Also, in contrast to existing optimization
    1, here we keep the ability of specifying if where in memory the first digit of
    converted *N* should be placed.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于“LR 打印机”从左到右报告 *N* 的数字，因此最后不需要做任何反转。此外，与现有的优化 1 相比，这里我们保留了指定转换后的 *N* 的第一个数字应放置在内存中的位置的能力。
- en: “LR printer” can be used for printing numbers in any base (not just base 10).
    For doing so, we will only need to replace the precalculated powers of 10 with
    precalculated powers of the new base.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: “LR 打印机”可以用于打印任何基数的数字（不仅仅是 base 10）。为此，我们只需要用新基数的预计算幂替换预计算的 10 的幂。
- en: Implementation of “LR printer” in C++ language can be found on GitHub at [3].
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: “LR 打印机”在 C++ 语言中的实现可以在 GitHub 上找到，链接为 [3]。
- en: '*Optimization 2 for “LR printer”*'
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*“LR 打印机”的优化 2*'
- en: My algorithm can be enhanced with the second optimization described in “Existing
    optimizations” section, and documented in [1] and [2]. If done, then instead of
    printing the given number by 1 digit at a step, we will print it by 2 digits at
    a single step.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我的算法可以通过在“现有优化”部分中描述的第二次优化进行增强，并在 [1] 和 [2] 中进行了记录。如果进行优化，则我们将每次打印 2 位数字，而不是逐位打印。
- en: 'Let’s see how it will run for example on number “*N* = 4''610''937”. Here *L*=7,
    and we start by dividing *N* over 10^(L-2)=10''000 this time:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它如何在数字“*N* = 4'610'937”上运行。这里 *L*=7，我们这次从将 *N* 除以 10^(L-2)=10'000 开始：
- en: '![](../Images/c243cca15d3805619d805fc2b98a5f48.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c243cca15d3805619d805fc2b98a5f48.png)'
- en: '*Actions for printing number “4610937” with second optimization enabled for
    “LR printer”:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*启用第二次优化的“LR 打印机”打印数字“4610937”的操作：'
- en: 'Step 1: 4610937 / 10⁵ = 46 (printing digits ‘46’) , 4610937–46*10⁵ = 10937
    (continuing with number 10937),'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤 1：4610937 / 10⁵ = 46（打印数字‘46’），4610937–46*10⁵ = 10937（继续处理数字 10937），
- en: 'Step 2: 10937 / 10³ = 10 (printing digits ‘10’) , 10937–10*10³ = 937 (continuing
    with number 937),'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤 2：10937 / 10³ = 10（打印数字‘10’），10937–10*10³ = 937（继续处理数字 937），
- en: 'Step 3: 937 / 10 = 93 (printing digits ‘93’) , 937–93*10 = 7 (continuing with
    number 7),'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤 3：937 / 10 = 93（打印数字‘93’），937–93*10 = 7（继续处理数字 7），
- en: 'Step 4: As “7 < 100”, just printing the last digit ‘7’.*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤 4：由于“7 < 100”，只打印最后一位数字‘7’。*
- en: 'By enabling this, we will spend:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 启用此功能后，我们将花费：
- en: 1 integer division,
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1 次整数除法，
- en: 1 multiplication, and
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1 次乘法，以及
- en: 1 subtraction,
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1 次减法，
- en: per 2 digits of the input number.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 每 2 位输入数字。
- en: Here again, the digits will be obtained in their natural order — from left to
    right, so there is no need to reverse them at the end.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，数字将按其自然顺序 — 从左到右获取，因此无需在最后进行反转。
- en: Implementation of “LR printer” with second optimization enabled can also be
    found on GitHub at [3].
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 启用第二次优化的“LR 打印机”的实现也可以在 GitHub 上找到，链接为 [3]。
- en: 5\. Experimental comparison with existing algorithms
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5\. 与现有算法的实验比较
- en: 'Doing experimental comparison is essential for this type of work, so in this
    chapter I will present results of comparison between the following integer-printing
    algorithms:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 进行实验比较对于这类工作至关重要，因此在本章中，我将展示以下整数打印算法的比较结果：
- en: the standard algorithm with first optimization (labeled as “Std”),
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个优化的标准算法（标记为“Std”），
- en: my algorithm “LR printer” (labeled as “LR”),
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的算法“LR 打印机”（标记为“LR”），
- en: standard algorithm with second optimization too (labeled as “Std [2-dig]”),
    and
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准算法的第二次优化（标记为“Std [2-dig]”）和
- en: “LR printer” with second optimization (labeled as “LR [2-dig]”).
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 含第二次优化的“LR 打印机”（标记为“LR [2-dig]”）。
- en: Each of those algorithms is tested both on 32-bit and 64-bit integers, with
    different count of digits of the input numbers.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这些算法都在 32 位和 64 位整数上进行了测试，输入数字的位数不同。
- en: 'Printing numbers in base=10:'
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 base=10 中打印数字：
- en: 'Results when printing in number *base*=10 (the ordinary case) are:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在*基数*=10（普通情况）下打印的结果是：
- en: '![](../Images/f3f2cda188c3dc87927d43c604a6f007.png)![](../Images/7157dd90303bf97121bc29b03eea9e1e.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f3f2cda188c3dc87927d43c604a6f007.png)![](../Images/7157dd90303bf97121bc29b03eea9e1e.png)'
- en: '*Time (in nanoseconds) spent to print 1 number (either 32-bit or 64-bit),'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*打印 1 个数字（无论是 32 位还是 64 位）所花费的时间（以纳秒为单位），'
- en: having certain count of digits, with different algorithms.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 具有特定位数的不同算法。
- en: Printing is done in base=10.*
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 打印是在 base=10 中完成的。*
- en: For 32-bit integers, we can see that the gain of “LR printer” compared to standard
    printer is around **30–38%**. The gain when printing with second optimization
    (printing 2 digits at single step) is lower — **13–28%**. This is totally expected,
    as overall we do only 2 or 4 steps in that case.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 32 位整数，我们可以看到“LR printer”相较于标准打印机的性能提升约为**30–38%**。当启用第二次优化（每步打印 2 位）时，性能提升较低，为**13–28%**。这是完全预期的，因为总体上我们只执行了
    2 或 4 步。
- en: When it comes to printing 64-bit integers, performance of my algorithm is even
    better. “LR printer” runs around **40–50%** faster than the standard algorithm.
    And with second optimization enabled for both, “LR printer” performs **47–58%**
    faster.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在打印 64 位整数时，我的算法表现更佳。“LR printer”比标准算法快约**40–50%**。当两者都启用第二次优化时，“LR printer”性能提升**47–58%**。
- en: 'Percentage in the title of this story was chosen by addressing the most regular
    case: when we are in *base*=10, working with 32-bit integers, and assuming they
    have many digits. For that case performance gain of “LR printer” over standard
    algorithm was 30–38%, so taking the average makes around 34%.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 本故事标题中的百分比是通过考虑最常见的情况选择的：当我们在 *base*=10 下处理 32 位整数，并假设它们有许多位数时。在这种情况下，“LR printer”相对于标准算法的性能提升为
    30–38%，所以取平均数大约为 34%。
- en: 'Printing numbers in base=3:'
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 base=3 中打印数字：
- en: 'Let’s also see if the results will differ significantly when printing integers
    in another base. We will observe printing in number *base*=3:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在其他基数下打印整数时结果是否会显著不同。我们将观察在数字 *base*=3 中的打印情况：
- en: '![](../Images/c52a7f84592d708358720c41e2f11555.png)![](../Images/8b03d4fa77d6bdc865cbdc6de0a44a8e.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c52a7f84592d708358720c41e2f11555.png)![](../Images/8b03d4fa77d6bdc865cbdc6de0a44a8e.png)'
- en: '*Time (in nanoseconds) spent to print 1 number (either 32-bit or 64-bit),'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*打印一个数字（无论是 32 位还是 64 位）所花费的时间（以纳秒为单位），'
- en: having certain count of digits, with different algorithms.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 具有一定数量位数的情况下，使用不同算法。
- en: Printing is done in base=3.*
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 打印是在 base=3 中进行的。
- en: As we can see here, for 32-bit integers performance gain of “LR-printer” over
    the standard algorithm is around **25–33%**, which generally corresponds to the
    difference in performance of used arithmetical operations.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，对于 32 位整数，“LR-printer”相对于标准算法的性能提升约为**25–33%**，这通常对应于所使用算术操作的性能差异。
- en: And for 64-bit integers performance gain of “LR-printer” is around **50–55%**
    for short numbers (8 digits), and **27–30%** for long numbers (36 digits).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 64 位整数，“LR-printer”的性能提升约为短数字（8 位）**50–55%**，长数字（36 位）**27–30%**。
- en: '*Overall remarks*'
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*总体备注*'
- en: Generally, the base in which integers are printed doesn’t affect relative performance
    gain much, as the count of operations to be performed during print is proportional
    to the count of digits that the input numbers have, and not to the number of possible
    values that those digits might have.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，整数打印的基数不会对相对性能提升产生太大影响，因为打印过程中要执行的操作数量与输入数字的位数成正比，而不是这些位数可能具有的值的数量。
- en: Almost always it is the case that the greater the count of digits is, that more
    “LR-printer” (or “LR-printer [2-dig]” variation) will outperform the standard
    printing algorithm (or its “2-dig” variation). This is also clear, because the
    more digits we have, that less impact will have the out-of-loop instructions (like
    calling one function from another, or placing the null-terminating character).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎总是这样，数字位数越多，“LR-printer”（或“LR-printer [2-dig]”变体）比标准打印算法（或其“2-dig”变体）的表现会更好。这一点也很明确，因为位数越多，循环外指令的影响（如从一个函数调用另一个函数或放置空字符）越小。
- en: And overall, when printing 64-bit integers, results are more impressive for
    both “LR-printer” and “LR-printer [2-dig]” variation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，在打印 64 位整数时，“LR-printer”和“LR-printer [2-dig]”变体的结果都更令人印象深刻。
- en: Personally for me, those results as quite notable.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对我个人而言，这些结果相当显著。
- en: 6\. Conclusion
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. 结论
- en: We have presented a new algorithm for converting integers to strings, and called
    it “LR printer”. It runs by **25–38%** faster for 32-bit integers, and **40–58%**
    faster for 64-bit integers, compared to the optimized standard conversion algorithm.
    Our algorithm can work in any number base (not only in ordinary base 10).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提出了一种将整数转换为字符串的新算法，称为“LR printer”。与优化后的标准转换算法相比，它在 32 位整数上运行**25–38%**更快，在
    64 位整数上运行**40–58%**更快。我们的算法可以在任何数字基数下工作（不仅仅是在普通的 base 10 下）。
- en: The algorithm which converts integers into strings is never a bottleneck for
    applications that print only a few numbers during their lifetime. But for other
    types of applications, which automatically generate text files such as *.csv,
    *xml or *.json, the efficiency of the conversion algorithm matters. This is especially
    the case if those text files are going to contain lots of numbers, as is the case
    when exporting large datasets.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 将整数转换为字符串的算法在仅打印少量数字的应用程序中从不成为瓶颈。但对于其他类型的应用程序，例如自动生成 *.csv、*xml 或 *.json 等文本文件的应用程序，转换算法的效率就显得尤为重要。特别是当这些文本文件将包含大量数字时，例如在导出大型数据集时。
- en: Huge thanks for reading till the end! Will be glad to read any comments below!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 非常感谢你读到最后！很高兴看到你在下面的评论！
- en: I express my gratitude to David Ayrapetyan ([https://www.linkedin.com/in/davidayrapetyan/](https://www.linkedin.com/in/davidayrapetyan/)),
    for careful reviewing the draft of this story, and proposing multiple contextual
    enhancements and grammatical corrections.
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我向 David Ayrapetyan 表示感谢 ([https://www.linkedin.com/in/davidayrapetyan/](https://www.linkedin.com/in/davidayrapetyan/))，感谢他仔细审阅了本故事的草稿，并提出了多个上下文改进和语法修正。
- en: ''
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Gratitude to Hayk Aslanyan ([https://www.linkedin.com/in/haykaslanyan/](https://www.linkedin.com/in/haykaslanyan/)),
    for making technical review of the draft, and proposing other enhancements.
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 感谢 Hayk Aslanyan ([https://www.linkedin.com/in/haykaslanyan/](https://www.linkedin.com/in/haykaslanyan/))，感谢他对草稿进行了技术审查，并提出了其他改进建议。
- en: ''
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Illustrations design by Asya Papyan: [https://www.behance.net/asyapapyan](https://www.behance.net/asyapapyan)'
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '插图设计由 Asya Papyan 制作: [https://www.behance.net/asyapapyan](https://www.behance.net/asyapapyan)'
- en: ''
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you enjoyed reading this story, you can find me on LinkedIn at: [https://www.linkedin.com/in/tigran-hayrapetyan-88989b12/](https://www.linkedin.com/in/tigran-hayrapetyan-88989b12/)'
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你喜欢阅读这个故事，可以在 LinkedIn 上找到我： [https://www.linkedin.com/in/tigran-hayrapetyan-88989b12/](https://www.linkedin.com/in/tigran-hayrapetyan-88989b12/)
- en: References
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[1] : “Integer to string conversion” — [https://tia.mat.br/posts/2014/06/23/integer_to_string_conversion.html](https://tia.mat.br/posts/2014/06/23/integer_to_string_conversion.html)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] : “整数到字符串转换” — [https://tia.mat.br/posts/2014/06/23/integer_to_string_conversion.html](https://tia.mat.br/posts/2014/06/23/integer_to_string_conversion.html)'
- en: '[2] : “Three optimization tips for C++” — [https://www.facebook.com/notes/10158791579037200/](https://www.facebook.com/notes/10158791579037200/)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[2] : “C++ 的三个优化技巧” — [https://www.facebook.com/notes/10158791579037200/](https://www.facebook.com/notes/10158791579037200/)'
- en: '[3] : “LR printer implementation in C++ language” — [https://github.com/tigranh/lr_printer](https://github.com/tigranh/lr_printer)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[3] : “C++ 语言中的 LR 打印机实现” — [https://github.com/tigranh/lr_printer](https://github.com/tigranh/lr_printer)'
