- en: 'Monte Carlo Approximation Methods: Which one should you choose and when?'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蒙特卡罗近似方法：你应该选择哪一种，何时使用？
- en: 原文：[https://towardsdatascience.com/monte-carlo-approximation-methods-which-one-should-you-choose-and-when-886a379fb6b?source=collection_archive---------5-----------------------#2023-08-25](https://towardsdatascience.com/monte-carlo-approximation-methods-which-one-should-you-choose-and-when-886a379fb6b?source=collection_archive---------5-----------------------#2023-08-25)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/monte-carlo-approximation-methods-which-one-should-you-choose-and-when-886a379fb6b?source=collection_archive---------5-----------------------#2023-08-25](https://towardsdatascience.com/monte-carlo-approximation-methods-which-one-should-you-choose-and-when-886a379fb6b?source=collection_archive---------5-----------------------#2023-08-25)
- en: Is it Inverse Transformation, Random Walk Metropolis-Hastings, or Gibbs? An
    analysis focusing on the mathematical foundation, Python implementation from scratch,
    and pros/cons of each method
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 是逆变换、随机游走Metropolis-Hastings，还是Gibbs？对每种方法的数学基础、从零开始的Python实现以及优缺点的分析
- en: '[](https://susiesyli.medium.com/?source=post_page-----886a379fb6b--------------------------------)[![Suyang
    Li](../Images/9612066e1b048c1289f133e909cb21e8.png)](https://susiesyli.medium.com/?source=post_page-----886a379fb6b--------------------------------)[](https://towardsdatascience.com/?source=post_page-----886a379fb6b--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----886a379fb6b--------------------------------)
    [Suyang Li](https://susiesyli.medium.com/?source=post_page-----886a379fb6b--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://susiesyli.medium.com/?source=post_page-----886a379fb6b--------------------------------)[![Suyang
    Li](../Images/9612066e1b048c1289f133e909cb21e8.png)](https://susiesyli.medium.com/?source=post_page-----886a379fb6b--------------------------------)[](https://towardsdatascience.com/?source=post_page-----886a379fb6b--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----886a379fb6b--------------------------------)
    [Suyang Li](https://susiesyli.medium.com/?source=post_page-----886a379fb6b--------------------------------)'
- en: ·
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F2b9882509386&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmonte-carlo-approximation-methods-which-one-should-you-choose-and-when-886a379fb6b&user=Suyang+Li&userId=2b9882509386&source=post_page-2b9882509386----886a379fb6b---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----886a379fb6b--------------------------------)
    ·12 min read·Aug 25, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F886a379fb6b&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmonte-carlo-approximation-methods-which-one-should-you-choose-and-when-886a379fb6b&user=Suyang+Li&userId=2b9882509386&source=-----886a379fb6b---------------------clap_footer-----------)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[关注](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F2b9882509386&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmonte-carlo-approximation-methods-which-one-should-you-choose-and-when-886a379fb6b&user=Suyang+Li&userId=2b9882509386&source=post_page-2b9882509386----886a379fb6b---------------------post_header-----------)
    发表在 [Towards Data Science](https://towardsdatascience.com/?source=post_page-----886a379fb6b--------------------------------)
    · 12 min read · 2023年8月25日'
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F886a379fb6b&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmonte-carlo-approximation-methods-which-one-should-you-choose-and-when-886a379fb6b&source=-----886a379fb6b---------------------bookmark_footer-----------)![](../Images/a69c02e7513a5252713b3e1deb243285.png)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F886a379fb6b&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmonte-carlo-approximation-methods-which-one-should-you-choose-and-when-886a379fb6b&source=-----886a379fb6b---------------------bookmark_footer-----------)![](../Images/a69c02e7513a5252713b3e1deb243285.png)'
- en: Photo by [Joakim Honkasalo](https://unsplash.com/@jhonkasalo?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由[Joakim Honkasalo](https://unsplash.com/@jhonkasalo?utm_source=medium&utm_medium=referral)拍摄，发布在[Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: Introduction to Approximation Sampling
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 近似抽样介绍
- en: For most probabilistic models of practical interest, exact inference is intractable,
    and so we have to resort to some form of approximation.
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于大多数实际应用中的概率模型，精确推理是不可行的，因此我们必须采用某种形式的近似。
- en: ''
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: — Pattern Recognition and Machine Learning¹
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: — 模式识别与机器学习¹
- en: 'Since deterministic inference is often intractable with probabilistic models
    as we saw just now, we now turn to approximation methods based on numerical sampling,
    which are known as **Monte Carlo** techniques. The key question we will look at
    with these methods is computing the expectation of a target function *f(z)* given
    a probability distribution *p(z)*. Recall that the simple definition of expectation
    is given as an integral:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于如刚刚所见，确定性推断在概率模型中通常难以处理，因此我们现在转向基于数值采样的近似方法，这些方法被称为**蒙特卡罗**技术。我们将研究这些方法的关键问题是给定概率分布*p(z)*下目标函数*f(z)*的期望值计算。回顾一下，期望的简单定义是通过积分给出的：
- en: '![](../Images/e9e87120954cc0e72e3fbda6c6d18435.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e9e87120954cc0e72e3fbda6c6d18435.png)'
- en: 'Source: PRML¹ Eq. 11.1'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：PRML¹ Eq. 11.1
- en: As we will see, these integrals are too **computationally complex**, so we will
    turn to **sampling methods** in this article.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的，这些积分过于**计算复杂**，因此我们将在本文中转向**采样方法**。
- en: 'In this article, we will look at 3 core sampling methods: **inverse transformation**,
    Markov chain Monte Carlo (MCMC), and **Gibbs** Sampling. By understanding the
    underlying statistical properties and computational requirements of these methods,
    we will learn that:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们将研究三种核心采样方法：**逆变换**、马尔可夫链蒙特卡罗（MCMC）和**Gibbs** 采样。通过理解这些方法的基本统计属性和计算要求，我们将了解到：
- en: '**Inverse transformation sampling** is best for simulating data with high accuracy
    from known and simple distributions, particularly in low dimensions.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逆变换采样**最适合从已知和简单分布中高精度地模拟数据，特别是在低维情况下。'
- en: '**Random Walk Metropolis-Hastings** is best for complex, multi-modal, or unknown
    distributions, where global exploration and/or convergence is a priority; specifically,
    the **Metropolis** algorithm — a specific instance of Metropolis-Hastings — can
    be used for symmetric distributions.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随机游走 Metropolis-Hastings** 最适合复杂、多模态或未知分布，其中全球探索和/或收敛是优先考虑的；具体而言，**Metropolis**
    算法——Metropolis-Hastings 的一个特定实例——可以用于对称分布。'
- en: '**Gibbs Sampling** is best for high-dimensional problems where conditional
    distributions are easy to sample from, and efficiency is a priority.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Gibbs 采样**最适合高维问题，其中条件分布容易采样，并且效率是优先考虑的。'
- en: Table of Contents
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目录
- en: '[Inverse Transform Sampling](#e96f)'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[逆变换采样](#e96f)'
- en: • [How does the algorithm work?](#93fc)
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: • [算法如何工作？](#93fc)
- en: • [Python Implementation](#d1ff)
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: • [Python 实现](#d1ff)
- en: • [Prerequisites](#c20f)
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: • [前提条件](#c20f)
- en: • [Pros & cons](#9cdd)
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: • [优缺点](#9cdd)
- en: '[Markov Chain Monte Carlo](#d20d)'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[马尔可夫链蒙特卡罗](#d20d)'
- en: • [Metropolis-Hastings Algorithm](#2847)
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: • [Metropolis-Hastings 算法](#2847)
- en: '• [Special Instance: Metropolis Algorithm for Symmetrical Distribution](#bfed)'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: • [特殊情况：对称分布的 Metropolis 算法](#bfed)
- en: • [Pros/Cons](#76a3)
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: • [优缺点](#76a3)
- en: '[Gibbs](#c3b6)'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[Gibbs](#c3b6)'
- en: • [Algorithm](#42ee)
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: • [算法](#42ee)
- en: • [Conditions](#cf29)
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: • [条件](#cf29)
- en: • [Gibbs’ relationship with Metropolis-Hastings](#0cf9)
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: • [Gibbs 与 Metropolis-Hastings 的关系](#0cf9)
- en: '[Comparison: Pros/Cons of Transformation vs. Met-Hastings vs. Gibbs](#e6ac)'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[比较：转换 vs. Met-Hastings vs. Gibbs 的优缺点](#e6ac)'
- en: '1\. Transformation Method: Inverse CDF'
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1\. 转换方法：逆 CDF
- en: 'Inverse Transform Sampling, as its name suggests, uses the inverse cumulative
    distribution function (CDF) of a target distribution to generate random numbers
    that follow a desired distribution. The basic idea is:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 逆变换采样，顾名思义，使用目标分布的逆累积分布函数（CDF）生成符合期望分布的随机数。基本思想是：
- en: '**Generate a Uniform Random Number**: We draw a number *U* from a uniform distribution
    between 0 and 1.'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**生成一个均匀随机数**：我们从 0 到 1 之间的均匀分布中抽取一个数 *U*。'
- en: '**Apply the Inverse CDF**: Using the inverse of the target distribution’s CDF,
    transform *U* into a sample that follows the target distribution.'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**应用逆 CDF**：利用目标分布 CDF 的逆，将 *U* 转换为符合目标分布的样本。'
- en: 'Here’s a quick illustration of how the samples (blue) are drawn from the distribution
    (red):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是样本（蓝色）如何从分布（红色）中抽取的简要说明：
- en: '![](../Images/8e5d2b1707e1d71d1887eeaec4b24878.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8e5d2b1707e1d71d1887eeaec4b24878.png)'
- en: Inverse CDF is a **computationally** **simple and generalizable** method to
    sample from distributions for which **we know the CDF**, such as the normal, exponential,
    gamma or beta distribution.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 逆 CDF 是一种**计算上** **简单且可推广**的方法，用于从已知 CDF 的分布中进行采样，例如正态分布、指数分布、伽马分布或贝塔分布。
- en: PDF, CDF, and Inverse CDF
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PDF、CDF 和逆 CDF
- en: '![](../Images/30e9376ff43939896930449104c0eb74.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/30e9376ff43939896930449104c0eb74.png)'
- en: '(From left to right): PDF, CDF, and Inverse CDF of the standard normal distribution'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: （从左到右）：标准正态分布的 PDF、CDF 和逆CDF
- en: In intuitive terms, the CDF is the cumulative value of the PDF, which is equal
    to the integral of the PDF; then we take the inverse of the CDF function to get
    the final inverse CDF used for this method.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从直观上讲，CDF 是 PDF 的累计值，相当于 PDF 的积分；然后我们取 CDF 函数的逆函数，以获得用于此方法的最终逆CDF。
- en: 'Formally, if *a* is a random variable, then the CDF of *a* is given by:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正式来说，如果 *a* 是一个随机变量，那么 *a* 的 CDF 给出如下：
- en: '![](../Images/e5505c7ce4a106b209e247f362f59bd8.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e5505c7ce4a106b209e247f362f59bd8.png)'
- en: PRML, Eq. 11.5–11.6
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: PRML，第 11.5–11.6 节
- en: 'A CDF *F* has the following key properties:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: CDF *F* 具有以下关键属性：
- en: '*F* is continuous'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*F* 是连续的'
- en: '*F* is non-decreasing'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*F* 是单调非减的'
- en: '*F* has range 0 ≤ cdf(*a*) ≤ 1 for all *a* ∈ R'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*F* 的范围是 0 ≤ cdf(*a*) ≤ 1 对于所有 *a* ∈ R'
- en: How does the inverse CDF algorithm work?
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逆CDF 算法是如何工作的？
- en: 'The algorithm consists of the following ingredients:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法包含以下要素：
- en: '**Input:**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入：**'
- en: '`U`: *U* is a uniform random variable drawn between 0 and 1.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`U`：*U* 是一个从 0 到 1 之间均匀分布的随机变量。'
- en: This serves as the input probability for the inverse CDF and is what will be
    transformed into a sample from the desired distribution.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这作为逆CDF的输入概率，并将被转换为来自期望分布的样本。
- en: '**Parameter**:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数**：'
- en: '`*F:*`the CDF of the target distribution.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*F:*` 目标分布的 CDF。'
- en: With *F,* we can simply compute its inverse, *F*^-1, and use it to map an input
    value to the desired domain
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *F*，我们可以简单地计算其逆函数 *F*^-1，并用它将输入值映射到期望的领域。
- en: '**Output**:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**：'
- en: '`x`: a random sample drawn from the target distribution.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`：从目标分布中抽取的随机样本。'
- en: This is generated by applying the inverse CDF to the random number from the
    uniform distribution (input).
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是通过将逆CDF 应用到均匀分布的随机数（输入）来生成的。
- en: Python Implementation
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 实现
- en: 'Now, let’s implement this method from scratch. We will use the exponential
    function since it will be easy to visualize our samples drawn by inverse CDF and
    compare them to the exact distribution:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从头开始实现这个方法。我们将使用指数函数，因为它将容易可视化我们通过逆CDF 生成的样本，并与精确分布进行比较：
- en: '![](../Images/8af34e7ef1b6f16d77f29a6bcf53a72f.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8af34e7ef1b6f16d77f29a6bcf53a72f.png)'
- en: PDF of the exponential function (target distribution)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 指数函数（目标分布）的 PDF
- en: 'By standard calculus integration techniques, we find that the target CDF *F(x)*
    is:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过标准微积分积分技术，我们发现目标 CDF *F(x)* 是：
- en: '![](../Images/664a8e1ee0c2a55acb775c804eb7eade.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/664a8e1ee0c2a55acb775c804eb7eade.png)'
- en: CDF of the exponential function
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 指数函数的 CDF
- en: 'The inverse of this CDF is:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 CDF 的逆函数是：
- en: '![](../Images/8b54a28e59301732af785e77bcb20428.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8b54a28e59301732af785e77bcb20428.png)'
- en: Inverse CDF of the exponential function
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 指数函数的逆CDF
- en: 'We will generate 5000 samples using the Inverse CDF method:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用逆CDF 方法生成 5000 个样本：
- en: '[PRE0]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![](../Images/8e5d2b1707e1d71d1887eeaec4b24878.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8e5d2b1707e1d71d1887eeaec4b24878.png)'
- en: Requirements for the inverse CDF algorithm to work
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逆CDF 算法工作的要求
- en: 'The inverse CDF method makes a key assumption:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 逆CDF 方法做了一个关键假设：
- en: '**CDF *F* is invertible**: The CDF *F* must be **invertible**, meaning that
    each input to *F* must have a unique output'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CDF *F* 是可逆的**：CDF *F* 必须是**可逆的**，这意味着每个输入到 *F* 的值必须有唯一的输出。'
- en: 'This constraint rules out a number of functions. For example, below are a few
    function types that are common but **non-invertible** (and thus would **not work
    with inverse CDF)**:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个约束排除了一些函数。例如，下面是一些常见但**不可逆**的函数类型（因此**不能与逆CDF 一起使用**）：
- en: '**Constant functions**: Any constant function in the form of *f(x) = c* where
    *c* is a constant is not invertible since every input maps to the same output
    and thus the function is **not one-to-one**.'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**常数函数**：任何形式为 *f(x) = c* 的常数函数，其中 *c* 是常数，都不是可逆的，因为每个输入都映射到相同的输出，因此该函数**不是一对一的**。'
- en: '![](../Images/f63ff25af3ce705bdb89e0ff2d1d784c.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f63ff25af3ce705bdb89e0ff2d1d784c.png)'
- en: The red dots show two of the many x values that map to the same y value in f(x)
    = 5, making it non-invertible
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 红点显示了映射到相同 y 值的多个 x 值中的两个，这使得 f(x) = 5 变得不可逆。
- en: '2. **Certain quadratic functions**: For example *f(x) = x^2* is non-invertible
    since it’s many-to-one (consider *f(x) = 1*, *x* could be *1* or *-1*).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 2. **某些二次函数**：例如 *f(x) = x^2* 是不可逆的，因为它是多对一的（考虑 *f(x) = 1*，*x* 可以是 *1* 或 *-1*）。
- en: '![](../Images/59146469e51e069c4e325cca1b4509db.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/59146469e51e069c4e325cca1b4509db.png)'
- en: The red dots show one of the many pairs of x values that map to the same y value
    in f(x) = x²
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 红点显示了映射到相同 y 值的多个 x 值中的一对，在 f(x) = x² 中。
- en: '3\. **Certain trigonometric functions**: For example *f(x) = sin(x)* is not
    invertible over their entire domain since they are periodic, although with **restricted
    domains** they may be made invertible.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. **某些三角函数**：例如 *f(x) = sin(x)* 在其整个域上不可逆，因为它们是周期性的，尽管在**限制域**上它们可能变得可逆。
- en: '![](../Images/eec4b28788026f8b59493e8bd239dbbe.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/eec4b28788026f8b59493e8bd239dbbe.png)'
- en: The red dots show one of the many sets of x values that map to the same y value
    in f(x) = sin(x) due to its periodicity over the given domain
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 红点显示了由于周期性，在 f(x) = sin(x) 给定域上映射到相同 y 值的多个 x 值集合之一。
- en: Why does inverse CDF work?
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么逆累积分布函数（CDF）有效？
- en: The key idea is that a **random variable uniformly distributed between 0 and
    1** can be transformed into a **random variable with a certain distribution**
    by applying the inverse of the target distribution’s CDF, which is assumed to
    be known and tractable.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 关键思想是，一个**在0到1之间均匀分布的随机变量**可以通过应用目标分布CDF的逆变换成**具有特定分布的随机变量**，前提是该分布的CDF已知且易于处理。
- en: Advantages
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优势
- en: '**Algorithmic simplicity**: it’s very easy to implement with lower-dimensional
    data, thus having a wide application area across different fields and tasks.'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**算法简单性**：对于低维数据，实现起来非常容易，因此在不同领域和任务中有广泛的应用。'
- en: '**Sample accuracy:** assuming the CDF and its inversion represents the exact
    target distribution, the method yields a relatively high exactness compared to
    other methods such as MCMC which we will see soon.'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**样本准确性**：假设CDF及其逆函数表示准确的目标分布，该方法相比于其他方法（如稍后会看到的MCMC），具有相对较高的准确性。'
- en: Disadvantages
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺点
- en: '**Computational complexity**: For some distributions, the inverse CDF may not
    have a closed-form expression, making computation challenging or expensive.'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**计算复杂性**：对于一些分布，逆CDF可能没有封闭形式表达式，使得计算具有挑战性或昂贵。'
- en: '**Difficulty with high dimensionality**: It can be difficult to apply in high-dimensional
    spaces, especially with dependencies between variables.'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**高维度难度**：在高维空间中应用可能很困难，尤其是当变量之间存在依赖关系时。'
- en: '**Invertibility constraint**: Anytime a CDF is non-invertible, this method
    becomes invalid. This excludes a number of functions as we saw above.'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**可逆性限制**：任何CDF不可逆时，该方法将变得无效。这排除了我们上面看到的一些函数。'
- en: '**Limited to known distributions**: Inverse CDF requires the exact form of
    the CDF, limiting its application to known distributions only.'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**限于已知分布**：逆CDF需要CDF的准确形式，这限制了其仅能应用于已知分布。'
- en: Taking all these limitations into account, there are only a few categories of
    distributions that we can apply inverse CDF to. In reality, with Big Data and
    unknown distributions, this method can quickly become unavailable.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些限制，我们只能将逆CDF应用于少数几类分布。实际上，面对大数据和未知分布时，这种方法可能会迅速失效。
- en: 'With these advantages and disadvantages in mind, let’s now look at another
    random sampling framework that tackles these limitations: **Markov Chain Monte
    Carlo (MCMC).**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这些优缺点后，让我们现在来看另一种随机采样框架，**马尔可夫链蒙特卡罗（MCMC）**，它解决了这些限制。
- en: 2\. Markov Chain Monte Carlo (MCMC)
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. 马尔可夫链蒙特卡罗（MCMC）
- en: As we saw just now, the inverse CDF transformation method is **highly limited**,
    especially with **high dimensional** sample spaces. Markov Chain Monte Carlo (MCMC),
    on the other hand, scales well with dimensionality, enabling us to sample from
    a much larger family of distributions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才看到的，逆CDF变换方法**高度受限**，尤其是在**高维**样本空间中。另一方面，马尔可夫链蒙特卡罗（MCMC）在维度上表现良好，使我们能够从更大的分布家族中进行采样。
- en: '![](../Images/7aadb0e9bfad08606a83b2bcb0f4a4a4.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7aadb0e9bfad08606a83b2bcb0f4a4a4.png)'
- en: An example of Metropolis-Hastings exploring a mixed Gaussian (left), generating
    samples (right)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Metropolis-Hastings 例子探索混合高斯分布（左），生成样本（右）
- en: How does the Metropolis-Hastings algorithm work?
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Metropolis-Hastings 算法是如何工作的？
- en: 'In intuitive terms, the algorithm works in the following steps: Similar to
    inverse CDF, we have a **target distribution** that we’re sampling from. However,
    we need an additional ingredient: the current state `z*`, and *q(z|z*)* depends
    on `z*`, creating a Markov chain with samples z¹, z², z³,. Each sample is accepted
    into the chain only if it satisfies a certain criterion, which we will define
    below since this criterion differs across variations of the algorithm.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 直观地说，算法按以下步骤工作：类似于逆 CDF，我们有一个我们从中采样的**目标分布**。然而，我们需要一个额外的成分：当前状态 `z*`，并且 *q(z|z*)*
    依赖于 `z*`，创建一个具有样本 z¹、z²、z³ 的马尔可夫链。每个样本只有在满足某些标准时才被接受到链中，这些标准将在下文定义，因为这些标准在算法的不同变体中有所不同。
- en: Let’s formalize it into a more algorithmic structure.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其形式化为更算法化的结构。
- en: 'The algorithm runs in cycles, and each cycle follows these steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 算法以周期性方式运行，每个周期遵循以下步骤：
- en: Generate a sample *z** from the proposal distribution.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从提议分布中生成一个样本 *z**。
- en: 'Accept the sample with probability Then we will accept this value with an **acceptance
    probability,** which in Metropolis-Hastings is defined as:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以概率接受样本，然后我们将以**接受概率**接受该值，在 Metropolis-Hastings 中定义为：
- en: '![](../Images/9f5b7dd83e528a0a8d399046030d7b8c.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9f5b7dd83e528a0a8d399046030d7b8c.png)'
- en: PRML¹ Eq 11.44
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: PRML¹ Eq 11.44
- en: where
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其中
- en: '*z** is the current state.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*z** 是当前状态。'
- en: '*z^T* is the proposed new state.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*z^T* 是提议的新状态。'
- en: '*p(z*)* is the probability of state z* according to the desired distribution.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*p(z*)* 是根据期望分布的状态 z* 的概率。'
- en: '*p(z^T)* is the probability of state *z^T* according to the desired distribution.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*p(z^T)* 是根据期望分布的状态 *z^T* 的概率。'
- en: The logic behind this acceptance threshold is that it ensures that the **more
    probable states** (according to the desired distribution) are **visited more often**.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接受阈值背后的逻辑是确保**更可能的状态**（根据期望分布）**更频繁地被访问**。
- en: Now, this is the most generalized version of the algorithm; if the proposal
    distribution is known to be symmetric, meaning that the probability of proposing
    a move from state *x* to *x*′ is the same as proposing a move from *x*′ to *x,*
    i.e. *q*(*x′*|*x*) = *q*(*x|x′*), then we can use a special case of Metropolis-Hastings
    that requires a simpler acceptance threshold.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是算法的最通用版本；如果提议分布已知是对称的，即从状态 *x* 到 *x*′ 的提议移动的概率与从 *x*′ 到 *x* 的提议移动的概率相同，即
    *q*(*x′*|*x*) = *q*(*x|x′*），那么我们可以使用一个特殊的 Metropolis-Hastings 变体，该变体需要更简单的接受阈值。
- en: Metropolis algorithm for Symmetric Distributions
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对称分布的 Metropolis 算法
- en: 'This is a specific MCMC algorithm that we choose to use **if the proposal distribution
    is symmetric**, i.e. q(z⁰ | z¹) = q(z¹ | z⁰) for all values of 1 and 0, interpreted
    as “the probability of transitioning from any state A to state B is equal to the
    probability of transitioning from B to A”. So, each step of the algorithm becomes:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个特定的 MCMC 算法，我们选择在**提议分布对称**时使用，即 q(z⁰ | z¹) = q(z¹ | z⁰) 对于所有值 1 和 0，解释为“从任何状态
    A 过渡到状态 B 的概率等于从 B 过渡到 A 的概率”。所以，算法的每一步变成：
- en: Generate a sample z* from the proposal distribution.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从提议分布中生成一个样本 z*。
- en: 'Accept the sample with probability:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以以下概率接受样本：
- en: '![](../Images/7e41da8ba42ba27d11ab1bd9c3318a73.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7e41da8ba42ba27d11ab1bd9c3318a73.png)'
- en: 'Metropolis algorithm acceptance threshold. Src: PRML¹ Eq. 11.33'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Metropolis 算法接受阈值。来源：PRML¹ Eq. 11.33
- en: Metropolis-Hastings and Metropolis Algorithms
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Metropolis-Hastings 和 Metropolis 算法
- en: 'Let’s look at the algorithms side by side. As we saw before, the only difference
    is the acceptance threshold; all other steps of the algorithms run identically:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们并排比较这些算法。如我们之前所见，唯一的区别是接受阈值；算法的其他步骤完全相同：
- en: '![](../Images/c99439fa15f3dea42cd2a269f6eefcb4.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c99439fa15f3dea42cd2a269f6eefcb4.png)'
- en: Metropolis vs Metropolis-Hastings Algorithm
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Metropolis 与 Metropolis-Hastings 算法
- en: Advantages
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优势
- en: '**Convergence to Equilibrium Distribution**: In certain cases, the random walk
    can converge to a desired equilibrium distribution although it likely takes a
    long time in high-dimensional spaces.'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**收敛到平衡分布**：在某些情况下，随机游走可以收敛到期望的平衡分布，尽管在高维空间中可能需要很长时间。'
- en: '**Low Computational Cost**: Random walk often requires fewer computational
    resources compared to other complex sampling methods, making it suitable for problems
    where computational efficiency is a priority.'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**低计算成本**：随机游走通常比其他复杂的采样方法需要更少的计算资源，因此适用于计算效率为优先的问题。'
- en: '**Versatility of application**: Due to its high similarity to naturally occurring
    patterns, Random Walk has applications in a wide variety of fields:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**应用的多样性**：由于与自然发生模式的高度相似性，随机游走在广泛的领域中都有应用：'
- en: '• Physics: Brownian motion of molecules in liquids and gases.'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: • 物理学：液体和气体中分子的布朗运动。
- en: • Network Analysis
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: • 网络分析
- en: '• Financial Markets: to model stock price movements'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: • 金融市场：用于建模股票价格波动
- en: • Population Genetics
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: • 群体遗传学
- en: '**Disadvantages**:'
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**缺点**：'
- en: '**Sensitive to initialization**: The algorithm’s performance can be sensitive
    to the choice of the starting values, especially if the initialized values are
    far from the high-density areas.'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**对初始化敏感**：算法的性能可能对起始值的选择敏感，特别是当初始化值远离高密度区域时。'
- en: '**Locality traps**: Depending on the complexity of the proposal distribution,
    the algorithm could get stuck in local optima and have difficulty traversing to
    other areas along the distribution.'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**局部陷阱**：根据提案分布的复杂性，算法可能会陷入局部最优，并且难以遍历分布的其他区域。'
- en: 'Now, keeping the Metropolis-Hastings algorithm in mind, let’s look at another
    special instance of it: Gibbs Sampling.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，牢记 Metropolis-Hastings 算法，让我们看看它的另一个特殊实例：Gibbs 采样。
- en: 3\. Gibbs Sampling
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3\. Gibbs 采样
- en: Gibbs Sampling is a special instance of Metropolis-Hastings where **each step
    is always accepted**. Let’s first look at the Gibbs sampling algorithm itself.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Gibbs 采样是 Metropolis-Hastings 的一个特殊实例，其中 **每一步都总是被接受**。让我们首先看看 Gibbs 采样算法本身。
- en: '**How does the Gibbs algorithm work?**'
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**Gibbs 算法是如何工作的？**'
- en: 'The idea is relatively simple and is best illustrated by first zooming in on
    a micro example involving sampling from a distribution *p(z1, z2, z3)* over 3
    variables. The algorithm would run in the following steps:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法相对简单，最好通过首先放大涉及从分布 *p(z1, z2, z3)* 中采样的微观例子来说明。算法的步骤如下：
- en: 'At timestep *T,* initialize the starting values to:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在时间步 *T*，将起始值初始化为：
- en: '![](../Images/7cd087dce3e8d6677b236c4ea8bd4024.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7cd087dce3e8d6677b236c4ea8bd4024.png)'
- en: PRML¹
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: PRML¹
- en: 2\. Draw the new value for *z1:*
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 为 *z1* 生成新值：
- en: '![](../Images/9d86e1bd0dfd60f0945c508585063b76.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9d86e1bd0dfd60f0945c508585063b76.png)'
- en: PRML¹ Eq 11.46
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: PRML¹ Eq 11.46
- en: '3\. Draw a new value for the second position, *z2* from the conditional:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 从条件分布中为第二个位置 *z2* 生成一个新值：
- en: '![](../Images/d756a4f209a7d918c9a6d2bd55ce730b.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d756a4f209a7d918c9a6d2bd55ce730b.png)'
- en: PRML¹ Eq 11.47
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: PRML¹ Eq 11.47
- en: '4\. Finally draw a new value for the last position, *z3*:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 最后为最后一个位置 *z3* 生成一个新值：
- en: '![](../Images/88460e00830181cceb0d2031ec0023b7.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/88460e00830181cceb0d2031ec0023b7.png)'
- en: PRML¹ Eq 11.48
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: PRML¹ Eq 11.48
- en: 5\. Repeat this process, cycling through the three variables *z1…z3* until it
    reaches a certain satisfactory threshold.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. 重复这一过程，在三个变量 *z1…z3* 之间循环，直到达到某个令人满意的阈值。
- en: Generalized algorithm
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 广义算法
- en: Formally, the algorithm is represented by first initializing the starting positions,
    and then taking *T* consecutive steps
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 从形式上看，算法首先初始化起始位置，然后采取 *T* 个连续步骤
- en: '![](../Images/5b2d3cf7ff76b0588770593aac58b413.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5b2d3cf7ff76b0588770593aac58b413.png)'
- en: 'Image source: PRML¹ Ch11.3 Gibbs Sampling'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图片来源：PRML¹ Ch11.3 Gibbs 采样
- en: Conditions for Gibbs to sample from a target distribution correctly
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gibbs 从目标分布中正确采样的条件
- en: '**Invariance**. The target distribution *p(z)* is invariant of each Gibbs step,
    and therefore *p(z)* is invariant of the entire Markov chain.'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**不变性**。目标分布 *p(z)* 在每个 Gibbs 步骤中是不变的，因此 *p(z)* 对整个马尔可夫链是不变的。'
- en: '**Ergodicity**. If the conditional distributions are all non-zero, then ergodicity
    is implied since any point in *z* space is reachable in a finite number of steps.'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**遍历性**。如果条件分布都是非零的，则意味着遍历性，因为 *z* 空间中的任何点都可以在有限步数内到达。'
- en: '**Sufficient burn-in**. As we saw with any method that requires random initialization,
    the first few samples are dependent on the initialization, and the dependence
    weakens after many iterations.'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**充分的烧入时间**。正如我们在任何需要随机初始化的方法中看到的那样，前几个样本依赖于初始化，随着迭代次数的增加，这种依赖性会减弱。'
- en: How does this relate to Metropolis-Hastings?
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这与 Metropolis-Hastings 有什么关系？
- en: 'In Metropolis-Hastings, we defined the acceptance threshold to be:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Metropolis-Hastings 中，我们定义接受阈值为：
- en: '![](../Images/c30ed153ca1b1cac19f0606319abe736.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c30ed153ca1b1cac19f0606319abe736.png)'
- en: Thus, the Metropolis-Hastings proposal steps are always accepted, as we saw
    in the Gibbs algorithm.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Metropolis-Hastings 提案步骤总是被接受的，正如我们在 Gibbs 算法中所看到的那样。
- en: Variations
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变体
- en: Since the Gibbs method updates one variable at a time, there are strong dependencies
    between consecutive samples. To overcome this, we could use an intermediate strategy
    to sample from **groups of variables** instead of **individual variables,** known
    as [blocking Gibbs](https://www.sciencedirect.com/science/article/pii/S0002929707623398).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Gibbs方法一次更新一个变量，因此连续样本之间存在较强的依赖性。为克服这一点，我们可以使用一种中间策略来从**变量组**而非**单个变量**中采样，称为[阻塞Gibbs](https://www.sciencedirect.com/science/article/pii/S0002929707623398)。
- en: Similarly, by the nature of Markov chains, the examples drawn successively will
    be correlated. To generate independent samples, we could use sub-sampling within
    the sequence.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，由于马尔可夫链的性质，连续抽取的样本将会相关。为了生成独立样本，我们可以在序列中使用子采样。
- en: '4\. Pros/Cons: Inverse CDF vs Metropolis-Hastings vs Gibbs'
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 优缺点：逆CDF vs Metropolis-Hastings vs Gibbs
- en: Now that we’ve walked through how each algorithm works and its application areas,
    let’s summarize the defining characteristic of each method.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经详细了解了每种算法的工作原理及其应用领域，让我们总结一下每种方法的定义特征。
- en: 1\. Inverse Transformation Sampling
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1. 逆变换采样
- en: '**Data Size**: Best for moderate-sized datasets.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据大小**：适合中等大小的数据集。'
- en: '**Time**: Generally efficient for univariate distributions.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间**：通常对单变量分布有效率。'
- en: '**Data Complexity**: Use for simple distributions where the cumulative distribution
    function (CDF) and its inverse are known and easy to compute.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据复杂性**：适用于已知并易于计算的累积分布函数（CDF）及其逆函数的简单分布。'
- en: '**Consider avoiding if:** Sampling high-dimensional variables/distributions.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如果**：采样高维变量/分布。'
- en: '**Biggest Advantage**: High accuracy if the CDF accurately reflects the target
    distribution.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大优点**：如果CDF准确反映目标分布，则准确性高。'
- en: '**Requirement:** The CDF must be known and invertible.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**要求**：CDF必须已知且可逆。'
- en: 2\. Metropolis-Hastings (MCMC)
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2. Metropolis-Hastings (MCMC)
- en: '**Data Size**: Scalable and suitable for large datasets.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据大小**：可扩展且适合大型数据集。'
- en: '**Time**: Can be computationally intensive, depending on the complexity of
    the target distribution.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间**：可能计算量大，取决于目标分布的复杂性。'
- en: '**Data Complexity**: Ideal for complex or multi-modal distributions.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据复杂性**：适用于复杂或多模态分布。'
- en: '**Biggest Advantages**:'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大优点**：'
- en: '- Can sample from a distribution without knowing its normalization constant
    (the full form)'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- 可以在不知道其归一化常数（完整形式）的情况下从分布中采样'
- en: '- Great for exploring the global structure of a distribution and guarantees
    convergence'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- 适合探索分布的全球结构并保证收敛'
- en: '**Disadvantage:** May suffer from very slow convergence with'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**：可能会出现非常慢的收敛速度'
- en: '- complex or multimodal target distribution, since the algorithm may be stuck
    in local modes and have difficulty transitioning between them;'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- 复杂或多峰目标分布，因为算法可能陷入局部模式并难以在它们之间转换；'
- en: '- the variables are highly correlated;'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- 变量高度相关；'
- en: '- high dimensional spaces;'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- 高维空间；'
- en: '- poor initial values or step size choices'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- 不良的初始值或步长选择'
- en: 3\. Gibbs Sampling
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3. Gibbs采样
- en: '**Data Size**: Suitable for both small and large datasets.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据大小**：适用于小型和大型数据集。'
- en: '**Time**: Often more efficient than Random Walk Metropolis-Hastings since it
    doesn’t require acceptance/rejection steps.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间**：通常比随机游走Metropolis-Hastings更有效，因为它不需要接受/拒绝步骤。'
- en: '**Data Complexity**: Best used when dealing with high-dimensional distributions
    where you can sample from the conditional distribution of each variable.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据复杂性**：当处理高维分布时，最佳用于可以从每个变量的条件分布中采样的情况。'
- en: '**Biggest Advantages**:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大优点**：'
- en: '- Can easily compute conditional distributions;'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- 可以轻松计算条件分布；'
- en: '- Less prone to local minima traps compared to Random Walk.'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- 相比于随机游走，较少陷入局部极小值。'
- en: '**Requirements**:'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**要求**：'
- en: '- Markov chain ergodicity'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- 马尔可夫链遍历性'
- en: '- The full conditional distributions must be known and tractable'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- 必须已知且可处理完整的条件分布'
- en: 'In summary:'
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结：
- en: '![](../Images/67e33e80ecf03e5ed1c319ef7a79cb45.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/67e33e80ecf03e5ed1c319ef7a79cb45.png)'
- en: Summary table of pros and cons of inverse CDF, Metropolis-Hastings, and Gibbs
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 逆CDF、Metropolis-Hastings和Gibbs的优缺点汇总表
- en: Conclusion
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: 'Thanks for sticking with me this far! In this article, we looked at 3 key approximation
    sampling methods: Inverse CDF, Metropolis Hastings MCMC, and Gibbs Sampling MCMC.
    We explored how each algorithm functions, their respective advantages and disadvantages,
    and typical use-cases.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢你一直陪伴到现在！在这篇文章中，我们探讨了3种关键的近似采样方法：逆CDF、Metropolis Hastings MCMC 和 Gibbs Sampling
    MCMC。我们了解了每种算法的工作原理、各自的优缺点以及典型的应用场景。
- en: '**Inverse CDF** provides a straightforward method to sample from a known distribution
    when its CDF is invertible. It’s computationally efficient but is less suitable
    for high-dimensional or complex distributions.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**逆CDF** 提供了一种直接从已知分布中采样的方法，当其CDF是可逆时。这种方法计算效率高，但不太适用于高维或复杂的分布。'
- en: '**Metropolis Hastings MCMC** offers a more general approach that allows for
    sampling from distributions that are difficult to tackle otherwise. However, it
    does require more computational resources and may be sensitive to tuning parameters
    like the proposal distribution.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**Metropolis Hastings MCMC** 提供了一种更通用的方法，允许从难以处理的分布中进行采样。然而，它需要更多的计算资源，并且可能对像提议分布这样的调参敏感。'
- en: '**Gibbs Sampling MCMC** is specifically efficient when the joint distribution
    is complex but can be broken down into simpler conditional distributions. It’s
    widely used in machine learning, although it can be slow to converge and memory-intensive
    for high-dimensional problems.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**Gibbs Sampling MCMC** 在联合分布复杂但可以分解为更简单的条件分布时特别高效。它在机器学习中广泛使用，尽管对于高维问题可能收敛缓慢且占用内存。'
- en: '[1] Bishop, C. M. (2016). *Pattern Recognition and Machine Learning* (Softcover
    reprint of the original 1st edition 2006 (corrected at 8th printing 2009)). Springer
    New York.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] Bishop, C. M. (2016). *模式识别与机器学习*（原版第1版2006年软封面再版（2009年第8次印刷校订版））。Springer
    New York.'
- en: '**Images by author unless otherwise stated,*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**图片由作者提供，除非另有说明，**'
