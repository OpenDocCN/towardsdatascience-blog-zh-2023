- en: 3D Point Cloud Shape Detection for Indoor Modelling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 室内建模的 3D 点云形状检测
- en: 原文：[https://towardsdatascience.com/3d-point-cloud-shape-detection-for-indoor-modelling-70e36e5f2511](https://towardsdatascience.com/3d-point-cloud-shape-detection-for-indoor-modelling-70e36e5f2511)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/3d-point-cloud-shape-detection-for-indoor-modelling-70e36e5f2511](https://towardsdatascience.com/3d-point-cloud-shape-detection-for-indoor-modelling-70e36e5f2511)
- en: '[Hands-on Tutorials](https://towardsdatascience.com/tagged/hands-on-tutorials),
    3D Python'
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[动手教程](https://towardsdatascience.com/tagged/hands-on-tutorials)，3D Python'
- en: A 10-step Python Guide to Automate 3D Shape Detection, Segmentation, Clustering,
    and Voxelization for Space Occupancy 3D Modeling of Indoor Point Cloud Datasets.
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10 步 Python 指南，用于自动化 3D 形状检测、分割、聚类和体素化，以实现室内点云数据集的空间占用 3D 建模。
- en: '[](https://medium.com/@florentpoux?source=post_page-----70e36e5f2511--------------------------------)[![Florent
    Poux, Ph.D.](../Images/74df1e559b2edefba71ffd0d1294a251.png)](https://medium.com/@florentpoux?source=post_page-----70e36e5f2511--------------------------------)[](https://towardsdatascience.com/?source=post_page-----70e36e5f2511--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----70e36e5f2511--------------------------------)
    [Florent Poux, Ph.D.](https://medium.com/@florentpoux?source=post_page-----70e36e5f2511--------------------------------)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@florentpoux?source=post_page-----70e36e5f2511--------------------------------)[![Florent
    Poux, Ph.D.](../Images/74df1e559b2edefba71ffd0d1294a251.png)](https://medium.com/@florentpoux?source=post_page-----70e36e5f2511--------------------------------)[](https://towardsdatascience.com/?source=post_page-----70e36e5f2511--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----70e36e5f2511--------------------------------)
    [Florent Poux, Ph.D.](https://medium.com/@florentpoux?source=post_page-----70e36e5f2511--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----70e36e5f2511--------------------------------)
    ·28 min read·Sep 7, 2023
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: ·发布于 [Towards Data Science](https://towardsdatascience.com/?source=post_page-----70e36e5f2511--------------------------------)
    ·阅读时长 28 分钟·2023年9月7日
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: If you have experience with point clouds or data analysis, you know how crucial
    it is to spot patterns. Recognizing data points with similar patterns, or "objects,"
    is important to gain more valuable insights. Our visual cognitive system accomplishes
    this task easily, but replicating this human ability through computational methods
    is a significant challenge.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有点云或数据分析的经验，你知道识别模式有多重要。识别具有相似模式的数据点或“对象”对获取有价值的见解至关重要。我们的视觉认知系统可以轻松完成这项任务，但通过计算方法复制这种人类能力是一个重大挑战。
- en: The goal is to utilize the natural tendency of the human visual system to group
    sets of elements. 👀
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是利用人类视觉系统自然的元素分组倾向。👀
- en: '![](../Images/f7a3a366e3f8d7cc6c3e1b7a11307505.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f7a3a366e3f8d7cc6c3e1b7a11307505.png)'
- en: Example of a result of the Segmentation phase on the 3D Point Cloud. © F. Poux
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 3D 点云分割阶段结果示例。© F. Poux
- en: But why is it useful?
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 但这有什么用呢？
- en: First, it lets you easily access and work with specific parts of the data by
    grouping them into segments. Secondly, it makes the data processing faster by
    looking at regions instead of individual points. This can save a lot of time and
    energy. And finally, segmentation can help you find patterns and relationships
    you wouldn’t be able to see just by looking at the raw data. 🔍 Overall, segmentation
    is crucial for getting useful information from point cloud data. If you are unsure
    how to do it, do not worry — We will figure this out together! 🤿
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它通过将数据分组到不同的段中，让你轻松访问和处理数据的特定部分。其次，通过查看区域而不是单个点，它使数据处理更快。这可以节省大量时间和精力。最后，分割可以帮助你发现通过查看原始数据无法看到的模式和关系。🔍
    总的来说，分割对于从点云数据中获取有用信息至关重要。如果你不确定如何做，别担心——我们会一起搞定的！🤿
- en: The Strategy
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略
- en: Let us frame the overall approach before approaching the project with an efficient
    solution. This tutorial follows a strategy comprising ten straightforward steps,
    as illustrated in our strategy diagram below.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们以有效的解决方案处理项目之前，让我们框定整体方法。本教程遵循一个由十个简单步骤组成的策略，如下方的策略图所示。
- en: '![](../Images/49c746a4375f4f284fe81f501c11fb4f.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/49c746a4375f4f284fe81f501c11fb4f.png)'
- en: The workflow for 3D Point Cloud Indoor Modelling shown in this guide. © F. Poux
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南展示了 3D 点云室内建模的工作流程。© F. Poux
- en: 'The strategy is laid out, and below, you can find the quick links to the different
    steps:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 策略已列出，下面你可以找到不同步骤的快捷链接：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now that we are set up, let us jump right in.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已做好准备，那就直接开始吧。
- en: '🎵**Note to Readers***: This hands-on guide is part of a* [***UTWENTE***](https://www.itc.nl/)
    *joint work, with co-authors* ***F. Poux*** *and* ***V. Lehtola****. We acknowledge
    the financial contribution from the digital twins* [*@ITC*](http://twitter.com/ITC)
    *-project granted by the ITC faculty of the University of Twente.* ***All images
    are © Florent Poux****.*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 🎵**读者注意**：此动手指南是* [***UTWENTE***](https://www.itc.nl/) *联合工作的一部分，由* ***F. Poux***
    *和* ***V. Lehtola*** *共同作者。我们感谢来自数字双胞胎* [*@ITC*](http://twitter.com/ITC) *项目的资助，该项目由特温特大学
    ITC 系提供。***所有图像 © Florent Poux***。*
- en: 1\. Set up your Python environment.
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1\. 设置您的 Python 环境。
- en: '![](../Images/b862dfa664dd54db82f77e3449a9a117.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b862dfa664dd54db82f77e3449a9a117.png)'
- en: In a previous article below, we saw how to quickly set up an environment with
    Anaconda and use the IDE JupyterLab to manage your code. Continuing in this fashion
    if you set yourself up to become a fully-fledged Python app developer 😆.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的上一篇文章中，我们展示了如何快速设置 Anaconda 环境并使用 IDE JupyterLab 管理代码。如果您继续以这种方式设置自己，您将成为一名完整的
    Python 应用程序开发者 😆。
- en: '[](/3d-python-workflows-for-lidar-point-clouds-100ff40e4ff0?source=post_page-----70e36e5f2511--------------------------------)
    [## 3D Python Workflows for LiDAR City Models: A Step-by-Step Guide'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[](/3d-python-workflows-for-lidar-point-clouds-100ff40e4ff0?source=post_page-----70e36e5f2511--------------------------------)
    [## 3D Python 工作流程用于 LiDAR 城市模型：逐步指南'
- en: The Ultimate Guide to unlocking a streamlined workflow for 3D City Modelling
    Applications. The tutorial covers Python…
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解锁 3D 城市建模应用程序的精简工作流程的终极指南。教程涵盖了 Python...
- en: towardsdatascience.com](/3d-python-workflows-for-lidar-point-clouds-100ff40e4ff0?source=post_page-----70e36e5f2511--------------------------------)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: towardsdatascience.com](/3d-python-workflows-for-lidar-point-clouds-100ff40e4ff0?source=post_page-----70e36e5f2511--------------------------------)
- en: '🦊 **Florent***: I highly recommend using a desktop setup or IDE and avoiding
    Google Colab IF you need to visualize 3D point clouds using the libraries provided,
    as they will be unstable at best or not working at worse (unfortunately…).*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 🦊 **Florent**：*我强烈推荐使用桌面设置或 IDE，避免使用 Google Colab，尤其是当您需要使用提供的库可视化 3D 点云时，因为它们在最佳情况下会不稳定，最糟糕的情况下则无法工作（不幸的是…）。*
- en: '🤠 **Ville**: *We guess that you are running on Windows? This is fine, but if
    you want to get into computational methods, Linux is the go-to choice!*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 🤠 **Ville**：*我们猜您是在 Windows 上运行？这没问题，但如果您想进入计算方法领域，Linux 是首选！*
- en: Well, we will take a “parti-pris” to quickly get results. Indeed, we will accomplish
    excellent segmentation by following a minimalistic approach to coding 💻. That
    means being very picky about the underlying libraries! We will use three very
    robust ones, namely. `numpy`, `matplotlib`, and `open3d`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们将采取一种“快速成果”的方法。实际上，我们将通过遵循最简化的编码方法来实现卓越的分割💻。这意味着我们对底层库非常挑剔！我们将使用三个非常强大的库，分别是`numpy`、`matplotlib`和`open3d`。
- en: 'Okay, to install the library package above in a fresh virtual environment,
    we suggest you run the following command from the `cmd` terminal:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，要在一个全新的虚拟环境中安装上述库包，我们建议您从`cmd`终端运行以下命令：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 🍜 ***Disclaimer Note****:* We choose Python, not C++ nor Julia, so performances
    are what they are 😄. Hopefully, it will be enough for your application 😉, for
    what we call “offline” processes (not real-time).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 🍜 ***免责声明***：*我们选择了 Python，而不是 C++ 或 Julia，所以性能就是那样 😄。希望它能满足您的应用需求 😉，对于我们所谓的“离线”过程（非实时）。*
- en: 'Within your Python IDE, make sure to import the three libraries that will be
    under heavy use:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 Python IDE 中，请确保导入将被频繁使用的三个库：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: And that is it! We are ready to rock indoor point cloud modeling workflows!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们准备好进行室内点云建模工作流程了！
- en: 2\. Point Cloud Data Preparation
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. 点云数据准备
- en: '![](../Images/e18d10ffc4d22a7dfa415f9b85211b8a.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e18d10ffc4d22a7dfa415f9b85211b8a.png)'
- en: 'In previous tutorials, we illustrated point cloud processing and meshing over
    a 3D dataset obtained using an aerial LiDAR from the AHN4 LiDAR Campaign. This
    time, we will use a dataset gathered using a Terrestrial Laser Scanner: the ITC
    new building. It was organized into three different sets for you to experiment
    on. In purple, you have an outdoor part. In red is the ground level, and in green
    is the first floor, as illustrated below.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的教程中，我们演示了如何处理点云并在使用 AHN4 LiDAR 活动获取的 3D 数据集上进行网格化。这一次，我们将使用一个通过地面激光扫描仪收集的数据集：ITC
    新建筑。它被组织成三个不同的集合供您实验。紫色的是户外部分。红色是地面层，绿色是第一层，如下图所示。
- en: '![](../Images/a3a4446fe2fae77b40da248fa8e3081b.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a3a4446fe2fae77b40da248fa8e3081b.png)'
- en: The 3D Point Cloud parts of the ITC Dataset used. © F. Poux
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的 ITC 数据集的 3D 点云部分。© F. Poux
- en: 'You can download the data from the Drive Folder here: [ITC Datasets](https://drive.google.com/drive/folders/1sCBT1lc9A8Zn4grpxwFrBrvos86c0HZR?usp=share_link).
    Once you have a firm grasp on the data locally, you can load the dataset in your
    Python execution runtime with two simple lines:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从这里下载数据：[ITC 数据集](https://drive.google.com/drive/folders/1sCBT1lc9A8Zn4grpxwFrBrvos86c0HZR?usp=share_link)。一旦你在本地对数据有了牢固的掌握，你可以用两行简单的代码将数据集加载到你的
    Python 执行环境中：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '🦊 **Florent**: *This Python code snippet uses the* `*Open3D*` *library to read
    a point cloud data file* `*ITC_groundfloor.ply*` *located in the directory. “*`*../DATA/*`*”
    and assign it to the variable* `*pcd*`*.*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '🦊 **Florent**: *这段 Python 代码片段使用* `*Open3D*` *库来读取位于目录“*`*../DATA/*`*”中的点云数据文件*
    `*ITC_groundfloor.ply*` *，并将其赋值给变量* `*pcd*`*。*'
- en: 'The variable now holds your point cloud `pcd` you will play with the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 变量现在保存着你的点云 `pcd`，你将用以下代码进行操作：
- en: '![](../Images/6ac078d0d708734f455c9e8907b18642.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6ac078d0d708734f455c9e8907b18642.png)'
- en: Once the point cloud data has been successfully loaded using Open3D, the next
    step is to apply various pre-processing techniques to enhance its quality and
    extract meaningful information.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦点云数据成功加载到 Open3D 中，下一步是应用各种预处理技术来提升其质量并提取有意义的信息。
- en: 3\. Point Cloud Pre-Processing
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3\. 点云预处理
- en: '![](../Images/0bb8b750bb4d32115dac7abbc406fbde.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0bb8b750bb4d32115dac7abbc406fbde.png)'
- en: 'If you intend on visualizing the point cloud within `open3d`It is good practice
    to shift your point cloud to bypass the large coordinates approximation, which
    creates shaky visualization effects. To apply such a shift to your `pcd` point
    cloud, first get the center of the point cloud, then translate it by subtracting
    it from the original variable:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算在 `open3d` 中可视化点云，建议你将点云移动以绕过大坐标的近似，这样可以避免产生晃动的可视化效果。要对你的 `pcd` 点云应用这种移动，首先获取点云的中心，然后通过从原始变量中减去它来进行平移：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Which can now be interactively visualized with the following line of code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以通过以下代码行进行交互式可视化：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '🦚 **Note**: `o3d.visualization.draw_geometries([pcd])` *calls the* `*draw_geometries()*`
    *function from the* `*visualization*` *Module in Open3D. The function takes a
    list of geometries as an argument and displays them in a visualization window.
    In this case, the list contains a single geometry, which is the* `*pcd*` *variable
    representing the point cloud. The* `*draw_geometries()*` *function creates a 3D
    visualization window and renders the point cloud. You can interact with the visualization
    window to rotate, zoom, and explore the point cloud from different perspectives.*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '🦚 **注意**: `o3d.visualization.draw_geometries([pcd])` *调用了* `*draw_geometries()*`
    *函数，这个函数属于 Open3D 的* `*visualization*` *模块。该函数接受一个几何体列表作为参数，并在可视化窗口中显示它们。在这种情况下，列表包含一个几何体，即表示点云的*
    `*pcd*` *变量。* `*draw_geometries()*` *函数创建一个 3D 可视化窗口并渲染点云。你可以与可视化窗口互动以旋转、缩放，并从不同角度探索点云。*'
- en: '![](../Images/38196ff8a2b3f0d77fa32690deefe8ba.png)![](../Images/1b23848831179d63eccaa3cf24969e6a.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/38196ff8a2b3f0d77fa32690deefe8ba.png)![](../Images/1b23848831179d63eccaa3cf24969e6a.png)'
- en: Great👌, we are all set up to test some sampling strategies to unify our downward
    processes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了👌，我们已经准备好测试一些采样策略来统一我们的下游处理。
- en: 3.1\. Point Cloud Random Sampling
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1\. 点云随机采样
- en: 'Let us consider random sampling methods that can effectively reduce point cloud
    size while preserving overall structural integrity and representativeness. If
    we define a point cloud as a matrix (m x n), then a **decimated cloud** is obtained
    by keeping one row out of n of this matrix :'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑那些可以有效减少点云大小同时保持整体结构完整性和代表性的方法。如果我们将点云定义为一个矩阵 (m x n)，那么通过保留该矩阵每隔 n 行的一个行，我们可以得到一个**简化的点云**：
- en: '![](../Images/43048e0ad321a1ec9cb3b8607d68133a.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/43048e0ad321a1ec9cb3b8607d68133a.png)'
- en: A Point Cloud Decimation Strategy. © F. Poux
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一个点云简化策略。© F. Poux
- en: 'At the matrix level, the decimation acts by keeping points for every n-th row
    depending on the n factor. Of course, this is made based on how the points are
    stored in the file. Slicing a point cloud with `open3d` It is pretty straightforward.
    To shorten and parametrize the expression, you can write the lines:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在矩阵级别，简化操作是通过根据 n 因子保留每隔 n 行的点来进行的。当然，这取决于点在文件中的存储方式。用 `open3d` 切片点云是相当直接的。为了简化和参数化表达式，你可以写出以下代码：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '🦚 **Note**: `sampled_pcd = pcd.random_down_sample(retained_ratio)` *applies
    random downsampling to the original point cloud* `*pcd*` *using the* `random_down_sample()`
    *function provided by Open3D. The* `retained_ratio` *parameter determines the
    proportion of points to be retained after downsampling. For example, if* `retained_ratio`
    *it is set to 0.5, approximately 50% of the points will be randomly selected and
    retained in the sampled point cloud.*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 🦚 **注意**：`sampled_pcd = pcd.random_down_sample(retained_ratio)` *对原始点云* `*pcd*`
    *应用随机下采样，使用的是* `random_down_sample()` *函数，该函数由 Open3D 提供。* `retained_ratio` *参数决定了下采样后保留的点的比例。例如，如果*
    `retained_ratio` *设置为 0.5，则大约 50% 的点将被随机选择并保留在采样后的点云中。*
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](../Images/f4d15aa96e162454499be387b499b6e3.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f4d15aa96e162454499be387b499b6e3.png)'
- en: Results of the subsampling of the point cloud. © F. Poux
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 点云的下采样结果。© F. Poux
- en: '🌱 **Growing**: *When studying 3D point clouds, random sampling has limitations
    that could result in missing important information and inaccurate analysis. It
    doesn’t consider the spatial component or relationships between the points. Therefore,
    it’s essential to use other methods to ensure a more comprehensive analysis.*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 🌱 **发展**：*在研究 3D 点云时，随机采样有其局限性，可能会导致遗漏重要信息和分析不准确。它没有考虑点之间的空间组件或关系。因此，使用其他方法以确保更全面的分析是至关重要的。*
- en: While this strategy is quick, random sampling may not be most adapted to a “standardization”
    use case. The next step is to address potential outliers through statistical outlier
    removal techniques, ensuring the data quality and reliability for subsequent analysis
    and processing.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种策略快速，但随机采样可能不适合“标准化”用例。下一步是通过统计异常值去除技术来处理潜在的异常值，以确保数据的质量和可靠性，以便进行后续分析和处理。
- en: 3.2\. Statistical outlier removal
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2\. 统计异常值去除
- en: Using an outlier filter on 3D point cloud data can help identify and remove
    any data points significantly different from the rest of the dataset. These outliers
    could result from measurement errors or other factors that can skew the analysis.
    By removing these outliers, we can get a more valid representation of the data
    and better adjust algorithms. However, we need to be careful not to delete valuable
    points.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对 3D 点云数据使用异常值过滤器可以帮助识别和去除任何显著不同于数据集其余部分的数据点。这些异常值可能是由于测量误差或其他因素造成的，这些因素可能会影响分析。通过去除这些异常值，我们可以获得更有效的数据表示，并更好地调整算法。然而，我们需要小心不要删除有价值的点。
- en: 'We will define a `statistical_outlier_removal` filter to remove points that
    are further away from their neighbors compared to the average for the point cloud.
    It takes two input parameters:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个 `statistical_outlier_removal` 过滤器，以去除与其邻居相比远离平均值的点。它需要两个输入参数：
- en: '`nb_neighbors`, which specifies how many neighbors are considered to calculate
    the average distance for a given point.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nb_neighbors`，用于指定在计算给定点的平均距离时考虑多少个邻居。'
- en: '`std_ratio`, which allows setting the threshold level based on the standard
    deviation of the average distances across the point cloud. The lower this number,
    the more aggressive the filter will be.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std_ratio`，允许根据点云中平均距离的标准差设置阈值水平。这个数值越低，过滤器的作用就越强。'
- en: 'This amount to the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括以下内容：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '🦚 **Note**: *the* `*remove_statistical_outlier()*` *the function applies statistical
    outlier removal to the point cloud using a specified number of nearest neighbors
    (*`*nn*`*) and a standard deviation multiplier (*`*std_multiplier*`*). The function
    returns two values:* `*filtered_pcd*` *and* `*filtered_idx*`*.* `*filtered_pcd*`
    *represents the filtered point cloud, where statistical outliers have been removed.*
    `*filtered_idx*` *is an array of indices corresponding to the points in the original
    point cloud* `*pcd*` *that were retained after the outlier removal process.*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 🦚 **注意**：*`*remove_statistical_outlier()*` *函数通过指定数量的最近邻（*`*nn*`*）和一个标准差乘数（*`*std_multiplier*`*）来对点云应用统计异常值去除。该函数返回两个值：*
    `*filtered_pcd*` *和* `*filtered_idx*`*。* `*filtered_pcd*` *表示经过滤的点云，其中已去除统计异常值。*
    `*filtered_idx*` *是一个索引数组，对应于在异常值去除过程中保留的原始点云* `*pcd*` *中的点。*
- en: 'To visualize the results of this filtering technique, we color the outliers
    in red and add them to the list of point cloud objects we want to visualize:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化这种过滤技术的结果，我们将异常值标记为红色，并将其添加到我们希望可视化的点云对象列表中：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![](../Images/6ef3e983fc62a7eda4eaf143ce2330a5.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6ef3e983fc62a7eda4eaf143ce2330a5.png)'
- en: The outliers are in tagged and visualized in red in the point cloud. © F. Poux
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 异常值在点云中用红色标记和可视化。© F. Poux
- en: After removing statistical outliers from the point cloud, the next step involves
    applying voxel-based sampling techniques to downsample the data further, facilitating
    efficient processing and analysis while preserving the essential structural characteristics
    of the point cloud.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在从点云中移除统计异常值之后，下一步是应用基于体素的采样技术，进一步下采样数据，以便高效处理和分析，同时保留点云的基本结构特征。
- en: 3.3\. Point Cloud Voxel (Grid) Sampling
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3. 点云体素（网格）采样
- en: The grid subsampling strategy is based on the division of the 3D space in regular
    cubic cells called voxels. For each cell of this grid, we only keep one representative
    point, and this point, the representative of the cell, can be chosen in different
    ways. When subsampling, we keep that cell's closest point to the barycenter.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 网格下采样策略基于将3D空间划分为规则的立方体单元，称为体素。对于这个网格的每个单元，我们只保留一个代表性点，并且可以用不同的方式选择这个点。当下采样时，我们保留该单元最接近重心的点。
- en: '![](../Images/802a55909c5aa28b959e4357b8e2f9e4.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/802a55909c5aa28b959e4357b8e2f9e4.png)'
- en: Example of Voxel Grid Sampling. © F. Poux
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 体素网格采样示例。© F. Poux
- en: 'Concretely, we define a `voxel_size` that we then use to filter our point cloud:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 具体而言，我们定义一个`voxel_size`，然后用它来过滤我们的点云：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '🦚 **Note**: *This line performs voxel downsampling on the filtered point cloud,*
    `*filtered_pcd*`*, using the* `*voxel_down_sample()*` *function. The* `*voxel_size*`
    *parameter specifies the size of each voxel for downsampling the point cloud.
    Larger voxel sizes result in a more significant reduction in point cloud density.
    The result of the downsampling operation is assigned to the variable* `*pcd_downsampled*`*,
    representing the downsampled point cloud*.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 🦚 **注意**：*此行对过滤后的点云执行体素下采样，* `*filtered_pcd*`*，使用* `*voxel_down_sample()*` *函数。*
    `*voxel_size*` *参数指定体素下采样点云的每个体素的大小。较大的体素尺寸会导致点云密度显著减少。下采样操作的结果分配给变量* `*pcd_downsampled*`*，代表下采样后的点云*。
- en: 'Time to visualize the repartition closely after our downsampling:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是仔细可视化下采样后分布的时间：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![](../Images/f65a10e76a7e48feae0b94ffc246e5db.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f65a10e76a7e48feae0b94ffc246e5db.png)'
- en: The result of the sampling strategy applied on the point cloud. © F. Poux
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 应用在点云上的采样策略结果。© F. Poux
- en: At this stage, we have an outlier point set left untouched in further processing
    and a downsampled point cloud that constitutes the new subject of the subsequent
    processes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，我们有一组未在进一步处理时触及的异常点和一个下采样后的点云，构成了后续过程的新主题。
- en: 3.4\. Point Cloud Normals Extraction
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4. 点云法线提取
- en: 'A point cloud normal refers to the direction of a surface at a specific point
    in a 3D point cloud. It can be used for segmentation by dividing the point cloud
    into regions with similar normals, for example. In our case, normals will help
    identify objects and surfaces within the point cloud, making it easier to visualize.
    And it is an excellent opportunity to introduce a way to compute such normals
    semi-automatically. We first define the average distance between each point in
    the point cloud and its neighbors:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 点云法线指的是3D点云中特定点处表面的方向。它可以用于通过将点云划分为具有相似法线的区域来进行分割。例如，在我们的案例中，法线将有助于识别点云中的物体和表面，使其更容易可视化。这也是介绍一种半自动计算法线的方法的绝佳机会。我们首先定义点云中每个点与其邻居之间的平均距离：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then we use this information to extract a limited `max_nn` points within a
    radius `radius_normals` to compute a normal for each point in the 3D point cloud:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们利用这些信息在半径为`radius_normals`的范围内提取有限的`max_nn`个点，为3D点云中的每个点计算法线：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The pcd_downsampled point cloud object is now proud to have normals, ready
    to display its prettiest side 😊. You know the drill at this stage:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`pcd_downsampled`点云对象很高兴地拥有法线，准备展示其最漂亮的一面😊。此时你知道该做什么：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![](../Images/92aa19172478994bb05bcd86ef4bd146.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/92aa19172478994bb05bcd86ef4bd146.png)'
- en: The point cloud used for the follow-up experiments.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 用于后续实验的点云。
- en: Upon completing the voxel downsampling of the point cloud, the subsequent step
    involves configuring the parameters for point cloud shape detection and clustering,
    which plays a crucial role in grouping similar points together and extracting
    meaningful structures or objects from the downsampled point cloud data.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 完成点云的体素下采样后，下一步是配置点云形状检测和聚类的参数，这在将相似点分组以及从下采样点云数据中提取有意义的结构或对象中起着关键作用。
- en: 4\. Point Cloud Parameter setting
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4\. 点云参数设置
- en: '![](../Images/4d43adb22c40912f783a2cb44c0064b4.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4d43adb22c40912f783a2cb44c0064b4.png)'
- en: 'In this tutorial, we have selected two of the most effective and reliable methods
    for 3D Shape detection and clustering for you to master: RANSAC and Euclidean
    Clustering using DBSCAN. However, before utilizing these approaches, hence understanding
    the parameters, it is crucial to comprehend the fundamental concepts in simple
    terms.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们为您精选了两种最有效且可靠的3D形状检测和聚类方法：RANSAC和使用DBSCAN的欧几里得聚类。然而，在使用这些方法之前，了解参数的同时，理解基本概念是至关重要的。
- en: RANSAC
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RANSAC
- en: 'The RANSAC algorithm, short for RANdom SAmple Consensus, is a powerful tool
    for handling data that contains outliers, which is often the case when working
    with real-world sensors. The algorithm works by grouping data points into two
    categories: inliers and outliers. By identifying and ignoring the outliers, you
    can focus on working with reliable inliers, making your analysis more effective.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: RANSAC算法，RANdom SAmple Consensus的缩写，是一个强大的工具，用于处理包含异常值的数据，这在使用现实世界传感器时常常会遇到。该算法通过将数据点分为两类：内点和外点来工作。通过识别并忽略外点，您可以专注于处理可靠的内点，从而使分析更加有效。
- en: '![](../Images/a5c122fcaa8c0f6453ae2b2363de65b9.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a5c122fcaa8c0f6453ae2b2363de65b9.png)'
- en: Planar detection with RANSAC in a 3D Point Cloud. © F. Poux
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在3D点云中使用RANSAC进行平面检测。© F. Poux
- en: So let me use a tiny but simple example to illustrate how RANSAC works. Let
    us say that we want to fit a plane through the point cloud below. How can we do
    that?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我用一个简单的例子来说明RANSAC的工作原理。假设我们想通过下面的点云拟合一个平面。我们怎么做呢？
- en: '![](../Images/bb85346e13ae187ec137bef80050cce3.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/bb85346e13ae187ec137bef80050cce3.png)'
- en: RANSAC Plane detection simulation in a random point cloud. © F. Poux
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在随机点云中进行的RANSAC平面检测模拟。© F. Poux
- en: First, we create a plane from the data, and for this, we randomly select 3 points
    from the point cloud necessary to establish a plane. And then, we simply check
    how many of the remaining points kind of fall on the plane (to a certain threshold),
    which will give a score to the proposal.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从数据中创建一个平面，为此，我们从点云中随机选择3个点来建立平面。然后，我们简单地检查剩余的点中有多少点落在该平面上（达到某个阈值），这将为提案打分。
- en: '![](../Images/4162c310eb51619b469d062fc8078732.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4162c310eb51619b469d062fc8078732.png)'
- en: RANSAC Scoring system illustrated. You can see that each iteration samples 3
    random points from which it will create a plan and then select the points that
    would fall on it. Here, iteration 159 would be the best candidate. © F. Poux
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: RANSAC评分系统说明。您可以看到，每次迭代都会随机抽取3个点，从中创建一个平面，然后选择落在平面上的点。在这里，第159次迭代会是最佳候选。© F.
    Poux
- en: 'Then, we repeat the process with 3 new random points and see how we are doing.
    Is it better? Is it worse? And again, we repeat this process over and over again,
    let’s say 10 times, 100 times, 1000 times, and then we select the plane model
    with the highest score (i.e. which has the best “support” of the remaining data
    points). And that will be our solution: the supporting points plus the three points
    that we have sampled constitute our **inlier point set**, and the rest is our
    **outlier point set**. Easy enough, hun 😁?'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们用3个新的随机点重复这个过程，看看效果如何。是更好了吗？更差了吗？然后，我们反复进行这个过程，比如说10次、100次、1000次，然后选择得分最高的平面模型（即具有最佳“支持”的剩余数据点）。这将是我们的解决方案：支持点加上我们采样的三个点构成我们的**内点集**，其余部分是我们的**外点集**。够简单吧
    😁？
- en: 'Haha, but for the skeptics, don’t you have a rising question? How do we actually
    determine how many times we should repeat the process? How often should we try
    that? Well, that is actually something that we can compute, but let''s put it
    aside, for now, to focus on the matter at hand: point cloud segmentation 😉.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 哈哈，对于那些怀疑者，你们难道没有一个上升的问题吗？我们如何实际确定应该重复多少次过程？我们应该多频繁地尝试？好吧，这实际上是可以计算的，但我们先把它放到一边，专注于当前的问题：点云分割😉。
- en: RANSAC Parameter Setting
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RANSAC参数设置
- en: 'We want to use RANSAC for detecting 3D planar shapes in our point cloud. To
    use RANSAC, we need to define three parameters: a distance threshold `distance_threshold`
    that allows tagging a point inlier or outlier to the 3D shape; a minimal number
    of point `ransac_n` selected to fit the geometric model; a number of iterations
    `num_iterations`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望使用RANSAC来检测点云中的3D平面形状。使用RANSAC时，我们需要定义三个参数：一个距离阈值`distance_threshold`，用于将点标记为内点或外点；一个最小点数`ransac_n`，用于拟合几何模型；一个迭代次数`num_iterations`。
- en: '**Determination of the Distance threshold:** We may be a bit limited by needing
    some domain knowledge to set up future segmentation and modeling threshold. Therefore,
    it would be exciting to try and bypass this to open the approach to non-experts.
    we will share with you a straightforward thought that could be useful. What if
    we were to compute the mean distance between points in our datasets and use this
    as a base to set up our threshold?'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**距离阈值的确定**：我们可能会因为需要一些领域知识来设置未来的分割和建模阈值而受到限制。因此，尝试绕过这一点以使方法对非专家开放将是令人兴奋的。我们将与你分享一个简单的想法，这可能会有用。如果我们计算数据集中点之间的平均距离，并将其作为设置阈值的基础，会怎样呢？'
- en: 'Well, it is an idea worth exploring. To determine such a value, we use a `KD-Tree`
    to speed up the process of querying the nearest neighbors for each point. From
    there, we can then query the k-nearest neighbors for each point in the point cloud,
    which is then packed in the `open3d` function shown below:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这是一个值得探索的想法。为了确定这样的值，我们使用 `KD-Tree` 来加速每个点的最近邻查询过程。从那里开始，我们可以查询点云中每个点的 k
    个最近邻，然后将其打包到下面显示的 `open3d` 函数中：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: without much surprise, it is close to 5 cm as we sampled our point cloud to
    this value. It means that if we reasoned by considering the nearest neighbor,
    we would have an average distance of 51 mm.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无意外，它接近 5 cm，因为我们将点云采样到这个值。这意味着如果我们考虑最近邻，我们会有 51 mm 的平均距离。
- en: '🌱 **Growing**: *From there, what we could do it to set the RANSAC parameter
    to a value derived from the nn_distance variable, which would then be adapted
    to the considered dataset, independently from domain knowledge. How would you
    approach this?*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 🌱 **成长**：*从这里开始，我们可以将 RANSAC 参数设置为从 nn_distance 变量得出的值，这样可以根据考虑的数据集进行调整，而不依赖于领域知识。你会怎么处理这个问题？*
- en: '**Determination of the point number**: Here, it is quick. We want to find planes,
    so we will take the minimum number of points needed to define a 3D plane: 3.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**点数的确定**：这里很简单。我们想要找出平面，因此我们将取定义 3D 平面所需的最小点数：3。'
- en: '**Determination of the iteration number**: The more iteration you have, the
    more robust your 3D shape detection works, but the longer it takes. For now, we
    can leave that to 1000, which yields good results. We will explore more ingenious
    ways to find the noise ratio of a point cloud in future tutorials. 😉'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**迭代次数的确定**：迭代次数越多，你的 3D 形状检测就越稳健，但所需时间也越长。目前，我们可以将其设置为 1000，这样可以获得良好的结果。我们将在未来的教程中探索更多巧妙的方法来找出点云的噪声比例。😉'
- en: '🧙‍♂️ **Experts**: *There exists an automatic way to get the iteration number
    right every time. If we want to succeed with a probability p (e.g., 99%), the
    outlier ratio in our data is e (e.g., 60%), and we need s point to define our
    model (here 3). The formula below gives us the expected number of iterations:*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 🧙‍♂️ **专家**：*有一种自动获取每次迭代次数的方法。如果我们希望以概率 p（例如 99%）成功，数据中的离群点比例是 e（例如 60%），我们需要
    s 个点来定义我们的模型（这里是 3）。以下公式给出了预期的迭代次数：*
- en: '![](../Images/f34e9a8ff5e9d1dd5f22f9c860ef44df.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f34e9a8ff5e9d1dd5f22f9c860ef44df.png)'
- en: Now that our RANSAC parameters are defined, we can study a first segmentation
    pass.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了 RANSAC 参数，我们可以研究第一次分割过程。
- en: 5\. Point Cloud Segmentation with RANSAC
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5\. 使用 RANSAC 进行点云分割
- en: '![](../Images/17e07a01da7ba28e3c757053c097f9b7.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/17e07a01da7ba28e3c757053c097f9b7.png)'
- en: 'Let us first set the different thresholds to non-automatic values for testing:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先将不同的阈值设置为非自动值进行测试：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'From there, we can segment the point cloud using RANSAC to detect planes with
    the following lines:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里开始，我们可以使用 RANSAC 对点云进行分割以检测平面，具体如下：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We gather results in two variables: `plane_model`, which holds the parameters
    `a`,`b`,`c`,`d` of a plane, and the `inliers` as point indexes.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将结果收集到两个变量中：`plane_model`，它包含平面的参数 `a`,`b`,`c`,`d`，以及 `inliers` 作为点索引。
- en: 'This allows to use the indexes to segment the point cloud in a `inlier_cloud`
    point set (that we color in red), and `outlier_cloud` point set (that we color
    in grey:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得可以使用索引将点云分割为 `inlier_cloud` 点集（我们将其标记为红色）和 `outlier_cloud` 点集（我们将其标记为灰色）：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '🦊 **Florent***: The argument* `*invert=True*` *permits to select the opposite
    of the first argument, which means all indexes not present in* `*inliers*`*. If
    you are lacking the shading, remember to compute the normals, as shown above.*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 🦊 **Florent** *：`*invert=True*` *参数允许选择第一个参数的反义，即所有不在* `*inliers*`* 中的索引。如果你缺少阴影，记得计算法线，如上所示。*
- en: '![](../Images/36f15121cce1019bae4e2e1fe3e1ebcc.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/36f15121cce1019bae4e2e1fe3e1ebcc.png)'
- en: '🌱 **Growing**: *Try and adjust the various parameters, and study the impact
    with a qualitative analysis. Remember first to decorrelate changes (one variable
    at a time); else your analysis may be biased* 😊.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 🌱 **成长**：*尝试调整各种参数，并通过定性分析研究其影响。首先记住要去相关变化（一次一个变量）；否则你的分析可能会有偏差* 😊。
- en: '![](../Images/385ce6263c78e78ca2ce72c1d56b7849.png)![](../Images/d0cf065a6a1ee3ea0f54091a3c00d1fb.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/385ce6263c78e78ca2ce72c1d56b7849.png)![](../Images/d0cf065a6a1ee3ea0f54091a3c00d1fb.png)'
- en: Great! You know how to segment your point cloud in an inlier point set and an
    outlier point set 🥳! Now, let us study how to find some clusters close to one
    another. So let us imagine that once we detected the big planar portions, we have
    some “floating” objects that we want to delineate. How to do this? (yes, it is
    a false question, we have the answer for you 😀)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！你知道如何将点云分割为内点集和外点集 🥳！现在，让我们研究如何找到彼此接近的一些簇。让我们想象一下，一旦我们检测到大的平面部分，我们有一些“漂浮”的物体需要
    delineate。怎么做呢？（是的，这是一个假问题，我们有答案给你 😀）
- en: '6\. Scaling 3D Segmentation: Multi-Order RANSAC'
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6\. 扩展 3D 分割：多阶 RANSAC
- en: '![](../Images/24389692747d404df62d0d88855514cd.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/24389692747d404df62d0d88855514cd.png)'
- en: Our philosophy will be very simple. We will first run RANSAC multiple times
    (let say `n` times) to extract the different planar regions constituting the scene.
    Then we will deal with the “floating elements” through Euclidean Clustering (DBSCAN).
    It means that we have to make sure we have a way to store the results during iterations.
    Ready?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的理念将非常简单。我们将首先多次运行 RANSAC（假设 `n` 次）以提取构成场景的不同平面区域。然后，我们将通过欧几里得聚类（DBSCAN）处理“漂浮元素”。这意味着我们必须确保有一种方法在迭代过程中存储结果。准备好了吗？
- en: 'Okay, let us instantiate an empty dictionary that will hold the results of
    the iterations (the plane parameters in `segment_models`, and the planar regions
    from the point cloud in `segments`):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们实例化一个空字典，以保存迭代结果（`segment_models`中的平面参数和`segments`中的点云平面区域）：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we want to make sure that we can influence later on the number of times
    we want to iterate for detecting the planes. To this end, let us create a variable
    `max_plane_idx` that holds the number of iterations:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要确保可以影响以后迭代的次数，以检测平面。为此，让我们创建一个变量`max_plane_idx`来保存迭代次数：
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '🦊 **Florent***: Here, we say that we want to iterate 10 times to find 10 planes,
    but there are smarter ways to define such a parameter. It actually extends the
    scope of the article and will be covered in another session.*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 🦊 **Florent***：在这里，我们说我们希望迭代 10 次以找到 10 个平面，但有更聪明的方法来定义这样的参数。这实际上扩展了文章的范围，将在另一节中讨论。*
- en: Now let us go into a working loopy-loopy 😁, that I will first quickly illustrate.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们进入一个工作循环 😁，我将首先快速说明。
- en: '![](../Images/75431eb5d58c5a9972a73c461b4868ee.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/75431eb5d58c5a9972a73c461b4868ee.png)'
- en: The loop to be executed to perform the segmentation within the RANSAC pass.
    © F. Poux
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以在 RANSAC 过程中进行分割的循环。© F. Poux
- en: 'In the first pass (loop `i=0`), we separate the inliers from the outliers.
    We store the inliers in `segments`, and then we want to pursue with only the remaining
    points stored in `rest`, that becomes the subject of interest for the loop n+1
    (loop `i=1`). That means that we want to consider the outliers from the previous
    step as the base point cloud until reaching the above threshold of iterations
    (not to be confused with RANSAC iterations). This translates into the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次迭代（循环`i=0`）中，我们将内点与外点分开。我们将内点存储在`segments`中，然后我们只对存储在`rest`中的剩余点感兴趣，这将成为循环
    n+1（循环`i=1`）的研究对象。这意味着我们希望将上一阶段的外点作为基础点云，直到达到上述的迭代阈值（与 RANSAC 迭代不同）。这转化为以下内容：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And that is pretty much it! Now, for visualizing the ensemble, as we paint
    each segment detected with a color from `tab20` through the first line in the
    loop (`colors = plt.get_cmap("tab20")(i)`), you just need to write:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！现在，为了可视化整体，我们通过循环中的第一行将每个检测到的分段涂上来自`tab20`的颜色（`colors = plt.get_cmap("tab20")(i)`），你只需写：
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 🦚 **Note***:* The list `[segments[i] for i in range(max_plane_idx)]` that we
    pass to the function `o3d.visualization.draw_geometries()` is actually a “list
    comprehension” 🤔. It is equivalent to writing a `for` loop that appends the first
    element `segments[i]` to a list. Conveniently, we can then add the `[rest]` to
    this list and the `draw.geometries()` method will understand we want to consider
    one point cloud to draw. How cool is that?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 🦚 **注意**：我们传递给函数`o3d.visualization.draw_geometries()`的列表`[segments[i] for i
    in range(max_plane_idx)]`实际上是一个“列表推导式”🤔。它等同于编写一个`for`循环，将第一个元素`segments[i]`追加到列表中。方便的是，我们可以将`[rest]`添加到这个列表中，`draw.geometries()`方法会理解我们想要绘制一个点云。这不是很酷吗？
- en: '![](../Images/149829534a11885af97f3ff19dea8f8f.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/149829534a11885af97f3ff19dea8f8f.png)'
- en: The result of the DBSCAN first pass on the 3D Point Cloud
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: DBSCAN对3D点云的第一次扫描结果
- en: Ha! We think we are done… But are we? Do you notice something strange here?
    If you look closely, there are some strange artifacts, like “red lines/planes”
    that actually cut some planar elements. Why? 🧐
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 哈！我们以为完成了……但我们真的完成了吗？你注意到这里有什么奇怪的地方吗？如果你仔细看，会发现一些奇怪的伪影，比如实际切割一些平面元素的“红色线条/平面”。为什么？🧐
- en: '![](../Images/1c67e5140011a746f7e66524ef332420.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1c67e5140011a746f7e66524ef332420.png)'
- en: In fact, because we fit all the points to RANSAC plane candidates (which have
    no limit extent in the Euclidean space) independently of the point's density continuity,
    then we have these “lines” artifacts depending on the order in which the planes
    are detected. So the next step is to prevent such behavior! For this, I propose
    to include in the iterative process a condition based on Euclidean clustering
    to refine inlier point sets in contiguous clusters. To this end, we will rely
    on the DBSCAN algorithm.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，由于我们将所有点拟合到RANSAC平面候选者（在欧几里得空间中没有限制范围）而不考虑点的密度连续性，因此根据平面的检测顺序，我们会出现这些“线”伪影。所以下一步是防止这种行为！为此，我建议在迭代过程中包含一个基于欧几里得聚类的条件，以在连续的簇中细化内点集。为此，我们将依赖于DBSCAN算法。
- en: Euclidean Clustering (DBSCAN)
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 欧几里得聚类（DBSCAN）
- en: With point cloud datasets, we often need to group sets of points spatially contiguous
    (i.e. that are physically close or adjacent to each other in 3D space), as illustrated
    below. But how can we do this efficiently?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在点云数据集中，我们经常需要将空间上连续的点集合（即在3D空间中物理上接近或相邻）进行分组，如下所示。但我们如何有效地做到这一点呢？
- en: '![](../Images/2d3ff3a05173c7b35dfab22f6883f9a2.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2d3ff3a05173c7b35dfab22f6883f9a2.png)'
- en: In this image, it seems obvious that we want to group points that are closed
    to one another, finding 5 sets of points. © F. Poux
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这张图中，很明显我们想要将彼此接近的点分组，找到5组点。© F. Poux
- en: The DBSCAN (Density-Based Spatial Clustering of Applications with Noise) algorithm
    was introduced in 1996 for this purpose. This algorithm is widely used, which
    is why it was awarded a scientific contribution award in 2014 that has stood the
    test of time.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: DBSCAN（基于密度的空间聚类应用与噪声）算法于1996年为此目的而提出。该算法被广泛使用，因此在2014年获得了经得起时间考验的科学贡献奖。
- en: The DBSCAN algorithm involves scanning through each point in the dataset and
    constructing a set of reachable points based on density. This is achieved by analyzing
    the neighborhood of each point and including it in the region if it contains enough
    points. The process is repeated for each neighboring point until the cluster can
    no longer expand. Points that do not have enough neighbors are labeled as noise,
    making the algorithm robust to outliers. It’s pretty impressive, isn’t it? 😆
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: DBSCAN算法涉及扫描数据集中的每个点，并基于密度构建一个可达点集合。这是通过分析每个点的邻域并在其包含足够点时将其包含在区域内来实现的。这个过程对每个邻近点重复，直到簇无法再扩展。没有足够邻居的点被标记为噪声，使得该算法对离群点具有鲁棒性。这不是很令人印象深刻吗？😆
- en: '![](../Images/5f884ed20535463901f44913fbc652f1.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5f884ed20535463901f44913fbc652f1.png)'
- en: Illustration of the DBSCAN algorithm process and influence of the two parameters
    ϵ and min_points on the results. You can see that the bigger the value, the fewer
    clusters are constituted. © F. Poux
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: DBSCAN算法过程和两个参数ϵ和min_points对结果的影响的示意图。你可以看到，值越大，组成的簇就越少。© F. Poux
- en: 'Ah, we almost forgot. The choice of parameters (ϵ for the neighborhood and
    n_min for the minimal number of points) can also be tricky: One must take great
    care when setting parameters to create enough interior points (which will not
    happen if n_min is too large or ϵ too small). In particular, this means that DBSCAN
    will have trouble finding clusters of different densities. BUT, DBSCAN has the
    great advantage of being computationally efficient without requiring to predefine
    the number of clusters, unlike Kmeans, for example. Finally, it allows for finding
    clusters of arbitrary shapes. We are now ready to dive in the parameter dark side
    of things 💻'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，我们差点忘了。参数选择（ϵ用于邻域，n_min用于最小点数）也可能很棘手：设置参数时必须小心，以确保创建足够的内部点（如果n_min太大或ϵ太小，就不会发生）。特别是，这意味着DBSCAN在发现不同密度的簇时会遇到困难。但DBSCAN有一个很大的优势，就是计算效率高，不需要像Kmeans那样预定义簇的数量。最后，它允许发现任意形状的簇。现在我们准备深入探讨参数的黑暗面
    💻
- en: DBSCAN for 3D Point Cloud Clustering
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DBSCAN用于3D点云聚类
- en: 'Let me detail the logical process (Activate the beast mode👹). First, we need
    to define the parameters to run DBSCAN:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我详细说明逻辑过程（激活猛兽模式👹）。首先，我们需要定义运行DBSCAN的参数：
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '🌱 **Growing**: *The definition of these parameters is something to explore.
    You have to find a way to balance over-segmentation and under-segmentation problematics.
    Eventually, you can use some heuristics determination based on the initial distance
    definition of RANSAC. Something to explore* 😉.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 🌱 **成长**：*这些参数的定义是一个需要探索的问题。你必须找到一种方法来平衡过度分割和不足分割的问题。最终，你可以基于RANSAC的初始距离定义使用一些启发式方法。这是一个值得探索的方面*
    😉。
- en: 'Within the for loop that we defined before, we will run DBSCAN just after the
    assignment of the inliers (`segments[i]=rest.select_by_index(inliers)`), by adding
    the following line right after:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前定义的for循环中，我们将在分配内点（`segments[i]=rest.select_by_index(inliers)`）后立即运行DBSCAN，方法是紧接着添加以下一行：
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we will count how many points each cluster that we found holds, using
    a weird notation that makes use of a list comprehension. The result is then stored
    in the variable `candidates`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将计算每个找到的簇包含多少个点，使用一种奇怪的符号表示法，该表示法利用了列表推导。结果存储在变量`candidates`中：
- en: '[PRE25]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And now? We have to find the “best candidate”, which is normally the cluster
    that holds the more points! And for this, here is the line:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 那现在呢？我们需要找到“最佳候选者”，通常是包含最多点的簇！为此，这里是这行代码：
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Okay, many tricks are happening under the hood here, but essentially, we use
    our Numpy proficiency to search and return the index of the points that belong
    to the biggest cluster. From here, it is downhill skiing, and we just need to
    ensure that we include any remaining clusters from each iteration for consideration
    in subsequent RANSAC iterations (🔥 recommendation to to read 5 times the sentence
    to digest!):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，很多技巧在这里发生，但本质上，我们利用Numpy的熟练度来搜索并返回属于最大簇的点的索引。从这里开始，接下来的过程就简单了，我们只需确保在每次迭代中将任何剩余簇纳入后续RANSAC迭代中（🔥
    推荐阅读5遍以消化！）：
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '🦚 **Note***: the* `rest` *variable now makes sure to hold both the remaining
    points from RANSAC and DBSCAN. And of course, the inliers are now filtered to
    the biggest cluster present in the raw RANSAC inlier set*.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 🦚 **注意**：*`rest`* 变量现在确保包含RANSAC和DBSCAN剩余的点。当然，内点现在被筛选为原始RANSAC内点集中最大的簇*。
- en: 'When the loop is over, you get a clean set of segments holding spatially contiguous
    point sets that follow planar shapes, that you can visualize with different colors
    using the following lines of code in the loop:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当循环结束时，你会得到一组干净的段，这些段包含空间上连续的点集，符合平面形状，你可以使用以下代码行以不同颜色可视化：
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The results should be something similar to this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该类似于这个：
- en: '![](../Images/e91a792806f2bc948d988ded50f423c9.png)![](../Images/111103f10b8da9050953ae4423df66d6.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e91a792806f2bc948d988ded50f423c9.png)![](../Images/111103f10b8da9050953ae4423df66d6.png)'
- en: But is this the end? Noooo, never 😄! Once the multi-order RANSAC segmentation
    has been applied to the point cloud, the next stage involves refining the remaining
    non-segmented points through the utilization of DBSCAN, which aids in further
    enhancing the granularity of the point cloud analysis with additional clusters.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 但这就结束了吗？不，不可能的 😄！一旦对点云应用了多阶RANSAC分割，下一阶段就是通过利用DBSCAN来细化剩余的未分割点，这有助于进一步提升点云分析的粒度，增加更多的簇。
- en: '🦚 **Note**: *Granularity is a useful academic word that is used a lot in data
    science. The granularity of data means the level of detail in how it is organized
    or modeled. Here, the smaller objects we can model from the point cloud, the finer
    granularity our representation has. (fancy, right?!)*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 🦚 **注意**：*粒度是一个在数据科学中经常使用的学术词汇。数据的粒度意味着数据组织或建模的详细程度。在这里，我们可以从点云中建模的对象越小，我们的表示的粒度就越细。（很高大上，对吧？！）*
- en: 7\. Euclidean Clustering Refinement
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7\. 欧几里得聚类精炼
- en: '![](../Images/664bd457a80f786f5d09aa8239aaeca7.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/664bd457a80f786f5d09aa8239aaeca7.png)'
- en: 'Okay, time to evade the loop, and work on the remaining points assigned to
    the`rest` variable, that are not yet attributed to any segment. Let us first get
    a visual grasp on what we are talking about:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，是时候摆脱循环，处理分配给 `rest` 变量的剩余点，这些点尚未分配给任何段。让我们首先对我们讨论的内容有一个视觉上的了解：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![](../Images/76fdada74949c1d91e41829464bb87af.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/76fdada74949c1d91e41829464bb87af.png)'
- en: 'We can apply a simple pass of Euclidean clustering with DBSCAN and capture
    the results in a `labels` variable. You know the drill:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 DBSCAN 进行简单的欧几里得聚类，并将结果捕获到一个 `labels` 变量中。你知道怎么做的：
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 🌱 **Growing:** *We use a radius of 10 cm for “growing” clusters and consider
    one only if, after this step, we have at least 10 points. But is this the right
    choice?* 🤔*Feel free to experiment to find a good balance and, ideally, a way
    to automate this*😀.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 🌱 **生长：** *我们使用 10 cm 的半径来“生长”簇，只有在此步骤之后至少有 10 个点时才考虑一个簇。但这是正确的选择吗？* 🤔*可以随意实验以找到一个好的平衡点，理想情况下，找到一种自动化的方法*😀。
- en: The labels vary between `-1` and `n`, where `-1` indicate it is a “noise” point
    and values `0` to `n` are then the cluster labels given to the corresponding point.
    Note that we want to get the labels as a NumPy array thereafter.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 标签的范围在 `-1` 和 `n` 之间，其中 `-1` 表示“噪声”点，`0` 到 `n` 的值则是分配给相应点的簇标签。请注意，我们希望将标签作为
    NumPy 数组获取。
- en: '![](../Images/3eb8a5f384d733521bb73466db0acea9.png)![](../Images/4f479ccf0472670ad4b5a84553201700.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3eb8a5f384d733521bb73466db0acea9.png)![](../Images/4f479ccf0472670ad4b5a84553201700.png)'
- en: 'On the left: parameters are not well defined. On the right, we have a better
    delineation of objects for downward processes.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧：参数定义不佳。右侧，我们对物体的轮廓有了更好的划分，以便进行后续处理。
- en: 'Nice. Now that we have groups of points defined with a label per point, let
    us color the results. This is optional, but it is handy for iterative processes
    to search for the right parameter’s values. To this end, we propose to use the
    Matplotlib library to get specific [color ranges](https://matplotlib.org/stable/tutorials/colors/colormaps.html),
    such as the tab20:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。现在我们已经定义了每个点的标签组，让我们为结果着色。这是可选的，但对于迭代过程以搜索合适的参数值非常有用。为此，我们建议使用 Matplotlib
    库获取特定的[颜色范围](https://matplotlib.org/stable/tutorials/colors/colormaps.html)，例如
    tab20：
- en: '[PRE31]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '🦚 **Note***: The* `max_label` *should be intuitive: it stores the maximal value
    in the labels list. This permits to use it as a denominator for the coloring scheme
    while treating with an “*`if`*” statement the special case where the clustering
    is skewed and delivers only noise + one cluster. After, we make sure to set these
    noisy points with the label* `-1` *to black* (`0`). *Then, we give to the attribute*
    `colors` *of the point cloud* `pcd` *the 2D NumPy array of 3 “columns”, representing
    R, G, B.*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 🦚 **注意**：*`max_label`* *应该是直观的：它存储标签列表中的最大值。这允许将其用作着色方案的分母，同时处理一个特殊情况，其中聚类被扭曲，仅产生噪声+一个簇。之后，我们确保将这些噪声点的标签设置为*
    `-1` *（黑色*（`0`）*）。*然后，我们将点云* `pcd` *的* `colors` *属性设置为表示 R、G、B 的 3 列的 2D NumPy
    数组。*
- en: Et voilà! I employ the same methodology as before, no sorcery! I just make sure
    to use coherent parameters to have a refined clustering to get the beautiful rainbow
    scene you always dreamed of 🥳!
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我采用了与之前相同的方法，没有任何魔法！我只是确保使用一致的参数来进行精细的聚类，以获得你一直梦想的美丽彩虹场景 🥳！
- en: '![](../Images/0e7ebe11fc52adac83a2b93374501062.png)![](../Images/727dec15d27cdf31f1fcf08a86dd71b1.png)![](../Images/a4fd6c629333ca0ddd5943b6fd1c602b.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0e7ebe11fc52adac83a2b93374501062.png)![](../Images/727dec15d27cdf31f1fcf08a86dd71b1.png)![](../Images/a4fd6c629333ca0ddd5943b6fd1c602b.png)'
- en: After refining the point cloud clustering results using DBSCAN, the focus shifts
    to the voxelization technique, which involves organizing the data into a meaningful
    spatial structure, thereby enabling efficient modeling of the point cloud information.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 DBSCAN 精炼点云聚类结果之后，焦点转向体素化技术，这涉及将数据组织成有意义的空间结构，从而实现对点云信息的高效建模。
- en: 8\. Voxelization and Labelling
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8\. 体素化和标记
- en: '![](../Images/b83044b78cead7000efc9944696472ca.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b83044b78cead7000efc9944696472ca.png)'
- en: Now that we have a point cloud with segment labels, it would be very interesting
    to see if we could fit indoor modeling workflows. One way to approach this is
    the use of voxels to accommodate for O-Space and R-Space. By dividing a point
    cloud into small cubes, it becomes easier to understand a model's occupied and
    empty spaces. Let us get into it.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个带有分段标签的点云，查看我们是否能适应室内建模工作流将会非常有趣。一种方法是使用体素来适应O-Space和R-Space。通过将点云划分为小立方体，可以更容易地理解模型的占用和空白空间。让我们深入了解一下。
- en: 9.1\. Voxel Grid Generation
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1\. 体素网格生成
- en: Creating accurate and detailed 3D models of the space means generating a nice
    and tight voxel grid. This technique divides a point cloud into small cubes or
    voxels with their own coordinate system.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 创建准确且详细的空间3D模型意味着生成一个紧凑的体素网格。这种技术将点云划分为具有自己坐标系统的小立方体或体素。
- en: '![](../Images/6ddeb653af9fa95611230f33d792e393.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6ddeb653af9fa95611230f33d792e393.png)'
- en: Voxel Grid Generation to structure the 3D Point Cloud with the segment information.
    © F. Poux
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 体素网格生成以结构化带有分段信息的3D点云。© F. Poux
- en: 'To create such a structure, we first define the size of our new entity: the
    voxel:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这样的结构，我们首先定义我们新实体的大小：体素：
- en: '[PRE32]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we want to know how many of these cubes we must stack onto one another
    to fill the bounding box defined by our point cloud. This means that we have first
    to compute the extent of our point cloud:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想知道我们需要堆叠多少个这样的立方体才能填充由点云定义的边界框。这意味着我们首先需要计算点云的范围：
- en: '[PRE33]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Great, now we use the `o3d.geometry.VoxelGrid.create_from_point_cloud()` function
    onto any point cloud of choice to fit a voxel grid on it. but wait. Which point
    cloud do we want to distinguish for further processes?
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，现在我们使用`o3d.geometry.VoxelGrid.create_from_point_cloud()`函数对任何选择的点云进行操作，以便在其上拟合体素网格。但是等等，我们想区分哪个点云以便进一步处理？
- en: 'Okay, let us illustrate the case where you want to have voxels of “structural”
    elements vs voxels of clutter that do not belong to structural elements. Without
    labeling, we could guide our choice based on whether or not they belong to RANSAC
    segments or other segments; This means first concatenating the segments from the
    RANSAC pass:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们举例说明你想拥有“结构性”元素的体素与不属于结构性元素的杂物体素的情况。没有标签的情况下，我们可以根据它们是否属于RANSAC分段或其他分段来指导我们的选择；这意味着首先将RANSAC处理的分段进行拼接：
- en: '[PRE34]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '🦚 **Note**: *At this stage, you have the ability to color the point clouds
    with a uniform color later picked up by the voxels. If this is something you would
    like, you can use:* `pcd_ransac.paint_uniform_color([1, 0, 0])`'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '🦚 **注意**: *在这个阶段，你有能力用体素稍后拾取的均匀颜色为点云着色。如果这是你想要的，你可以使用：* `pcd_ransac.paint_uniform_color([1,
    0, 0])`'
- en: 'Then, we can simply extract our voxel grid:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以简单地提取我们的体素网格：
- en: '[PRE35]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'and do the same thing for the remaining elements:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 并对剩余元素做同样的处理：
- en: '[PRE36]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The final step is to visualize our result:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是可视化我们的结果：
- en: '[PRE37]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![](../Images/a710cdc6698553309602a38d1349b361.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a710cdc6698553309602a38d1349b361.png)'
- en: A semantic representation of the space using voxel representation. © F. Poux
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用体素表示的空间的语义表示。© F. Poux
- en: This is awesome! It looks like one of those computer games where the whole world
    is constructed out of cubes! And we can actually use the segment labels to guide
    our voxel modeling! This opens up many perspectives! But an issue remains. With
    Open3D, it is hard to extract the voxels that are not filled; So, having achieved
    the structuration of the voxelized point cloud, the subsequent step involves exploring
    voxel space modeling techniques to provide alternative perspectives for analyzing
    the spatial relationships and properties of the voxelized data, opening up new
    avenues for advanced point cloud modeling.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这太棒了！它看起来像那些整个世界由立方体构成的计算机游戏！而且我们实际上可以使用分段标签来指导我们的体素建模！这开启了许多视角！但问题依然存在。使用Open3D，提取未填充的体素是困难的；因此，完成体素化点云的结构化后，下一步涉及探索体素空间建模技术，以提供分析体素化数据空间关系和属性的替代视角，为高级点云建模开辟新途径。
- en: '🤠 **Ville**: *Voxelization is a different spatial representation of the same
    point cloud data. Great for robots if they need to avoid collisions! And for great
    for simulating… fire drills, for example!*'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '🤠 **Ville**: *体素化是对相同点云数据的不同空间表示。如果机器人需要避开碰撞，这种表示非常有用！比如在模拟…火灾演习时也非常有用！*'
- en: 9\. Spatial Modelling
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9\. 空间建模
- en: '![](../Images/8f45765461494fbd3c658993a1b48144.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8f45765461494fbd3c658993a1b48144.png)'
- en: 'In indoor modeling applications, the voxel-based representation of point clouds
    plays a pivotal role in capturing and analyzing the geometric properties of complex
    environments. As the scale and complexity of point cloud datasets increase, it
    becomes essential to delve deeper into voxel segmentation techniques to extract
    meaningful structures and facilitate higher-level analysis. Let us thus define
    a function that fits a voxel grid and return both filled and empty spaces:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在室内建模应用中，基于体素的点云表示在捕捉和分析复杂环境的几何属性方面起着关键作用。随着点云数据集的规模和复杂性的增加，深入探讨体素分割技术变得至关重要，以提取有意义的结构并促进更高层次的分析。因此，让我们定义一个函数来拟合体素网格，并返回填充和空白区域：
- en: '[PRE38]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Within the function, we will (1) Determine the minimum and maximum coordinates
    of the point cloud, (2) Calculate the dimensions of the voxel grid, (3) Create
    an empty voxel grid, (4) Calculate the indices of the occupied voxels and (5)
    Mark occupied voxels as True.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，我们将 (1) 确定点云的最小和最大坐标，(2) 计算体素网格的尺寸，(3) 创建一个空的体素网格，(4) 计算已占据体素的索引以及 (5)
    将占据体素标记为 True。
- en: '![](../Images/c8495062282952b988f871455aef9eb1.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c8495062282952b988f871455aef9eb1.png)'
- en: Algorithm workflow to create an occupancy grid from the point cloud. © F. Poux
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 从点云创建占据网格的算法工作流程。© F. Poux
- en: 'This translates into the following code that we want to have inside this function:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这转化为我们希望在此函数中包含的以下代码：
- en: '[PRE39]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Our function is defined, and we can now use it to extract the voxels, segmented
    between structural, clutter, and empty ones:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了函数，现在可以使用它提取体素，按结构、杂乱和空体素进行分段：
- en: '[PRE40]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '🦚 **Note**: *The* `*nonzero()*` *function from NumPy finds the indices of the
    nonzero elements in the* `*ransac_voxels*` *variable. The* `*nonzero()*` *function
    returns a tuple of arrays, where each array corresponds to the indices along a
    specific axis where the elements are nonzero. then we apply the* `*np.transpose()*`
    *NumPy function to the result obtained from* `*np.nonzero(ransac_voxels)*`*. The*
    `*transpose()*` *function finally permutes the axes of the array. (effectively
    swapping the rows with the columns). By combining these operations, the code line
    transposes the indices of the nonzero elements of* `*ransac_voxels*`*, resulting
    in a transposed array where each row represents the coordinates or indices of
    a nonzero element in the original* `*ransac_voxels*` *array*. 😊'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 🦚 **注意**：*NumPy 中的 `*nonzero()*`* 函数查找 `*ransac_voxels*` 变量中非零元素的索引。`*nonzero()*`*
    函数返回一个数组的元组，每个数组对应于特定轴上非零元素的索引。然后，我们将 `*np.transpose()*`* NumPy 函数应用于从 `*np.nonzero(ransac_voxels)*`*
    获得的结果。`*transpose()*`* 函数最终会排列数组的轴（有效地交换行和列）。通过结合这些操作，代码行对 `*ransac_voxels*`*
    的非零元素索引进行转置，生成一个转置数组，其中每行表示原始 `*ransac_voxels*`* 数组中非零元素的坐标或索引。😊
- en: This voxel modeling approach offers valuable insights into the spatial relationships
    and properties of the voxelized data. To visualize the results as shown below
    outside of Python with transparency, we need to export our data.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这种体素建模方法提供了对体素化数据空间关系和属性的宝贵见解。为了在 Python 之外以透明度可视化结果，我们需要导出数据。
- en: '![](../Images/26688159b8fd845b7e77716526a41603.png)![](../Images/b5cf1042943b2491366570bf5785fea4.png)![](../Images/ac7654c650a1171f5b0bc0629506989d.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/26688159b8fd845b7e77716526a41603.png)![](../Images/b5cf1042943b2491366570bf5785fea4.png)![](../Images/ac7654c650a1171f5b0bc0629506989d.png)'
- en: Results of the Occupancy grid matching. On the left are both the filled voxels
    and empty voxels, in the middle are the filled voxels, and in the right are the
    empty voxels. © F. Poux
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 占据网格匹配的结果。左侧是填充体素和空体素，中间是填充体素，右侧是空体素。© F. Poux
- en: After achieving the structuration of the voxelized point cloud, the next step
    involves exporting both the point cloud and voxel data to external formats, facilitating
    interoperability and enabling seamless integration with other software tools and
    workflows. This export process ensures that the structured voxel data and the
    original point cloud can be easily shared, visualized, or utilized for further
    analysis in various applications, fostering a collaborative and versatile approach
    to point cloud data utilization.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现体素化点云的结构化后，下一步涉及将点云和体素数据导出为外部格式，以便实现互操作性，并与其他软件工具和工作流程无缝集成。此导出过程确保结构化的体素数据和原始点云可以轻松共享、可视化或用于进一步分析，从而促进对点云数据利用的协作和多功能方法。
- en: 10\. Exporting 3D Datasets
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10\. 导出 3D 数据集
- en: '![](../Images/61eb9b7f6baa27577836ecc3290f343b.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/61eb9b7f6baa27577836ecc3290f343b.png)'
- en: Let us first focus on exporting the point cloud segmented datasets.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先关注导出点云分割数据集。
- en: 10.1\. Segmented point cloud export
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1\. 分割点云导出
- en: 'To export the segmented point cloud, we must ensure that we can write the label
    per point within a readable ASCII file. To do this, we will create a list of XYZ
    segments to which we will append the label feature. This can be done with the
    following for loop:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要导出分割后的点云，我们必须确保可以在可读的ASCII文件中为每个点写入标签。为此，我们将创建一个XYZ片段列表，并将标签特征附加到该列表。这可以通过以下`for`循环完成：
- en: '[PRE41]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'From there, we want not to forget the remaining elements from the DBSCAN clustering,
    on which we apply the same principle:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，我们不想忘记DBSCAN聚类中的剩余元素，对其应用相同的原则：
- en: '[PRE42]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'finally, we append this to the segments list:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将其附加到片段列表中：
- en: '[PRE43]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'all that we have to do is then to use numpy to export the dataset and visualize
    it externally:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们所需要做的就是使用numpy导出数据集并进行外部可视化：
- en: '[PRE44]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '![](../Images/9a6913b5b3158a617aa100ac50f293b6.png)![](../Images/3f317d5083906d7a4c6ef6e961bc04df.png)![](../Images/3d6ef345ce0c619c4c2e337ea05070c8.png)![](../Images/678224d1204a44582879919bd30270e1.png)![](../Images/a40abe9f177b691d00b9bc7991871a61.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9a6913b5b3158a617aa100ac50f293b6.png)![](../Images/3f317d5083906d7a4c6ef6e961bc04df.png)![](../Images/3d6ef345ce0c619c4c2e337ea05070c8.png)![](../Images/678224d1204a44582879919bd30270e1.png)![](../Images/a40abe9f177b691d00b9bc7991871a61.png)'
- en: Following the successful export of the segmented point cloud dataset, the focus
    now shifts to exporting the voxel dataset as a `.obj` file.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功导出分割后的点云数据集后，现在的重点是将体素数据集导出为`.obj`文件。
- en: 10.2\. Voxel Model Export
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2\. 体素模型导出
- en: 'To export the voxels, we first have to generate a cube for each voxel; These
    cubes are then combined in a `voxel_assembly`, stacked together to generate the
    final file. We create the `voxel_modelling(filename, indices, voxel_size)` function
    to do this:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要导出体素，我们首先必须为每个体素生成一个立方体；这些立方体然后在`voxel_assembly`中组合在一起，堆叠生成最终文件。我们创建了`voxel_modelling(filename,
    indices, voxel_size)`函数来完成这个任务：
- en: '[PRE45]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '🦚 **Note**: *the function* `[cube()](https://drive.google.com/file/d/1kPu85YHl66gQH8Qumxlyd-Sp4PjgvBVm/view?usp=sharing)`
    *reads the provided indices, generates voxel cubes based on the indices and voxel
    size, writes the voxel cubes to a file, and keeps track of the assembled voxel
    cubes in the* `*voxel_assembly*` *list, which is ultimately returned by the function.*'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 🦚 **注意**：*函数* `[cube()](https://drive.google.com/file/d/1kPu85YHl66gQH8Qumxlyd-Sp4PjgvBVm/view?usp=sharing)`
    *读取提供的索引，根据索引和体素大小生成体素立方体，将体素立方体写入文件，并跟踪在* `*voxel_assembly*` *列表中的组装体素立方体，最终由函数返回。*
- en: 'This is then used to export three different voxel assemblies:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 然后用来导出三种不同的体素组合：
- en: '[PRE46]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '![](../Images/2d627d5ec536ba3c638629a25ce4f5f5.png)![](../Images/7860e71bb83efd674302b5c044716254.png)![](../Images/442975beca59c66312b3cdbbcfc21310.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2d627d5ec536ba3c638629a25ce4f5f5.png)![](../Images/7860e71bb83efd674302b5c044716254.png)![](../Images/442975beca59c66312b3cdbbcfc21310.png)'
- en: The results of the Segmentation and voxel modeling. © F. Poux
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 分割和体素建模的结果。© F. Poux
- en: '💻 Get Access to the Code here: [Code Samples](https://drive.google.com/drive/folders/1-sGlVvsPcyp9VZ8cw-J8kbhj4-aK_8p8?usp=sharing)'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 💻 在这里获取代码访问权限：[代码示例](https://drive.google.com/drive/folders/1-sGlVvsPcyp9VZ8cw-J8kbhj4-aK_8p8?usp=sharing)
- en: '🍇 Get Access to the Data here: [3D Datasets](https://drive.google.com/drive/folders/1sCBT1lc9A8Zn4grpxwFrBrvos86c0HZR?usp=sharing)'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 🍇 在这里获取数据访问权限：[3D 数据集](https://drive.google.com/drive/folders/1sCBT1lc9A8Zn4grpxwFrBrvos86c0HZR?usp=sharing)
- en: '👨‍🏫3D Data Processing and AI Courses: [3D Academy](https://learngeodata.eu/)'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 👨‍🏫3D 数据处理和AI课程：[3D 学院](https://learngeodata.eu/)
- en: '📖 Subscribe to get early access to 3D Tutorials: [3D AI Automation](https://medium.com/@florentpoux/subscribe)'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 📖 订阅以获得3D教程的提前访问权限：[3D AI 自动化](https://medium.com/@florentpoux/subscribe)
- en: '![](../Images/ceab061ce5f1ea698c109d269cc41fd2.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ceab061ce5f1ea698c109d269cc41fd2.png)'
- en: Conclusion
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: '🦊 **Florent**: Massive congratulations 🎉! You just learned how to develop an
    automatic shape detection, clustering, voxelization, and indoor modeling program
    for 3D point clouds composed of millions of points with different strategies!
    Sincerely, well done! But the path certainly does not end here because you just
    unlocked a tremendous potential for intelligent processes that reason at a segment
    level!'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 🦊 **Florent**：大规模祝贺🎉！你刚刚学会了如何开发一个自动形状检测、聚类、体素化和室内建模程序，用于处理由数百万个点组成的3D点云，并采用不同的策略！真心地，做得很好！但道路显然不止于此，因为你刚刚解锁了一个巨大的智能过程潜力，能够在片段级别进行推理！
- en: '🤠 **Ville**: So, now you’re wondering if we can make 3D modeling a completely
    hands-off process? We’re halfway there with the technique we’ve got. Why? Our
    technique can find parameters, for example, for the plane models. This is why
    the folks in academia call it parametric modeling. However, we still need to carefully
    choose some of the other parameters, such as the ones for RANSAC. I encourage
    you to experiment by applying your code on a different point cloud!'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 🤠 **Ville**：那么，你是否在想我们是否可以让 3D 建模成为完全无需人工干预的过程？凭借我们目前的技术，我们已经完成了一半。为什么？我们的技术可以找到，例如，平面模型的参数。这就是为什么学术界的人称之为参数建模。然而，我们仍然需要仔细选择其他一些参数，比如
    RANSAC 的参数。我鼓励你尝试在不同的点云上应用你的代码！
- en: '![](../Images/4b6c35c1665bd5dbdfac5fc7031fb72a.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4b6c35c1665bd5dbdfac5fc7031fb72a.png)'
- en: Example of 3D meshing based on the semantics of the ground. © F. Poux
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 基于地面语义的 3D 网格示例。© F. Poux
- en: Going Further
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更进一步
- en: The learning journey does not end here. Our lifelong search begins, and future
    steps will dive into deepening 3D Voxel work, exploring semantics, and point cloud
    analysis with deep learning techniques. We will unlock advanced 3D LiDAR analytical
    workflows. A lot to be excited about!
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 学习之旅并未结束。我们的终身探索才刚刚开始，未来的步骤将深入到 3D Voxel 工作，探索语义和点云分析与深度学习技术。我们将解锁高级的 3D LiDAR
    分析工作流程。令人兴奋的事情还有很多！
- en: '**Lehtola, V.**, Nikoohemat, S., & Nüchter, A. (2020). Indoor 3D: Overview
    on scanning and reconstruction methods. Handbook of Big Geospatial Data, 55–97\.
    [https://doi.org/10.1007/978-3-030-55462-0_3](https://doi.org/10.1007/978-3-030-55462-0_3)'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Lehtola, V.**，Nikoohemat, S.，& Nüchter, A.（2020）。室内 3D：扫描和重建方法概述。大地空间数据手册，55–97\.
    [https://doi.org/10.1007/978-3-030-55462-0_3](https://doi.org/10.1007/978-3-030-55462-0_3)'
- en: '**Poux, F.**, & Billen, R. (2019). Voxel-based 3D point cloud semantic segmentation:
    unsupervised geometric and relationship featuring vs deep learning methods. *ISPRS
    International Journal of Geo-Information*. 8(5), 213; [https://doi.org/10.3390/ijgi8050213](https://doi.org/10.3390/ijgi8050213)
    — Jack Dangermond Award ([Link to press coverage](https://www.geographie.uliege.be/cms/c_5724437/en/florent-poux-and-roland-billen-winners-of-the-2019-jack-dangermond-award))'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Poux, F.**，& Billen, R.（2019）。基于体素的 3D 点云语义分割：无监督几何和关系特征与深度学习方法。*ISPRS 国际地理信息杂志*。8(5)，213；[https://doi.org/10.3390/ijgi8050213](https://doi.org/10.3390/ijgi8050213)
    — Jack Dangermond 奖（[新闻报道链接](https://www.geographie.uliege.be/cms/c_5724437/en/florent-poux-and-roland-billen-winners-of-the-2019-jack-dangermond-award)）'
- en: Bassier, M., Vergauwen, M., **Poux, F.**, (2020). Point Cloud vs. Mesh Features
    for Building Interior Classification. *Remote Sensing*. 12, 2224\. https://doi:10.3390/rs12142224
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Bassier, M., Vergauwen, M., **Poux, F.**，（2020）。建筑内部分类中的点云与网格特征。*遥感*。12，2224\.
    https://doi:10.3390/rs12142224
