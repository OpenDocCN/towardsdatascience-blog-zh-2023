- en: 'Rock Paper Scissors: A Quantum Computing Twist'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 石头剪刀布：量子计算的妙趣
- en: 原文：[https://towardsdatascience.com/rock-paper-scissors-a-quantum-computing-twist-bcf66b88d781](https://towardsdatascience.com/rock-paper-scissors-a-quantum-computing-twist-bcf66b88d781)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/rock-paper-scissors-a-quantum-computing-twist-bcf66b88d781](https://towardsdatascience.com/rock-paper-scissors-a-quantum-computing-twist-bcf66b88d781)
- en: TUTORIAL
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 教程
- en: A New Way to Play with Advanced Computing
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以先进计算的新方式来玩
- en: '[](https://medium.com/@KoryBecker?source=post_page-----bcf66b88d781--------------------------------)[![Kory
    Becker](../Images/53a2493fe53f215d3e715d456b36c553.png)](https://medium.com/@KoryBecker?source=post_page-----bcf66b88d781--------------------------------)[](https://towardsdatascience.com/?source=post_page-----bcf66b88d781--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----bcf66b88d781--------------------------------)
    [Kory Becker](https://medium.com/@KoryBecker?source=post_page-----bcf66b88d781--------------------------------)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@KoryBecker?source=post_page-----bcf66b88d781--------------------------------)[![Kory
    Becker](../Images/53a2493fe53f215d3e715d456b36c553.png)](https://medium.com/@KoryBecker?source=post_page-----bcf66b88d781--------------------------------)[](https://towardsdatascience.com/?source=post_page-----bcf66b88d781--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----bcf66b88d781--------------------------------)
    [Kory Becker](https://medium.com/@KoryBecker?source=post_page-----bcf66b88d781--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----bcf66b88d781--------------------------------)
    ·14 min read·May 16, 2023
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: ·发表于[Towards Data Science](https://towardsdatascience.com/?source=post_page-----bcf66b88d781--------------------------------)
    ·14分钟阅读·2023年5月16日
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/1857887a77872c72506f163d82e4cd04.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1857887a77872c72506f163d82e4cd04.png)'
- en: 'Source: [Stable Diffusion](https://stablediffusionweb.com).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[Stable Diffusion](https://stablediffusionweb.com)。
- en: Having fun with quantum computing games
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 享受量子计算游戏的乐趣
- en: I love demonstrating the effects of quantum computing. Especially, through games
    that use quantum superposition and entanglement.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢展示量子计算的效果。特别是，通过使用量子叠加态和纠缠的游戏。
- en: Quantum computing is an incredibly exciting technology that will impact virtually
    every industry and science. Learning about how quantum computing works, and specifically
    how it differs from classical computing, can make you a better programmer and
    a more logical thinker!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 量子计算是一项极其激动人心的技术，它将影响几乎所有的行业和科学。了解量子计算的工作原理，特别是它如何不同于经典计算，能让你成为更好的程序员和更具逻辑思维能力的人！
- en: So, I thought it would be fun to come up with a game that could be implemented
    on a quantum computer in order to further demonstrate the differences between
    quantum and traditional computing.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我认为设计一个可以在量子计算机上实现的游戏，进一步展示量子计算和传统计算之间的差异，会很有趣。
- en: No shortage of amazing quantum feats
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不乏令人惊叹的量子奇迹
- en: There are many surprisingly powerful (and even confusing!) properties that quantum
    computers can perform compared to their classical counterparts.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 与经典计算机相比，量子计算机具备许多令人惊讶（甚至令人困惑！）的强大特性。
- en: Increased performance from [exponential](https://medium.com/towards-data-science/ghostly-images-and-qubits-a-new-way-to-visualize-quantum-superposition-94b582889549)
    processing power, evaluating multiple scenarios [simultaneously](/programming-in-3d-my-first-steps-into-quantum-computing-566b9b93929d),
    and even something as simple as generating advanced [random numbers](/the-magic-of-quantum-computing-a-beginners-guide-to-writing-a-magic-number-guessing-game-c1cdb384f457)
    can all be achieved on a quantum level.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通过[指数](https://medium.com/towards-data-science/ghostly-images-and-qubits-a-new-way-to-visualize-quantum-superposition-94b582889549)处理能力提高性能，评估多个场景[同时](/programming-in-3d-my-first-steps-into-quantum-computing-566b9b93929d)，甚至生成高级[随机数](/the-magic-of-quantum-computing-a-beginners-guide-to-writing-a-magic-number-guessing-game-c1cdb384f457)，这些都可以在量子层面实现。
- en: We’ll focus on superposition — the technique that allows a quantum computer
    to evaluate many different scenarios simultaneously. To make it fun — we’ll use
    a game!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重点关注叠加态——这种技术允许量子计算机同时评估多种不同的场景。为了增加趣味性——我们将使用游戏！
- en: Ideas for quantum games
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 量子游戏的创意
- en: I searched far and wide for ideas of a game that would be simple enough to use,
    easy enough to play, and yet that can take advantage of quantum processing.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我四处搜寻，希望找到一个足够简单、易于玩耍，同时又能利用量子处理的游戏创意。
- en: '*It would also help if this has never been done before!*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果这以前从未做过，那就更好了！*'
- en: This led me to the idea of classical games such as [tic tac toe](https://quantumfrontiers.com/2019/07/15/tiqtaqtoe),
    [poker](https://link.springer.com/article/10.1140/epjp/s13360-020-00360-5), and
    [other](https://arxiv.org/abs/2202.07756) games.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我想到了一些经典游戏，比如[井字游戏](https://quantumfrontiers.com/2019/07/15/tiqtaqtoe)、[扑克](https://link.springer.com/article/10.1140/epjp/s13360-020-00360-5)以及[其他](https://arxiv.org/abs/2202.07756)游戏。
- en: While many research papers that combine quantum computing with games often focus
    on various algorithmic approaches and mathematical complexity, I wanted to create
    something more easily understandable.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然许多将量子计算与游戏结合的研究论文通常关注各种算法方法和数学复杂性，但我希望创建一些更容易理解的东西。
- en: Writing a quantum computing program doesn’t have to be difficult.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 编写量子计算程序并不一定很难。
- en: Once you have an understanding of the various gates and behaviors of qubits,
    you can create a vast array of quantum applications.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你了解了各种量子门和量子比特的行为，你就可以创建大量的量子应用程序。
- en: What better way to demonstrate this than with a game of rock, paper, scissors!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 还有什么比用石头、剪刀、布的游戏更好地展示这一点呢！
- en: Rock, paper, scissors
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 石头、剪刀、布
- en: Rock, Paper, Scissors is a game for two players. The game involves each player
    secretly choosing an item of rock, paper, or scissors. The players typically count
    to three and then reveal their hand at the same time.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 石头、剪刀、布是一个两人游戏。游戏中每个玩家秘密选择一个石头、剪刀或布的物品。玩家通常数到三，然后同时展示他们的选择。
- en: The rules of the game state that rock defeats scissors, scissors defeats paper,
    and paper defeats rock.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏规则规定，石头击败剪刀，剪刀击败布，布击败石头。
- en: Simple enough! Or is it?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 足够简单！或者说是吗？
- en: A mathematical paradox
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个数学悖论
- en: The underlying principle of rock, paper, scissors is really a measure of weights
    and values.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 石头、剪刀、布的基本原则实际上是一种权重和价值的衡量。
- en: We can consider that rock is valued greater than scissors. Likewise, scissors
    is valued greater than paper. So far, so good.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以认为石头的价值大于剪刀。同样，剪刀的价值大于布。到目前为止，一切都很好。
- en: Rock > Scissors > Paper
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 石头 > 剪刀 > 布
- en: Now, if rock is greater than scissors, and scissors is greater that paper, then
    surely rock is greater than paper as well. However, according to the game rules,
    paper is valued *greater* than rock!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果石头大于剪刀，剪刀大于布，那么石头也一定大于布。然而，根据游戏规则，布的价值*大于*石头！
- en: Rock > Scissors > Paper > Rock?
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 石头 > 剪刀 > 布 > 石头？
- en: It’s quite the paradox!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是一个悖论！
- en: Thinking about this mathematically for a moment
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们从数学角度思考一下这个问题。
- en: Let’s take a step back to consider the paradox that makes the game rock, paper,
    scissors so unique.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们退一步来考虑一下使石头、剪刀、布游戏如此独特的悖论。
- en: 'Consider that we have three variables: A, B, and C (representing rock, paper,
    and scissors respectively). Each variable is assigned a weight such that A > B
    and B > C. The [transitive property of inequality](https://www.mathsisfun.com/algebra/inequality-properties.html)
    states that according to this arrangement, A > C.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 设想我们有三个变量：A、B 和 C（分别代表石头、布和剪刀）。每个变量被赋予一个权重，使得 A > B 和 B > C。[不等式的传递性](https://www.mathsisfun.com/algebra/inequality-properties.html)规定，根据这种排列，A
    > C。
- en: This would lead us to believe that if rock > scissors, and scissors > paper,
    then rock > paper. Clearly, this is not how the game is played!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这会使我们相信，如果石头 > 剪刀，剪刀 > 布，那么石头 > 布。显然，这不是游戏的实际玩法！
- en: In fact, this is the premise behind Hardy’s Paradox.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这就是哈代悖论的前提。
- en: The Hardy Paradox of rock, paper, and scissors
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 石头、剪刀、布的哈代悖论
- en: The [Hardy Paradox](https://en.wikipedia.org/wiki/Hardy%27s_paradox), developed
    by [Lucien Hardy](https://en.wikipedia.org/wiki/Lucien_Hardy) in 1992, examines
    the situation where three variables that are seemingly aligned in weights of each
    being greater than the next, can still create a situation where the last variable
    ends up being greater than the first — violating the transitive property of inequality.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[哈代悖论](https://en.wikipedia.org/wiki/Hardy%27s_paradox)，由[卢西安·哈代](https://en.wikipedia.org/wiki/Lucien_Hardy)于1992年提出，考察了三种变量表面上在每个变量的权重上都大于下一个的情况，仍然可以产生最后一个变量大于第一个变量的情况——违反了不等式的传递性。'
- en: In fact, this type of violation is [distinctly possible](https://www.sciencedaily.com/releases/2023/04/230419095535.htm)
    in the quantum world where particles may become entangled and, in fact, can be
    found in the game rock, paper, scissors!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这种类型的违反在量子世界中是[显然可能的](https://www.sciencedaily.com/releases/2023/04/230419095535.htm)，在量子世界中，粒子可能会纠缠在一起，事实上，它还可以在石头、剪子、布的游戏中找到！
- en: I think we’ve just found the perfect game to demonstrate some of the power behind
    quantum computing.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我们刚刚找到了一款完美的游戏，来展示量子计算背后的部分力量。
- en: Establishing the rules of the game
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立游戏规则
- en: We’re going to create a quantum computing program that can find all winning
    hands in a game of rock, paper, scissors.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个量子计算程序，可以在石头、纸、剪刀的游戏中找到所有获胜手。
- en: We’ll create both a classical and quantum version of the program in order to
    demonstrate the difference in complexity.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建经典版和量子版程序，以展示复杂性的差异。
- en: The first thing that we need to do is to encode the items in the game so that
    we can utilize them in an algorithm. Since each player can choose one of three
    items (rock, paper, or scissors) during each round of the game, we can have nine
    different possibilities for game hands.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是对游戏中的项进行编码，以便我们可以在算法中使用它们。由于每个玩家在每轮游戏中可以选择三项中的一个（石头、纸或剪刀），我们可以有九种不同的游戏手可能性。
- en: Let’s use the first letter for each item to represent possible choices from
    each player in a round of the game. Therefore, the possible hands that can be
    played are shown below.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用每个项的首字母来代表游戏中每个玩家的可能选择。因此，可能的手牌如下所示。
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The above list shows all possible hands, beginning with rock versus rock (RR),
    rock versus paper (RP), rock versus scissors (RS), etc.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的列表显示了所有可能的手牌，从石头对石头（RR），石头对纸（RP），石头对剪刀（RS）等开始。
- en: 'Of the above nine possible hands, only three of these are winning choices:
    rock versus scissors (RS), scissors versus paper (SP), and paper versus rock (PR).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述九种可能的手牌中，只有三种是获胜选择：石头对剪刀（RS），剪刀对纸（SP），和纸对石头（PR）。
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Moving to the digital world
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入数字世界
- en: Now that we’ve defined our game choices, we need to convert these choices from
    letters (R, S, P) into binary digits of zero or one. This is needed so that we
    can eventually represent the choices as qubits.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了游戏选择，我们需要将这些选择从字母（R，S，P）转换为二进制数字零或一。这是必要的，以便我们最终可以将选择表示为量子比特。
- en: Since we have three items, we’ll represent them from the values zero to two
    (00, 01, 10).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有三项，我们将从零到二（00，01，10）表示它们。
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It’s important to note the binary values that we assign to each item, as we
    will be referring back to these when looking at the input and output to our programs.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意我们为每个项分配的二进制值，因为我们在查看程序的输入和输出时会参考这些值。
- en: Next, let’s define the rules of the game from the perspective of player one.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们从玩家一的角度定义游戏规则。
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we’ve defined a simple digital definition for each possible game hand,
    let’s start writing some code.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为每种可能的游戏手定义了简单的数字定义，让我们开始编写一些代码。
- en: Encoding the game as bits
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将游戏编码为比特
- en: With our game items defined as binary values, we can now store these values
    within qubits. Let’s create a Python object that defines each item with a corresponding
    value as listed in the prior section above.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的游戏项被定义为二进制值，我们现在可以将这些值存储在量子比特中。让我们创建一个Python对象，将每个项的对应值定义为上面部分中列出的值。
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, let’s see if we can find all possible winning moves that can be made.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看能否找到所有可能的获胜动作。
- en: Creating a logical expression for the win
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建获胜的逻辑表达式
- en: We’ve already defined a representation for each choice (rock 00, paper 01, scissors
    10). Since we have two players, there would be four bits per round.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为每种选择定义了一个表示（石头00，纸01，剪刀10）。由于我们有两个玩家，每轮将有四个比特。
- en: A single round of the game might appear as shown below.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一轮游戏可能如下面所示。
- en: '*Player 1 chooses Rock.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*玩家1选择石头。'
- en: Player 2 chooses Paper.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家2选择纸。
- en: Rock = 00 and Paper = 01*
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 石头 = 00 和 纸 = 01*
- en: '*The input would be 0001.*'
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*输入将是0001。*'
- en: In order to determine if this is a winning move for player one, we need to check
    some logic that dictates the rules of the game.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定这是玩家一的获胜动作，我们需要检查一些逻辑来决定游戏规则。
- en: The game rules state that rock defeats scissors, scissors defeats paper, and
    paper defeats rock.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏规则规定石头击败剪刀，剪刀击败纸，纸击败石头。
- en: We can encode these rules using Boolean logic.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用布尔逻辑来编码这些规则。
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The slow way to find all winning hands
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现所有获胜手的慢速方法
- en: Let’s begin by writing a classical computer program to find all winning hands.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编写一个经典计算机程序来找出所有获胜手。
- en: We can create a method called *check_all_games()* that loops through a list
    of all possible combinations of items and returns only those that are winning
    hands for player one.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个名为 *check_all_games()* 的方法，该方法遍历所有可能的项组合，并仅返回对玩家一有利的手牌。
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ([(0, 0, 1, 0), (0, 1, 0, 0), (1, 0, 0, 1)], 16)
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ([(0, 0, 1, 0), (0, 1, 0, 0), (1, 0, 0, 1)], 16)
- en: The method returns the list of winning hands including rock versus scissors,
    paper versus rock, and scissors versus paper. It also returns the number of iterations
    that it took to search through all combinations.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法返回包括石头对剪刀、纸对石头和剪刀对纸的获胜手牌列表。它还返回搜索所有组合所需的迭代次数。
- en: (0, 0, 1, 0) = rock (0, 0) vs. scissors (1, 0)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: (0, 0, 1, 0) = 石头 (0, 0) 对比 剪刀 (1, 0)
- en: (0, 1, 0, 0) = paper (0, 1) vs. rock (0, 0)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: (0, 1, 0, 0) = 纸 (0, 1) 对比 石头 (0, 0)
- en: (1, 0, 0, 1) = scissors (1, 0) versus paper (0, 1)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: (1, 0, 0, 1) = 剪刀 (1, 0) 对比 纸 (0, 1)
- en: Did you notice that this required **16** iterations to find all winning games?
    Not to mention, the iterations include invalid bit combinations, such as [1, 1,
    1, 1] — which do not even correspond to a valid item!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到找到所有获胜游戏需要 **16** 次迭代吗？更不用说，这些迭代包括无效的比特组合，例如 [1, 1, 1, 1] — 这些甚至不对应有效的项！
- en: Can quantum do better?
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 量子计算能做得更好吗？
- en: Let’s try this again. However, this time we’re going to create a quantum computing
    program to find all winning hands.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再试一次。不过，这次我们将创建一个量子计算程序来找到所有获胜手牌。
- en: In the same manner as the classical program, we’ll define a function *isWin()*
    that encodes the rules of the game.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以经典程序的相同方式，我们将定义一个 *isWin()* 函数，编码游戏规则。
- en: A black box quantum circuit that encodes some specific set of logical rules
    (such as the rules for winning in our game), is called an **oracle**.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一个编码了某些特定逻辑规则（例如我们游戏中的获胜规则）的黑箱量子电路称为 **oracle**。
- en: Since our oracle will work with binary values of 0 and 1, rather than variable
    names, let’s just rewrite our logical expression using these values.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的 oracle 将处理二进制值 0 和 1，而不是变量名称，让我们用这些值重写我们的逻辑表达式。
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Also, since we will be using the quantum computing library [Qiskit](https://qiskit.org/),
    we will need to represent the qubits in reverse order. Therefore, we’ll arrange
    our logic accordingly by swapping the positions of the right and left bits.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们将使用量子计算库 [Qiskit](https://qiskit.org/)，我们需要将量子比特按相反的顺序表示。因此，我们将通过交换右边和左边位的位置来调整我们的逻辑。
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first row is our result of winning hands, as returned from our classical
    program. We’re just representing each bit with a qubit (indicated as q0, q1, q2,
    q3). The qubits are arranged in reverse order so that the first two bits are player
    one, and the last two bits are player two. Each player’s qubits are arranged with
    the least-significant bit to the right and the most-significant bit to the left
    (corresponding to [q1, q0] and [q3, q2]). We repeat this for all three of the
    winning hand combinations.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是我们经典程序返回的获胜手牌结果。我们只是用量子比特（标记为 q0、q1、q2、q3）表示每个位。量子比特按相反的顺序排列，使得前两个位是玩家一，最后两个位是玩家二。每个玩家的量子比特按最不重要的位在右，最重要的位在左排列（对应于
    [q1, q0] 和 [q3, q2]）。我们对所有三种获胜手牌组合都重复这一过程。
- en: Creating an oracle
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个 oracle
- en: Let’s create the oracle for our quantum computing solution.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的量子计算解决方案创建 oracle。
- en: Just as we did with the classical program, we will encode the rules of the game
    using Boolean logic. The difference this time, however, is that we’re referring
    to q0, q1, q2, q3 to represent rock, paper, scissors.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在经典程序中做的那样，我们将使用布尔逻辑编码游戏规则。然而，这次的不同之处在于，我们引用 q0、q1、q2 和 q3 来表示石头、纸和剪刀。
- en: For example, the first type of winning hand encoded within our oracle is for
    rock versus scissors. We can encode this as shown below.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，编码在我们 oracle 中的第一种获胜手牌是石头对剪刀。我们可以如下所示地编码这一点。
- en: '***Rock versus scissors***'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '***石头对剪刀***'
- en: (0, 0, 1, 0)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: (0, 0, 1, 0)
- en: (q1 q0 q3 q2)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: (q1 q0 q3 q2)
- en: '***First winning hand condition***'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '***首次赢牌条件***'
- en: (not q0 and not q1 and not q2 and q3)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: (not q0 and not q1 and not q2 and q3)
- en: '***Reversing the qubit order***'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '***反转量子比特顺序***'
- en: (not q1 and not q0 and q3 and not q2)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: (not q1 and not q0 and q3 and not q2)
- en: '***Converting to binary***'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '***转换为二进制***'
- en: (00 versus 10)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: (00 对比 10)
- en: '***Converting to a game round***'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '***转换为游戏轮次***'
- en: (rock versus scissors)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: (石头对剪刀)
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: All winning hands are encoded in the oracle with one line of Boolean logic.
    This creates a quantum computing circuit that can be used within our program to
    find all winning hands!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 所有获胜手牌都在 oracle 中用一行布尔逻辑进行编码。这创建了一个量子计算电路，可以在我们的程序中用于找到所有获胜手牌！
- en: '![](../Images/31c68d47dd6555627bad7c59a34d90c0.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/31c68d47dd6555627bad7c59a34d90c0.png)'
- en: 'A quantum computing oracle for all winning hands in the game rock, paper, scissors.
    Source: Author.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 针对游戏石头、剪刀、布的所有获胜手牌的量子计算神谕。来源：作者。
- en: Putting this all together, we can create a quantum computing program using this
    oracle.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些内容整合在一起，我们可以使用这个神谕创建一个量子计算程序。
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, we’re playing a single round of the game with paper versus
    rock. In the resulting quantum computing program, notice that the first qubit
    (q0) is inverted using the X-Gate to a value of one, and the second qubit (q1)
    is left with a value of zero. This corresponds to (01) which represents paper.
    Similarly, qubits three and four (q2 and q3) are left as zero (00), corresponding
    to rock.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们玩的是纸对石头的单轮游戏。在得到的量子计算程序中，请注意第一个量子比特（q0）使用 X-门反转为一，而第二个量子比特（q1）保持为零。这对应于（01），表示纸。同样，第三个和第四个量子比特（q2
    和 q3）保持为零（00），对应于石头。
- en: This is a game of paper versus rock.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一场纸对石头的游戏。
- en: '![](../Images/d63466251637410d49d7aa0c78d1a945.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d63466251637410d49d7aa0c78d1a945.png)'
- en: 'A quantum computing circuit for paper versus rock, where player one selects
    paper (01), and player two selects rock (00). Source: Author.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用于纸对石头的量子计算电路，其中玩家一选择纸（01），玩家二选择石头（00）。来源：作者。
- en: The result of our quantum computing program returns an output indicating if
    this is a winning hand. Since the output of qubits are in reverse order (*remember,
    we’re reading from right to left!*), I’ve highlighted an example along with notation
    that explains each qubit value below.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的量子计算程序的结果返回了一个输出，指示这是否是一个获胜的手牌。由于量子比特的输出是反向的（*记住，我们是从右到左读取的！*），我在下面高亮了一个示例并附上了解释每个量子比特值的注释。
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Running the quantum computing program
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行量子计算程序
- en: Let’s run the program and see the result. Since paper always defeats rock, we
    would expect our program to output a value of one across all measurements of the
    quantum program.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行程序并查看结果。由于纸总是战胜石头，我们期望我们的程序在量子程序的所有测量中都输出一个值为一的结果。
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '{‘1’: 1024}'
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{‘1’: 1024}'
- en: '![](../Images/65b5e7b070005fb5556314895abfb991.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/65b5e7b070005fb5556314895abfb991.png)'
- en: 'A winning hand of rock, paper, scissors for player one. Source: Author.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家一的石头、剪刀、布获胜手牌。来源：作者。
- en: Indeed, we can see that all measurements result in a strong value of one. This
    indicates that paper versus rock is a win for player one!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，我们可以看到所有测量结果都是强值一。这表明纸对石头对玩家一是胜利的！
- en: Similarly, we can run the same oracle against a game round of paper versus scissors.
    In this round, we would expect the result to be zero, since paper is always defeated
    by scissors.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以将相同的神谕应用于纸对剪刀的游戏轮次。在这一轮中，我们预计结果为零，因为纸总是被剪刀战胜。
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '{‘0’: 1024}'
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{‘0’: 1024}'
- en: Once again, we’ve obtained a correct answer, indicating that this is a loss
    for player one.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次得到了正确的答案，表明这是玩家一的失利。
- en: '![](../Images/64d26f6de55e5f4c55a29983bca1005c.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/64d26f6de55e5f4c55a29983bca1005c.png)'
- en: 'A losing hand for player one. Source: Author.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家一的输牌。来源：作者。
- en: Well, so far, we’re only determining if a single round of the game is a win
    for player one. That’s not very impressive. After all, our classical program found
    all winning hands (*albeit it took 16 iterations to calculate this!*).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是确定单轮游戏是否对玩家一有利。这并不令人印象深刻。毕竟，我们的经典程序找到了所有获胜手牌（*尽管计算需要 16 次迭代！*）。
- en: Can we find *all* winning hands?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能找到*所有*的获胜手牌吗？
- en: The power of quantum processing
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 量子处理的力量
- en: As it turns out, since we’ve created a quantum oracle that encodes the winning
    hands of our game, we can in fact calculate all winning hands. Even better, we
    can do this in just one single CPU cycle!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，我们已经创建了一个编码了游戏获胜手牌的量子神谕，我们实际上可以计算所有的获胜手牌。更棒的是，我们可以在一个 CPU 周期内完成这个计算！
- en: Instead of hard-coding our qubits with a specific value of zero or one, which
    corresponded to a particular item choice of rock, paper, scissors for each player,
    we will place the qubits into superposition. This changes the qubits from a value
    of 0 ***or*** 1 to a value of 0 ***and*** 1 at the same time!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将量子比特置于叠加态，而不是将其硬编码为特定的零或一，这些值对应于每个玩家选择的石头、纸或剪刀项。这将量子比特的值从 0 ***或*** 1 改变为
    0 ***和*** 1 同时存在！
- en: By using superposition, we can evaluate ***all*** possible game hands in one
    single execution and only return those winning hands that satisfy the oracle Boolean
    logic.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用叠加态，我们可以在一次执行中评估 ***所有*** 可能的游戏手牌，并仅返回那些满足神谕布尔逻辑的获胜手牌。
- en: Here is an example for how this is done.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个如何实现的例子。
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice that we’ve omitted hard coding a specific item for player one and player
    two. Instead, we’re using the [Hadamard Gate](https://www.quantum-inspire.com/kbase/hadamard/)
    to place all four qubits into superposition so that they hold a value of both
    0 and 1 simultaneously.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有为玩家一和玩家二硬编码特定项目。相反，我们使用[Hadamard门](https://www.quantum-inspire.com/kbase/hadamard/)将所有四个量子比特放入超位置，以便它们同时持有0和1的值。
- en: '![](../Images/786bc869d5c6d01c2eef13e19a1fcc15.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/786bc869d5c6d01c2eef13e19a1fcc15.png)'
- en: 'Finding all possible winning hands in rock, paper, scissors by placing player
    one and two’s qubits into superposition. Source: Author.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将玩家一和玩家二的量子比特放入超位置来找到石头、剪刀、布的所有可能获胜组合。来源：作者。
- en: This results in a quantum computing circuit as shown above. If we run this program
    we should expect to see an indication of all winning hands that satisfy the oracle
    Boolean logic.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生如上所示的量子计算电路。如果我们运行这个程序，我们应该看到所有满足oracle布尔逻辑的获胜组合的指示。
- en: '![](../Images/b04a0bc460e4ec6e61198629677926c6.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b04a0bc460e4ec6e61198629677926c6.png)'
- en: 'Execution of a quantum circuit using an oracle without amplification. Source:
    Author.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用没有放大的oracle执行量子电路。来源：作者。
- en: In the results, the most significant qubit (the left-most or downward-most)
    is a value of 0 (loss) or 1 (win). So, we’re concerned with the 3 wins at the
    far right of the graph.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在结果中，最重要的量子比特（最左侧或最下方）是0（失败）或1（获胜）。所以，我们关注的是图表最右侧的3个获胜结果。
- en: However, this doesn’t appear quite right!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这似乎不太对劲！
- en: In fact, all possible combinations of qubit values appear to be completely random.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，所有可能的量子比特值组合似乎是完全随机的。
- en: Grover search to the rescue
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Grover搜索救援
- en: As it turns out, when search across a space of qubits in superposition with
    an oracle, we need to amplify the measurement results for winning hands that satisfy
    the oracle, while minimizing losing hands that do not satisfy the oracle.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，当在超位置的量子比特空间中与一个oracle进行搜索时，我们需要放大满足oracle的获胜结果，同时最小化不满足oracle的失败结果。
- en: We can do this using the [Grover search](https://en.wikipedia.org/wiki/Grover%27s_algorithm)
    quantum algorithm.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用[Grover搜索](https://en.wikipedia.org/wiki/Grover%27s_algorithm)量子算法来实现这一点。
- en: Grover’s search algorithm utilizes a diffuser and amplification process that
    allows correct results to “float” higher, while incorrect results remain low.
    It can be used for searching for a key within a database of unordered items and
    searches [quadratically](https://www.primaryobjects.com/2022/01/22/quantum-computing-hello-world/)
    faster than any classical algorithm.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Grover的搜索算法利用扩散器和放大过程，使正确的结果“漂浮”得更高，而错误的结果保持较低。它可以用于在无序项目的数据库中搜索密钥，并且比任何经典算法的搜索速度[平方级](https://www.primaryobjects.com/2022/01/22/quantum-computing-hello-world/)更快。
- en: '![](../Images/a821a4353ab666195c1994e8611f870a.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a821a4353ab666195c1994e8611f870a.png)'
- en: 'Finding all possible winning moves in rock, paper, scissors by using the Grover
    search algorithm. Source: Author.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Grover搜索算法找到石头、剪刀、布中所有可能的获胜动作。来源：作者。
- en: After running this new circuit using the Grover search algorithm, along with
    our same oracle for rock, paper, scissors, we can see the following change in
    output.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Grover搜索算法运行这个新电路后，加上我们相同的石头、剪刀、布的oracle，我们可以看到输出的变化。
- en: '![](../Images/da516e68f1240ecfb05c4f1d643ac855.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/da516e68f1240ecfb05c4f1d643ac855.png)'
- en: 'The winning hands in rock, paper and scissors. From left to right: paper (01)
    vs. rock (00), scissors (10) vs. paper (01), rock (00) vs. scissors (10). Source:
    Author.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 石头、剪刀和布中的获胜组合。从左到右：布 (01) 对 石头 (00)，剪刀 (10) 对 布 (01)，石头 (00) 对 剪刀 (10)。来源：作者。
- en: Examining the above results, we indeed have three results that are far higher
    than the rest of the combinations. In fact, these correspond directly to the winning
    moves in the game!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 检查上述结果，我们确实有三个结果远高于其余组合。实际上，这些结果直接对应于游戏中的获胜动作！
- en: If we decode each result, beginning from the left-most in the chart, and reversing
    the bits that Qiskit returned as output, we can determine the winning hands. *Recall,
    the top-most bit is the least-significant bit and corresponds to Player One.*
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们解码每一个结果，从图表最左侧开始，并反转Qiskit返回的比特，我们可以确定获胜的组合。*请记住，最上面的比特是最低有效比特，对应于玩家一。*
- en: 0001 = paper (01) vs rock (00) = *WIN*
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 0001 = 布 (01) 对 石头 (00) = *获胜*
- en: 0110 = scissors (10) vs paper (01) = *WIN*
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 0110 = 剪刀 (10) 对 布 (01) = *获胜*
- en: 1000 = rock (00) vs scissors (10) = *WIN*
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 1000 = 石头 (00) 对 剪刀 (10) = *获胜*
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The most amazing part about this is that the classical program took **16** iterations
    to find these three winning combinations. **The quantum computing program took
    just one!**
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最令人惊讶的是，经典程序需要 **16** 次迭代才能找到这三种获胜组合。**量子计算程序只需要一次！**
- en: One more bit of fun
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有一点乐趣
- en: We’ve just examined how a quantum computing program can find all winning moves
    in the game rock, paper, scissors with just a single execution on the CPU. We
    did this by placing the qubits into superposition.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚研究了量子计算程序如何通过在 CPU 上进行一次执行即可找到石头、剪刀、布游戏中的所有获胜招数。我们通过将量子位置于叠加态来实现这一点。
- en: However, by playing with which qubits are in and out of superposition, we can
    actually create different behaviors of our program.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过调整量子位的叠加状态，我们实际上可以创造出程序的不同行为。
- en: For example, suppose that we want to find the best move for player one when
    given a specific choice by player two. We can do this by setting player one’s
    qubits into superposition and leaving player two's qubits hard-coded to a specific
    value.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要找出在玩家二给定特定选择时，玩家一的最佳行动。我们可以通过将玩家一的量子位置于叠加态，而将玩家二的量子位固定为特定值来做到这一点。
- en: '![](../Images/38fd2fca173c6d6b3fd3c9253f92a218.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/38fd2fca173c6d6b3fd3c9253f92a218.png)'
- en: 'Finding a winning move for player one when player two chooses rock. Source:
    Author.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在玩家二选择石头时，为玩家一找到一个获胜的动作。来源：作者。
- en: If we now run the quantum program, instead of seeing three results with high
    measurements (corresponding to all winning hands), we should expect to see just
    one high measurement, which will correspond to the winning hand that player one
    should choose in order to defeat player two.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行量子程序，期望看到的结果是一个高测量值，这将对应于玩家一应选择的获胜手牌，以击败玩家二，而不是看到三个高测量值（对应于所有获胜手牌）。
- en: In the above scenario, we’re assigning player two the choice of rock (00). Let’s
    see what the quantum program selects as its move!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述场景中，我们为玩家二分配了石头（00）的选择。让我们看看量子程序选择的行动是什么！
- en: '![](../Images/39d62c41da5c7e4e46480e40245ae908.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/39d62c41da5c7e4e46480e40245ae908.png)'
- en: 'The winning move for player one is paper (01) when player two chooses rock
    (00). Source: Author.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家二选择石头（00）时，玩家一的制胜招数是纸（01）。来源：作者。
- en: The result indicates (0001). Reading from least to most significant bits, this
    evaluates to player one choosing paper (01) whenever player two chooses rock (00).
    Making this move is, indeed, a winning play for player one!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明（0001）。从最低位到最高位读取，这评估为玩家一在玩家二选择石头（00）时选择纸（01）。实际上，这一举动确实是玩家一的制胜招数！
- en: '*Paper defeats rock!*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*纸胜石头！*'
- en: You can download the complete code example for the rock, paper, scissors program
    [here](https://gist.github.com/primaryobjects/f58e5528e3b183b6bfcb8d7a9dc34934).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [这里](https://gist.github.com/primaryobjects/f58e5528e3b183b6bfcb8d7a9dc34934)
    下载完整的石头、剪刀、布程序代码示例。
- en: It’s your turn
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轮到你了
- en: Now that we’ve completed a quantum computing program to find all winning moves
    in the game Rock, Paper, Scissors, let’s think for a moment what we’ve achieved.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了一个量子计算程序来找到石头、剪刀、布游戏中的所有获胜招数，让我们思考一下我们所取得的成就。
- en: A classical program took 16 iterations to find all winning hands. By contrast,
    a quantum version using Grover’s search executed in just 1 single iteration. This
    is just one of the fantastic differences between how classical and quantum computers
    work.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经典程序需要16次迭代才能找到所有获胜的手牌。相比之下，使用 Grover 搜索的量子版本只需 1 次迭代。这只是经典计算机和量子计算机工作方式之间的一个惊人差异。
- en: Grover’s search can be applied to many different searchability problems, including
    algorithms, file systems, and databases, just to name a few. Additionally, since
    the field of quantum computing is still so young, you have the real opportunity
    to make an impact.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Grover 搜索可以应用于许多不同的可搜索性问题，包括算法、文件系统和数据库，仅举几例。此外，由于量子计算领域仍然如此年轻，你有真正的机会产生影响。
- en: I hope that your excitement is piqued into learning more about this amazing
    technology. Now it’s your turn!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你对学习更多关于这项惊人技术的兴趣被激发。现在轮到你了！
- en: About the Author
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于作者
- en: If you’ve enjoyed this article, please consider following me on [Medium](https://medium.com/@KoryBecker),
    [Twitter](https://twitter.com/PrimaryObjects), and my [web site](https://primaryobjects.com/)
    to be notified of my future posts and research work.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢这篇文章，请考虑在 [Medium](https://medium.com/@KoryBecker)、[Twitter](https://twitter.com/PrimaryObjects)
    和我的 [网站](https://primaryobjects.com/) 上关注我，以便接收我未来的帖子和研究工作通知。
