- en: Quantum Computing for Complete Beginners
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 量子计算完全初学者指南
- en: 原文：[https://towardsdatascience.com/quantum-computing-for-complete-beginners-63b989ded053?source=collection_archive---------1-----------------------#2023-10-20](https://towardsdatascience.com/quantum-computing-for-complete-beginners-63b989ded053?source=collection_archive---------1-----------------------#2023-10-20)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/quantum-computing-for-complete-beginners-63b989ded053?source=collection_archive---------1-----------------------#2023-10-20](https://towardsdatascience.com/quantum-computing-for-complete-beginners-63b989ded053?source=collection_archive---------1-----------------------#2023-10-20)
- en: '*A guide to the basics of quantum computing with no prior knowledge required*'
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*量子计算基础指南，无需先前知识*'
- en: '[](https://angjelinhila.medium.com/?source=post_page-----63b989ded053--------------------------------)[![Angjelin
    Hila](../Images/44d826eda81d6fb95ec9c65a1da5933d.png)](https://angjelinhila.medium.com/?source=post_page-----63b989ded053--------------------------------)[](https://towardsdatascience.com/?source=post_page-----63b989ded053--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----63b989ded053--------------------------------)
    [Angjelin Hila](https://angjelinhila.medium.com/?source=post_page-----63b989ded053--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://angjelinhila.medium.com/?source=post_page-----63b989ded053--------------------------------)[![Angjelin
    Hila](../Images/44d826eda81d6fb95ec9c65a1da5933d.png)](https://angjelinhila.medium.com/?source=post_page-----63b989ded053--------------------------------)[](https://towardsdatascience.com/?source=post_page-----63b989ded053--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----63b989ded053--------------------------------)
    [Angjelin Hila](https://angjelinhila.medium.com/?source=post_page-----63b989ded053--------------------------------)'
- en: ·
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fcb73222d75bc&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fquantum-computing-for-complete-beginners-63b989ded053&user=Angjelin+Hila&userId=cb73222d75bc&source=post_page-cb73222d75bc----63b989ded053---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----63b989ded053--------------------------------)
    ·25 min read·Oct 20, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F63b989ded053&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fquantum-computing-for-complete-beginners-63b989ded053&user=Angjelin+Hila&userId=cb73222d75bc&source=-----63b989ded053---------------------clap_footer-----------)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[关注](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fcb73222d75bc&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fquantum-computing-for-complete-beginners-63b989ded053&user=Angjelin+Hila&userId=cb73222d75bc&source=post_page-cb73222d75bc----63b989ded053---------------------post_header-----------)
    发表在 [Towards Data Science](https://towardsdatascience.com/?source=post_page-----63b989ded053--------------------------------)
    · 25 分钟阅读 · 2023年10月20日'
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F63b989ded053&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fquantum-computing-for-complete-beginners-63b989ded053&source=-----63b989ded053---------------------bookmark_footer-----------)![](../Images/a8494d01986d3b1e1a88bf3f0d9193c8.png)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F63b989ded053&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fquantum-computing-for-complete-beginners-63b989ded053&source=-----63b989ded053---------------------bookmark_footer-----------)![](../Images/a8494d01986d3b1e1a88bf3f0d9193c8.png)'
- en: 'An IBM Quantum cryostat used to keep IBM’s 50-qubit quantum computer cold in
    the IBM Quantum lab in Yorktown Heights, New York. source: [https://www.flickr.com/photos/ibm_research_zurich/40786969122](https://www.flickr.com/photos/ibm_research_zurich/40786969122)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一台 IBM 量子冷却器用于在纽约约克镇的 IBM 量子实验室中保持 IBM 的 50-qubit 量子计算机的低温。来源：[https://www.flickr.com/photos/ibm_research_zurich/40786969122](https://www.flickr.com/photos/ibm_research_zurich/40786969122)
- en: Some have described the last several millennia of human dominion over the earth’s
    resources as the *anthropocene*, deriving from the Greek “anthropo” meaning human,
    and “cene” meaning recent. The last century in particular has been dubbed the
    [fourth industrial revolution](https://www.weforum.org/focus/fourth-industrial-revolution),
    due to the pace of technological innovation ushered in by the advent of computers
    in the middle of the 20th century.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一些人将人类对地球资源的统治称为*人类世*，这个词源自希腊语中的“anthropo”（人类）和“cene”（最近）。特别是过去一个世纪，由于20世纪中期计算机的出现带来了技术创新的速度，已被称为[第四次工业革命](https://www.weforum.org/focus/fourth-industrial-revolution)。
- en: In the past seventy years, computation has transformed every aspect of society,
    enabling efficient production at an accelerated rate, displacing human labour
    from chiefly production to services, and exponentially augmenting information
    storage, generation, and transmission through telecommunications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去七十年里，计算已经改变了社会的各个方面，能够以加速的速度进行高效生产，将人类劳动从主要的生产领域转移到服务领域，并通过电信技术指数级提升了信息存储、生成和传输。
- en: How did we get here? Fundamentally, technological advancement draws on existing
    science. Without an understanding of the nature of electromagnetism and the structure
    of atoms, we wouldn’t have electricity and the integrated circuitry that power
    computers. It was only a matter of time, then, before we thought of exploiting
    the most accurate, fundamental description of physical reality provided by [quantum
    mechanics](https://en.wikipedia.org/wiki/Quantum_mechanics) for computation.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是如何到达这里的？从根本上说，技术进步依赖于现有的科学。如果没有对电磁学的性质和原子结构的理解，我们就不会有电力和驱动计算机的集成电路。因此，我们迟早会想到利用[量子力学](https://en.wikipedia.org/wiki/Quantum_mechanics)提供的物理现实的最准确、最基本的描述来进行计算。
- en: I became interested in quantum computation through both a strong interest in
    physics and the nature of computation. If successful, quantum computation could
    usher in an unprecedented chapter in our information age by exponentially augmenting
    the efficiency of current computers. As someone interested in data, computation,
    and information science, understanding the rudiments of quantum information will
    not only equip you with a very basic understanding of quantum physics but also
    prepare you for the next major technological frontier of our information age.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我对量子计算产生了兴趣，这源于对物理学和计算本质的强烈兴趣。如果成功，量子计算可能会通过指数级提升当前计算机的效率，开启信息时代前所未有的一章。作为一个对数据、计算和信息科学感兴趣的人，理解量子信息的基本知识不仅会使你对量子物理有一个非常基础的理解，还会为你准备迎接信息时代下一个主要技术前沿做好准备。
- en: Quantum Phenomena & Quantum Information
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 量子现象与量子信息
- en: In order to understand the basics of computing, it is necessary to have a basic
    understanding of the physical phenomena that quantum computing exploits.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解计算的基本概念，有必要对量子计算所利用的物理现象有一个基本的了解。
- en: The phenomena in question are ***electron* *spin***and ***light polarization***,
    the latter being another term for *photon spin*. Recall that electrons are negatively
    charged subatomic particles that surround a positively charged nucleus, whereas
    photons are the particle equivalents of electromagnetism or light. Electron and
    photon spin are connected since they both refer to quantum properties that have
    no analogue in classical mechanics, which describes the scale of everyday objects.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些现象包括***电子自旋***和***光偏振***，后者是*光子自旋*的另一种说法。请记住，电子是带负电的亚原子粒子，围绕带正电的原子核旋转，而光子则是电磁或光的粒子等价物。电子和光子的自旋是相关的，因为它们都指的是在经典力学中没有类比的量子属性，经典力学描述的是日常物体的尺度。
- en: Nonetheless, the easiest way to introduce spin is to draw a comparison to a
    classical property called angular momentum. Angular momentum refers to the rotational
    equivalent of linear momentum in a classical system, where momentum is calculated
    as the product of mass and velocity. As such, momentum is a vector quantity since
    it possesses both magnitude and direction. Angular momentum is represented as
    the cross product of the position and momentum vectors of a particle. Since angular
    momentum is a classical property, it admits of continuous values and can be expressed
    as a volume integral (generalized from the integral as the area under the curve
    in two dimensions).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，引入自旋最简单的方法是与经典属性角动量进行比较。角动量指的是经典系统中线动量的旋转等效量，其中动量被计算为质量和速度的乘积。因此，动量是一个向量量，因为它具有大小和方向。角动量表示为粒子的位矢和动量矢量的叉积。由于角动量是经典属性，它接受连续值，并且可以表示为体积分（从二维中的曲线下的面积推广而来）。
- en: Spin is often defined as *intrinsic angular momentum.* Recall that in classical
    mechanics force is defined as change in momentum. Furthermore the energy of the
    system is defined in terms of motion or the rate of change of motion, which presupposes
    mass. Unlike classical mechanics, Einstein’s special theory of relativity ascribes
    intrinsic energy to rest mass through the equality E = mc². Similarly, intrinsic
    angular momentum is intimately bound up with the intrinsic energy state of a subatomic
    particle. In fact, it is a property that elementary particles possess whether
    or not they are actually rotating, that is, regardless of extrinsic factors like
    momentum and position, hence the qualifier *intrinsic*. Like classical angular
    momentum, quantum spin changes under rotations. However, unlike classical angular
    momentum, spin is quantized, which means that it only admits a discrete set of
    values.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 自旋通常定义为*内在角动量*。回忆一下，在经典力学中，力被定义为动量的变化。此外，系统的能量是以运动或运动变化率来定义的，这假设了质量。与经典力学不同，爱因斯坦的相对论通过等式E
    = mc²将内在能量归于静止质量。同样，内在角动量与亚原子粒子的内在能量状态密切相关。事实上，这是一个基本粒子所具备的属性，无论它们是否实际旋转，即不考虑诸如动量和位置等外在因素，因此称为*内在*。像经典角动量一样，量子自旋在旋转下会发生变化。然而，与经典角动量不同，自旋是量子化的，这意味着它只接受一组离散的值。
- en: 'The maximum spin of an elementary particle is given by the product of n (any
    integer of half integer n/2 values) and the reduced Planck’s constant ℏ (h/2𝜋)
    . All ordinary particles, called fermions, have half-integer (1/2) spin, whereas
    force-carrier particles, known as bosons, like the photon have integer (1) spin.
    Both electrons and photons have two possible spin states: spin “up” or “down”.
    In mathematical terms, electrons will have a maximum spin of 1/2ℏ or -1/2ℏ, namely
    spin in the positive or negative “rotations”. The photon will have maximum spin
    of 1ℏ and -1ℏ, since it takes integer spin values. Even though we’re using the
    word “rotation”, it is best not think of it in terms of spatial transformations.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 基本粒子的最大自旋由n（任何半整数n/2值）与约化普朗克常数ℏ（h/2𝜋）的乘积给出。所有普通粒子，称为费米子，都具有半整数（1/2）自旋，而力载体粒子，如光子，具有整数（1）自旋。电子和光子都有两种可能的自旋状态：自旋“向上”或“向下”。用数学术语来说，电子的最大自旋为1/2ℏ或-1/2ℏ，即正向或负向的“旋转”。光子的最大自旋为1ℏ和-1ℏ，因为它取整数自旋值。尽管我们使用了“旋转”一词，但最好不要将其视为空间变换。
- en: 'Now let’s look at the strange quantum properties that will be exploited for
    quantum computation. We noted earlier that the electron can have two possible
    spin states, but which state is it in at any given moment? This is where it is
    useful to draw a distinction between the *state* of the system and *measurement*.
    In classical mechanics, state and measurement coincide perfectly: the state of
    the system is what you measure. Not in quantum mechanics. The state of the system
    without measurement is given by a coherent superposition of wave functions 𝛹i
    . After measurement, the state of the system will be given by either 𝛹↓ or 𝛹↑,
    if we’re measuring a single particle. This disjunction between state and measurement
    enables quantum computers to carry out operations that can take infinite values
    in two dimensional complex vector spaces.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下将被利用于量子计算的奇异量子性质。我们之前提到电子可以有两种可能的自旋状态，但它在任何给定时刻处于哪个状态呢？在这里区分系统的*状态*和*测量*是很有用的。在经典力学中，状态和测量完全一致：系统的状态就是你所测量的。在量子力学中却不是如此。没有测量的情况下，系统的状态由波函数𝛹i
    的相干叠加给出。测量之后，如果我们测量一个单粒子，系统的状态将由𝛹↓或𝛹↑给出。这种状态和测量之间的分离使得量子计算机能够进行在二维复数向量空间中可以取无限值的操作。
- en: 'Finally, measurements obey certain rules relative to the way the measurement
    is carried out. Specifically, the direction of measurement matters for the outcome.
    Let’s say we have two directions: vertical and horizontal. If we measure the spin
    of an electron in the vertical direction, we will get a state of spin up or down.
    If we carry out the exact same measurement, that is, measure spin again in the
    vertical direction, we will get the same outcome. This shows that there’s an experimental
    setup that yields predictable outcomes. However, if we first measure the spin
    of the electron in the vertical direction and subsequently in the horizontal and
    keep repeating the measurement, the outcomes will be a random sequence of spin
    up or down that distribute uniformly between the two with enough trials. This
    means that if we’re not careful, quantum measurements can produce random outcomes.
    The purpose of quantum algorithms will be to control the operations so that we
    get the outcomes we desire.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，测量遵循某些规则，这些规则与测量的方式有关。具体来说，测量的方向对结果很重要。假设我们有两个方向：垂直和水平。如果我们在垂直方向上测量电子的自旋，我们将得到自旋向上或向下的状态。如果我们进行完全相同的测量，即再次在垂直方向上测量自旋，我们将得到相同的结果。这表明存在一种实验设置可以产生可预测的结果。然而，如果我们首先在垂直方向上测量电子的自旋，然后在水平方向上测量，并不断重复测量，结果将是自旋向上或向下的随机序列，在足够的试验中均匀分布。这意味着，如果我们不小心，量子测量可能会产生随机结果。量子算法的目的是控制操作，以便我们得到所期望的结果。
- en: Even though ***qubits***, the informational units of quantum computing, can
    be represented either by electron or photon spin, we will use the former as the
    physical analogue of quantum computation going forward.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管***量子比特***（qubits），即量子计算的信息单位，可以通过电子或光子的自旋来表示，但我们将使用前者作为量子计算的物理类比。
- en: From Quantum Phenomena to Quantum Computation
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从量子现象到量子计算
- en: The fundamental informational unit of a classical computer is a called a bit,
    which has two discrete states often represented as 0 or 1\. Since the computer
    is a physical machine, this mathematical abstraction must be mapped to some physical
    phenomenon. Classical computers map these discrete states on a flowing current
    or voltage. When the voltage is low or close to none, we use it to represent state
    0 and when the voltage is higher, we use it to represent 1\. In other words, modulations
    of voltage magnitudes allow us to mechanistically realize a binary system of representation.
    Sequences of these low-voltage and high-voltage states are subsequently arranged
    into electrical circuits that simulate logical operations like AND, XOR etc called
    logic gates. Combinations of logical operations through electrical circuitry are
    subsequently scaffolded to execute any computable algorithm.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 经典计算机的基本信息单位称为比特（bit），它具有两个离散状态，通常表示为0或1。由于计算机是一个物理机器，这种数学抽象必须映射到某种物理现象上。经典计算机将这些离散状态映射到流动的电流或电压上。当电压较低或几乎为零时，我们用它来表示状态0，当电压较高时，我们用它来表示状态1。换句话说，电压幅度的调制使我们能够机械地实现一个二进制表示系统。这些低电压和高电压状态的序列随后被排列成模拟逻辑操作的电路，如与门（AND）、异或门（XOR）等，称为逻辑门。通过电路的逻辑操作组合随后被搭建以执行任何可计算的算法。
- en: Now that we see that classical computers leverage electricity to realize computations,
    it helps us to understand how a quantum computer might operate. Unlike a classical
    computer, a quantum computer leverages quantum or subatomic scale phenomena to
    carry out computations. While voltage in our everyday macro scale is measured
    as a continuous variable, quantum mechanics tells us that at the subatomic scale
    this is not really the case. Rather, by all experimental accounts, subatomic particles
    appear to occupy only discrete energy states. This means that an electron and
    a photon can occupy some energy states, and not others. This contravenes our intuitions
    about physical objects being able to occupy any continuous energy state. For example,
    while we typically think of time as a purely continuous variable that’s infinitely
    divisible, this is starkly not the case for the energy states of subatomic particles.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到经典计算机利用电力来实现计算，这有助于我们理解量子计算机的工作方式。与经典计算机不同，量子计算机利用量子或亚原子尺度现象来进行计算。虽然我们在日常宏观尺度上测量电压时它是一个连续变量，但量子力学告诉我们，在亚原子尺度下情况并非如此。相反，根据所有实验数据，亚原子粒子似乎仅占据离散的能量状态。这意味着电子和光子可以占据某些能量状态，而不能占据其他状态。这与我们对物理对象能够占据任何连续能量状态的直觉相矛盾。例如，尽管我们通常认为时间是一个完全连续的变量，且可以无限分割，但对于亚原子粒子的能量状态，这种情况完全不同。
- en: 'This has the peculiar consequence that subatomic particles cannot be described
    as having fixed positions and momenta. While we can try to describe these variables
    simultaneously, there’s a physical scale in which the precision breaks down such
    that knowing the momentum means losing track of the position and vice versa. That
    physical scale is the called the Planck scale denoted by ***h***: 6.626070· 10⁻³⁴
    m²kg/s and represents the physical threshold between classical and quantum scale
    phenomena. At this scale, again by all experimental evidence, subatomic particles
    occupy all their possible states simultaneously. Because of this property, we
    can only describe subatomic particles as probability distributions of all their
    possible states as described by Schrödinger’s equation. As we pointed out earlier
    however, there’s a second description called a measurement. Prior to measurement,
    the particle exists in a state of superposition as described by Schrödinger’s
    wave function. After measurement, the particle collapses to a discrete state of
    one position or another. Quantum computing leverages this peculiar property of
    quantum mechanics to perform computations, that is, by taking advantage of both
    *superposition* and *measurement* states. (If you want to get clear on the experimental
    basis of the objectivity of the superposition read [*this*](https://en.wikipedia.org/wiki/Bell_test)).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个独特的结果，那就是亚原子粒子不能被描述为具有固定的位置和动量。虽然我们可以尝试同时描述这些变量，但存在一个物理尺度，在这个尺度下，精度会崩溃，使得知道动量就意味着失去位置的信息，反之亦然。这个物理尺度被称为普朗克尺度，用***h***表示：6.626070·10⁻³⁴
    m²kg/s，代表了经典与量子尺度现象之间的物理阈值。在这个尺度下，根据所有实验证据，亚原子粒子同时占据所有可能的状态。由于这一特性，我们只能将亚原子粒子描述为所有可能状态的概率分布，如**薛定谔方程**所述。然而，正如我们之前指出的，还有一种称为测量的第二种描述。在测量之前，粒子存在于**薛定谔波函数**描述的叠加态中。测量之后，粒子会坍缩到一个确定的位置状态。量子计算利用了量子力学这一奇特特性来进行计算，即利用*叠加*和*测量*状态。（如果你想弄清楚叠加态客观性的实验基础，可以阅读[*这篇文章*](https://en.wikipedia.org/wiki/Bell_test)）。
- en: So if a classical computer builds computations from two possible discrete states,
    we can think of a quantum computer as building computations from discrete states
    as well as superpositions. A qubit can be in state 0 or 1 when we measure it.
    However, prior to measurement, the qubit is in a superposition of 0 and 1\. During
    superposition, the qubit can occupy an infinite number of states. By leveraging
    the laws of quantum mechanics, quantum computation surpasses the computational
    capacities of classical computation whose state space is confined to 2^n. To be
    sure, measurement reduces quantum states to classical states, namely, the same
    state space of 2^n. In what way then does quantum computing confer advantages
    that elude classical computing?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果经典计算机通过两个可能的离散状态来构建计算，我们可以认为量子计算机则通过离散状态以及叠加态来构建计算。当我们测量量子比特时，它可以处于状态0或1。然而，在测量之前，量子比特处于0和1的叠加态。在叠加态期间，量子比特可以占据无限多个状态。通过利用量子力学的法则，量子计算超越了经典计算的计算能力，经典计算的状态空间局限于2^n。值得注意的是，测量将量子状态简化为经典状态，即相同的状态空间2^n。那么，量子计算以什么方式提供了经典计算无法比拟的优势呢？
- en: As we will see below, quantum algorithms enable controlled operations in the
    state of superposition that allow us to get useful answers after measurement.
    Computer scientists define the complexity of an algorithm with respect to the
    time steps required to solve it. If *n* denotes the input length of the algorithm
    and *T(n)* the time to solve it, then complexity refers to the function that describes
    the growth of *T(n)*. If *T(n)* amounts to a polynomial, then the algorithm is
    said to belong to a polynomial-time class problem. If *T(n)* amounts to an exponential
    function, then it belongs to an exponential-time class problem. Those that belong
    to exponential time, like the prime factorization of large numbers, are intractable
    for classical computers since the time required to solve the problem increases
    exponentially and can easily exceed human-scale time constraints.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们下面将看到的，量子算法使得在叠加态下进行受控操作成为可能，这使我们在测量后能够得到有用的答案。计算机科学家根据解决算法所需的时间步骤来定义算法的复杂性。如果*n*表示算法的输入长度，*T(n)*表示解决它所需的时间，那么复杂性指的是描述*T(n)*增长的函数。如果*T(n)*是多项式，则该算法被称为属于多项式时间类问题。如果*T(n)*是指数函数，则它属于指数时间类问题。那些属于指数时间的，例如大数的质因数分解，对于经典计算机来说是难以处理的，因为解决问题所需的时间呈指数级增长，并且很容易超出人类可接受的时间限制。
- en: The promise of quantum computing lies partly in being able to solve exponential-time
    problems sufficiently quickly.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 量子计算的前景部分在于能够足够快地解决指数时间问题。
- en: 'Representing Qubits: Linear Algebra'
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表示量子比特：线性代数
- en: In order to understand quantum computing, we have to understand some of the
    math underlying the representation of qubits. The mathematical tools need to correspond
    to the underlying phenomena upon which we will map computation, primarily linear
    algebra.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解量子计算，我们必须了解表示量子比特（qubits）的一些数学基础。这些数学工具需要与我们将要映射计算的基本现象相对应，主要是线性代数。
- en: '*We represent Qubits with two-dimensional unit vectors.*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们用二维单位向量来表示量子比特（Qubits）。*'
- en: '***What is a vector?***'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '***什么是向量？***'
- en: 'A vector is a quantity that is expressed by at least two values: a magnitude
    and a direction. A vector’s magnitude is given by the Euclidean distance, whereas
    the direction is given by the starting point. (1,-3) for example represents a
    two dimensional vector, with a length of 3.162 and a direction given by the x
    value.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 向量是由至少两个值表示的量：大小和方向。向量的大小由欧几里得距离给出，而方向由起点给出。例如（1，-3）表示一个二维向量，其长度为3.162，方向由x值给出。
- en: '***What is a unit vector?***'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '***什么是单位向量？***'
- en: A unit vector is a vector with length or magnitude equal to 1\. For example
    <0,1> is a unit vector because if we calculate the Euclidean distance using the
    Pythagorean Theorem we get the value 1.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 单位向量是长度或大小等于1的向量。例如，<0,1>是一个单位向量，因为如果我们使用毕达哥拉斯定理计算欧几里得距离，我们得到的值是1。
- en: '***Why two-dimensional unit vectors?***'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '***为什么是二维单位向量？***'
- en: 'Since there are two possible electron spin measurement outcomes, a two dimensional
    vector space denoted by ℝ² will do. We use unit vectors because we want to limit
    measurement outcomes to two possible values: 0 or 1\. As we will see, the operations
    we will perform on qubits will amount to rotations on a unitary plane. However,
    the space of possible outcomes should include all possible rotations on a three
    dimensional sphere whose underlying space is still two dimensional, denoting the
    two possible measurement outcomes. To do this we represent vectors as complex
    numbers rather than as real numbers, denoted by the complex vector space ℂ². (Complex
    numbers are any operations involving real numbers and imaginary numbers, where
    an imaginary number *i* is equal to √-1) For simplicity’s sake, we will for now
    stick to ℝ² and eschew complex numbers.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在两种可能的电子自旋测量结果，二维向量空间 ℝ² 足够。我们使用单位向量是因为我们希望将测量结果限制为两个可能的值：0 或 1。正如我们将看到的，我们对量子比特进行的操作将等同于在单位平面上的旋转。然而，可能的结果空间应该包括所有可能的三维球面旋转，其底层空间仍然是二维的，表示两个可能的测量结果。为此，我们将向量表示为复数，而不是实数，表示为复向量空间
    ℂ²。（复数是涉及实数和虚数的运算，其中虚数 *i* 等于 √-1）为了简便起见，我们现在将坚持使用 ℝ²，暂时避开复数。
- en: In order to limit outcomes to two possible values, we need more than just unit
    vectors. We need pairs of unit vectors to be *orthogonal* to each other. Two vectors
    are orthogonal to each other if and only if their ***inner or dot product*** equals
    to zero. When combinations of unit vectors are orthogonal to each other, we call
    those **orthonormal bases**, combining the word normal that stands for unit vectors
    and orthogonal.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将结果限制为两个可能的值，我们不仅需要单位向量。我们需要一对对正交的单位向量。两个向量相互正交当且仅当它们的 ***内积或点积*** 等于零。当单位向量的组合彼此正交时，我们称这些为
    **正交规范基**，结合了表示单位向量的 "normal" 和表示正交的 "orthogonal"。
- en: '**Orthogonality**: Two vectors are orthogonal if and only if their product
    equals zero : <a|b> = 0.'
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**正交性**：两个向量是正交的，当且仅当它们的乘积等于零：<a|b> = 0。'
- en: We can check that any n-dimension ket is an orthonormal basis if the product
    of the matrix A and its transposal A^T equals an **identity matrix** In.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查任意 n 维 ket 是否为正交规范基，如果矩阵 A 和其转置 A^T 的乘积等于 **单位矩阵** In。
- en: '**Bracket Notation**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**括号符号**'
- en: Before we describe these bases, let’s say a few words about the standard notation
    used in linear algebra so that you you’re able to interpret symbols appropriately.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述这些基之前，我们先说几句关于在线性代数中使用的标准符号的内容，以便你能适当地解释符号。
- en: '*Column vectors* are called **bras,** whereas *row vectors* are called **kets**
    denoted as follows: <a| & |b>, where:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*列向量* 被称为 **bras**，而 *行向量* 被称为 **kets**，表示为：<a| & |b>，其中：'
- en: '![](../Images/d98f9f4fdf10b3774ba7e471aeaf815e.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d98f9f4fdf10b3774ba7e471aeaf815e.png)'
- en: bras are row vectors, where as kets are column vectors.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**bras** 是行向量，而 **kets** 是列向量。'
- en: Together, they form *bra-kets*. From the dot product rule (i.e. vector multiplication),
    we can only multiply bras with kets provided that each have equal dimensionality.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 它们一起形成 *bra-kets*。根据点积规则（即向量乘法），我们只能在每个维度相等的情况下将 bras 与 kets 相乘。
- en: 'The inner product of the bra-ket above is represented by **<a|b>** and denotes:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 bra-ket 的内积表示为 **<a|b>**，并表示：
- en: '![](../Images/7e9e55a7f231c87ce60a2ecf56c29871.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7e9e55a7f231c87ce60a2ecf56c29871.png)'
- en: dot product of two unit vectors.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 两个单位向量的点积。
- en: However, vectors of the same type (bra or ket) of the same dimension can be
    summed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，相同维度的相同类型（bra 或 ket）的向量可以相加。
- en: Instead of using actual values, we can use arrows to represent the types of
    orthonormal pairs relevant for electron spin measurement.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用箭头来表示与电子自旋测量相关的正交规范对，而不是使用实际值。
- en: 'There are three orthonormal bases for spin:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 自旋有三种正交规范基：
- en: '![](../Images/4e983c9b799f48d0f7c23e1222006fde.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4e983c9b799f48d0f7c23e1222006fde.png)'
- en: Three two dimensional orthonormal bases used to measure spin (Berhardt, 2019).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 用于测量自旋的三种二维正交规范基（Berhardt, 2019）。
- en: 'When we multiply bras and kets of the same spin, we yield a value of 1:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们乘以具有相同自旋的 bras 和 kets 时，结果为 1：
- en: '![](../Images/b691aa2aa9c47b97773a7bc16215b644.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b691aa2aa9c47b97773a7bc16215b644.png)'
- en: Equal orthonormal bra-kets have a dot product of 1.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 相等的正交规范 bra-kets 的点积为 1。
- en: 'Conversely, when we multiply bras and kets of opposite spins, we yield a value
    of 0:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，当我们乘以具有相反自旋的 bras 和 kets 时，结果为 0：
- en: '![](../Images/9b0844c8c4c010a49f15314c731231ab.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9b0844c8c4c010a49f15314c731231ab.png)'
- en: Opposite orthonormal bra-kets have a dot product of 0.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 相对的正交 bra-kets 的点积为 0。
- en: As you can see, **orthonormal bracket products** give us measurements that simulate
    binary outcomes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，**正交括号积**给出模拟二进制结果的测量值。
- en: The first basis, represented by the up and down arrows, is called the **standard
    basis** and corresponds to vertical measurement of spin, that is, measurement
    along the y-axis. The second basis, represented by the right and left arrows corresponds
    to the horizontal measurement of spin, namely measurement along the x-axis. Generally,
    ordered orthonormal bases represent the measurement of spin along a certain direction.
    In fact we can measure spin at any angle or direction 𝛳 and the output will collapse
    to a discrete outcome of spin up or down in that direction, since spin states
    can only be discrete.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个基，由上下箭头表示，称为**标准基**，对应于自旋的垂直测量，即沿 y 轴的测量。第二个基，由左右箭头表示，对应于自旋的水平测量，即沿 x 轴的测量。通常，排序的正交基代表沿某个方向的自旋测量。实际上，我们可以在任何角度或方向𝛳上测量自旋，结果会坍缩为该方向上自旋向上或向下的离散结果，因为自旋状态只能是离散的。
- en: '*A quantum state* of a single or multiple qubits will be given by a linear
    combination of these bases. The basis vectors, therefore, will represent the possible
    outcomes of a quantum state. As we said earlier, the state of a qubit can be modelled
    on the spin of an electron or photon. Prior to measurement, the particle or the
    quantum state will be in superposition, represented by a linear combination of
    the bases |b1> and |b2> that takes the form of **c1|b1> + c2|b2> ,** where c1
    and c2 represent probability amplitudes. Because the probability amplitudes can
    be negative, only their squared values are used to represent the probabilities
    of the outcomes where c1² + c2² = 1\. In a superposition, therefore, c1² and c2²
    will each have a probability of 0.5.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*单个或多个量子位的量子态* 将由这些基的线性组合给出。因此，基向量将代表量子态的可能结果。如前所述，量子位的状态可以通过电子或光子的自旋进行建模。在测量之前，粒子或量子态将处于叠加态，由基
    |b1> 和 |b2> 的线性组合表示，形式为 **c1|b1> + c2|b2>**，其中 c1 和 c2 代表概率振幅。由于概率振幅可以为负值，仅使用它们的平方值来表示结果的概率，其中
    c1² + c2² = 1。在叠加态中，因此 c1² 和 c2² 各自将具有 0.5 的概率。'
- en: After measurement, the spin state collapses to one of the orthonormal bases
    |b1> or |b2>. The probability of collapsing to |b1> is given by c1², while the
    probability of collapsing to |b2> is given by c2². If the measurement collapses
    to |b1>, c1² will equal 1 and c2² 0 and vice versa. To put it even more bluntly,
    the basis vector multiplied with probability value 1 will represent the outcome
    of the measurement.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 测量后，自旋状态坍缩为正交基 |b1> 或 |b2> 之一。坍缩到 |b1> 的概率由 c1² 给出，而坍缩到 |b2> 的概率由 c2² 给出。如果测量坍缩到
    |b1>，则 c1² 将等于 1，c2² 为 0，反之亦然。更直接地说，与概率值 1 乘积的基向量将代表测量的结果。
- en: 'In classical computing, multiple bits are represented by the tensor product
    of those bits, denoted by the following symbol: ⊗'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典计算中，多位通过这些位的张量积表示，记作符号：⊗
- en: 'We said that [1,0] and [0,1] kets represent the standard bases, and therefore
    constitute analogues of 0 and 1 respectively in classical bits. We also said that
    any quantum state must conserve the following equality: **c1² + c2² = 1**. We
    called it the unit measure constraint ([*the second axiom of probability theory*)](https://en.wikipedia.org/wiki/Probability_axioms#Second_axiom),
    which means that all kets must be unit vectors in ℝ². However, since actual quantum
    particle states are represented via complex numbers, the actual state space is
    given by ℂ². Therefore, the actual unit measure constraint is given by: ‖𝛼‖² +
    ‖β‖² = 1, where 𝛼 and β are complex numbers and represent probability amplitudes.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说过，[1,0] 和 [0,1] kets 代表标准基，因此分别对应经典位中的 0 和 1。我们还提到任何量子态必须满足以下等式：**c1² + c2²
    = 1**。我们称其为单位测量约束（[*概率论的第二公理*](https://en.wikipedia.org/wiki/Probability_axioms#Second_axiom)），这意味着所有
    kets 必须是 ℝ² 中的单位向量。然而，由于实际的量子粒子状态是通过复数表示的，因此实际的状态空间由 ℂ² 给出。因此，实际的单位测量约束为：‖𝛼‖²
    + ‖β‖² = 1，其中 𝛼 和 β 是复数，代表概率振幅。
- en: To represent multiple qubit states we therefore take the tensor product of our
    standard bases |0> and |1>. Notice that the product will conserve the unit measure
    constraint, regardless of how many qubits we concatenate.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了表示多个量子位状态，我们取标准基 |0> 和 |1> 的张量积。注意，无论我们串联多少量子位，乘积都会保持单位测量约束。
- en: '![](../Images/92a41c3d853bdbb941f821b2f5fe1796.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/92a41c3d853bdbb941f821b2f5fe1796.png)'
- en: Tensor product of two 1 qubits yields the above vector.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 两个1量子比特的张量积产生上述向量。
- en: '![](../Images/05b6461f7a9e5a517954eceed1bb6525.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05b6461f7a9e5a517954eceed1bb6525.png)'
- en: Tensor product of two 0 qubits yields the above vector.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 两个0量子比特的张量积产生上述向量。
- en: Since we’ve been working in ℝ², we can heuristically represent the state space
    of a qubit in two dimensions (x,y) via a unit circle. Remember that all operations
    will be on the orthonormal bases we enumerated above. Furthermore, all quantum
    logic gates will be represented by unitary and thereby orthogonal matrices. Why?
    Because vector multiplication by an orthogonal matrices produces *rotations* by
    preserving the inner product of vectors. This produces isometric transformations
    on a Euclidean space.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们一直在ℝ²中工作，我们可以直观地通过单位圆表示一个量子比特的状态空间在二维(x,y)中。请记住，所有操作都将在我们上面列举的正交基上进行。此外，所有量子逻辑门都将通过单位矩阵来表示，从而也是正交矩阵。为什么？因为正交矩阵的向量乘法通过保持向量的内积来产生*旋转*。这会在欧几里得空间上产生等距变换。
- en: Notice, also, the negative signs for every 180⁰ rotations. The negative signs
    help distinguish equivalent outputs such that every operation can in principle
    be invertible or reversible. All quantum computations will need to be reversible
    to leverage the computational capacities of quantum states, namely the states
    of superposition and entanglement prior to measurement. As we will see later,
    the state of superposition (as well as entanglement) endows quantum computing
    with advantages that elude classical computing. In the state of superposition,
    any arbitrary number of qubits N occupy all of their possible states at once.
    If we have 4 qubits, the sample will have 2⁴ possible states, but in superposition
    all these states will obtain simultaneously. The probability of collapsing to
    one of these states upon measurement will be distributed equally along the linear
    combination of the unit vectors.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，每180⁰旋转的负号。这些负号有助于区分等效输出，以便每个操作原则上可以是可逆的或可逆的。所有量子计算都需要是可逆的，以利用量子态的计算能力，即在测量之前的叠加态和纠缠态。正如我们稍后会看到的，叠加态（以及纠缠态）赋予量子计算相对于经典计算的优势。在叠加态下，任何任意数量的量子比特N同时占据它们所有的可能状态。如果我们有4个量子比特，样本将有2⁴个可能的状态，但在叠加态下，所有这些状态将同时存在。测量时坍缩到其中一个状态的概率将均匀分布在单位向量的线性组合上。
- en: The lines in the unit circle below represent the state changes from input to
    output via operations with the Hadamard gate, which puts qubits into superposition
    and back. Due to the following equality ‖𝛼‖² + ‖β‖² = 1, measurement will always
    collapse the system into a distinct classical state, which in our case map to
    electron or photon spin. Operations with quantum gates however change the state
    of a single or multiple qubits without collapsing the wave function.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 下图中的单位圆中的线表示通过Hadamard门的操作从输入到输出的状态变化，该门将量子比特置于叠加态然后再恢复。由于以下等式 ‖𝛼‖² + ‖β‖² =
    1，测量将始终将系统坍缩到一个明确的经典状态，在我们的例子中对应于电子或光子自旋。然而，量子门的操作改变了单个或多个量子比特的状态，而不会坍缩波函数。
- en: '![](../Images/8c8e1a3cd177ec02dd33fb8ea98175e4.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8c8e1a3cd177ec02dd33fb8ea98175e4.png)'
- en: Qubit unit circle representation. Image from Wikimedia commons.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 量子比特单位圆表示。图片来源于Wikimedia commons。
- en: If we apply the bit-flip operator, equivalent to the NOT gate in classical computing,
    it will invert the value of the input state. For example, the |1> ket will flip
    to the |0> ket indicated below by the state transition from (0,1) to (1,0).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们应用位翻转操作符，相当于经典计算中的NOT门，它将翻转输入状态的值。例如，|1>态将翻转到|0>态，如下图所示，从 (0,1) 变到 (1,0)
    的状态过渡。
- en: 'The Hadamard gate, meanwhile, takes (0,1) as input and outputs (1/√2,−1/√2)
    by multiplying the input with the following orthogonal or unitary matrix:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，Hadamard门将 (0,1) 作为输入，通过将输入与以下正交或单位矩阵相乘来输出 (1/√2,−1/√2)：
- en: '![](../Images/596c2842ccbaf499cdb9947dcc60954f.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/596c2842ccbaf499cdb9947dcc60954f.png)'
- en: 'In case you’re wondering exactly how the state changes, here’s an explicit
    illustration of matrix multiplication with the Hadamard gate from |1> input:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道状态如何变化，这里有一个关于Hadamard门在|1>输入下的矩阵乘法的详细示例：
- en: '![](../Images/2a596fa69464a55b483f1192c6bf3f61.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2a596fa69464a55b483f1192c6bf3f61.png)'
- en: Hadamard gate operation with |1> input state vector.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Hadamard门在|1>输入状态向量下的操作。
- en: '***How does the Hadamard gate work and what is so special about it?***'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '***Hadamard门是如何工作的，它有什么特别之处？***'
- en: Notice by looking at the unit circle that the bit-flip operation corresponds
    to a 90⁰ rotation on the unit circle, meanwhile the Hadamard gate corresponds
    to 180⁰ rotation. What you need to keep in mind is that all quantum gates are
    done via orthogonal or unitary matrixes, which produce rotations along the origin.
    The Hadamard gate, specifically, produces half-rotations between the x and y axes,
    which correspond to probability amplitudes of 0.5.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 从单位圆上可以看出，比特翻转操作对应于单位圆上的90⁰旋转，而Hadamard门对应于180⁰旋转。需要记住的是，所有量子门都通过正交或单位矩阵完成，这些矩阵沿原点产生旋转。特别地，Hadamard门在x轴和y轴之间产生半旋转，对应于0.5的概率振幅。
- en: Notice also that the vector output is a unit vector since (1/√2, −1/√2) observes
    the following identity ‖𝛼‖² + ‖β‖² = 1\. Try to do the calculation yourself by
    plugging in the output values in place of 𝛼 and β.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，向量输出是单位向量，因为(1/√2, −1/√2)观察到以下恒等式 ‖𝛼‖² + ‖β‖² = 1。试着通过将输出值代入𝛼和β来进行计算。
- en: Think of the state of the qubit at some point in the unit circle as distributing
    the probability amplitudes from analogues of 0 and 1 to some set of values in
    between that conserve the unit sum. The Hadamard gate sets that distribution exactly
    to a 50/50 outcome. In other words, there’s a 50/50 chance that measurement will
    collapse the qbit to |0> or |1> state vectors. This is the mathematical analogue
    to a state of superposition. We will see later how superposition can be leveraged
    computationally.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，在单位圆上的某一点，量子比特的状态将从0和1的类比中分配概率振幅到一组保持单位和的值之间。Hadamard门将这种分布精确设置为50/50的结果。换句话说，测量时有50/50的概率会将量子比特坍缩为|0>或|1>状态向量。这是叠加态的数学类比。我们稍后将看到如何在计算中利用叠加态。
- en: Finally, our demonstrations thus far have utilized the unit circle as the space
    of possible states of a qubit in ℝ². Since actual qbit states are represented
    by complex numbers in ℂ², a more accurate representation of the qubit state space
    is given by what’s called a **block sphere**, which aims to capture the possible
    states of complex valued numbers shown below as a three-dimensional sphere.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，到目前为止，我们的演示利用了单位圆作为量子比特在ℝ²中的可能状态空间。由于实际的量子比特状态由ℂ²中的复数表示，因此量子比特状态空间的更准确表示是所谓的**Bloch球体**，旨在捕捉下图所示的复杂值数字的可能状态，这是一种三维球体。
- en: '![](../Images/37fcd2c0b73912cf049f454408a00bc9.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/37fcd2c0b73912cf049f454408a00bc9.png)'
- en: Qubit block sphere representation. Image from Wikimedia commons.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 量子比特Bloch球体表示。图片来自Wikimedia commons。
- en: Quantum Logic Gates
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 量子逻辑门
- en: Much like traditional computing, logic gates in quantum computing consist of
    circuits that perform some operation on a qubit or sets of qubits. Earlier we
    saw that quantum gates mathematically amount to matrix multiplications on qubits.
    We also said that qubits are represented by unit vectors, whereas quantum logic
    gates by orthogonal or unitary matrices. As we saw, these produce rotations on
    a unit sphere, or circle, to reduce the complex space to a two-dimensional one
    for the sake of simplification.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统计算类似，量子计算中的逻辑门由对量子比特或量子比特集合执行某种操作的电路组成。我们早些时候看到，量子门在数学上相当于对量子比特的矩阵乘法。我们还说过，量子比特由单位向量表示，而量子逻辑门由正交或单位矩阵表示。正如我们所看到的，这些在单位球体或圆上产生旋转，以简化为二维空间。
- en: However, to perform operations on qubits, quantum gates must be reversible.
    Reversibility means that every operation from *input* to *output* must also be
    revertible from *output* to *input*. The reason for this is that quantum states
    are reversible, time-reversal invariant, and conserve information in the state
    of superposition. What we termed *measurement*, however, reduces the quantum state
    into a classical one. Measurement or collapse is irreversible and does not thereby
    conserve input information. In other words, we cannot revert the collapse into
    its preceding superpositioned state. As such, quantum gates constitute controlled
    operations that manipulate the quantum state while also conserving it. The circuitry
    necessary for these outcomes leverages semiconductor particles a few nanometers
    in size called quantum dots that have to be kept temperatures close to zero Kelvin.
    However, it is crucial to note that the desired outputs of quantum computation
    can only be retrieved through measurement.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了对量子比特进行操作，量子门必须是可逆的。可逆性意味着从*输入*到*输出*的每个操作也必须从*输出*到*输入*是可逆的。原因在于量子态是可逆的，时间反转不变的，并且在叠加态中保留信息。然而，我们所称的*测量*会将量子态降解为经典态。测量或坍缩是不可逆的，因此不会保留输入信息。换句话说，我们不能将坍缩恢复到之前的叠加态。因此，量子门构成了受控操作，它们在操控量子态的同时也保持了量子态。这些结果所需的电路利用了几纳米大小的半导体颗粒，称为量子点，这些量子点必须保持在接近零开尔文的温度。然而，需要注意的是，量子计算的期望输出只能通过测量来检索。
- en: 'There are, therefore, two properties that matter the most when it comes to
    quantum logic gates: a) **reversibility** and b) **universality**. Universality
    refers to a type of logic gate that can compute all possible operations on bits.
    The most well known universal gate in classical computing is NAND (NOT AND) represented
    by the table below:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当涉及量子逻辑门时，最重要的两个属性是：a) **可逆性** 和 b) **普遍性**。普遍性指的是一种能够计算所有可能位操作的逻辑门。经典计算中最著名的通用门是
    NAND（NOT AND），如下面的表格所示：
- en: '![](../Images/4084cfd71b8c1be84e10574f9022fe8b.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4084cfd71b8c1be84e10574f9022fe8b.png)'
- en: 'Note that NAND is the truth-functional *complement* to AND. At most, only two
    logical operators suffice to express all possible logical statements including
    the theorems of logic. This is known as *functional completeness*. Since NAND
    combines both NOT & AND into one operation, by corollary it qualifies as a functionally
    complete and thereby universal logical operator and gate. For comparison’s sake,
    let’s look at the truth table for AND:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，NAND 是 AND 的真值函数*补集*。最多，仅需两个逻辑运算符即可表达所有可能的逻辑语句，包括逻辑定理。这被称为*函数完备性*。由于 NAND
    将 NOT 和 AND 结合为一个操作，因此它也就成为了功能上完备的、普遍的逻辑运算符和门。为了比较，我们来看一下 AND 的真值表：
- en: '![](../Images/fafcba244a3d83d847426733e33562a2.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/fafcba244a3d83d847426733e33562a2.png)'
- en: In classical computing, most operations are irreversible. For example, if we
    input a sequence 010011110 into most logic gates and get another binary sequence
    as output, we would not be able to retrieve the input sequence from the output
    sequence alone. XOR and NAND are both irreversible. However, there are some gates
    that allow us to retrieve the input from the output alone, like the CNOT (equivalent
    to XOR but reversible), Hadamard and TOFFOLI gates. Among these, the Hadamard
    and TOFFOLI qualify as both *reversible* and *universal*. However, there are other
    gates that meet these qualifications like the FRIEDKIN gate. We will focus on
    the former triad.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典计算中，大多数操作是不可逆的。例如，如果我们将序列 010011110 输入到大多数逻辑门中并得到另一个二进制序列作为输出，我们将无法仅从输出序列中恢复输入序列。XOR
    和 NAND 都是不可逆的。然而，有些门允许我们仅从输出中检索输入，比如 CNOT（等效于 XOR 但可逆）、Hadamard 和 TOFFOLI 门。在这些门中，Hadamard
    和 TOFFOLI 都符合*可逆*和*普遍*的标准。然而，还有其他门也满足这些要求，如 FRIEDKIN 门。我们将重点讨论前述三者。
- en: 'Let us now take a look at two gates essential for most quantum computations:
    CNOT & Hadamard. The CNOT operates on two or more qubits by entangling them. The
    Hadamard gate operates on one or more qubits by putting them into superposition.
    We will also look at a third gate, the TOFFOLI gate, also known as the controlled-controlled
    NOT gate, which is a universal version of the CNOT gate.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看对大多数量子计算至关重要的两个门：CNOT 和 Hadamard。CNOT 通过纠缠两个或更多量子比特来操作它们。Hadamard 门通过将一个或多个量子比特置于叠加态来操作它们。我们还将关注第三个门，即
    TOFFOLI 门，也称为控制-控制 NOT 门，它是 CNOT 门的通用版本。
- en: 'What is the purpose of the CNOT gate? It allows us to entangle two input qubits
    by performing bit-flip operations that are reversible. The CNOT gate consists
    of two inputs: a control and a target input. When the control bit equals 1 the
    CNOT gate flips the target input. When the control bit equals 0, the CNOT gate
    does nothing. This way, every output combination can be traced back to one and
    only one input combination.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: CNOT 门的目的是什么？它允许我们通过执行可逆的比特翻转操作来纠缠两个输入量子位。CNOT 门由两个输入组成：一个控制输入和一个目标输入。当控制比特等于
    1 时，CNOT 门翻转目标输入。当控制比特等于 0 时，CNOT 门什么也不做。这样，每个输出组合都可以追溯到唯一的输入组合。
- en: '![](../Images/6507d34751e0517f6ce3c15b47e4813f.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6507d34751e0517f6ce3c15b47e4813f.png)'
- en: Classical CNOT gate with bits and tensor product output
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 带有比特的经典 CNOT 门和张量积输出
- en: '![](../Images/81fe0475faab25aaeae46e72c20af64f.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/81fe0475faab25aaeae46e72c20af64f.png)'
- en: Quantum CNOT gate on standard bases and tensor product output
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 标准基和张量积输出上的量子 CNOT 门
- en: In what sense is the CNOT gate equivalent to entanglement?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: CNOT 门在什么意义上等同于纠缠？
- en: Let’s take a look at an operation by the CNOT gate on |1> and |0> qubits. We
    take the tensor product of the two qubits and multiply it with the CNOT gate unitary
    matrix, which converts the input tensor product from |10> to |11>. Why? Because
    CNOT flips the value of the target qubit if and only if the control qubit equals
    |1>.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 CNOT 门对 |1> 和 |0> 量子位的操作。我们取两个量子位的张量积，并将其与 CNOT 门的单位矩阵相乘，将输入张量积从 |10>
    转换为 |11>。为什么？因为 CNOT 仅当控制量子位等于 |1> 时，才会翻转目标量子位的值。
- en: '![](../Images/a34217aef74e6af64eef40855cf0e0c1.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a34217aef74e6af64eef40855cf0e0c1.png)'
- en: 'By corollary, if our target qubit is |1> instead of |0>, the CNOT gate predictably
    flips the value back to |0> as we see below:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从推论上讲，如果我们的目标量子位是 |1> 而不是 |0>，CNOT 门会将值预测性地翻转回 |0>，如下面所示：
- en: '![](../Images/51d23677f57a1e2f559acf2062f60a31.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/51d23677f57a1e2f559acf2062f60a31.png)'
- en: In other words, CNOT is the reversible classic-computational equivalent of the
    XOR (exclusive OR).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，CNOT 是 XOR（异或）的可逆经典计算等效物。
- en: 'As we mentioned earlier, the **Hadamard gate** yields a perfect superposition.
    How does it do that? Take a look at the orthogonal matrix below:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，**哈达玛门**产生了一个完美的叠加态。它是如何做到的？请看下面的正交矩阵：
- en: '![](../Images/538f68fccfa8d14be05dc3d20e54189c.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/538f68fccfa8d14be05dc3d20e54189c.png)'
- en: Hadamard gate is an orthogonal matrix that puts input qubits into superposition
    and vice versa.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 哈达玛门是一个正交矩阵，它将输入量子位置于叠加态中，反之亦然。
- en: 'If we multiply the matrix with a standard base |0>, then it outputs the following
    state: (1/√2, 1/√2) which is equivalent to (|0>+|1>)/√2\. Conversely, if we multiply
    it with |1>, we get (1/√2,−1/√2), which is equivalent to (|0>−|1>)/√2\. Even though
    each input converts the output to an equal distribution of probability amplitudes,
    the negative sign allows us to distinguish the input (whether it is |0> or |1>)
    and thereby ensures the operation is reversible.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将矩阵与标准基 |0> 相乘，它会输出以下状态：(1/√2, 1/√2)，这等于 (|0>+|1>)/√2\. 相反，如果我们将其与 |1> 相乘，我们得到
    (1/√2,−1/√2)，这等于 (|0>−|1>)/√2\. 尽管每个输入将输出转换为概率幅度的均匀分布，但负号使我们能够区分输入（是 |0> 还是 |1>），从而确保操作是可逆的。
- en: Each value has a 50/50 chance of outcome in the classical world. Notice that
    in our example we carried out the operation on a single qubit. How do we put multiple
    qubits on superposition?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典世界中，每个值都有 50/50 的结果概率。注意在我们的例子中，我们对单个量子位进行了操作。我们如何将多个量子位置于叠加态？
- en: We need to pass each qubit separately through a Hadamard gate, then take their
    tensor product. As we noted earlier, multiple qubit states are represented as
    tensor products of single qubit states.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要分别通过哈达玛门处理每个量子位，然后取它们的张量积。正如我们之前提到的，多量子位状态表示为单个量子位状态的张量积。
- en: 'Below you can see the operation on a single qubit by multiplying the |1> standard
    base with the Hadamard matrix:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 下面你可以看到通过将 |1> 标准基与哈达玛矩阵相乘，对单个量子位的操作：
- en: '![](../Images/b4a8e0b24b69e0c39bae140c417a787b.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b4a8e0b24b69e0c39bae140c417a787b.png)'
- en: Finally, let’s take a look at the TOFFOLI gate, also known as the controlled-controlled-not
    (CCNOT) gate. The TOFFOLI gate is identical to the CNOT save for having an additional
    control variable. With two control variables, the TOFFOLI gate utilizes an 8x8
    orthogonal matrix for operations on three input qubits. Like CNOT, TOFFOLI produces
    quantum entanglement, and can be used to entangle and disentangle qubits.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来看看TOFFOLI门，也称为受控受控非门（CCNOT门）。TOFFOLI门与CNOT门相同，只是多了一个控制变量。TOFFOLI门利用一个8x8的正交矩阵对三个输入量子比特进行操作。像CNOT一样，TOFFOLI会产生量子纠缠，并可用于纠缠和解纠缠量子比特。
- en: 'The TOFFOLI gate input-output tables:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: TOFFOLI门的输入输出表：
- en: '![](../Images/d3dc1f6ea9e96884033c394453eb003b.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d3dc1f6ea9e96884033c394453eb003b.png)'
- en: Classical Toffoli gate inputs and outputs.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 经典Toffoli门的输入和输出。
- en: '![](../Images/4a69c119395b70bdc6bb366eae6d78c5.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4a69c119395b70bdc6bb366eae6d78c5.png)'
- en: Quantum Toffoli gate inputs and outputs.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 量子Toffoli门的输入和输出。
- en: '*Why do we need the TOFFOLI gate when we have CNOT?*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么我们需要TOFFOLI门而不是CNOT？*'
- en: Because like NAND, TOFFOLI is universal for classical computation and can thereby
    be used by a quantum computer to simulate reversible classical computations. TOFFOLI
    is however not quantum computationally universal since it cannot produce superpositions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因为像NAND一样，TOFFOLI对于经典计算是通用的，因此可以被量子计算机用来模拟可逆的经典计算。然而，TOFFOLI在量子计算上并不是通用的，因为它不能产生叠加态。
- en: '***Now that we have some handle on quantum logic gates and the operations that
    they perform, how do we combine them to get quantum algorithms?***'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '***现在我们对量子逻辑门及其执行的操作有所了解，我们如何将它们结合起来以获得量子算法？***'
- en: Since quantum gates preserve the state of superposition, we can use them to
    perform unitary computations that are reversible. Physically speaking, the evolution
    of the system in time is described by Schrödinger’s wave function. To retrieve
    any information from the quantum computer, however, we need to collapse the wave
    function.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于量子门保留了叠加态，我们可以使用它们执行可逆的单位运算。从物理角度来看，系统在时间上的演化由薛定谔方程描述。然而，要从量子计算机中检索任何信息，我们需要使波函数坍缩。
- en: Typically, we combine operations of bit-flips and Hadamard gates to get desired
    outcomes. However, bit-flips are non-reversible. The challenge of quantum computing
    lies in devising ways to write non-reversible functions in a reversible way. We
    will see how to do this with the Deutsch algorithm.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们将比特翻转操作和Hadamard门结合起来以获得期望的结果。然而，比特翻转是不可逆的。量子计算的挑战在于设计出以可逆方式书写不可逆函数的方法。我们将通过Deutsch算法来了解如何实现这一点。
- en: Classical bits are special cases of qbits
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 经典比特是量子比特的特殊情况
- en: In principle, a quantum computer can instantiate all classical computations
    as these are a proper subset of quantum computations.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，量子计算机可以实例化所有经典计算，因为这些计算是量子计算的一个适当子集。
- en: In order to realize classical computations through a quantum computer, we must
    limit computations to qubits expressed by ***normal bases*** (as analogs to classical
    bits) we’ve been using as examples all along and design circuitry that utilize
    ***classically universal reversible gates*** like the TOFFOLI gate. Since the
    TOFFOLI gate is a universal gate for classical computation, it can be used to
    instantiate classical computations.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过量子计算机实现经典计算，我们必须将计算限制在我们一直作为例子的***标准基底***（类似于经典比特）上，并设计利用***经典通用可逆门***（如TOFFOLI门）的电路。由于TOFFOLI门是经典计算的通用门，它可以用于实例化经典计算。
- en: However, we haven’t said anything thus far about quantum algorithms. Just how
    would be go about constructing one?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，到目前为止，我们还没有讨论过量子算法。我们该如何构造一个量子算法呢？
- en: 'Quantum Algorithms: The Deutsch Oracle'
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 量子算法：Deutsch Oracle
- en: Everything we’ve explicated thus far would be frivolous from a computational
    standpoint if we could not construct quantum algorithms that confer computational
    advantages over classical algorithms.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所阐述的一切从计算角度来看将是无意义的，如果我们不能构造出比经典算法具有计算优势的量子算法。
- en: The first algorithm that demonstrably achieved this was devised by David Deutsch
    in 1985, known as Deutsch’s Oracle.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个显著实现这一点的算法是由David Deutsch于1985年提出的，称为Deutsch的Oracle。
- en: Suppose you have four functions f₀-f₃. For every input 0 or 1, f₀ outputs 0\.
    For every input of 0 or 1, f₁ outputs 0 if the input is 0 and 1 if the input is
    1\. For every input of 0 or 1, f₂ outputs 1 if the input is 0 and 0 if the input
    is 1\. For every input of 0 or 1, f₃ outputs outputs 1.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有四个函数 f₀-f₃。对于每个输入 0 或 1，f₀ 输出 0。对于每个输入 0 或 1，f₁ 如果输入是 0 则输出 0，如果输入是 1 则输出
    1。对于每个输入 0 或 1，f₂ 如果输入是 0 则输出 1，如果输入是 1 则输出 0。对于每个输入 0 或 1，f₃ 输出 1。
- en: We can call functions f₀ and f₃ constants, since they produce the same output
    regardless of the input. And we call the functions f₁-f₂ balanced, since they
    distribute the outputs in a reciprocal way.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以称函数 f₀ 和 f₃ 为常量函数，因为它们无论输入是什么都产生相同的输出。而我们称函数 f₁-f₂ 为平衡函数，因为它们以互补的方式分配输出。
- en: 'The question we then ask is: ***if we’re given one of these functions at random,
    how many times should we query the algorithm to determine whether the function
    is a constant or balanced?***'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要问的问题是：***如果我们随机得到这些函数中的一个，我们应该查询算法多少次才能确定函数是常量还是平衡的？***
- en: The answer is that classical computation cannot determine the right answer in
    less than two queries. Let’s see how this works. We have the choice of 0 or 1
    as input. If we input 0, we could get 0 or 1 as output. Likewise, if input 1,
    we could get 0 or 1 as output. In both cases, we won’t know whether the output
    was produced by a constant or balanced function. We therefore have to query the
    algorithm a second time to make the correct determination.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是经典计算不能在少于两个查询的情况下确定正确答案。让我们看看这是如何实现的。我们可以选择 0 或 1 作为输入。如果我们输入 0，输出可能是 0 或
    1。同样地，如果输入 1，输出可能是 0 或 1。在这两种情况下，我们无法知道输出是由常量函数还是平衡函数产生的。因此，我们必须第二次查询算法才能做出正确的判断。
- en: 'With a quantum algorithm, Deutsch demonstrated, we can know the correct answer
    with a single query. In order to achieve this, we make use of the Hadamard gate
    and a control qubit in addition to the input qubit. We send our inputs through
    the Hadamard gate. Remember that H puts a qubit in a state of superposition. So
    if we input the pair |0> and |1>, we get the following respective states: (1/√2,
    1/√2) , (1/√2, −1/√2). We then pass the target gate through random fₓ.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 德意志（Deutsch）通过量子算法演示了，我们可以通过一次查询就知道正确答案。为了实现这一点，我们除了输入量子比特外，还利用了 Hadamard 门和一个控制量子比特。我们将输入通过
    Hadamard 门。请记住，H 将量子比特置于叠加态。因此，如果我们输入 |0> 和 |1>，我们会得到以下相应的状态：(1/√2, 1/√2) , (1/√2,
    −1/√2)。然后我们将目标门应用于随机 fₓ。
- en: 'Since Hadamard is reversible, fₓ should put our qubit in one of the following
    states:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Hadamard 是可逆的，fₓ 应该将我们的量子比特置于以下状态之一：
- en: (1/√2) (|0>+|1>); (1/√2) (|0>−|1>); (−1/√2) (|0>−|1>); (−1/√2) (|0>+|1>)
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (1/√2) (|0>+|1>); (1/√2) (|0>−|1>); (−1/√2) (|0>−|1>); (−1/√2) (|0>+|1>)
- en: 'We pass the control qubit through the Hadamard again in order to reverse the
    superposition. Since the operations are reversible, we get the following possible
    outcomes:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次通过 Hadamard 传递控制量子比特以逆转叠加态。由于操作是可逆的，我们会得到以下可能的结果：
- en: '**f₀ →|0>; f₁ →|1>; f₂ → −|1>; f₃ →−|0>**'
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**f₀ →|0>; f₁ →|1>; f₂ → −|1>; f₃ →−|0>**'
- en: This means that when we measure the qubit at the very end, if the output is
    |0> the function is a constant, and if the output is |1>, the function is balanced.
    Even though the Deutsch Oracle has no practical uses, it provides a powerful example
    of the advantages of quantum over classical computing.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当我们在最后测量量子比特时，如果输出是 |0>，函数是常量的；如果输出是 |1>，函数是平衡的。尽管德意志预言机没有实际应用，但它提供了量子计算相比经典计算的优势的强有力例证。
- en: '**Deutsch-Jozsa Algorithm**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**Deutsch-Jozsa 算法**'
- en: The Deutsch Oracle generalized to multiple variables is called the Deutsch-Jozsa
    algorithm. The diagram below provides the schematic quantum circuitry of the algorithm.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 德意志预言机推广到多个变量被称为 Deutsch-Jozsa 算法。下面的图示提供了该算法的示意量子电路。
- en: '![](../Images/bce1a5ba7680c4f90571238a17c07c1d.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/bce1a5ba7680c4f90571238a17c07c1d.png)'
- en: 'Circuit of Deutsch-Jozsa algorithm, where H stands for Hadamard, U for a constant
    or bit-flip function, with standard bases as input. Only the output on the top
    right is measured. [Image source: Wikipedia.](https://en.wikipedia.org/wiki/Deutsch%E2%80%93Jozsa_algorithm#/media/File:Deutsch-Jozsa-algorithm-quantum-circuit.png)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Deutsch-Jozsa 算法的电路，其中 H 代表 Hadamard，U 代表常量或比特翻转函数，标准基作为输入。仅测量右上角的输出。[图片来源：维基百科。](https://en.wikipedia.org/wiki/Deutsch%E2%80%93Jozsa_algorithm#/media/File:Deutsch-Jozsa-algorithm-quantum-circuit.png)
- en: '**Shor’s Algorithm**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**Shor 算法**'
- en: Shor’s algorithm is a quantum algorithm used for factoring large numbers. The
    algorithm consists of two parts, the first of which is executed in a classical
    computer, and the second executed in a quantum one that makes use of the quantum
    Fourier Transform. We will not delve into the mathematical details of this algorithm
    as they’re complex and therefore beyond the scope of this article.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Shor算法是一种用于分解大数的量子算法。该算法由两个部分组成，其中第一部分在经典计算机上执行，第二部分在利用量子傅里叶变换的量子计算机上执行。我们不会深入探讨该算法的数学细节，因为这些细节复杂且超出了本文的范围。
- en: Shor’s algorithm requires two registers with 1024 and 2048 qubits respectively
    in order to factor a 1024 bit number with 309 digits. The largest number that
    has been factored to date has a length of 48 bits, which falls short of the RSA
    100 digit semiprime milestone. So far no quantum computer has met any of the RSA
    number challenges, which consists of a list of identified large numbers that have
    only two prime factors. RSA numbers are used in public-key cryptography for secure
    data transmission by governments and financial institutions.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Shor算法需要两个寄存器，分别具有1024和2048量子位，以分解一个具有309位的1024位数字。迄今为止被分解的最大数字长度为48位，未达到RSA
    100位半素数的里程碑。目前没有任何量子计算机解决了RSA数字挑战，这是一份列出仅有两个素因子的已知大数的清单。RSA数字用于公钥加密，以确保政府和金融机构的安全数据传输。
- en: With a sufficiently powerful quantum computer, Shor’s algorithm can be used
    to decode public-key cryptography, which uses very large primes deemed computationally
    intractable by classical computers.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用足够强大的量子计算机，Shor算法可以用来解码公钥加密，这种加密使用的非常大的素数被经典计算机认为是计算上难以处理的。
- en: Quantum Supremacy & The Future
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 量子霸权与未来
- en: 'As we said at the outset, the notion of quantum supremacy refers to the ability
    of quantum computers to solve classically intractable problems in a reasonable
    time-frame. In principle, classical computers can solve any theoretically computable
    algorithm. The problem lies with praxis: limited processing power precludes them
    from solving certain problems in a useful timeframe. This is where quantum computers
    promise to bridge the gap. In 2019, Google announced that they had achieved quantum
    supremacy with their Sycamore, a 53 qubit quantum computer. In their Nature paper
    titled [Quantum Supremacy Using a Programmable Superconducting Processor](https://www.nature.com/articles/s41586-019-1666-5)
    they claim that Sycamore took 200 seconds to sample one instance of a quantum
    circuit a million times, a task which, they further claimed, would take a classical
    supercomputer 10000 years. IBM countered the latter claim by averring that one
    of their supercomputers could perform that task in 2.5 days, undercutting Google’s
    claim to the finish line.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们一开始所说，量子霸权的概念指的是量子计算机在合理的时间范围内解决经典上难以处理的问题的能力。原则上，经典计算机可以解决任何理论上可计算的算法。问题在于实践：有限的处理能力使它们无法在有用的时间范围内解决某些问题。这就是量子计算机有望弥合差距的地方。2019年，谷歌宣布他们通过其Sycamore量子计算机实现了量子霸权，该计算机拥有53个量子位。在他们题为[使用可编程超导处理器实现量子霸权](https://www.nature.com/articles/s41586-019-1666-5)的《自然》论文中，他们声称Sycamore花了200秒来对一个量子电路实例进行一百万次采样，而他们进一步声称，这项任务需要经典超级计算机花费10000年。IBM反驳了这一说法，表示他们的一台超级计算机可以在2.5天内完成这一任务，从而削弱了谷歌对完成时间的声明。
- en: The largest quantum computer to date, IBM’s Osprey, sports a 433 qubit processor.
    Current attempts to build quantum computers with sufficiently large processors
    are beleaguered by creeping noise, namely the potential of the quantum state to
    decohere or collapse into a classical state through interaction with its surrounding
    environment such as changes in temperature and magnetic fields.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止最大的量子计算机，IBM的Osprey，拥有一个433量子位的处理器。目前尝试构建具有足够大处理器的量子计算机的工作受到逐渐增加的噪声困扰，即量子态通过与周围环境（如温度和磁场变化）的互动而发生退相干或崩溃成经典态的潜力。
- en: The noise-problem constitutes one of the key challenges of scaling quantum computers
    to the computational potential such as factoring inordinately large primes. [Noise-cancelling
    qubits](https://news.uchicago.edu/story/noise-cancelling-qubits-can-minimize-errors-quantum-computers#:~:text=As%20existing%20quantum%20computers%20are,to%20high%20rates%20of%20error.)
    could offset some of these challenges, but currently the advent of quantum computing
    is still in its infancy.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 噪声问题构成了将量子计算机扩展到如因式分解极其大的质数等计算潜力的一项关键挑战。[降噪量子比特](https://news.uchicago.edu/story/noise-cancelling-qubits-can-minimize-errors-quantum-computers#:~:text=As%20existing%20quantum%20computers%20are,to%20high%20rates%20of%20error.)可能会缓解这些挑战的一部分，但目前量子计算仍处于起步阶段。
- en: References
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考文献
- en: Bernhardt, Chris. *Quantum Computing for Everyone*. The MIT Press, 2020.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Bernhardt, Chris。*面向所有人的量子计算*。麻省理工学院出版社，2020年。
- en: '*IBM unveils 400 qubit-plus quantum processor and next-generation IBM Quantum
    System Two*. IBM Newsroom. (n.d.). [https://newsroom.ibm.com/2022-11-09-IBM-Unveils-400-Qubit-Plus-Quantum-Processor-and-Next-Generation-IBM-Quantum-System-Two](https://newsroom.ibm.com/2022-11-09-IBM-Unveils-400-Qubit-Plus-Quantum-Processor-and-Next-Generation-IBM-Quantum-System-Two)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*IBM推出400量子比特以上的量子处理器和下一代IBM量子系统二*。IBM新闻。（无日期）。 [https://newsroom.ibm.com/2022-11-09-IBM-Unveils-400-Qubit-Plus-Quantum-Processor-and-Next-Generation-IBM-Quantum-System-Two](https://newsroom.ibm.com/2022-11-09-IBM-Unveils-400-Qubit-Plus-Quantum-Processor-and-Next-Generation-IBM-Quantum-System-Two)'
- en: Kaye, P., Laflamme, R., & Mosca, M. (2020). *An introduction to quantum computing*.
    Oxford University Press.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Kaye, P., Laflamme, R., & Mosca, M. (2020)。*量子计算导论*。牛津大学出版社。
- en: '*“Noise-cancelling” qubits can minimize errors in quantum computers*. University
    of Chicago News. (n.d.). [https://news.uchicago.edu/story/noise-cancelling-qubits-can-minimize-errors-quantum-computers#:~:text=As%20existing%20quantum%20computers%20are,to%20high%20rates%20of%20error.](https://news.uchicago.edu/story/noise-cancelling-qubits-can-minimize-errors-quantum-computers#:~:text=As%20existing%20quantum%20computers%20are,to%20high%20rates%20of%20error.)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*“降噪”量子比特可以最小化量子计算机中的错误*。芝加哥大学新闻。（无日期）。 [https://news.uchicago.edu/story/noise-cancelling-qubits-can-minimize-errors-quantum-computers#:~:text=As%20existing%20quantum%20computers%20are,to%20high%20rates%20of%20error.](https://news.uchicago.edu/story/noise-cancelling-qubits-can-minimize-errors-quantum-computers#:~:text=As%20existing%20quantum%20computers%20are,to%20high%20rates%20of%20error.)'
- en: Roush, W. (2020, July 13). *The google-IBM “Quantum Supremacy” feud*. MIT Technology
    Review. [https://www.technologyreview.com/2020/02/26/905777/google-ibm-quantum-supremacy-computing-feud/](https://www.technologyreview.com/2020/02/26/905777/google-ibm-quantum-supremacy-computing-feud/)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Roush, W. (2020年7月13日)。*谷歌-IBM“量子霸权”争端*。MIT技术评论。 [https://www.technologyreview.com/2020/02/26/905777/google-ibm-quantum-supremacy-computing-feud/](https://www.technologyreview.com/2020/02/26/905777/google-ibm-quantum-supremacy-computing-feud/)
- en: 'Zubairy, Muhammad Suhail. *Quantum Mechanics for Beginners: With Applications
    to Quantum Communication and Quantum Computing*. Oxford University Press, 2020.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Zubairy, Muhammad Suhail。*初学者的量子力学：量子通信和量子计算的应用*。牛津大学出版社，2020年。
