- en: 'Optimizing Connections: Mathematical Optimization within Graphs'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化连接：图中的数学优化
- en: 原文：[https://towardsdatascience.com/optimizing-connections-mathematical-optimization-within-graphs-7364e082a984](https://towardsdatascience.com/optimizing-connections-mathematical-optimization-within-graphs-7364e082a984)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/optimizing-connections-mathematical-optimization-within-graphs-7364e082a984](https://towardsdatascience.com/optimizing-connections-mathematical-optimization-within-graphs-7364e082a984)
- en: '![](../Images/9b3b31ccdb700cdf4e096983187caa65.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9b3b31ccdb700cdf4e096983187caa65.png)'
- en: Disconnected graphs. Image created with Dall-E 2 by the author.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 断开的图。图片由作者用 Dall-E 2 创建。
- en: An introduction to graph theory and its applications
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图论及其应用简介
- en: '[](https://hennie-de-harder.medium.com/?source=post_page-----7364e082a984--------------------------------)[![Hennie
    de Harder](../Images/3e4f2cccd6cb976ca3f8bf15597daea8.png)](https://hennie-de-harder.medium.com/?source=post_page-----7364e082a984--------------------------------)[](https://towardsdatascience.com/?source=post_page-----7364e082a984--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----7364e082a984--------------------------------)
    [Hennie de Harder](https://hennie-de-harder.medium.com/?source=post_page-----7364e082a984--------------------------------)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://hennie-de-harder.medium.com/?source=post_page-----7364e082a984--------------------------------)[![Hennie
    de Harder](../Images/3e4f2cccd6cb976ca3f8bf15597daea8.png)](https://hennie-de-harder.medium.com/?source=post_page-----7364e082a984--------------------------------)[](https://towardsdatascience.com/?source=post_page-----7364e082a984--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----7364e082a984--------------------------------)
    [Hennie de Harder](https://hennie-de-harder.medium.com/?source=post_page-----7364e082a984--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----7364e082a984--------------------------------)
    ·13 min read·Jul 28, 2023
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: ·发表在 [Towards Data Science](https://towardsdatascience.com/?source=post_page-----7364e082a984--------------------------------)
    ·13 min read·2023年7月28日
- en: --
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '**In this post, we delve into the world of mathematical optimization within
    graphs, exploring key concepts, algorithms, and practical applications. Graph
    problems can be found in many places. Obvious ones are in logistics or social
    network analysis, like finding the optimal route for a delivery company or the
    lowest amount of connections between two people. But did you know that graphs
    are also applicable in urban planning, disease transmission modeling, fraud detection,
    recommendation engines, and cybersecurity? By leveraging optimization algorithms
    specifically designed for graphs, data scientists can uncover optimal solutions,
    allocate resources efficiently, and make data-driven decisions.**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**在这篇文章中，我们将深入探讨图中的数学优化，探索关键概念、算法和实际应用。图问题可以在许多地方找到。显而易见的例子有物流或社交网络分析，比如寻找一个配送公司的最佳路线或两个个体之间的最少连接数。但你知道图也适用于城市规划、疾病传播建模、欺诈检测、推荐引擎和网络安全吗？通过利用专为图设计的优化算法，数据科学家可以发现最佳解决方案，高效分配资源，并做出数据驱动的决策。**'
- en: First, we’ll start with an introduction section, to explain the basics of graphs.
    Then we dive into common graph problems and algorithms trying to solve these problems.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从介绍部分开始，以解释图的基础知识。然后，我们将深入探讨常见的图问题和算法，尝试解决这些问题。
- en: Graph Basics
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图的基础知识
- en: As a recap, below the basics on graph theory.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 作为回顾，以下是图论的基础知识。
- en: What is a graph?
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是图？
- en: A graph consists of vertices (or nodes) and edges. If the vertices are related
    in a certain way, they are connected with an edge. To define a graph, you need
    the names of all the vertices and you need to know which vertices are connected.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图由顶点（或节点）和边组成。如果顶点以某种方式相关，它们就通过边连接。要定义一个图，你需要所有顶点的名称，并且需要知道哪些顶点是连接的。
- en: Below a graph that has vertices {A, B, C, D, E} and edges {{A, D}, {A, E}, {B,
    C}, {B, D}, {C, D}}.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个具有顶点 {A, B, C, D, E} 和边 {{A, D}, {A, E}, {B, C}, {B, D}, {C, D}} 的图。
- en: '![](../Images/26104cd30f3e3328155310a42c084ce1.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/26104cd30f3e3328155310a42c084ce1.png)'
- en: Simple graph. Image by author.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 简单图。图片由作者提供。
- en: Sometimes, graphs can contain *loops*. A loop is an edge that has the same start
    and end node (a node is connected with itself).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，图中可能包含*回路*。回路是一条起点和终点相同的边（一个节点与自身连接）。
- en: 'Other terms that are nice to know in graph theory:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图论中还需了解的其他术语：
- en: The *order* of a graph is equal to its number of vertices.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图的*顺序*等于其顶点数。
- en: The *size* of a graph is the number of edges (sometimes plus the number of vertices).
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图的*大小*是边的数量（有时加上顶点数量）。
- en: The *degree* of a vertex is the amount of edges it has (a loop is counted twice
    for the beginning and end point).
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶点的*度数*是它拥有的边的数量（一个回路在起点和终点处都算作两次）。
- en: Common variations
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见变体
- en: The previous graph example is also called a *simple graph*, because it only
    contains vertices and (undirected) edges. But you can easily make it a bit more
    complex, and often more interesting, by providing additional information.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的图示例也被称为*简单图*，因为它只包含顶点和（无向）边。但你可以通过提供额外的信息使它变得稍微复杂一些，通常更有趣。
- en: 'Below an example of a *directed graph* (a.k.a digraph), where the edges are
    pointed in a certain direction:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个*有向图*（即digraph）的示例，其中边指向特定方向：
- en: '![](../Images/f61afead3a89631492b8c04b1199d3b4.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f61afead3a89631492b8c04b1199d3b4.png)'
- en: Directed graph. Image by author.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有向图。图像由作者提供。
- en: 'Another graph that is a fit in many situations is a *weighted graph*. In a
    weighted graph, the edges are associated with a weight: this can be anything,
    e.g. length or costs.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种适用于多种情况的图是*加权图*。在加权图中，边与一个权重相关联：这可以是任何东西，例如长度或成本。
- en: '![](../Images/cceedb61743fb27e3c6375419b43f869.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/cceedb61743fb27e3c6375419b43f869.png)'
- en: Weighted graph. Image by author.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 加权图。图像由作者提供。
- en: 'The last interesting graph variation discussed here is a *multigraph*. In a
    multigraph, the same edge can occur more than once:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里讨论的最后一种有趣的图形变体是*多重图*。在多重图中，同一条边可以出现多次：
- en: '![](../Images/bbd106886fe6eaac4a2e48ab35ef10e7.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/bbd106886fe6eaac4a2e48ab35ef10e7.png)'
- en: Multigraph. Image by author.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 多重图。图像由作者提供。
- en: 'Note: There are many special types of graphs with their own properties. E.g.
    a graph in which each pair of vertices is connected with an edge is called a complete
    graph.'
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意：有许多特殊类型的图形及其自身的属性。例如，一个每对顶点都用边连接的图称为完全图。
- en: From Problem to Graph
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从问题到图
- en: 'How to create a graph out of a problem? Let’s go through some examples:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如何从问题创建图？让我们通过一些示例来探讨：
- en: '**Locations and Distances**'
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**位置和距离**'
- en: A classic problem is a problem for which you have locations and distances between
    the locations. In the *adjacency* matrix below, the distances between the locations
    are provided (if there is a distance greater than 0, there is an edge). From this
    matrix, you can easily create a graph.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经典问题是有位置和位置之间距离的问题。在下面的*邻接*矩阵中，提供了位置之间的距离（如果距离大于0，则有一条边）。从这个矩阵中，你可以轻松地创建一个图。
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![](../Images/d02837525b3e90fe7f3d360b1afb12a0.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d02837525b3e90fe7f3d360b1afb12a0.png)'
- en: Graph created from the matrix. Image by author.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从矩阵创建的图。图像由作者提供。
- en: You can also create matrices from a graph, common ones are the *incidence* and
    the *degree* matrix.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以从图中创建矩阵，常见的有*关联*矩阵和*度数*矩阵。
- en: 'Let’s replace the weights by the name of the edge:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用边的名称替换权重：
- en: '![](../Images/6474a10598f2a4eef6fa8e8a8946ccdf.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6474a10598f2a4eef6fa8e8a8946ccdf.png)'
- en: 'No we can create the incidence matrix, it has a row for each node and a column
    for each edge. It shows which nodes are connected by an edge:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建关联矩阵，它有一行对应每个节点，一列对应每条边。它显示了哪些节点通过边连接：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For a weighted graph, we can replace the ones by the weights of the corresponding
    edge.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于加权图，我们可以用相应边的权重替换一。
- en: 'The degree matrix is a diagonal matrix and counts the number of edges attached
    to each node. A loop is counted twice. For the previous graph, the degree matrix
    would be:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 度矩阵是对角矩阵，计算附加到每个节点的边的数量。一个回路算作两次。对于之前的图，度矩阵将是：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note: Official matrix form is without index row and index column. For clarity
    they are added.'
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意：官方矩阵形式没有索引行和索引列。为了清晰起见，已添加。
- en: '**Flows**'
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**流量**'
- en: 'Directed graphs often deal with network flows. E.g. in networks where data
    is transmitted, in transportation, or in pipelines. If you know how much the maximum
    capacity is between two nodes, you can create a network flow graph:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有向图常用于网络流动。例如在数据传输网络、交通运输或管道中。如果你知道两个节点之间的最大容量，你可以创建一个网络流图：
- en: '![](../Images/9d9ea1db92b424f260bf655ea772e076.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9d9ea1db92b424f260bf655ea772e076.png)'
- en: Digraph with Source (S) and Sink (T). Image by author.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有源点(S)和汇点(T)的有向图。图像由作者提供。
- en: The source (s) and the sink (t) are the starting and ending point of the flow.
    The edges are directed, they show the direction of the flow between nodes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 源点(s)和汇点(t)是流的起点和终点。边是有向的，它们显示了节点之间流动的方向。
- en: '**Tree graphs**'
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**树图**'
- en: 'A special type of graph is a tree graph. You can find them in many different
    places: competition schedules, family trees, organizational charts and evolutionary
    trees. A tree is *undirected*, *acyclic* and *connected*. It should not contain
    a cycle or directed edges, and all nodes are connected to the tree.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一种特殊类型的图是树图。你可以在许多不同的地方找到它们：比赛日程、家谱、组织结构图和进化树。树是*无向*、*无环*和*连通*的。它不应包含循环或有向边，所有节点都与树相连。
- en: '![](../Images/c52ee54b9ad721f05328968bf6bb1af1.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c52ee54b9ad721f05328968bf6bb1af1.png)'
- en: Three tree graphs. Image by author.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 三个树图。作者提供的图像。
- en: 'A tree has interesting properties:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 树具有有趣的属性：
- en: It always has `n-1` edges (where `n` is the number of nodes).
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它总是有`n-1`条边（其中`n`是节点的数量）。
- en: There is a unique path between any pair of nodes in a tree.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树中的任意一对节点之间都有一条唯一的路径。
- en: Removing a single edge will disconnect the graph (split the graph in two).
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除一条边将使图断开（将图分成两部分）。
- en: Social Network
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 社交网络
- en: 'Connections between people are nice to visualize in a graph. By analyzing relationships
    and visualizing them, you can extract valuable insights. Here is an example of
    7 people, if they are connected on social media, they are connected with an edge:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 人与人之间的联系在图中可视化起来很美好。通过分析和可视化关系，你可以提取有价值的见解。这里是 7 个人的一个例子，如果他们在社交媒体上相互连接，他们就通过一条边连接：
- en: '![](../Images/0ee53fe6222b84dbdda98c857e8eed8a.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0ee53fe6222b84dbdda98c857e8eed8a.png)'
- en: Network of people. Image by author.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 人员网络。作者提供的图像。
- en: 'Questions that can arise by looking at this graph are:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看此图表可能会出现的问题是：
- en: Who are the most important people?
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁是最重要的人物？
- en: Which persons are most similar to each other?
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些人最相似？
- en: Can we predict missing links?
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以预测缺失的链接吗？
- en: How can we cluster these people in the best way?
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何以最佳方式对这些人进行聚类？
- en: Common algorithms applied to graphs
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用于图的常见算法
- en: After modeling a situation as graph, you can solve the problem at hand. For
    the different examples in the previous paragraph, we will apply algorithms to
    find the shortest path, calculate the maximum flow and minimum cut, determine
    the minimum spanning tree and touch upon topics in graph analysis.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在将情况建模为图后，你可以解决手头的问题。对于上一段中的不同示例，我们将应用算法来寻找最短路径、计算最大流和最小割、确定最小生成树，并触及图分析中的话题。
- en: Shortest Path
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最短路径
- en: 'The first problem to solve is the shortest path problem: how should we go from
    A to B while keeping the route as short as possible?'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是最短路径问题：我们应该如何从 A 到 B，同时保持路径尽可能短？
- en: 'Let’s consider the following graph:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下图表：
- en: '![](../Images/94b7bbb0ece4b97fc359d5795d50456e.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/94b7bbb0ece4b97fc359d5795d50456e.png)'
- en: Graph. How to find the shortest route from A to I? Image by author.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图。如何从 A 找到到 I 的最短路线？作者提供的图像。
- en: 'An algorithm that is used often for solving this problem is Dijkstra’s algorithm.
    It works as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常用于解决此问题的算法是 Dijkstra 算法。其工作方式如下：
- en: '**Step 1.** The starting node has distance 0\. Set the rest of the nodes at
    distance infinity, this is their provisional distance. There are three types of
    nodes: *visited*, *unvisited* and the *current* node. For the first run the current
    node is the starting node.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 1.** 起始节点的距离为 0。将其余节点的距离设置为无穷大，这是它们的暂定距离。节点有三种类型：*已访问*、*未访问*和*当前*节点。在第一次运行中，当前节点是起始节点。'
- en: '![](../Images/c4021a0b7797c05874d7a395cc11549d.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c4021a0b7797c05874d7a395cc11549d.png)'
- en: Starting node is the yellow node with distance 0\. All other distances are set
    to infinity. Image by author.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 起始节点是黄色节点，距离为 0。所有其他距离设置为无穷大。作者提供的图像。
- en: '**Step 2.** Look at the direct neighbors of the current node and calculate
    the distance to them (via the current node). If this distance is smaller than
    the smallest distance so far, replace the old distance with the new distance.
    To discover the fastest route, mark the new route if the distance is accepted
    (and remove previous marked route if that exists).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 2.** 查看当前节点的直接邻居，并计算到它们的距离（通过当前节点）。如果这个距离小于迄今为止的最小距离，则用新距离替换旧距离。为了发现最快的路线，如果距离被接受，则标记新路线（并在存在时删除之前标记的路线）。'
- en: '![](../Images/e0f8b81e59126d0bb0e9d3196ae17289.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e0f8b81e59126d0bb0e9d3196ae17289.png)'
- en: Look at all the neighbors of the current node and replace the provisional distance
    with the new distance if the new distance is smaller. Mark the ‘accepted’ routes
    (routes with a shorter distance) green. Image by author.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 查看当前节点的所有邻居，如果新距离更小，则用新距离替换暂定距离。将“接受的”路线（距离较短的路线）标记为绿色。作者提供的图像。
- en: '**Step 3.** Now the first node can be marked as visited (green), and the new
    current node will be the unvisited node with the lowest provisional distance (yellow
    node in the image below has distance 1). Continue with step 2 for this node, and
    repeat step 2 and 3 until the end node is reached.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 3。** 现在可以将第一个节点标记为已访问（绿色），新的当前节点将是距离最短的未访问节点（下图中的黄色节点距离为 1）。对该节点继续执行步骤
    2，并重复步骤 2 和 3，直到达到终点。'
- en: '![](../Images/823498aaa7c22a5ac0844eb55194f0d3.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/823498aaa7c22a5ac0844eb55194f0d3.png)'
- en: New current node marked yellow. Previous yellow node marked as visited. Image
    by author.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 新的当前节点标记为黄色。以前的黄色节点标记为已访问。图片作者。
- en: '![](../Images/2e25af4b8a0f986e6302e3e44971eedd.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2e25af4b8a0f986e6302e3e44971eedd.png)'
- en: Step 2 applied for the second node. The upper node gets a new distance of 2,
    1+1 (because that is shorter than its provisional distance of 3). We can choose
    between the two yellow nodes for applying step 2 again. Image by author.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对第二个节点应用步骤 2。上面的节点得到新的距离 2，1+1（因为这比其暂定距离 3 更短）。我们可以在两个黄色节点中选择一个来再次应用步骤 2。图片作者。
- en: 'If we repeat these steps, in the end the solved graph looks like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重复这些步骤，最终解决后的图形如下所示：
- en: '![](../Images/3329717be2d40e6232ee892f116da381.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3329717be2d40e6232ee892f116da381.png)'
- en: Finding the shortest path with Dijkstra’s algorithm. Image by author.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Dijkstra 算法寻找最短路径。图片作者。
- en: Now we found the shortest distance from the start node to every other node,
    together with the corresponding routes (green edges)! Dijkstra’s algorithm is
    applied widely and popular because it is efficient and avoids unnecessary computations.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们找到了从起始节点到每个其他节点的最短距离，并附上了相应的路径（绿色边）！Dijkstra 算法被广泛应用并且受欢迎，因为它高效且避免了不必要的计算。
- en: There are many more fun shortest path problems, like the [Chinese postman problem](https://en.wikipedia.org/wiki/Chinese_postman_problem),
    where you have to discover the shortest route while visiting all edges, or the
    traveling salesman problem where you have to visit all the nodes. The traveling
    salesman problem can be solved in many different ways, for example with [mixed
    integer programming](/how-to-handle-optimization-problems-daf97b3c248c) (example
    2) or with [simulated annealing](/local-search-with-simulated-annealing-from-scratch-9f8dcb6c2e06)
    (example 1).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多有趣的最短路径问题，例如[中国邮差问题](https://en.wikipedia.org/wiki/Chinese_postman_problem)，在这个问题中，你需要在访问所有边的同时发现最短路径，或者旅行推销员问题，在这个问题中你需要访问所有节点。旅行推销员问题可以通过许多不同的方法来解决，例如使用[混合整数规划](/how-to-handle-optimization-problems-daf97b3c248c)（示例
    2）或使用[模拟退火](/local-search-with-simulated-annealing-from-scratch-9f8dcb6c2e06)（示例
    1）。
- en: Maximum Flow & Minimum Cut
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最大流与最小割
- en: 'An important question in flow graphs is: How much flow can be send from the
    source to the sink? The weights at the edges correspond to the capacity of an
    edge and those capacities can never be exceeded. The incoming flow for every node
    should be equal to the outgoing flow (except for the source and the sink).'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在流图中，一个重要的问题是：从源点到汇点可以发送多少流量？边的权重对应于边的容量，这些容量永远不会被超过。每个节点的流入流量应该等于流出流量（源点和汇点除外）。
- en: 'Below an example of a maximum flow problem:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个最大流问题的示例：
- en: '![](../Images/9d9ea1db92b424f260bf655ea772e076.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9d9ea1db92b424f260bf655ea772e076.png)'
- en: Digraph with Source (S) and Sink (T). Image by author.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 带有源点（S）和汇点（T）的有向图。图片作者。
- en: How can we solve this problem and discover how much flow can reach the sink?
    There are several different algorithms for this. Let’s solve this using the Ford-Fulkerson
    algorithm.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何解决这个问题，并发现有多少流量可以到达汇点？对此有几种不同的算法。我们使用 Ford-Fulkerson 算法来解决这个问题。
- en: '**Step 1\.** Set the initial capacity to 0 on all edges.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 1。** 将所有边的初始容量设置为 0。'
- en: '![](../Images/f1fceb180090220f6a7f0025ac9a2119.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f1fceb180090220f6a7f0025ac9a2119.png)'
- en: Initial capacity set to 0 for all edges. Image by author.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有边的初始容量设置为 0。图片作者。
- en: '**Step 2\.** Find an *augmenting path* from source to sink. This is a path
    that has unused capacity greater than 0 on all edges and starts at the source
    and ends at the sink. You can find augmenting paths with e.g. breadth first search
    or depth first search.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 2。** 找到一个*增广路径*从源点到汇点。这是一条所有边的未使用容量大于 0 的路径，起点是源点，终点是汇点。你可以通过例如广度优先搜索或深度优先搜索来找到增广路径。'
- en: '![](../Images/d9d66ca94bf472638b9736c05d70586e.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d9d66ca94bf472638b9736c05d70586e.png)'
- en: An augmenting path from source to sink. Image by author.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从源点到汇点的增广路径。图片作者。
- en: '**Step 3.** For the augmenting path from step 2, we can find the *bottleneck*,
    this is the edge with the smallest remaining capacity. We increase the capacity
    on all edges for the augmenting path with this value.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 3.** 对于步骤 2 中的增广路径，我们可以找到*瓶颈*，即剩余容量最小的边。我们用这个值增加增广路径上所有边的容量。'
- en: '![](../Images/cf46b69723e15b812a677a219b029fca.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/cf46b69723e15b812a677a219b029fca.png)'
- en: Capacity increased with 3 (value of the bottleneck edge). Image by author.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 容量增加了 3（瓶颈边的值）。图像由作者提供。
- en: '**Step 4\.** Continue with step 2 and 3 until there is no augmenting path left.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 4\.** 继续执行步骤 2 和 3，直到没有增广路径。'
- en: '![](../Images/d698ad0a957a8d8556bd033706c36f7c.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d698ad0a957a8d8556bd033706c36f7c.png)'
- en: Another augmented path with updated capacity of 5\. 5 was the lowest remaining
    capacity for the edges, so the capacities are updated with 5\. Image by author.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个增广路径，更新后的容量为 5。5 是边缘中剩余容量最低的，因此容量更新为 5。图像由作者提供。
- en: 'After continuing doing this, in the end there are no more augmenting paths
    possible. The end result can look like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续这样做之后，最终不会再有增广路径。最终结果可能如下所示：
- en: '![](../Images/13c978dc1ef11bcae776d9e1f67cb001.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/13c978dc1ef11bcae776d9e1f67cb001.png)'
- en: Solved! There are more solutions possible that will yield the same result. Image
    by author.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 已解决！还存在其他可能的解决方案，可以得到相同的结果。图像由作者提供。
- en: The maximum flow is easily found by adding 11 + 1 + 4 = 16\. These are the flows
    of the edges directed to the sink. This problem can also be solved with [linear
    programming](/a-beginners-guide-to-linear-programming-and-the-simplex-algorithm-87db017e92b4).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最大流量可以通过计算 11 + 1 + 4 = 16 很容易得到。这些是指向汇点的边的流量。这个问题也可以通过[线性规划](/a-beginners-guide-to-linear-programming-and-the-simplex-algorithm-87db017e92b4)来解决。
- en: Related to maximum flow is *minimum cut*. The minimum cut is finding the lowest
    sum of weight of connections you need to disconnect to split the network into
    two separate parts. It is closely related to maximum flow, because when you found
    the solution of maximum flow, you can derive the minimum cut as well. They are
    equal to each other.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与最大流相关的是*最小割*。最小割是找到将网络分成两个独立部分所需断开的连接的权重总和的最小值。它与最大流密切相关，因为当你找到了最大流的解决方案时，你也可以推导出最小割。它们是相等的。
- en: '![](../Images/df848de2f4b4c6ca7175b6b5e72552ea.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/df848de2f4b4c6ca7175b6b5e72552ea.png)'
- en: Minimum cut. Divide the graph in two pieces while trying to minimize the sum
    of the weight of the removed edges. The weight of the edges removed in this image
    is the minimum cut, which is the same as the value of the maximum flow, 16 in
    this example. Image by author.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最小割。将图分成两部分，同时尽量减少移除边的权重总和。这个图像中移除的边的权重就是最小割，这与最大流的值相同，在这个例子中为 16。图像由作者提供。
- en: Minimum cut is used in image segmentation, for example to separate an object
    from the background. Another critical application of minimum cut is analyzing
    the reliability of complex networks, such as power grids or communication networks,
    by identifying critical edges whose failure can lead to network disconnection
    or reduced performance.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最小割用于图像分割，例如将对象与背景分离。最小割的另一个重要应用是分析复杂网络的可靠性，例如电网或通信网络，通过识别关键边缘，这些边缘的故障可能导致网络断开或性能下降。
- en: Minimum Spanning Tree
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小生成树
- en: 'Imagine you are the boss of a railway company and you want to discover how
    to connect seven cities with the lowest amount of railway possible. What you are
    looking for in this case is the *minimum spanning tree*. If we visualize this
    problem it looks like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你是一个铁路公司的老板，你想要找出如何用最少的铁路连接七个城市。在这种情况下，你要找的是*最小生成树*。如果我们可视化这个问题，它看起来像这样：
- en: '![](../Images/c9902afe0c0ec93db5e37f751ca29b5b.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c9902afe0c0ec93db5e37f751ca29b5b.png)'
- en: Connected cities. Image by author.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 连接的城市。图像由作者提供。
- en: How can we calculate the minimum spanning tree in this graph? We can use Prim’s
    algorithm, which is a greedy algorithm and quite easy to understand.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何计算这个图中的最小生成树？我们可以使用 Prim 算法，这是一种贪心算法，比较容易理解。
- en: '**Step 1\.** Choose one node of the graph to start with, arbitrarily. This
    node is the first part of the tree.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 1\.** 随意选择图中的一个节点作为起点。这个节点是树的第一部分。'
- en: '![](../Images/a13040379c843fc6f9db996c36aee509.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a13040379c843fc6f9db996c36aee509.png)'
- en: Red house chosen to start with.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 选择红色房子作为起点。
- en: '**Step 2.** Grow the tree by one edge. Select the edge that has the minimum
    weight of all edges connected to the tree.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 2.** 通过一条边扩展树。选择与树连接的所有边中权重最小的边。'
- en: '![](../Images/379936dde32d3e3bbe9fd4eb817760ff.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/379936dde32d3e3bbe9fd4eb817760ff.png)'
- en: Selected edge. Smallest edge from the city in the center. The house on the top
    right is also in the tree. Image by author.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 选择的边。来自中心城市的最小边。右上角的房子也在树中。图片来源于作者。
- en: '**Step 3.** Repeat step 2 until all nodes are in the tree.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 3.** 重复步骤 2，直到所有节点都在树中。'
- en: 'The next edge we select is the one with weight 3:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们选择的边是权重为3的边：
- en: '![](../Images/77c8c84da675c5ee12991d1887929e22.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/77c8c84da675c5ee12991d1887929e22.png)'
- en: Tree is growing… Image by author.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 树在生长中…… 图片来源于作者。
- en: In the end, we found the minimum spanning tree with a total length of 17.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们找到了总长度为17的最小生成树。
- en: '![](../Images/3a50165122e0cc6d8c67f56272c7d2be.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3a50165122e0cc6d8c67f56272c7d2be.png)'
- en: Final tree in red. Image by author.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的树用红色表示。图片来源于作者。
- en: The minimum spanning tree has many different applications. The most straightforward
    one is network design, when a network has to be fully connected with the lowest
    weight. Examples of such networks are telecommunication networks, computer networks,
    electrical power distribution systems and transportation networks. Did you know
    that minimum spanning trees are also used in taxonomy, cluster analysis, feature
    extraction for computer vision and in handwriting recognition? If you dive into
    the applications of minimum spanning trees, you discover there are quite a lot!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最小生成树有许多不同的应用。最直接的应用是网络设计，当一个网络必须以最低的权重完全连接时。这样的网络例子包括电信网络、计算机网络、电力分配系统和交通网络。你知道最小生成树也用于分类学、聚类分析、计算机视觉中的特征提取和手写识别吗？如果你深入研究最小生成树的应用，你会发现还有很多其他应用！
- en: Centrality & Similarity
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中心性与相似性
- en: Graph analysis leverages the tools and techniques developed in graph theory
    to gain insights and make informed decisions in different domains, such as social
    networks, transportation networks, computer networks, biology, and many others.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图分析利用图论中开发的工具和技术，以在不同领域（如社交网络、交通网络、计算机网络、生物学等）获得洞察力和做出明智的决策。
- en: Centrality and similarity are two core concepts in graph analysis. You might
    have heard of the [PageRank algorithm](https://en.wikipedia.org/wiki/PageRank)
    used by Google Search. PageRank is a centrality algorithm used to measure the
    importance or influence of nodes in a network, particularly in web page ranking
    and hyperlink analysis. It assigns a numerical score to each node based on the
    number and quality of incoming links, helping identify key nodes in a network.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 中心性和相似性是图分析中的两个核心概念。你可能听说过谷歌搜索使用的[PageRank算法](https://en.wikipedia.org/wiki/PageRank)。PageRank是一种中心性算法，用于测量网络中节点的重要性或影响力，特别是在网页排名和超链接分析中。它根据每个节点的入链数量和质量分配一个数值评分，从而帮助识别网络中的关键节点。
- en: '*Betweenness centrality* is another measure of centrality. The node with the
    highest betweenness centrality acts as the most important bridge among all the
    other nodes. To find the betweenness centrality of a node, we need to look at
    all the pairs of nodes and see how many times each node appears on the shortest
    path between two other nodes. The node who appears on the most shortest paths
    is the one with the highest betweenness centrality.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*介数中心性*是另一种中心性测量方法。具有最高介数中心性的节点在所有其他节点之间充当最重要的桥梁。要找出一个节点的介数中心性，我们需要查看所有节点对，计算每个节点出现在两个其他节点之间的最短路径上的次数。出现在最多最短路径上的节点就是具有最高介数中心性的节点。'
- en: '![](../Images/4de586827c31eed4ca3c1a77152da603.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4de586827c31eed4ca3c1a77152da603.png)'
- en: Graph with nodes and betweenness centrality for every node. Image by author.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 带有节点及每个节点的介数中心性的图。图片来源于作者。
- en: In social networks or real-world systems, nodes (e.g. people, places, or entities)
    with high betweenness centrality play a crucial role in maintaining communication
    and connections between different parts of the network. They act as important
    mediators, ensuring efficient communication and keeping the network connected.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在社交网络或现实世界系统中，具有高介数中心性的节点（例如，人员、地点或实体）在维持网络中不同部分之间的通信和连接方面发挥着至关重要的作用。它们充当重要的中介，确保高效的沟通并保持网络连接。
- en: It can also be useful to find out how similar certain nodes are. This can be
    done by calculating *node similarity*. Jaccard Similarity is often used for unweighted
    graphs. It calculates the similarity between two nodes based on the number of
    common neighbors they share, divided by the total number of unique neighbors they
    have.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 了解某些节点的相似性也很有用。这可以通过计算*节点相似性*来完成。Jaccard 相似度通常用于无权图。它通过计算两个节点共享的共同邻居数量与它们拥有的唯一邻居总数之比来衡量相似性。
- en: Let’s calculate the Jaccard Similarity for node 2 and 4 in the graph. They share
    2 neighbors (node 3 and 5), and the total number of unique neighbors is 5 (node
    1, 2, 3, 4 and 5). 2 divided by 5 gives a Jaccard Similarity of 0.4.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们计算图中节点 2 和 4 的 Jaccard 相似度。它们共享 2 个邻居（节点 3 和 5），总的唯一邻居数量是 5（节点 1、2、3、4 和
    5）。2 除以 5 得到的 Jaccard 相似度为 0.4。
- en: Node similarity is used in collaborative filtering techniques to recommend items
    to users based on the similarity of their preferences with other users. It can
    also be used to predict missing or future links in a network or for detecting
    clusters and communities.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 节点相似性用于协同过滤技术，通过根据用户偏好的相似性向用户推荐项目。它还可以用于预测网络中的缺失或未来链接，或者用于检测簇和社区。
- en: What’s next?
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下一步是什么？
- en: This was just a glimpse into the world of graph theory and graph analysis. Beyond
    what we’ve explored here, there are many more exciting problems and applications
    waiting to be discovered. The beauty of graph theory lies in its versatility;
    it offers a way to tackle real-world challenges by transforming them into graph-based
    puzzles solvable with clever algorithms.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是图论和图分析世界的一瞥。在我们探索的内容之外，还有许多更多令人兴奋的问题和应用等待发现。图论的美在于其多样性；它提供了一种通过将现实世界挑战转化为可用巧妙算法解决的图形谜题的方式。
- en: From social networks to logistics, countless real-world problems find their
    perfect match in the realm of graphs. Unraveling communities, uncovering hidden
    connections, and exploring the unique properties of different graph types are
    interesting aspects of graph theory.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从社交网络到物流，许多现实世界的问题在图的领域中找到完美的匹配。揭示社区、发现隐藏的联系以及探索不同图类型的独特属性是图论中有趣的方面。
- en: In the realm of data science, graphs become allies, enabling the creation of
    features that can have a huge impact on model performance. Graph embeddings hold
    the key to unlocking new dimensions of understanding within vast datasets.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据科学领域，图成为盟友，使得创建可以对模型性能产生巨大影响的特征成为可能。图嵌入是解锁广泛数据集中新维度理解的关键。
- en: Hopefully, this post made you curious to dive deeper into the wonders of graph
    theory!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这篇文章能激发你对图论奇妙世界的好奇心！
- en: Related
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: '[](/four-ways-to-combine-mathematical-optimization-and-machine-learning-8cb874276254?source=post_page-----7364e082a984--------------------------------)
    [## Five ways to combine Mathematical Optimization and Machine Learning'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[## 五种数学优化与机器学习结合的方法](https://towardsdatascience.com/four-ways-to-combine-mathematical-optimization-and-machine-learning-8cb874276254?source=post_page-----7364e082a984--------------------------------)'
- en: Practical examples of combining two forces.
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结合两种力量的实际例子。
- en: towardsdatascience.com](/four-ways-to-combine-mathematical-optimization-and-machine-learning-8cb874276254?source=post_page-----7364e082a984--------------------------------)
    [](/constraint-programming-explained-2882dc3ad9df?source=post_page-----7364e082a984--------------------------------)
    [## Constraint Programming Explained
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[## 约束编程解释](https://towardsdatascience.com/constraint-programming-explained-2882dc3ad9df?source=post_page-----7364e082a984--------------------------------)'
- en: The core of a constraint programming solver and the relationship with mixed
    integer programming
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 约束编程求解器的核心及其与混合整数编程的关系
- en: 'towardsdatascience.com](/constraint-programming-explained-2882dc3ad9df?source=post_page-----7364e082a984--------------------------------)
    [](/an-introduction-to-a-powerful-optimization-technique-simulated-annealing-87fd1e3676dd?source=post_page-----7364e082a984--------------------------------)
    [## An Introduction to a Powerful Optimization Technique: Simulated Annealing'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[## 强大优化技术介绍：模拟退火](https://towardsdatascience.com/an-introduction-to-a-powerful-optimization-technique-simulated-annealing-87fd1e3676dd?source=post_page-----7364e082a984--------------------------------)'
- en: Explanation, parameters, strengths, weaknesses and use cases
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释、参数、优点、缺点和使用案例
- en: towardsdatascience.com](/an-introduction-to-a-powerful-optimization-technique-simulated-annealing-87fd1e3676dd?source=post_page-----7364e082a984--------------------------------)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[关于模拟退火——一种强大的优化技术介绍](https://towardsdatascience.com/an-introduction-to-a-powerful-optimization-technique-simulated-annealing-87fd1e3676dd?source=post_page-----7364e082a984--------------------------------)'
