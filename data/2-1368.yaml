- en: Is Julia Faster than Python and Numba?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Julia比Python和Numba更快吗？
- en: 原文：[https://towardsdatascience.com/is-julia-faster-than-python-and-numba-897c53694621](https://towardsdatascience.com/is-julia-faster-than-python-and-numba-897c53694621)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/is-julia-faster-than-python-and-numba-897c53694621](https://towardsdatascience.com/is-julia-faster-than-python-and-numba-897c53694621)
- en: Optimisation
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化
- en: Numba is very fast, but is it fast enough?
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Numba非常快速，但它够快吗？
- en: '[](https://medium.com/@maclayton?source=post_page-----897c53694621--------------------------------)[![Mike
    Clayton](../Images/2d37746b13b7d2ff1c6515893914da97.png)](https://medium.com/@maclayton?source=post_page-----897c53694621--------------------------------)[](https://towardsdatascience.com/?source=post_page-----897c53694621--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----897c53694621--------------------------------)
    [Mike Clayton](https://medium.com/@maclayton?source=post_page-----897c53694621--------------------------------)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@maclayton?source=post_page-----897c53694621--------------------------------)[![Mike
    Clayton](../Images/2d37746b13b7d2ff1c6515893914da97.png)](https://medium.com/@maclayton?source=post_page-----897c53694621--------------------------------)[](https://towardsdatascience.com/?source=post_page-----897c53694621--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----897c53694621--------------------------------)
    [Mike Clayton](https://medium.com/@maclayton?source=post_page-----897c53694621--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----897c53694621--------------------------------)
    ·16 min read·Sep 19, 2023
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: ·发布于[数据科学前沿](https://towardsdatascience.com/?source=post_page-----897c53694621--------------------------------)
    ·16分钟阅读·2023年9月19日
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/69fa7749831310e9eb6a02054d9ee87d.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/69fa7749831310e9eb6a02054d9ee87d.png)'
- en: Photo by [Stanos](https://unsplash.com/@stan_remnev?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
    on [Unsplash](https://unsplash.com/photos/2Yj6MBvJ0sg?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图片来源：[Stanos](https://unsplash.com/@stan_remnev?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)于[Unsplash](https://unsplash.com/photos/2Yj6MBvJ0sg?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
- en: '**Numba is a widely used optimisation library for Python that elevates function
    execution times into the same ballpark as the C language, and C is undoubtedly
    rapid.**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**Numba是一个广泛使用的Python优化库，它将函数执行时间提升到接近C语言的水平，而C语言毫无疑问是快速的。**'
- en: '**Is that level of optimisation enough to compete with a newer, purpose built,
    targeted language like Julia? And if so, are there any caveats to achieving that
    level of execution speed in Python?**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**这种优化水平足以与像Julia这样较新的、专门构建的目标语言竞争吗？如果是的话，在Python中实现这种执行速度是否有任何陷阱？**'
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: '![](../Images/4aa570daa0aa0c472205cffbdcfa200e.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4aa570daa0aa0c472205cffbdcfa200e.png)'
- en: Photo by [Ann H](https://www.pexels.com/photo/yellow-letter-tiles-1888003/)
    on [Pexels](https://www.pexels.com/#)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图片来源：[Ann H](https://www.pexels.com/photo/yellow-letter-tiles-1888003/)于[Pexels](https://www.pexels.com/#)
- en: 'I have previously written an [article comparing NumPy to Julia](/is-julia-really-faster-than-python-and-numpy-242e0a5fe34f).
    The outcome was essentially that Julia is indeed faster than NumPy, in general.
    However, it is a bit more nuanced than that, so I encourage you to check out the
    article to get the whole story:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前写过一篇[对比NumPy和Julia的文章](/is-julia-really-faster-than-python-and-numpy-242e0a5fe34f)。结果基本上是Julia确实比NumPy快，总体而言。然而，事情比这更复杂一点，所以我建议你查看那篇文章，了解详细信息：
- en: '[](/is-julia-really-faster-than-python-and-numpy-242e0a5fe34f?source=post_page-----897c53694621--------------------------------)
    [## Is Julia Really Faster than Python and Numpy?'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[](/is-julia-really-faster-than-python-and-numpy-242e0a5fe34f?source=post_page-----897c53694621--------------------------------)
    [## Julia真的比Python和Numpy更快吗？'
- en: The speed of C with the simplicity of Python
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C语言的速度与Python的简单性
- en: towardsdatascience.com](/is-julia-really-faster-than-python-and-numpy-242e0a5fe34f?source=post_page-----897c53694621--------------------------------)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: towardsdatascience.com](/is-julia-really-faster-than-python-and-numpy-242e0a5fe34f?source=post_page-----897c53694621--------------------------------)
- en: 'One of the most common responses to that article was something along the lines
    of:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对那篇文章最常见的回应之一是类似于：
- en: Well you should also use Numba. It is simple to implement, and makes things
    even faster!
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 好吧，你也应该使用Numba。它实现简单，而且更快！
- en: ''
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -quite a few people
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: -相当多人
- en: …so this article is going to attempt to address that suggestion head on.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: …因此这篇文章将直接尝试解决这个建议。
- en: Does using Numba match, or even exceed, the speed of Julia? Is it as easy to
    use and implement as people seem to claim? And, are there any downsides?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Numba是否能与Julia的速度相匹配，甚至超越？它是否像人们声称的那样易于使用和实现？而且，有什么缺点吗？
- en: Let’s find out…
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看……
- en: A quick primer on Julia
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于Julia的简要介绍
- en: '![](../Images/0d756d1fe48b6f81c08fe8e1cfc26c38.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0d756d1fe48b6f81c08fe8e1cfc26c38.png)'
- en: Photo by [Ann H](https://www.pexels.com/photo/yellow-letter-tiles-1888003/)
    on [Pexels](https://www.pexels.com/#)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[Ann H](https://www.pexels.com/photo/yellow-letter-tiles-1888003/) 在 [Pexels](https://www.pexels.com/#)
    上的照片'
- en: As some of you may not have read the [previous article about NumPy](/is-julia-really-faster-than-python-and-numpy-242e0a5fe34f),
    I will repeat the “What is Julia?” section included in that article here, but
    feel free to skip ahead if you have already read the previous article.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你们中的一些人可能还没有阅读[关于NumPy的前一篇文章](/is-julia-really-faster-than-python-and-numpy-242e0a5fe34f)，我将重复那篇文章中包含的“什么是Julia？”部分，但如果你已经阅读了前一篇文章，可以随意跳过。
- en: What is Julia?
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是Julia？
- en: Just in case you have no idea what Julia is, here is a quick primer.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对Julia一无所知，这里有一个快速入门指南。
- en: '[Julia](https://julialang.org/) is an open source language that is dynamically
    typed, intuitive, and easy to use like Python, but with the speed of execution
    of a language like C.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[Julia](https://julialang.org/) 是一种开源语言，具有动态类型、直观且易于使用的特点，类似于Python，但执行速度如同C语言一般。'
- en: It has been around approximately 11 years (born in 2012), so it is a relatively
    new language. However, it is at a stage of maturity where you wouldn’t call it
    a fad.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 它已经存在大约11年（诞生于2012年），所以它是一种相对较新的语言。然而，它已经发展到一个成熟的阶段，你不会把它称作是一时的潮流。
- en: 'The original creators of the language are active in a relevant field of work:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 语言的原始创造者活跃于相关领域的工作中：
- en: For the work we do — scientific computing, machine learning, data mining, large-scale
    linear algebra, distributed and parallel computing — …
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于我们所做的工作——科学计算、机器学习、数据挖掘、大规模线性代数、分布式和并行计算——…
- en: ''
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '- [julialang.org](https://julialang.org/blog/2012/02/why-we-created-julia/)
    — Jeff Bezanson, Stefan Karpinski, Viral B. Shah, Alan Edelman'
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '- [julialang.org](https://julialang.org/blog/2012/02/why-we-created-julia/)
    — Jeff Bezanson, Stefan Karpinski, Viral B. Shah, Alan Edelman'
- en: 'All in all, it is a **modern language specifically designed to be used in the
    field of data science**. The aims of the creators themselves tell you a great
    deal:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，它是一种**专门为数据科学领域设计的现代语言**。创造者的目标本身就能告诉你很多东西：
- en: We want the speed of C with the dynamism of Ruby. We want a language that’s
    homoiconic, with true macros like Lisp, but with obvious, familiar mathematical
    notation like Matlab. We want something as usable for general programming as Python,
    as easy for statistics as R, as natural for string processing as Perl, as powerful
    for linear algebra as Matlab, as good at gluing programs together as the shell.
    Something that is dirt simple to learn, yet keeps the most serious hackers happy.
    We want it interactive and we want it compiled.
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们希望拥有C的速度和Ruby的动态特性。我们希望有一种语言，它是同构的，具有类似Lisp的真正宏，但也具备像Matlab那样明显的、熟悉的数学符号。我们希望它像Python一样适用于通用编程，像R一样适合统计，像Perl一样自然地处理字符串，像Matlab一样强大地进行线性代数，像shell一样擅长将程序粘合在一起。我们希望它易于学习，同时能够让最严肃的黑客感到满意。我们希望它既具交互性又具编译性。
- en: ''
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (Did we mention it should be as fast as C?)
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: （我们提到过它应该和C一样快吗？）
- en: ''
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '- [julialang.org](https://julialang.org/blog/2012/02/why-we-created-julia/)
    — Jeff Bezanson, Stefan Karpinski, Viral B. Shah, Alan Edelman'
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '- [julialang.org](https://julialang.org/blog/2012/02/why-we-created-julia/)
    — Jeff Bezanson, Stefan Karpinski, Viral B. Shah, Alan Edelman'
- en: Sounds quite exciting right?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来很令人兴奋，对吧？
- en: '*Incidentally, if you want an idea as to how Python and Julia compare side-by-side
    in terms of syntax and general usage, then you may want to check out my other
    article, which takes an in depth look at running a deep learning image classification
    problem using both Julia (Flux) and Python (TensorFlow):*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*顺便说一下，如果你想了解Python和Julia在语法和一般使用方面的对比，那么你可以查看我的另一篇文章，该文章深入探讨了使用Julia（Flux）和Python（TensorFlow）解决深度学习图像分类问题的情况：*'
- en: '[](/julias-flux-vs-python-s-tensorflow-how-do-they-compare-574a3fb5e059?source=post_page-----897c53694621--------------------------------)
    [## Julia’s Flux vs Python’s TensorFlow: How Do They Compare?'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[](/julias-flux-vs-python-s-tensorflow-how-do-they-compare-574a3fb5e059?source=post_page-----897c53694621--------------------------------)
    [## Julia的Flux与Python的TensorFlow：它们如何比较？'
- en: An end-to-end deep learning project comparison
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个端到端深度学习项目的比较
- en: towardsdatascience.com](/julias-flux-vs-python-s-tensorflow-how-do-they-compare-574a3fb5e059?source=post_page-----897c53694621--------------------------------)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[towardsdatascience.com](/julias-flux-vs-python-s-tensorflow-how-do-they-compare-574a3fb5e059?source=post_page-----897c53694621--------------------------------)'
- en: What is Numba, and why is it so fast (and popular)?
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Numba是什么，它为什么如此快速（以及受欢迎）？
- en: '![](../Images/2a1aaf170dbbf7c9485d0cd5023662a6.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2a1aaf170dbbf7c9485d0cd5023662a6.png)'
- en: Photo by [Towfiqu barbhuiya](https://unsplash.com/@towfiqu999999?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
    on [Unsplash](https://unsplash.com/photos/oZuBNC-6E2s?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由 [Towfiqu barbhuiya](https://unsplash.com/@towfiqu999999?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
    提供，在 [Unsplash](https://unsplash.com/photos/oZuBNC-6E2s?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
- en: The idea behind Numba is extremely simple.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Numba的理念极其简单。
- en: 'Pre-compile the Python code to machine code, and execute the compiled code
    rather than the Python code. Or for a little more detail:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 将Python代码预编译为机器代码，并执行编译后的代码，而不是Python代码。或者更详细地说：
- en: Numba translates Python functions to optimized machine code at runtime using
    the industry-standard [LLVM](https://llvm.org/) compiler library. Numba-compiled
    numerical algorithms in Python can approach the speeds of C or FORTRAN.
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Numba使用行业标准的 [LLVM](https://llvm.org/) 编译器库，将Python函数翻译为优化后的机器代码。用Numba编译的Python数值算法可以接近C或FORTRAN的速度。
- en: ''
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -[numba.pydata.org](https://numba.pydata.org/)
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: -[numba.pydata.org](https://numba.pydata.org/)
- en: To approach the speed of C (or FORTRAN) by definition means that Numba is indeed
    going to be extremely fast.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要接近C（或FORTRAN）的速度，意味着Numba确实会非常快。
- en: Implementation is (generally) easy
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现（通常）很简单
- en: 'One of the major pluses to the way Numba is implemented is that it is, in most
    cases, very easy to use. Here is an example of a normal Python function, and then
    the equivalent Numba function:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Numba实现方式的一个主要优点是，在大多数情况下，它非常易于使用。以下是一个普通Python函数的例子，以及相应的Numba函数：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Literally a single decorator! It would appear to be verging on criminal not
    to implement Numba on every function. (more on the reality of that later…)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上只需一个装饰器！似乎不在每个函数上实现Numba就有些不妥。（稍后会更多地讲到现实情况……）
- en: So should I replace NumPy with Numba?
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那我应该用Numba替换NumPy吗？
- en: Numba is not a replacement, or alternative, to NumPy. It is designed to be utilised
    **in addition** to NumPy.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Numba不是NumPy的替代品或替代选择。它的设计目的是**补充**NumPy。
- en: Numba is designed to be used with NumPy arrays and functions. Numba generates
    specialized code for different array data types and layouts to optimize performance.
    Special decorators can create [universal functions](https://docs.scipy.org/doc/numpy/reference/ufuncs.html)
    that broadcast over NumPy arrays just like NumPy functions do.
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Numba旨在与NumPy数组和函数一起使用。Numba为不同的数组数据类型和布局生成专门的代码，以优化性能。特殊的装饰器可以创建 [通用函数](https://docs.scipy.org/doc/numpy/reference/ufuncs.html)，这些函数可以像NumPy函数一样对NumPy数组进行广播。
- en: ''
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[-numba.pydata.org](https://numba.pydata.org/)'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[-numba.pydata.org](https://numba.pydata.org/)'
- en: This is excellent, as NumPy is already extremely powerful, and Numba just elevates
    it even further. Plus, there is no requirement to re-write all your NumPy code
    if you decide you want to utilise Numba.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常出色，因为NumPy已经非常强大，而Numba进一步提升了它的性能。此外，如果你决定使用Numba，也不需要重新编写所有的NumPy代码。
- en: Numba’s other tricks
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Numba的其他技巧
- en: 'The compilation step is only the start. Numba has an extensive set of additional
    features that can potentially further increase execution speed. Some examples:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 编译步骤只是开始。Numba具有一整套附加功能，可以进一步提高执行速度。一些例子：
- en: '[***Parallel processing***](https://numba.readthedocs.io/en/stable/user/parallel.html)—
    if you have a CPU with multiple cores, you can potentially use them in parallel
    to speed up processing'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[***并行处理***](https://numba.readthedocs.io/en/stable/user/parallel.html)— 如果你的CPU有多个核心，你可以利用它们进行并行处理，以加快计算速度'
- en: '[***Fastmath***](https://numba.readthedocs.io/en/stable/user/performance-tips.html#fastmath)
    — reduce numerical accuracy to gain speed of execution'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[***快速数学***](https://numba.readthedocs.io/en/stable/user/performance-tips.html#fastmath)
    — 减少数值精度以提高执行速度'
- en: '[***Cache***](https://numba.readthedocs.io/en/stable/user/jit.html#cache) —
    save compiled code in a cache to reduce compile overhead on repeat future usage'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[***缓存***](https://numba.readthedocs.io/en/stable/user/jit.html#cache) — 将编译后的代码保存在缓存中，以减少重复使用时的编译开销'
- en: '[***CUDA***](https://numba.readthedocs.io/en/stable/cuda/index.html)— Use your
    GPU for your calculations'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[***CUDA***](https://numba.readthedocs.io/en/stable/cuda/index.html)— 利用你的GPU进行计算'
- en: There are of course more options than the four above, and plenty of customisation
    should you need it. This article will primarily focus on parallel processing and
    Fastmath from the list above.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，除了上述四个选项之外，还有更多的选择，如果需要的话，还可以进行大量的自定义。本文将主要关注上面列表中的并行处理和 Fastmath。
- en: Using a GPU (CUDA) warrants a whole other article to do it justice, so that
    won’t be covered in this article.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GPU (CUDA) 需要另外一篇文章来详细说明，因此在这篇文章中不会涉及。
- en: The disadvantages
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺点
- en: There are two main negative points to Numba.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Numba 主要有两个负面点。
- en: The first, and most obvious, is that **compilation is required**, and compilation
    takes time.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个也是最明显的，就是**需要编译**，而且编译需要时间。
- en: If the function is only executed once, the compilation time may be a significant
    disadvantage. However, if the code requires repeat usage of the compiled function
    (like in a loop), then the disadvantage could become negligible. It all depends
    on the circumstances.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数只执行一次，那么编译时间可能是一个显著的缺点。然而，如果代码需要重复使用编译的函数（例如在循环中），那么这个缺点可能会变得微不足道。这完全取决于情况。
- en: …compilation is required, and compilation takes time.
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: …需要编译，而且编译需要时间。
- en: The second, as per the quote directly from the Numba website itself, is that
    Numba can only be implemented on functions it is designed to be used with.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个，根据直接来自 Numba 网站的引用，是 Numba 只能在其设计用于的函数上实现。
- en: Numba is an open source JIT compiler that translates **a subset of Python and
    NumPy code** into fast machine code.
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Numba 是一个开源 JIT 编译器，将**Python 和 NumPy 代码的一个子集**翻译成快速的机器代码。
- en: ''
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[-numba.pydata.org](https://numba.pydata.org/)'
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[-numba.pydata.org](https://numba.pydata.org/)'
- en: I will point out that the functions available are quite extensive, so you may
    not find that this is an issue, but it is a negative point all the same. There
    is also quite a bit of in built flexibility to allow custom code to be written,
    such as [NumPy ufuncs](https://numba.readthedocs.io/en/stable/user/vectorize.html#).
    So there are some workarounds if you do have quite unique requirements.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我会指出，虽然提供的函数非常丰富，因此你可能不会觉得这是个问题，但这仍然是一个负面点。此外，还有相当多的内置灵活性，允许编写自定义代码，比如 [NumPy
    ufuncs](https://numba.readthedocs.io/en/stable/user/vectorize.html#)。因此，如果你有非常独特的需求，也有一些变通办法。
- en: The basis of the speed test
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 速度测试的基础
- en: '![](../Images/5c49768600b5c778213e8806c5df4352.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5c49768600b5c778213e8806c5df4352.png)'
- en: Image by [StockSnap](https://pixabay.com/users/stocksnap-894430/?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=2606859)
    from [Pixabay](https://pixabay.com//?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=2606859)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图片来源 [StockSnap](https://pixabay.com/users/stocksnap-894430/?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=2606859)
    [Pixabay](https://pixabay.com//?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=2606859)
- en: As alluded to in the introduction to this article, this particular article is
    the culmination of two previous articles.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本文开头所提到的，这篇文章实际上是两篇之前文章的汇总。
- en: 'The first provides a guide on how to utilise NumPy vectorization to speed up
    your Python code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个提供了如何利用 NumPy 矢量化来加速你的 Python 代码的指南：
- en: '[](/how-to-speedup-data-processing-with-numpy-vectorization-12acac71cfca?source=post_page-----897c53694621--------------------------------)
    [## How to Speedup Data Processing with Numpy Vectorization'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[](/how-to-speedup-data-processing-with-numpy-vectorization-12acac71cfca?source=post_page-----897c53694621--------------------------------)
    [## 如何利用 NumPy 矢量化加速数据处理'
- en: Up to 8000 times faster than normal functions
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比普通函数快多达 8000 倍
- en: towardsdatascience.com](/how-to-speedup-data-processing-with-numpy-vectorization-12acac71cfca?source=post_page-----897c53694621--------------------------------)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: towardsdatascience.com](/how-to-speedup-data-processing-with-numpy-vectorization-12acac71cfca?source=post_page-----897c53694621--------------------------------)
- en: '…a natural progression was to see how NumPy, and it’s implementation of vectorization
    stacked up against Julia:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: …一个自然的进展是查看 NumPy 及其矢量化实现与 Julia 的比较：
- en: '[](/is-julia-really-faster-than-python-and-numpy-242e0a5fe34f?source=post_page-----897c53694621--------------------------------)
    [## Is Julia Really Faster than Python and Numpy?'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[](/is-julia-really-faster-than-python-and-numpy-242e0a5fe34f?source=post_page-----897c53694621--------------------------------)
    [## Julia 真的是比 Python 和 NumPy 更快吗？'
- en: The speed of C with the simplicity of Python
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C 的速度与 Python 的简单性
- en: towardsdatascience.com](/is-julia-really-faster-than-python-and-numpy-242e0a5fe34f?source=post_page-----897c53694621--------------------------------)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: towardsdatascience.com](/is-julia-really-faster-than-python-and-numpy-242e0a5fe34f?source=post_page-----897c53694621--------------------------------)
- en: …and now, mainly due to comments on the previous Julia article, I think it will
    be interesting to see how Julia stacks up against the added features of Numba.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: …现在，主要是由于对之前 Julia 文章的评论，我认为观察 Julia 与 Numba 增加的功能相比如何将会很有趣。
- en: So, let’s get into it!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧！
- en: How will the tests work?
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试将如何进行？
- en: '![](../Images/912092a1bd5b04350e215a97c5f87798.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/912092a1bd5b04350e215a97c5f87798.png)'
- en: Photo by [Nguyen Dang Hoang Nhu](https://unsplash.com/@nguyendhn?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
    on [Unsplash](https://unsplash.com/photos/cbEvoHbJnIE?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由 [Nguyen Dang Hoang Nhu](https://unsplash.com/@nguyendhn?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
    提供，来源于 [Unsplash](https://unsplash.com/photos/cbEvoHbJnIE?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
- en: There will be three different function tested. Each function will increase in
    complexity.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 将测试三种不同的函数。每个函数的复杂度逐渐增加。
- en: Function 1 — A simple summation
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数 1 — 简单的求和
- en: The inputs (**a** and **b**) to the following functions are defined as a 1D
    array/vector with one million elements. Each element is a random number taken
    from a normal distribution, and of type float32.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数的输入（**a** 和 **b**）定义为具有一百万个元素的一维数组/向量。每个元素是从正态分布中取出的随机数，类型为 float32。
- en: For the Python function, the arrays will be NumPy arrays.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Python 函数，数组将是 NumPy 数组。
- en: '[PRE1]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Function 2 — A loop function
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数 2 — 循环函数
- en: Loops are ubiquitous, and therefore worth looking at.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 循环是无处不在的，因此值得关注。
- en: The input arrays will be the same as for Function 1.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 输入数组将与函数 1 相同。
- en: '[PRE3]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Function 3 — Matrix manipulation
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数 3 — 矩阵操作
- en: Matrix manipulation is a key component of many algorithms and tasks in the field
    of data science (especially deep learning), and so is an important factor to consider.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵操作是数据科学（尤其是深度学习）领域许多算法和任务的关键组成部分，因此是一个重要的考虑因素。
- en: Input into the functions will take the form of a 100 by 100 matrix of random
    numbers taken from a normal distribution.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 输入到函数中的数据将是一个从正态分布中取出的 100 x 100 随机数矩阵。
- en: '[PRE5]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Additional investigations
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 额外的调查
- en: 'To make things a little more informative, the following items will also be
    investigated:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让信息更具参考性，还将研究以下项目：
- en: All of the Numba functions will be timed both with and without the inclusion
    of the compilation stage. This will help judge the impact of compilation on overall
    execution time
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有 Numba 函数都将分别在包含和不包含编译阶段的情况下进行计时。这将帮助判断编译对整体执行时间的影响。
- en: A single iteration, and multiple iterations will be performed. Again, to investigate
    the impact of compilation on execution time
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将进行单次迭代和多次迭代测试。再次是为了研究编译对执行时间的影响。
- en: Apart from the ‘normal’ running of the functions, the effectiveness of parallel
    processing in both Numba and Julia will be compared
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了“正常”运行函数外，还将比较 Numba 和 Julia 中并行处理的有效性。
- en: The additional benefits of the Fastmath parameter in Numba will be investigated
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将研究 Numba 中 Fastmath 参数的额外好处
- en: The measurements
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测量
- en: The timing of the functions will be conducted using the [timeit module](https://docs.python.org/3/library/timeit.html)
    in Python and the [BenchmarkTools module](https://juliaci.github.io/BenchmarkTools.jl/stable/)
    in Julia.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的计时将使用 Python 中的 [timeit 模块](https://docs.python.org/3/library/timeit.html)
    和 Julia 中的 [BenchmarkTools 模块](https://juliaci.github.io/BenchmarkTools.jl/stable/)
    进行。
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Some general information (environment, versions, etc.)
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些常规信息（环境、版本等）
- en: All numbers that will follow were run on the exact same hardware, which uses
    an 4 core/8 thread CPU (i7–4790K) (exact details are printed in the Jupyter notebooks).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的测试都在完全相同的硬件上进行，该硬件使用的是 4 核心/8 线程 CPU（i7–4790K）（具体细节打印在 Jupyter notebooks
    中）。
- en: 'The software versions were as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 软件版本如下：
- en: '**Julia:** 1.9.2'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**Julia：** 1.9.2'
- en: '**Python:** 3.11.4'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python：** 3.11.4'
- en: '**NumPy:** 1.23.5'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**NumPy：** 1.23.5'
- en: '**Numba:** 0.57.1'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**Numba：** 0.57.1'
- en: The notebooks for this article
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本文的 notebooks
- en: '![](../Images/7a23361e1a8b46a4e777f807d816a9df.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7a23361e1a8b46a4e777f807d816a9df.png)'
- en: Photo by [Jessica Lewis](https://www.pexels.com/photo/ball-point-pen-on-opened-notebook-606541/)
    on [Pexels](https://www.pexels.com/)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由 [Jessica Lewis](https://www.pexels.com/photo/ball-point-pen-on-opened-notebook-606541/)
    提供，来源于 [Pexels](https://www.pexels.com/)
- en: 'All the code used to generate the results in this article are available in
    their entirety in two Jupyter notebooks here:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 本文中生成结果所用的所有代码都完整地保存在两个 Jupyter notebooks 中，链接如下：
- en: '[](https://github.com/thetestspecimen/notebooks/tree/main/julia-numba-comparison?source=post_page-----897c53694621--------------------------------)
    [## notebooks/julia-numba-comparison at main · thetestspecimen/notebooks'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://github.com/thetestspecimen/notebooks/tree/main/julia-numba-comparison?source=post_page-----897c53694621--------------------------------)
    [## notebooks/julia-numba-comparison at main · thetestspecimen/notebooks'
- en: Jupyter notebooks. Contribute to thetestspecimen/notebooks development by creating
    an account on GitHub.
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Jupyter笔记本。通过在GitHub上创建帐户来为thetestspecimen/notebooks的开发做出贡献。
- en: github.com](https://github.com/thetestspecimen/notebooks/tree/main/julia-numba-comparison?source=post_page-----897c53694621--------------------------------)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: github.com](https://github.com/thetestspecimen/notebooks/tree/main/julia-numba-comparison?source=post_page-----897c53694621--------------------------------)
- en: The results
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结果
- en: '![](../Images/cbe240e6d9f026ec916742b4a45f619a.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/cbe240e6d9f026ec916742b4a45f619a.png)'
- en: Photo by [Anna Nekrashevich](https://www.pexels.com/photo/magnifying-glass-on-top-of-document-6801648/)
    on [Pexels](https://www.pexels.com/)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由 [Anna Nekrashevich](https://www.pexels.com/photo/magnifying-glass-on-top-of-document-6801648/)
    提供，来源于 [Pexels](https://www.pexels.com/)
- en: Starting with…
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 从……
- en: A simple summation
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的求和
- en: First of all over a single iteration.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先在单次迭代中。
- en: '![](../Images/58ef2049cc84e1743e349b89f3e93e06.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/58ef2049cc84e1743e349b89f3e93e06.png)'
- en: A simple summation of two arrays over one iteration — Graph by Author
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对两个数组进行一次迭代的简单求和 — 图表由作者提供
- en: This first run over a single iteration is just to illustrate the significant
    overhead, compared to the overall execution time, that the compilation of the
    function **may** have when using Numba.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一次单次迭代的运行仅仅是为了说明，相较于整体执行时间，使用Numba时函数编译**可能**会带来显著的开销。
- en: It is worth pointing this out to avoid falling into the trap of just using Numba
    for everything, and not thinking about whether it is appropriate. If you have
    to execute a relatively simple function only once, then it will typically be better
    to just use NumPy directly, or at least take advantage of [caching](https://numba.readthedocs.io/en/stable/user/jit.html#cache)
    if your situation allows for it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，要避免陷入仅仅因为Numba而使用它的陷阱，而不考虑它是否合适。如果你只需执行一个相对简单的函数一次，那么通常直接使用NumPy会更好，或者如果情况允许，至少利用[缓存](https://numba.readthedocs.io/en/stable/user/jit.html#cache)。
- en: Now let’s increase the iterations to reduce the impact of the initial compilation.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们增加迭代次数，以减少初始编译的影响。
- en: '![](../Images/89251f787087fcb1410f7b63d0fd1aa8.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/89251f787087fcb1410f7b63d0fd1aa8.png)'
- en: A simple summation of two arrays over 10000 iterations — Graph by Author
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对两个数组进行10000次迭代的简单求和 — 图表由作者提供
- en: Well, there you have it. Julia is dead last!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，就是这样。Julia垫底了！
- en: In reality the difference is small (10000 iterations — Julia[7.2s] — NumPy[5.1s]),
    but it is a difference all the same.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，差异很小（10000次迭代 — Julia[7.2s] — NumPy[5.1s]），但这仍然是一个差异。
- en: Even more surprising is that Numba actually makes the execution slightly slower
    than NumPy, even if the Numba compilation time is ignored.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 更令人惊讶的是，即使忽略掉Numba的编译时间，Numba的执行速度实际上比NumPy稍慢。
- en: This goes a long was to illustrate that *properly* vectorized NumPy calculations
    are very well optimised, which is another element to consider when thinking about
    about whether Numba is worth using for your particular application.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好地说明了*适当*矢量化的NumPy计算非常优化，这是在考虑Numba是否适合你的特定应用时需要考虑的另一个因素。
- en: '***Note:*** *for more detail on what exactly NumPy vectorization is, and how
    it works, please check out my previous article where I go into detail:*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '***注意：*** *有关NumPy矢量化的详细信息，以及它是如何工作的，请查看我之前的文章，我在其中详细讲解了：*'
- en: '[](/how-to-speedup-data-processing-with-numpy-vectorization-12acac71cfca?source=post_page-----897c53694621--------------------------------)
    [## How to Speedup Data Processing with Numpy Vectorization'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[](/how-to-speedup-data-processing-with-numpy-vectorization-12acac71cfca?source=post_page-----897c53694621--------------------------------)
    [## 如何通过Numpy矢量化加速数据处理'
- en: Up to 8000 times faster than normal functions
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比普通函数快最多8000倍
- en: towardsdatascience.com](/how-to-speedup-data-processing-with-numpy-vectorization-12acac71cfca?source=post_page-----897c53694621--------------------------------)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: towardsdatascience.com](/how-to-speedup-data-processing-with-numpy-vectorization-12acac71cfca?source=post_page-----897c53694621--------------------------------)
- en: Looped Function
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环函数
- en: Moving on to a more realistic and slightly more complicated scenario, let’s
    have a look at a looping function.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 进入一个更现实且稍微复杂的场景，让我们看看一个循环函数。
- en: Essentially, running element by element through a 1 million element array and
    replacing each element based on an if-else statement.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上是逐个元素地运行一个包含 100 万个元素的数组，并根据 if-else 语句替换每个元素。
- en: '[PRE9]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![](../Images/575ccf1c2aa455dd85b03e8c61e739ff.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/575ccf1c2aa455dd85b03e8c61e739ff.png)'
- en: A loop funciton over 100 iterations (**Comp** — includes the function compilation
    time, **Para** — parallel processing)— Graph by Author
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 100 次迭代的循环函数（**Comp** — 包括函数编译时间，**Para** — 并行处理）— 作者图表
- en: Yet again, Numba comes out on top.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，Numba 占据了上风。
- en: Interestingly, even including the compilation time in the Numba run still has
    Numba coming out faster than Julia. Obviously, if the iterations were less, this
    lead would diminish, and then ultimately reverse. However, the execution stage
    is definitely quicker.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，即使在 Numba 运行中包含编译时间，Numba 的速度仍然比 Julia 快。显然，如果迭代次数较少，这种领先优势将会减小，甚至**最终**会逆转。然而，执行阶段确实更快。
- en: You will also note that parallel processing can help significantly in the case
    of both Julia and Numba. Some slight adjustments to the function must be made
    but nothing too extreme.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到，在 Julia 和 Numba 的情况下，并行处理可以显著帮助。函数需要做一些轻微调整，但没有过于极端的改动。
- en: 'For Julia it is just a case of adding `Threads.@threads` in front of the for
    loop:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Julia，只需在 for 循环前添加 `Threads.@threads`：
- en: '[PRE10]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For Numba it just requires adding `parallel=True` to the decorator and swapping
    out `np.arange` for `prange`(i.e. [parallel range](https://numba.pydata.org/numba-doc/latest/user/parallel.html?highlight=prange)).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Numba，只需在装饰器中添加 `parallel=True`，并将 `np.arange` 替换为 `prange`（即 [并行范围](https://numba.pydata.org/numba-doc/latest/user/parallel.html?highlight=prange)）。
- en: '[PRE11]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Another few additional microseconds were gained via the use of [Fastmath](https://numba.pydata.org/numba-doc/latest/user/performance-tips.html?highlight=fastmath#fastmath),
    which essentially reduces precision to gain execution speed. This could be very
    useful in the realms of machine/deep learning where high numeric precision is
    not necessarily required when training a model.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 [Fastmath](https://numba.pydata.org/numba-doc/latest/user/performance-tips.html?highlight=fastmath#fastmath)
    获得了额外的微秒，这本质上是通过降低精度来提高执行速度。这在机器/深度学习领域非常有用，因为在训练模型时不一定需要高数字精度。
- en: 'Again just a simple addition to the decorator:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 只需对装饰器做一个简单的补充：
- en: '[PRE12]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Matrix manipulation
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 矩阵操作
- en: Matrix manipulation is an essential part of Data Science workflow and specifically
    deep learning/neural networks.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵操作是数据科学工作流和深度学习/神经网络中不可或缺的一部分。
- en: 'With that in mind, I thought it might be interesting to see how Julia and Numba
    cope with chaining some different matrix manipulations together. Including:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于此，我觉得可能有趣的是看看 Julia 和 Numba 如何处理不同的矩阵操作链，包括：
- en: the ubiquitous dot product
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 普遍存在的点积
- en: transposition
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转置
- en: reshaping
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新形状
- en: summation
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 求和
- en: square root
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平方根
- en: absolute value
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绝对值
- en: average value
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平均值
- en: '[PRE13]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![](../Images/11f13a8a0fd7e4593271f29348367508.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11f13a8a0fd7e4593271f29348367508.png)'
- en: Matrix manipulation over 20 iterations (**Comp** — includes the function compilation
    time, **Para** — parallel processing) — Graph by Author
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 20 次迭代的矩阵操作（**Comp** — 包括函数编译时间，**Para** — 并行处理）— 作者图表
- en: Julia comes out on top in this case, by quite a margin (approx. 10 times quicker).
    Why this is is difficult to say, and would require further investigation. However,
    I suspect it will be down to some of the limitations of Numba, which I will discuss
    further in the next section.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Julia 表现最佳，差距相当大（大约快 10 倍）。为什么会这样尚难以解释，需要进一步调查。然而，我怀疑这与 Numba 的一些限制有关，我将在下一节进一步讨论。
- en: Another thing to note here is that due to the extended execution time of this
    function compared to Functions 1 and 2, the compilation time is already insignificant
    at just 20 iterations.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的地方是，由于这个函数的执行时间较长，相比于函数 1 和 2，编译时间在 20 次迭代时已经微不足道。
- en: Ultimately though, Numba is as quick as they say, and it is easy to use **in
    the majority of cases**. It easily pushes Python and it’s ecosystem into the territory
    of Julia, and in general bang up to date.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**最终**，Numba 如人们所说的那样快速，并且在**大多数情况下**使用起来非常简单。它轻松地将 Python 及其生态系统推向 Julia 的领域，整体上更新鲜。'
- en: With some caveats…
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 但有一些注意事项…
- en: The Limitations
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 局限性
- en: '![](../Images/1b13fc39d5096096b5e1dd1140a9f81e.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1b13fc39d5096096b5e1dd1140a9f81e.png)'
- en: Photo by [RDNE Stock project](https://www.pexels.com/photo/woman-hand-holding-paper-bag-7564158/)
    on [Pexels](https://www.pexels.com/)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由 [RDNE Stock project](https://www.pexels.com/photo/woman-hand-holding-paper-bag-7564158/)
    提供，来自 [Pexels](https://www.pexels.com/)
- en: It is fair to say that Numba can indeed keep up, and sometimes exceed Julia
    in terms of execution speed.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 可以公平地说，Numba 确实能够跟上，有时甚至超越 Julia 的执行速度。
- en: However, there is one major difference between Julia and Numba. Numba is an
    external library for a language, whereas the methods used in Julia are native
    methods integrated in to the core language.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Julia 和 Numba 之间有一个主要区别。Numba 是一个语言的外部库，而 Julia 中使用的方法是集成到核心语言中的原生方法。
- en: Numba is an external library for a language, whereas the methods used in Julia
    are native methods integrated in to the core language.
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Numba 是一个语言的外部库，而 Julia 中使用的方法是集成到核心语言中的原生方法。
- en: 'What this essentially means is that with Julia you are very unlikely to hit
    incompatibility issues or limitations on method application. The same cannot be
    said for Numba. Not only are the limitations of the application of Numba explicitly
    defined in the official documentation:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上意味着，使用 Julia 你非常不容易遇到不兼容问题或方法应用限制。而对于 Numba，则不能这样说。Numba 的应用限制不仅在官方文档中被明确规定：
- en: '[Supported Python features](https://numba.readthedocs.io/en/stable/reference/pysupported.html)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[支持的 Python 特性](https://numba.readthedocs.io/en/stable/reference/pysupported.html)'
- en: '[Supported NumPy features](https://numba.readthedocs.io/en/stable/reference/numpysupported.html)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[支持的 NumPy 特性](https://numba.readthedocs.io/en/stable/reference/numpysupported.html)'
- en: …but you are much more likely to find bugs due to incompatibility.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ……但由于不兼容性，你更可能会发现 bugs。
- en: Some bugs I found
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我发现的一些 bug
- en: The code in this article is very limited. Pretty simple functions. However,
    I still had issues with Numba, and had to adjust my analysis as a result.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 本文中的代码非常有限。比较简单的函数。然而，我仍然遇到了 Numba 的问题，因此不得不调整我的分析。
- en: On the last benchmarks conducted on 2D arrays/matrices (Function 3), there were
    various adjustments that had to be made just to get the function to run when using
    Numba.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在最近对 2D 数组/矩阵（函数 3）进行的基准测试中，为了使函数在使用 Numba 时能够运行，必须进行各种调整。
- en: '**It should be noted that none of the following are a problem when using straight
    Python/NumPy without Numba.**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**需要注意的是，使用纯 Python/NumPy 而不使用 Numba 时，以下问题都不存在。**'
- en: You cannot use `np.reshape` with a second argument (i.e. you cannot specify
    the re-order type ‘F’, ‘C’ etc.). This was an issue as Julia and Python use a
    different matrix index ordering as default, and attempting to keep things as comparable/fair
    as possible required looking into this second argument
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你不能使用带有第二个参数的 `np.reshape`（即你不能指定重新排序类型‘F’，‘C’等）。这是一个问题，因为 Julia 和 Python 使用不同的默认矩阵索引顺序，尝试尽可能保持比较/公平需要查看这个第二个参数。
- en: '`np.matmul` is not supported and therefore you have to use `np.dot`. This is
    not an issue for 2D arrays like those used in this article, but these methods
    are not equivalent for higher dimensional arrays, and you therefore may have an
    issue if you rely on `np.matmul` for higher dimensional arrays.'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`np.matmul` 不受支持，因此你必须使用 `np.dot`。这对像本文中使用的 2D 数组没有问题，但这些方法在高维数组中并不等效，因此如果你依赖于
    `np.matmul` 处理高维数组，可能会遇到问题。'
- en: '[Open bug](https://github.com/numba/numba/issues/5433) — using `np.reshape`
    after a transpose requires a copy to be taken, or it fails'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[打开 bug](https://github.com/numba/numba/issues/5433) — 在转置后使用 `np.reshape`
    需要进行复制，否则会失败'
- en: '[Open bug](https://github.com/numba/numba/issues/6714) — no support for integer
    arrays with `np.dot`. Having been forced to abandon`np.matmul` for `np.dot` (due
    to point 2), I now had another issue during testing before moving to floats'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[打开 bug](https://github.com/numba/numba/issues/6714) — `np.dot` 不支持整数数组。由于第
    2 点，被迫从 `np.matmul` 切换到 `np.dot` 后，在测试中我遇到了另一个问题，然后才转向浮点数。'
- en: I lost quite a bit of time with the four points above, as it is not always clear
    whether you are doing something wrong (i.e. trying to implement something that
    is not supported), or dealing with a bug. If I wasn’t dealing with “play” code
    for an article, and this was project code, it could become quite frustrating.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我在上述四个点上浪费了不少时间，因为不总是清楚你是否在做错事（即尝试实现不支持的内容），或者是在处理一个 bug。如果我处理的不是用于文章的“实验”代码，而是项目代码，那可能会变得相当令人沮丧。
- en: Conclusion
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: '![](../Images/6480554e0174618f60b14cd1368bdc38.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6480554e0174618f60b14cd1368bdc38.png)'
- en: Photo by [Ann H](https://www.pexels.com/photo/yellow-letter-tiles-1888003/)
    on [Pexels](https://www.pexels.com/#)
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 由 [Ann H](https://www.pexels.com/photo/yellow-letter-tiles-1888003/) 提供的照片，来源于
    [Pexels](https://www.pexels.com/#)
- en: 'Numba is excellent, and most importantly everything people claim it is:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Numba 非常优秀，最重要的是它完全符合人们对它的所有评价：
- en: '**Fast and easy to implement**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速且易于实现**'
- en: …and yes, to generalise, it is basically as fast as Julia. As long as it is
    used in the appropriate circumstances.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: …是的，总的来说，它基本上和 Julia 一样快。只要在适当的情况下使用。
- en: However, I can’t overlook the fact that Numba has some serious limitations when
    compared directly to Julia. Of course, the importance of those limitations will
    vary depending on your own requirements, and particular constraints.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我不能忽视的是，与 Julia 直接比较时，Numba 有一些严重的局限性。当然，这些局限性的重要性会根据你的需求和特定约束有所不同。
- en: In the real world, all this basically means is that if your current projects,
    or infrastructure, rely on Python, and changing to a new language is too much
    (lack of experienced devs, too much legacy code, not enough budget etc.). Then
    due to the hard work and persistence of the devs behind libraries like NumPy and
    Numba, Python is still bang up to date in terms of speed and features in the field
    of Data Science. Numba, and NumPy, very effectively fill a gap.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，这基本上意味着，如果你的当前项目或基础设施依赖于 Python，而转到新语言太困难（缺乏经验丰富的开发者、太多的遗留代码、预算不足等）。那么由于像
    NumPy 和 Numba 背后开发者的辛勤工作和坚持不懈，Python 在数据科学领域的速度和功能仍然是最新的。Numba 和 NumPy 非常有效地填补了这一空白。
- en: 'However, when writing code in Julia you well are aware of the fact that the
    base language is heavily optimised without any external libraries. It is also
    designed with data science in mind from the ground up, as that is what the creators
    needed themselves:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你在 Julia 中编写代码时，你很清楚，基础语言在没有任何外部库的情况下已经进行了高度优化。它也是从根本上以数据科学为设计目标，因为这是创造者自己所需的：
- en: For the work we do — scientific computing, machine learning, data mining, large-scale
    linear algebra, distributed and parallel computing — …
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于我们所做的工作——科学计算、机器学习、数据挖掘、大规模线性代数、分布式和并行计算——…
- en: ''
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '- [julialang.org](https://julialang.org/blog/2012/02/why-we-created-julia/)
    — Jeff Bezanson, Stefan Karpinski, Viral B. Shah, Alan Edelman'
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '- [julialang.org](https://julialang.org/blog/2012/02/why-we-created-julia/)
    — Jeff Bezanson, Stefan Karpinski, Viral B. Shah, Alan Edelman'
- en: You don’t have to be aware, or knowledgeable, about external libraries and tools
    to ensure that your project is fast with Julia. It will be fast by default. This
    allows more thought to go into what you are trying to achieve, rather than constantly
    having to consider the best way to speed things up, or optimise.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要了解或熟悉外部库和工具来确保你的项目在 Julia 中运行得很快。它默认就是很快的。这允许你更多地考虑你想要实现的目标，而不是不断考虑如何加快速度或优化。
- en: That is why, **if reasonably possible**, it makes a lot of sense to switch over
    to Julia (in my opinion!).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么**如果条件允许**，转向 Julia 是非常有意义的（在我看来！）。
- en: '***Note:*** *If you want to know more about the ins and outs of Julia for something
    like deep learning when compared to Python (TensorFlow), then be sure to take
    a look at this article:*'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '***注意：*** *如果你想了解更多关于 Julia 与 Python（TensorFlow）在深度学习方面的对比，务必查看这篇文章：*'
- en: '[](/julias-flux-vs-python-s-tensorflow-how-do-they-compare-574a3fb5e059?source=post_page-----897c53694621--------------------------------)
    [## Julia’s Flux vs Python’s TensorFlow: How Do They Compare?'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[](/julias-flux-vs-python-s-tensorflow-how-do-they-compare-574a3fb5e059?source=post_page-----897c53694621--------------------------------)
    [## Julia 的 Flux 与 Python 的 TensorFlow：它们的比较如何？'
- en: An end-to-end deep learning project comparison
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个端到端深度学习项目的比较
- en: towardsdatascience.com](/julias-flux-vs-python-s-tensorflow-how-do-they-compare-574a3fb5e059?source=post_page-----897c53694621--------------------------------)
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: towardsdatascience.com](/julias-flux-vs-python-s-tensorflow-how-do-they-compare-574a3fb5e059?source=post_page-----897c53694621--------------------------------)
- en: If you found this article interesting or useful, remember to follow me, or [sign
    up for my newsletter](https://medium.com/@maclayton/subscribe) for more content
    like this.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得这篇文章有趣或有用，记得关注我，或 [注册我的新闻通讯](https://medium.com/@maclayton/subscribe) 获取更多类似内容。
- en: If you haven’t already, you could also consider [subscribing to Medium](https://medium.com/@maclayton/membership).
    Your membership fee directly supports, not just me, but other writers you read
    too. You’ll also get full unrestricted access to every story on Medium.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有，可以考虑 [订阅 Medium](https://medium.com/@maclayton/membership)。你的会员费不仅直接支持我，还支持你阅读的其他作者。你还将获得
    Medium 上每篇文章的完全无限制访问权限。
- en: Using my referral link to sign up will grant me a small kickback with zero effect
    on your membership, so thank you if you choose to do so.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我的推荐链接注册将使我获得少量回扣，而不会影响你的会员资格，因此，如果你选择这样做，我非常感谢。
- en: '[](https://medium.com/@maclayton/membership?source=post_page-----897c53694621--------------------------------)
    [## Join Medium with my referral link - Mike Clayton'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@maclayton/membership?source=post_page-----897c53694621--------------------------------)
    [## 使用我的推荐链接加入 Medium - Mike Clayton'
- en: As a Medium member, a portion of your membership fee goes to writers you read,
    and you get full access to every story…
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作为 Medium 会员，你的会员费的一部分将支付给你阅读的作者，而且你可以完全访问每一个故事…
- en: medium.com](https://medium.com/@maclayton/membership?source=post_page-----897c53694621--------------------------------)
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: medium.com](https://medium.com/@maclayton/membership?source=post_page-----897c53694621--------------------------------)
