- en: Grover’s Quantum Search Algorithm
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Grover 的量子搜索算法
- en: 原文：[https://towardsdatascience.com/grovers-quantum-search-algorithm-54c427315768](https://towardsdatascience.com/grovers-quantum-search-algorithm-54c427315768)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/grovers-quantum-search-algorithm-54c427315768](https://towardsdatascience.com/grovers-quantum-search-algorithm-54c427315768)
- en: Quantum Computing
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 量子计算
- en: A visual explanation of one of the first quantum algorithms
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 量子算法之一的视觉解释
- en: '[](https://medium.com/@danjackho?source=post_page-----54c427315768--------------------------------)[![Dan
    Jackson](../Images/d7b923d6f0462d8226dd7ded7488ba9c.png)](https://medium.com/@danjackho?source=post_page-----54c427315768--------------------------------)[](https://towardsdatascience.com/?source=post_page-----54c427315768--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----54c427315768--------------------------------)
    [Dan Jackson](https://medium.com/@danjackho?source=post_page-----54c427315768--------------------------------)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@danjackho?source=post_page-----54c427315768--------------------------------)[![Dan
    Jackson](../Images/d7b923d6f0462d8226dd7ded7488ba9c.png)](https://medium.com/@danjackho?source=post_page-----54c427315768--------------------------------)[](https://towardsdatascience.com/?source=post_page-----54c427315768--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----54c427315768--------------------------------)
    [Dan Jackson](https://medium.com/@danjackho?source=post_page-----54c427315768--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----54c427315768--------------------------------)
    ·16 min read·May 23, 2023
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: ·发表于 [Towards Data Science](https://towardsdatascience.com/?source=post_page-----54c427315768--------------------------------)
    ·阅读时间 16 分钟·2023年5月23日
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/7d2e92f1b38559616e6d4b40772d403a.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7d2e92f1b38559616e6d4b40772d403a.png)'
- en: Close-up image of an IBM cryostat refrigeration system for a quantum computer.
    Image by [IBM/Graham Carlow](https://newsroom.ibm.com/media-quantum-innovation?keywords=quantum&l=100).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 量子计算机 IBM 低温冷却系统的特写图像。图像来源：[IBM/Graham Carlow](https://newsroom.ibm.com/media-quantum-innovation?keywords=quantum&l=100)。
- en: G**rover’s algorithm** is one of the earliest proposed quantum algorithms to
    demonstrate a quantum advantage, in this case a quadratic ‘speed-up’, over its
    classical analogue. Developed by ***Lov Grover*** [1] in 1996, the algorithm was
    a breakthrough in the field of quantum computing, following in the tracks of similar
    algorithms such as [***Shor’s algorithm***](https://en.wikipedia.org/wiki/Shor%27s_algorithm)
    and the [***Deutsch-Jozsa algorithm***](https://en.wikipedia.org/wiki/Deutsch%E2%80%93Jozsa_algorithm).
    In this article, we’ll visually explain how Grover’s algorithm works, and we’ll
    mathematically show how it demonstrates a ***quantum ‘speed-up’*** over the best
    classical search algorithm.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**Grover 算法** 是最早提出的量子算法之一，它展示了量子相对于经典算法的优势，在这种情况下是二次‘加速’。该算法由***洛夫·格罗弗***
    [1] 在 1996 年开发，是量子计算领域的一项突破，继类似算法如 [***Shor 算法***](https://en.wikipedia.org/wiki/Shor%27s_algorithm)
    和 [***Deutsch-Jozsa 算法***](https://en.wikipedia.org/wiki/Deutsch%E2%80%93Jozsa_algorithm)
    之后。在本文中，我们将通过视觉方式解释 Grover 算法的工作原理，并通过数学展示它相对于最佳经典搜索算法的***量子‘加速’***。'
- en: The Problem of Unstructured Searching
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无结构搜索问题
- en: However, first let’s introduce the problem that Grover’s algorithm addresses.
    Imagine we have access to an ***unstructured database***, or list, containing
    *N* ***elements***, each of which is represented by a ***unique n-bit string ID
    denoted*** *x*. The list can thus contain at most *N* = 2*ⁿ* elements. We are
    tasked with finding a particular ***“marked”*** element from the database with
    a particular bit-string *x₀.*
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们介绍一下 Grover 算法所解决的问题。假设我们有一个***无结构数据库***，或列表，其中包含 *N* ***元素***，每个元素由一个***唯一的
    n 位字符串 ID 代表*** *x*。因此，该列表最多可以包含 *N* = 2*ⁿ* 个元素。我们的任务是从数据库中找到一个特定的***“标记”***元素，其位字符串为
    *x₀*。
- en: '![](../Images/6d2900ce402d0dd3f417f0588c64f21b.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6d2900ce402d0dd3f417f0588c64f21b.png)'
- en: Simplified diagram of an N-element database with the marked element shown in
    red. Image by author.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: N 元素数据库的简化示意图，其中标记的元素用红色标出。图像来源：作者。
- en: To find the marked element, we will have to ***query*** the database by requesting
    the ID number *x* of an element in the database and checking if it is equal to
    the target ID number *x₀.* In the unlikely case that it does then we have successfully
    found the marked element with a single query!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到标记的元素，我们需要通过查询数据库来获取数据库中某个元素的 ID 号 *x* 并检查它是否等于目标 ID 号 *x₀*。如果它相等，那么我们通过一次查询就成功找到了标记的元素！
- en: However, the queried element most likely will not match the target that we are
    looking for on the first try. Especially if the database contains many elements
    (i.e. *N* is large). Therefore, we will have to continue to query the database
    repeatedly until there is a match *x = x₀* and we successfully find the target
    element.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，被查询的元素很可能不会在第一次尝试时与我们寻找的目标匹配，尤其是当数据库中包含很多元素（即 *N* 很大）时。因此，我们将不得不继续反复查询数据库，直到出现匹配的
    *x = x₀*，并成功找到目标元素。
- en: '***Note:*** *When ‘checking’ the ID number of an element we do not know what
    the target ID x₀ is. We just have some method of determining if the queried ID
    number x is equal to x₀. Thus, ‘finding the marked element’ is also equivalent
    to determining what x₀ actually is.*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '***注意：*** *在“检查”元素的ID号时，我们不知道目标ID x₀是什么。我们只是有一些方法来确定查询的ID号 x 是否等于 x₀。因此，“找到标记元素”也等同于确定
    x₀ 实际上是什么。*'
- en: Classical Unstructured Search Algorithm
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 经典无结构搜索算法
- en: 'To “check” the ID number *x* of a certain element suppose we have access to
    a ***function* *f(x)*** which takes in an *n*-bit string *x* and ***outputs***
    ***‘0’*** if it is not equal to the target bit-string, and ***outputs ‘1’*** if
    it is. Since we have no knowledge of what the target bit-string *x₀* actually
    is, the function is described as a ***black-box function***. We can define this
    function as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了“检查”某个元素的ID号 *x*，假设我们可以访问一个***函数* *f(x)***，该函数接收一个 *n* 位字符串 *x*，如果它不等于目标比特串，则***输出***
    ***‘0’***，如果相等则***输出 ‘1’***。由于我们不知道目标比特串 *x₀* 实际上是什么，函数被描述为***黑箱函数***。我们可以如下定义该函数：
- en: '![](../Images/3f9513ca48b3f842541006bbd368d419.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3f9513ca48b3f842541006bbd368d419.png)'
- en: Now, to find the marked element we iteratively query each element in the database
    and apply *f(x)* to check if it’s the target.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了找到标记元素，我们逐个查询数据库中的每个元素，并应用 *f(x)* 来检查它是否是目标。
- en: In the ***best-case scenario,*** we find the target after a single query.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在***最佳情况下***，我们在一次查询后找到目标。
- en: In the ***worst-case scenario,*** we must query the database *N* times, i.e.
    we must query each element in the database.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在***最坏情况下***，我们必须查询数据库 *N* 次，即我们必须查询数据库中的每个元素。
- en: '***On average,*** we must make *N/2* queries to find the marked element.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***平均而言***，我们必须进行 *N/2* 次查询才能找到标记元素。'
- en: 'In general, we can say that if we make ***k distinct queries*** to the database
    the ***probability of finding the marked element*** is:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，我们可以说，如果我们对数据库进行 ***k 次不同查询***，那么***找到标记元素的概率***是：
- en: '![](../Images/9f286cb21767f9219e509f39b7c87f22.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9f286cb21767f9219e509f39b7c87f22.png)'
- en: 'Therefore, if we wish to succeed with a probability of 𝝐 then we will have
    to make *k* ≥ 𝝐*N* queries. Overall, we can define the ***query complexity***of
    the classical search algorithm using [***Big-O notation***](https://en.wikipedia.org/wiki/Big_O_notation)as:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们希望以 𝝐 的概率成功，那么我们必须进行 *k* ≥ 𝝐*N* 次查询。总体而言，我们可以使用 [***Big-O 记法***](https://en.wikipedia.org/wiki/Big_O_notation)定义经典搜索算法的***查询复杂度***为：
- en: '![](../Images/e266c1924ca8fadae3c94600bfea6ae8.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e266c1924ca8fadae3c94600bfea6ae8.png)'
- en: Grover’s Quantum Search Algorithm
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Grover的量子搜索算法
- en: 'In this section we’ll dive into the theory behind how Grover’s quantum search
    algorithm finds a marked element in an unstructured database with a query complexity
    of:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将深入探讨Grover量子搜索算法如何在一个无结构的数据库中找到标记元素的理论，其查询复杂度为：
- en: '![](../Images/7e639780417fb20f745f0e936f88920d.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7e639780417fb20f745f0e936f88920d.png)'
- en: 'The algorithm describes how to apply a set of ***quantum operators or*** [***quantum
    gates***](https://en.wikipedia.org/wiki/Quantum_logic_gate) in a [***quantum circuit***](https://en.wikipedia.org/wiki/Quantum_circuit)
    on *n* qubits which are initially in a ***zero state***:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法描述了如何在[***量子电路***](https://en.wikipedia.org/wiki/Quantum_circuit)上对初始处于***零态***的
    *n* 个量子比特应用一组***量子算符或*** [***量子门***](https://en.wikipedia.org/wiki/Quantum_logic_gate)。
- en: '![](../Images/fe1f4b011879098e473e4e0ebe3070bb.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/fe1f4b011879098e473e4e0ebe3070bb.png)'
- en: The quantum circuit will transform the ***initial*** *n* qubit state into a
    ***final*** *n* qubit state which is equal to the target quantum state with a
    ***high probability***. Then, measuring the final quantum state will return the
    target ID bit-string *x₀ (with high probability).*
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 量子电路将***初始***的 *n* 量子比特状态转化为***最终***的 *n* 量子比特状态，该状态等于目标量子态，并且具有***高概率***。然后，测量最终量子状态将返回目标ID比特串
    *x₀*（具有高概率）。
- en: Quantum Gates & Operators
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 量子门与算符
- en: The Oracle Operator
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预言机算符
- en: 'The oracle operator is the quantum gate equivalent of the black-box function
    *f(x)* used in the classical algorithm. The oracle will act on an *n*-qubit quantum
    state ***|****x***⟩** and ***add a negative phase*** to the state if it is equal
    to the target state ***|****x₀***⟩** and leave it unchanged otherwise:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 预言算子是经典算法中黑箱函数 *f(x)* 的量子门等效物。预言算子将作用于 *n* 量子比特态 ***|****x***⟩** 上，并且如果它等于目标态
    ***|****x₀***⟩** 则***添加负相位***，否则保持不变：
- en: '![](../Images/0988fb29827027b76392b645d258068d.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0988fb29827027b76392b645d258068d.png)'
- en: 'To see how this is linked to the black-box function *f(x)* we can also represent
    the oracle operation as:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这如何与黑箱函数 *f(x)* 相关，我们还可以将预言操作表示为：
- en: '![](../Images/a61e05cff64d697e613157604737a1de.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a61e05cff64d697e613157604737a1de.png)'
- en: 'If we think about it carefully, we can see that the oracle operator is equivalent
    to the [***diagonal identity operator***](https://en.wikipedia.org/wiki/Identity_matrix)(*which
    in matrix form has only diagonal terms which are equal to 1*) with the element
    corresponding to the target state ***|****x₀***⟩** possessing a negative sign.
    As such, we can write the oracle operator as:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细考虑，可以发现预言算子等同于[***对角单位算子***](https://en.wikipedia.org/wiki/Identity_matrix)(*在矩阵形式中只有对角项等于1*)，其对应于目标态
    ***|****x₀***⟩** 的元素具有负号。因此，我们可以将预言算子写为：
- en: '![](../Images/394b59f0849b2600c8d58bbb2fd54f32.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/394b59f0849b2600c8d58bbb2fd54f32.png)'
- en: A quick check can verify that this representation is indeed equal to the two
    above it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过快速检查可以验证该表示确实等于上述的两个表示。
- en: The oracle is the ***core of the algorithm*** and defines the computational
    problem being solved. In essence, it simply ***verifies potential solutions to
    the given problem***. As such, Grover’s algorithm can be used to solve any problem
    which can be represented using a black-box function and so it can be applied to
    much more than just unstructured search problems.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 预言算子是***算法的核心***，定义了解决的计算问题。本质上，它只是***验证给定问题的潜在解决方案***。因此，Grover 算法可以用来解决任何可以用黑箱函数表示的问题，所以它不仅限于无结构搜索问题。
- en: The Phase Inverter Operator
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相位反转算子
- en: The phase inverter operator is similar to the oracle operator, except rather
    than adding a negative phase to the state if it’s equal to the target state ***|****x₀***⟩**
    it instead ***adds a negative phase to the state if it’s equal to the*** ***n-qubit
    zero state*** ***|0*⟩**. As before, the state is left unchanged otherwise.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 相位反转算子类似于预言算子，不同之处在于，如果状态等于目标态 ***|****x₀***⟩**，它会添加负相位；如果状态等于***n-量子比特零态***
    ***|0*⟩**，它会添加负相位。其他情况下，状态保持不变。
- en: '![](../Images/d9739a16ed953ab4b18259a6ba022740.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d9739a16ed953ab4b18259a6ba022740.png)'
- en: 'The phase inverter operator can also be expressed as the ***diagonal identity
    operator*** with the element corresponding to the zero state possessing a negative
    phase:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 相位反转算子也可以表示为***对角单位算子***，其对应于零态的元素具有负相位：
- en: '![](../Images/e06482dd648dd0feb0e9a400deb49fb7.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e06482dd648dd0feb0e9a400deb49fb7.png)'
- en: Grover’s Operator
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Grover 的算子
- en: 'Grover’s operator ***D*** is obtained by applying a [***Hadamard operator***](https://en.wikipedia.org/wiki/Hadamard_transform)on
    all *n* qubits before and after applying the ***phase inverter operator*** and
    then adding a negative phase, i.e. adding a negative sign. It can be expressed
    as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Grover 的算子 ***D*** 通过在应用***相位反转算子***之前和之后对所有 *n* 个量子比特应用一个[***Hadamard 算子***](https://en.wikipedia.org/wiki/Hadamard_transform)
    并添加负相位，即添加负号，从而获得。它可以表达为：
- en: '![](../Images/8f4ee654d13b1fd02b77b30abcec573f.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8f4ee654d13b1fd02b77b30abcec573f.png)'
- en: 'Where the Hadamard operator simply puts all *n* qubits into an ***equal superposition***
    of possible *N = 2ⁿ* states. We can substitute in our alternative representation
    for the phase inverter operator to obtain:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 Hadamard 算子将所有 *n* 个量子比特置于***等概率叠加***的可能 *N = 2ⁿ* 状态。我们可以代入相位反转算子的替代表示，以获得：
- en: '![](../Images/d5c169b7db56f02987f99f6d8c6d9515.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d5c169b7db56f02987f99f6d8c6d9515.png)'
- en: 'Where the action of the Hadamard operation on a single qubit in the zero state
    puts it into the following single qubit superposition state:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在零态的单个量子比特上，Hadamard 操作的效果是将其置于以下单量子比特叠加态：
- en: '![](../Images/819807144479c10cbabf66af3e7c23dd.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/819807144479c10cbabf66af3e7c23dd.png)'
- en: Inversion and Reflection Operator Representations
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反转和反射算子表示
- en: To get a clearer and more intuitive understanding of the action of the oracle
    operator, phase inverter operator, and Grover’s D operator on the *n*-qubit quantum
    state let’s first take a brief detour to explore two general classes of operators
    known as ***inversion and reflection operators***.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清晰、更直观地理解预言算符、相位倒置算符和Grover的D算符对 *n* 量子比特状态的作用，让我们首先稍作绕行，探讨两类一般算符，即***倒置和反射算符***。
- en: 'As you might guess, inversion and reflection operators perform an ***‘inversion’***
    or a ***‘reflection’*** of a quantum state about some other quantum state |𝜓⟩.
    They are expressed as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能猜到的，倒置和反射算符执行对某个其他量子状态 |𝜓⟩ 的***‘倒置’***或***‘反射’***。它们表示如下：
- en: '![](../Images/ad4d685d22fccf20cfb6c40092a50325.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ad4d685d22fccf20cfb6c40092a50325.png)'
- en: 'To see how these two forms of operators act on a state let us consider their
    ***action on an arbitrary state*** which is ***decomposed into orthogonal components***:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了观察这两种形式的算符对状态的作用，让我们考虑它们对一个***任意状态的作用***，该状态被***分解为正交组件***：
- en: '![](../Images/0fc09fb6afaf138686cfc38f6caf2fa4.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0fc09fb6afaf138686cfc38f6caf2fa4.png)'
- en: Inversion
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 倒置
- en: 'It’s easy to check that applying the inversion operator to the arbitrary state
    above results in the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易检查，将倒置算符应用于上述任意状态会得到以下结果：
- en: '![](../Images/ef2654a86b2be4a773602b0a5ae40dfd.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ef2654a86b2be4a773602b0a5ae40dfd.png)'
- en: 'We can see that the the sign in front of the |𝜓⟩ component of the state has
    been flipped. This corresponds to a ***‘reflection’*** of the overall state |𝜙⟩
    about the orthogonal |𝜓⟩ state. We can visualise this below:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，状态的 |𝜓⟩ 组件前面的符号被翻转了。这对应于对整体状态 |𝜙⟩ 关于正交状态 |𝜓⟩ 的***‘反射’***。我们可以如下可视化：
- en: '![](../Images/2a761b65c0cf6ac49468370def344345.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2a761b65c0cf6ac49468370def344345.png)'
- en: Animation of the inversion operation on an arbitrary state |𝜙⟩. Yellow axis
    indicates the axis of reflection. Gif by author.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 任意状态 |𝜙⟩ 上的倒置操作动画。黄色轴表示反射轴。Gif 作者提供。
- en: Reflection
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反射
- en: 'Similarly if we apply the reflection operator to the arbitrary state then we
    obtain:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我们将反射算符应用于任意状态，则会得到：
- en: '![](../Images/232cfec8fd5ca5a0e4d0aa6fdf7f29eb.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/232cfec8fd5ca5a0e4d0aa6fdf7f29eb.png)'
- en: 'Where we now find the sign has flipped for the orthogonal component. This sign
    flip corresponds to a reflection of the overall state |𝜙⟩ about the |𝜓⟩ state.
    We can visualise this below:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在发现正交组件的符号被翻转了。这种符号翻转对应于对整体状态 |𝜙⟩ 关于 |𝜓⟩ 状态的反射。我们可以如下可视化：
- en: '![](../Images/305f450e77694012d24ca444e9cbc977.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/305f450e77694012d24ca444e9cbc977.png)'
- en: Animation of the reflection operation on an arbitrary state |𝜙⟩. Yellow axis
    indicates axis of reflection. Gif by author.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 任意状态 |𝜙⟩ 上的反射操作动画。黄色轴表示反射轴。Gif 作者提供。
- en: The Oracle, Phase Inverter, and Grover’s D Operators
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预言算符、相位倒置算符和Grover的D算符
- en: 'With our new understanding of inversion and reflection operators let us represent
    the oracle operator, phase inverter operator, and Grover’s D operator as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 基于我们对倒置和反射算符的新理解，让我们将预言算符、相位倒置算符和Grover的D算符表示如下：
- en: '![](../Images/d2a8d4794a43831de3470134673c3821.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d2a8d4794a43831de3470134673c3821.png)'
- en: The Quantum Algorithm
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 量子算法
- en: 'Now that we have developed a solid understanding of the core concepts and quantum
    operators involved in Grover’s algorithm we can begin examining how the algorithm
    works. The complete algorithm is described below:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对Grover算法涉及的核心概念和量子算符有了深入的理解，我们可以开始研究算法的工作原理。完整算法描述如下：
- en: '![](../Images/9d5259173b89ec9078f83c7576e70153.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9d5259173b89ec9078f83c7576e70153.png)'
- en: 'The ***complete*** [***unitary operator***](https://en.wikipedia.org/wiki/Unitary_matrix)
    describing the algorithm is therefore:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 描述该算法的***完整*** [***单位算符***](https://en.wikipedia.org/wiki/Unitary_matrix) 因此是：
- en: '![](../Images/125a5879e591b82ac1f2508a1e237333.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/125a5879e591b82ac1f2508a1e237333.png)'
- en: 'And so the ***final quantum state*** that our *n* qubits are in at the end
    of the algorithm is:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，算法结束时我们 *n* 量子比特所处的***最终量子状态***是：
- en: '![](../Images/16d4d07c1a4706815f79cbc5c1cc8207.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/16d4d07c1a4706815f79cbc5c1cc8207.png)'
- en: If our algorithms works as it should, the final state above should be equal
    to the ***target state*** ***|****x₀***⟩** with high probability. Then, measuring
    the final state of each qubit should give us the target ID bit-string *x₀.*
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的算法正常工作，则最终状态应该等于***目标状态*** ***|****x₀***⟩**，具有较高的概率。然后，测量每个量子比特的最终状态应该给我们目标ID比特串
    *x₀*。
- en: 'The quantum circuit representing the algorithm is illustrated below:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 代表该算法的量子电路如下所示：
- en: '![](../Images/6640631e3fe6df7c3b8a2a3ef5dfdb78.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6640631e3fe6df7c3b8a2a3ef5dfdb78.png)'
- en: Diagram of the quantum circuit corresponding to Grover’s algorithm. Image by
    author.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对应于 Grover 算法的量子电路图。图片作者提供。
- en: Grover Iteration
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Grover 迭代
- en: 'The action of each of the *T* ***‘Grover iterations’*** on an *n*-qubit state
    is described by the operators in brackets. We’ll combine them into a Grover operator
    *G*:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 *T* ***‘Grover 迭代’*** 对 *n*-qubit 状态的作用由括号中的算符描述。我们将它们组合成一个 Grover 算符 *G*：
- en: '![](../Images/a9725ce91225ca0aabeade915b715459.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a9725ce91225ca0aabeade915b715459.png)'
- en: 'Which we can express in terms of ***inversion and reflection operators*** as:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用 ***反演和反射算符*** 来表达：
- en: '![](../Images/06c065db47a2791e64a7fc5616da7609.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/06c065db47a2791e64a7fc5616da7609.png)'
- en: Where the 2*nd* last term indicates a reflection about the orthogonal |+ⁿ**⟩**
    state. We can say that the |*x₀***⟩** and |+ⁿ**⟩** states ***span a 2D subspace
    of the Hilbert space*** *(the total N* = *2ⁿ state space of our n-qubits)*and
    that the reflection operations in each Grover iteration take place in this 2D
    subspace.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，倒数第二项表示对正交的 |+ⁿ**⟩** 状态的反射。我们可以说 |*x₀***⟩** 和 |+ⁿ**⟩** 状态 ***张成了 Hilbert
    空间的二维子空间*** *(我们 n-qubits 的总 N* = *2ⁿ 状态空间)*，每次 Grover 迭代中的反射操作都发生在这个二维子空间中。
- en: A Geometric Explanation of The Algorithm
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算法的几何解释
- en: 'Let’s consider the action of each Grover iteration *G* on some arbitrary state
    |𝜁⟩ in the 2D subspace spanned by |*x₀***⟩** and |+ⁿ**⟩**. We can express the
    arbitrary state |𝜁⟩ in terms of the state |+ⁿ**⟩** and its orthogonal counterpart:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑每次 Grover 迭代 *G* 在二维子空间中对任意状态 |𝜁⟩ 的作用，该子空间由 |*x₀***⟩** 和 |+ⁿ**⟩** 张成。我们可以将任意状态
    |𝜁⟩ 表达为状态 |+ⁿ**⟩** 及其正交对应物：
- en: '![](../Images/e1de6102b4b9a328f03657bd4181b32b.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e1de6102b4b9a328f03657bd4181b32b.png)'
- en: 'Similarly, the target state |*x₀***⟩** can be written as:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，目标状态 |*x₀***⟩** 可以写成：
- en: '![](../Images/475ab20782c0a992ae8a761c950a5efb.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/475ab20782c0a992ae8a761c950a5efb.png)'
- en: The initial state |𝜁⟩ and the target state |*x₀***⟩** can then be plotted on
    a graph of the 2D subspace with the axes representing the orthogonal |+ⁿ**⟩**
    components. This is illustrated below with the relevant angles between states
    indicated.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 初始状态 |𝜁⟩ 和目标状态 |*x₀***⟩** 可以在表示正交 |+ⁿ**⟩** 组件的二维子空间图中绘制。下图展示了状态之间的相关角度。
- en: '![](../Images/24bd59b54bea886f678a8d932adfb565.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/24bd59b54bea886f678a8d932adfb565.png)'
- en: Illustration of the 2D subspace spanned by some arbitrary initial state and
    the target state. Image by author.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 展示由某些初始状态和目标状态张成的二维子空间。图片作者提供。
- en: 'If we inspect the Grover iteration operator:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查 Grover 迭代算符：
- en: '![](../Images/26526a2ca91928bd5ea8718d9389b717.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/26526a2ca91928bd5ea8718d9389b717.png)'
- en: 'The action of each Grover iteration on some initial state can be understood
    graphically as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 每次 Grover 迭代对某些初始状态的作用可以通过图形化的方式理解如下：
- en: '***Reflection*** of the |𝜁⟩ state about the |*x₀***⟩** state.'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '|𝜁⟩ 状态关于 |*x₀***⟩** 状态的 ***反射***。'
- en: '***Reflection*** of the resulting state about the orthogonal axis.'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果状态关于正交轴的 ***反射***。
- en: 'Thus, if we initially have an angle of 𝜽 between the state and the target state,
    we first have to ***subtract*** -2𝜽 ***upon reflection*** about the |*x₀***⟩**
    state and then ***add*** +2(𝜽 — 𝛾) ***upon reflection*** about the vertical orthogonal
    axis. The final angle is therefore given by:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们初始状态和目标状态之间的角度为 𝜽，我们首先需要在 |*x₀***⟩** 状态关于的 ***反射*** 后 ***减去*** -2𝜽，然后在关于垂直正交轴的反射后
    ***加上*** +2(𝜽 — 𝛾)。最终角度因此由下式给出：
- en: '![](../Images/685dda9829875c05850ee5cc2cc10232.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/685dda9829875c05850ee5cc2cc10232.png)'
- en: 'In other words:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说：
- en: With each Grover iteration the angle between the *n*-qubit quantum state |𝜁⟩
    and the target state |*x₀***⟩** decreases by 2𝛾.
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 每次 Grover 迭代中 *n*-qubit 量子状态 |𝜁⟩ 和目标状态 |*x₀***⟩** 之间的角度减少 2𝛾。
- en: 'This can be more clearly understood using the animation below:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用下面的动画可以更清楚地理解这一点：
- en: '![](../Images/3cdf10320e72ea39de2b3f2ee6186212.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3cdf10320e72ea39de2b3f2ee6186212.png)'
- en: Animation of the action of a Grover iteration on some initial arbitrary state.
    Gif by author.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Grover 迭代对某些初始任意状态的作用动画。Gif 作者提供。
- en: Therefore, to put our initial quantum state |𝜁⟩ into the target state |*x₀***⟩**
    we just have to ***repeatedly apply Grover iterations*** and then stop once the
    state |𝜁⟩ is ***as close to*** the target state |*x₀***⟩** as possible.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了将初始量子状态 |𝜁⟩ 转换为目标状态 |*x₀***⟩**，我们只需 ***反复应用 Grover 迭代***，然后在状态 |𝜁⟩ ***尽可能接近***
    目标状态 |*x₀***⟩** 时停止。
- en: 'However, as discussed previously we do not begin with some initial ***arbitrary***
    state |𝜁⟩ to which we apply our Grover iterations. As shown by ***steps 1 and
    2*** we actually begin with the initial state:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如前所述，我们并不是从某个初始***任意***态 |𝜁⟩ 开始，并应用我们的 Grover 迭代。如 ***步骤 1 和 2*** 所示，我们实际上从初始状态开始：
- en: '![](../Images/95576615dd5c7458ff5218d02949706f.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/95576615dd5c7458ff5218d02949706f.png)'
- en: 'The ***initial angle 𝜽*** between the initial state |𝜁⟩ and the target state
    |*x₀***⟩** is found by the [***inner product***](https://en.wikipedia.org/wiki/Inner_product_space):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 初始状态 |𝜁⟩ 和目标状态 |*x₀***⟩** 之间的 ***初始角度 𝜽*** 通过 [***内积***](https://en.wikipedia.org/wiki/Inner_product_space)
    找到：
- en: '![](../Images/a7297c5f7f02d2a11f41c3abd18470ad.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a7297c5f7f02d2a11f41c3abd18470ad.png)'
- en: 'Similarly, we can also easily show that the angle 𝛾 between the target state
    |*x₀***⟩** and the orthogonal axis is given by:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们还可以很容易地展示目标状态 |*x₀***⟩** 与正交轴之间的角度 𝛾 如下所示：
- en: '![](../Images/1331bfe4e6486d4b50cca9f5b43ad43f.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1331bfe4e6486d4b50cca9f5b43ad43f.png)'
- en: Thus, as the database size *N* increases, i.e.***in the limit of a very large
    set size N,*** we get the following**:**
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，随着数据库大小 *N* 的增加，即 ***在非常大的集合大小 N 的极限下，*** 我们得到如下结果：
- en: '![](../Images/264b5d1774e68175b614e2e15770958b.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/264b5d1774e68175b614e2e15770958b.png)'
- en: Similarly, we can also say ***(using the*** [***small angle approximation***](https://en.wikipedia.org/wiki/Small-angle_approximation)***)***
    that in the limit of large *N:*
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们也可以说 ***(使用*** [***小角度近似***](https://en.wikipedia.org/wiki/Small-angle_approximation)***)***
    在大 *N* 的极限下：
- en: '![](../Images/7dc1cc1c3613176e392d3878a4c98f09.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7dc1cc1c3613176e392d3878a4c98f09.png)'
- en: Query Complexity Analysis
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询复杂度分析
- en: So with these initial angles, ***approximately how many Grover iterations will
    we require for the initial state to arrive at or get as close as possible to the
    target state |x₀⟩?***
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，使用这些初始角度，***大约需要多少次 Grover 迭代才能使初始状态接近或尽可能接近目标状态 |x₀⟩?***
- en: 'Since each Grover iteration reduces the angle between the state and the target
    state by 2𝛾 and the initial angle is 𝜋/*2* we can show that:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每次 Grover 迭代都将状态与目标状态之间的角度减少 2𝛾，而初始角度为 𝜋/*2*，我们可以展示：
- en: '![](../Images/33af3e36ce558a025fc3d64673099d45.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/33af3e36ce558a025fc3d64673099d45.png)'
- en: Where *T* represents the number of Grover iterations and thus also the number
    of ***queries k to the oracle***. However, we should note that this is ***just
    an approximation***. A more precise derivation of the optimal number of Grover
    iterations will be presented in the following section. Nevertheless, the ***query
    complexity*** can be found and expressed in [***Big-O notation***](https://en.wikipedia.org/wiki/Big_O_notation)***:***
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *T* 代表 Grover 迭代次数，因此也代表 ***对 oracle 的查询次数 k***。然而，我们应该注意这 ***只是一个近似值***。关于
    Grover 迭代次数的更精确推导将在接下来的章节中介绍。不过，***查询复杂度*** 可以用 [***大 O 符号***](https://en.wikipedia.org/wiki/Big_O_notation)***
    表示：***
- en: '![](../Images/2aee03c8f292d23a0f149abf1acacfd8.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2aee03c8f292d23a0f149abf1acacfd8.png)'
- en: '***A*** ***quadratic speed-up over the classical query complexity***! The graph
    below compares the classical query complexity to the quantum query complexity
    and indicates the point of quantum advantage.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '***相对于经典查询复杂度的二次加速***！下图比较了经典查询复杂度与量子查询复杂度，并指出了量子优势的点。'
- en: '![](../Images/91e5993d556f6910260d6a49466ed36f.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/91e5993d556f6910260d6a49466ed36f.png)'
- en: Classical query complexity vs. quantum query complexity, with the point of quantum
    advantage indicated in yellow. Image by author.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 经典查询复杂度与量子查询复杂度，量子优势点用黄色标出。图片由作者提供。
- en: Success Probability Analysis
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成功概率分析
- en: However, the probability of successfully arriving at the target state |*x₀***⟩**
    is strongly dependent on the total system size *N* and the number of Grover iterations
    applied *T*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，成功到达目标状态 |*x₀***⟩** 的概率强烈依赖于总系统大小 *N* 和应用的 Grover 迭代次数 *T*。
- en: 'In fact, the success probability doesn’t approach unity with increasingly many
    Grover iterations but rather ***oscillates*!** To see why, let’s first consider
    the probability that the ***final state*** |𝜁⟩ is in the ***target state*** |*x₀***⟩**
    using:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，成功概率并不会随着 Grover 迭代次数的增加而趋近于 1，而是 ***振荡*!** 要了解原因，我们首先考虑***最终状态*** |𝜁⟩ 在
    ***目标状态*** |*x₀***⟩** 中的概率：
- en: '![](../Images/0b61d52c1dfe3b84012e756072e057d3.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0b61d52c1dfe3b84012e756072e057d3.png)'
- en: 'We know the ***inner-product*** can be expressed in its more familiar geometric
    form:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道 ***内积*** 可以用更为熟悉的几何形式表示：
- en: '![](../Images/af3f30c4a14d022625c6bc5c90a90bb9.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/af3f30c4a14d022625c6bc5c90a90bb9.png)'
- en: 'Using the ***final angle*** between the state |𝜁⟩ and the target state |*x₀***⟩**
    after *T* Grover iterations. We also already know this angle is given by:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用***最终角度***，即状态|𝜁⟩与目标状态|*x₀***⟩**之间的角度，在*T*次Grover迭代后。我们也已经知道这个角度由以下公式给出：
- en: '![](../Images/9dd8de7129053098b54abd0edf273e70.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9dd8de7129053098b54abd0edf273e70.png)'
- en: 'And using the relation:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下关系：
- en: '![](../Images/971f2a36de24cc7f2a745465f7916c77.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/971f2a36de24cc7f2a745465f7916c77.png)'
- en: 'Gives us the following expression for the final angle:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 给出以下最终角度的表达式：
- en: '![](../Images/56dc08d61502177e7ec78b6a5e51d207.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/56dc08d61502177e7ec78b6a5e51d207.png)'
- en: 'We can substitute this into the inner-product to get:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其代入内积公式得到：
- en: '![](../Images/32fd9a9f51d2036495c00e92ef06e464.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/32fd9a9f51d2036495c00e92ef06e464.png)'
- en: 'Which finally gives us the following expression for the probability of successfully
    putting the final state into the target state:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最终给出以下成功将最终状态置于目标状态的概率表达式：
- en: '![](../Images/92c2866ce3af73b3384c249e89f1a334.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/92c2866ce3af73b3384c249e89f1a334.png)'
- en: Using this equation, ***we can plot the probability of success as a function
    of the number of Grover iterations*** for some system size *N* to see that the
    success probability does indeed oscillate.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个方程，***我们可以绘制成功概率作为Grover迭代次数的函数***，对于某些系统规模*N*，以观察成功概率是否确实存在振荡。
- en: '![](../Images/770b3bfa0f36bf5d6e7c98f9eb932986.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/770b3bfa0f36bf5d6e7c98f9eb932986.png)'
- en: Probability of success as a function of the number of Grover iterations. Image
    by author.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 成功概率作为Grover迭代次数的函数。图像由作者提供。
- en: To see why this oscillation occurs we can once again plot the state |𝜁⟩ and
    the target state |*x₀***⟩** on a graph and apply many Grover iterations to see
    how the state ***behaves*** over many iterations *T*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这种振荡现象，我们可以再次将状态|𝜁⟩和目标状态|*x₀***⟩**绘制在图上，并应用许多Grover迭代，以观察状态在多次*T*迭代中的***行为***。
- en: '![](../Images/49b6756dce6a97928d80a6f001c5bc2a.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/49b6756dce6a97928d80a6f001c5bc2a.png)'
- en: Animation of the behaviour of the state over many Grover iterations. Gif by
    author.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 状态在多次Grover迭代中的行为动画。Gif由作者提供。
- en: We can see that as the state approaches the target state at an angular rate
    of 2𝛾 per Grover iteration it actually reaches a minimum point at which the sign
    of the angle between the state and the target state flips. Thus, the state begins
    to ‘spiral’ away from the target state.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，当状态以每次Grover迭代2𝛾的角速度接近目标状态时，实际上会达到一个最小点，此时状态与目标状态之间的角度符号发生反转。因此，状态开始“螺旋”远离目标状态。
- en: At every system size *N* there exists an **optimal number of Grover iterations
    *T* which maximises the probability of success**.
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在每个系统规模*N*下，都存在一个**最大化成功概率的最优Grover迭代次数*T***。
- en: We can find this optimal number by setting the probability of success to 1 and
    re-arranging to find *T.*
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将成功概率设为1并重新排列以找到*T*来确定这个最优数字。
- en: '![](../Images/3d7560bedc2e93af7d504e8246e79257.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3d7560bedc2e93af7d504e8246e79257.png)'
- en: However, this optimal number of iterations must be an ***integer value*** so
    there will often be some ***small truncation error*** as a result of rounding
    to the nearest integer.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个最优的迭代次数必须是***整数值***，因此通常会因舍入到最近整数而存在一些***小的截断误差***。
- en: We can observe the effect of this truncation error by ***plotting the success
    probability as a function of set size N***and using the ***optimal number of Grover
    iterations rounded to the nearest integer.***
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过***绘制成功概率作为集合大小N的函数***并使用***四舍五入到最近整数的最优Grover迭代次数***来观察这种截断误差的影响。
- en: '![](../Images/2a91fc9bf8ce3c67f244d6dd1d8ceaac.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2a91fc9bf8ce3c67f244d6dd1d8ceaac.png)'
- en: Success probability as a function of system size N using nearest-integer optimal
    Grover iteration T values. Image by author.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用最近整数的最优Grover迭代次数*T*值作为系统规模N的函数的成功概率。图像由作者提供。
- en: 'Where the blue curve shows the success probability and the red curve shows
    an ***envelope approximation*** of the success probability ***as a function of
    set size N***. As shown in the graph, the success probability scales according
    to:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 其中蓝色曲线显示了成功概率，红色曲线显示了成功概率的***包络线近似***，***作为集合大小N的函数***。如图所示，成功概率的变化规律如下：
- en: '![](../Images/4d228af4a883b3ee349a6aa4e86ccf78.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4d228af4a883b3ee349a6aa4e86ccf78.png)'
- en: Thus, as the set size *N* gets larger the ***probability of success approaches
    unity!***
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，随着集合大小*N*增大，***成功概率接近于1！***
- en: 'We can perhaps gain a clearer understanding of why this trend in the success
    probability occurs if we once again plot the oscillating probability of success
    as a function of Grover iterations, but this time we’ll show only the integer
    values of *T*. For a set size of *N=7,* we get the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次绘制成功概率的振荡图像，作为Grover迭代次数的函数，但这次仅显示*T*的整数值，我们或许能更清楚地理解成功概率为何出现这种趋势。对于集大小*N=7*，我们得到以下结果：
- en: '![](../Images/a873a730df412c67c63cd0ea9ce76a87.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a873a730df412c67c63cd0ea9ce76a87.png)'
- en: Success probability as a function of truncated nearest integer Grover iterations,
    set size N=7\. Image by author.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 成功概率作为截断的最接近整数Grover迭代次数的函数，设定集大小N=7。图像由作者提供。
- en: We can see that the ***‘frequency’ of the oscillation*** in the success probability
    is such that for the first cycle of oscillation shown above the ***nearest integer
    Grover iterations (the vertical lines) do not align with the peak of the oscillation.
    Therefore, the success probability cannot reach unity.***
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，成功概率的***振荡‘频率’***是这样的，在上述第一个振荡周期中，***最接近整数的Grover迭代次数（垂直线）与振荡的峰值不对齐。因此，成功概率无法达到1。***
- en: 'However, if we do the same for a set size of *N=100* we get the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们对集大小*N=100*进行相同的操作，我们得到以下结果：
- en: '![](../Images/0f22bda4829378c87fe1214f6809e966.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0f22bda4829378c87fe1214f6809e966.png)'
- en: Success probability as a function of truncated nearest integer Grover iterations,
    set size N=100\. Image by author.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 成功概率作为截断的最接近整数Grover迭代次数的函数，设定集大小N=100。图像由作者提供。
- en: 'Increasing the set size *N* has effectively ***decreased the ‘frequency’***
    of the oscillations such that the ***optimal nearest integer Grover iteration
    can get much closer to the peak of oscillation.*** This pattern becomes even more
    clear if we increase the set size further to *N = 800*, as shown below:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 增加集大小*N*有效地***降低了振荡的‘频率’***，使得***最优的最接近整数Grover迭代次数可以更接近振荡的峰值。*** 如果我们进一步增加集大小到*N=800*，这种模式会变得更加明显，如下所示：
- en: '![](../Images/3df9aca387fb16ce12e23dfcd36e0191.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3df9aca387fb16ce12e23dfcd36e0191.png)'
- en: Success probability as a function of truncated nearest integer Grover iterations,
    set size N=800\. Image by author.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 成功概率作为截断的最接近整数Grover迭代次数的函数，设定集大小N=800。图像由作者提供。
- en: Therefore, as *N* tends to infinity, the optimal nearest integer Grover iteration
    T approaches the peak of the oscillation and the success probability approaches
    unity.
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 因此，随着*N*趋向于无穷大，最优的最接近整数Grover迭代次数T接近振荡的峰值，而成功概率趋向于1。
- en: Conclusion
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: In this article, we explored in great detail the theory behind how Grover’s
    quantum search algorithm achieves a quadratic speed-up over traditional classical
    search algorithms. However, in theory Grover’s algorithm can be applied to a much
    greater range of algorithms than just unstructured searches. More generally, the
    algorithm can offer a speed up to any ***black-box problem*** which involves satisfying
    some constraint, as checked by the oracle operator, or any problem which inherently
    involves an ***exhaustive search***. As such, one potential application of the
    algorithm that has received extensive interest is that of ***quantum cryptography***.
    In particular, Grover’s algorithm may offer a quantum speed to the exhaustive
    searches intrinsic to many ***brute-force attack*** algorithms.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇文章中，我们详细探讨了Grover量子搜索算法如何实现比传统经典搜索算法更快的二次加速的理论。然而，理论上Grover算法可以应用于比非结构化搜索更广泛的算法。更一般地说，该算法可以加速任何***黑箱问题***，这涉及到满足一些由oracle操作符检查的约束，或任何固有地涉及***穷举搜索***的问题。因此，该算法的一个潜在应用是***量子密码学***，特别是Grover算法可能为许多***暴力攻击***算法中固有的穷举搜索提供量子加速。
- en: However, the query complexity of Grover’s algorithm only overtakes that of its
    classical counterpart after a particular system size *N* is realised. Currently,
    near-term quantum computers are far from being able to supply the large numbers
    of noise-free qubits required for such a quantum advantage. Nevertheless, with
    continued progress in the fields of quantum computing and quantum engineering
    over the coming decades it seems likely that long-term fault-tolerant quantum
    computers will reach the complexity and sophistication needed to realise the promises
    of Grover’s quantum search algorithm.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Grover 算法的查询复杂性只有在特定系统规模 *N* 实现后才会超过其经典对手。目前，近期的量子计算机远未能够提供实现这种量子优势所需的大量无噪声量子比特。不过，随着未来几十年量子计算和量子工程领域的持续进展，长期的容错量子计算机似乎有可能达到实现
    Grover 量子搜索算法承诺所需的复杂性和精密度。
- en: '**Thanks for reading!** If you enjoyed this article and want to read more about
    physics, quantum mechanics, and quantum computing then give me a follow and check
    out some of my other articles! And if you ***really*** enjoyed it you can buy
    me a coffee (if you’d like) at [https://bmc.link/danjackho5](https://bmc.link/danjackho5),
    I’d really appreciate it!'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**感谢阅读！** 如果你喜欢这篇文章并想阅读更多关于物理学、量子力学和量子计算的内容，请关注我并查看我的其他文章！如果你***真的***喜欢这篇文章，你还可以在
    [https://bmc.link/danjackho5](https://bmc.link/danjackho5) 请我喝一杯咖啡（如果你愿意的话），我会非常感激！'
- en: Finally, if you want to keep reading about maths and physics on Medium then
    why not sign up to become a Medium member using the following link [https://medium.com/@danjackho/membership](https://medium.com/@danjackho/membership).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想继续在 Medium 上阅读关于数学和物理的内容，那么为什么不通过以下链接注册成为 Medium 会员呢？[https://medium.com/@danjackho/membership](https://medium.com/@danjackho/membership)。
- en: '[](https://medium.com/@danjackho/quantum-physics-101-the-schr%C3%B6dinger-equation-in-its-various-forms-3c9f3bcd68ee?source=post_page-----54c427315768--------------------------------)
    [## The Schrödinger Equation in its Various Forms'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@danjackho/quantum-physics-101-the-schr%C3%B6dinger-equation-in-its-various-forms-3c9f3bcd68ee?source=post_page-----54c427315768--------------------------------)
    [## 薛定谔方程的各种形式'
- en: Perhaps no equation in quantum mechanics is as ubiquitous as the Schrödinger
    equation.
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 也许在量子力学中，没有哪个方程像薛定谔方程那样普遍存在。
- en: 'medium.com](https://medium.com/@danjackho/quantum-physics-101-the-schr%C3%B6dinger-equation-in-its-various-forms-3c9f3bcd68ee?source=post_page-----54c427315768--------------------------------)
    [](https://medium.com/@danjackho/the-quantum-harmonic-oscillator-diracs-approach-f847569b9df0?source=post_page-----54c427315768--------------------------------)
    [## The Quantum Harmonic Oscillator: Dirac’s Approach'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[量子物理学101：薛定谔方程的各种形式](https://medium.com/@danjackho/quantum-physics-101-the-schr%C3%B6dinger-equation-in-its-various-forms-3c9f3bcd68ee?source=post_page-----54c427315768--------------------------------)
    [](https://medium.com/@danjackho/the-quantum-harmonic-oscillator-diracs-approach-f847569b9df0?source=post_page-----54c427315768--------------------------------)
    [## 量子谐振子：狄拉克的研究方法'
- en: How this fundamental model in physics becomes quantised and how we can apply
    Dirac’s ‘ladder method’ to find its energy…
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 这个物理学基本模型如何被量子化，以及我们如何应用狄拉克的‘阶梯方法’来找到其能量…
- en: medium.com](https://medium.com/@danjackho/the-quantum-harmonic-oscillator-diracs-approach-f847569b9df0?source=post_page-----54c427315768--------------------------------)
    [](https://medium.com/@danjackho/the-mathematics-of-quantum-teleportation-explained-3db2b9066c7a?source=post_page-----54c427315768--------------------------------)
    [## The Mathematics of Quantum Teleportation Explained
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[量子谐振子：狄拉克的研究方法](https://medium.com/@danjackho/the-quantum-harmonic-oscillator-diracs-approach-f847569b9df0?source=post_page-----54c427315768--------------------------------)
    [](https://medium.com/@danjackho/the-mathematics-of-quantum-teleportation-explained-3db2b9066c7a?source=post_page-----54c427315768--------------------------------)
    [## 量子传送的数学解释'
- en: The mathematics behind how the quantum state of a particle can be ‘transferred’
    to a distant particle using quantum…
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 量子态如何‘转移’到远处粒子的数学原理…
- en: medium.com](https://medium.com/@danjackho/the-mathematics-of-quantum-teleportation-explained-3db2b9066c7a?source=post_page-----54c427315768--------------------------------)
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[量子计算传送的数学原理](https://medium.com/@danjackho/the-mathematics-of-quantum-teleportation-explained-3db2b9066c7a?source=post_page-----54c427315768--------------------------------)'
- en: References
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[1] Grover, Lov K. “A fast quantum mechanical algorithm for database search.”
    *Proceedings of the twenty-eighth annual ACM symposium on Theory of computing*.
    1996.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] Grover, Lov K. “一种快速的量子机械算法用于数据库搜索。” *第二十八届年度 ACM 计算理论研讨会论文集*。1996年。'
- en: '[2] Linden, Noah. *Lecture Notes,* *“Quantum Computation”*. 2022.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[2] Linden, Noah. *讲义,* *“量子计算”*。2022年。'
