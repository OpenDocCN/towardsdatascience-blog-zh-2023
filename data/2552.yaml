- en: Visualised Explanation of PageRank
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PageRank 的可视化解释
- en: 原文：[https://towardsdatascience.com/large-graph-analysis-with-pagerank-e571e3dec8ed?source=collection_archive---------9-----------------------#2023-08-09](https://towardsdatascience.com/large-graph-analysis-with-pagerank-e571e3dec8ed?source=collection_archive---------9-----------------------#2023-08-09)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/large-graph-analysis-with-pagerank-e571e3dec8ed?source=collection_archive---------9-----------------------#2023-08-09](https://towardsdatascience.com/large-graph-analysis-with-pagerank-e571e3dec8ed?source=collection_archive---------9-----------------------#2023-08-09)
- en: Discover how Google search engine ranks documents based on their link structure
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解 Google 搜索引擎如何根据链接结构对文档进行排名
- en: '[](https://medium.com/@slavahead?source=post_page-----e571e3dec8ed--------------------------------)[![Vyacheslav
    Efimov](../Images/db4b02e75d257063e8e9d3f1f75d9d6d.png)](https://medium.com/@slavahead?source=post_page-----e571e3dec8ed--------------------------------)[](https://towardsdatascience.com/?source=post_page-----e571e3dec8ed--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----e571e3dec8ed--------------------------------)
    [Vyacheslav Efimov](https://medium.com/@slavahead?source=post_page-----e571e3dec8ed--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@slavahead?source=post_page-----e571e3dec8ed--------------------------------)[![Vyacheslav
    Efimov](../Images/db4b02e75d257063e8e9d3f1f75d9d6d.png)](https://medium.com/@slavahead?source=post_page-----e571e3dec8ed--------------------------------)[](https://towardsdatascience.com/?source=post_page-----e571e3dec8ed--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----e571e3dec8ed--------------------------------)
    [Vyacheslav Efimov](https://medium.com/@slavahead?source=post_page-----e571e3dec8ed--------------------------------)'
- en: ·
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fc8a0ca9d85d8&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Flarge-graph-analysis-with-pagerank-e571e3dec8ed&user=Vyacheslav+Efimov&userId=c8a0ca9d85d8&source=post_page-c8a0ca9d85d8----e571e3dec8ed---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----e571e3dec8ed--------------------------------)
    ·14 min read·Aug 9, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fe571e3dec8ed&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Flarge-graph-analysis-with-pagerank-e571e3dec8ed&user=Vyacheslav+Efimov&userId=c8a0ca9d85d8&source=-----e571e3dec8ed---------------------clap_footer-----------)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[关注](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fc8a0ca9d85d8&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Flarge-graph-analysis-with-pagerank-e571e3dec8ed&user=Vyacheslav+Efimov&userId=c8a0ca9d85d8&source=post_page-c8a0ca9d85d8----e571e3dec8ed---------------------post_header-----------)
    发表在 [Towards Data Science](https://towardsdatascience.com/?source=post_page-----e571e3dec8ed--------------------------------)
    ·14分钟阅读·2023年8月9日[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fe571e3dec8ed&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Flarge-graph-analysis-with-pagerank-e571e3dec8ed&user=Vyacheslav+Efimov&userId=c8a0ca9d85d8&source=-----e571e3dec8ed---------------------clap_footer-----------)'
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fe571e3dec8ed&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Flarge-graph-analysis-with-pagerank-e571e3dec8ed&source=-----e571e3dec8ed---------------------bookmark_footer-----------)![](../Images/f23509038e4fe63a4a3baf5f188e97a1.png)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fe571e3dec8ed&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Flarge-graph-analysis-with-pagerank-e571e3dec8ed&source=-----e571e3dec8ed---------------------bookmark_footer-----------)![](../Images/f23509038e4fe63a4a3baf5f188e97a1.png)'
- en: Ranking is an important problem in machine learning. Given a set of documents,
    the goal is to sort them in a specific order based on certain criteria. Ranking
    is widely used in information retrieval systems to sort search results or in recommender
    systems to filter content will potentially be interesting to a particular user.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 排名是机器学习中的一个重要问题。给定一组文档，目标是根据特定标准对它们进行排序。排名在信息检索系统中广泛使用，用于排序搜索结果，或在推荐系统中筛选出可能对特定用户感兴趣的内容。
- en: 'Based on a given problem and objective, there exist an abundance of ranking
    algorithms. The one we are going to study in this article is named [**PageRank**](https://arxiv.org/pdf/1002.2858.pdf).
    Its main objective is to rank a set of documents (web pages) by using the information
    about their connectivity. The rank assigned to each web page indicates its importance:
    the higher the rank is, the higher the importance is. The algorithm is based on
    two assumptions which we are going to look at in the next section.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 根据具体问题和目标，存在大量的排名算法。我们将在本文中研究的算法名为[**PageRank**](https://arxiv.org/pdf/1002.2858.pdf)。它的主要目标是通过利用关于连接性的信息对一组文档（网页）进行排名。分配给每个网页的排名表示它的重要性：排名越高，重要性越高。该算法基于两个假设，我们将在下一节中讨论。
- en: Assumptions
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 假设
- en: We can define the term “importance” of a web page by making two assumptions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过做出两个假设来定义网页的“重要性”一词。
- en: The importance of a web page is high if there are many other web pages pointing
    to it.
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果有许多其他网页指向某个网页，那么该网页的重要性就会很高。
- en: Imagine we have a popular research paper and many other articles linking to
    it by using quotes or results from it. Primarily, it makes sense to give this
    article a large importance. On the other hand, if there is an unknown web page
    with no links to it from other resources, it seems logical to assign low importance
    to the page.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一篇热门的研究论文以及许多其他文章通过引用或结果链接到它。主要是，这使得给这篇文章赋予较大重要性是有意义的。另一方面，如果有一个未知的网页没有其他资源的链接，似乎将低重要性分配给该页面是合乎逻辑的。
- en: In reality, we should also care about the quality of the incoming links.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们还应该关注入站链接的质量。
- en: The importance of a web page is proportional to the importance of the web pages
    pointing to it.
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个网页的重要性与指向它的网页的重要性成正比。
- en: If a page is originally cited by a high-quality article on Wikipedia, then such
    a link should have a larger weight. Conversely, when an absolutely unknown resource
    points to another web page, it should not normally have high importance.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个页面最初被维基百科上的高质量文章引用，那么这样的链接应该具有更大的权重。相反，当一个完全不知名的资源指向另一个网页时，它通常不会有高的重要性。
- en: '![](../Images/2619d05b34a9a9a81ac493e26654dc6e.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2619d05b34a9a9a81ac493e26654dc6e.png)'
- en: Example of importance distribution made by PageRank algorithm from the [official
    paper](https://arxiv.org/pdf/1002.2858.pdf). Scores were normalized to sum up
    to 100\. The node with the value of 38.4 has such high importance due to a large
    number of other nodes pointing to it. On the other hand, the node with the importance
    of 34.3 has only one incoming link but it is importance is still relatively high
    because its single input link comes from another influential node. Nodes with
    low importances of 1.6 do not have any incoming links.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 来自[官方论文](https://arxiv.org/pdf/1002.2858.pdf)的PageRank算法的重要性分布示例。得分被标准化为总和为100。具有38.4值的节点由于有大量其他节点指向它而具有如此高的重要性。另一方面，重要性为34.3的节点只有一个入站链接，但由于其唯一的输入链接来自另一个有影响力的节点，它的重要性仍然相对较高。重要性为1.6的节点没有任何入站链接。
- en: Formal definition
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正式定义
- en: Let us say that the importance of a node is equal to the sum of the weights
    of incoming links.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个节点的重要性等于所有入站链接权重的总和。
- en: Imagine a node *i* with importance *rᵢ* having *k* outcoming links. How can
    we determine the weight of each link? The most straightforward approach is to
    take the node’s importance and divide it equally between all the outcoming links.
    This way, each outcoming link will receive the weight of *rᵢ / k*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个重要性为*rᵢ*的节点*i*，它有*k* 个出站链接。我们如何确定每个链接的权重？最直接的方法是将节点的重要性平均分配给所有出站链接。这样，每个出站链接将获得*rᵢ
    / k*的权重。
- en: '![](../Images/1aa89e43a0ee6a6095fef51e9f7c7785.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1aa89e43a0ee6a6095fef51e9f7c7785.png)'
- en: Example of calculating the rank of a node
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 节点排名计算示例
- en: '![](../Images/7d2f2575cf6eee5451d256668d55552f.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7d2f2575cf6eee5451d256668d55552f.png)'
- en: The rank of a node is equal to the sum of ranks of incoming nodes divided by
    their total out degree.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的排名等于入站节点的排名总和除以它们的总出度。
- en: Given a graph of *n* web pages, we can create a system of *n* linear equations
    to find the weights of the graph. However, such a system can have an infinite
    number of solutions. That is why we should add another constraint that will impose
    a unique solution. By the way, PageRank adds the normalized condition that the
    sum of all node importance is equal to 1.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个 *n* 个网页的图，我们可以创建一个 *n* 个线性方程的系统来找到图的权重。然而，这样的系统可能有无限多个解。这就是为什么我们应该添加另一个约束条件以强加唯一解。顺便说一下，PageRank
    添加了归一化条件，即所有节点的重要性之和等于 1。
- en: '![](../Images/010fd0358235454b88c63e208722f3ad.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/010fd0358235454b88c63e208722f3ad.png)'
- en: Finding a solution of a system of linear equations describing graph structure
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找描述图结构的线性方程组的解
- en: We have come up with a solution but it is not scalable. Even with Gaussian elimination,
    we end up with *O(n³)* complexity. Keeping in mind that the number of analyzed
    web pages *n* can reach billions, we need to come up with a more efficient approach.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提出了一个解决方案，但它不可扩展。即使使用高斯消元法，我们的复杂度也达到了 *O(n³)*。考虑到分析的网页数量 *n* 可以达到数十亿，我们需要想出一种更高效的方法。
- en: 'First of all, let us simplify the notation. For this, we introduce the adjacency
    square matrix *G* which will contain link weights for every pair of linked web
    pages (if two web pages are not linked, we will put 0 in a corresponding matrix
    element). More formally:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们简化表示法。为此，我们引入了邻接方阵 *G*，它将包含每对链接网页的链接权重（如果两个网页没有链接，我们将在相应的矩阵元素中放置 0）。更正式地：
- en: '![](../Images/3a76da3e63295a8f9f2a8b4e0d08b3fd.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3a76da3e63295a8f9f2a8b4e0d08b3fd.png)'
- en: Definition of a matrix element G[j][i]
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵元素 G[j][i] 的定义
- en: Matrix *G* is called **stochastic** because each of its columns sums up to 1.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵 *G* 被称为**随机矩阵**，因为它的每一列的总和为 1。
- en: Next, we define the rank vector *r* whose *i*-th element is equal to the rank
    (importance) of page *i*. The sum of all elements of this vector also equals 1\.
    Our ultimate goal is to find values of this vector *r*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义排名向量 *r*，其 *i* -th 元素等于页面 *i* 的排名（重要性）。该向量所有元素的总和也等于 1。我们的**最终目标**是找到这个向量
    *r* 的值。
- en: PageRank equation
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PageRank 方程
- en: Let us see what will happen if we multiply matrix *G* by vector *r*. Based on
    the example with the graph from the section above, we can see that it results
    in the same vector *r*!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果将矩阵 *G* 乘以向量 *r* 会发生什么。根据上一节的图示，我们可以看到结果仍然是相同的向量 *r*！
- en: '![](../Images/367e82305bad992b43ceb17a7b2ef98c.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/367e82305bad992b43ceb17a7b2ef98c.png)'
- en: Multiplying matrix G by vector r results again in vector r
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将矩阵 G 乘以向量 r 再次得到向量 r
- en: 'Why does it happen? Is it just a coincidence? Remember that the *i*-th row
    of matrix *G* contains weights of all input links to the page *i*. When we multiply
    the *j*-th element of the *i*-th row by *r[j]*, we actually get the component
    r*j* / *d[j]out* — the importance which flows from node *j* to *i*. If there is
    no link between nodes *i* and *j*, then the respective component is set to 0\.
    Logically, the final result of the multiplication of the *i*-th row by the vector
    *r* will be equal to the sum of all importances which flow from any connected
    node of the graph to node *i*. By definition, this value equals the rank of the
    node *i*. In general, we can write the following equation:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会这样？这只是巧合吗？请记住，矩阵 *G* 的 *i* -th 行包含所有输入链接到页面 *i* 的权重。当我们将 *i* -th 行的 *j*
    -th 元素乘以 *r[j]* 时，我们实际上得到的是组件 r*j* / *d[j]out* —— 从节点 *j* 流向 *i* 的重要性。如果节点 *i*
    和 *j* 之间没有链接，则相应的组件设置为 0。逻辑上，*i* -th 行与向量 *r* 的乘积的最终结果将等于从图的任何连接节点流向节点 *i* 的所有重要性的总和。根据定义，这个值等于节点
    *i* 的排名。一般来说，我们可以写出以下方程：
- en: '![](../Images/09e121829ca20698156b8b0901a4f767.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09e121829ca20698156b8b0901a4f767.png)'
- en: PageRank equation
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: PageRank 方程
- en: Therefore, our goal is to find such a vector *r* which being multiplied by the
    input matrix *G* will remain the same.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的目标是找到一个向量 *r*，使其在与输入矩阵 *G* 相乘时保持不变。
- en: Eigenvectors
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特征向量
- en: 'We can find the solution to the equation above by revising the theory on eigenvectors
    from linear algebra. Given a matrix *A*, the vector *v* is called the **eigenvector**
    if there exists such a number *α* which satisfies the following equation:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过回顾线性代数中关于特征向量的理论来找到上述方程的解。给定一个矩阵 *A*，如果存在一个数 *α* 使得下列方程成立，则向量 *v* 被称为**特征向量**：
- en: '![](../Images/62c0e1f08ded53fccaca33f4a76c573b.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/62c0e1f08ded53fccaca33f4a76c573b.png)'
- en: Eigenvalue definition
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 特征值定义
- en: The number *α* is called the **eigenvalue**. We can notice that the PageRank
    equation corresponds to the eigenvalue equation where *A = G, v = r* and *α =
    1*. Normally, any square matrix has several eigenvalues and eigenvectors but since
    our matrix *G* is stochastic, the theory claims that its largest eigenvalue is
    equal to 1.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 数字 *α* 被称为 **特征值**。我们可以注意到，PageRank 方程对应于特征值方程，其中 *A = G, v = r* 和 *α = 1*。通常，任何方阵都有多个特征值和特征向量，但由于我们的矩阵
    *G* 是随机的，理论上它的最大特征值等于 1。
- en: Power iteration
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 幂迭代
- en: One of the most popular ways of finding matrix eigenvectors is the **Power iteration**
    method. It consists of initializing an initial vector *r* with some values (we
    will use *1 / n* where *n* is the number of web pages), then constantly computing
    the value of *G * r* and assigning this value to *r* again. If on any iteration
    the distance between vectors *r* and *G * r* is less than a certain threshold
    *ε*, we stop the algorithm as it has converged successfully.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找矩阵特征向量的最流行的方法之一是 **幂迭代** 方法。它包括用一些值（我们将使用 *1 / n*，其中 *n* 是网页数量）初始化初始向量 *r*，然后不断计算
    *G * r* 的值，并将该值重新分配给 *r*。如果在任何迭代中，向量 *r* 和 *G * r* 之间的距离小于某个阈值 *ε*，我们就停止算法，因为它已经成功收敛。
- en: '![](../Images/759a280818414db10f3f899d86d1f64c.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/759a280818414db10f3f899d86d1f64c.png)'
- en: PageRank algorithm
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: PageRank 算法
- en: 'In the example above we can see that by setting *ε* to0.0005 the algorithm
    correctly converges just in 9 iterations:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，我们可以看到，通过将 *ε* 设置为 0.0005，算法在仅 9 次迭代中正确收敛：
- en: '![](../Images/dd71e8506a7bbf15834355e5b082ada6.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/dd71e8506a7bbf15834355e5b082ada6.png)'
- en: Obviously, this is only a toy example but in practice, this method works very
    well for a larger number of variables as well.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这只是一个玩具示例，但在实际中，这种方法对于更多变量也能很好地工作。
- en: Random walk
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随机游走
- en: Imagine a surfer (walker) being at any node of the graph at time *t*. Let us
    denote by *p(t)* the vector whose *i*-th component equals the probability that
    at time *t* the surfer is present at node *i*. Then the surfer randomly (with
    equal probabilities) chooses another linked node to the current one and moves
    there at time *t + 1*. Ultimately, we want to find the distribution vector *p(t
    + 1)* at the moment *t + 1*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个游览者（行走者）在时刻 *t* 位于图的任何节点上。我们用 *p(t)* 表示一个向量，其中 *i* 位置的分量等于游览者在时刻 *t* 出现在节点
    *i* 的概率。然后，游览者随机（以相等的概率）选择另一个链接到当前节点的节点，并在时刻 *t + 1* 移动到那里。最终，我们希望找到时刻 *t + 1*
    的分布向量 *p(t + 1)*。
- en: '![](../Images/786184a62c210f59cf091bfa695db6e0.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/786184a62c210f59cf091bfa695db6e0.png)'
- en: Random walk of the surfer
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 游览者的随机游走
- en: We can notice that the probability of the surfer appearing at a node *i* at
    the moment *t + 1* is the sum of probabilities (over all linked nodes to *i*)
    that the surfer was previously at an adjacent node *j* multiplied by the probability
    of moving from node *j* to *i*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以注意到，游览者在时刻 *t + 1* 出现于节点 *i* 的概率是游览者之前在相邻节点 *j* 的概率总和（所有链接到 *i* 的节点）乘以从节点
    *j* 移动到 *i* 的概率。
- en: 'We already know the probability of the surfer appearing at node *j* at moment
    t: *p(t)[j]*.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经知道游览者在时刻 t 出现在节点 *j* 的概率：*p(t)[j]*。
- en: The probability of moving from node *j* to *i* is equal to *G[j][i]*.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从节点 *j* 到 *i* 的移动概率等于 *G[j][i]*。
- en: 'By summing up these probabilities, we get the value for *p(t + 1)[i]*. For
    finding the value of *p(t + 1)* for all the graph nodes, we can write the same
    equation in the matrix form:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过汇总这些概率，我们得到 *p(t + 1)[i]* 的值。为了找到所有图节点的 *p(t + 1)* 值，我们可以将相同的方程写成矩阵形式：
- en: '![](../Images/73dc64949c2dc43287b0bc7bbf53b979.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/73dc64949c2dc43287b0bc7bbf53b979.png)'
- en: This equation has absolutely the same form as what we have obtained for the
    PageRank before! *This means these two problems have the same solution and interpretation.*
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方程的形式与我们之前为 PageRank 得到的完全相同！*这意味着这两个问题有相同的解决方案和解释。*
- en: 'At some point, the distribution vector *p(t)* will converge: *p(t + 1) = M
    * p(t) = p(t)*. The converged vector *p(t)* in such case is called the **stationary
    distribution.** At all the following moments of time, the probability of residing
    at any given node does not change.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时刻，分布向量 *p(t)* 会收敛：*p(t + 1) = M * p(t) = p(t)*。在这种情况下，收敛后的向量 *p(t)* 被称为
    **平稳分布**。在所有后续时刻，驻留在任何给定节点的概率不会改变。
- en: The PageRank score of a node equals the probability that the surfer will be
    located at this node in the future by randomly walking through the graph.
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 节点的 PageRank 得分等于游览者通过随机游走图后，未来会出现在该节点的概率。
- en: Convergence
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收敛
- en: 'The described process of walking throughout the graph is often referred to
    as “**Markov chains**”. There exists a theorem in Markov chains theory which states
    that:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 描述的图遍历过程通常被称为“**马尔可夫链**”。在马尔可夫链理论中存在一个定理，指出：
- en: Under certain conditions on the graph structure, the stationary distribution
    is unique and can be reached with any initial probability distribution at the
    moment t = 0.
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在图结构的某些条件下，稳态分布是唯一的，并且可以通过任意初始概率分布在 t = 0 时到达。
- en: In the following section, we will go more in-depth into the conditions that
    need to be satisfied for the unique convergence. It turns out that for not all
    the graphs the unique convergence can be achieved.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分中，我们将更深入地探讨实现唯一收敛所需满足的条件。结果表明，并非所有图都能实现唯一收敛。
- en: Principally, there exist 2 kinds of cases that we want to avoid at all costs.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，我们希望避免两种情况。
- en: Dead ends
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 死胡同
- en: 'Nodes that do not have out links are called **dead ends**. The problem with
    such kind of nodes is that because of them the total importance leaks out of the
    network. Here is an example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 没有出链接的节点称为**死胡同**。这种节点的问题在于它们会使总权重从网络中泄漏。以下是一个示例：
- en: '![](../Images/4dbf32d49a466b74634e3bf3058fc73c.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4dbf32d49a466b74634e3bf3058fc73c.png)'
- en: Dead end problem. At the moment t = 2, the importance leaks out. At the moment
    t = 3, the rank vector converges.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 死胡同问题。在时刻 t = 2，权重泄漏。在时刻 t = 3，排名向量收敛。
- en: Spider trap
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 蜘蛛陷阱
- en: 'A group of nodes form a **spider trap** if they do not have out links to other
    nodes outside of this group. Basically, once there, it is impossible to get outside
    of this group of nodes. Spider traps lead to the two following problems:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一组节点没有指向该组外其他节点的出链接，则该组节点形成**蜘蛛陷阱**。基本上，一旦进入这些节点，就无法离开这个节点组。蜘蛛陷阱会导致以下两个问题：
- en: The algorithm never converges.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法从不收敛。
- en: The group of nodes forming a spider trap absorbs all the graph importance. As
    a result, these nodes have very high importance while other nodes have importance
    being equal to 0.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形成蜘蛛陷阱的节点组吸收了所有图的权重。结果，这些节点的权重非常高，而其他节点的权重为0。
- en: 'The first problem is illustrated in the figure below:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题如下面的图所示：
- en: '![](../Images/62a0855f44eea35bcf6a46157cbf815b.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/62a0855f44eea35bcf6a46157cbf815b.png)'
- en: Spider trap problem. Starting from the moment t = 0, the ranks of 1 and 0 infinitely
    alternate between two nodes. As a result, the algorithm never converges.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 蜘蛛陷阱问题。从时刻 t = 0 开始，1 和 0 的排名在两个节点之间无限交替。结果，算法从不收敛。
- en: The absorption of importance is demonstrated in the next figure. Though it might
    not look like a serious problem in the toy example below, imagine a web network
    with millions of web pages where several of them form a spider trap. As a consequence,
    these several pages will distribute all of the available importance while the
    importance of all other web pages will be set to 0\. Obviously, this is not what
    we normally want in real life.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 权重的吸收在下图中展示。虽然在下面的玩具示例中可能看起来不是一个严重的问题，但想象一个有数百万网页的网络，其中几个网页形成了蜘蛛陷阱。因此，这几个页面将分配所有可用的权重，而所有其他网页的权重将被设置为0。显然，这不是我们在现实中通常期望的情况。
- en: '![](../Images/6fc95ec057ad88ff91ebadbccbad3894.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6fc95ec057ad88ff91ebadbccbad3894.png)'
- en: Nodes b and d form a spider trap. As a result, at the moment t = 18 they already
    absorb all of the importance while other nodes are left with zero importance.
    Starting from this moment, the importance alternates between nodes b and d making
    the algorithm divergent.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 节点 b 和 d 形成了一个蜘蛛陷阱。结果，在时刻 t = 18 时，它们已经吸收了所有的权重，而其他节点的权重为零。从此时开始，权重在节点 b 和 d
    之间交替，使得算法发散。
- en: Teleports
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传送
- en: 'One of the solutions proposed by Google is to add the following condition before
    each move of the surfer:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Google 提出的一个解决方案是在每次移动前添加以下条件：
- en: With probability *β*, move to another linked node.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以概率 *β*，移动到另一个链接的节点。
- en: With probability *(1 — β)*, move to a random node (through a **teleport**).
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以概率 *(1 — β)*，通过**传送**移动到一个随机节点。
- en: The parameter *β* is called the **dumping factor**. Authors of the original
    PageRank algorithm recommend choosing the value for *β = 0.85* meaning that on
    average after 5 transitions the surfer will randomly jump to another node. The
    idea is that if the surfer falls into a spider trap, then after some time it will
    eventually get out of there through a teleport.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 参数 *β* 被称为 **衰减因子**。原始 PageRank 算法的作者建议选择 *β = 0.85*，这意味着平均来说，冲浪者在 5 次过渡后会随机跳到另一个节点。这个想法是，如果冲浪者陷入了蜘蛛陷阱，那么经过一段时间，它最终会通过传送门离开那里。
- en: The diagram below shows how teleports can help to deal with the spider trap
    problem. If the surfer walks into the node *c*, then it will stay there forever.
    Introducing teleports (blue lines) helps eliminating this problem guaranteeing
    that after some time the surfer will have to walk to another random node.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了传送门如何帮助处理蜘蛛陷阱问题。如果冲浪者走到节点 *c*，那么它将永远停留在那里。引入传送门（蓝线）有助于消除这个问题，确保在一段时间后，冲浪者将不得不移动到另一个随机节点。
- en: '![](../Images/035f46ce60ec11406c0dbf59520388b6.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/035f46ce60ec11406c0dbf59520388b6.png)'
- en: Teleports (blue lines) eliminate the spider trap problem
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 传送门（蓝线）消除了蜘蛛陷阱问题
- en: 'However, for dead-end nodes, we need to slightly modify the approach. From
    one of the examples above, we know that dead ends lead to importance leakage in
    a graph. This phenomenon can be observed during the power iteration method, when
    the rank vector becomes full of zeros because of a corresponding zero column in
    the initial matrix *G*. Ultimately, what we can do is the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于死胡同节点，我们需要稍微修改方法。从上述一个例子中，我们知道死胡同会导致图中的重要性泄漏。这种现象可以在幂迭代方法中观察到，当秩向量因为初始矩阵
    *G* 中的零列而变成全零。最终，我们可以做的是：
- en: Whenever the surfer lands on a dead-end node, then it should immediately jump
    to a random node (with an equal probability) of the graph.
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 每当冲浪者到达一个死胡同节点时，它应该立即跳到图中的一个随机节点（概率相等）。
- en: 'In fact, we can modify the initial matrix *G* to satisfy this statement: we
    just need to replace zeros to *1 / n* in place of all the elements of the columns
    of all dead-end nodes of matrix *G*. The example below demonstrates this principle.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以修改初始矩阵 *G* 来满足这一声明：我们只需将所有死胡同节点的列中的所有元素的零替换为 *1 / n*。下面的示例演示了这一原理。
- en: '![](../Images/32aeee48af04e636380c61882d60595f.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/32aeee48af04e636380c61882d60595f.png)'
- en: The node *c* is a dead-end node with a corresponding column of zeros in the
    matrix *G*. Adding *n = 3* teleports from *c* to all of the nodes of the graph
    imposes equal probability *p = 1 / 3* of moving from *c* to any node. To account
    for this, we fill the column of the matrix *G* corresponding to node c with values
    of *1 / 3*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 节点 *c* 是一个死胡同节点，在矩阵 *G* 中对应一列全零的列。将 *n = 3* 个传送门从 *c* 添加到图中的所有节点，会使从 *c* 到任何节点的移动概率
    *p = 1 / 3*。为了考虑这一点，我们用 *1 / 3* 填充矩阵 *G* 中与节点 c 对应的列。
- en: We can notice that after adding teleports the sum of all matrix columns is now
    equal to 1\. In other words, the matrix *G* becomes stochastic. This is an essential
    property which we will be used later.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以注意到，添加传送门后，所有矩阵列的和现在等于 1。换句话说，矩阵 *G* 变成了随机链。这是一个重要的属性，我们将在后面使用。
- en: Convergence condition
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 收敛条件
- en: There exists a crucial theorem from the theory of Markov chains that defines
    the convergence condition.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 马尔可夫链理论中存在一个关键定理定义了收敛条件。
- en: For any start vector, the transition matrix G converges to a unique positive
    stationary distribution vector r if the chain corresponding to G is stochastic,
    aperiodic and irreducible.
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于任何起始向量，转移矩阵 G 会收敛到一个唯一的正定平稳分布向量 r，如果对应于 G 的链是随机的、非周期性的和不可约的。
- en: Let us remind the last three properties in this theorem and check if introduced
    teleports solve the problems above.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下这个定理中的最后三个属性，并检查引入的传送门是否解决了上述问题。
- en: A chain G is called stochastic if sum of its each column equals to 1.
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个链 G 被称为随机链，如果其每一列的和等于 1。
- en: As we observed above, adding teleports to dead-end nodes eliminates zero columns
    in the matrix and makes the sum of all its columns equal to 1\. The condition
    is already satisfied.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，将传送门添加到死胡同节点消除了矩阵中的零列，使所有列的和等于 1。这个条件已经满足。
- en: A chain G is called periodic if there exists a number k > 1 that the path length
    between any pair of nodes is always a multiple of k. Otherwise, the chain is called
    aperiodic.
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个链 G 被称为周期链，如果存在一个数字 k > 1，使得任何一对节点之间的路径长度总是 k 的倍数。否则，链被称为非周期链。
- en: This condition means that any return to the same state must occur in multiple
    of *k* times. In the case of aperiodicity, the return occurs at irregular times.
    Basically, the condition refers to the spider trap problem. Since we have already
    dealt with spider traps by adding teleports, the chain *G* is aperiodic.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个条件意味着返回到同一状态的次数必须是 *k* 的倍数。在非周期性的情况下，返回会在不规则的时间发生。基本上，这个条件涉及到蜘蛛陷阱问题。由于我们已经通过添加传送门解决了蜘蛛陷阱问题，因此链
    *G* 是非周期的。
- en: A chain G is called irreducible if the probability of transitioning from any
    one node to any another node is always greater than 0.
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果从任意一个节点到任何其他节点的过渡概率始终大于 0，则链 G 被称为不可约的。
- en: This condition implies that there always exists a link between any two nodes,
    so it is impossible to stuck at any node. In other words, the matrix *G* needs
    to consist of all non-zero elements. We are going to see in the next section below
    how this condition will be satisfied by connecting all the nodes of the graph.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个条件意味着任意两个节点之间总是存在一个链接，因此不可能卡在任何一个节点上。换句话说，矩阵 *G* 需要包含所有非零元素。我们将在下一节中看到如何通过连接图中的所有节点来满足这个条件。
- en: Modifying the algorithm
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改算法
- en: 'PageRank algorithm proposed by Google takes the initial matrix *G* and adjusts
    it by adding teleports from dead ends to other nodes. This ensures stochasticity.
    To guarantee aperiodicity and irreducibility it then adds the condition described
    before to each node:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Google 提出的 PageRank 算法以初始矩阵 *G* 为基础，通过将死胡同的传送门添加到其他节点来调整它。这确保了随机性。为了保证非周期性和不可约性，它然后对每个节点添加之前描述的条件：
- en: With probability *β*, move to another linked node.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 *β* 的概率，移动到另一个链接节点。
- en: With probability *(1 — β)*, move to a random node.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 *(1 — β)* 的概率，移动到一个随机节点。
- en: 'Mathematically, it results in the following rank equation for every node:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学上，这导致每个节点的以下等级方程：
- en: '![](../Images/b2dd62e416efb0bbbef6f097444b6cfd.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b2dd62e416efb0bbbef6f097444b6cfd.png)'
- en: Vector equation of PageRank
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: PageRank 的向量方程
- en: 'We can transform this equation into the matrix form:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个方程转换成矩阵形式：
- en: '![](../Images/cc102c6449df56ea5d1ecf82966beb14.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/cc102c6449df56ea5d1ecf82966beb14.png)'
- en: Matrix equation of PageRank from Google
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Google 的 PageRank 矩阵方程
- en: '![](../Images/854a444ae13eff395a48cdd56c6e1ae9.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/854a444ae13eff395a48cdd56c6e1ae9.png)'
- en: The matrix R must satisfy the necessary conditions for existence of unique stationary
    distribution r which needs to be found.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵 R 必须满足唯一平稳分布 r 存在的必要条件，而这个分布需要被找到。
- en: 'Let us draw the modified graph and the corresponding transition matrix R from
    on of the examples above:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们绘制修改后的图和上面某个示例的相应转移矩阵 R：
- en: '![](../Images/b3ccbea245e7b847d45dd6ecd242bae4.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b3ccbea245e7b847d45dd6ecd242bae4.png)'
- en: Matrix R composed from the original link matrix G and the teleport matrix. In
    this example *β = 0.9.*
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从原始链接矩阵 G 和传送门矩阵组成的矩阵 R。在这个例子中 *β = 0.9*。
- en: Increasing efficiency
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高效率
- en: The only problem left for us is how to store the transition matrix *R.* Remember
    that *R* is a square matrix of size *n x n* where *n* is the number of web pages.
    Currently, Google has more than 25 billion web pages! The matrix R does not have
    any zeros, so it is dense which means we have to fully store it. Let us assume
    that every matrix element requires 4 bytes to be stored. The total memory size
    required to store the matrix *R* equals *(25 * 10⁹)² * 4* (bytes) *~ 3 * 10²¹*
    (bytes). This is a gigantic memory size! We need to come up with another approach
    to reduce at least by several orders.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一剩下的问题是如何存储转移矩阵 *R*。记住 *R* 是一个大小为 *n x n* 的方阵，其中 *n* 是网页的数量。目前，Google 拥有超过
    250 亿个网页！矩阵 R 不含任何零，因此它是密集的，这意味着我们必须完全存储它。假设每个矩阵元素需要 4 字节存储。存储矩阵 *R* 所需的总内存大小等于
    *(25 * 10⁹)² * 4*（字节）*~ 3 * 10²¹*（字节）。这是一个巨大的内存大小！我们需要想出另一种方法，将其至少减少几个数量级。
- en: 'Firstly, we can simply notice that adding teleports is equivalent to reducing
    initial matrix *G* elements by *(1 — β)*% and distributing them evenly across
    every node. Keeping this in mind we can transform the matrix equation of PageRank
    into another format:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以简单地注意到，添加传送门等同于将初始矩阵 *G* 的元素减少 *(1 — β)*% 并均匀分配到每个节点。牢记这一点，我们可以将 PageRank
    的矩阵方程转换成另一种格式：
- en: '![](../Images/ccb97176c8743f80c2300dace06e54f7.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ccb97176c8743f80c2300dace06e54f7.png)'
- en: Transforming PageRank equation
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 转换 PageRank 方程
- en: Let us look at the last obtained equation. *G* is the initial link matrix with
    most of the elements being equal to 0\. Why is it so? In reality, if you take
    any web page, it will probably contain at most a few dozen links to other web
    pages. Keeping in mind that are more than 25 billion web pages we get that the
    relative number of total links compared to the number of web pages is extremely
    small. Therefore, there are a lot of zeros in *G*, so *G* is sparse.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下最后得到的方程。*G*是初始链接矩阵，大多数元素都等于0。为什么会这样？实际上，如果你查看任何网页，它可能只包含最多几十个指向其他网页的链接。考虑到有超过250亿个网页，我们得到的总链接数相对于网页数量是极其少的。因此，*G*中有很多零，*G*是稀疏的。
- en: Storing sparse matrices requires much less memory than dense ones. Let us assume
    that each web page links on average to other 40 pages. The total number of bytes
    required to store the matrix G now becomes *25 * 10⁹ * 40* (bytes) *= 10¹²* (bytes)
    *= 1* (TB). It turns out we only need 1 terabyte to store *G*. Compared to what
    we had previously, this is a fabulous improvement!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 存储稀疏矩阵所需的内存远远少于密集矩阵。假设每个网页平均链接到其他40个网页。现在存储矩阵G所需的总字节数变为*25 * 10⁹ * 40*（字节）*
    = 10¹²*（字节）* = 1*（TB）。结果是，我们只需要1TB来存储*G*。与之前相比，这是一个巨大的改进！
- en: In fact, at each iteration, we only need to compute the multiplication of matrix
    *G* by vector *r*, multiply it by *β* and add a constant *(1 — β) / n* to each
    element of the resulting vector.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在每次迭代中，我们只需计算矩阵*G*与向量*r*的乘积，将其乘以*β*，并在结果向量的每个元素中加上常数*(1 — β) / n*。
- en: '![](../Images/4ca378c1728b589b1fc29c52ed89c394.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4ca378c1728b589b1fc29c52ed89c394.png)'
- en: Resulting PageRank equation
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 结果PageRank方程
- en: Also keep in mind that if the initial chain *G* contains dead-end nodes, then
    the sum of vector *r* at each iteration will be less than 1\. To deal with this,
    it is enough to renormalise it, so all the vector components sum up to 1.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，如果初始链*G*包含死节点，那么每次迭代时向量*r*的总和将小于1。为了解决这个问题，只需对其进行重新归一化，使得所有向量组件的总和为1。
- en: Complete algorithm
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完整算法
- en: In the figure below we can see the full version of the PageRank algorithm. At
    each iteration, the update of ranks proceeds in 2 stages. The first stage includes
    only update according to the initial matrix *G*. Then we sum up the components
    of the rank vector into the variable *s*. This way, the value of *(1 — s)* is
    the value by which the total input rank of a single node was reduced. To compensate
    for this, in the second stage, we account for teleports and add them from a node
    to all the nodes with the equal value of *(1 — s) / n*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，我们可以看到PageRank算法的完整版本。在每次迭代中，排名更新分为两个阶段。第一阶段仅根据初始矩阵*G*进行更新。然后我们将排名向量的组件汇总到变量*s*中。这样，*(1
    — s)*的值就是单个节点的总输入排名减少的值。为了弥补这一点，在第二阶段，我们考虑了传送，并将它们从一个节点添加到所有节点中，值为*(1 — s) / n*。
- en: '![](../Images/0773d09b8c550ebf9178f9f12bc7710a.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0773d09b8c550ebf9178f9f12bc7710a.png)'
- en: Complete PageRank algorithm
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的PageRank算法
- en: Conclusion
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: In this article, we have looked through different formulations of the PageRank
    algorithm to ultimately come up with its optimised version. Despite the existence
    and evolution of other methods for ranking search results, PageRank remains the
    most efficient algorithm among others which works under the hood of Google’s search
    engine.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们探讨了PageRank算法的不同公式，以最终得出其优化版本。尽管存在并发展了其他用于排名搜索结果的方法，PageRank仍然是Google搜索引擎背后最有效的算法之一。
- en: References
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: The logical structure of this article is based on the lecture from Stanford
    University on [large graphs](http://snap.stanford.edu/class/cs246-2022/slides/09-pagerank.pdf).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 本文的逻辑结构基于斯坦福大学关于[大图](http://snap.stanford.edu/class/cs246-2022/slides/09-pagerank.pdf)的讲座。
- en: '[Analysis of Large Graphs: Link Analysis, PageRank](http://snap.stanford.edu/class/cs246-2022/slides/09-pagerank.pdf)'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[大型图分析：链接分析，PageRank](http://snap.stanford.edu/class/cs246-2022/slides/09-pagerank.pdf)'
- en: '[Mining of Massive Datasets | Jure Leskovec, Anand Rajaraman, Jeff Ullman](http://www.mmds.org)'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[大规模数据集的挖掘 | Jure Leskovec, Anand Rajaraman, Jeff Ullman](http://www.mmds.org)'
- en: '[PageRank: Standing on the shoulders of giants](https://arxiv.org/pdf/1002.2858.pdf)'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[PageRank: 站在巨人的肩膀上](https://arxiv.org/pdf/1002.2858.pdf)'
- en: '*All images unless otherwise noted are by the author*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*除非另有说明，否则所有图片均由作者提供*'
