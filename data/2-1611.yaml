- en: Organizing a Machine Learning Monorepo with Pants
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Pants 组织机器学习单一仓库
- en: 原文：[https://towardsdatascience.com/organizing-a-machine-learning-monorepo-with-pants-8e0570de0c4c](https://towardsdatascience.com/organizing-a-machine-learning-monorepo-with-pants-8e0570de0c4c)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/organizing-a-machine-learning-monorepo-with-pants-8e0570de0c4c](https://towardsdatascience.com/organizing-a-machine-learning-monorepo-with-pants-8e0570de0c4c)
- en: MLOps
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MLOps
- en: Streamline your ML workflow management
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简化你的机器学习工作流管理
- en: '[](https://michaloleszak.medium.com/?source=post_page-----8e0570de0c4c--------------------------------)[![Michał
    Oleszak](../Images/61b32e70cec4ba54612a8ca22e977176.png)](https://michaloleszak.medium.com/?source=post_page-----8e0570de0c4c--------------------------------)[](https://towardsdatascience.com/?source=post_page-----8e0570de0c4c--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----8e0570de0c4c--------------------------------)
    [Michał Oleszak](https://michaloleszak.medium.com/?source=post_page-----8e0570de0c4c--------------------------------)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://michaloleszak.medium.com/?source=post_page-----8e0570de0c4c--------------------------------)[![Michał
    Oleszak](../Images/61b32e70cec4ba54612a8ca22e977176.png)](https://michaloleszak.medium.com/?source=post_page-----8e0570de0c4c--------------------------------)[](https://towardsdatascience.com/?source=post_page-----8e0570de0c4c--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----8e0570de0c4c--------------------------------)
    [Michał Oleszak](https://michaloleszak.medium.com/?source=post_page-----8e0570de0c4c--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----8e0570de0c4c--------------------------------)
    ·20 min read·Aug 18, 2023
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: ·发布于 [Towards Data Science](https://towardsdatascience.com/?source=post_page-----8e0570de0c4c--------------------------------)
    ·阅读时间 20 分钟·2023年8月18日
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/9a6317d603483978f49944578ae5d4f6.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9a6317d603483978f49944578ae5d4f6.png)'
- en: Have you ever copy-pasted chunks of utility code between projects, resulting
    in multiple versions of the same code living in different repositories? Or, perhaps,
    you had to make pull requests to tens of projects after the name of the GCP bucket
    in which you store your data was updated?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经在项目之间复制粘贴公用代码块，导致不同仓库中存在多个版本的相同代码？或者，可能在更新存储数据的 GCP 存储桶名称后，你需要对数十个项目进行拉取请求？
- en: Situations described above arise way too often in ML teams, and their consequences
    vary from a single developer’s annoyance to the team’s inability to ship their
    code as needed. Luckily, there’s a remedy.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 上述情况在机器学习团队中经常发生，其后果从单个开发者的不满到团队无法按需交付代码等各不相同。幸运的是，有解决办法。
- en: Let’s dive into the world of monorepos, an architecture widely adopted in major
    tech companies like Google, and how they can enhance your ML workflows. A monorepo
    offers a plethora of advantages which, despite some drawbacks, make it a compelling
    choice for managing complex machine learning ecosystems.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨单一仓库，这是一种在谷歌等大型科技公司广泛采用的架构，了解它如何提升你的机器学习工作流。单一仓库提供了众多优势，尽管存在一些缺点，但它仍然是管理复杂机器学习生态系统的有力选择。
- en: We will briefly debate monorepos’ merits and demerits, examine why it’s an excellent
    architecture choice for machine learning teams, and peek into how Big Tech is
    using it. Finally, we’ll see how to harness the power of the Pants build system
    to organize your machine learning monorepo into a robust CI/CD build system.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简要讨论单一仓库的优缺点，研究为什么它是机器学习团队的优秀架构选择，并窥探大科技公司如何使用它。最后，我们将了解如何利用 Pants 构建系统将你的机器学习单一仓库组织成一个强大的
    CI/CD 构建系统。
- en: Strap in as we embark on this journey to streamline your ML project management.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 系好安全带，我们将开始简化你的机器学习项目管理之旅。
- en: '*This article was first published on the* [*neptune.ai blog*](https://neptune.ai/blog/organizing-ml-monorepo-with-pants)*.*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*本文最初发布在* [*neptune.ai 博客*](https://neptune.ai/blog/organizing-ml-monorepo-with-pants)*。*'
- en: '![](../Images/6fb7ffce5da7442155bbf5238b9548e7.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6fb7ffce5da7442155bbf5238b9548e7.png)'
- en: What is a monorepo?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是单一仓库？
- en: '![](../Images/586c839a5c9dda9f07343a12f9b94634.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/586c839a5c9dda9f07343a12f9b94634.png)'
- en: Machine Learning Monorepo. Image by the author, via neptune.ai.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习单一仓库。作者提供的图片，来源于 neptune.ai。
- en: A monorepo (short for monolithic repository) is a software development strategy
    where code for many projects is stored in the same repository. The idea can be
    as broad as *all* of the company code written in a variety of programming languages
    stored together (did somebody say Google?) or as narrow as a couple of Python
    projects developed by a small team thrown into a single repository.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Monorepo（单体仓库的缩写）是一种软件开发策略，其中多个项目的代码存储在同一个仓库中。这个想法可以广泛到*所有*公司代码用各种编程语言存储在一起（有人说
    Google 吗？），也可以狭窄到由一个小团队开发的几个 Python 项目放在一个仓库中。
- en: In this blog post, we focus on repositories storing machine learning code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇博客文章中，我们关注于存储机器学习代码的仓库。
- en: '![](../Images/abba89053139f8144e87c408977bbddb.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/abba89053139f8144e87c408977bbddb.png)'
- en: Monorepos vs. polyrepos
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Monorepos 与 polyrepos
- en: Monorepos are in stark contrast to the polyrepos approach, where each individual
    project or component sits in its own repository. A lot has been said about the
    advantages and disadvantages of both approaches, and we won’t go down this rabbit
    hole too deep. Let’s just put the basics on the table.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Monorepos 与 polyrepos 方法形成鲜明对比，在 polyrepos 中，每个单独的项目或组件都在其自己的仓库中。关于这两种方法的优缺点已经讨论了很多，我们不会过于深入探讨。我们只讨论一些基本内容。
- en: '![](../Images/6a41b74e9bdd87ab9ce5afd2d96e97cd.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6a41b74e9bdd87ab9ce5afd2d96e97cd.png)'
- en: Monorepo architecture. Image by the author, via neptune.ai.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Monorepo 架构。图片由作者提供，通过 neptune.ai。
- en: 'The monorepo architecture offers the following advantages:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Monorepo 架构提供了以下优势：
- en: '**Single CI/CD pipeline**, meaning no hidden deployment knowledge spread across
    individual contributors to different repositories;'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一 CI/CD 管道**，意味着没有隐藏的部署知识分散在不同仓库的个体贡献者之间；'
- en: '**Atomic commits**, given that all projects reside in the same repository,
    developers can make cross-project changes that span across multiple projects but
    are merged as a single commit;'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子提交**，由于所有项目都存在于同一个仓库中，开发人员可以进行跨项目的更改，这些更改跨越多个项目但作为单个提交合并；'
- en: '**Easy sharing** of utilities and templates across projects;'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨项目轻松共享** 公用程序和模板；'
- en: '**Easy unification** of coding standards and approaches;'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轻松统一** 编码标准和方法；'
- en: Better **code discoverability**.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的 **代码可发现性**。
- en: 'Naturally, there are no free lunches. We need to pay for the above goodies,
    and the price comes in the form of:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，没有免费的午餐。我们需要为上述好处付出代价，而代价表现为：
- en: '**Scalability challenges**: As the codebase grows, managing a monorepo can
    become increasingly difficult. At a really large scale, you’ll need powerful tools
    and servers to handle operations like cloning, pulling, and pushing changes, which
    can take a significant amount of time and resources.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性挑战**：随着代码库的增长，管理 monorepo 可能变得越来越困难。在非常大的规模下，你将需要强大的工具和服务器来处理克隆、拉取和推送更改等操作，这可能需要大量的时间和资源。'
- en: '**Complexity**: A monorepo can be more complex to manage, particularly with
    regard to dependencies and versioning. A change in a shared component could potentially
    impact many projects, so extra caution is needed to avoid breaking changes.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂性**：Monorepo 可能更难管理，特别是与依赖和版本控制有关。共享组件的更改可能会影响多个项目，因此需要额外的谨慎以避免破坏性更改。'
- en: '**Visibility and access control**: With everyone working out of the same repository,
    it can be difficult to control who has access to what. While not a disadvantage
    as such, it could pose problems of a legal nature in cases where code is subject
    to a very strict NDA.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可见性和访问控制**：由于每个人都在同一个仓库中工作，控制谁可以访问什么可能会很困难。虽然这本身不是缺点，但在代码受严格 NDA 保护的情况下，可能会引发法律问题。'
- en: The decision as to whether the advantages a monorepo offers are worth paying
    the price is to be determined by each organization or team individually. However,
    unless you are operating at a prohibitively large scale or are dealing with top-secret
    missions, I would argue that — at least when it comes to my area of expertise,
    the machine learning projects — a monorepo is a good architecture choice in most
    cases.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 是否值得支付 monorepo 提供的优势由每个组织或团队单独决定。然而，除非你在极其庞大的规模上运作或处理绝密任务，否则我认为——至少在我擅长的领域，即机器学习项目中——monorepo
    是大多数情况下的良好架构选择。
- en: Let’s talk about why that is.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来谈谈原因。
- en: '![](../Images/23835533a1899635f3612622d3f49523.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/23835533a1899635f3612622d3f49523.png)'
- en: Machine learning with monorepos
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 monorepo 的机器学习
- en: There are at least six reasons why monorepos are particularly suitable for machine
    learning projects.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 至少有六个原因说明单一代码库特别适合机器学习项目。
- en: Data pipeline integration
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据管道集成
- en: Consistency across experiments
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实验间的一致性
- en: Simplified model versioning
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简化模型版本控制
- en: Cross-functional collaboration
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跨职能协作
- en: Atomic changes
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原子性更改
- en: Unification of coding standards
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编码标准的统一
- en: Let’s discuss each of them.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一讨论这些方面。
- en: Data pipeline integration
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据管道集成
- en: Machine learning projects often involve data pipelines that preprocess, transform,
    and feed data into the model. These pipelines might be tightly integrated with
    the ML code. Keeping the data pipelines and ML code in the same repo helps maintain
    this tight integration and streamline the workflow.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习项目通常涉及预处理、转换和将数据输入模型的数据管道。这些管道可能与机器学习代码紧密集成。将数据管道和机器学习代码保存在同一代码库中，有助于保持这种紧密集成，并简化工作流程。
- en: Consistency across experiments
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实验间的一致性
- en: Machine learning development involves a lot of experimentation. Having all experiments
    in a monorepo ensures consistent environment setups and reduces the risk of discrepancies
    between different experiments due to varying code or data versions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习开发涉及大量实验。将所有实验保存在单一代码库中可以确保环境设置的一致性，并减少由于代码或数据版本不同而导致的实验间差异风险。
- en: Simplified model versioning
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简化模型版本控制
- en: In a monorepo, the code and model versions are in sync because they are checked
    into the same repository. This makes it easier to manage and trace model versions,
    which can be especially important in projects where ML reproducibility is critical.
    Just take the commit SHA at any given point in time, and it provides information
    on the state of all models and services.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在单一代码库中，代码和模型版本是同步的，因为它们被检查到同一个仓库中。这使得管理和追踪模型版本变得更加容易，这在机器学习可重复性至关重要的项目中尤其重要。只需查看任何时刻的提交SHA，它即可提供所有模型和服务的状态信息。
- en: Cross-functional collaboration
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨职能协作
- en: Machine learning projects often involve collaboration between data scientists,
    ML engineers, and software engineers. A monorepo facilitates this [cross-functional
    collaboration](https://neptune.ai/blog/ml-collaboration-best-practices-from-ml-teams)
    by providing a single source of truth for all project-related code and resources.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习项目通常涉及数据科学家、机器学习工程师和软件工程师之间的合作。单一代码库通过提供所有项目相关代码和资源的唯一真实来源来促进这种[跨职能协作](https://neptune.ai/blog/ml-collaboration-best-practices-from-ml-teams)。
- en: Atomic changes
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原子性更改
- en: In the context of ML, a model’s performance can depend on various interconnected
    factors like data preprocessing, feature extraction, model architecture, and post-processing.
    A monorepo allows for atomic changes — changes to multiple components can be committed
    as one, ensuring that interdependencies are always in sync.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习的背景下，模型的性能可能依赖于数据预处理、特征提取、模型架构和后处理等各种互相关联的因素。单一代码库允许进行原子性更改——对多个组件的更改可以作为一个整体提交，确保依赖关系始终保持同步。
- en: Unification of coding standards
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码标准的统一
- en: Finally, machine learning teams often include members without a software engineering
    background. These mathematicians, statisticians, and econometricians are brainy
    folks with brilliant ideas and the skills to train models that solve business
    problems. However, writing code that is clean, easy to read, and maintain might
    not always be their strongest side.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，机器学习团队通常包括没有软件工程背景的成员。这些数学家、统计学家和计量经济学家是拥有出色想法和训练解决业务问题模型能力的聪明人才。然而，编写干净、易读且易于维护的代码可能并不是他们最擅长的领域。
- en: A monorepo helps by automatically checking and enforcing coding standards across
    all projects, which not only ensures high code quality but also helps the less
    engineering-inclined team members learn and grow.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 单一代码库通过自动检查和执行所有项目的编码标准，帮助确保高代码质量，并且帮助工程能力较弱的团队成员学习和成长。
- en: '![](../Images/9dbd6e638b6820d6dac1719416168009.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9dbd6e638b6820d6dac1719416168009.png)'
- en: 'How they do it in the industry: famous monorepos'
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行业中的做法：著名的单一代码库
- en: In the software development landscape, some of the largest and most successful
    companies in the world use monorepos. Here are a few notable examples.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发领域，一些全球最大、最成功的公司使用单一代码库。以下是一些值得注意的例子。
- en: '**Google**: Google has long been a staunch advocate for the monorepo approach.
    Their entire codebase, estimated to contain 2 billion lines of code, is contained
    in a single, massive repository. They even [published a paper about it](https://research.google/pubs/pub45424/).'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google**: Google 长期以来一直坚定支持单一代码仓库方法。他们的整个代码库，估计包含 20 亿行代码，都集中在一个庞大的仓库中。他们甚至[发表了一篇相关论文](https://research.google/pubs/pub45424/)。'
- en: '**Meta**: Meta also employs a monorepo for their vast codebase. They created
    a version control system called “Mercurial” to handle the size and complexity
    of their monorepo.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Meta**: Meta 也为其庞大的代码库使用了单一代码仓库。他们创建了一个名为“Mercurial”的版本控制系统，以处理单一代码仓库的规模和复杂性。'
- en: '**Twitter**: Twitter has been managing their monorepo for a long time using
    Pants, the build system we will talk about next!'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Twitter**: Twitter 已经长期使用 Pants 来管理他们的单一代码仓库，接下来我们将讨论这个构建系统！'
- en: Many other companies such as Microsoft, Uber, Airbnb, and Stripe [are using
    the monorepo approach](https://en.wikipedia.org/wiki/Monorepo#:~:text=This%20practice%20dates%20back%20to,of%20code%20and%20daily%20changes)
    at least for some parts of their codebases, too.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他公司，如 Microsoft、Uber、Airbnb 和 Stripe，也[在部分代码库中使用单一代码仓库方法](https://en.wikipedia.org/wiki/Monorepo#:~:text=This%20practice%20dates%20back%20to,of%20code%20and%20daily%20changes)。
- en: Enough of the theory! Let’s take a look at how to actually build a machine learning
    monorepo. Because just throwing what used to be separate repositories into one
    folder does not do the job.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 理论讲解够了！让我们看看如何实际构建一个机器学习单一代码仓库。因为仅仅把曾经分开的仓库放到一个文件夹中是不够的。
- en: '![](../Images/8518f644286399e4088193971a851222.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8518f644286399e4088193971a851222.png)'
- en: How to set up ML monorepo with Python?
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何用 Python 设置机器学习单一代码仓库？
- en: 'Throughout this section, we will base our discussion around a [sample machine
    learning repository](https://github.com/MichalOleszak/pants-monorepo-example)
    I’ve created for this article. It is a simple monorepo holding just one project,
    or module: a hand-written digits classifier called *mnist*, after the famous dataset
    it uses.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将围绕我为本文创建的[示例机器学习仓库](https://github.com/MichalOleszak/pants-monorepo-example)展开讨论。它是一个简单的单一代码仓库，仅包含一个项目或模块：一个名为
    *mnist* 的手写数字分类器，以其使用的著名数据集命名。
- en: All you need to know right now is that in the monorepo’s root, there is a directory
    called mnist, and in it, there is some Python code for training the model, the
    corresponding unit tests, and a Dockerfile to run training in a container.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 目前你只需知道，在单一代码仓库的根目录下，有一个名为 mnist 的目录，其中包含用于训练模型的 Python 代码、相应的单元测试，以及一个用于在容器中运行训练的
    Dockerfile。
- en: '![](../Images/a4c1059a813539b92d0daee3a685d087.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a4c1059a813539b92d0daee3a685d087.png)'
- en: We will be using this small example to keep things simple, but in a larger monorepo,
    *mnist* would be just one of the many project folders in the repo’s root, each
    of which will contain source code, tests, dockerfiles, and requirement files at
    the least.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个小示例来保持简单，但在更大的单一代码仓库中，*mnist* 仅是仓库根目录中的众多项目文件夹之一，每个文件夹至少会包含源代码、测试、Dockerfile
    和需求文件。
- en: '![](../Images/1853da3f4c65f32ad70efa19fd79bd65.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1853da3f4c65f32ad70efa19fd79bd65.png)'
- en: 'Build system: Why do you need one and how to choose it?'
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建系统：你为什么需要一个，以及如何选择？
- en: Why a Build System
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么需要构建系统
- en: Think about all the actions, other than writing code, that the different teams
    developing different projects within the monorepo take as part of their development
    workflow. They would run linters against their code to ensure adherence to style
    standards, run unit tests, build artifacts such as docker containers and Python
    wheels, push them to external artifact repositories, and deploy them to production.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 想一想，除了编写代码，开发不同项目的各个团队在单一代码仓库中的开发工作流中还会采取哪些行动。他们会对代码运行静态分析工具，以确保符合风格标准，运行单元测试，构建例如
    Docker 容器和 Python wheels 这样的工件，将它们推送到外部工件库，并将它们部署到生产环境。
- en: Take testing. You’ve made a change in a utility function you maintain, ran the
    tests, and all’s green. But how can you be sure your change is not breaking code
    for other teams that might be importing your utility? You should run *their* test
    suite, too, of course.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以测试为例。你在维护的工具函数中进行了更改，运行了测试，所有测试都通过了。但是你如何确保你的更改不会破坏其他团队可能正在使用的代码？你当然也应该运行*他们*的测试套件。
- en: 'But to do this, you need to know exactly where the code you changed is being
    used. As the codebase grows, finding this out manually doesn’t scale well. Of
    course, as an alternative, you can always execute all the tests, but again: that
    approach doesn’t scale very well.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 但要做到这一点，你需要准确知道你所更改的代码在哪里被使用。随着代码库的增长，手动查找这点并不高效。当然，作为替代方案，你可以始终执行所有测试，但再次强调：这种方法并不是特别高效。
- en: '![](../Images/5e6003d2707e682757d3b2d4a620c3e6.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5e6003d2707e682757d3b2d4a620c3e6.png)'
- en: 'Why do you need a build system: testing. Image by the author, via neptune.ai.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你需要一个构建系统：测试。图像由作者提供，来自 neptune.ai。
- en: 'Another example: production deployment. Whether you deploy weekly, daily, or
    continuously, when the time comes, you would build all the services in the monorepo
    and push them to production. But hey, do you need to build *all* of them on each
    occasion? That could be time-consuming and expensive at scale.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子：生产部署。无论你是每周、每日还是持续部署，当时间到来时，你会构建 monorepo 中的所有服务并将其推送到生产环境。但，嘿，你需要在每次部署时*全部*构建吗？在大规模时这可能会耗时且成本高昂。
- en: Some projects might not have been updated for weeks. On the other hand, the
    shared utility code they use might have received updates. How do we decide what
    to build? Again, it’s all about dependencies. Ideally, we would only build services
    that have been affected by the recent changes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有些项目可能已经好几周没有更新了。另一方面，它们使用的共享工具代码可能已经进行了更新。我们如何决定构建什么？再次，这全关乎依赖关系。理想情况下，我们只会构建那些受最近更改影响的服务。
- en: '![](../Images/3dfb9abeb2a76fad098602efa7078842.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3dfb9abeb2a76fad098602efa7078842.png)'
- en: 'Why do you need a build system: deployment. Image by author via neptune.ai.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你需要一个构建系统：部署。图像由作者提供，来自 neptune.ai。
- en: All of this can be handled with a simple shell script with a small codebase,
    but as it scales and projects start sharing code, challenges emerge, many of which
    revolve around dependency management.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些在代码库较小的情况下可以通过简单的 shell 脚本处理，但随着规模的扩大和项目开始共享代码，挑战也随之出现，其中许多挑战都围绕着依赖管理。
- en: Picking the right system
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择合适的系统
- en: 'All of the above is not a problem anymore if you invest in a proper build system.
    A build system’s primary task is to build code. And it should do so in a clever
    way: the developer should only need to tell it *what* to build (“build docker
    images affected by my latest commit”, or “run only those tests that cover code
    which uses the method I’ve updated”), but the *how* should be left for the system
    to figure out.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你投资一个合适的构建系统，上述问题将不再存在。构建系统的主要任务是构建代码。它应该以一种聪明的方式来完成这项任务：开发者只需要告诉它*构建什么*（“构建受我最新提交影响的
    Docker 镜像”或“仅运行那些涵盖了我更新的方法的代码的测试”），但*如何*进行则应该留给系统来处理。
- en: There are a couple of great open-source build systems out there. Since most
    machine learning is done in Python, let’s focus on the ones with the best Python
    support. The two most popular choices in this regard are [Bazel](https://bazel.build/)
    and [Pants](https://www.pantsbuild.org/).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个优秀的开源构建系统。由于大多数机器学习是用 Python 完成的，我们来关注一下支持 Python 最好的构建系统。在这方面最受欢迎的两个选择是
    [Bazel](https://bazel.build/) 和 [Pants](https://www.pantsbuild.org/)。
- en: Bazel is an open-source version of Google’s internal build system, Blaze. Pants
    is also heavily inspired by Blaze and it aims for similar technical design goals
    as Bazel. An interested reader will find a good comparison of Pants vs. Bazel
    in this [blog post](https://blog.pantsbuild.org/pants-vs-bazel/) (but keep in
    mind it comes from the Pants devs). The table at the bottom of [monorepo.tools](https://monorepo.tools/)
    offers yet another comparison.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Bazel 是 Google 内部构建系统 Blaze 的开源版本。Pants 也受到 Blaze 的极大启发，并且它旨在实现与 Bazel 类似的技术设计目标。感兴趣的读者可以在这篇
    [博客文章](https://blog.pantsbuild.org/pants-vs-bazel/) 中找到对 Pants 和 Bazel 的比较（但请注意，这来自
    Pants 的开发者）。[monorepo.tools](https://monorepo.tools/) 底部的表格提供了另一种比较。
- en: Both systems are great, and it is not my intention to declare a *better* solution
    here. That being said, Pants is often described as easier to set up, more approachable,
    and well-optimized for Python, which makes it a perfect fit for machine learning
    monorepos.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 两个系统都很棒，我并不打算在这里宣布哪一个*更好*。话虽如此，Pants 通常被描述为更易于设置，更易于接触，并且对 Python 进行了良好的优化，这使得它非常适合机器学习
    monorepo。
- en: In my personal experience, the decisive factor that made me go with Pants was
    its active and helpful community. Whenever you have questions or doubts, just
    post on the community Slack channel, and a bunch of supportive folks will help
    you out soon.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我个人的经验，决定使用Pants的关键因素是它活跃且乐于助人的社区。每当你有问题或疑虑时，只需在社区Slack频道发帖，许多支持者将很快帮助你解决。
- en: '![](../Images/23835533a1899635f3612622d3f49523.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/23835533a1899635f3612622d3f49523.png)'
- en: Introducing Pants
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Pants
- en: Alright, time to get to the meat of it! We will go step by step, introducing
    different Pants’ functionalities and how to implement them. Again, you can check
    out the associated sample repo [here](https://github.com/MichalOleszak/pants-monorepo-example/tree/main).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，进入重点吧！我们将一步一步介绍不同的Pants功能及其实现方法。你也可以在[这里](https://github.com/MichalOleszak/pants-monorepo-example/tree/main)查看相关的示例代码库。
- en: Setup
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置
- en: Pants is installable with pip. In this tutorial, we will use the most recent
    stable version as of this writing, 2.15.1.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Pants可以通过pip安装。在本教程中，我们将使用截至本文撰写时的最新稳定版本2.15.1。
- en: '[PRE0]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Pants is configurable through a global master config file named [*pants.toml*](https://github.com/MichalOleszak/pants-monorepo-example/blob/main/pants.toml)*.*
    In it, we can configure Pants’ own behavior as well as the settings of downstream
    tools it relies on, such as pytest or mypy.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Pants可以通过一个名为[*pants.toml*](https://github.com/MichalOleszak/pants-monorepo-example/blob/main/pants.toml)*.*
    的全局主配置文件进行配置。在其中，我们可以配置Pants自身的行为以及它依赖的下游工具的设置，如pytest或mypy。
- en: Let’s start with a bare minimum *pants.toml:*
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个最基本的*pants.toml* 开始：
- en: '[PRE1]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the global section, we define the Pants version and the backend packages
    we need. These packages are Pants’ engines that support different features. For
    starters, we only include the Python backend.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在全局部分，我们定义Pants版本和我们需要的后端包。这些包是Pants的引擎，支持不同的功能。作为起点，我们只包含Python后端。
- en: In the source section, we set the source to the repository’s root. Since version
    2.15, to make sure this is picked up, we also need to add an [empty BUILD_ROOT
    file](https://github.com/MichalOleszak/pants-monorepo-example/blob/main/BUILD_ROOT)
    at the repository’s root.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在源部分，我们将源设置为代码库的根目录。从版本2.15开始，为了确保这一点，我们还需要在代码库的根目录下添加一个[空的 BUILD_ROOT 文件](https://github.com/MichalOleszak/pants-monorepo-example/blob/main/BUILD_ROOT)。
- en: Finally, in the Python section, we choose the Python version to use. Pants will
    browse our system in search of a version that matches the conditions specified
    here, so make sure you have this version installed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在Python部分，我们选择要使用的Python版本。Pants会在我们的系统中查找符合这里指定条件的版本，因此请确保你已经安装了这个版本。
- en: 'That’s a good start! Next, let’s take a look at any build system’s heart: the
    BUILD files.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个好的开始！接下来，让我们来看一下任何构建系统的核心：构建文件。
- en: Build files
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建文件
- en: Build files are configuration files used to define targets (what to build) and
    their dependencies (what they need to work) in a declarative way.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 构建文件是用于以声明方式定义目标（要构建的内容）及其依赖项（它们工作所需的内容）的配置文件。
- en: You can have multiple build files at different levels of the directory tree.
    The more there are, the more granular the control over dependency management.
    Indeed, Google has a build file in virtually every directory in their repo.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在目录树的不同层级拥有多个构建文件。文件越多，对依赖管理的控制就越细粒度。实际上，Google在其代码库中的几乎每个目录都有一个构建文件。
- en: 'In our example, we will use three build files:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将使用三个构建文件：
- en: '`mnist/BUILD` — in the project directory, this build file will define the Python
    requirements for the project and the docker container to build;'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mnist/BUILD` — 在项目目录中，这个构建文件将定义项目的Python需求和要构建的docker容器；'
- en: '`mnist/src/BUILD` — in the source code directory, this build file will define
    Python sources, that is, files to be covered by Python-specific checks;'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mnist/src/BUILD` — 在源代码目录中，这个构建文件将定义Python源文件，即需要进行Python特定检查的文件；'
- en: '`mnist/tests/BUILD` — in the tests directory, this build file will define which
    files to run with Pytest and what dependencies are needed for these tests to execute.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mnist/tests/BUILD` — 在测试目录中，这个构建文件将定义哪些文件使用Pytest运行，以及这些测试执行所需的依赖。'
- en: 'Let’s take a look at the `mnist/src/BUILD`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`mnist/src/BUILD`：
- en: '[PRE2]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And `mnist/BUILD` looks like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`mnist/BUILD` 看起来是这样的：'
- en: '[PRE3]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The two entries in the build files are referred to as targets. First, we have
    a Python sources target, which we aptly call *python*, although the name could
    be anything. We define our Python sources as all .py files in the directory. This
    is relative to the build file’s location, that is: even if we had Python files
    outside of the *mnist/src* directory, these sources only capture the contents
    of the *mnist/src* folder. There is also a resolve filed; we will talk about it
    in a moment.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 构建文件中的两个条目被称为目标。首先，我们有一个 Python 源代码目标，我们称之为*python*，虽然名称可以是任何东西。我们将 Python 源代码定义为目录中的所有
    .py 文件。这是相对于构建文件的位置，也就是说：即使我们在*mnist/src*目录之外有 Python 文件，这些源代码只捕获*mnist/src*文件夹中的内容。还有一个
    resolve 字段，我们稍后会谈论它。
- en: Next, we have the Python requirements target. It tells Pants where to find the
    requirements needed to execute our Python code (again, relative to the build file’s
    location, which is in the mnist project’s root in this case).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有 Python 需求目标。它告诉 Pants 在哪里可以找到执行我们 Python 代码所需的需求（同样，相对于构建文件的位置，在这个例子中是
    mnist 项目的根目录）。
- en: 'This is all we need to get started. To make sure the build file definition
    is correct, let’s run:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要的所有信息。为了确保构建文件定义正确，让我们运行：
- en: '[PRE4]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As expected, we get: “No required changes to BUILD files found.” as the output.
    Good!'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，我们得到： “未发现对 BUILD 文件的必要更改。”作为输出。很好！
- en: Let’s spend a bit more time on this command. In a nutshell, a bare *pants tailor*
    can automatically create build files. However, it sometimes tends to add too many
    for one’s needs, which is why I tend to add them manually, followed by the command
    above that checks their correctness.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再花点时间了解一下这个命令。简而言之，裸的*pants tailor*可以自动创建构建文件。然而，它有时会添加过多的文件，这就是为什么我倾向于手动添加文件，然后使用上述命令检查其正确性。
- en: The double semicolon at the end is the Pants notation which tells it to run
    the command over the entire monorepo. Alternatively, we could have replaced it
    with *mnist::* to run only against the *mnist* module.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 结尾的双分号是 Pants 的表示法，它告诉 Pants 对整个 monorepo 运行该命令。或者，我们可以用*mnist::*替换它，以仅对*mnist*模块运行。
- en: Dependencies and lockfiles
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖项和锁定文件
- en: To do efficient dependency management, Pants relies on lockfiles. Lockfiles
    record the specific versions and sources of all dependencies used by each project.
    This includes both direct and transitive dependencies.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行高效的依赖管理，Pants 依赖于锁定文件。锁定文件记录每个项目所使用的所有依赖项的特定版本和来源。这包括直接依赖和传递依赖。
- en: By capturing this information, lockfiles ensure that the same versions of dependencies
    are used consistently across different environments and builds. In other words,
    they serve as a snapshot of the dependency graph, ensuring reproducibility and
    consistency across builds.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过捕捉这些信息，锁定文件确保在不同环境和构建中一致地使用相同版本的依赖项。换句话说，它们作为依赖关系图的快照，确保在构建中的可重现性和一致性。
- en: To generate a lockfile for our *mnist* module, we need the following addition
    to *pants.toml:*
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要为我们的*mnist*模块生成锁定文件，我们需要在*pants.toml*中添加以下内容：
- en: '[PRE5]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We enable the resolves (Pants term for lockfiles’ environments) and define
    one for *mnist* passing a file path. We also choose it as the default one. This
    is the resolve we have passed to Python sources and Python requirements targets
    before, which is how they know what dependencies are needed. We can now run:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启用了 resolves（Pants 对锁定文件环境的术语），并为*mnist*定义了一个，传递了一个文件路径。我们还将其设置为默认的。这是我们之前传递给
    Python 源代码和 Python 需求目标的 resolve，这就是它们知道需要什么依赖项的方式。我们现在可以运行：
- en: '[PRE6]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'to get:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以获取：
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This has created a file at *mnist/mnist.lock*. This file should be checked with
    git if you intend to use Pants for your remote CI/CD. And naturally, it needs
    to be updated every time you update the *requirements.txt* file.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这在*mnist/mnist.lock*创建了一个文件。如果你打算在远程 CI/CD 中使用 Pants，该文件应该用 git 进行检查。而且，自然地，每次更新*requirements.txt*文件时，它都需要更新。
- en: With more projects in the monorepo, you would rather generate the lockfiles
    selectively for the project that needs it, e.g. `pants generate-lockfiles --resolve=mnist`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 monorepo 中有更多项目时，你可能会选择有选择性地为需要它的项目生成锁定文件，例如 `pants generate-lockfiles --resolve=mnist`。
- en: That’s it for the setup! Now let’s use Pants to do something useful for us.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 设置完成了！现在让我们使用 Pants 做一些对我们有用的事情。
- en: Unifying code style with Pants
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Pants 统一代码风格
- en: Pants natively supports a number of Python linters and code formatting tools
    such as Black, yapf, Docformatter, Autoflake, Flake8, isort, Pyupgrade, or Bandit.
    They are all used in the same way; in our example, let’s implement Black and Docformatter.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Pants 本身支持多种 Python linter 和代码格式化工具，如 Black、yapf、Docformatter、Autoflake、Flake8、isort、Pyupgrade
    或 Bandit。它们的使用方式相同；在我们的示例中，让我们实现 Black 和 Docformatter。
- en: To do so, we add appropriate two backends to *pants.toml:*
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们向*pants.toml*中添加两个适当的后端：
- en: '[PRE8]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We could configure both tools if we wanted to by adding additional sections
    below in the toml file, but let’s stick with the defaults now.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想的话，可以通过在 toml 文件中添加额外的部分来配置这两个工具，但现在我们先使用默认设置。
- en: To use the formatters, we need to execute what’s called a Pants goal. In this
    case, two goals are relevant.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用格式化工具，我们需要执行一个称为 Pants 目标的操作。在这种情况下，有两个目标相关。
- en: First, the lint goal will run both tools (in the order in which they are listed
    in backend packages, so Docformatter first, Black second) in the check mode.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，lint 目标将以检查模式运行这两种工具（按照它们在后端包中列出的顺序，所以 Docformatter 先，Black 后）。
- en: '[PRE9]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It looks like our code adheres to the standards of both formatters! However,
    if that was not the case, we could execute the fmt (short for “format”) goal that
    adapts the code appropriately:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们的代码符合这两个格式化工具的标准！但是，如果不是这样，我们可以执行 fmt（“格式化”的缩写）目标，以适当地调整代码：
- en: '[PRE11]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In practice, you might want to use more than these two formatters. In this case,
    you may need to update each formatter’s config to ensure that it is compatible
    with the others. For instance, if you are using Black with its default config
    as we have done here, it will expect code lines not to exceed 88 characters.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可能会想使用多于这两个格式化工具。在这种情况下，你可能需要更新每个格式化工具的配置，以确保它与其他工具兼容。例如，如果你使用的是 Black
    的默认配置，就像我们这里做的一样，它将期望代码行不超过 88 个字符。
- en: 'But if you then want to add isort to automatically sort your imports, they
    will clash: isort truncates lines after 79 characters. To make isort compatible
    with Black, you would need to include the following section in the toml file:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果你还想添加 isort 来自动排序你的导入项，它们会发生冲突：isort 会在 79 个字符后截断行。为了使 isort 与 Black 兼容，你需要在
    toml 文件中包含以下部分：
- en: '[PRE12]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: All formatters can be configured in the same way in *pants.toml* by passing
    the arguments to their underlying tool.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 所有格式化工具都可以通过将参数传递给其底层工具的方式在*pants.toml*中进行配置。
- en: Testing with Pants
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Pants 进行测试
- en: Let’s run some tests! To do this, we need two steps.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行一些测试！为此，我们需要两个步骤。
- en: 'First, we add the appropriate sections to *pants.toml*:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们向*pants.toml*中添加相应的部分：
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These settings make sure that as the tests are run, a test coverage report is
    produced. We also pass a couple of custom Pytest options to adapt its output.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置确保在运行测试时会生成测试覆盖率报告。我们还传递了一些自定义的 Pytest 选项来调整其输出。
- en: 'Next, we need to go back to our `mnist/tests/BUILD` file and add a Python tests
    target:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要回到我们的 `mnist/tests/BUILD` 文件，并添加一个 Python 测试目标：
- en: '[PRE14]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We call it tests and specify the resolve (i.e. lockfile) to use. Sources are
    the locations where Pytest will be let in to look for tests to run; here, we explicitly
    pass all .py files prefixed with “test_”.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其称为 tests 并指定要使用的 resolve（即锁定文件）。Sources 是 Pytest 查找要运行的测试的地方；在这里，我们显式传递了所有以“test_”开头的
    .py 文件。
- en: 'Now we can run:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行：
- en: '[PRE15]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'to get:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 获取：
- en: '[PRE16]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you can see, it took around three seconds to run this test suite. Now, if
    we re-run it again, we will get the results immediately:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，运行这个测试套件大约花了三秒钟。如果我们再次运行它，我们将立即得到结果：
- en: '[PRE17]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice how Pants tells us these results are memoized, or cached. Since no changes
    have been made to the tests, the code being tested, or the requirements, there
    is no need to actually re-run the tests — their results are guaranteed to be the
    same, so they are just served from the cache.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Pants 如何告诉我们这些结果是被缓存的。由于测试、测试的代码或要求没有更改，因此无需实际重新运行测试——它们的结果是保证一致的，因此只是从缓存中提供。
- en: Checking static typing with Pants
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Pants 检查静态类型
- en: Let’s add one more code quality check. Pants allows us to use mypy to check
    static typing in Python. All we need to do is add the mypy backend in *pants.toml:*
    `pants.backend.python.typecheck.mypy`*.*
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再添加一个代码质量检查。Pants 允许我们使用 `mypy` 来检查 Python 中的静态类型。我们需要做的就是在*pants.toml*中添加
    mypy 后端：`pants.backend.python.typecheck.mypy`*。*
- en: 'You might also want to configure mypy to make its output more readable and
    informative by including the following config section:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还想配置 mypy 以使其输出更具可读性和信息量，可以包含以下配置部分：
- en: '[PRE18]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With this, we can run `pants check ::` to get:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以运行 `pants check ::` 来获取：
- en: '[PRE19]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Shipping ML models with Pants
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Pants 发布 ML 模型
- en: Let’s talk shipping. Most machine learning projects involve one or more Docker
    containers, for example, processing training data, training a model, or serving
    it via an API using Flask or FastAPI. In our toy project, we also have [a container
    for model training](https://github.com/MichalOleszak/pants-monorepo-example/blob/main/mnist/Dockerfile).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈发布。大多数机器学习项目涉及一个或多个 Docker 容器，例如处理训练数据、训练模型或通过 Flask 或 FastAPI 通过 API 提供服务。在我们的玩具项目中，我们还有一个
    [用于模型训练的容器](https://github.com/MichalOleszak/pants-monorepo-example/blob/main/mnist/Dockerfile)。
- en: Pants supports automatic building and pushing of Docker images. Let’s see how
    it works.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Pants 支持自动构建和推送 Docker 镜像。让我们看看它是如何工作的。
- en: 'First, we add the Docker backend in *pants.toml:* `pants.backend.docker`*.*
    We will also configure it, passing it a number of environment variables and a
    build arg which will come in handy in a moment:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在 *pants.toml* 中添加 Docker 后端：`pants.backend.docker`*.* 我们还将对其进行配置，传递一些环境变量和一个构建参数，这在稍后会派上用场：
- en: '[PRE20]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, in the `mnist/BUILD` file, we will add two more targets: a files target
    and a Docker image target.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `mnist/BUILD` 文件中，我们将添加两个目标：一个文件目标和一个 Docker 镜像目标。
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We call the Docker target `train_mnist`. As a dependency, we need to pass it
    the list of files to be included in the container. The most convenient way to
    do this is to define this list as a separate `files` target. Here, we simply include
    all the files in the mnist module in a target called `module_files`, and pass
    it as a dependency to the Docker image target.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 Docker 目标命名为 `train_mnist`。作为依赖项，我们需要传递要包含在容器中的文件列表。最方便的方式是将此列表定义为单独的 `files`
    目标。在这里，我们简单地将 mnist 模块中的所有文件包含在一个名为 `module_files` 的目标中，并将其作为依赖项传递给 Docker 镜像目标。
- en: Naturally, if you know that only some subset of files will be needed by the
    container, it’s a good idea to pass only those as dependencies. It is essential
    because these dependencies are used by Pants to infer whether a container has
    been affected by a change and needs a rebuild. Here, with `module_files` including
    all files, if any file in the mnist folder changes (even a readme!), Pants will
    see the `train_mnist`docker image as affected by this change.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，如果你知道容器只需要某些文件的子集，传递这些文件作为依赖项是个好主意。这一点很重要，因为这些依赖项被 Pants 用来推断容器是否受到了更改影响并需要重建。在这里，`module_files`
    包括所有文件，如果 mnist 文件夹中的任何文件发生更改（即使是 readme!），Pants 会将 `train_mnist` Docker 镜像视为受到了这一更改的影响。
- en: 'Finally, we can also set the external registry and repository to which the
    image shall be pushed, and the tags with which it will be pushed: here, I will
    be pushing the image to my personal Docker Hub repo, always with two tags: “latest”,
    and the short commit SHA which will be passed as a build arg.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还可以设置外部注册表和要推送镜像的仓库，以及推送时使用的标签：在这里，我将把镜像推送到我的个人 Docker Hub 仓库，总是带有两个标签：“latest”和短的提交
    SHA，后者将作为构建参数传递。
- en: 'With this, we can build an image. Just one more thing: since Pants is working
    in its isolated environments, it cannot read env vars from the host. Hence, to
    build or push the image that requires the SHORT_SHA variable, we need to pass
    it together with the Pants command.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以构建一个镜像。还有一件事：由于 Pants 在其隔离的环境中工作，它不能从主机读取环境变量。因此，要构建或推送需要 SHORT_SHA
    变量的镜像，我们需要将其与 Pants 命令一起传递。
- en: 'We can build the image like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样构建镜像：
- en: '[PRE22]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'to get:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 获取：
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A quick check reveals that the images have indeed been built:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 快速检查显示镜像确实已被构建：
- en: '[PRE24]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can also build and push images in one go using Pants. All it takes is replacing
    the `package` command with the `publish` command.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 Pants 一次性构建和推送镜像。只需将 `package` 命令替换为 `publish` 命令即可。
- en: '[PRE26]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This built the images and pushed them to my Docker Hub, [where they have indeed
    landed](https://hub.docker.com/repository/docker/michaloleszak/mnist/general).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这将构建镜像并将其推送到我的 Docker Hub，[它们确实已经到达了](https://hub.docker.com/repository/docker/michaloleszak/mnist/general)。
- en: Pants in CI/CD
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pants 在 CI/CD 中
- en: The same commands we have just manually run locally can be executed as parts
    of a CI/CD pipeline. You can run them via services such as GitHub Actions or Google
    CloudBuild, for instance as a PR check before a feature branch is allowed to be
    merged to the main branch, or after the merge, to validate it’s green and build
    & push artifacts.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚手动在本地运行的相同命令可以作为 CI/CD 流水线的一部分执行。例如，你可以通过 GitHub Actions 或 Google CloudBuild
    等服务来运行它们，比如在功能分支被允许合并到主分支之前作为 PR 检查，或者在合并之后验证其是否有效，并构建和推送工件。
- en: 'In our toy repo, I have implemented [a pre-push commit hook](https://github.com/MichalOleszak/pants-monorepo-example/blob/main/.pre-commit-config.yaml)
    that runs Pants commands on git push and only lets it through if they all pass.
    In it, we are running the following commands:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的玩具仓库中，我实现了[一个预推送提交钩子](https://github.com/MichalOleszak/pants-monorepo-example/blob/main/.pre-commit-config.yaml)，该钩子在git
    push时运行Pants命令，并且仅在所有命令通过时才允许推送。在其中，我们运行以下命令：
- en: '[PRE27]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can see some new flags for `pants check`, which is the typing check with
    mypy. They ensure that the check is only run on files that have changed compared
    to the main branch and their transitive dependencies. This is useful since mypy
    tends to take some time to run. Limiting its scope to what’s actually needed accelerates
    the process.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到一些用于`pants check`的新标志，这是使用mypy进行类型检查的功能。它们确保检查仅在与主分支相比发生了更改的文件及其传递依赖项上运行。这很有用，因为mypy的运行时间较长。将其范围限制在实际需要的部分可以加快处理速度。
- en: 'How would a docker build & push look like in a CI/CD pipeline? Somewhat like
    this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在CI/CD管道中，docker构建和推送会是什么样的？大致如下：
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We use the publish command as before, but with three additional arguments:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像以前一样使用publish命令，但增加了三个额外的参数：
- en: '`--changed-since=HEAD^` and `--changed-dependees=transitive` make sure that
    only the containers affected by the changes compared to the previous commit are
    built; this is useful for executing on the main branch after the merge.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--changed-since=HEAD^` 和 `--changed-dependees=transitive` 确保仅构建与先前提交相比受更改影响的容器；这对于在合并后的主分支上执行非常有用。'
- en: '`--filter-target-type=docker_image` makes sure that the only thing Pants does
    is build and push Docker images; this is because the `publish` command can refer
    to targets other than Docker: for example, it can be used to publish helm charts
    to OCI registries. The same goes for the `package` command: on top of building
    docker images, it can also create a Python package; for that reason, it’s a good
    practice to pass the `--filter-target-type` option.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--filter-target-type=docker_image` 确保Pants只做构建和推送Docker镜像的工作；这是因为`publish`命令可能会引用其他目标，例如，它可以用来将helm
    charts发布到OCI注册表。`package`命令也是如此：除了构建docker镜像，它还可以创建Python包；因此，传递`--filter-target-type`选项是一种良好的做法。'
- en: '![](../Images/23835533a1899635f3612622d3f49523.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/23835533a1899635f3612622d3f49523.png)'
- en: Conclusion
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: 'Monorepos are more often than not an excellent architecture choice for machine
    learning teams. Managing them at scale, however, requires an investment in a proper
    build system. One such system is Pants: it’s easy to set up and use, and t offers
    native support for many Python and Docker features that machine learning teams
    often use.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 单体仓库通常是机器学习团队的绝佳架构选择。然而，大规模管理它们需要对适当的构建系统进行投资。其中一个系统是Pants：它易于设置和使用，并且提供对机器学习团队经常使用的许多Python和Docker功能的本地支持。
- en: On top of that, it is an open-source project with a large and helpful community.
    I hope after reading this article you will go ahead and try it out. Even if you
    don’t currently have a monolithic repository, Pants can still streamline and facilitate
    many aspects of your daily work!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它是一个开源项目，拥有一个庞大且乐于助人的社区。我希望在阅读完这篇文章后，你能尝试一下。即使你目前没有一个单体仓库，Pants仍然可以简化和促进你日常工作的许多方面！
- en: '![](../Images/23835533a1899635f3612622d3f49523.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/23835533a1899635f3612622d3f49523.png)'
- en: References
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'Pants documentation: [https://www.pantsbuild.org/](https://www.pantsbuild.org/)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Pants文档: [https://www.pantsbuild.org/](https://www.pantsbuild.org/)'
- en: 'Pants vs. Bazel blog post: [https://blog.pantsbuild.org/pants-vs-bazel/](https://blog.pantsbuild.org/pants-vs-bazel/)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Pants与Bazel的博客文章: [https://blog.pantsbuild.org/pants-vs-bazel/](https://blog.pantsbuild.org/pants-vs-bazel/)'
- en: 'monorepo.tools: [https://monorepo.tools/](https://monorepo.tools/)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'monorepo.tools: [https://monorepo.tools/](https://monorepo.tools/)'
- en: '![](../Images/23835533a1899635f3612622d3f49523.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/23835533a1899635f3612622d3f49523.png)'
- en: Thanks for reading!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢阅读！
- en: If you liked this post, why don’t you [**subscribe for email updates**](https://michaloleszak.medium.com/subscribe)
    on my new articles? And by [**becoming a Medium member**](https://michaloleszak.medium.com/membership),
    you can support my writing and get unlimited access to all stories by other authors
    and yours truly.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢这篇文章，为什么不[**订阅电子邮件更新**](https://michaloleszak.medium.com/subscribe)我的新文章呢？通过[**成为Medium会员**](https://michaloleszak.medium.com/membership)，你可以支持我的写作，并获得对所有其他作者和我自己的故事的无限访问权。
- en: Want to always keep your finger on the pulse of the increasingly faster-developing
    field of machine learning and AI? Check out my new newsletter, [**AI Pulse**](https://pulseofai.substack.com/).
    Need consulting? You can ask me anything or book me for a 1:1 [**here**](https://topmate.io/michaloleszak).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 想时刻掌握机器学习和人工智能领域日新月异的动态吗？查看我的新通讯，[**AI Pulse**](https://pulseofai.substack.com/)。需要咨询吗？你可以问我任何问题或[**在这里**](https://topmate.io/michaloleszak)预约一对一咨询。
- en: 'You can also try one of [my other articles](https://michaloleszak.github.io/blog/).
    Can’t choose? Pick one of these:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以尝试[我的其他文章](https://michaloleszak.github.io/blog/)。无法选择？可以看看这些：
- en: '[](/unboxing-dinov2-metas-new-all-purpose-computer-vision-backbone-d8e22c059040?source=post_page-----8e0570de0c4c--------------------------------)
    [## Unboxing DINOv2, Meta’s new all-purpose computer vision backbone'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[](/unboxing-dinov2-metas-new-all-purpose-computer-vision-backbone-d8e22c059040?source=post_page-----8e0570de0c4c--------------------------------)
    [## 开箱 DINOv2，Meta 的新型通用计算机视觉骨干网'
- en: Are vision foundational models catching up with LLMs?
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 视觉基础模型是否正在赶上大型语言模型？
- en: towardsdatascience.com](/unboxing-dinov2-metas-new-all-purpose-computer-vision-backbone-d8e22c059040?source=post_page-----8e0570de0c4c--------------------------------)
    [](/self-supervised-learning-in-computer-vision-fd43719b1625?source=post_page-----8e0570de0c4c--------------------------------)
    [## Self-Supervised Learning in Computer Vision
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: towardsdatascience.com](/unboxing-dinov2-metas-new-all-purpose-computer-vision-backbone-d8e22c059040?source=post_page-----8e0570de0c4c--------------------------------)
    [](/self-supervised-learning-in-computer-vision-fd43719b1625?source=post_page-----8e0570de0c4c--------------------------------)
    [## 自监督学习在计算机视觉中的应用
- en: How to train models with only a few labeled examples
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何用仅有的几个标记样本来训练模型
- en: towardsdatascience.com](/self-supervised-learning-in-computer-vision-fd43719b1625?source=post_page-----8e0570de0c4c--------------------------------)
    [](/how-to-detect-data-drift-with-hypothesis-testing-1a3be3f8e625?source=post_page-----8e0570de0c4c--------------------------------)
    [## How to Detect Data Drift with Hypothesis Testing
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: towardsdatascience.com](/self-supervised-learning-in-computer-vision-fd43719b1625?source=post_page-----8e0570de0c4c--------------------------------)
    [](/how-to-detect-data-drift-with-hypothesis-testing-1a3be3f8e625?source=post_page-----8e0570de0c4c--------------------------------)
    [## 如何通过假设检验检测数据漂移
- en: 'Hint: forget about the p-values'
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示：忘记 p 值吧
- en: towardsdatascience.com](/how-to-detect-data-drift-with-hypothesis-testing-1a3be3f8e625?source=post_page-----8e0570de0c4c--------------------------------)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: towardsdatascience.com](/how-to-detect-data-drift-with-hypothesis-testing-1a3be3f8e625?source=post_page-----8e0570de0c4c--------------------------------)
