- en: '3D Python Workflows for LiDAR City Models: A Step-by-Step Guide'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 《LiDAR 城市模型的 3D Python 工作流程：一步步指南》
- en: 原文：[https://towardsdatascience.com/3d-python-workflows-for-lidar-point-clouds-100ff40e4ff0](https://towardsdatascience.com/3d-python-workflows-for-lidar-point-clouds-100ff40e4ff0)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/3d-python-workflows-for-lidar-point-clouds-100ff40e4ff0](https://towardsdatascience.com/3d-python-workflows-for-lidar-point-clouds-100ff40e4ff0)
- en: 3D Python
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3D Python
- en: '[](https://medium.com/@florentpoux?source=post_page-----100ff40e4ff0--------------------------------)[![Florent
    Poux, Ph.D.](../Images/74df1e559b2edefba71ffd0d1294a251.png)](https://medium.com/@florentpoux?source=post_page-----100ff40e4ff0--------------------------------)[](https://towardsdatascience.com/?source=post_page-----100ff40e4ff0--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----100ff40e4ff0--------------------------------)
    [Florent Poux, Ph.D.](https://medium.com/@florentpoux?source=post_page-----100ff40e4ff0--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@florentpoux?source=post_page-----100ff40e4ff0--------------------------------)[![Florent
    Poux, Ph.D.](../Images/74df1e559b2edefba71ffd0d1294a251.png)](https://medium.com/@florentpoux?source=post_page-----100ff40e4ff0--------------------------------)[](https://towardsdatascience.com/?source=post_page-----100ff40e4ff0--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----100ff40e4ff0--------------------------------)
    [Florent Poux, Ph.D.](https://medium.com/@florentpoux?source=post_page-----100ff40e4ff0--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----100ff40e4ff0--------------------------------)
    ·38 min read·Apr 4, 2023
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·发表于 [Towards Data Science](https://towardsdatascience.com/?source=post_page-----100ff40e4ff0--------------------------------)
    ·38 分钟阅读·2023年4月4日
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: The Ultimate Guide to unlocking a streamlined workflow for 3D City Modelling
    Applications. The tutorial covers Python Automation combining 3D Point Clouds,
    Meshes, and Voxels for advanced analysis.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 解锁 3D 城市建模应用的精简工作流程的终极指南。教程涵盖了结合 3D 点云、网格和体素的 Python 自动化，以进行高级分析。
- en: '![](../Images/97c090b15454c5c08f7efcab12fb9808.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/97c090b15454c5c08f7efcab12fb9808.png)'
- en: '3D Python Workflows for LiDAR City Models: A Step-by-Step Guide. This cover
    is from my other half [Marina](https://www.instagram.com/mimatelier_/), and highlights
    the art process of 3D City Modelling. © [Mimatelier](https://mimatelier.com/).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 《LiDAR 城市模型的 3D Python 工作流程：一步步指南》。封面来自我的另一半[Marina](https://www.instagram.com/mimatelier_/)，展示了
    3D 城市建模的艺术过程。© [Mimatelier](https://mimatelier.com/)。
- en: 'Did you stumble upon the term Smart City before? or Smart Something? Well,
    we touch on the subject! Think of a Smart City as a baker on steroids 🥐: it knows
    what you need before you even ask for it and will provide you with the most straightforward
    advice to make a delicious choice. No, this Smart City Metaphor is not all I have
    for you today. Indeed, to get to this level of “Smart”, we first have to get to
    the base layer: 3D City Models.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前遇到过“智能城市”这个词吗？或者“智能某物”？好吧，我们会涉及这个话题！将智能城市想象成一个超能的面包师 🥐：它知道你需要什么，甚至在你提出之前就会提供最直接的建议，帮助你做出美味的选择。不，这个智能城市的比喻并不是我今天唯一要分享的内容。确实，要达到这种“智能”的水平，我们首先得从基础层面入手：3D
    城市模型。
- en: If you ever wanted to create stunning 3D City Models but found the workflow
    daunting and complex, this is where I come in! This article explores how Python
    and open-source software can define a powerful 3D workflow to kickstart your 3D
    City Modelling journey. Say (almost) goodbye to tedious manual processes and hello
    to efficient, dynamic, and eye-catching creations!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经想要创建令人惊叹的 3D 城市模型，但发现工作流程令人生畏且复杂，那么我可以帮忙！本文探讨了如何利用 Python 和开源软件定义一个强大的
    3D 工作流程，以启动你的 3D 城市建模之旅。向繁琐的手动流程说（几乎）再见，迎接高效、动态且引人注目的创作吧！
- en: We dive into a four-step strategy that describes Environment setup, 3D Data
    Curation & Preparation, and 3D Geometry Processing to extract critical insights
    such as the built coverage of your neighborhood using point cloud data, meshes,
    voxels, and some grey matter 🧠.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们深入探讨了一个四步策略，描述了环境设置、3D 数据策划与准备以及 3D 几何处理，以提取关键洞察，例如使用点云数据、网格、体素以及一些灰质 🧠，了解你所在社区的建筑覆盖情况。
- en: '![](../Images/dd6cd4c7638e5fd0967612930ab5e1a1.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/dd6cd4c7638e5fd0967612930ab5e1a1.png)'
- en: '3D Python Workflows for LiDAR City Models: A Step-by-Step Guide. © Author'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 《LiDAR 城市模型的 3D Python 工作流程：一步步指南》。© 作者
- en: If you are ready and pumped, it is time to get 3D Coding!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经准备好并充满热情，现在是时候开始 3D 编程了！
- en: '🎵**Note to Readers***: This hands-on guide is part of a* [***UTWENTE***](https://www.itc.nl/)
    *joint work with my dear colleagues* [***Dr. Sander Oude Elberink***](https://people.utwente.nl/s.j.oudeelberink)*,*
    [***Dr. Mila Koeva***](https://people.utwente.nl/m.n.koeva)*,* [***Dr. Ville Lehtola***](https://people.utwente.nl/v.v.lehtola)*,*
    [***Dr. Pirouz Nourian***](https://people.utwente.nl/p.nourian)*,* [***Dr. Paulo
    Raposo***](https://people.utwente.nl/p.raposo)*. and* [***Prof G. Vosselman***](https://research.utwente.nl/en/persons/george-vosselman)*.
    We acknowledge the financial contribution from the digital twins* [*@ITC*](http://twitter.com/ITC)
    *-project granted by the ITC faculty of the University of Twente.*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 🎵**致读者的说明**：这本实践指南是* [***UTWENTE***](https://www.itc.nl/) *与我亲爱的同事们* [***Dr.
    Sander Oude Elberink***](https://people.utwente.nl/s.j.oudeelberink)*,* [***Dr.
    Mila Koeva***](https://people.utwente.nl/m.n.koeva)*,* [***Dr. Ville Lehtola***](https://people.utwente.nl/v.v.lehtola)*,*
    [***Dr. Pirouz Nourian***](https://people.utwente.nl/p.nourian)*,* [***Dr. Paulo
    Raposo***](https://people.utwente.nl/p.raposo)*. 和* [***Prof G. Vosselman***](https://research.utwente.nl/en/persons/george-vosselman)*
    的共同工作之一。我们感谢来自数字双胞胎* [*@ITC*](http://twitter.com/ITC) *项目的资金支持，该项目由特温特大学ITC学院授予。*
- en: '![](../Images/a969888432c000fbe6ebde8acd430ae3.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a969888432c000fbe6ebde8acd430ae3.png)'
- en: An extract of the 3D Python dataset we will handle in this guide. © Author
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本指南中处理的3D Python数据集的摘录。© 作者
- en: Introduction
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: 'Before rushing onto the fun bits, let me tell you a small story to give a bit
    of depth to what we will achieve. This starts with a fundamental question: What
    is 3D City Modeling, and why is it helpful?'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入有趣的部分之前，让我讲一个小故事，为我们将要实现的目标提供一些背景。这始于一个基本的问题：什么是3D城市建模，它为何有用？
- en: 'In an urbanized world, 3D city modeling is essential for efficiently managing
    our daily lives. By accurately representing our cities in three dimensions, we
    can analyze and visualize complex urban environments, understand the impact of
    proposed changes, and make informed decisions to improve the quality of life for
    residents. This is a fundamental notion that is well captured by the beautifully
    phrased sentence: Cities shape life¹.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个城市化的世界里，3D城市建模对于高效管理我们的日常生活至关重要。通过准确地以三维方式呈现我们的城市，我们可以分析和可视化复杂的城市环境，理解提议更改的影响，并做出明智的决策，以改善居民的生活质量。这是一个基本的概念，由那句优美的话很好地表达：城市塑造生活¹。
- en: '![](../Images/8cfddea6a8bbd75cb37a16e5edb3493c.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8cfddea6a8bbd75cb37a16e5edb3493c.png)'
- en: Toward Smart Cities to improve our lives. © Author
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 朝向智能城市以改善我们的生活。© 作者
- en: Indeed, Cities are places where people live, form communities, and establish
    their own identities. They are spaces, such as the inner city and the suburb,
    that offer a way to configure and shape the material world and natural environment.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，城市是人们生活、形成社区并建立自己身份的地方。它们是如市中心和郊区这样的空间，提供了一种配置和塑造物质世界和自然环境的方式。
- en: Imagine if you had a superpowered ability to model transportation networks in
    your city, predict traffic patterns and identify areas of congestion. How would
    it change the way you live your city? And that is a super tiny example taken as
    a city “user”. But at the root, 3D city modeling provides valuable insights for
    urban planners, architects, and policymakers to optimize city infrastructure,
    reduce traffic, and enhance public safety.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果你有一种超级能力，可以对你的城市交通网络进行建模，预测交通模式并识别拥堵区域。这将如何改变你在城市中的生活方式？这只是作为城市“用户”的一个微小例子。但从根本上讲，3D城市建模为城市规划师、建筑师和政策制定者提供了宝贵的见解，以优化城市基础设施、减少交通拥堵并提高公共安全。
- en: By creating a digital replica of our cities, we can thus better plan for the
    future and create sustainable, livable communities for generations to come.²⁻³
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建我们城市的数字化复制品，我们可以更好地规划未来，为子孙后代创造可持续、宜居的社区。²⁻³
- en: '¹ Chen, X., Orum, A. M., & Paulsen, K. E. (2018). *Introduction to Cities:
    How place and space shape human experience*. John Wiley & Sons.'
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ Chen, X., Orum, A. M., & Paulsen, K. E. (2018). *《城市导论：地方和空间如何塑造人类体验》*。约翰·威利父子公司。
- en: ''
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '² Lehtola, V. V., Koeva, M., Elberink, S. O., Raposo, P., Virtanen, J. P.,
    Vahdatikhaki, F., & Borsci, S. (2022). *Digital twin of a city: Review of technology
    serving city needs.* International Journal of Applied Earth Observation and Geoinformation,
    102915.'
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ² Lehtola, V. V., Koeva, M., Elberink, S. O., Raposo, P., Virtanen, J. P., Vahdatikhaki,
    F., & Borsci, S. (2022). *《城市数字双胞胎：服务城市需求的技术综述》*。《国际应用地球观察与地理信息杂志》，102915。
- en: ''
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '³ Nourian, P., Ohori, K. A., & Martinez-Ortiz, C. (2018). Essential means for
    urban computing: Specification of web-based computing platforms for urban planning,
    a Hitchhiker’s guide. Urban Planning, 3(1), 47–57'
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³ Nourian, P., Ohori, K. A., & Martinez-Ortiz, C. (2018). 城市计算的基本手段：基于网络的城市规划计算平台的规范，旅行者指南。城市规划，3(1)，47–57
- en: '3D City Modelling: The Workflow'
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3D城市建模：工作流程
- en: Time to get half-serious and define a coherent 3D Workflow that we could use
    as an inspiration for different 3D City Modeling Operations. We aim at something
    that is (1) Easy to set up and run, (2) Provides great flexibility to various
    scenarios, and (3) powerful enough to encompass the complexity of multi-modal
    applications.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候认真起来，定义一个一致的3D工作流程，我们可以将其作为不同3D城市建模操作的灵感。我们的目标是（1）易于设置和运行，（2）为各种场景提供极大的灵活性，以及（3）足够强大以涵盖多模态应用的复杂性。
- en: '🦚 **Note**: *No, multi-modal is not a swearword: it just touches on the point
    that when dealing with 3D City Models, we encounter various geospatial data modalities
    to be considered. In this tutorial, we will focus on a beautiful niche: 3D Geospatial
    Data in the form of* ***Point Clouds****,* ***Voxels****, and* ***3D Meshes****.*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 🦚 **注意**：*不，多模态不是脏话：它只是触及到当处理3D城市模型时，我们遇到各种需要考虑的地理空间数据模态。在本教程中，我们将专注于一个美丽的细分领域：*
    ***点云****，* ***体素****，以及* ***3D网格****。
- en: If we decompose the workflow definition on a high-level view, we follow four
    main steps, as shown below.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从高层次定义工作流程，我们会遵循四个主要步骤，如下所示。
- en: '![](../Images/35a2f7dccc19d471620463aa5284aeb7.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/35a2f7dccc19d471620463aa5284aeb7.png)'
- en: The 3D Python LiDAR Workflow in the context of City Models. We start with the
    Environment Set up (Step 1) and 3D Data Preparation (Step 2). Once this is done,
    we move on to Python Automation (Step 3), with a specific part dealing with 3D
    Python Challenges (Step 4), such as Parcel Surface or Point Of Interest Queries.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在城市模型背景下的3D Python LiDAR工作流程。我们从环境设置（步骤1）和3D数据准备（步骤2）开始。一旦完成这些步骤，我们进入Python自动化（步骤3），其中一个特定部分处理3D
    Python挑战（步骤4），例如地块表面或兴趣点查询。
- en: Excited? Looking closely at the pipeline, you can see that we start from scratch.
    This permits the adaptation of the proposed structure to various scenarios, which
    would necessitate various environments, datasets, or automation bits.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 激动了吗？仔细查看流程，你会发现我们从零开始。这允许将提出的结构适应各种场景，这些场景需要不同的环境、数据集或自动化工具。
- en: 'Let us now go a bit deeper. Let us imagine we own a house in the Netherlands
    (It can be close to the University of Twente), and we would like to understand
    the surrounding area better. That is our starting point. Now, to better grasp
    the relationship of our house to the surrounding, some questions arise: how dense
    is the built area of the neighborhood? Can the house be subject to flooding? Am
    I respecting the built ratio for the parcel I own?'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更深入一点。假设我们在荷兰拥有一所房子（可以靠近特文特大学），我们想更好地了解周围的区域。这是我们的起点。现在，为了更好地理解我们房子与周围环境的关系，出现了一些问题：邻里建筑区的密度有多高？房子是否可能面临洪水？我是否遵守了我所拥有地块的建筑比例？
- en: How should we go around and answer these questions? Should we look on the internet?
    Should we open a map? Should we call the cadastral services? Let's work around
    that together and simultaneously unlock a new robust set of skills in this context.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该如何解决这些问题？我们是否应该上网查找？是否应该打开地图？是否应该联系测绘服务？让我们一起探索这个过程，同时在这个背景下解锁一套新的强大技能。
- en: 'In the following, we detail the four steps that allow answering these questions:
    the first step covers the ideal environment setup. Secondly, we get our hands
    on 3D point clouds and city models as meshes of an area of interest. Then, we
    create a 3D Python notebook with a high focus on automation. Finally, we create
    a set of Python functions to answer the challenging scenarios. Okay, let us arm
    ourselves with coffee or tea 🍵 and dive into finding answers to these interrogations!'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的内容中，我们详细介绍了回答这些问题的四个步骤：第一步是理想的环境设置。其次，我们获取3D点云和作为感兴趣区域网格的城市模型。然后，我们创建一个高度关注自动化的3D
    Python笔记本。最后，我们创建一套Python函数以应对具有挑战性的场景。好了，让我们拿起咖啡或茶🍵，深入寻找这些问题的答案吧！
- en: '🦚 **Note**: *I designed the next series of actions to be easy to follow linearly
    without needing coding skills or available data. Nevertheless, if you are an experienced
    coder, I provided helpful optimization tricks on crucial tasks to ensure code
    performance is at its peak!*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 🦚 **注意**：*我设计了下一系列操作，使其易于线性跟随，无需编码技能或可用数据。然而，如果你是经验丰富的编码人员，我提供了有用的优化技巧，以确保代码性能达到巅峰！*
- en: 'Step 1: 3D Environment Set-up'
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一步：3D 环境设置
- en: Before making our hands dirty with code and 3D thoughts, a good practice is
    to ensure we work in a proper environment. We do not cook on a dirty countertop
    with dull knives and outdated food (or at least we avoid 😁)! Let us follow the
    three sub-steps as illustrated below.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始动手编写代码和进行 3D 思考之前，一个好的做法是确保我们在适当的环境中工作。我们不会在肮脏的台面上用钝刀和过期的食材做饭（或者至少我们会避免 😁）！让我们遵循下面所示的三个子步骤。
- en: '![](../Images/d2e39d1775e3819afe4a4b05635da305.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d2e39d1775e3819afe4a4b05635da305.png)'
- en: 'Step 1: 3D Environment Set-up.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步：3D 环境设置。
- en: 1\. 1\. The software stack
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1\. 1\. 软件堆栈
- en: 'To get things going, let us first install a 3D point cloud and mesh processing
    software: CloudCompare. It is a marvelous tool that permits to efficiently handle
    the scientific analysis of point cloud data (but not only). It is an essential
    cog in any iterative experiment where you want to quickly get a data-driven idea
    about the feasibility of a theory, for example.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，让我们首先安装一个 3D 点云和网格处理软件：CloudCompare。它是一个出色的工具，允许有效地处理点云数据的科学分析（但不限于此）。它是任何迭代实验中的一个重要部分，例如，当你想快速获得关于理论可行性的数据驱动想法时。
- en: To get the CloudCompare software, you can go to the download section of [CloudCompare.org](https://cloudcompare.org/)
    and get the latest stable release for your OS, as illustrated below.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取 CloudCompare 软件，你可以前往 [CloudCompare.org](https://cloudcompare.org/) 的下载部分，获取适合你操作系统的最新稳定版，如下所示。
- en: '![](../Images/22b4cf7d7ef80b3b341e8aaeebaee4aa.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/22b4cf7d7ef80b3b341e8aaeebaee4aa.png)'
- en: Downloading CloudCompare from [https://cloudcompare.org/](https://cloudcompare.org/)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [https://cloudcompare.org/](https://cloudcompare.org/) 下载 CloudCompare
- en: 'After downloading the software, follow the linear installation steps to get
    to a working software that you can open, which should look similar to the following
    GUI upon launch:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下载软件后，按照线性安装步骤操作，直到获得可以打开的工作软件，启动时界面应类似于以下 GUI：
- en: '![](../Images/78d2d6aca43e0ca4a55ee2ca7be1797e.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/78d2d6aca43e0ca4a55ee2ca7be1797e.png)'
- en: CloudCompare GUI.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: CloudCompare GUI。
- en: Then, we want to get a Python Distribution that allows us to focus on the actual
    code. It is called Anaconda, and it is available on various platforms from [Anaconda.com](https://www.anaconda.com/).
    Once you download the software that matches your OS, you can install it. A GUI
    is provided (Anaconda Navigator) that you can launch to get up and running quickly,
    as shown below..
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们希望获得一个允许我们专注于实际代码的 Python 发行版。它被称为 Anaconda，可以在各种平台上从 [Anaconda.com](https://www.anaconda.com/)
    获得。下载与您的操作系统匹配的软件后，您可以进行安装。提供了一个 GUI（Anaconda Navigator），您可以启动它以快速开始，如下所示。
- en: '![](../Images/0de35f78f0fcbacebf630f4eb0510aea.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0de35f78f0fcbacebf630f4eb0510aea.png)'
- en: This is the Anaconda Navigator GUI that allows you to manage independent Python
    Environments for your future experiments.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Anaconda Navigator GUI，允许你管理未来实验的独立 Python 环境。
- en: Using the GUI Anaconda Navigator, go to the “`Environments`” Tab on the left.
    We then create a brand new isolated Python environment by clicking on “`Create`”
    as shown below.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GUI Anaconda Navigator，转到左侧的“`环境`”标签。然后，我们通过点击“`创建`”来创建一个全新的隔离 Python 环境，如下所示。
- en: '![](../Images/af87f918dfe6a994ed3653fc37485d0d.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/af87f918dfe6a994ed3653fc37485d0d.png)'
- en: In Anaconda Navigator, you have four tabs on the left side. In the Home Tab,
    you will find the IDE at your disposal in a specific environment; in the “Environments”
    tab, you can create, manage, and select any environment.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Anaconda Navigator 中，你的左侧有四个标签。在“首页”标签中，你会发现 IDE 处于特定环境中；在“环境”标签中，你可以创建、管理和选择任何环境。
- en: This will allow us to manage better some Python “libraries” we want to install
    (Step 1.3) while avoiding version conflicts.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们能够更好地管理一些我们想要安装的 Python “库”（第 1.3 步），同时避免版本冲突。
- en: '🦚 **Note**: *For this tutorial, we chose a Python version of 3.9.16, as shown
    above. Once you created an environment and after clicking on it, you can see a
    “play” icon next to its name. This opens the possibility of launching an* ***Anaconda
    Terminal*** *directly acting in the selected environment.* ***This is the go-to
    way to install libraries or IDEs in this environment****.*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 🦚 **注意**：*对于本教程，我们选择了 Python 版本 3.9.16，如上所示。创建环境后，点击它，你会看到其名称旁边有一个“播放”图标。这将开启直接在所选环境中启动*
    ***Anaconda Terminal*** *的可能性。***这是在此环境中安装库或 IDE 的首选方式****。*
- en: If you have a working Anaconda Navigator and a new environment created, we are
    ready to choose a way to code, intending to be more efficient than a text editor.
    😁
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经有一个工作中的 Anaconda Navigator 和一个新创建的环境，我们就可以选择一种编码方式，旨在比文本编辑器更高效。😁
- en: 1.2\. The Python IDE
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2\. Python IDE
- en: A Python IDE (Integrated Development Environment) is a software application
    that provides a comprehensive set of tools for developing, testing, and debugging
    Python code. They offer an all-in-one environment where we can write, edit, and
    execute code, manage project files, track changes, and collaborate with other
    developers. Some popular Desktop Python IDEs include PyCharm, Visual Studio Code,
    and Spyder, each offering unique features and capabilities to suit different programming
    needs.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Python IDE（集成开发环境）是一种软件应用程序，提供了一整套用于开发、测试和调试 Python 代码的工具。它们提供了一个一体化的环境，我们可以在其中编写、编辑和执行代码，管理项目文件，跟踪更改，并与其他开发人员协作。一些流行的桌面
    Python IDE 包括 PyCharm、Visual Studio Code 和 Spyder，每个 IDE 都提供了适应不同编程需求的独特功能和能力。
- en: 'Today, I want to highlight a great “web-based” IDE: JupyterLab. One of the
    main benefits of JupyterLab is its notebook interface, which provides a visual,
    interactive environment for working with code. It makes it easy to create, edit,
    and run code cells in real time without switching between different windows or
    applications. Additionally, JupyterLab supports a wide range of data visualization
    tools, making it an excellent choice for working with any geodata science or 3D
    machine learning project.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我想重点介绍一个出色的“基于网络”的 IDE：JupyterLab。JupyterLab 的主要优点之一是其笔记本界面，它提供了一个可视化的、互动的编程环境。它使得实时创建、编辑和运行代码单元变得简单，而无需在不同窗口或应用程序之间切换。此外，JupyterLab
    支持广泛的数据可视化工具，是处理任何地理数据科学或 3D 机器学习项目的绝佳选择。
- en: '![](../Images/11bbac3dd2b3dbf60e7b3f3a15fd2f2f.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11bbac3dd2b3dbf60e7b3f3a15fd2f2f.png)'
- en: JupyterLab IDE for 3D Python.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: JupyterLab IDE 用于 3D Python。
- en: JupyterLab’s intuitive interface, robust feature set, and support for multiple
    programming languages make it a popular choice for Python developers of all skill
    levels.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: JupyterLab 直观的界面、强大的功能集以及对多种编程语言的支持，使其成为各个技能水平的 Python 开发人员的热门选择。
- en: '🦚 **Note**: *JupyterLab IDE also offers support for multiple programming languages,
    including Python, R, and Julia, allowing one to work with various tools and libraries
    within a single environment. And this is massively cool, as R and Julia are lovely
    languages.*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 🦚 **注意**：*JupyterLab IDE 还支持多种编程语言，包括 Python、R 和 Julia，允许在一个环境中使用各种工具和库。这非常酷，因为
    R 和 Julia 是很棒的语言。*
- en: Before being able to use JupyterLab, we need to install it in our current Anaconda
    Environment. As mentioned before, we have to open the Anaconda Terminal in the
    environment of choice (ITC in our case). To achieve this with Anaconda Navigator,
    from your selected environment, (1) click on the green arrow, (2) select *“*`Open
    Terminal`*”* as shown below*.*
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在能够使用 JupyterLab 之前，我们需要在当前 Anaconda 环境中安装它。如前所述，我们必须在所选环境中打开 Anaconda Terminal（在我们的例子中是
    ITC）。要通过 Anaconda Navigator 实现这一点，从你选择的环境中，（1）点击绿色箭头，（2）选择 *“*`Open Terminal`*”*，如下所示。*
- en: '![](../Images/3ab8549967e0a486f8d32c8a1b6afef4.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3ab8549967e0a486f8d32c8a1b6afef4.png)'
- en: How to install dependencies on the current environment.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在当前环境中安装依赖。
- en: 'In the console (Anaconda Terminal) that opens, write the following line: `conda
    install -c conda-forge jupyterlab`, and press “`Enter`”. This will install JupyterLab
    directly.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开的控制台（Anaconda Terminal）中，输入以下命令：`conda install -c conda-forge jupyterlab`，然后按“`Enter`”。这将直接安装
    JupyterLab。
- en: '![](../Images/302aec290a29f80cbf63ec1609280c43.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/302aec290a29f80cbf63ec1609280c43.png)'
- en: The command line is executed in the Anaconda Terminal (we see that we are in
    the (ITC) environment).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行在 Anaconda Terminal 中执行（我们看到我们在（ITC）环境中）。
- en: Note that it may ask for your approval to install some needed library, which
    you need to accept by typing `y` followed by pressing the key “`Enter`”.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，它可能会要求你确认安装一些需要的库，你需要通过输入`y`并按下“`Enter`”键来接受。
- en: '![](../Images/aecfb0e6f732cc0b0b1d8d0c1c85d1b9.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/aecfb0e6f732cc0b0b1d8d0c1c85d1b9.png)'
- en: After 30+ seconds, the installation needs our approval. type ‘`y`’ and press
    `Enter`. This will download, extract and install the libraries mentioned above.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 经过30多秒后，安装需要我们的确认。输入‘`y`’并按`Enter`键。这将下载、解压并安装上述提到的库。
- en: Once the process is done, you have a JupyterLab IDE installed in your ITC Conda
    environment. Do not close the console; from there, we will test that everything
    works smoothly in four simple steps.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦过程完成，你就有一个安装在ITC Conda环境中的JupyterLab IDE。不要关闭控制台；从那里，我们将通过四个简单的步骤测试一切是否顺利。
- en: '**Launch JupyterLab**: From the same console, you can launch JupyterLab by
    writing the command: “`jupyter lab`”. This will automatically open the JupyterLab
    interface in your default web browser.'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**启动JupyterLab**：在相同的控制台中，你可以通过输入命令：“`jupyter lab`”来启动JupyterLab。这将自动在默认网页浏览器中打开JupyterLab界面。'
- en: '**Create a new notebook**: To create a new notebook (where we want to write
    code), click on the “`File`” menu in the top-left corner of the JupyterLab interface
    and select “`New Notebook`.” This will open a new notebook in a new tab.'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建一个新的笔记本**：要创建一个新的笔记本（我们在其中编写代码），请点击JupyterLab界面左上角的“`文件`”菜单，并选择“`新建笔记本`”。这将会在新标签页中打开一个新的笔记本。'
- en: '**Write code**: You can now start writing code in the notebook. To create a
    new code cell, click the “`+`” button in the toolbar or press “`Ctrl + Shift +
    Enter`.” You can then write your Python code (E.g. : `‘This is working’` in the
    cell and run it by pressing “`Shift + Enter`.”'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编写代码**：现在你可以在笔记本中开始编写代码。要创建一个新的代码单元格，请点击工具栏中的“`+`”按钮或按“`Ctrl + Shift + Enter`”。然后你可以在单元格中编写Python代码（例如：`‘This
    is working’`），并通过按“`Shift + Enter`”运行它。'
- en: '**Save your work**: Remember to save your work regularly by clicking the “`Save`”
    button in the toolbar or using the “`Ctrl + S`” keyboard shortcut.'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**保存你的工作**：记得定期保存你的工作，通过点击工具栏中的“`保存`”按钮或使用“`Ctrl + S`”键盘快捷键来保存。'
- en: These are the basic steps to get started with JupyterLab. As you become more
    familiar with the interface, you can explore more advanced features, such as adding
    markdown text, importing and exporting data, and working with JupyterLab extensions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是开始使用JupyterLab的基本步骤。随着你对界面的熟悉，你可以探索更多高级功能，如添加Markdown文本、导入和导出数据以及使用JupyterLab扩展。
- en: '🦚 **Note**: *For students at ITC — University of Twente, we have the luck to
    have the* [***CRIB: A Geospatial Computing Platform***](https://crib.utwente.nl/)
    *using Jupyter Lab. I highly recommend using this cloud computing service if your
    computer shows some processing limitations while following this course.*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '🦚 **注意**：*对于ITC—特温特大学的学生，我们很幸运能使用* [***CRIB: A Geospatial Computing Platform***](https://crib.utwente.nl/)
    *进行Jupyter Lab。 如果你的计算机在跟随本课程时显示出某些处理限制，我强烈推荐使用这个云计算服务。*'
- en: 1.3\. 3D Python Libraries
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3\. 3D Python库
- en: For this tutorial, I will introduce five libraries that are key to 3D Geospatial
    Analysis. These are `NumPy`, `Pandas`, `Open3D`, `Matplotlib,` and `Shapely`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我将介绍五个对3D地理空间分析至关重要的库。这些库是`NumPy`、`Pandas`、`Open3D`、`Matplotlib`和`Shapely`。
- en: '🦚 **Note**: i*f you want to use the mentioned libraries, we must ensure they
    are installed and available in your environment. Therefore, in the same environment
    terminal, we use the formula* “`pip install package-name==version`” *(the* `==version`
    *is optional to fix certain versions) as follows:*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 🦚 **注意**：*如果你想使用上述库，我们必须确保它们在你的环境中已安装并可用。因此，在相同的环境终端中，我们使用公式* “`pip install
    package-name==version`” *(其中`==version`是可选的，用于固定某些版本)，如下面所示：*
- en: '![](../Images/9265d7a29ec28a42dda3e94ef33194e0.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9265d7a29ec28a42dda3e94ef33194e0.png)'
- en: '[PRE0]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**NumPy**: This library is used for working with arrays and matrices. It provides
    fast and efficient operations on large, multi-dimensional arrays, making it a
    powerful tool for scientific computing and data analysis. One hands-on example
    of how to use `NumPy` is to create a point cloud as a set of data points in the
    3D euclidean space. To do this, you can create a NumPy array with three columns,
    where each row represents a single point in the point cloud:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**NumPy**：这个库用于处理数组和矩阵。它提供了对大型多维数组的快速高效操作，使其成为科学计算和数据分析的强大工具。一个使用`NumPy`的实际示例是创建一个点云，将其作为3D欧几里得空间中的数据点集合。为此，你可以创建一个具有三列的NumPy数组，每一行表示点云中的一个点：'
- en: '[PRE1]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, the point cloud has three points with coordinates `(1, 2, 3),
    (4, 5, 6)`, and `(7, 8, 9)`, respectively. Easy, Peasy, you said? 😁
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，点云包含三个坐标为`(1, 2, 3)`、`(4, 5, 6)`和`(7, 8, 9)`的点。简单吧，你说？😁
- en: '**Pandas**: This library is more geared towards data manipulation and analysis.
    It provides robust data structures and tools for working with structured data,
    such as CSV files, spreadsheets, and databases. While it’s not specifically designed
    for 3D data processing, it can still be used to write and access point clouds
    in a tabular format. To do this, you can create a DataFrame object with columns
    representing the X, Y, and Z coordinates of each point:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**Pandas**：这个库更侧重于数据操作和分析。它提供了强大的数据结构和工具，用于处理结构化数据，例如 CSV 文件、电子表格和数据库。虽然它并不是专门为
    3D 数据处理设计的，但仍可以用来以表格格式读写点云。为此，你可以创建一个 DataFrame 对象，其中列表示每个点的 X、Y 和 Z 坐标：'
- en: '[PRE2]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, the point cloud has three points with coordinates `(1, 2, 3)`,
    `(4, 5, 6)`, and `(7, 8, 9)`, as obtained with NumPy. The DataFrame is then saved
    to a CSV file using the `to_csv` function.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，点云包含三个坐标为`(1, 2, 3)`、`(4, 5, 6)`和`(7, 8, 9)`的点，如使用 NumPy 获得的。然后，DataFrame
    使用 `to_csv` 函数保存到 CSV 文件中。
- en: '🦚 **Note**: *Pandas can be extended with another Python module:* [***Geopandas***](https://geopandas.org/)*.
    This library makes it possible to directly work with spatial data stored e.g.
    in Shapefiles or PostGIS database. This extends the scope of the current tutorial,
    but it is good to know because we will surely use it in other cases.* 😉'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 🦚 **注意**：*Pandas 可以通过另一个 Python 模块进行扩展：* [***Geopandas***](https://geopandas.org/)*。这个库使得可以直接处理存储在例如
    Shapefiles 或 PostGIS 数据库中的空间数据。这扩展了当前教程的范围，但了解这些内容是有益的，因为我们在其他情况下肯定会用到它。* 😉
- en: '**Open3D**: This library is geared toward 3D data processing and visualization.
    It provides various tools and functions for working with point clouds, meshes,
    and other 3D data formats, such as voxels.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**Open3D**：这个库专注于 3D 数据处理和可视化。它提供了各种工具和函数，用于处理点云、网格和其他 3D 数据格式，如体素。'
- en: '🦚 **Note**: *A quick way to install the library is to run the Anaconda Environment
    Terminal the same way as before and type the following command:* `pip install
    open3d==0.16.0`, *which will install the version 0.16.0 of* [*Open3D*](http://www.open3d.org/)*,
    as used in this tutorial.*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 🦚 **注意**：*快速安装该库的方法是运行 Anaconda 环境终端并输入以下命令：* `pip install open3d==0.16.0` *，这将安装版本
    0.16.0 的* [*Open3D*](http://www.open3d.org/)*，如本教程中使用的版本。*
- en: 'Now, back in the Jupyter Lab IDE, let us create a point cloud using built-in
    Open3D functions:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 Jupyter Lab IDE 中，让我们使用内置的 Open3D 函数创建一个点云：
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, the point cloud has the same three points with coordinates
    `(1, 2, 3)`, `(4, 5, 6)`, and `(7, 8, 9)`, respectively.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，点云包含三个具有坐标`(1, 2, 3)`、`(4, 5, 6)`和`(7, 8, 9)`的点。
- en: '🦚 **Note**: *In the code block above, we created an Open3D PointCloud object
    and then* passed *the points list to the points attribute through the* `o3d.utility.Vector3dVector`
    *function that converts the list of points into a format that can be added to
    the point cloud object.*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 🦚 **注意**：*在上面的代码块中，我们创建了一个 Open3D PointCloud 对象，然后通过* `o3d.utility.Vector3dVector`
    *函数将点列表传递给 points 属性，该函数将点列表转换为可以添加到点云对象中的格式。*
- en: '**Matplotlib**: This library is used for data visualization. It provides many
    tools for creating high-quality charts, graphs, and other visualizations. While
    it’s not specifically designed for 3D data visualization, it can still create
    3D scatter plots of point clouds. To do this, you can use the Axes3D class to
    create a 3D plot and the scatter function to plot the points:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**Matplotlib**：这个库用于数据可视化。它提供了许多工具，用于创建高质量的图表、图形和其他可视化内容。虽然它并不是专门为 3D 数据可视化设计的，但它仍然可以创建点云的
    3D 散点图。为此，你可以使用 Axes3D 类创建 3D 图，并使用 scatter 函数绘制点：'
- en: '[PRE4]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, a point cloud with 1000 random points is generated using NumPy.
    The points are then plotted as a scatter plot in a 3D plot using the `scatter`
    function. Finally, the plot is displayed using the `show` function.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，使用 NumPy 生成了一个包含 1000 个随机点的点云。然后，使用 `scatter` 函数在 3D 图中绘制这些点。最后，使用 `show`
    函数显示图形。
- en: '**Shapely**: This library is used mainly for 2D geometric operations to create,
    manipulate, and analyze geometric objects. It provides a wide range of tools for
    working with points, lines, polygons, and other geometric shapes. One common use
    case for `Shapely` is creating a polygon and checking if a point is within the
    polygon. To do this, you can create a Polygon object using a list of coordinates
    that define the polygon and then use the `contains` function to check if a point
    is within the polygon:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**Shapely**：这个库主要用于2D几何操作，用于创建、操作和分析几何对象。它提供了广泛的工具来处理点、线、多边形和其他几何形状。`Shapely`的一个常见用例是创建一个多边形，并检查一个点是否在多边形内。为此，你可以使用定义多边形的坐标列表创建一个Polygon对象，然后使用`contains`函数检查点是否在多边形内：'
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is just a simple example, but Shapely provides many other functions for
    working with geometric objects that can be useful for more complex applications.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简单的例子，但Shapely提供了许多其他用于处理几何对象的函数，这些函数对于更复杂的应用可能会很有用。
- en: '🦚 **Note**: *In this example, a polygon with four vertices is created using
    a list of coordinates. A point is then created using the* `Point` *function. Finally,
    the* `contains` *function is used to check if the point is within the polygon,
    and a message is printed to the console depending on the result of the check.*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 🦚 **注意**：*在这个例子中，使用一个坐标列表创建了一个具有四个顶点的多边形。然后，使用* `Point` *函数创建一个点。最后，使用* `contains`
    *函数检查点是否在多边形内，并根据检查结果将消息打印到控制台。*
- en: Our first step in this 3D Workflow for 3D City Modeling is a clever combination
    of simple yet effective and proven tools and libraries, visually summarized below.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个3D城市建模的工作流程中，我们的第一步是巧妙地结合简单而有效且经过验证的工具和库，下面做了视觉总结。
- en: '![](../Images/36edff1699f49afb2c4cc4a1515dcaeb.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/36edff1699f49afb2c4cc4a1515dcaeb.png)'
- en: The summary of the environment set-up. © Author
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 环境设置的总结。© 作者
- en: Now that we have an explicit software stack, a functional python IDE and a basic
    understanding of python libraries, we can start preparing our data.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了明确的软件栈、功能齐全的Python IDE和对Python库的基本理解，我们可以开始准备数据。
- en: Step 2\. 3D Data Preparation
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2步：3D数据准备
- en: 'We now move on to the second step: 3D Data Preparation.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在进入第二步：3D数据准备。
- en: '![](../Images/eef72b8db48508cfa76b3ed2f1ecd575.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/eef72b8db48508cfa76b3ed2f1ecd575.png)'
- en: 3D Data Preparation. We will download 3D dataset, then develop some easy 3D
    visualization to work by subsampling and exporting the data in a ready-to-use
    Python-friendly format.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 3D数据准备。我们将下载3D数据集，然后开发一些简单的3D可视化，通过下采样和导出数据为适合Python使用的格式来进行处理。
- en: Our goal is to gather and prepare the datasets to be usable for our analysis
    with Python in mind. Therefore, this step also acts as a “3D Data Visualization”
    phase, where we will qualitatively assess what we are dealing with. If you are
    ready, let us get started.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是收集和准备数据集，以便我们用Python进行分析。因此，这一步也充当了“3D数据可视化”阶段，我们将定性评估我们所处理的数据。如果你准备好了，就开始吧。
- en: 2.1\. Downloading 3D Datasets
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1. 下载3D数据集
- en: For 3D City Model Analysis, we gather some excellent datasets from OpenData
    Sources. I illustrate a specific tile of interest in the Netherlands, but I encourage
    you to study on your house or any point of interest for you (if you live in the
    Netherlands, of course, 😉).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于3D城市模型分析，我们从开放数据源中收集了一些优秀的数据集。我展示了荷兰一个特定的兴趣区域，但我鼓励你研究你自己的房子或任何对你感兴趣的地点（如果你住在荷兰的话，当然，😉）。
- en: '**The Point Cloud Dataset.** First, we gather a point cloud dataset using the
    [geotiles.nl](https://geotiles.nl/) portal, which provides some nice datasets
    under the CC-BY 4.0 license. For this, you can head over to the website, zoom
    in on the tile of interest, and get the latest version of the AHN LiDAR point
    cloud (in our case, AHN4), as illustrated below. The file will then be downloaded
    as a .laz (LasZip) file.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**点云数据集**。首先，我们使用[geotiles.nl](https://geotiles.nl/)门户网站收集点云数据集，该网站提供了一些在CC-BY
    4.0许可下的良好数据集。为此，你可以访问该网站，缩放到感兴趣的瓦片，并获取最新版本的AHN LiDAR点云（在我们的案例中是AHN4），如下图所示。文件将被下载为.laz（LasZip）文件。'
- en: '![](../Images/f230047cf879386afe3e52e933855c1c.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f230047cf879386afe3e52e933855c1c.png)'
- en: Downloading a 3D LiDAR dataset from the AHN-X campaing, through the portal geotiles.nl.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从AHN-X项目下载3D LiDAR数据集，通过门户网站geotiles.nl。
- en: '🦚 **Note**: *The AHN (Actueel Hoogtebestand Nederland) stems from an Aerial
    LiDAR coverage that provides a digital elevation map for all of the Netherlands.
    It contains detailed and precise height data with an average of eight measurements
    per square meter. Organizations such as the water boards, the provinces, and the
    Department of Public Works use the AHN for water and dam management. Based on
    the height and elevation of the ground level, it is determined whether the water
    can flow sufficiently from the land, how high the water level in the ditches can
    be, whether the water in rivers, flood plains, and ditches can be drained sufficiently
    and whether the dikes are still high and strong enough. The AHN is also used for
    many other types of management, such as daily management and maintenance of dikes,
    preparing specifications for significant maintenance, 3D mapping, permitting,
    and enforcement. Municipalities, businesses, and researchers also use detailed
    elevation data.*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 🦚 **注意**：*AHN（Actueel Hoogtebestand Nederland）源自航拍LiDAR覆盖，为荷兰所有地区提供数字高程地图。它包含详细且精确的高度数据，每平方米平均有八次测量。水务局、省份和公共工程部门等组织使用AHN进行水务和堤坝管理。根据地面高度和高程，决定水是否能从土地上顺利排出，沟渠中的水位可以多高，河流、洪水平原和沟渠中的水是否能得到充分排放，以及堤坝是否仍然足够高且强大。AHN还用于许多其他类型的管理，如日常管理和堤坝维护、重大维护的规格准备、3D绘图、许可和执法。市政府、企业和研究人员也使用详细的高程数据。*
- en: 'If you like figures, I have a quick overview of AHN LiDAR data for you:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢图形，我为你准备了AHN LiDAR数据的快速概述：
- en: 'AHN1: 1997–2004, 1 pt/16 m2 to 1 pt/m2'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'AHN1: 1997–2004, 1 pt/16 m2至1 pt/m2'
- en: 'AHN2: 2007–2012, 8 pts/m2'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'AHN2: 2007–2012, 8 pts/m2'
- en: 'AHN3: 2014–2019, 8 pts/m2'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'AHN3: 2014–2019, 8 pts/m2'
- en: 'AHN4: 2020–2022, 10–15 pts/m2,'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'AHN4: 2020–2022, 10–15 pts/m2，'
- en: 'AHN5: 2023–2025, 10–15 pts/m2'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'AHN5: 2023–2025, 10–15 pts/m2'
- en: '**The Mesh Dataset.**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**网格数据集**。'
- en: For this part, we want to find a 3D Mesh in the same spot as the LiDAR area
    we downloaded. We thus use the platform [3DBAG](http://3dbag.nl) created by TUDelft
    that allows us to retrieve 10M buildings in the Netherlands in LoD1.2, LoD1.3,
    and LoD2.2 from the [CityGML Specification](https://www.ogc.org/standard/citygml/).
    At this step, we are mainly interested in the geometry. Still, we know that the
    semantics and topology are crucial aspects of the CityGML / City JSON Data Models
    and will be explored in further articles. 😉
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这一部分，我们想在与我们下载的LiDAR区域相同的位置找到一个3D网格。因此，我们使用由TUDelft创建的平台 [3DBAG](http://3dbag.nl)，它允许我们从
    [CityGML Specification](https://www.ogc.org/standard/citygml/) 中检索荷兰的10M建筑物，具有LoD1.2、LoD1.3和LoD2.2。在这一步，我们主要关注几何形状。虽然我们知道语义和拓扑是CityGML
    / City JSON数据模型的重要方面，但将在后续文章中探讨。😉
- en: '![](../Images/50f588623ef6881757261e292df79872.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/50f588623ef6881757261e292df79872.png)'
- en: Downloading a dataset from the portal 3Dbag.nl.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从门户网站3Dbag.nl下载数据集。
- en: '🦚 **Note**: *3DBAG contains 3D models at multiple levels of detail, which are
    generated by combining two available data sets: the building data from the* [*BAG*](https://docs.3dbag.nl/en/overview/sources/#BAG)
    *and the height data from the* [*AHN*](https://docs.3dbag.nl/en/overview/sources/#AHN)*.
    The 3D BAG is updated regularly, keeping it up-to-date with the latest openly
    available building stock and elevation information*.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 🦚 **注意**：*3DBAG包含多个细节层级的3D模型，这些模型是通过结合两个可用数据集生成的：来自* [*BAG*](https://docs.3dbag.nl/en/overview/sources/#BAG)
    *的建筑数据和来自* [*AHN*](https://docs.3dbag.nl/en/overview/sources/#AHN)*的高度数据。3D BAG会定期更新，保持最新的开放建筑库存和高程信息*。
- en: After downloading the datasets, you should have one point cloud in the .laz
    file format and one or more .obj datasets (with their accompanying .mtl files)
    that describe approximately the same extent with different Levels of Detail (in
    our case LoD 1.2, 1.3, and 2.2), as illustrated below.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 下载数据集后，你应该会有一个.laz文件格式的点云和一个或多个.obj数据集（以及其附带的.mtl文件），这些数据集大致描述了相同的范围，但具有不同的细节层级（在我们的例子中是LoD
    1.2、1.3和2.2），如下面所示。
- en: '![](../Images/50511df16a6b00c5995b8594721a4391.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/50511df16a6b00c5995b8594721a4391.png)'
- en: '🧙‍♂️ **Wizard**: [OPTIONAL] *If you want to deepen your expertise on 3D data
    file format, especially meshes from point clouds, I encourage you to follow the
    tutorial below that will show you in-depth how to mesh point clouds and how they
    are structured.*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 🧙‍♂️ **向导**： [可选] *如果你想深入了解3D数据文件格式，尤其是点云网格的部分，我建议你跟随下面的教程，详细了解如何将点云网格化及其结构。*
- en: '[](/5-step-guide-to-generate-3d-meshes-from-point-clouds-with-python-36bad397d8ba?source=post_page-----100ff40e4ff0--------------------------------)
    [## 5-Step Guide to generate 3D meshes from point clouds with Python'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[](/5-step-guide-to-generate-3d-meshes-from-point-clouds-with-python-36bad397d8ba?source=post_page-----100ff40e4ff0--------------------------------)
    [## 5步指南：使用Python从点云生成3D网格'
- en: Tutorial to generate 3D meshes (.obj, .ply, .stl, .gltf) automatically from
    3D point clouds using python. (Bonus)…
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 教程：使用python自动从3D点云生成3D网格（.obj, .ply, .stl, .gltf）。(附赠)…
- en: towardsdatascience.com](/5-step-guide-to-generate-3d-meshes-from-point-clouds-with-python-36bad397d8ba?source=post_page-----100ff40e4ff0--------------------------------)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: towardsdatascience.com](/5-step-guide-to-generate-3d-meshes-from-point-clouds-with-python-36bad397d8ba?source=post_page-----100ff40e4ff0--------------------------------)
- en: For the sake of convenience, you can directly download the selection from this
    [**Drive Folder**](https://drive.google.com/drive/folders/1CFX42bIcl3Y4NBa6qhrtmYZ-IX3o7q4r?usp=sharing).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，你可以直接从这个 [**Drive文件夹**](https://drive.google.com/drive/folders/1CFX42bIcl3Y4NBa6qhrtmYZ-IX3o7q4r?usp=sharing)
    下载选择项。
- en: 2.2\. 3D Data Visualization
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2\. 3D数据可视化
- en: We will now jump into `CloudCompare` to ensure that the data downloaded for
    the analysis hold no distinctive surprise. 😁 After launching `CloudCompare`, you
    can load the `.laz` point cloud from your local folder. When the import window
    displays, ensure to import only the `“Classification”` Extra field for this application
    and accept the global shift as shown below.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将进入`CloudCompare`以确保下载的数据分析没有特殊的惊喜。😁 启动`CloudCompare`后，你可以从本地文件夹加载`.laz`点云。当导入窗口显示时，确保仅导入此应用程序的`“Classification”`额外字段，并接受如下面所示的全局偏移。
- en: '![](../Images/135545f5da43ce67aede78208a48476c.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/135545f5da43ce67aede78208a48476c.png)'
- en: 3D Data Visualization within CloudCompare.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在CloudCompare中进行3D数据可视化。
- en: '🦚 **Note**: *The Global Shift is a temporary shift to permit* `*CloudCompare*`
    *to work with georeferenced data that cross the bounds of the number of numbers
    it can handle for visualization purposes. Thus, it is a transparent step* and
    will be applied to the data upon saving*.*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 🦚 **注意**：*全局偏移是一个临时的偏移，以允许`*CloudCompare*`处理地理参考数据，该数据超出了它可以处理的可视化范围。因此，这一步是透明的*，并将在保存数据时应用*。*
- en: We can now move on to importing the mesh data as well. For this, we execute
    the same import action and accept the proposed translation shift while ensuring
    it is the same as the one applied to the point cloud.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续导入网格数据。为此，我们执行相同的导入操作，并接受建议的平移偏移，同时确保它与应用于点云的偏移相同。
- en: '![](../Images/1f493402266cfe74dbbebb61afaf2d50.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1f493402266cfe74dbbebb61afaf2d50.png)'
- en: Loading 3D meshes from the downloaded assets.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 从下载的资产中加载3D网格。
- en: You can now see from the Database Tree the different objects imported in your
    current project (You can check the image below if you cannot find the DBTree).
    The `DBTree` behaves a bit like your OS Explorer, where you have a folder that
    holds different point clouds or meshes. Each object (e.g., a point cloud or a
    3D Mesh) can be activated ☑️ (or deactivated) visually like a layer and selected
    to identify object properties.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以从数据库树中看到当前项目中导入的不同对象（如果找不到DBTree，可以查看下图）。`DBTree`的功能有点类似于你的操作系统资源管理器，其中包含不同的点云或网格。每个对象（例如点云或3D网格）可以像图层一样可视化地激活
    ☑️（或停用）并选择以识别对象属性。
- en: '![](../Images/5835e687656ac5c5a90468fe7fa06d51.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5835e687656ac5c5a90468fe7fa06d51.png)'
- en: CloudCompare Interface for 3D data processing and analysis. © Author
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: CloudCompare 3D数据处理和分析界面。© 作者
- en: '🦚 **Note**: *CloudCompare does not save by default. To bypass any crash, if
    you are worried, you can always put all your data and analysis in one folder from
    the DBTree (Right-Click > Create New Empty Group) and save this folder as a .bin
    CloudCompare project.*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 🦚 **注意**：*CloudCompare默认不保存。为了避免崩溃，如果你担心，可以将所有数据和分析放在DBTree中的一个文件夹中（右键点击 > 创建新的空组），并将此文件夹保存为.bin
    CloudCompare项目。*
- en: 2.3\. 3D Data Subsampling
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3\. 3D数据子采样
- en: It is now time to dive into 3D data filtering. First, we select the point cloud
    from the `DBTree` and apply a spatial subsampling function to keep one point every
    50 cm, allowing us to retain sufficient information while not comprising the computational
    speed after that. For this, we use the `subsample` function as illustrated below.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是深入3D数据过滤的时候了。首先，我们从`DBTree`中选择点云，并应用空间子采样函数以每50厘米保留一个点，这样可以保留足够的信息，同时不会影响计算速度。为此，我们使用下面所示的`subsample`函数。
- en: '![](../Images/75c60243e4fdfd456fd59b6de354358d.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/75c60243e4fdfd456fd59b6de354358d.png)'
- en: 3D Point Cloud Sub-sampling
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 3D 点云子采样
- en: '🧙‍♂️ **Wizard**: *[OPTIONAL] In our case, we used a spatial subsampling function
    to retain one point every 50 cm on average. If you want to explore and deepen
    the 3D point cloud sampling strategies, I recommend diving into the following
    article.*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '🧙‍♂️ **向导**: *[可选] 在我们的案例中，我们使用了空间子采样函数，每隔 50 cm 平均保留一个点。如果你想探索和深入 3D 点云采样策略，我推荐深入阅读以下文章。*'
- en: '[](/how-to-automate-lidar-point-cloud-processing-with-python-a027454a536c?source=post_page-----100ff40e4ff0--------------------------------)
    [## How to automate LiDAR point cloud processing with Python'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[](/how-to-automate-lidar-point-cloud-processing-with-python-a027454a536c?source=post_page-----100ff40e4ff0--------------------------------)
    [## 如何使用 Python 自动化 LiDAR 点云处理'
- en: The ultimate guide on point cloud sub-sampling from scratch, with Python. It
    covers LiDAR I/O, 3D voxel grid processing…
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于点云子采样的终极指南，从零开始，用 Python 编写。涵盖 LiDAR I/O、3D 体素网格处理等……
- en: towardsdatascience.com](/how-to-automate-lidar-point-cloud-processing-with-python-a027454a536c?source=post_page-----100ff40e4ff0--------------------------------)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: towardsdatascience.com](/how-to-automate-lidar-point-cloud-processing-with-python-a027454a536c?source=post_page-----100ff40e4ff0--------------------------------)
- en: Once the subsampling step is done, we get a resulting subsampled point cloud
    in the `DBTree`, that we can use for downstream processes.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成子采样步骤，我们将在 `DBTree` 中得到一个结果子采样点云，可以用于后续处理。
- en: On the Mesh side, upon import, we see that we can open each mesh object from
    the DBTree by clicking on the little arrow icon next to it, which shows many different
    sub-mesh elements. This is because, in the original `.obj` file, we have an “object”
    refinement that permits us to retain some “semantic” decomposition linked to geometries.
    Each sub-mesh is a building entity decomposition.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mesh 方面，导入后，我们可以通过点击每个网格对象旁边的小箭头图标从 DBTree 中打开它，这会显示许多不同的子网格元素。这是因为在原始的 `.obj`
    文件中，我们有一个“对象”细化，这允许我们保留一些与几何体相关的“语义”分解。每个子网格是一个构建实体的分解。
- en: If you want to see these elements, you can open the mesh, select all the sub-element
    by holding `Ctrl+Shift` on the second mouse click, and `right-click > toggle`
    to display them. You can also uncheck the `Visible` property of the parent mesh
    element to ensure what you view is only the sub-elements, as shown below.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看这些元素，可以打开网格，通过按住 `Ctrl+Shift` 并在第二次鼠标点击时选择所有子元素，然后 `右键点击 > 切换` 以显示它们。你还可以取消选中父网格元素的
    `可见` 属性，以确保你看到的仅是子元素，如下所示。
- en: '![](../Images/694d934e30ea666f3dfb863b4b8a4544.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/694d934e30ea666f3dfb863b4b8a4544.png)'
- en: 3D Data Preparation within CloudCompare.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: CloudCompare 中的 3D 数据准备。
- en: '🦚 **Note**: *We cannot use the sub-mesh selection as they also encompass all
    the vertices from the mesh parent, which means that, if we were to use it, we
    would have to segment the mesh to only the vertices of the sub-mesh selected.*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '🦚 **注意**: *我们不能使用子网格选择，因为它们也包含网格父项的所有顶点，这意味着，如果我们使用它，我们将不得不将网格分割为仅选中的子网格的顶点。*'
- en: Excellent, well done! From there, you can uncheck all elements except the mesh
    you want to consider (in our case, the LoD 1.2) and use, E.g., the “Cross Section”
    function, to select the house you are interested in, as shown below.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒，干得好！从那里，你可以取消选择所有元素，只保留你想要考虑的网格（在我们的例子中是 LoD 1.2），并使用例如“横截面”功能，选择你感兴趣的房屋，如下所示。
- en: '![](../Images/f552098ff1c35a90d330c244b378b1d8.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f552098ff1c35a90d330c244b378b1d8.png)'
- en: 3D Data Selection within CloudCompare
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: CloudCompare 中的 3D 数据选择
- en: Once this is done, we are ready to export our selected study site for both 3D
    modalities.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，我们就准备好导出我们选择的研究站点的两种 3D 模态。
- en: 2.4\. 3D Data Export
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4\. 3D 数据导出
- en: Concerning the point cloud data, we can export it in various file formats. Because
    we want to retain the classification field for some Python analysis (E.g., to
    know if a point belongs to the ground or a building), we export the 3D point cloud
    as an ASCII file for easy manipulation in Python, as shown below.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 关于点云数据，我们可以以各种文件格式导出它。由于我们希望保留分类字段以进行一些 Python 分析（例如，了解一个点是否属于地面或建筑物），我们将 3D
    点云导出为 ASCII 文件，以便在 Python 中轻松处理，如下所示。
- en: '![](../Images/e375bc8da30926779b138a3c60a9416c.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e375bc8da30926779b138a3c60a9416c.png)'
- en: 3D Point Cloud Data Export within CloudCompare.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: CloudCompare 中的 3D 点云数据导出。
- en: '🦚 **Note**: *When saving the file, we can optionally modify the file extension
    to* `*.xyz*` *and check the “keep the column names” option when the export dialog
    opens. This will allow having the column’s name written in your file. However,
    if you open your file with a text editor, make sure to delete the two backslashes
    that are not really useful, as shown above.*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 🦚 **注意**：*在保存文件时，我们可以选择修改文件扩展名为* `*.xyz*` *，并在导出对话框打开时勾选“保留列名”选项。这将允许在文件中写入列名。然而，如果你用文本编辑器打开文件，确保删除两个不必要的反斜杠，如上所示。*
- en: Our first 3D dataset is prepared and ready to be used as a `.xyz` file for Python.
    Now, let us move on to the 3D Mesh.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个3D数据集已经准备好，可以作为`.xyz`文件用于Python。现在，让我们继续进行3D网格处理。
- en: After selecting your house/building block of interest, I encourage you to get
    the associated sub-mesh element name and use this as the name for your exported
    file. Concerning the export dialog options, you can choose the .obj file extension,
    which is a safe bet 😉.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 选择你感兴趣的房屋/建筑块后，我建议你获取相关的子网格元素名称，并将其用作导出文件的名称。关于导出对话框的选项，你可以选择`.obj`文件扩展名，这是一个安全的选择😉。
- en: '![](../Images/ac17be9b0af97e470aaa69ecb8fa42ff.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ac17be9b0af97e470aaa69ecb8fa42ff.png)'
- en: 3D Mesh Export within CloudCompare.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: CloudCompare中的3D网格导出。
- en: The 3D Mesh is now ready and accompanied by a material `.mtl` file (not helpful
    in our case).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 3D网格现在已经准备好，并附带一个材料`.mtl`文件（在我们的案例中不太有用）。
- en: Step 2 is Complete! Well done. We first gathered a 3D Point Cloud and a 3D Mesh
    of a zone of the Netherlands. We then visualized them to check if they were corresponding
    to our intent. Then we filtered the point cloud to retain around 1 point every
    50 cm, the 3D Mesh to keep only one object representing a building house, and
    we exported both modalities respectively as a `.xyz`, and a `.obj` + `.mtl` file.¹
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤2已完成！干得好。我们首先收集了荷兰一个区域的3D点云和3D网格。然后我们进行了可视化，以检查它们是否符合我们的意图。接着我们过滤了点云，保留每50厘米左右一个点，3D网格只保留一个代表建筑房屋的对象，并将两种数据分别导出为`.xyz`和`.obj`
    + `.mtl`文件。¹
- en: '![](../Images/4595e2ca0af6a47c7bf76134ee9cf658.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4595e2ca0af6a47c7bf76134ee9cf658.png)'
- en: 'A visual summary of Step 2: 3D Data Preparation. © F. Poux'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤2的可视化总结：3D数据准备。© F. Poux
- en: Let us now put these bad boys into a great Python setup to maximize automation
    and 3D analysis!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将这些数据集放入一个出色的Python设置中，以最大化自动化和3D分析！
- en: ¹For convenience, you can find these datasets in this [**Drive Folder**](https://drive.google.com/drive/folders/1ANqPB5t_pw_n26QkZggbt5JMI0cZ-cO_?usp=sharing).
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹为了方便，你可以在这个[**Drive文件夹**](https://drive.google.com/drive/folders/1ANqPB5t_pw_n26QkZggbt5JMI0cZ-cO_?usp=sharing)中找到这些数据集。
- en: Step 3\. Python Automation
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3步\. Python自动化
- en: Now the real fun begins, time for coding with Python! 🤓
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在真正有趣的部分开始了，是时候用Python编程了！🤓
- en: '![](../Images/a314de57983d17100cf5259317f63320.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a314de57983d17100cf5259317f63320.png)'
- en: 3D Python Automation.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 3D Python自动化。
- en: As shown above, we will follow a five-stage approach by importing libraries,
    loading datasets, setting up our 3D Python Visualiser, Defining solutions to 3D
    Challenges, and then exporting our results to be used outside Python. Let us first
    build the bulk of our automated pipeline in Python before moving to the different
    challenges
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示，我们将遵循五个阶段的方法，包括导入库、加载数据集、设置我们的3D Python可视化工具、定义3D挑战的解决方案，然后将结果导出以供Python之外使用。让我们先在Python中建立我们自动化管道的主体，然后再处理不同的挑战。
- en: 3.1\. Importing libraries
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1\. 导入库
- en: As defined in Step 1., we will stick to a minimal amount of libraries to deepen
    our expertise in their usage. These are `NumPy`, `Pandas`, `Open3D`, `Matplotlib,`
    and `Shapely`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如步骤1中定义的，我们将坚持使用最少的库，以加深我们对其使用的了解。这些库包括`NumPy`、`Pandas`、`Open3D`、`Matplotlib`和`Shapely`。
- en: We will write the lines of code that follow in a Python notebook (`.ipynb`)
    from our IDE.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从我们的IDE中在Python笔记本（`.ipynb`）中编写以下代码行。
- en: '![](../Images/b8a497ba7aed223b175d69426e78d072.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b8a497ba7aed223b175d69426e78d072.png)'
- en: The IDE view to write our script.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 用于编写我们脚本的IDE视图。
- en: 'We import the libraries mentioned above with the following code block:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用以下代码块导入上述提到的库：
- en: '[PRE6]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will return the current Open 3D Version as a string: `Open 3D Version:
    0.16.0`. We are set up, and we can move on to loading the datasets.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '这将返回当前的Open 3D版本作为字符串：`Open 3D Version: 0.16.0`。我们已经设置好了，可以继续加载数据集。'
- en: 3.2\. Loading datasets
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2\. 加载数据集
- en: Now we will define the specific paths where our datasets are stored. I like
    to make it clear and relative to my code file. This way, everything is expressed
    relatively (the `../` means go to the parent folder) in my current notebook, making
    navigating the folder easy if I need to code on different machines.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将定义存储数据集的具体路径。我喜欢将其明确且相对于我的代码文件。这样，一切都相对表达（`../` 表示转到父文件夹），使得在不同机器上编码时，浏览文件夹变得容易。
- en: '[PRE7]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Point Cloud Dataset.**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**点云数据集**。'
- en: 'We can prepare the point cloud by first creating a Pandas `DataFrame` object
    called `pcd_df`, which will host the point cloud data:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过首先创建一个名为 `pcd_df` 的 Pandas `DataFrame` 对象来准备点云，该对象将包含点云数据：
- en: '[PRE8]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will return the name of the columns in this pcd_df DataFrame, which are:
    `[‘X’, ‘Y’, ‘Z’, ‘R’, ‘G’, ‘B’, ‘Classification’]`. This is handy for selecting
    only the explicit “columns” without blurry indexes 😁. And this is precisely what
    we will do: select only the `[‘X’, ‘Y’, ‘Z’]` coordinates to create an Open3D
    `PointCloud` object. This is an excellent way to understand that when we use a
    different library, we must cope with different mechanisms to transform the dataset
    in different Python Objects. Here, we go from a Pandas DataFrame to an Open3D
    PointCloud, which is necessary to use the Open3D functions implemented in the
    Open3D library. Let us proceed in four steps, as illustrated below:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回 pcd_df 数据框中的列名，它们是：`[‘X’, ‘Y’, ‘Z’, ‘R’, ‘G’, ‘B’, ‘Classification’]`。这对于仅选择明确的“列”而不是模糊的索引非常有用
    😁。这正是我们要做的：仅选择 `[‘X’, ‘Y’, ‘Z’]` 坐标以创建 Open3D `PointCloud` 对象。这是一个很好的方法来理解当我们使用不同的库时，我们必须适应不同的机制以将数据集转换为不同的
    Python 对象。在这里，我们从 Pandas DataFrame 转到 Open3D PointCloud，这是使用 Open3D 库中实现的 Open3D
    函数所必需的。让我们按以下四个步骤进行：
- en: '![](../Images/7e414dcc4e8af9947fabce7223ab2bb6.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7e414dcc4e8af9947fabce7223ab2bb6.png)'
- en: The concept workflow for open3D point cloud creation. © Author
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Open3D 点云创建的概念工作流程。© 作者。
- en: 'This decomposed mechanism translates into the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个分解机制转化为以下内容：
- en: '![](../Images/8c0ddc98b107fe8264d4b46bc61da2e7.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8c0ddc98b107fe8264d4b46bc61da2e7.png)'
- en: The code workflow for open3D point cloud creation. © Author.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 Open3D 点云的代码工作流程。© 作者。
- en: 'But hey, if we want to be a bit more condensed, this transformation can then
    be done with a single code line, this one:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，如果我们想要更简洁一点，这个转换可以通过一行代码完成，即：
- en: '[PRE9]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We now have two important variables: `pcd_o3d` and `pcd_df`. We can also give
    some colors to the Open3D `PointCloud` object:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有两个重要的变量：`pcd_o3d` 和 `pcd_df`。我们还可以为 Open3D `PointCloud` 对象添加一些颜色：
- en: '[PRE10]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have to be mindful to transform the `R,G,B` values to float values between
    `[0,1]`, and make sure that we pass a `Vector3dVector` object to the `colors`
    attribute.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须注意将 `R,G,B` 值转换为 `[0,1]` 范围内的浮点值，并确保将 `Vector3dVector` 对象传递给 `colors` 属性。
- en: '**Mesh Dataset.**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**网格数据集**。'
- en: 'Now, we can load the 3D Mesh in a `mesh` variable using the `read_triangle_mesh()`
    method from `open3d`. We can also paint the mesh with the `paint_uniform_color()`
    method:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `open3d` 的 `read_triangle_mesh()` 方法将 3D 网格加载到 `mesh` 变量中。我们还可以使用
    `paint_uniform_color()` 方法为网格上色：
- en: '[PRE11]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We now have two Open3D objects: APointCloud with 7 103 848 points and a Triangle
    Mesh with 674 points and 488 triangles. Let us see what that means, shall we?'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有两个 Open3D 对象：一个包含 7 103 848 个点的 APointCloud 和一个包含 674 个点和 488 个三角形的三角网格。让我们看看这意味着什么，好吗？
- en: 3.3\. Python 3D Visualization
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3\. Python 3D 可视化
- en: 'To visualize in Open3D different 3D objects, we have to pass a **python list**
    of holding these Open3D objects. Our list is thus composed of one Open3D `PointCloud`,
    and one Open3D `TriangleMesh`, which gives `[pcd_o3d,mesh]`. Let us visualize
    this combination in a standalone window with the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Open3D 中可视化不同的 3D 对象，我们必须传递一个包含这些 Open3D 对象的 **python 列表**。因此，我们的列表由一个 Open3D
    `PointCloud` 和一个 Open3D `TriangleMesh` 组成，即 `[pcd_o3d, mesh]`。让我们使用以下代码在独立窗口中可视化这个组合：
- en: '[PRE12]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '🦚 **Note**: *The line above will create an interactive Open3D window that combines
    the 3D point cloud and the 3D mesh.*'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 🦚 **注意**：*上面的代码行将创建一个交互式的 Open3D 窗口，结合了 3D 点云和 3D 网格。*
- en: 'To play with the colors to display, there is one handy trick: using a color
    variable that we will pass to the colors attribute of the PointCloud Open3D object.
    This variable should hold R, G, B float values ranging from `O` to `1`.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要调整显示的颜色，有一个实用的技巧：使用一个颜色变量，该变量将传递给 PointCloud Open3D 对象的颜色属性。此变量应包含从 `0` 到 `1`
    的 R、G、B 浮点值。
- en: '![](../Images/18551016caa1227467965bcf70bb8738.png)![](../Images/3cff291b433da91c893721c7d6b934e7.png)![](../Images/e5a4d747c0c69f956eeb40c7e9454e05.png)![](../Images/e12a344c10402c875344a31f1a3f84a7.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/18551016caa1227467965bcf70bb8738.png)![](../Images/3cff291b433da91c893721c7d6b934e7.png)![](../Images/e5a4d747c0c69f956eeb40c7e9454e05.png)![](../Images/e12a344c10402c875344a31f1a3f84a7.png)'
- en: '🦚 **Note**: *Do you see the slight difference between both screenshots? On
    the right side, we can better delineate the borders, and we have a bit more of
    a depth impression (this is more noticeable interactively). This is because, in
    the second case, we also use normals for visualization. To do that, you can run
    the line* `pcd_o3d.estimate_normals()` *and* `mesh.compute_vertex_normals()` *before
    running the visualization part. Enjoy* 😉'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 🦚 **注意**：*你是否注意到两个截图之间的细微差别？右侧我们可以更好地勾勒出边界，并且有更强的深度感（这在交互式操作中更为明显）。这是因为在第二种情况下，我们还使用了法线进行可视化。要做到这一点，你可以在运行可视化部分之前运行*
    `pcd_o3d.estimate_normals()` *和* `mesh.compute_vertex_normals()` *。享受吧* 😉
- en: 'Let us say that we want to visualize the point cloud colored based on the classification
    attribute. What we thus need to do is to follow this four-stage process:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要根据分类属性可视化点云。我们需要遵循以下四阶段过程：
- en: '![](../Images/3f448bdbc8c3545587c308f4e2c961e2.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3f448bdbc8c3545587c308f4e2c961e2.png)'
- en: The concept workflow to use classification as a color for Open3D.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分类作为Open3D颜色的概念工作流程。
- en: 'If you carefully notice, this then translates into code such as:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，这将转换为如下代码：
- en: '![](../Images/3fa8055f2ac49a7fb61ac506f2745632.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3fa8055f2ac49a7fb61ac506f2745632.png)'
- en: The code workflow to use classification as a color for Open3D.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分类作为Open3D颜色的代码工作流程。
- en: '[PRE13]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '🦚 **Note**: *Because we want to have a hand on the color of each class, we
    can adapt the code above to the number of unique classes. Then, the correspondence
    is done based on the* [*LAS (1.4) Specifications*](https://www.asprs.org/wp-content/uploads/2010/12/LAS_Specification.pdf)*.*'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 🦚 **注意**：*因为我们希望对每个类别的颜色进行控制，我们可以根据唯一类别的数量调整上述代码。然后，映射是基于* [*LAS (1.4) 规范*](https://www.asprs.org/wp-content/uploads/2010/12/LAS_Specification.pdf)*进行的。*
- en: '![](../Images/4cb0fbe0068e65ff012e850ddb032d3d.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4cb0fbe0068e65ff012e850ddb032d3d.png)'
- en: ASPRS Standard Point Classes of the LAS LiDAR data specifications file format.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: LAS LiDAR数据规格文件格式的ASPRS标准点类别。
- en: 'We could visualize the results that would give something like this (with different
    colors depending on the `R,G,B` values inputted):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以可视化结果，类似于这样（根据输入的`R,G,B`值显示不同的颜色）：
- en: '![](../Images/445de1239d521084b27fe5e0e32d8e8d.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/445de1239d521084b27fe5e0e32d8e8d.png)'
- en: Open3D interactive multi-modal data visualization. © Author.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Open3D交互式多模式数据可视化。© 作者。
- en: We have variables loaded, we can see both the point cloud and the 3D Mesh, and
    everything looks like it is working smoothly! Time to define the various 3D City
    Analytical tasks we want to do!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经加载了变量，可以看到点云和3D网格，一切看起来运行顺畅！现在是定义我们想要进行的各种3D城市分析任务的时刻！
- en: 3.4\. 3D City Analysis
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4. 3D城市分析
- en: '3D city analysis refers to the process of using three-dimensional (3D) models
    of urban environments to analyze and understand various aspects of the built environment,
    such as building energy performance, urban morphology, and pedestrian movement.
    This analysis typically involves using specialized paradigms and conducting analyses
    to gain insights into urban planning and design. 3D city analysis can be used
    by urban planners, architects, and engineers to inform decisions about the placement
    of infrastructure, the design of public spaces, and the mitigation of various
    environmental impacts. In this tutorial, we will touch on three main aspects of
    3D City Analysis:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 3D城市分析指的是使用城市环境的三维（3D）模型来分析和理解建筑环境的各种方面，如建筑能源性能、城市形态和行人流动。这种分析通常涉及使用专业范式和进行分析，以获得有关城市规划和设计的见解。3D城市分析可供城市规划师、建筑师和工程师使用，以提供有关基础设施布置、公共空间设计和各种环境影响缓解的决策信息。在本教程中，我们将涉及3D城市分析的三个主要方面：
- en: '1\. Urban Morphology analysis: We can use Python to analyze the shape and form
    of buildings in 3D city dataset, which can help inform decisions about urban design
    and planning.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 城市形态分析：我们可以使用Python分析3D城市数据集中建筑物的形状和形式，这可以帮助提供有关城市设计和规划的决策。
- en: '2\. Geospatial Znalysis: We can perform geospatial analysis on the city model,
    such as identifying the optimal location for new infrastructure projects based
    on factors such as accessibility and environmental impact.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 地理空间分析：我们可以对城市模型进行地理空间分析，例如根据可达性和环境影响等因素确定新基础设施项目的最佳位置。
- en: '3\. 3D Visualization: We can create interactive 3D visualizations, which can
    help stakeholders better understand and engage with urban planning and design
    projects.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 3D 可视化：我们可以创建交互式 3D 可视化，这可以帮助利益相关者更好地理解和参与城市规划和设计项目。
- en: Therefore, this step is specialized to one application, where we do most of
    the analysis. We illustrate on 3D City Analysis, which we extend in section 4,
    through the various Python Challenges, as illustrated below.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这一步专门用于一个应用程序，我们在这里进行大部分分析。我们在 3D 城市分析中进行演示，并在第4节通过各种 Python 挑战进行扩展，如下所示。
- en: '![](../Images/bed78e8f4aea28f4d8fcfef513f4121b.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/bed78e8f4aea28f4d8fcfef513f4121b.png)'
- en: '3D Analysis in the context of cities, and its decomposition in Step 4: 3D Python
    Challenges (Section 4).'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 城市背景下的 3D 分析及其在第4步中的分解：3D Python 挑战（第4节）。
- en: However, we can follow a common workflow, adapted to each application, which
    is usually composed of an input, a processing pipeline, and an output for each
    specific analytical part.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，我们可以遵循一个通用的工作流程，适应于每个应用程序，通常由输入、处理管道和每个特定分析部分的输出组成。
- en: '![](../Images/1e05945cdf9c74f35899860f253e8508.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1e05945cdf9c74f35899860f253e8508.png)'
- en: The conceptual workflow from input to output in the context of point cloud data.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 从输入到输出的概念性工作流程，适用于点云数据。
- en: The input can vary, but in most cases, it is a NumPy array that holds the spatial
    information. The output can be an integer, a list, another NumPy array, … Anything
    you need in return. 😁
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 输入可以有所不同，但在大多数情况下，它是一个包含空间信息的 NumPy 数组。输出可以是一个整数、一个列表、另一个 NumPy 数组……你需要的任何东西。😁
- en: '🦚 **Note**: *This specific stage is dense, and we will leave some space in
    our notebook for the different analyses linked to the challenges we will see in
    Step 4\. For now, let us move to define some way to export our data.*'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 🦚 **注意**：*这个特定阶段比较复杂，我们将在笔记本中留出一些空间，用于记录与第4步挑战相关的不同分析。现在，让我们定义一些方法来导出我们的数据。*
- en: 3.5\. 3D Multi-Modal Export
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5\. 3D 多模态导出
- en: After our 3D pipeline is fully functional, we can save the results to one or
    more files to work them outside Python. For this, we will use two valuable possibilities.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 3D 管道完全功能后，我们可以将结果保存到一个或多个文件中，以便在 Python 之外处理。为此，我们将使用两种有价值的可能性。
- en: '**Numpy (Recommended for complex outputs):** We can export with Numpy with
    the following line of code: `np.savetxt(result_folder+pc_dataset.split(“.”)[0]+”_selection.xyz”,
    np.asarray(o3d_parcel_corners),delimiter=’;’, fmt=’%1.9f’)`'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Numpy（推荐用于复杂输出）：** 我们可以使用以下代码行通过 Numpy 导出：`np.savetxt(result_folder+pc_dataset.split(“.”)[0]+”_selection.xyz”,
    np.asarray(o3d_parcel_corners),delimiter=’;’, fmt=’%1.9f’)`'
- en: '**Open3D (Recommended when needing only spatial attributes):** We can Export
    with Open3D with the following line of code: `o3d.io.write_point_cloud(result_folder+pc_dataset.split(“.”)[0]+”_result_filtered_o3d.ply”,
    pcd_selection, write_ascii=False, compressed=False, print_progress=False)`'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Open3D（推荐仅需空间属性时使用）：** 我们可以使用以下代码行通过 Open3D 导出：`o3d.io.write_point_cloud(result_folder+pc_dataset.split(“.”)[0]+”_result_filtered_o3d.ply”,
    pcd_selection, write_ascii=False, compressed=False, print_progress=False)`'
- en: '*🦚* **Note***: the* `.split(“.”)`*allows to split the* `pc_dataset` *string
    object into a list of two strings, before and after the* `.`*, an then we keep
    only the first element with* `[0]`*. The NumPy exports a variable* `o3d_parcel_corners`
    *stage wit a delimiter ; in a* `.xyz` *ASCII file. The Open3D will write a* `.ply`
    *file from the open3d object* `pcd_selection` *.*'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '*🦚* **注意**：*`.split(“.”)`*允许将*`pc_dataset`*字符串对象拆分为两个字符串的列表，分别在*`.`*之前和之后，然后我们仅保留第一个元素，使用*`[0]`*。NumPy
    将一个变量*`o3d_parcel_corners`*的阶段以分隔符 ; 导出到一个*.xyz* ASCII 文件中。Open3D 将从 open3d 对象*`pcd_selection`*中写入一个*.ply*
    文件。*'
- en: 'Wow, well done! The Python Automation bulk structure is up and running! Congratulation!
    We have the libraries imported, the datasets are stored in different explicit
    variables, and we ensure we can deal with various visualization without leaving
    the comfort of Python. The Export step is set up; all that is left is to target
    the initial question we had in Step 4:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，干得好！Python 自动化的批量结构已经运行起来了！恭喜！我们已经导入了库，数据集被存储在不同的显式变量中，我们确保可以处理各种可视化而无需离开
    Python 的舒适环境。导出步骤已设置完成；剩下的就是解决我们在第4步中提出的初始问题：
- en: How dense is the built area of the neighborhood around our house? Can the house
    be subject to flooding? Am I respecting the built ratio for the parcel I own?
  id: totrans-263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们房子周围的建筑区域有多密集？房子是否可能会受到洪水影响？我是否遵守了我拥有地块的建筑比例？
- en: Step 4\. 3D Python Challenges
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步骤 4. 3D Python 挑战
- en: To answer the questions above, we will find a solution to four challenges and
    voxelization steps, as illustrated below.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答上述问题，我们将找到解决四个挑战和体素化步骤的方案，如下所示。
- en: '![](../Images/4b3d247558729a28d903f154c58610c7.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4b3d247558729a28d903f154c58610c7.png)'
- en: 'Step 4: 3D Python Challenges. We investigate Point of Interest queries, Manual
    Boundary selection, High point extraction, voxelization and built coverage extraction.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤 4：3D Python 挑战。我们研究兴趣点查询、手动边界选择、高点提取、体素化和建筑覆盖提取。
- en: Challenge 1 will permit cropping out the study zone to the desired neighborhood.
    Challenge 2 will permit to extract a built ratio for the owned parcel. Challenge
    3 guides the flooding analysis. And Challenge 4, with a voxelization beforehand,
    will allow getting the built coverage of the area of interest. Let us get started.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战 1 将允许裁剪出所需的研究区域。挑战 2 将允许提取所拥有地块的建筑比例。挑战 3 指导洪水分析。而挑战 4，经过体素化处理后，将允许获取感兴趣区域的建筑覆盖情况。让我们开始吧。
- en: 4.1\. Point of Interest Query
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1. 兴趣点查询
- en: 'For this challenge, we start with an input that comprises a 3D `PointCloud`
    Open3D Object and a `TriangleMesh` Open3D Object, as illustrated below:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个挑战，我们从一个包含 3D `PointCloud` Open3D 对象和 `TriangleMesh` Open3D 对象的输入开始，如下所示：
- en: '![](../Images/76e8121f7bd21325fbe30c9778a0856b.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/76e8121f7bd21325fbe30c9778a0856b.png)'
- en: A 3D Point Cloud with a 3D mesh object. © F. Poux
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 一个带有 3D 网格对象的 3D 点云。© F. Poux
- en: 'The objective of this challenge is to keep only the data points that fall within
    a certain distance from your point of interest, the building house. Our inputs
    are the point cloud and the mesh, and our output is the filtered point cloud which
    answers the distance to the POI criterion as shown below:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这个挑战的目标是只保留落在兴趣点（建筑房屋）一定距离内的数据点。我们的输入是点云和网格，输出是经过过滤的点云，符合到 POI 距离的标准，如下所示：
- en: '![](../Images/6a9063effb3862f75a508f44428c39cc.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6a9063effb3862f75a508f44428c39cc.png)'
- en: 'To get there, I set up a six-stage process as illustrated below:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我设置了一个六阶段的过程，如下所示：
- en: '![](../Images/6453feea2a7852e03490303e8fd1d213.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6453feea2a7852e03490303e8fd1d213.png)'
- en: The Conceptual Workflow for a radius search in a 3D Point Cloud. © Author.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 3D 点云半径搜索的概念工作流。© 作者。
- en: '🎓 **Learning Note**: *The goal is to try to sort things out on your own and
    check back if you have troubles. Whenever you are ready, you can read the solution
    below.* 👇'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 🎓 **学习笔记**：*目标是尽量自己解决问题，如果遇到困难可以查看下面的解决方案。准备好后，可以阅读下面的解决方案。* 👇
- en: '(1) To set the distance threshold, we pass the radius value we want to use
    as a threshold (E.g., `50`) to a new variable `dist_POI`. (2) Then, we get the
    POI from the BAG dataset `mesh` using the `get_center()` Open3D method of the
    Mesh object. This permits getting the center of the mesh as a POI: `POI=mesh.get_center()`.
    We can, after that, create a KD-tree (3), a data structure used to organize points
    in space. KD trees are helpful for point cloud processing because they allow for
    fast nearest-neighbor searches and range queries. These are good news then because
    this is what we are doing 😁. Indeed, using a KD-tree makes it possible to find
    the points closest to a given point quickly, or all the points within a certain
    distance (our POI), without having to search through all the points in the point
    cloud.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: (1) 设置距离阈值时，我们将所需的半径值（例如 `50`）传递给新变量 `dist_POI`。 (2) 然后，我们使用 Mesh 对象的 `get_center()`
    Open3D 方法从 BAG 数据集中获取 POI。这允许获取网格的中心作为 POI：`POI=mesh.get_center()`。之后，我们可以创建 KD
    树 (3)，一种用于组织空间中点的数据结构。KD 树对点云处理非常有用，因为它们允许快速进行最近邻搜索和范围查询。这是好消息，因为这正是我们要做的 😁。实际上，使用
    KD 树可以快速找到离给定点最近的点，或者所有在一定距离内的点（我们的 POI），而无需遍历点云中的所有点。
- en: '[PRE14]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '🦚 **Note**: *The KD-Tree works by recursively partitioning the space into smaller
    regions, dividing it along the median of one of the dimensions at each level (*`X`
    *is a dimension,* `Y` *another,* `Z` *another* 😉*). This results in a “tree” structure
    where each node represents a space partition, and each leaf node represents a
    single point.*'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 🦚 **注意**：*KD-Tree 通过递归地将空间划分为较小的区域，每个级别沿一个维度的中位数进行划分（*`X` *是一个维度，* `Y` *是另一个，*
    `Z` *是另一个* 😉*）。这会生成一个“树”结构，其中每个节点表示一个空间分区，每个叶子节点表示一个单独的点。*
- en: 'From there, we can then use the `search_radius_vector_3d()` method of Open3D
    and select the points from the output index: to finally visualize our result (`4`+`5`+`6`):'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，我们可以使用 Open3D 的 `search_radius_vector_3d()` 方法，并从输出索引中选择点：最后可视化我们的结果（`4`+`5`+`6`）：
- en: '[PRE15]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can finally visualize our results (6):'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终可以可视化我们的结果（6）：
- en: '[PRE16]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![](../Images/01cce6fda16a7553c4811b3f1eccd17f.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01cce6fda16a7553c4811b3f1eccd17f.png)'
- en: The 3D Point Cloud and Mesh underlay of the radius search.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 半径搜索下的 3D 点云和网格叠加。
- en: 'Which amount, all in all, to the following code pipeline:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 总共涉及以下代码管道：
- en: '![](../Images/ca75475c8f727b0c5dd5067e69a82134.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ca75475c8f727b0c5dd5067e69a82134.png)'
- en: The Code workflow of the radius search.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 半径搜索的代码工作流。
- en: Very good! Now that you have a working solution let us extract the parcel area
    from that selection.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 非常好！现在你有了一个有效的解决方案，让我们从那个选择中提取地块面积。
- en: 4.2\. Manual Boundaries Selection
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2\. 手动边界选择
- en: To extract the unofficial boundaries, we have to move onto some semi-automated
    and interactive approach. The good news is that we can do that directly within
    Python with Open3D.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取非官方边界，我们需要采用一些半自动和互动的方法。好消息是，我们可以直接在 Python 中使用 Open3D 来完成这项工作。
- en: 'The first thing to do is to create an interactive Open3D window with the following
    `draw_geometries_with_vertex_selection()` method:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要创建一个带有以下 `draw_geometries_with_vertex_selection()` 方法的互动 Open3D 窗口：
- en: '[PRE17]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can then follow the animated part below, which allows selecting the points
    that define the corners of your parcel.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以跟随下面的动画部分，这允许选择定义地块角落的点。
- en: '![](../Images/2ec4c396a33dc3162d115db29197734f.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2ec4c396a33dc3162d115db29197734f.png)'
- en: The Manual Boundary selection Interactive Process, using Open3D GUI and holding
    the MAJ+Mouse to select points of interest.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 手动边界选择的互动过程，使用 Open3D GUI 并按住 MAJ+鼠标选择感兴趣的点。
- en: The results will then appear in the results under your cell in your notebook
    (or your REPL) upon closing the window.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将出现在你的笔记本（或 REPL）中的单元格下方，关闭窗口后即可查看。
- en: '🦚 **Note**: *It may be easier at this step to use the* `R`*,* `G`*,* `B` *coloring.
    You would thus have to move back to change this before the selection if you want
    to work with the correct indexes.* 😉 *If you want to extract the cadastral boundary*,
    *this is feasible, by importing the official 2D vector shape and cutting based
    on this data constraint.*'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 🦚 **注意**：*在此步骤中，使用* `R`*、* `G`*、* `B` *着色可能更容易。因此，如果您想使用正确的索引，需要在选择前返回进行更改。*
    😉 *如果您想提取地籍边界*，*可以通过导入官方的 2D 矢量图形并根据此数据约束进行裁剪来实现。*
- en: 'From your REPL, you can copy and paste the different indexes (E.g., `34335`,`979`
    ,`21544`,`19666`,`5924`,`21816`,`38008`) of the selected points into the `select_by_index()`
    selection method to define a `o3d_parcel_corners` variable:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 从你的 REPL 中，你可以将选定点的不同索引（例如 `34335`、`979`、`21544`、`19666`、`5924`、`21816`、`38008`）复制并粘贴到
    `select_by_index()` 选择方法中，以定义 `o3d_parcel_corners` 变量：
- en: '[PRE18]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We still have to prepare the corners further because we want to avoid considering
    the `Z` value. Therefore, we will filter out the coordinates to drop the Z value,
    but beware: doing this means that we consider that we are in a flat area (which
    is the case in the Netherlands 😉).'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要进一步准备角落，因为我们想避免考虑 `Z` 值。因此，我们将过滤坐标以去掉 Z 值，但要注意：这样做意味着我们认为我们在一个平坦区域（这在荷兰是事实
    😉）。
- en: '[PRE19]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'From there, it is time to compute the area of the parcel with the `Shapely`
    library! For this, we can directly use `Polygon` function first to create a polygon
    out of the set of provided corners:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，接下来使用 `Shapely` 库计算地块的面积！为此，我们可以直接使用 `Polygon` 函数首先从提供的角落集合中创建一个多边形：
- en: '[PRE20]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Which outputs the following:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](../Images/ea3f386608dbe0efefe779723d4ad548.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ea3f386608dbe0efefe779723d4ad548.png)'
- en: wrong geometry
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 错误的几何形状
- en: 'This looks somewhat wrong, doesn’t it? If you do not believe me, we can compute
    the area to check:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来有点不对，是吧？如果你不相信我，我们可以计算面积来检查：
- en: '[PRE21]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Which outputs `43.583 m²`. That sounds weird for a big building, doesn’t it?
    Ha, a simple problem becomes a bit more complicated! Indeed, the problem here
    is that computing the area needs a polygon that is constituted in a way we obtain
    a closed shape. This is not always the case because the order corners have been
    added to the data structure. Thus, the problem becomes sorting out the coordinates
    to avoid any edges intersection.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这会输出`43.583 m²`。对于一个大建筑来说，这听起来很奇怪，不是吗？哈哈，一个简单的问题变得有点复杂了！实际上，这里的问题在于计算面积需要一个由多边形组成的闭合形状。这并不总是能实现，因为添加角点的顺序可能会影响数据结构。因此，问题变成了排序坐标以避免边缘交叉。
- en: 'One way of dealing with the problem is to perceive all coordinates from the
    perspective of the center point. We can then compute the angle between each corner
    in the list and our center point. We do this to have an idea of how wide the individual
    angles are and therefore provide us with the means tosort out the coordinates
    based on their values. Translating this into code allows defining a sorting function
    as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这个问题的一种方法是从中心点的角度来看所有坐标。然后，我们可以计算列表中每个角点与中心点之间的角度。我们这样做是为了了解每个角度的宽度，从而提供排序坐标的手段。将其翻译成代码允许定义一个排序函数，如下所示：
- en: '[PRE22]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '🦚 **Note**: *I use the NumPy* `arctan2()` *method to perform angle estimation
    for every coordinate. This will return the array of angles in radians. All that’s
    left is to sort out the angles in ascending order to receive a list of indices
    in the correct order. The list can then fix the original list indices with the*
    `argsort()` *method. At this step, it will not work with U-shape buildings.*'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 🦚 **注意**：*我使用 NumPy* `arctan2()` *方法对每个坐标进行角度估算。这将返回以弧度表示的角度数组。剩下的工作是将角度按升序排序，以获取正确顺序的索引列表。然后，列表可以使用*
    `argsort()` *方法修正原始列表的索引。在此步骤中，它不适用于 U 形建筑。*
- en: 'From there, we can apply our sorting function to the corners, create a new
    sorted variable, compute the polygon and the associated area:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，我们可以将排序函数应用于角点，创建一个新的排序变量，计算多边形及其相关面积：
- en: '[PRE23]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This returns the following polygon with an area of `2 247.14 m²`, which is much
    more plausible. 😉
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回了一个面积为`2 247.14 m²`的多边形，这更为可信。😉
- en: '![](../Images/5d875c3360117687f6b52f9bace96f7e.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5d875c3360117687f6b52f9bace96f7e.png)'
- en: right geometry
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的几何形状
- en: Well done again. We now have a good idea of the area of our parcel. Now, let
    us find the high and low points in the zone
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 再次做得很好。我们现在对我们地块的面积有了一个不错的了解。现在，让我们在区域内找到高点和低点。
- en: 4.3\. Find high and low points
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3\. 查找高点和低点
- en: 'To get the low and high points of the area, one specific way would be to use
    the `get_max_bound()` and `get_min_bound()` methods of Open3D:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取区域的低点和高点，一种特定的方法是使用 Open3D 的`get_max_bound()`和`get_min_bound()`方法：
- en: '[PRE24]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'However, doing this will not hint which point is the highest and which is the
    lowest. What we need are the point indexes to retrieve the coordinates after that.
    For this, I propose that we code it this way:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这样做不会提示哪个点是最高的，哪个点是最低的。我们需要的是点的索引，以便在之后检索坐标。为此，我建议我们这样编码：
- en: We create a NumPy array object, `np_pcd_selection`, from the Open3D PointCloud
    object that holds only the `X`,`Y` and `Z` coordinates.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从 Open3D PointCloud 对象中创建一个 NumPy 数组对象`np_pcd_selection`，该对象仅包含`X`、`Y`和`Z`坐标。
- en: We gather the indexes of the min and max values over the `Z` dimension with
    the `argmax()` method and store the results in the variables `lowest_point_index`
    and `highest_point_index`.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`argmax()`方法收集`Z`维度上的最小值和最大值的索引，并将结果存储在变量`lowest_point_index`和`highest_point_index`中。
- en: '[PRE25]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let us check the results by selecting using the indexes, creating `TriangleMesh`
    Spheres, translating them to the position of the points, and then visualizing
    with Open3D:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过选择索引，创建`TriangleMesh`球体，将它们转换到点的位置，然后使用 Open3D 进行可视化来检查结果：
- en: '[PRE26]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As shown below, we now have our 3D scene with the high and low points.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，我们现在有了包含高点和低点的 3D 场景。
- en: '![](../Images/3184931216ccb57af6023a5964685cfa.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3184931216ccb57af6023a5964685cfa.png)'
- en: Let us study the building coverage in an extended vicinity of 350 meters. For
    this, we will re-execute the code for some parts, as explained below.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 350 米的扩展区域内研究建筑覆盖情况。为此，我们将重新执行代码中的某些部分，如下所述。
- en: 4.4\. Point Cloud Voxelization
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4\. 点云体素化
- en: 'We want to extract the built coverage. For this, we will take an intuitive
    approach by first transforming the point cloud modality to a filled analog of
    the 2D pixels: 3D voxels. This will allow us to pursue the following methodology:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要提取已建立的覆盖范围。为此，我们将采取一种直观的方法，首先将点云的模式转换为2D像素的填充模拟：3D体素。这将允许我们使用以下方法：
- en: '![](../Images/b6ed77cf8ddc61af78175af10bfa9c2f.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b6ed77cf8ddc61af78175af10bfa9c2f.png)'
- en: Extracting high points by constructing a 3D voxel data structure. We first voxelize
    the point cloud, then we color each voxel from a binary perspective, and then
    we filter by top-down indexes. © F. Poux
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 通过构建3D体素数据结构来提取高点。我们首先对点云进行体素化，然后从二进制角度对每个体素上色，最后按自上而下的索引进行筛选。© F. Poux
- en: Basically, we will (1) generate voxels where points exist, then (2) we will
    color the voxels based on the classification of the points they hold, and finally,
    we will filter the voxels to keep and count only the highest voxel per X,Y coordinate.
    This way, we can avoid counting elements that would bias the built coverage.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们将（1）生成存在点的体素，然后（2）根据体素所持有的点的分类对体素上色，最后，我们将筛选体素，只保留和计数每个X,Y坐标的最高体素。这样，我们可以避免计数那些会偏向已建立覆盖范围的元素。
- en: 'The first step is to create a voxel grid. This is where Open3D shines: with
    these simple lines of code, we can fit a voxel grid to the point cloud, where
    each voxel is a cube of 20 cm, then visualize the results:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个体素网格。这是Open3D的强项：通过这些简单的代码行，我们可以将一个体素网格适配到点云中，每个体素是一个20 cm的立方体，然后可视化结果：
- en: '[PRE27]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![](../Images/fd12edaca914ab554fbe335093ad0e41.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/fd12edaca914ab554fbe335093ad0e41.png)'
- en: A View of the 3D voxel data structure. © F. Poux
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 3D 体素数据结构的视图。© F. Poux
- en: '🦚 **Note**: *The result you see has been through a change in the coloring of
    the voxels beforehand. This change means, with Open3D, that we have to change
    the color of the voxel’s points. Then, the VoxelGrid method will average the colors
    and retain the result as a color for the voxel.*'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 🦚 **注意**：*您看到的结果已经经过体素上色的变化。这个变化意味着，使用Open3D时，我们必须更改体素点的颜色。然后，VoxelGrid方法将平均这些颜色，并将结果保留为体素的颜色。*
- en: 'Now that we know how to generate 3D voxels from point clouds let us play on
    their color scheme to bypass the coloring averaging problem. For this, a simple
    way would be to handle the color in a binary way. Either it is black ([0,0,0])
    or not (all the rest). This means that we can initialize the colors variable to
    0, and then select all the points which are classified as a building, and give
    them another color, E.g., Red ([1,0,0]):'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何从点云生成3D体素，让我们通过改变它们的颜色方案来绕过颜色平均的问题。为此，一个简单的方法是以二进制方式处理颜色。即黑色（[0,0,0]）或其他颜色（所有其他颜色）。这意味着我们可以将颜色变量初始化为0，然后选择所有被分类为建筑的点，并赋予它们另一种颜色，例如红色（[1,0,0]）：
- en: '[PRE28]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Very nice! Now, because we played with the original point cloud, we will need
    to redefine the POI and the selection to our choosing. For the sake of efficiency,
    you will find the code block that you can run to update your voxel rendering to
    the new color scheme:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 非常好！现在，由于我们对原始点云进行了操作，我们需要根据自己的选择重新定义POI和选择。为了提高效率，您会找到可以运行的代码块，以更新体素渲染到新的颜色方案：
- en: '[PRE29]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![](../Images/8fe6067757404ffe3a2d928221c50c0a.png)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8fe6067757404ffe3a2d928221c50c0a.png)'
- en: The binary coloured point cloud. © F. Poux
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制着色的点云。© F. Poux
- en: 'Awesome! now, we need to actually get the discrete integer indexes of each
    voxel in a list, as well as the colors and the bounds. This will permit us to
    loop over each voxel and its color later to check if a voxel is the highest in
    a “voxel column.” To do this, an efficient way is to do a list comprehension to
    vectorize our computation and avoid unnecessary loops:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在，我们需要实际获取每个体素的离散整数索引，并将它们列出，还有体素的颜色和边界。这将允许我们之后遍历每个体素及其颜色，检查一个体素是否在“体素列”中是最高的。为此，一个有效的方法是使用列表推导式来向量化我们的计算，避免不必要的循环：
- en: '[PRE30]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is awesome! On a selection of 50 meters, we have a grid of 49 x 49x 16
    voxels, which amounts to 38 416 filled voxels. Time to extract the built coverage!
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！在50米的选择区域中，我们有一个49 x 49 x 16的体素网格，总共有38,416个填充的体素。现在是提取已建立的覆盖范围的时候了！
- en: 4.5\. Extract the Built Coverage
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5\. 提取已建立的覆盖范围
- en: 'Now that we have a voxelized point cloud with binary colors, we focus on the
    third stage of the illustration below:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个具有二进制颜色的体素化点云，我们专注于下图的第三阶段：
- en: '![](../Images/f9bc143b7fc885997f06c2ae9dffff23.png)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f9bc143b7fc885997f06c2ae9dffff23.png)'
- en: As we see, selecting only the top voxels is a bit more complex than it seems!
    😁 But lucky you, I designed a simple yet robust pipeline that will do just that,
    below.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，选择仅顶层体素比看起来复杂一些！😁 但幸运的是，我设计了一个简单而强大的管道，可以做到这一点，见下文。
- en: '![](../Images/f0032781dab39f48d3a5d500f98e2246.png)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0032781dab39f48d3a5d500f98e2246.png)'
- en: The Voxel Selection Workflow to extract the built coverage in seven sub-step.
    © F. Poux.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 体素选择工作流以七个子步骤提取已建成的覆盖范围。© F. Poux。
- en: Let us go through it step by step.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步来。
- en: '(1) First, we initialize two dictionaries that hold the max indices:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: (1) 首先，我们初始化两个字典来保存最大索引：
- en: '[PRE31]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '(2 to 5) We loop over all filled voxels to check if they are the highest in
    a voxel column or to be dropped, which gives the following for loop :'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: (2到5) 我们遍历所有填充的体素，以检查它们是否在体素列中最高或应被丢弃，这给出了以下for循环：
- en: '[PRE32]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '🦚 **Note**: *The first thing to notice is the* `enumerate()` *method in the
    loop definition. This permits looping over each value of the variable* `idx_voxels`
    *while keeping track of the index of the list. Handy! The second thing is that
    we are using the “tuples” data type as* `(X, Y)` *, which gives the integer position
    of our voxel. This permits us to ensure that we are continuously checking on the
    identical* `X`*,*`Y` *grid position. Finally, the “*`if`*” statement permits testing
    the expressed condition and will execute if the condition returns* `True`*. If
    it does not, it will execute the* `else` *statement (in the case there is one)
    or pass and exit the condition check.*'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '🦚 **注意**: *首先要注意的是循环定义中的* `enumerate()` *方法。这允许在循环* `idx_voxels` *变量的每个值时跟踪列表的索引。很方便！第二点是我们使用“元组”数据类型，如*
    `(X, Y)`*，这给出了体素的整数位置。这使我们能够确保我们持续检查相同的* `X`*、* `Y` *网格位置。最后，“*`if`*”语句允许测试表达的条件，并在条件返回*
    `True`*时执行。如果条件不为* `True`*，则执行* `else` *语句（如果存在）或跳过并退出条件检查。*'
- en: '(6) We initialize the counts of voxels tagged as built or non-built, and we
    check if the color of the top voxel retained is black or not, in which case we
    update the voxel count of the respective category:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: (6) 我们初始化标记为已建成或未建成的体素的计数，并检查保留的顶部体素的颜色是否为黑色，如果是，我们更新相应类别的体素计数：
- en: '[PRE33]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '🦚 **Note**: `np.all()` *is also a boolean check and will return* `True` *only
    if all values within are* `True`*. In our case, the black color is* `[0,0,0]`*,
    which will thus return* `True` *because all* `R`*,* `G`*, and* `B` *are set to*
    `0` *in this case. If one of them is not zero, that means that not all are* `0`
    *and the* `np.all()` *will return* `False`*, which will trigger the* `else` *statement.
    Easy?* 😉'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '🦚 **注意**: `np.all()` *也是一个布尔检查，只会在所有值都是* `True` *时返回* `True`。在我们的例子中，黑色是* `[0,0,0]`*，因此返回*
    `True` *，因为所有* `R`*、* `G`* 和* `B` *都设置为* `0`。如果其中一个不是零，则意味着并非所有值都是* `0`*，`np.all()`
    *将返回* `False`*，这会触发* `else` *语句。简单吧？* 😉'
- en: '(7) We can extract the area covered for each type (built and non-built) without
    forgetting to multiply the count variable by the actual 2D voxel area (4 m² in
    our case) and get the ratio:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: (7) 我们可以提取每种类型（已建成和未建成）的覆盖区域，记得将计数变量乘以实际的2D体素面积（在我们的例子中为4平方米），并计算比率：
- en: '[PRE34]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This gives us, for 50 meters, a coverage of 17.3%, which amount to 1352 m² of
    built area and 6456 m² belonging to the rest. (19.2%, 73416 m² and 308280 m² for
    the 350 meters query).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，对于50米的范围，我们的覆盖率为17.3%，相当于1352平方米的已建成区域和6456平方米的其余区域。（350米查询的覆盖率为19.2%，73416平方米和308280平方米）。
- en: So, we have a nice balance of building occupation on the selected point of interest
    compared to the rest!
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，与其余部分相比，我们在选定的兴趣点上有一个很好的建筑占用平衡！
- en: Hopefully, putting our 3D Python Workflow to the test was not too nerve-wracking!
    Feel free to return regularly to the code and workflow snippets to master the
    hidden code tricks that permit (1) to answer with brio the challenges and (2)
    optimize the efficiency of our implementation.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 希望测试我们的3D Python工作流并没有让你感到太紧张！随时返回查看代码和工作流片段，掌握隐藏的代码技巧，以便（1）出色地应对挑战和（2）优化我们实现的效率。
- en: '![](../Images/7c041bc073b2d234e2497baf19ce1a09.png)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7c041bc073b2d234e2497baf19ce1a09.png)'
- en: Yet, some room remains left for tweaking, such as using the classification information
    combined with the high-low POI to isolate the ground point for water flows or
    using the parcel surface selection as a filtering technique for built coverage
    extraction.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仍然有一些调整空间，例如使用分类信息结合高低POI来隔离水流的地面点，或使用地块表面选择作为过滤技术来提取已建成的覆盖范围。
- en: '💻 Direct access to the hands-on code: [Google Colab](https://colab.research.google.com/drive/1vvPOYZtUMx2zUxDczakv6XDUq0Ram21y)'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 💻 直接访问实操代码：[Google Colab](https://colab.research.google.com/drive/1vvPOYZtUMx2zUxDczakv6XDUq0Ram21y)
- en: '🪄 Direct access to Point Cloud Processing: [Github](https://github.com/florentPoux/point-cloud-processing)'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 🪄 直接访问点云处理：[Github](https://github.com/florentPoux/point-cloud-processing)
- en: '🧙‍♂️ Direct access to Point Cloud Courses: [3D Academy](https://learngeodata.eu)'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 🧙‍♂️ 直接访问点云课程：[3D Academy](https://learngeodata.eu)
- en: 🔮 Conclusion
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 🔮 结论
- en: Congratulations! This was an actual giant first leap in the world of 3D Python
    Workflows using LiDAR for City Modelling! The pipeline that we constructed below
    is very generic and can be considered a point of reference for your future analytical
    work, which likely follows a similar pattern.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！这在使用 LiDAR 进行城市建模的 3D Python 工作流程领域是一个真正的巨大第一步！我们下面构建的流程非常通用，可以作为你未来分析工作的参考点，这些工作可能会遵循类似的模式。
- en: '![](../Images/35a2f7dccc19d471620463aa5284aeb7.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/35a2f7dccc19d471620463aa5284aeb7.png)'
- en: The 3D Python Workflow in the context of LiDAR City Models. We start with the
    Environment Set up (Step 1) and 3D Data Preparation (Step 2). Once this is done,
    we move on to Python Automation (Step 3), with a specific part dealing with 3D
    Python Challenges (Step 4), such as Parcel Surface or Point Of Interest Queries.
    © Author
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在 LiDAR 城市模型背景下的 3D Python 工作流程。我们从环境设置（步骤 1）和 3D 数据准备（步骤 2）开始。一旦完成这些步骤，我们将进入
    Python 自动化（步骤 3），其中一个特定部分涉及 3D Python 挑战（步骤 4），如地块表面或兴趣点查询。© 作者
- en: 'To summarize the new skills you unlocked, you can now efficiently address the
    following challenges:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下你解锁的新技能，你现在可以高效地应对以下挑战：
- en: Combining Open-Source Software with Python in a coherent workflow;
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将开源软件与 Python 结合成一个连贯的工作流程；
- en: Gathering Open datasets and preparing them before processing;
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集开放数据集并在处理之前准备好它们；
- en: Processing 3D Data Modalities, especially 3D Point Clouds, 3D Meshes and 3D
    Voxels with 3D Python;
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 3D Python 处理 3D 数据模式，特别是 3D 点云、3D 网格和 3D 体素；
- en: Using critical aspects of each 3D Modality for Advanced Geospatial Analysis
    while optimizing the code;
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用每种 3D 模式的关键方面进行高级地理空间分析，同时优化代码；
- en: Extracting Key insights as a City Planner to better understand a local area
    based on the classified point cloud.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为城市规划师从分类点云中提取关键洞察，以更好地理解本地区域。
- en: If you feel in control and able to address these different aspects, then you
    are on the path to becoming a great 3D Geospatial Professional! The only thing
    to do is to keep up the effort and push existing boundaries.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感到自己能够掌握并处理这些不同的方面，那么你正走在成为伟大的 3D 地理空间专业人士的道路上！唯一需要做的就是保持努力，推动现有的边界。
- en: 🤿 Going Further
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 🤿 更进一步
- en: But the learning journey does not end here. Our lifelong search begins, and
    future steps will dive into deepening 3D Voxel work, exploring semantics, CityGML,
    CityJSON, and especially how to get from Clever to Smart Cities. On top, we will
    analyze point clouds with deep learning techniques and unlock advanced 3D LiDAR
    analytical workflows. A lot to be excited about!
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 但学习旅程并未就此结束。我们的终身探索才刚刚开始，未来的步骤将深入研究 3D 体素工作，探索语义、CityGML、CityJSON，特别是如何从聪明的城市走向智慧城市。此外，我们还将利用深度学习技术分析点云，并解锁高级
    3D LiDAR 分析工作流程。有很多令人兴奋的内容！
