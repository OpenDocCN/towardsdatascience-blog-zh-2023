["```py\ndef greeting(input):\n  if input == 1:\n    print('Hello')\n  elif input == 3:\n    print('Goodbye')\n\ngreeting(1)\ngreeting(3)\n```", "```py\n# Create a quantum circuit with 2 qubits.\nqc = QuantumCircuit(2)\n\n# Initialize the simulator.\nsimulator = Aer.get_backend('aer_simulator')\n\n# Invert the first qubit (q0) to a value of 1.\nqc.x(0)\n\n# Place the second qubit (q1) into superposition for a value of 0 AND 1.\nqc.h(1)\n\n# Measure the result.\nqc.measure_all()\n```", "```py\n# Execute the circuit.\njob = execute(qc, simulator)\nresult = job.result()\ncounts = result.get_counts()\n```", "```py\ndef qgreeting(counts):\n  if counts['01'] > 0:\n    print('Hello')\n  if counts['11'] > 0:\n    print('Goodbye')\n\nqgreeting(counts)\n```", "```py\ndef qgreeting(counts):\n    message = ''\n\n    # Define our messages.\n    hello = 'Hello'\n    goodbye = 'Goodbye'\n\n    # Get the total number of measurements counts.\n    total = counts['01'] + counts['11']\n\n    # Calculate the percentage from the counts for \"hello\" and \"goodbye\".\n    percent_hello = counts['01'] / total\n    percent_goodbye = counts['11'] / total\n\n    # Calculate the number of letters to use from \"hello\" and \"goodbye\".\n    hello_chars = math.ceil(len(hello) * percent_hello)\n    goodbye_chars = math.ceil(len(goodbye) * percent_goodbye)\n\n    # Combine the two greetings into a single message.\n    for i in range(hello_chars):\n        message += hello[i]\n    for i in range(goodbye_chars):\n        message += goodbye[i]\n\n    # The result is magic!\n    print(message)\n\nqgreeting(counts)\n```", "```py\nfor i in range(6):\n  # Execute the circuit.\n  job = execute(qc, simulator)\n  result = job.result()\n  counts = result.get_counts()\n\n  # Find the most frequent hit count.\n  key = max(counts, key=counts.get)\n\n  # Since the quantum computer returns a binary string (one bit for each qubit), we need to convert it to an integer.\n  num = int(key, 2)\n\n  # Display \"Hello\" or \"Goodbye\".\n  greeting(num)\n```"]