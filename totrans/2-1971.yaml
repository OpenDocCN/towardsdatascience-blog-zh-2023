- en: Testing Python Code With Pytest — For Beginners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/testing-python-code-with-pytest-for-beginners-bcde301e7453](https://towardsdatascience.com/testing-python-code-with-pytest-for-beginners-bcde301e7453)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Overview and Implementation With Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@aashishnair?source=post_page-----bcde301e7453--------------------------------)[![Aashish
    Nair](../Images/23f4b3839e464419332b690a4098d824.png)](https://medium.com/@aashishnair?source=post_page-----bcde301e7453--------------------------------)[](https://towardsdatascience.com/?source=post_page-----bcde301e7453--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----bcde301e7453--------------------------------)
    [Aashish Nair](https://medium.com/@aashishnair?source=post_page-----bcde301e7453--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----bcde301e7453--------------------------------)
    ·8 min read·Apr 3, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c8878181dbd849d86d9719658b424a99.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Photo by Pixabay: [https://www.pexels.com/photo/blur-business-close-up-code-270557/](https://www.pexels.com/photo/blur-business-close-up-code-270557/)'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When maintaining a data pipeline, it’s important to test the underlying code
    after making any changes. That way, you can be alerted whenever any refactored
    code fails to perform as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Most beginners tend to test their code manually, running their functions against
    different arguments one at a time. This approach is simple, but it does not scale
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a piece of code against a set of arguments once shouldn’t be very time-consuming,
    but how long would it take to do it 10 times? 50 times? 100 times?
  prefs: []
  type: TYPE_NORMAL
- en: In projects that span months or years, where a data pipeline’s underlying code
    is frequently refactored, testing code manually will cost programmers a considerable
    amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: Those taking on long-term projects will benefit from automating this process
    by using [**pytest**](https://docs.pytest.org/en/7.2.x/), a Python testing framework
    that enables users to execute tests with little code.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we uncover the benefits of pytest and show how data scientists can leverage
    this package to write basic tests through a case study.
  prefs: []
  type: TYPE_NORMAL
- en: Is Pytest Worth The Effort?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Writing test with pytest requires users to learn the new framework and even
    adopt new programming habits. So, it might be tempting to shun this tool and stick
    to testing code by manually running it on kernels in a Jupyter Notebook (confession:
    this used to be me).'
  prefs: []
  type: TYPE_NORMAL
- en: However, the benefits of pytest more than make up for the time and effort it
    takes to learn to write them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Pytest requires little run time**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The time needed to run the given tests is negligible. Moreover, thanks to the
    pytest package’s easy syntax, a single command is sufficient for running all tests
    against the pre-defined arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '**2\. Pytest improves the debugging experience**'
  prefs: []
  type: TYPE_NORMAL
- en: The reports generated by pytest are very informative. They identify the tests
    that pass/fail, while also pointing out the cause of the failed tests. This makes
    it easier for programmers to spot their mistake and rectify it.
  prefs: []
  type: TYPE_NORMAL
- en: '**3\. Pytest provides documentation**'
  prefs: []
  type: TYPE_NORMAL
- en: The scripts written with pytest serve as an additional piece of documentation.
    Collaborators looking to understand a piece of code can use the test functions
    to determine its purpose without needing to skim through endless lines of source
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '**4\. Pytest breeds confidence**'
  prefs: []
  type: TYPE_NORMAL
- en: With pytest, users can safely push code to production knowing that the code
    still performs as expected. This allays any fears that data scientists may have
    of pushing code that sabotages the data pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Case Study
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this case study, we will write a number of test functions using pytest
    to test the functions in the `module.py` file. This file contains two functions:
    `add_lists` and `subtract_lists`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `add_lists` function merges two lists by adding the numbers in each element.
    For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `subtract_lists` function merges two lists by subtracting the numbers in
    each element from the lists. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Setting Up the Environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, install pytest by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Long-term projects tend to comprise multiple scripts, so it is common practice
    for the written tests to be placed in a separate folder that doesn’t contain the
    source code. For this case study, we will adhere to this practice by setting up
    the project in the following manner.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The file named `test_module.py` will store all of the test functions.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Our First Tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we can write our first test functions, which test the `add_lists` and
    `subtract_lists` functions. As explained by the [pytest documentation](https://docs.pytest.org/en/7.1.x/explanation/anatomy.html),
    a test typically has 4 steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arrange**: Prepare everything needed for the test.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Act**: Run the function that is being tested'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Assert**: Check if the tested code’s output matches what was expected.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Cleanup**: Remove any objects generated from the test (if any) so that other
    tests aren’t affected. This step is optional.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s write two test functions that follow these steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: The test functions in pytest *must* follow the form `test_*.py` or `\*_test.py`
    to be executed.'
  prefs: []
  type: TYPE_NORMAL
- en: In the snippet above, we *arrange* the tests by establishing the input lists
    as well as the expected outputs. Then, we *act* by running the `add_lists` and
    `subtract_lists` functions with the provided inputs. Finally, we *assert* by using
    assert statements to check if the returned values match the expected values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: Assert statements are a core component in many tests. If you’re unfamiliar
    with the syntax of assert statements or just need a refresher, check out the following
    article:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/debugging-in-python-is-easy-with-with-assert-statements-ff333bfb3388?source=post_page-----bcde301e7453--------------------------------)
    [## Debugging in Python Is Easy With With Assert Statements'
  prefs: []
  type: TYPE_NORMAL
- en: A look into a tool that allows a pain-free troubleshooting experience
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/debugging-in-python-is-easy-with-with-assert-statements-ff333bfb3388?source=post_page-----bcde301e7453--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 'Tests can be run by using the following command in the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Interpreting The Pytest Report
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s get familiar with the pytest report by running the tests in the `test_module.py`
    file with the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If all test functions pass, the report will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e9b7ab331e419adfd6659c5034e8d4e5.png)'
  prefs: []
  type: TYPE_IMG
- en: Command Output (Created By Author)
  prefs: []
  type: TYPE_NORMAL
- en: 'If one or more test functions fail, the report will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a66bc48f17c1a254599eec9b5ccd7d0f.png)'
  prefs: []
  type: TYPE_IMG
- en: Command Output (Created By Author)
  prefs: []
  type: TYPE_NORMAL
- en: As shown by the outputs, test functions that pass are denoted with the `.` character,
    while test functions that fail are denoted with the `F` character.
  prefs: []
  type: TYPE_NORMAL
- en: When a test fails, the report points to the assert statement that isn’t being
    met with the `>` symbol and presents the error message right under it.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, the reports generated by pytest are very informative. They tell us
    how many tests were run, how many tests passed/failed, and why the tests failed
    (if they did).
  prefs: []
  type: TYPE_NORMAL
- en: Generating Reports With Greater Verbosity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `pytest <file_name>` command is sufficient for running tests, but if you
    want to increase the amount of information reported in the output, you can simply
    use the -v flag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Let’s see the pytest report again after using the -v flag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/4a66852f4b9cd305bb3887a9089736f5.png)'
  prefs: []
  type: TYPE_IMG
- en: Command Output (Created By Author)
  prefs: []
  type: TYPE_NORMAL
- en: This time, we can explicitly see the name of the test functions as well as their
    outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a Function With Multiple Arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `test_add_lists` function currently tests the `add_lists` function with
    only one case. However, there are many situations where functions need to be tested
    with multiple cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the `add_lists` function for example. Although adding numbers in two lists
    is a simple task, there are a few edge cases that need to be considered:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding lists with unequal length
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding empty lists
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding lists with strings
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We could test the `add_lists` function with all of these cases by creating test
    functions that test one case each.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: However, that would require repeating many lines of code. Instead, we can run
    tests against multiple inputs by using the `pytest.mark.parametrize` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can modify the current `test_add_lists` function so that it tests multiple
    arguments with the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: This time, the `pytest.mark.parametrize`decorator defines 3 inputs as well as
    the expected outputs. This serves as the *arrange* phase of the test. The *act*
    and *assert* phases don’t need to be changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we execute the test for this function, we get the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/2cf2c56337e7bbed69db7208c999c052.png)'
  prefs: []
  type: TYPE_IMG
- en: Command Output (Created By Author)
  prefs: []
  type: TYPE_NORMAL
- en: As shown by the generated report, each input is defined in the `pytest.mark.parametrize`
    decorator is treated as an individual test. Hence, the report shows the results
    of 3 tests.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Multiple Functions With the Same Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have been creating the input data inside each test function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This begs the question: how should we approach tests where we wish to test
    multiple functions with the *same* data?'
  prefs: []
  type: TYPE_NORMAL
- en: The simplest approach would be to instantiate the same input data inside each
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: However, this is an undesirable practice for a number of reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, it would entail repeating the same lines of code, which hampers readability.
    Secondly, loading data repeatedly can be a time-consuming and computationally
    intensive process. If the data needed for tests comes from a database or flat
    file, performing reads repeatedly on the same data would be highly inefficient.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, users of pytest can resolve this issue by using **fixtures**.
  prefs: []
  type: TYPE_NORMAL
- en: A fixture is a function that uses the `pytest.fixture` decorator. It returns
    the data needed for subsequent tests. Tests that need data from a fixture can
    access it by passing the fixture function as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let’s suppose that we wish to test the `add_lists` and `subtract_lists`
    functions with the same data.
  prefs: []
  type: TYPE_NORMAL
- en: To do so, we can first create a function with the `pytest.fixture` decorator
    called `example_data` that returns the data that will be used for the tests.
  prefs: []
  type: TYPE_NORMAL
- en: This data can be accessed by the test functions `test_add_list` and `test_subtract_lists`
    by passing the `example_data` function as the argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/9edcd367271682a072f6d22dd0024b06.png)'
  prefs: []
  type: TYPE_IMG
- en: Command Output (Created By Author)
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/ad64f905a5de98635a3377a89df8f3cd.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Prateek Katyal](https://unsplash.com/it/@prateekkatyal?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Well done! You have now learned to write and run basic tests with pytest!
  prefs: []
  type: TYPE_NORMAL
- en: While this beginner-level case study doesn’t provide a comprehensive breakdown
    of all the features in pytest, it has hopefully encouraged users to embrace the
    practice of writing scripts using the package for a more structured, efficient,
    and scalable approach toward testing.
  prefs: []
  type: TYPE_NORMAL
- en: I wish you the best of luck in your data science endeavors!
  prefs: []
  type: TYPE_NORMAL
