["```py\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport pandas as pd\nfrom scipy import stats\nsns.set(rc={'figure.figsize':(8,3)})\n\n# Step 1: Create a histogram from beta(10,3)\n# we start by drawing 1000 samples\nbeta1 = stats.distributions.beta(a=10, b=3).rvs(1000)\nax = sns.histplot(beta1, kde=True, stat='density')\nplt.xlabel(\"beta1\", fontsize=14)\nplt.ylabel(\"Density\", fontsize=14)\nplt.title(\"Histogram of beta(10,3)\", fontsize=15)\nplt.show()\n\n# Step 2: Create a uniform distibution from beta(10,3)\n# using the integral probability transform\nu1 = stats.beta.cdf(beta1,a=10, b=3)\nax = sns.histplot(u1, stat='density')\nplt.xlabel(\"u1\", fontsize=14)\nplt.ylabel(\"Density\", fontsize=14)\nplt.title(\"Histogram of uniform samples from beta(10,3) CDF\", fontsize=15)\nplt.show()\n\n# Step 3: Use inverse sampling to generate beta(10,3) samples\n# from the previous uniform samples\n# notice that ppf is the inverse cumulative distribution function \nbeta_transformed = stats.beta.ppf(u1,a=10, b=3)\nax = sns.histplot(beta_transformed, kde=True, stat='density')\nplt.xlabel(\"beta1\", fontsize=14)\nplt.ylabel(\"Density\", fontsize=14)\nplt.title(\"Histogram of transformed beta(10,3)\", fontsize=15)\nplt.show()\n```", "```py\nsns.set(rc={'figure.figsize':(8,3)})\n\n# Step 1: Create a histogram from gamma\ngamma1 = stats.distributions.gamma(a=1, loc=0).rvs(1000)\nax = sns.histplot(gamma1, kde=True, stat='density')\nplt.xlabel(\"gamma1\", fontsize=14)\nplt.ylabel(\"Density\", fontsize=14)\nplt.title(\"Histogram of gamma\", fontsize=15)\nplt.show()\n\n# Step 2: Create a uniform distibution from gamma\nu1 = stats.gamma.cdf(gamma1, a=1, loc=0 )\nax = sns.histplot(u1, stat='density')\nplt.xlabel(\"gamma1\", fontsize=14)\nplt.ylabel(\"Density\", fontsize=14)\nplt.title(\"Histogram of uniform samples from gamma CDF\", fontsize=15)\nplt.show()\n\n# Step 3: Use inverse sampling to generate gamma samples\ngamma_transformed = stats.gamma.ppf(u1,a=1, loc=0)\nax = sns.histplot(gamma_transformed, kde=True, stat='density')\nplt.xlabel(\"gamma1\", fontsize=14)\nplt.ylabel(\"Density\", fontsize=14)\nplt.title(\"Histogram of transformed gamma\", fontsize=15)\nplt.show()\n```", "```py\ngamma1 <- rgamma(1e6, shape=1)\nhist(gamma1, main='gamma distribution', cex.main=1.3, cex.lab=1.3, cex.axis=1.3, prob='true')\n\n# pgamma is the cdf of gamma\nu <- pgamma(gamma1, shape=1)\nhist(u, main='Histogram of uniform samples from gamma CDF', cex.main=1.3, cex.lab=1.3, cex.axis=1.3, prob='true')\n\n# qgamma is the inverted cdf of gamma\ngamma_transformed <- qgamma(u, shape=1)\nhist(gamma_transformed, main='Histogram of transformed gamma', cex.main=1.3, cex.lab=1.3, cex.axis=1.3,prob='true')\n```", "```py\nmean1 = 0\nstd1 = 1\nmean2 = 0\nstd2 = 1\n\nx = np.linspace(-5, 5, 100)\ny = np.linspace(-5, 5, 100)\n\nz1=np.random.normal(mean1, std1, 1000)\nz2=np.random.normal(mean2, std2, 1000)\n\ndf_normal=pd.DataFrame({'z1':z1, 'z2':z2})\nh = sns.jointplot(x='z1', y='z2', data=df_normal)\n\nh.set_axis_labels('z1 (normal)', 'z2 (normal)', fontsize=13);\nh.plot_joint(sns.kdeplot, color=\"r\", zorder=0, levels=6)\nh.plot_marginals(sns.rugplot, color=\"r\", height=-.15, clip_on=False)\n```", "```py\nu1 = norm.cdf(z1)\nu2 = norm.cdf(z2)\n\ndf_uniform=pd.DataFrame({'u1':u1, 'u2':u2})\nh = sns.jointplot(x='u1', y='u2', data=df_uniform)\n\nh.set_axis_labels('u1 (uniform)', 'u2 (uniform)', fontsize=14);\nh.plot_joint(sns.kdeplot, color=\"r\", levels=1)\nh.plot_marginals(sns.rugplot, color=\"r\")\n```", "```py\n# Gaussian copula: C(u1,u2) = Φ2[ Φ^-1(u1), Φ^-2(u2) ]\n\n#sort the results to make the plot smoother\nu1=np.sort(u1)\nu2=np.sort(u2)\n\n# make the last sample exactly 1 to make the plot smoother\nu1[-1]=1\nu2[-1]=1\n\nx1=stats.norm.ppf(u1)  # Φ^-1(u1)\nx2=stats.norm.ppf(u2)  # Φ^-1(u2)\n\n# Parameters of Φ2\nmu_x = 0\nvariance_x = 1\nmu_y = 0\nvariance_y = 1\n# the covariance parameter is what parameterizes the Gaussian copula\ncov=0.8\n\nX, Y = np.meshgrid(x1,x2)\npos = np.empty(X.shape + (2,))\npos[:, :, 0] = X; pos[:, :, 1] = Y\n\n#remember phi2_ is just a multivariate normal CDF\nrv = stats.multivariate_normal([mu_x, mu_y], [[variance_x, cov], [cov, variance_y]])\nphi2 = rv.cdf(pos) \n\nX, Y = np.meshgrid(u1,u2)\n\nfig = plt.figure(figsize=(10,10))\nax = fig.add_subplot(projection='3d')\nax.plot_surface(X, Y, phi2, cmap=cm.coolwarm, linewidth=0)\nax.invert_yaxis()\nax.set_xlabel('X axis')\nax.set_ylabel('Y axis')\nax.set_zlabel('Z axis')\nax.set_title('Gaussian Copula of (z1,z2)', fontdict={'fontsize': 18})\nplt.show()\n```", "```py\nfrom statsmodels.distributions.empirical_distribution import ECDF\n\n# Gaussian copula: C(u1,u2) = Φ2[ Φ^-1(u1), Φ^-2(u2) ]\nx = np.linspace(-5, 5, 100)\ny = np.linspace(-5, 5, 100)\n\n# draw our data samples from 2 distributions, a beta and a gamma - \nbeta1 = stats.distributions.beta(a=10, b=3).rvs(1000)\ngamma1 = stats.distributions.gamma(a=1, loc=0).rvs(1000)\n\n# - we use the emprical cdf instead of beta's or gamma's cdf\n# - we do this to show that copulas can be computed regardless of the\n#   underlying distributions\necdf1 = ECDF(beta1)       # F(beta1) = u1\necdf2 = ECDF(gamma1)      # F(gamma1) = u2\n\n# small correction to remove infinities\necdf1.y[0]=0.0001\necdf2.y[0]=0.0001\n\nx1=stats.norm.ppf(ecdf1.y) # Φ^-1(u1)\nx2=stats.norm.ppf(ecdf2.y) # Φ^-1(u1)\n\n# Parameters of Φ2\nmu_x = 0\nvariance_x = 1\nmu_y = 0\nvariance_y = 1\ncov=0.8\n\nX, Y = np.meshgrid(x1,x2)\npos = np.empty(X.shape + (2,))\npos[:, :, 0] = X; pos[:, :, 1] = Y\n\n#remember phi2 is just a multivariate normal CDF\nrv = stats.multivariate_normal([mu_x, mu_y], [[variance_x, cov], [cov, variance_y]])\nphi2=rv.cdf(pos)\n\nX, Y = np.meshgrid(ecdf1.y,ecdf2.y)\n\nfig = plt.figure(figsize=(10,10))\nax = fig.add_subplot(projection='3d')\nax.plot_surface(X, Y, phi2, cmap=cm.coolwarm, linewidth=0)\nax.invert_yaxis()\nax.set_xlabel('X axis')\nax.set_ylabel('Y axis')\nax.set_zlabel('Z axis')\nax.set_title('Gaussian Copula of (beta,gamma)', fontdict={'fontsize': 18})\nplt.show()\n```"]