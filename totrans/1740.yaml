- en: 'Python to Rust: Everything You Must Know About Virtual Environments'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/python-to-rust-everything-you-must-know-about-virtual-environments-c1cd0e529835](https://towardsdatascience.com/python-to-rust-everything-you-must-know-about-virtual-environments-c1cd0e529835)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Python pro to Rust rookie — a data scientist’s transition tale
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://dennisbakhuis.medium.com/?source=post_page-----c1cd0e529835--------------------------------)[![Dennis
    Bakhuis](../Images/4dc6dca031cdedbb044a1d0a6b142186.png)](https://dennisbakhuis.medium.com/?source=post_page-----c1cd0e529835--------------------------------)[](https://towardsdatascience.com/?source=post_page-----c1cd0e529835--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----c1cd0e529835--------------------------------)
    [Dennis Bakhuis](https://dennisbakhuis.medium.com/?source=post_page-----c1cd0e529835--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----c1cd0e529835--------------------------------)
    ·7 min read·Dec 26, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/114983101b49df51f54b21054860ffc1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: The snake and the crab at the cargo bay. ([Crab](https://unsplash.com/photos/a-group-of-red-mushrooms-ZWrsjySNfxY);
    [Snake](https://unsplash.com/photos/close-up-photo-of-brown-and-gray-snake-VUr5nmC1IM4);
    [containers](https://unsplash.com/photos/assorted-color-filed-intermodal-containers-tjX_sniNzgQ);
    composition by author).'
  prefs: []
  type: TYPE_NORMAL
- en: Embarking on the journey from Python to Rust can feel like swapping a trusty
    lightsaber for a new kind of blade — exciting but a bit daunting. As a data scientist
    deeply familiar with Python’s quirks, diving into the Rust world is a thrilling
    new challenge. In this article, I’ll share my experiences and insights, comparing
    how these two powerful languages handle a key aspect of software development —
    particularly focusing on (virtual) environments and dependency management.
  prefs: []
  type: TYPE_NORMAL
- en: When using Python, one of the first things you learn is to work in so called
    *virtual environments*. It is a crucial tool for managing dependencies and isolating
    project-specific packages such that they do not interfere with other projects
    or the system-wide Python installation. I wrote an article on how I [manage Python](/environments-conda-pip-aaaaah-d2503877884c)
    a few years ago but it is still relevant (it changed a bit with [*micromamba*](https://mamba.readthedocs.io/en/latest/user_guide/micromamba.html)
    and [*poetry*](https://python-poetry.org/), let me know if I should write an article
    about that).
  prefs: []
  type: TYPE_NORMAL
- en: 'TLDR: Just use *cargo* and you will be fine most of the time — Dennis'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'After installing Rust using [*rustup*](https://rustup.rs/), my first question
    was: *how should I create a virtual environment?* To me this is a very sensible
    question as Rust also can use many packages (called Crates) as dependencies. The
    truth is that *cargo* solves this problem very elegantly. Below are my findings
    in comparing virtual environments and pip to the Rust’s *cargo* build system.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Disclaimer: As I navigate these Rustic landscapes, my proficiency with the
    language may still be a bit Rusty (pun intended). Join me in this learning adventure
    as we unravel the nuances of Cargo and bid farewell to the familiar embrace of
    virtual environments.*'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Single global location for packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Virtual environments in Python are created with tools like [*venv*](https://docs.python.org/3/library/venv.html),
    [*virtualenv*](https://virtualenv.pypa.io/en/latest/), or [*conda*](https://docs.conda.io/projects/conda/en/stable/user-guide/getting-started.html)
    on a per-project basis. Under the hood, these systems create a separate folder
    which holds the Python distribution and all its packages. Now, when we install
    a package with *pip* or *conda*, the package and all its dependencies are installed
    in this isolated folder. These virtual environment tools do something that is
    similar to “[*chroot*](https://en.wikipedia.org/wiki/Chroot)”, but for the Python
    installation.
  prefs: []
  type: TYPE_NORMAL
- en: Interpreted languages like Python, dependency resolution often happens at runtime.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In the case of interpreted languages like Python, dependency resolution often
    happens at runtime. This means that when a Python script is executed, the interpreter
    needs to resolve and load the required dependencies dynamically. Virtual environments
    help manage these dependencies, providing a clean separation between projects
    to avoid conflicts. Below is a typical workflow in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Rust on the other hand has a package manager called [*cargo*](https://doc.rust-lang.org/cargo/)
    which uses a single global location, i.e. no user-specific virtual environments.
    It can do this because of the *cargo build system*. When you create a project
    using *cargo* it centers around the `Cargo.toml` file. This is the so-called project
    file that defines details of the project, including its dependencies with semantic
    versioning. Using `cargo add <crate>` you add a dependency to this project-file,
    which is then downloaded during build. As we are using the *cargo* to build and
    cargo takes care of selecting/downloading the right dependencies, there is no
    need for a *chroot-like* mechanic as with Python virtual environments.
  prefs: []
  type: TYPE_NORMAL
- en: By using cargo everything is already in a virtual environment.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The workflow for a new project using *cargo* looks very similar that of Python,
    however, under the hood is it is definitely a bit smarter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: During build using cargo, the correct version of the package required is read
    from `Cargo.toml` and loaded from the global register (by default at `$HOME/.cargo`).
    This is of course mostly possible because Rust is a compiled language and much
    harder to do in Python which needs to resolve the dependencies itself during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Built-in dependency resolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Looking at Python, there is no built-in dependency resolution system. Yes, using
    `pip freeze` you can get an overview of the installed packages however, there
    is no guarantee that it also captures all indirect dependencies. This means that
    it cannot capture the complete complexity of the environment.
  prefs: []
  type: TYPE_NORMAL
- en: Pip freeze might not be enough to capture the full environment
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To solve this issue, dependency resolvers from other languages such a Ruby
    and JavaScript started using so-called *lock-files*. These lock-files capture
    all version information from all dependencies and also the dependencies of dependencies.
    Python gets similar functionality using [*Pipenv*](https://pipenv.pypa.io/en/latest/)
    or my personal favorite: [*Python Poetry*](https://python-poetry.org/) but there
    is no built-in tool when downloading Python.'
  prefs: []
  type: TYPE_NORMAL
- en: Rust’s Cargo, on the other hand, has built-in dependency resolution through
    the use of a lock file. When you use `cargo build` or `cargo run`, it checks the
    `Cargo.lock` file to ensure that the exact versions of all dependencies are used.
    This lock file captures the entire dependency tree, including transitive dependencies,
    making it a comprehensive and deterministic representation of the project's environment.
  prefs: []
  type: TYPE_NORMAL
- en: The `Cargo.lock` file serves as a comprehensive snapshot of the dependencies
    at a specific point in time. It contains precise version information for not only
    the direct dependencies specified in the `Cargo.toml` file but also all transitive
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if Project A depends on Library B version 1.0.0, and Library B
    depends on Library C version 2.1.0, both versions are recorded in the `Cargo.lock`
    file. This ensures that everyone working on the project, regardless of their environment,
    gets the exact same set of dependencies. Cargo is extremely flexible that it can
    support even multiple versions of the same dependency within the same compilation
    target.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a41ab7d2b40b768ae304bf51c76f0cbe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'figure 2: In the building phase Cargo collects all required dependencies. In
    the running phase, the dependencies are already linked inside the executable.
    (Diagram by author).'
  prefs: []
  type: TYPE_NORMAL
- en: Using Cargo’s lock file eliminates the need for developers to manually manage
    and synchronize dependency versions across different environments. It provides
    a consistent and reproducible build environment, making collaboration and deployment
    more reliable. This is a perk it gets from being a compiled language and we might
    consider this an unfair comparison.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Compatibility of packages and Rust itself
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In software engineering, compatibility is a cornerstone that ensures a project
    functions smoothly across various environments. When we compare Rust’s *cargo*
    with Python’s *pip*, we can clearly see that in Rust this has been carefully thought
    through while in Python it has grown to what it is now.
  prefs: []
  type: TYPE_NORMAL
- en: Compatibility in Rust is not just a consideration; it’s a cultural commitment.
    The community places a strong emphasis on maintaining a application programming
    interface (API) compatibility for major versions. This is clearly reflected with
    the *cargo* package manager, which enforces [semantic versioning](https://semver.org/).
    This results in a reliable and predictable development environment where dependencies
    are expected to play nicely with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Contrast this with the Python ecosystem, where compatibility can sometimes be
    a delicate matter. Upgrading Python or its dependencies might lead to unexpected
    issues, and the impact might only surface at runtime. Unlike Rust, where potential
    problems are more likely to be identified at build time, Python developers often
    only see the problems after deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example scenario: upgrading Python 3.7 to Python 3.9'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine you have a Python project running on Python 3.7\. This project includes
    a script that heavily relies on dictionaries. In Python 3.7, dictionaries retain
    insertion order as an implementation detail, but this wasn’t officially guaranteed.
    You decide to upgrade your Python environment to Python 3.9 for performance improvements
    and new language features.
  prefs: []
  type: TYPE_NORMAL
- en: After the upgrade, you notice that your script behaves differently. In Python
    3.7, you might have unintentionally relied on the order of items in dictionaries
    for some operations, even though it wasn’t officially part of the language specification.
    If your code relied on the order of elements in a dictionary and was written without
    the awareness that this behavior was not guaranteed in 3.7, it might behave unpredictably
    or break in Python 3.9 if there were any subtle changes in implementation.
  prefs: []
  type: TYPE_NORMAL
- en: This example illustrates how upgrading even within the same major version of
    Python (Python 3.x) can lead to unexpected issues, especially when the code relies
    on behaviors that were not formally specified in the language but were merely
    by-products of a particular implementation. In this example we ignore the many
    feature that are added within the minor versions, thereby, often changing the
    preferred workflow. Also, the deprecated functions are ignored. For example, some
    methods and functions are removed within Python, even within minor versions.
  prefs: []
  type: TYPE_NORMAL
- en: Rust’s strong focus on stable API maintenance across minor versions ensures
    compatibility and reduces upgrade-related issues. Its rigorous semantic versioning
    and Cargo’s dependency management minimize unexpected changes. This makes Rust
    updates more predictable and less disruptive for developers.
  prefs: []
  type: TYPE_NORMAL
- en: Wrap up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning and working with Rust really highlighted the big differences in how
    each language handles environment and dependency management. Python’s long history
    has led to the evolution of various tools like venv and Poetry, each addressing
    the language’s dynamic nature and runtime dependency resolution challenges. Despite
    their effectiveness, these solutions often feel more like necessary workarounds
    rather than integrated components of the language.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, Rust’s streamlined approach with Cargo demonstrates its commitment
    to a more integrated and user-friendly experience. Cargo’s efficient dependency
    management, free from the need for external tools or ‘PATH’ manipulations, showcases
    Rust’s modern approach to software development.
  prefs: []
  type: TYPE_NORMAL
- en: Learning both, Python and Rust really shines a light on what makes each language
    special and gives us a sneak peek into where software development is heading.
    I think that both Python and Rust still have different goals but we can see that
    these are growing more and more towards each other. Also with the Machine Learning
    community moving slowly towards Rust, and language features from Rust made possible
    in Python for more mature products. I am excited what the future will bring for
    both, Python and Rust!
  prefs: []
  type: TYPE_NORMAL
- en: I’m keen to hear your thoughts and feedback on this journey from Python to Rust.
    Let’s connect on [LinkedIn](https://linkedin.com/in/dennisbakhuis) and continue
    the conversation!
  prefs: []
  type: TYPE_NORMAL
