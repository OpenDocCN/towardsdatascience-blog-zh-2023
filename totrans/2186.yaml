- en: Understanding Independence and Why It Is Critical in Causal Inference and Causal
    Validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/understanding-independence-and-why-it-is-critical-in-causal-inference-and-causal-validation-dfdd26c29739](https://towardsdatascience.com/understanding-independence-and-why-it-is-critical-in-causal-inference-and-causal-validation-dfdd26c29739)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A step-by-step guide to understanding the concept of independence and how to
    apply it to validate directed acyclic graphs in causal validation using Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://grahamharrison-86487.medium.com/?source=post_page-----dfdd26c29739--------------------------------)[![Graham
    Harrison](../Images/c6bfe00c6e0cfcdf3bd042c7fdc03554.png)](https://grahamharrison-86487.medium.com/?source=post_page-----dfdd26c29739--------------------------------)[](https://towardsdatascience.com/?source=post_page-----dfdd26c29739--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----dfdd26c29739--------------------------------)
    [Graham Harrison](https://grahamharrison-86487.medium.com/?source=post_page-----dfdd26c29739--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----dfdd26c29739--------------------------------)
    ·23 min read·Dec 7, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2a1aaf170dbbf7c9485d0cd5023662a6.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Towfiqu barbhuiya](https://unsplash.com/@towfiqu999999?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash)
    on [Unsplash](https://unsplash.com/photos/a-blue-question-mark-on-a-pink-background-oZuBNC-6E2s?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash)
  prefs: []
  type: TYPE_NORMAL
- en: Background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a recent article the author explored and explained how [the concept of dependence](/demystifying-dependence-and-why-it-is-important-in-causal-inference-and-causal-validation-4263b18d5f04)
    can be used to validate a proposed Directed Acyclic Graph (DAG) against a dataset
    to identify spurious edges in the graph i.e. causal links suggested by the DAG
    that do not exist in the data.
  prefs: []
  type: TYPE_NORMAL
- en: In this second instalment, the opposite (but equally critical) concept will
    be applied i.e. how to use independence to identify missing edges. These are causal
    links that do not appear in the proposed DAG but do actually exist in the data
    that must be added back into the DAG to make it complete and correct.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Causal Inference is an emergent branch of data science concerned with determining
    the cause-and-effect relationship between events and outcomes and it has the potential
    to significantly add to the value that machine learning can generate for organisations.
  prefs: []
  type: TYPE_NORMAL
- en: For example a traditional machine learning algorithm can predict which loan
    customers are likely to default thereby enabling proactive intervention with customers.
    However, although this algorithm will be useful to reduce loan defaults it will
    have no concept of why they occurred and whilst pro-active intervention is useful,
    knowing the reasons for defaults would enable the underlying cause to be addressed.
    In this world pro-active intervention may no longer be necessary because the factors
    that led to defaulting have been permanently cured.
  prefs: []
  type: TYPE_NORMAL
- en: This is the promise of Causal Inference and why it has the potential to deliver
    significant impact and outcomes to those organisations that can harness that potential.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of different approaches but the most common approach typically
    starts by augmenting the data with a “Directed Acyclic Graph” (DAG) which encapsulates
    and visualises the causal relationships in the data and then uses causal inference
    techniques to ask “what-if” type questions.
  prefs: []
  type: TYPE_NORMAL
- en: The Problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A DAG that encapsulates the causal relationships in the data is typically constructed
    manually (or semi-manually) by data scientists and domain experts working together.
    Hence the DAG could be wrong which would invalidate any causal calculations leading
    to flawed conclusions and potentially incorrect decisions.
  prefs: []
  type: TYPE_NORMAL
- en: The Opportunity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A range of techniques exist for “Causal Validation” (the process of validating
    the DAG against the data) and if these techniques work they can minimise or eliminate
    errors in the DAG thereby ensuring that the calculations and conclusions are error-free.
  prefs: []
  type: TYPE_NORMAL
- en: The Way Forward
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The statistical concept of independence between random variables can be used
    to ascertain whether a relationship that does not exist in the DAG does exist
    in the data. If this situation is encountered it is likely that the causal relationship
    that is missing in the DAG needs to be added to it to make it complete and correct.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to need an example DAG to work through the problem which has enough
    nodes and links to provide a good example with which to explore the problem …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/62397b5d07af2ce29ceb59fa4144503a.png)'
  prefs: []
  type: TYPE_IMG
- en: DAG used throughout the article — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: The DAG is entirely fictitious so the letters on the nodes do not have any meaning,
    but to note that “X” is the treatment, “Y” is the outcome and the other nodes
    represent factors that are affecting the outcome with the potential to hide or
    skew the true effect of X on Y.
  prefs: []
  type: TYPE_NORMAL
- en: To better understand the DAG, if this were a real-world problem it could represent
    the following …
  prefs: []
  type: TYPE_NORMAL
- en: X represents the regularity with which a drug is taken.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: W represents the effect of the drug on blood pressure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Y represents the improvement on patient recovery and outcome.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Z1, Z2, and Z3 represent other factors (for example maybe Z1 represents healthy
    lifestyle and Z3 represents fitness level etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The arrows in a DAG then represent the causal effect of one factor on another,
    for example …
  prefs: []
  type: TYPE_NORMAL
- en: Taking the drug (represented by “X”) has a causal effect on blood pressure (represented
    by “W”) which in turn has a causal effect on patient recovery (“Y”).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also need some data that matches the DAG. The dataset below is entirely
    synthetic and has been generated by the author; it exactly encapsulates and matches
    the structure suggested by the DAG and contains no erroneous or faulty relationships
    …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/14c239ce462cc25b48f7c62b47cdcbe4.png)'
  prefs: []
  type: TYPE_IMG
- en: Dataset used throughout the article — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: The next sections will begin to unpack the DAG and the data and use them to
    explain how statistical independence can be used to identify causal links that
    have been missed or omitted from the DAG.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Independence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One definition of independence is as follows —
  prefs: []
  type: TYPE_NORMAL
- en: “Independence between two random variables refers to a fundamental concept where
    the occurrence or value of one random variable does not influence or provide any
    information about the occurrence or value of the other random variable”.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let’s take another look at our DAG and consider nodes Z1 and Z2 …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/022365171e6a2f664478b385088ec7b2.png)'
  prefs: []
  type: TYPE_IMG
- en: DAG with nodes Z1 and Z2 highlighted — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: We can see that nodes Z1 and Z2 (representing some causal factors affecting
    the treatment and outcome) have no direct or indirect connection and their are
    no paths through the DAG that link them so Z1 can be said to be independent of
    Z2 (and vice versa).
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the point further we can also see that although X (the treatment)
    and Y (the outcome) are not directly connected they are in fact dependent because
    there are several paths through the DAG that connect them …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/469b8ff3593a28ce0f21f7f168b9e17f.png)'
  prefs: []
  type: TYPE_IMG
- en: All paths between node X and node Y — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: What these two examples show is that if the value if Z1 changes it will not
    influence or change the value of Z2 but if the value of X changes it will change
    the value of Y.
  prefs: []
  type: TYPE_NORMAL
- en: This explanation can be expanded by taking another look at the dataset that
    the DAG is modelling …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/14c239ce462cc25b48f7c62b47cdcbe4.png)'
  prefs: []
  type: TYPE_IMG
- en: Review of the dataset — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: In a real-world causal inference problem the data would be the starting point
    and the DAG would be developed by consulting with the domain experts but to facilitate
    the article the author needed a dataset that was guaranteed to match the DAG.
  prefs: []
  type: TYPE_NORMAL
- en: Hence the dataset above was generated by applying the following formulae to
    create 1000 rows of data …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/622b646be82955250013e6658419d71b.png)'
  prefs: []
  type: TYPE_IMG
- en: Structural equations used to create the dataset — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: This can be read and understood as follows -
  prefs: []
  type: TYPE_NORMAL
- en: Z1 is an exogenous variable (i.e. it has no inputs) that is normally distributed
    with a mean of 4.37 and a standard deviation of 1.95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Z1 is an exogenous variable that is normally distributed with a mean of 1.28
    and a standard deviation of 1.94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Z3 = -1.5 X Z1–1.5 x Z2 + an error term
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: X = -1.5 x Z1 + 1.5 x Z3 + an error term
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: W = -3 x XZ + an error term
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Y = -2.5 x W + -3 x Z2 + -3 x Z3 + an error term
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The formulae that were used to create the data clearly show that Z1 is independent
    of Z2 because they are both completely separate normal distributions but that
    X and Y are not independent because changing X will change W and changing W will
    change Y.
  prefs: []
  type: TYPE_NORMAL
- en: There is yet another way of representing this, by using mathematical notation
    to show the dependence …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4c45fcc133c1680bfa8d5cec342f0d29.png)'
  prefs: []
  type: TYPE_IMG
- en: Independence and dependence notation — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: The ⫫ symbol is called a “double up-tack” and means “is independent of”. The
    ⫫̸ symbol does not have a widely accepted name so I have adopted “slashed double
    up-tack” through personal preference and means “is dependent on” so the formulae
    above read as “Z1 is independent of Z2” and separately “Y is dependent on X”.
  prefs: []
  type: TYPE_NORMAL
- en: In concluding this section we will bring this knowledge back to its importance
    in the context of causal validation.
  prefs: []
  type: TYPE_NORMAL
- en: In a causal inference problem the data will have been collected and the DAG
    will have been constructed separately, usually by consulting domain experts who
    could potentially have made mistakes or whose knowledge could have been incomplete.
  prefs: []
  type: TYPE_NORMAL
- en: Causal validation then is the process of proving or disproving that the DAG
    is a valid causal representation of the data.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Independence has a critical role to play in this process because if the dependencies
    and independencies represented in the DAG can all be matched and detected in the
    data then it can be inferred that the DAG is valid.
  prefs: []
  type: TYPE_NORMAL
- en: This can be represented using the following formulae ..
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/25d47fe820458ca0d20c3c620fc12676.png)'
  prefs: []
  type: TYPE_IMG
- en: Formulae inferring the DAG and data are equivalent for nodes Z1 and Y — Image
    by Author
  prefs: []
  type: TYPE_NORMAL
- en: These formulae look scary but are actually very straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: The first says that if Z1 is independent of Z2 in the graph (DAG) then Z1 should
    also be independent of Z2 in the data.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The second says that if Y is dependent on X in the graph (DAG) then Y should
    also be dependent on Y in the data.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Using Independence to Identify Missing Causal Links
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a previous article I explained how independence can be used to detect spurious
    links i.e. causal relationships that appear in the DAG that do not appear in the
    data …
  prefs: []
  type: TYPE_NORMAL
- en: '[](/demystifying-dependence-and-why-it-is-important-in-causal-inference-and-causal-validation-4263b18d5f04?source=post_page-----dfdd26c29739--------------------------------)
    [## Demystifying Dependence and Why it is Important in Causal Inference and Causal
    Validation'
  prefs: []
  type: TYPE_NORMAL
- en: A step-by-step guide in understanding the concept of dependence and how to apply
    it to validate directed acyclic graphs…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/demystifying-dependence-and-why-it-is-important-in-causal-inference-and-causal-validation-4263b18d5f04?source=post_page-----dfdd26c29739--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: … and in the remainder of this article I will explore how dependence can be
    used to identify missing links i.e. causal relationships that do not appear in
    the DAG that do appear in the data.
  prefs: []
  type: TYPE_NORMAL
- en: It follows that if missing links can be identified using independence they can
    then be added back into an invalid DAG to make it valid.
  prefs: []
  type: TYPE_NORMAL
- en: The approach proposed in this article has its basis in the many works and published
    papers of Judea Pearl who is recognised as a global authority on causal inference.
  prefs: []
  type: TYPE_NORMAL
- en: In “Causal Inference in Statistics” (Pearl, Glymour, Jewell, 2019) Pearl explores
    the idea of using d-separation to identify missing links but it is a partial example
    and does not provide enough explanation to implement an algorithm in Python.
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://www.amazon.co.uk/Causal-Inference-Statistics-Judea-Pearl/dp/1119186846/ref=asc_df_1119186846&amp;mcid=19d06a4904073cf985acfb21fe45ebbb?tag=grahamharri04-21&amp%3BlinkCode=df0&amp%3Bhvadid=80676723059500&amp%3Bhvnetw=o&amp%3Bhvqmt=e&amp%3Bhvbmt=be&amp%3Bhvdev=c&amp%3Bhvlocint=&amp%3Bhvlocphy=&amp%3Bhvtargid=pla-4584276297438266&amp%3Bpsc=1&_encoding=UTF8&linkCode=ur2&linkId=7f120490d4ac7cabf046e73a4cd1c14b&camp=1634&creative=6738&source=post_page-----dfdd26c29739--------------------------------)
    [## Causal Inference in Statistics: A Primer'
  prefs: []
  type: TYPE_NORMAL
- en: 'Buy Causal Inference in Statistics: A Primer 1 by Pearl, Judea, Glymour, Madelyn,
    Jewell, Nicholas P. (ISBN…'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: www.amazon.co.uk](https://www.amazon.co.uk/Causal-Inference-Statistics-Judea-Pearl/dp/1119186846/ref=asc_df_1119186846&amp;mcid=19d06a4904073cf985acfb21fe45ebbb?tag=grahamharri04-21&amp%3BlinkCode=df0&amp%3Bhvadid=80676723059500&amp%3Bhvnetw=o&amp%3Bhvqmt=e&amp%3Bhvbmt=be&amp%3Bhvdev=c&amp%3Bhvlocint=&amp%3Bhvlocphy=&amp%3Bhvtargid=pla-4584276297438266&amp%3Bpsc=1&_encoding=UTF8&linkCode=ur2&linkId=7f120490d4ac7cabf046e73a4cd1c14b&camp=1634&creative=6738&source=post_page-----dfdd26c29739--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: the link above is an amazon affiliate link. If you use the link to purchase
    the book a small finders fee will be paid to the author of this article at no
    additional cost to the purchaser.'
  prefs: []
  type: TYPE_NORMAL
- en: The exploration below aims to provide sufficient explanation and examples such
    that a solution can be implemented in Python that will reliably identify causal
    links that are missing from the DAG but that exist in the data.
  prefs: []
  type: TYPE_NORMAL
- en: This is the rule which must be implemented to reach that goal …
  prefs: []
  type: TYPE_NORMAL
- en: “Within a DAG any node N should be independent of its non-descendants given
    its parents”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (authors own words)
  prefs: []
  type: TYPE_NORMAL
- en: That sounds complicated and it is difficult to understand in isolation but with
    examples it can be made clearer.
  prefs: []
  type: TYPE_NORMAL
- en: Every node in the DAG can be tested separately against that rule. Here is the
    rule applied to node “W” …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ab78b611dc2fd225080859c530d02164.png)'
  prefs: []
  type: TYPE_IMG
- en: Independence rule for node W — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: … which can be read as — “W is independent of its non-descendants given (when
    conditioned on) its parents”.
  prefs: []
  type: TYPE_NORMAL
- en: So what does this mean and how can it be applied to identify missing causal
    relationships in the DAG?
  prefs: []
  type: TYPE_NORMAL
- en: To start with we will need to fully understand what is meant by “parents” and
    what is meant by “non-descendants”.
  prefs: []
  type: TYPE_NORMAL
- en: 'To note: the following diagrams are coloured-coded as follows …'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pink: The node of interest'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Red: Parents'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Green: Descendants'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Yellow: Non-descendants'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Blue: All other nodes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parents of a node are easy to visualise; they are the nodes in the DAG that
    have a causal link with an arrow pointing into that node and we can visualise
    that by considering the charts representing the parents of node W and separately
    the parents of node X …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f626729fd04a02e299cf0028c7a4d76b.png)'
  prefs: []
  type: TYPE_IMG
- en: Parents of node W and parents of node X — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: We can see that node W has a single parent — X and node X has two parents —
    Z1 and Z3 and we can also see that different nodes can have zero, 1 or more parents.
  prefs: []
  type: TYPE_NORMAL
- en: Non-descendants are slightly harder to visualise as they are subtly different
    from ancestors. My definition of non-descendants of a node is as follows …
  prefs: []
  type: TYPE_NORMAL
- en: “Non-descendants of a node are all nodes that are not descendants and also not
    direct parents”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To illustrate this, let’s first visualise all of the descendants of node W,
    and separately node X …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8c5b542eb9269198a2bfbfaea77b0edc.png)'
  prefs: []
  type: TYPE_IMG
- en: Non-descendants of node W and non-descendants of node X — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: And finally, here it is all together — a diagram for node W and a separate diagram
    for node X that highlights their parents in red and their non-descendants in yellow
    …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/12856406bc17871876347c9bff91f6f3.png)'
  prefs: []
  type: TYPE_IMG
- en: Parents and non-descendants of node “ and parents and non-descendants of node
    X — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering two things at this point …
  prefs: []
  type: TYPE_NORMAL
- en: '**Why do non-descendants exclude direct parents?**'
  prefs: []
  type: TYPE_NORMAL
- en: The answer to this question that this is a definition of “non-descendants” that
    broadly follows the solutions proposed in the books of Judea Pearl to discover
    missing links and if you include parents then the following formula will not work
    …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ab78b611dc2fd225080859c530d02164.png)'
  prefs: []
  type: TYPE_IMG
- en: Formula for independence of node W — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: … because the parents would appear on both sides if the “given” symbol (|).
  prefs: []
  type: TYPE_NORMAL
- en: '**What does all this have to do with causal validation?**'
  prefs: []
  type: TYPE_NORMAL
- en: The answer to this question will be revealed in the next section …
  prefs: []
  type: TYPE_NORMAL
- en: Using Independence, Non-Descendants and Parents to Identify Missing Links in
    the DAG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we have defined what independence is i.e. if A is independent of B then
    changing the value of A has no effect on B. We have also explored and understood
    what is meant by “parents” and “non-descendants” and we have a formula inferred
    and consolidated from the literature that can identify missing links (𝑁 ⫫ 𝑛𝑜𝑛−𝑑𝑒𝑠𝑐𝑒𝑛𝑑𝑎𝑛𝑡𝑠
    | 𝑝𝑎𝑟𝑒𝑛𝑡𝑠).
  prefs: []
  type: TYPE_NORMAL
- en: All that remains now is to put it all together — simple! Well maybe not simple,
    so let’s start by re-visiting the final diagram for node W and adding some additional
    paths …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/20efb622c05f51b47806f39cb0b6cc39.png)'
  prefs: []
  type: TYPE_IMG
- en: DAG highlighting possible missing paths from the non-descendants of node W to
    node W — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: The bright pink paths between nodes Z1, Z3, Z2 and Y should not exist in the
    data because they do not exist in the DAG. It therefore follows that if any of
    these dependencies can be detected in the data then the DAG must be wrong and
    not only that, we will know exactly where it is wrong! A missing link on the DAG
    will have been identified rendering the current DAG invalid which can then be
    corrected by adding the missing link back in.
  prefs: []
  type: TYPE_NORMAL
- en: This is an amazing possibility! Let’s start by looking at this expressed as
    a mathematical formula for node W …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/356eee060db8a7bb6ff90f51efd11027.png)'
  prefs: []
  type: TYPE_IMG
- en: Formula for the independence of Node W in the DAG and in the data — Image by
    Author
  prefs: []
  type: TYPE_NORMAL
- en: It looks scary, but all it is saying is that if W is independent of Z1, Z2 and
    Z3 given X in the graph (DAG) then W should be independent of Z1, Z2 and Z3 given
    X in the data as well.
  prefs: []
  type: TYPE_NORMAL
- en: If you would like a refresher on what “given” means in the context of conditioning
    in a DAG, this article provides an in-depth, step-by-step explanation …
  prefs: []
  type: TYPE_NORMAL
- en: '[](/unlock-the-secrets-of-causal-inference-with-a-master-class-in-directed-acyclic-graphs-f2d3b40738e?source=post_page-----dfdd26c29739--------------------------------)
    [## Unlock the Secrets of Causal Inference with a Master Class in Directed Acyclic
    Graphs'
  prefs: []
  type: TYPE_NORMAL
- en: A step-by-step explanation of Directed Acyclic Graphs from the basics through
    to more advanced aspects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/unlock-the-secrets-of-causal-inference-with-a-master-class-in-directed-acyclic-graphs-f2d3b40738e?source=post_page-----dfdd26c29739--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, it is relatively easy to run this test and to see if it is
    true (i.e. does the data matches the DAG or not). Let’s have a go …
  prefs: []
  type: TYPE_NORMAL
- en: To implement the test for W on the right hand side of the formula we can perform
    a regression on all 4 variables on the left hand side — Z1, Z2, Z3 and X. Some
    of the text books and sources talk about Z1, Z2 and Z3 “vanishing”.
  prefs: []
  type: TYPE_NORMAL
- en: What this means is that if the regression is performed on the parent and non-descendant
    variables then all the non-descendants should have either a zero co-efficient
    or one that is close to zero so let’s start by visualising these relationships
    in the data …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/683904ed56e4a2a52b7abbd6374ad575.png)'
  prefs: []
  type: TYPE_IMG
- en: Graphical representation of the Coefficients of X, Z1, Z2 and Z3 when regressed
    against W — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: We can see from this visualisation that Z1, Z2 and Z3 do indeed have a flat
    (or “vanishing”) co-efficient. If we represent the relationships mathematically
    they look like this …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/611e5ba961baaeb4f2d2887583a482a5.png)'
  prefs: []
  type: TYPE_IMG
- en: Mathematical representation of the Coefficients of X, Z1, Z2 and Z3 when regressed
    against W — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: This is all looking good so far, so how can we implement this test and extract
    the results in Python code using an ordinary least squares (OLS) regression?
  prefs: []
  type: TYPE_NORMAL
- en: Here is the source code that does exactly that using the synthetic dataset from
    earlier in the article …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/dd91e49cea4c11ff495b8e9860f53343.png)'
  prefs: []
  type: TYPE_IMG
- en: OLS results summary — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: The key aspects are the `coef` column (co-efficient or slope) and the `P>|t|`
    column (p-value) in the penultimate table of the results summary.
  prefs: []
  type: TYPE_NORMAL
- en: We can easily see that the coefficients (or slopes in the graph) are small but
    not zero (i.e. completely flat) for Z1, Z2 and Z3 so how can we reach a conclusion
    that they are “vanishing”?
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out there is no definition for a “vanishing” co-efficient in any
    of the texts or articles I have read so I have come up with my own method based
    on trial-and-error and a lot of testing …
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The test I have chosen based on many hours of testing is a combination of looking
    at both the p-value and the coefficient in the OLS results summary.
  prefs: []
  type: TYPE_NORMAL
- en: In theory the p-value should be enough on its own. For each variable there is
    a null hypothesis that there is no relationship between the independent variable
    (say Z1) and the dependent variable (W).
  prefs: []
  type: TYPE_NORMAL
- en: If the p-value is less than the alpha value (usually 0.05 is chosen) then the
    null hypothesis is rejected and the conclusion is that there is a relationship.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the results for variable Z1 we can see that the p-value is 0.473
    which is much higher than 0.05 so we cannot reject the null hypothesis and the
    conclusion is that there is no relationship between Z1 and X. This also holds
    for Z2 with a p-value of 0.176 and Z3 which has a p-value of 0.518\. X however
    has a p-value of 0.000 so the null hypothesis cannot be rejected and this all
    matches back to the graph of the slopes above.
  prefs: []
  type: TYPE_NORMAL
- en: So in this case the independence of Z1, Z2 and Z3 from W and the dependence
    of X on W could all have been established by looking at the p-value in isolation
    however in my observations from extensive testing this is not always the case
    and the best results are obtained by defining a “vanishing” co-efficient that
    indicates independence as follows …
  prefs: []
  type: TYPE_NORMAL
- en: “For each variable if the p-value is greater than 0.05 and the co-efficient
    is less than or equal to 1 then that variable is independent (or “vanishing”)”
  prefs: []
  type: TYPE_NORMAL
- en: I have found that if the co-efficient checked is performed in addition to the
    p-value check that the accuracy over a large number of randomly chosen tests increases
    significantly, hence this is the definition I have developed and chosen to implement
    in Python code to perform the check as accurately as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying a Missing Causal Link in an Invalid DAG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point we have considered a DAG and a dataset knowing that the DAG was
    an accurate representation of the causal relationships in the data because the
    author created the dataset to reflect the DAG and not the other way around (which
    is the way it works in the real world).
  prefs: []
  type: TYPE_NORMAL
- en: A method has been proposed for testing the validity of a DAG against a set of
    data that involves testing the independence of non-descendants for each node in
    the DAG and if independence cannot be identified to assume that a link is missing.
  prefs: []
  type: TYPE_NORMAL
- en: That method has been implemented in Python and tested against a case where the
    DAG matches the data and it has proved that the DAG is valid.
  prefs: []
  type: TYPE_NORMAL
- en: This is just the start though. Testing a matching DAG for validity is one thing
    but the more important case is — where the DAG is invalid and has missing links
    that DO exist in the dataset, will this method detect them?
  prefs: []
  type: TYPE_NORMAL
- en: Consider this variation on our DAG …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a9f9b3e4a9e182ebda4165ee712f8c82.png)'
  prefs: []
  type: TYPE_IMG
- en: A variation on the DAG with an additional link from node Z1 to node W — Image
    by Author
  prefs: []
  type: TYPE_NORMAL
- en: A new causal link has been added between node Z1 and node W and here is a new
    synthetic dataset that includes all of the causal relationship including the new
    one …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/aa5fda082cddf2f58f5a1bccdef02c00.png)'
  prefs: []
  type: TYPE_IMG
- en: New dataset including the new link from Z1 to W — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3b212efabdb548c60ec850ca5813a3c6.png)'
  prefs: []
  type: TYPE_IMG
- en: Structural equations that define and describe the new dataset — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s assume that our fictitious domain experts were unaware of the causal
    link between Z1 and W and created this DAG based on their domain knowledge when
    consulted by the data scientists …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8b1ef295b5473bf02b4710d401015d1c.png)'
  prefs: []
  type: TYPE_IMG
- en: DAG containing an error (the new link is missing) — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: At this point the proposed DAG does not match the dataset. The acid test now
    is to see if our method accurately detects the missing link.
  prefs: []
  type: TYPE_NORMAL
- en: The chart below shows the results of the ordinary least squares regression from
    implementing the dependence test “W ⫫ Z1, Z2, Z3 | X” …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3f884933e19e0f13fe3ab801dac38993.png)'
  prefs: []
  type: TYPE_IMG
- en: Coefficients of the new data (that contains the new link) — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When the causal relationship Z1 -> W exists in the data but not in the DAG it
    is correctly identified as missing from the DAG. Hence we know not only that the
    DAG is invalid but also how to fix it. Simply add (“Z1”, “W”) to the DAG as an
    additional edge and it becomes valid!
  prefs: []
  type: TYPE_NORMAL
- en: When I first ran this test successfully I was staggered by the implications.
    I was no longer dependent (no pun intended!) on domain experts being infallible.
    If their were gaps in their knowledge or if they made some mistakes this validation
    technique could find causal links they had missed and produce a correct and valid
    DAG!
  prefs: []
  type: TYPE_NORMAL
- en: At this point we have successfully tested a single node in a valid DAG against
    a dateset and we have successfully identified a missing link from a single node
    in an invalid DAG.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to expand our single-node test to identify and execute all
    validation tests for an entire DAG …
  prefs: []
  type: TYPE_NORMAL
- en: From Testing a Single Node to Validating and Entire DAG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now move from testing node “W” to validating the entire DAG and as it turns
    out this is very straight-forward. Simply iterate around every node executing
    this algorithm …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/074f0d4ed153fc4b32405114890ae368.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Mathematical representation of: for every node that node should be independent
    of its non-descendents given its parents — Image by Author'
  prefs: []
  type: TYPE_NORMAL
- en: For any validation failures add the identified missing link(s) to an overall
    list of missing links and the end result is an identification of all missing links
    in the DAG.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if a node has no parents it should still be tested but if a node has
    no non-descendants it should not and cannot be tested.
  prefs: []
  type: TYPE_NORMAL
- en: Hence node Z3 is omitted from the tests below as it does not have any non-descendants
    (recalling that parents are excluded from non-descendants).
  prefs: []
  type: TYPE_NORMAL
- en: The collection of validation tests required to test the entire DAG can be represented
    visually in the diagrams below (in each dag the node being tested is pink, its
    parents are red, its non-descendants are yellow and all remaining nodes are blue)
    …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/064d30c4245c129c23171a177d3dbd2b.png)'
  prefs: []
  type: TYPE_IMG
- en: Graphical representation of all tests required to fully validate the DAG for
    all missing links — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: Here are the tests represented in the equivalent mathematical notation …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/40fe930f22cc7be93d358393bfeebff4.png)'
  prefs: []
  type: TYPE_IMG
- en: Mathematical representation of all tests required to fully validate the DAG
    for all missing links — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: If these 5 independence tests are executed against the data and the non-descendants
    “vanish” in each test then there is a good level of confidence that the DAG is
    a valid causal representation of the data and that there are no causal links missing
    from the DAG.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is one more optimisation and improvement that can be made. The
    available texts, notably the Pearlean literature — for example “Causal Inference
    in Statistics” (Pearl, Glymour, Jewell, 2019) — describe a smaller set of tests
    than those represented above although I have never managed to find an explanation
    as to how they have been minimised.
  prefs: []
  type: TYPE_NORMAL
- en: Further research and trial-and-error have led to the discovery that some independence
    tests are equivalent, for example …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6f0fdf8a6ed895b783722cc5934a2bca.png)'
  prefs: []
  type: TYPE_IMG
- en: Identifying equivalent tests — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: This means that in test A ⫫ B | P1, P2, … , Pn is equivalent to B ⫫ A | P1,
    P2, … , Pn and one of them can be dropped as there is no point testing for exactly
    the same thing twice.
  prefs: []
  type: TYPE_NORMAL
- en: It therefore follows that the optimised tests for proving or disproving the
    validity of our example DAG are as follows …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b7d40e034c015e5d1ff7d908063cf95e.png)'
  prefs: []
  type: TYPE_IMG
- en: Optimised missing link tests for our DAG with equivalent tests removed — Image
    by Author
  prefs: []
  type: TYPE_NORMAL
- en: i.e. Z2 ⫫ Z1 has been removed because it is equivalent to Z1 ⫫ Z2 and tests
    do not need to be repeated.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s finish this section off by taking a look at the graphs that are produced
    when implementing the OLS regression test for each of our 4 independence statements
    …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/03b976f44ea940797193da83880198d8.png)'
  prefs: []
  type: TYPE_IMG
- en: Visualising the coefficients for all 4 missing link tests for the DAG — Image
    by Author
  prefs: []
  type: TYPE_NORMAL
- en: This result is exactly what we were hoping for! For each node being tested the
    graph shows that the coefficients for the non-descendants are very small i.e.
    they are vanishing i.e. they are independent i.e. there are no missing links.
  prefs: []
  type: TYPE_NORMAL
- en: The obvious next question to ask is “just how reliable is this technique and
    can it always be relied on to identify missing causal links and correct an invalid
    DAG?”
  prefs: []
  type: TYPE_NORMAL
- en: This is a very important question to ask and answer, made doubly so because
    none of the literature (books, blogs and articles etc.) that I have read addresses
    this critical question. Where causal validation is explored at all it tends to
    be incomplete, poorly explained and with too much statistical jargon and not enough
    Python code, but crucially I have only ever found examples where the DAG and the
    data match with no exploration of what happens when they do not.
  prefs: []
  type: TYPE_NORMAL
- en: The following sections develop this thought beyond anything I have ever found
    in the literature using approaches that I have conceived of and experimented with
    in Python code to see how these algorithms perform in life-like scenarios …
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Proposed Algorithm to Destruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To test the algorithm proposed in this article to destruction, the following
    approach was taken …
  prefs: []
  type: TYPE_NORMAL
- en: Identify every edge (causal relationship) in the dag
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run 100 tests as follows …
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate a valid set of test data for the DAG.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pick one of the missing edges at random and delete it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See if the proposed algorithm correctly identifies the missing edge.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In evaluating success two factors were considered …
  prefs: []
  type: TYPE_NORMAL
- en: Did the proposed algorithm find the deleted / missing edge(s) exactly?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Did the algorithm find the deleted / missing edges but in addition to that identify
    additional missing edges in error?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The results were as follows …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8690de7bbfdfc172f1ded399957f8278.png)'
  prefs: []
  type: TYPE_IMG
- en: Visualising the testing of all possible combinations of a single missing link
    — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: The missing edge is correctly identified in 100/100 tests but in 13 of those
    tests the algorithm also identifies some other edge(s) that are in fact not missing.
  prefs: []
  type: TYPE_NORMAL
- en: The next obvious question is “what if two edges / causal links are missing?”
    …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d4fa9b472be259ec22d63d49403f399b.png)'
  prefs: []
  type: TYPE_IMG
- en: Visualising the testing of all possible combinations of a two missing link s—
    Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: The accuracy drops when two edges are deleted. The algorithm correctly finds
    the two missing edges in 68/100 of tests but in 14 of those it over-identifies
    and finds some edges it thinks are missing which in fact are not.
  prefs: []
  type: TYPE_NORMAL
- en: Further tests can be carried out to evaluate the algorithm performance for a
    much more complicated, life-like DAG …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1b0a9732ef8f01f31fea3336c84519d9.png)'
  prefs: []
  type: TYPE_IMG
- en: Visualising the testing of all possible combinations of a single missing link
    in a complex DAG — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: In this case the algorithm correctly identifies the missing causal link in 74/100
    tests including 18 tests where additional links are identified as missing that
    actually are not.
  prefs: []
  type: TYPE_NORMAL
- en: To complete the testing, here is the test for a complex DAG with 2 valid links
    taken out …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/03a64de8d88d9fdc694df8f9be7d4dfe.png)'
  prefs: []
  type: TYPE_IMG
- en: Visualising the testing of all possible combinations of two missing links in
    a complex DAG — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: This time the accuracy starts to slip. The algorithm correctly identifies the
    missing causal links in 50/100 tests but that includes 20 where the algorithm
    incorrectly identified additional links that it thought were missing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bonus Section: Optimising Missing Links'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have been wondering why the test results have included the number of
    tests where the identified missing links matched exactly with another figure quoted
    for the tests that over-identified i.e. the deleted link(s) were found but so
    were some others that were incorrectly identified.
  prefs: []
  type: TYPE_NORMAL
- en: The reason is that in the case of over-identification the links identified as
    missing that were not actually missing can be easily fixed.
  prefs: []
  type: TYPE_NORMAL
- en: In a recent article I explored the mirror image of the validation explained
    here which is where dependence is used to identify spurious links (as opposed
    to using independence to identify missing links).
  prefs: []
  type: TYPE_NORMAL
- en: '[](/demystifying-dependence-and-why-it-is-important-in-causal-inference-and-causal-validation-4263b18d5f04?source=post_page-----dfdd26c29739--------------------------------)
    [## Demystifying Dependence and Why it is Important in Causal Inference and Causal
    Validation'
  prefs: []
  type: TYPE_NORMAL
- en: A step-by-step guide in understanding the concept of dependence and how to apply
    it to validate directed acyclic graphs…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/demystifying-dependence-and-why-it-is-important-in-causal-inference-and-causal-validation-4263b18d5f04?source=post_page-----dfdd26c29739--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: The “spurious links” algorithm is amazingly accurate and identifies nearly all
    spurious links correctly, even where there are 2 or more and even in a complex
    DAG.
  prefs: []
  type: TYPE_NORMAL
- en: That means that an algorithm that finds a missing link(s) but also over-identifies
    some that are not actually missing can be optimised and improved as follows …
  prefs: []
  type: TYPE_NORMAL
- en: Run the dependence / spurious link algorithm to identify and correct any genuine
    **spurious links**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the independence / missing link algorithm proposed in this article to identify
    and correct any **missing links**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As step 2 may have over-identified, re-run the dependence / spurious link algorithm
    which will find and remove any links step 2 thought were missing but actually
    were not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If this advanced algorithm were implemented it would increase the accuracy to
    the higher of the two numbers quoted for each test in the sections above, i.e.
    …
  prefs: []
  type: TYPE_NORMAL
- en: '1 missing link in a simple DAG: 100% accuracy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '2 missing links in a simple DAG: 68% accuracy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '1 missing link in a complex DAG: 74% accuracy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '2 missing links in a complex DAG: 50% accuracy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whilst these results are not perfect they are certainly good enough to be extremely
    useful.
  prefs: []
  type: TYPE_NORMAL
- en: It should also be noted that the algorithm proposed in this article has close
    to 100% accuracy when the DAG actually matches the data so in the case of a validation
    failure an alternative approach would be to modify the DAG through brute-force
    trial-and-error until the validation checks pass (or the errors are minimised).
  prefs: []
  type: TYPE_NORMAL
- en: These are complex techniques which will be fully explored in future articles
    but the theory is sound and it offers the tantalising potential to produce highly
    effective algorithms for implementing causal validation.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Causal inference offers the promise of a new set of techniques to extend the
    organisational impact and outcomes offered by established machine learning.
  prefs: []
  type: TYPE_NORMAL
- en: However, in order to start that causal journey the Directed Acyclic Graph (DAG)
    that captures the causal relationships must be constructed using domain expertise
    which can be flawed.
  prefs: []
  type: TYPE_NORMAL
- en: Unless the DAG accurately captures the causal relationships any subsequent analysis
    could contain errors but causal validation offers the potential to correct and
    fix inaccurate DAGs to ensure the conclusions of causal inference approaches are
    correct.
  prefs: []
  type: TYPE_NORMAL
- en: A previous article explored how to use dependence to identify and remove spurious
    causal links from the DAG whilst this article explored how to use independence
    to identify and add missing causal links.
  prefs: []
  type: TYPE_NORMAL
- en: Future articles will explore how to use v-structures to identify and correct
    reversed causal links (where the causal arrow is in the wrong direction) and also
    how to combine spurious, missing and reversed link tests into a coherent whole
    that offers the promise of highly effective causal validation algorithms leading
    to improved organisational impact and outcomes arising from the optimal application
    of causal inference techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Connect and Get in Touch …
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you enjoyed this article, you can get unlimited access to thousands more
    by becoming a Medium member for just $5 a month by [clicking on my referral link](https://grahamharrison-86487.medium.com/membership)
    (I will receive a proportion of the fees if you sign up using this link at no
    extra cost to you).
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://grahamharrison-86487.medium.com/membership?source=post_page-----dfdd26c29739--------------------------------)
    [## Join Medium with my referral link - Graham Harrison'
  prefs: []
  type: TYPE_NORMAL
- en: As a Medium member, a portion of your membership fee goes to writers you read,
    and you get full access to every story…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: grahamharrison-86487.medium.com](https://grahamharrison-86487.medium.com/membership?source=post_page-----dfdd26c29739--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: … or connect by …
  prefs: []
  type: TYPE_NORMAL
- en: '[Subscribing to a free e-mail whenever I publish a new story](https://grahamharrison-86487.medium.com/subscribe).'
  prefs: []
  type: TYPE_NORMAL
- en: '[Taking a quick look at my previous articles](https://grahamharrison-86487.medium.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: '[Downloading my free strategic data-driven decision making framework](https://relentless-originator-3199.ck.page/5f4857fd12).'
  prefs: []
  type: TYPE_NORMAL
- en: Visiting my data science website — [The Data Blog](https://www.the-data-blog.co.uk/).
  prefs: []
  type: TYPE_NORMAL
