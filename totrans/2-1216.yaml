- en: How to Objectively Compare Two Ranked Lists in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/how-to-objectively-compare-two-ranked-lists-in-python-b3d74e236f6a](https://towardsdatascience.com/how-to-objectively-compare-two-ranked-lists-in-python-b3d74e236f6a)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A simplified explanation and implementation of Rank Biased Overlap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://krupesh-raikar.medium.com/?source=post_page-----b3d74e236f6a--------------------------------)[![Krupesh](../Images/e5cf0673fe40d115c29e4c6628395745.png)](https://krupesh-raikar.medium.com/?source=post_page-----b3d74e236f6a--------------------------------)[](https://towardsdatascience.com/?source=post_page-----b3d74e236f6a--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----b3d74e236f6a--------------------------------)
    [Krupesh](https://krupesh-raikar.medium.com/?source=post_page-----b3d74e236f6a--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----b3d74e236f6a--------------------------------)
    ·10 min read·Jan 5, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8ce80da25708928b0424823ff8e67be0.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Imagine you and your friend have both watched all 8 Harry Potter movies.**'
  prefs: []
  type: TYPE_NORMAL
- en: '*But there’s a catch* — you have watched each movie the day it was released,
    without missing a single premier.'
  prefs: []
  type: TYPE_NORMAL
- en: Your friend, however, watched the 2nd movie first, then the 4th and 5th, and
    then binge-watched the rest when it was available on Netflix.
  prefs: []
  type: TYPE_NORMAL
- en: Theoretically, you and your friend are on an equal footing — both have watched
    all the movies of the series.
  prefs: []
  type: TYPE_NORMAL
- en: '***Is it really equal though?***'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8368f473939f56ce003463091bdd50b2.png)'
  prefs: []
  type: TYPE_IMG
- en: Image created by the author using a commercially usable typeface ([Harry P](https://fontswan.com/harry-potter-font/#4-caslon-antique))
    and CC image from [Wikimedia](https://commons.wikimedia.org/wiki/File:Harry_Potter_Lightning.svg)
  prefs: []
  type: TYPE_NORMAL
- en: You being a true fan, can never consider it equal.
  prefs: []
  type: TYPE_NORMAL
- en: How could someone not watch the movies of abook series, **In. A. Sequence?!**
  prefs: []
  type: TYPE_NORMAL
- en: '***You consider it a sacrilege!***'
  prefs: []
  type: TYPE_NORMAL
- en: The good news is — **the math is on your side.** *You can boil this problem
    down into a ranked list comparison.*
  prefs: []
  type: TYPE_NORMAL
- en: There are several methods to compare lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this post, you will:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand why we actually need a ranked list comparison
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the requirements a comparison measure should satisfy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get an overview of a method called Rank Biased Overlap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the mathematical approach behind it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a simple implementation in python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*At the end of it, you will finally settle the disagreement with your friend
    once and for all:*'
  prefs: []
  type: TYPE_NORMAL
- en: '**You != Your Friend**'
  prefs: []
  type: TYPE_NORMAL
- en: Why do you need a ranked list comparison?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from the above movie viewing order disagreement, we are surrounded by
    examples of comparing lists!
  prefs: []
  type: TYPE_NORMAL
- en: In fact, we all do such comparisons all the time.
  prefs: []
  type: TYPE_NORMAL
- en: Which results are better for the same query on Google vs. Bing?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How similar is the New York Times bestseller list to that from USA Today?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How different are the top 10 movie rankings on Rotten Tomatoes as compared to
    IMDB?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**In the field of natural language processing and machine learning:**'
  prefs: []
  type: TYPE_NORMAL
- en: How similar are two paragraphs once they are converted to tokenized word lists?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to compare the ranked outputs generated by two different learning-to-rank
    / machine-learned ranking (MLR)¹ models?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**In manufacturing/production and logistics:**'
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the sequence of incoming parts to the outgoing parts (FIFO). An ideal
    FIFO sequence looks like the one below. A ***1*** goes in first and a ***1***
    comes out first.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/519d672799c368ca6a79ff634f26e335.png)'
  prefs: []
  type: TYPE_IMG
- en: But this may not always happen in the real world. Maybe a ***1*** goes in first
    but a ***3*** comes out first?
  prefs: []
  type: TYPE_NORMAL
- en: '***Yeah, total chaos can ensue due to this.***'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3c411ebf2cc2c4ba4478210626748f53.png)'
  prefs: []
  type: TYPE_IMG
- en: Then, how are you supposed to measure the quality of the sequences?
  prefs: []
  type: TYPE_NORMAL
- en: '***You need some kind of measure.***'
  prefs: []
  type: TYPE_NORMAL
- en: Are there any requirements such a measure must satisfy?
  prefs: []
  type: TYPE_NORMAL
- en: Requirements for a comparison measure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ideally, a comparison measure should be in the form of a score that indicates
    how similar the rankings are.
  prefs: []
  type: TYPE_NORMAL
- en: Think of the above examples again.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can already get clues about what such a measure should tell us:'
  prefs: []
  type: TYPE_NORMAL
- en: The ranked lists may be indefinite and possibly of different lengths — hence
    the measure***should be able to handle two different list sizes***
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There should be an ability to compare at a chosen intersecting length — which
    means the measure***should handle the intersection length of the lists***
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The top elements have more importance (like in search results, movie order,
    etc.) than the bottom ones — hence there should be a***possibility to give weights
    whenever needed***
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now let’s go look at something that satisfies these conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Rank Biased Overlap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name itself implies, this method is rank-biased.
  prefs: []
  type: TYPE_NORMAL
- en: It means you can prioritize the top few elements in the list with a higher *weight*.
  prefs: []
  type: TYPE_NORMAL
- en: It was proposed in a paper titled — **A Similarity Measure for Infinite Rankings,
    by W. Weber et al²**
  prefs: []
  type: TYPE_NORMAL
- en: You don’t have to go through the entire complexities in the research paper,
    I simplify most of the parts below so we can try a quick implementation in Python.
  prefs: []
  type: TYPE_NORMAL
- en: '***However, fasten your seatbelts and put on your math glasses, as we navigate
    through a few labyrinthine formulae!***'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider S and T as the names of the 2 ranked lists from our title image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d6af78c3e0ca5e959b4c0b0439082065.png)'
  prefs: []
  type: TYPE_IMG
- en: Let’s now define the intersection of these two lists, at a depth (d).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8d5f71a407d3d0ae457d78ef94ff1c99.png)'
  prefs: []
  type: TYPE_IMG
- en: What does this actually mean?
  prefs: []
  type: TYPE_NORMAL
- en: 'It is the list of common elements from S and T, at a given length (called depth
    ***d***). It will be clear from this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/18114de3b6b8447fe6cf7c5ffa49fd05.png)'
  prefs: []
  type: TYPE_IMG
- en: The depth is taken as *at most the length of the smaller list*, otherwise, the
    intersection does not make sense.
  prefs: []
  type: TYPE_NORMAL
- en: The length of this new intersecting list is called the **Overlap**, which in
    this case is 7.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/997b92176df6ac85c999912cfccd4b13.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, we define something called the **Agreement** of the lists. It is simply
    the overlap by the depth.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1a6485faee812b787c6d399bc0af9519.png)'
  prefs: []
  type: TYPE_IMG
- en: The **Average Overlap (AO)** is the average agreement for all the depths of
    the lists, ranging from 1 to an integer k.
  prefs: []
  type: TYPE_NORMAL
- en: When k = 1, the depth ranges from 1 to 1, which means comparing only the first
    element.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/162de8fd4fde359b0b11ac1769ccdbeb.png)'
  prefs: []
  type: TYPE_IMG
- en: Since the elements match, the intersection X is 1 and so is Agreement A.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at k = 2.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/03984ece2d4e5a426d4136f3a25f0ca4.png)'
  prefs: []
  type: TYPE_IMG
- en: In this case, ***d*** ranges from 1 to 2, that is we compare the first 2 elements
    from the lists. The overlap, in this case, is 1 as only the first element is common.
    Hence, the Agreement is 1/2 or 0.5.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we can continue for k = 3.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d23813cc91da60f9dc8e5dea22e52149.png)'
  prefs: []
  type: TYPE_IMG
- en: Well, now that you understand how it works, you can continue the process until
    k = 7.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will get the **Average Overlap (AO)** as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/489a81fbe260bc14194cf33b87c98cf0.png)'
  prefs: []
  type: TYPE_IMG
- en: This can work for any number of elements in the two lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can generalize the above summation as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/fba4278a591d351f3926218ce6f7c743.png)'
  prefs: []
  type: TYPE_IMG
- en: '**This is the foundation for the similarity measures.**'
  prefs: []
  type: TYPE_NORMAL
- en: The Average Overlap is a similarity measure, comparing the two lists at a given
    depth.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a family of such similarity measures (SIM):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b0f39debd3de5ea3d119fae6af0bf412.png)'
  prefs: []
  type: TYPE_IMG
- en: It is a geometric series where the ***d’***thtermis of form 1/(1-**p**) where
    0 < **p** < 1.
  prefs: []
  type: TYPE_NORMAL
- en: Plugging this in the formula above and rearranging the terms, we can get the
    **Rank Based Overlap for the lists S and T as:**
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/477a2f114ddb7881cb13aef4969ca202.png)'
  prefs: []
  type: TYPE_IMG
- en: The variable **p** lies in the range (0, 1) and can be used to determine the
    influence of the first **d** elements on the final similarity score.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a single RBO score, the above formula can be extrapolated. Assuming
    that the **Agreement** till the depth **k** is continued indefinitely among the
    two lists, it can be generalized as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c64fb564aeb99e3b3f0342c65ec1680a.png)'
  prefs: []
  type: TYPE_IMG
- en: The RBO score lies between 0 and 1.
  prefs: []
  type: TYPE_NORMAL
- en: 0 means completely disjoint and 1 means exactly the same ranked lists.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**We will use this formula for the python implementation of an RBO function!**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The paper also shows how we can choose **p** for giving a weightage (Wrbo)
    to the top **d** elements under comparison (I will not get into the derivation
    here):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/aa7d049a61b23affc6753d9177076822.png)'
  prefs: []
  type: TYPE_IMG
- en: '**We will use this formula to implement the weight calculator function.**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Phew,*** that was a lot to process!'
  prefs: []
  type: TYPE_NORMAL
- en: But don’t worry, the formulae look a lot more complicated than they actually
    are — **you will see how simple it is with python.**
  prefs: []
  type: TYPE_NORMAL
- en: So I hope you are still here because the fun part begins now!
  prefs: []
  type: TYPE_NORMAL
- en: A Simple Implementation of Rank Biased Overlap in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I use the above formulae to write a simple implementation of the Rank Biased
    Overlap and a weightage calculator function in python.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand how RBO is derived, it is easy to implement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let’s check on our example lists S and T.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The RBO score of 0.88 means that the lists are nearly 90% similar (which we
    saw also in the average overlap calculation before).
  prefs: []
  type: TYPE_NORMAL
- en: This is in no way a robust python implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '*However, it is clearly good enough to get started!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Now let’s also implement the weight calculator function to help us choose
    p.**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let’s check if it works.
  prefs: []
  type: TYPE_NORMAL
- en: As per the research paper, p of 0.9 gives the top 10 elements a weightage of
    86% in the final similarity score¹.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using our above function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Yay, it works well — it gives 86% as indicated in the paper!
  prefs: []
  type: TYPE_NORMAL
- en: '*We now have our arsenal ready.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Let’s settle the score between you and your friend!**'
  prefs: []
  type: TYPE_NORMAL
- en: Settle Your Fight!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s test it out by creating lists of Harry Potter movies in the order of how
    you and your friend watched them.
  prefs: []
  type: TYPE_NORMAL
- en: And then run your RBO function on it!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**0.78!**'
  prefs: []
  type: TYPE_NORMAL
- en: So, watching the movies out of sequence is definitely different, else the score
    would be 1!
  prefs: []
  type: TYPE_NORMAL
- en: '***But you can go even further.***'
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the first few movies introduce the characters and build the fictional
    world — ***hence it is qualitatively more important that you watch them first
    and in the correct order.***
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use the weight calculator and give the first 4 movies more weightage (86%).
  prefs: []
  type: TYPE_NORMAL
- en: With some trials in the weight calculator function, we get a weight of 86% for
    p = 0.75 and d = 4.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Hence, using p as 0.75 in the RBO function will give the first four movies
    more influence in the ranking comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The resulting comparison score is **0.53!**
  prefs: []
  type: TYPE_NORMAL
- en: This means if you skip the first few movies, or watch them out of sequence,
    it is objectively bad.
  prefs: []
  type: TYPE_NORMAL
- en: '**In fact, your friend’s viewing order is only half as good (53%) as compared
    to yours!**'
  prefs: []
  type: TYPE_NORMAL
- en: '*And now you have the math to prove it!*'
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of RBO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rank-biased overlap is not the only method for comparing lists — the other
    methods are:'
  prefs: []
  type: TYPE_NORMAL
- en: Kendall Tau³
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pearson’s Correlation⁴
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, RBO has several advantages over them:'
  prefs: []
  type: TYPE_NORMAL
- en: RBO is suitable for different lengths of the comparison lists (disjoint or nonsimilar)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a weight measure — you can give more importance to the top or the bottom
    of the comparison
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Due to these benefits, I decided to explain RBO in detail in this post.
  prefs: []
  type: TYPE_NORMAL
- en: However, feel free to look at the other two as I linked in the sources — *they
    are also used in different situations!*
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To summarize, in this post you learned one of the measures for comparing ranked
    lists — the **Rank Biased Overlap.**
  prefs: []
  type: TYPE_NORMAL
- en: You ventured through the mathematics of it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Did a simple implementation in python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Used the functions to do a practical comparison of the movie viewing order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understood its benefits!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now anytime there is a disagreement about comparing movie rankings, viewing
    order, or basically any sequences, ***you can settle it like a pro!***
  prefs: []
  type: TYPE_NORMAL
- en: '*Fin.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sources and notes:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] [Learning to Rank](https://en.wikipedia.org/wiki/Learning_to_rank)'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] [A similarity measure for indefinite rankings — William Webber, Alistair
    Moffat, Justin Zobel](https://dl.acm.org/doi/10.1145/1852102.1852106)'
  prefs: []
  type: TYPE_NORMAL
- en: '[3] [Kendall rank correlation coefficient](https://en.wikipedia.org/wiki/Kendall_rank_correlation_coefficient)'
  prefs: []
  type: TYPE_NORMAL
- en: '[4] [Pearson correlation coefficient](https://en.wikipedia.org/wiki/Pearson_correlation_coefficient)'
  prefs: []
  type: TYPE_NORMAL
- en: Copyrights to images, gifs, and scripts belong to the author.
  prefs: []
  type: TYPE_NORMAL
