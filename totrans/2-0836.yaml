- en: Evolutionary Algorithm — Mutations Explained
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/evolutionary-algorithm-mutations-explained-4a3b5c2d49de](https://towardsdatascience.com/evolutionary-algorithm-mutations-explained-4a3b5c2d49de)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Illustrations with code implementation, applied to TSP as an example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@byjameskoh?source=post_page-----4a3b5c2d49de--------------------------------)[![James
    Koh, PhD](../Images/8e7af8b567cdcf24805754801683b426.png)](https://medium.com/@byjameskoh?source=post_page-----4a3b5c2d49de--------------------------------)[](https://towardsdatascience.com/?source=post_page-----4a3b5c2d49de--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----4a3b5c2d49de--------------------------------)
    [James Koh, PhD](https://medium.com/@byjameskoh?source=post_page-----4a3b5c2d49de--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----4a3b5c2d49de--------------------------------)
    ·8 min read·Nov 7, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1f3a72402d15dee37703769569019834.png)'
  prefs: []
  type: TYPE_IMG
- en: Image created by DALL·E 3 based on the prompt “Draw a science-fiction looking
    image that depicts mutation. Show the ‘before’ on the left, and the ‘after’ on
    the right.”
  prefs: []
  type: TYPE_NORMAL
- en: This is a continuation of [Evolutionary Algorithm — Selections Explained](/evolutionary-algorithm-selections-explained-2515fb8d4287?sk=a4cd1504b6098f82f004db32567c8832).
  prefs: []
  type: TYPE_NORMAL
- en: If you are reading to gain a high-level understanding of recombination and mutations
    in premutation-based representation, this article will be self-sufficient as a
    standalone.
  prefs: []
  type: TYPE_NORMAL
- en: However, to understand the full details of every step of the process, it will
    be helpful to first read the linked article above before continuing here.
  prefs: []
  type: TYPE_NORMAL
- en: Together with the code snippets from the previous article, you will be able
    to solve the famous Travelling Salesman Problem (TSP) on your personal computer.
    More importantly, you will appreciate everything that goes on behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to the same page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the first part, I gave an outline of the Evolutionary Algorithm framework
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/dbe66fc1a36b486b957647fe9fcaf5b8.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: After looking at a couple of terminologies used in EA, we dug into the details
    of initializing the appropriate genotype (in Section 3.1, for <1>) as well as
    roulette wheel and tournament selection (in Section 3.2, for <2>).
  prefs: []
  type: TYPE_NORMAL
- en: We shall continue with Section 3.3 now.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3 — Variation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variations can be unary (involving a single genotype) or binary (involving two
    genotypes). The objective is to end up with new genotype(s) which will, hopefully,
    have a higher fitness than its predecessor(s).
  prefs: []
  type: TYPE_NORMAL
- en: Statistics help us realize this hope. Simply by chance, some genotype would
    be better, while others would be worse. By working hand-in-hand with parent selection
    (section 3.2) and survival selection (section 3.4), the ‘successes’ count for
    much more than ‘failures’.
  prefs: []
  type: TYPE_NORMAL
- en: In sections 3.3.1 and 3.3.2, we focus on variations made to **permutation-based
    genotypes**.
  prefs: []
  type: TYPE_NORMAL
- en: Technically, the recombination process can involve more than two parents, but
    more is not necessarily better [1], and the scope of this article is kept at two
    parents.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.1 — Recombination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This involves two parent genotypes.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike binary representations, which can recombine using single-point or n-points
    crossover, it is less straightforward for permutation representations.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/25c5ed543025bc665d13bd5d52aa0a24.png)'
  prefs: []
  type: TYPE_IMG
- en: The outcome of forcing a cross-over on permutation-based genotypes.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we have a permutation from 0 to 5 inclusive, from two parents (one in
    red, the other in pink). A crossover would result in duplicates of some indices,
    and the absence of others. This cannot be a solution to the TSP.
  prefs: []
  type: TYPE_NORMAL
- en: What we do, instead, is to apply the partial map crossover.
  prefs: []
  type: TYPE_NORMAL
- en: In the example below, the first offspring [0, 1, 3, 5, 2, 4] is obtained from
    the left portion of the first (red) parent, retained as-in, combined with yet-to-be-used
    indices from the second (pink) parent, with the relative order maintained. This
    gives us [0, 1] (from the red) and [3, 5, 2, 4] (from the pink) added together.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2cd36cc77305b66e82d58d77671badf3.png)'
  prefs: []
  type: TYPE_IMG
- en: Process of partial map crossover. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: 'The motivation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The red parent [**0**, **1**, 4, 3, 5, 2] already has a good (or at least decent)
    fitness, hence it was selected as a parent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is possible that keeping a portion of its genotype, and shuffling the remaining,
    can lead to an improvement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We exploit the knowledge that the pink parent [**3**, **5**, 1, **2**, 0, **4**]
    also has a good fitness — It visited 3, before 5, before 2, before 4.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rather than randomly shuffling the tail end of the red parent randomly, we scramble
    it to follow the order of visit by the pink parent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The same is true when the two parents are switched. Hence, two offspring are
    obtained.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the cutoff could happen anywhere along the genotype with equal probability.
    If the cutoff was performed exclusively at the middle, we lose the opportunity
    for a diverse set of offspring in the subsequent generation. No one can say for
    certain that the first half is ideal and should be kept — it could well be just
    the first quarter, or perhaps the first three-quarters. Hence, all options should
    be kept on the table, and the work is left to statistics.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.2 — Mutation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Still in the ‘**Variation**’ aspects of Evolutionary Algorithms, we move on
    to changes which are applicable to individual genotypes.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0e6a3ee425f7ac3fca12d699ee620d30.png)'
  prefs: []
  type: TYPE_IMG
- en: Possible mutations for a permutation-based genotype.
  prefs: []
  type: TYPE_NORMAL
- en: If a genotype comprises a permutation sequence, the changes to be applied has
    to involve some sort of re-ordering. It is not feasible to perform a bit flip,
    or to increase/decrease a single number.
  prefs: []
  type: TYPE_NORMAL
- en: One approach is to randomly select a number (for example, ‘2’) and shift it
    to the beginning or the end of the sequence. Another approach is to randomly select
    two numbers and exchange their positions with each other.
  prefs: []
  type: TYPE_NORMAL
- en: The idea here is to make minimal changes to a single genotype, with the hope
    of making an already good solution even better. Such variations would be especially
    helpful in scenarios where the solution is very good for most parts except for
    a point that is out of place.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s the code for sections 3.3.1 (Recombination) and 3.3.2 (Mutation).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 3.4 — Survival selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After discussing extensively on parent selection and variation, let’s move on
    to the third pillar of EA, which involves selecting which individuals in the population
    make it to the next population.
  prefs: []
  type: TYPE_NORMAL
- en: The first approach is to put all parents and offspring together, and select
    the fittest individuals to populate the next generation. The issue here is that
    we are ‘diluting’ the evolution effects. After going through all the trouble of
    creating offspring from parent selection + recombination + mutation, a substantial
    portion of those ends up being discarded. There’s some elements of ‘*two steps
    forward and one step back*’ in this.
  prefs: []
  type: TYPE_NORMAL
- en: The second approach is to (somewhat) mimic nature. All parents will ‘die’ and
    disappear from the population, and the next generation is entirely populated by
    the offspring. The problem here is that the best offspring is not necessarily
    better than the best parent — and removing all parents may cause us to be further
    away from the ideal solution.
  prefs: []
  type: TYPE_NORMAL
- en: As such, the middle ground is usually taken. We select the best individual(s)
    from the parents. We also mutate copies of them, with the hope that some perturbations
    further improve the solution. Then, we generate just enough offspring to full
    up the remaining places of the next population, without discarding any.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, in the `##... elitism; keep best individuals and variants of
    them ...` component in section 3.3, we can do something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 3.5 — Termination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps your company has tasked you to apply EA and solve an industry problem,
    within a given budget. Or, perhaps you know the optimal objective value (but not
    the solution which gives that).
  prefs: []
  type: TYPE_NORMAL
- en: In such cases, you may want to perform early termination once the results are
    good enough.
  prefs: []
  type: TYPE_NORMAL
- en: If there’s no specific number to look for, and we are uncertain about what is
    ‘good enough’ in the first place, one approach is to stop the iteration after
    the improvement across a certain number of generations is smaller than some threshold.
  prefs: []
  type: TYPE_NORMAL
- en: If resources are not an issue, then you should be concerned about terminating
    *too early* rather than *too late.* It doesn’t hurt to go on with additional iterations,
    and run the evolution for more generations. Like in deep learning, we would keep
    the solution corresponding to the best iteration, and not the last iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Getting The Results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 4.1 Representing the TSP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s build a class for the Travelling Salesman problem, to streamline the implementation
    process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 4.2 Train and observe
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Putting together the code snippets above into a single `Evolutionary` class,
    the following can then be applied to find a solution to the TSP.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you’ve saved the intermediate results, you can simply put the screenshot
    images together to form a gif using my code which I shared [here](https://medium.com/towards-data-science/a-cornerstone-of-rl-td-%CE%BB-and-3-big-names-2e547b37c05).
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You now have the knowledge to solve an np-hard problem using
    evolutionary algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: The same gif shown at the beginning of this article. This is the result of the
    codes shared above.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this article, you learnt what makes Evolutionary Algorithm ticks, and how
    each component functions. Apart from the high level concepts, we dived deeply
    into the implementations, supported by visualization, codes, and tangible numbers.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[1] A. E. Eiben, P. E. Raue, and Z. Ruttkay, [Genetic algorithms with multi-parent
    recombination](https://link.springer.com/chapter/10.1007/3-540-58484-6_252) (1994),
    In International conference on parallel problem solving from nature'
  prefs: []
  type: TYPE_NORMAL
