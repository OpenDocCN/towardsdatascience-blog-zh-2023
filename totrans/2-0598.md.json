["```py\nimport numpy as np\nfrom mpl_toolkits.mplot3d import Axes3D\nimport matplotlib.pyplot as plt\n\n# Create a function to compute the surface\ndef f(theta):\n  x = theta[0]\n  y = theta[1]\n  return x**2 - y**2\n\n# Make a grid of points for plotting\nx, y = np.mgrid[-1:1:81j, -1:1:81j]\n```", "```py\n# Create a figure with axes in 3d projection\nfig1 = plt.figure(figsize = (4,8), dpi = 300)\nax1 = fig1.add_subplot(111, projection='3d')\n\nplot_args = {'rstride': 2, 'cstride': 2, 'cmap':\"coolwarm\",\n             'linewidth': 0.01, 'antialiased': False,\n             'vmin': -1, 'vmax': 1, 'edgecolors':'k'}\n\nax1.plot_surface(x, y, f([x,y]), **plot_args)\n\nax1.view_init(azim= 120, elev= 37)\nax1.set_xlabel('x')\nax1.set_ylabel('y')\n\nplt.plot()\n```", "```py\n# Define a function to compute the gradient\ndef grad_f(theta):\n    returnValue = np.array([0.,0.])\n    x = theta[0]\n    y = theta[1]\n    returnValue[0] += 2*x\n    returnValue[1] += - 2*y\n    return returnValue\n\n# Gradient descent routine\ndef gradient_descent(x_init, y_init, step_size, n_iters):\n  eta = step_size\n\n  theta = np.tile([x_init, y_init], (n_iters,1) )\n  g_t = np.zeros((n_iters,2))\n  z = np.tile([f(theta[0])], n_iters )\n\n  for k in range (1, n_iters):\n\n      g_t[k] = grad_f(theta[k-1])\n      theta[k] = theta[k-1] - eta * g_t[k]\n      z[k] = f(theta[k])\n\n  # Setting up Data Set for Animation\n  dataSet = np.stack((theta[:,0], theta[:,1], z), 1)\n\n  return dataSet\n```", "```py\nn_iters = 200\nstep_size = 0.0\n\nx_sym, y_sym = 1, 0\nx_off, y_off = 1, 0.25\n\ndata_sym = gradient_descent(x_sym, y_sym, step_size , n_iters)\ndata_off = gradient_descent(x_off, y_off, step_size , n_iters)\n```", "```py\nfig2, ax2 = plt.subplots(1,3, figsize = (6,2), dpi = 300)\n\nax2[0].plot(data_sym[:,0])\nax2[0].plot(data_off[:,0])\nax2[0].set_xlabel('Iteration')\nax2[0].set_ylabel('x')\n\nax2[1].plot(data_sym[:,1])\nax2[1].plot(data_off[:,1])\nax2[1].set_xlabel('Iteration')\nax2[1].set_ylabel('y')\nax2[1].set_ylim(0, 10)\n\nax2[2].plot(data_sym[:,2], label = 'Symmetry')\nax2[2].plot(data_off[:,2], label = 'Offset')\nax2[2].set_xlabel('Iteration')\nax2[2].set_ylabel('z')\nax2[2].set_ylim(-5, 2)\n\nhandles, labels = ax2[2].get_legend_handles_labels()\nfig2.legend(handles, labels, loc=(0.3, 0.75), fancybox = False, \n            frameon = False, ncols = 2)\nfig2.suptitle('Evolution of coordinates during gradient descent', y = 0.99)\n\nfig2.tight_layout()\n```", "```py\nnewax = fig1.add_axes(ax1.get_position(), projection='3d',\n                     xlim = ax1.get_xlim(),\n                     ylim = ax1.get_ylim(),\n                     zlim = ax1.get_zlim(),\n                     facecolor = 'none',)\nnewax.view_init(azim= 120, elev= 37)\nnewax.set_zorder(1)\nax1.set_zorder(0)\n\nnewax.plot3D(data_sym[:,0], data_sym[:, 1], data_sym[:, 2], \n             c='blue', alpha = 0.7)\nnewax.plot3D(data_off[:, 0], data_off[:, 1], data_off[:, 2],\n             c='red', alpha = 0.7)\n\nnewax.plot3D(data_sym[0, 0], data_sym[0, 1], data_sym[0, 2],\n               ms = 2.5, c='black', marker='o')\nnewax.plot3D(data_off[0, 0], data_off[0, 1], data_off[0, 2],\n               ms = 2.5, c='black', marker='s')\nnewax.set_axis_off()\nsq = u'■'\ncir = u'●'\nax1.text2D(0.05, 0.95, f'Initilization\\n'\\\n                      f'{sq}: x = {x_off}, y = {y_off}\\n'\\\n                      f'{cir}: x ={x_sym}, y = {y_sym}', transform=ax1.transAxes)\nfig1\n```", "```py\nfrom matplotlib import animation\n\n# Define Aimation function\ndef animate_func(num):\n  ... # Plot trajectories, index arrays with incremental num\n\n# Plotting the Animation\nfig = plt.figure()\nax = plt.axes(projection='3d')\nline_ani = animation.FuncAnimation(fig, animate_func, interval=100,   \n                                   frames=numDataPoints)\nplt.show()\n```", "```py\ndef descent_animation(num):\n    # Clear the axes where we are plotting the tracjectories\n    newax.clear()\n\n    # Manually adjust the order of the axes\n    newax.set_zorder(1)\n    ax.set_zorder(0)\n\n    # Hide the axes in the front plane\n    newax.set_axis_off()\n\n    # Plot new frame of trajectory line for the symmetry case\n    newax.plot3D(data_sym[:num+1, 0], data_sym[:num+1, 1],\n                 data_sym[:num+1, 2], c='blue', alpha = 0.7)\n    # Updating Point Location\n    newax.scatter(data_sym[num, 0], data_sym[num, 1], data_sym[num, 2],\n               s = 10, c='blue', marker='o', edgecolor = 'k', linewidth = 0.5)\n    # Adding Constant Origin\n    newax.plot3D(data_sym[0, 0], data_sym[0, 1], data_sym[0, 2],\n               ms = 2.5, c='black', marker='o')\n\n    # Plot new frame of trajectory line for the offset case\n    newax.plot3D(data_off[:num+1, 0], data_off[:num+1, 1],\n                 data_off[:num+1, 2], c='red', alpha = 0.7)\n    # Updating Point Location\n    newax.scatter(data_off[num, 0], data_off[num, 1], data_off[num, 2],\n               s = 10, c='red', marker='o', edgecolor = 'k', linewidth = 0.5)\n    # Adding Constant Origin\n    newax.plot3D(data_off[0, 0], data_off[0, 1], data_off[0, 2],\n               ms = 2.5, c='black', marker='s')\n\n    # Setting Axes Limits and view angles\n    newax.set_xlim3d([-1, 1])\n    newax.set_ylim3d([-1, 1])\n    newax.set_zlim3d([-1, 1])\n    newax.view_init(azim= 120, elev= 37)\n```", "```py\nfig = plt.figure(figsize = (4, 3), dpi = 300)\nax = fig.add_subplot(111, projection='3d')\n\nplot_args = {'rstride': 2, 'cstride': 2, 'cmap':\"coolwarm\",\n            'linewidth': 0.01, 'antialiased': False,\n            'vmin': -1, 'vmax': 1, 'edgecolors':'k'}\nx, y = np.mgrid[-1:1:81j, -1:1:81j]\n\n# Plot surface\nax.plot_surface(x, y, f([x,y]), **plot_args)\nax.view_init(azim= 120, elev= 37)\nax.set_xlim3d([-1, 1])\nax.set_ylim3d([-1, 1])\nax.set_zlim3d([-1, 1])\n\nax.w_xaxis.set_pane_color((1.0, 1.0, 1.0, 0.0))\nax.w_yaxis.set_pane_color((1.0, 1.0, 1.0, 0.0))\nax.w_zaxis.set_pane_color((1.0, 1.0, 1.0, 0.0))\n\n# Add second pair of axes\nnewax = fig.add_axes(ax.get_position(), projection='3d',\n                    xlim = ax.get_xlim(),\n                    ylim = ax.get_ylim(),\n                    zlim = ax.get_zlim(),\n                    facecolor = 'none',)\nnewax.view_init(azim= 120, elev= 37)\n\n# Manually adjust the order of the axes\nnewax.set_zorder(1)\nax.set_zorder(0)\n\n# Hide axes in the front plane\nnewax.set_axis_off()\n\n# Add some text to distinguish the two initialization points\nsq = u'■'\ncir = u'●'\nax.text2D(0.05, 0.95, f'Initilization\\n'\\\n                      f'{sq}: x = {x_off}, y = {y_off}\\n'\\\n                      f'{cir}: x ={x_sym}, y = {y_sym}', \n          transform=ax.transAxes,\n          fontsize = 8)\n\n# Plotting the Animation\nline_ani = animation.FuncAnimation(fig, descent_animation, interval=100,\n                                   frames= n_iters + 1)\nplt.show() \n```", "```py\nfilename = \"gradient_func.gif\"\nwritergif = animation.PillowWriter(fps=500)\nline_ani.save(filename, writer=writergif)\n```", "```py\nfrom IPython.display import Image\nImage(open(filename,'rb').read())\n```"]