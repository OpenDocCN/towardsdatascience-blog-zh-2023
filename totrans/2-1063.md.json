["```py\npeople = ['Ann', 'Betty', 'Charlotte', 'Edith', 'Felicia', 'Georgia', 'Helen']\npeople_met = {'Ann': ['Betty', 'Charlotte', 'Felicia', 'Georgia'],\n              'Betty': ['Ann', 'Charlotte', 'Edith', 'Felicia', 'Helen'],\n              'Charlotte': ['Ann', 'Betty', 'Edith'],\n              'Edith': ['Betty', 'Charlotte', 'Felicia'],\n              'Felicia': ['Ann', 'Betty', 'Edith', 'Helen'],\n              'Georgia': ['Ann', 'Helen'],\n              'Helen': ['Betty', 'Felicia', 'Georgia']}\n\ndef create_graph(plot_graph=False):\n    \"\"\"\n    Generate graph based on interrogation, and draw it it plot_graph = True\n    :param plot_graph: True if graph is plotted\n    :return: Graph\n    \"\"\"\n    G = nx.Graph()\n    for person in people:\n        G.add_node(person)\n    for p1 in people_met.keys():\n        for p2 in people_met[p1]:\n            G.add_edge(p1, p2)\n    if plot_graph:\n        nx.draw_spectral(G, node_size=500, node_color=['red', 'green', 'pink', 'brown', 'yellow', 'orange', 'skyblue'],\n                         with_labels=True)\n        plt.show()\n    return G\n```", "```py\ndef check_cycles(G):\n    \"\"\"\n    Print all the chordless cycles with length = 4\n    :param G: Input graph\n    \"\"\"\n    list_cycles = list(sorted(nx.simple_cycles(G.to_directed())))\n    for l in list_cycles:\n        if len(l) == 4:\n            H = G.subgraph(l)\n            if not nx.is_chordal(H):\n                print(l, len(l))\n\nG = create_graph(False)\ncheck_cycles(G)\n```", "```py\nfrom ortools.sat.python import cp_model\nimport pandas as pd\nfrom matplotlib import pyplot as plt\n\npeople = ['Ann', 'Betty', 'Charlotte', 'Edith', 'Felicia', 'Georgia', 'Helen']\npeople_met = {'Ann': ['Betty', 'Charlotte', 'Felicia', 'Georgia'],\n           'Betty': ['Ann', 'Charlotte', 'Edith', 'Felicia', 'Helen'],\n           'Charlotte': ['Ann', 'Betty', 'Edith'],\n           'Edith': ['Betty', 'Charlotte', 'Felicia'],\n           'Felicia': ['Ann', 'Betty', 'Edith', 'Helen'],\n           'Georgia': ['Ann', 'Helen'],\n           'Helen': ['Betty', 'Felicia', 'Georgia']}\n\nmodel = cp_model.CpModel()\nnum_vals = 1000\n\n# Arrival time of person i in the castle\ns = {i: model.NewIntVar(0, num_vals, 'start_' + i) for i in people}\n# Duration of the visit of person i in the castle\ne = {i: model.NewIntVar(0, num_vals, 'end_' + i) for i in people}\n# Departure time of person i from the castle\nd = {i: model.NewIntVar(0, num_vals, 'duration_' + i) for i in people}\n# Logic variable that is True (1) is person cannot be included in the visit schedule. False otherwise\nv = {i: model.NewBoolVar('v_' + i) for i in people}\n```", "```py\n# Auxiliary Boolean variables\nb1 = {(p, p2): model.NewBoolVar(name='b1_' + p + \"_\" + p2) for p in people for p2 in people if p != p2}\nb2 = {(p, p2): model.NewBoolVar(name='b2_' + p + \"_\" + p2) for p in people for p2 in people if p != p2}\nb3 = {(p, p2): model.NewBoolVar(name='b3_' + p + \"_\" + p2) for p in people for p2 in people if p != p2}\nb4 = {(p, p2): model.NewBoolVar(name='b4_' + p + \"_\" + p2) for p in people for p2 in people if p != p2}\n\nfor i in people:\n    for j in people:\n        if i != j:\n            if j in people_met[i]:\n                # Overlap condition 1\n                model.Add(e[i] > s[j]).OnlyEnforceIf(b1[(i, j)])\n                model.Add(s[i] < e[j]).OnlyEnforceIf(b1[(i, j)])\n                # Overlap condition 2\n                model.Add(s[i] < e[j]).OnlyEnforceIf(b2[(i, j)])\n                model.Add(s[i] > s[j]).OnlyEnforceIf(b2[(i, j)])\n                # At least one of the overlap conditions\n                model.AddAtLeastOne([b1[(i, j)], b2[(i, j)], v[i], v[j]])\n            else:\n                # No overlap condition 1\n                model.Add(e[i] <= s[j]).OnlyEnforceIf(b3[(i, j)])\n                # No overlap condition 2\n                model.Add(s[i] >= e[j]).OnlyEnforceIf(b4[(i, j)])\n                # At least one of the non overlap conditions\n                model.AddAtLeastOne([b3[(i, j)], b4[(i, j)], v[i], v[j]])\n```", "```py\n# Duration of person (d_i) is 0 is value v_i is True. If v_i is False, d_i must be strictly positive.\nfor i in people:\n    model.Add(d[i] == 0).OnlyEnforceIf(v[i])\n    model.Add(d[i] > 0).OnlyEnforceIf(v[i].Not())\n```", "```py\n# Departure time is equal to arrival time plus duration\nfor i in people:\n    model.Add(s[i] + d[i] == e[i])\n```", "```py\n# Objective function is maximizing the number of people included - minimizing the sum of variable v_i.\nvar_obj = 0\nfor i in people:\n    var_obj += v[i]\nmodel.Minimize(var_obj)Running the model we can plot the gantt chart generated:\n```", "```py\n solver = cp_model.CpSolver()\nstatus = solver.Solve(model)\n\nif status == cp_model.OPTIMAL:\n   for p in people:\n      print(p, solver.Value(s[p]), solver.Value(e[p]), solver.Value(d[p]))\ngantt_result_dict = {'Person': [], 'Start': [], 'End': [], 'Duration': []}\nfor i in people:\n   gantt_result_dict['Person'].append(i)\n   gantt_result_dict['Start'].append(solver.Value(s[i]))\n   gantt_result_dict['End'].append(solver.Value(e[i]))\n   gantt_result_dict['Duration'].append(solver.Value(d[i]))\ngantt_result_df = pd.DataFrame.from_dict(gantt_result_dict)\nprint(gantt_result_df)\nfig, ax = plt.subplots(1, figsize=(16, 6))\nax.barh(gantt_result_df['Person'], gantt_result_df['Duration'], left=gantt_result_df['Start'])\nplt.grid()\nplt.show()\n```", "```py\nimport pandas as pd\nfrom matplotlib import pyplot as plt\nfrom ortools.linear_solver import pywraplp\n\npeople = ['Ann', 'Betty', 'Charlotte', 'Edith', 'Felicia', 'Georgia', 'Helen']\npeople_met = {'Ann': ['Betty', 'Charlotte', 'Felicia', 'Georgia'],\n              'Betty': ['Ann', 'Charlotte', 'Edith', 'Felicia', 'Helen'],\n              'Charlotte': ['Ann', 'Betty', 'Edith'],\n              'Edith': ['Betty', 'Charlotte', 'Felicia'],\n              'Felicia': ['Ann', 'Betty', 'Edith', 'Helen'],\n              'Georgia': ['Ann', 'Helen'],\n              'Helen': ['Betty', 'Felicia', 'Georgia']}\n\nperiods = 6\nT = [p for p in range(0, periods)]\nsolver = pywraplp.Solver('puzzle', pywraplp.Solver.CBC_MIXED_INTEGER_PROGRAMMING)\n\n# 1 if person i is included. 0 otherwise\ny = {(i): solver.IntVar(0, 1, \"y_{0}\".format(i)) for i in people}\n\n# 1 if person i is in the castle at t. 0 otherwise\nx = {(i, t): solver.IntVar(0, 1, \"x_{0}_{1}\".format(i, t)) for i in people for t in T}\n\n# 1 if person i and j are in the castle simultaneously at t. 0 otherwise\nz = {(i, j, t): solver.IntVar(0, 1, \"z_{0}_{1}_{2}\".format(i, j, t))\nfor i in people for j in people for t in T if i != j}\n\n# 1 if person i arrives in the castle at t. 0 otherwise\nw = {(i, t): solver.IntVar(0, 1, \"w_{0}_{1}\".format(i, t)) for i in people for t in range(0, periods - 1)}\n```", "```py\n# If a person is included she must have been in the castle at least once\nc1 = {i: solver.Add(solver.Sum(x[(i, t)] for t in T) >= y[i]) for i in people}\n\n# If a person is included she must have been in the castle simultaneously with other people she met at least once\nc2 = {(i, j): solver.Add(solver.Sum(z[(i, j, t)] for t in T) >= y[i])\n      for i in people for j in people_met[i]}\n\n# Two people were simultaneously at t in the castle only if they are both there at t\nc3 = {(i, j, t): solver.Add((z[(i, j, t)] >= x[(i, t)] + x[(j, t)] - 1))\n      for i in people for j in people for t in T if i != j}\n\n# Two people were simultaneously at t in the castle only if they are both there at t and if they are included\nc4 = {(i, j, t): solver.Add(\n    (x[(i, t)] + x[(j, t)] + periods * (1 - z[(i, j, t)]) >= y[i] + y[j]))\n      for i in people for j in people for t in T if i != j}\n\n# Two people that did not meet cannot be in the castle simultaneously\nc5 = {(i, j): solver.Add(solver.Sum(z[(i, j, t)] for t in T) == 0)\n      for i in people for j in people if i != j and j not in people_met[i]}\n\n# Defines the arrival time of person\nc6 = {(i, t): solver.Add((w[(i, t)] >= x[(i, t + 1)] - x[(i, t)]))\n      for i in people for t in range(0, periods - 1)}\n\n# Person cannot be in the castle in period 0 and period T\nc7 = {(i): solver.Add(x[(i, 0)] + x[(i, periods - 1)] == 0)\n      for i in people}\n\n# If a person was included it has just one arrival time\nc8 = {(i): solver.Add(solver.Sum(w[(i, t)] for t in range(0, periods - 1)) == y[i])\n      for i in people}\n```", "```py\nnumber_of_people = solver.Sum(y[i] for i in people)\nsolver.Maximize(number_of_people)\n```", "```py\ngantt_result_dict = {'Person': [], 'Start': [], 'End': [], 'Duration': []}\nduration = {i: 0 for i in people}\nstart = {i: 0 for i in people}\nend = {i: 0 for i in people}\nfor i in people:\n    for t in T:\n        if x[(i, t)].solution_value() >= 0.1:\n            duration[i] += 1\n            if x[(i, t - 1)].solution_value() == 0:\n                start[i] = t\n    end[i] = start[i] + duration[i]\n    gantt_result_dict['Person'].append(i)\n    gantt_result_dict['Start'].append(start[i])\n    gantt_result_dict['End'].append(end[i])\n    gantt_result_dict['Duration'].append(duration[i])\ngantt_result_df = pd.DataFrame.from_dict(gantt_result_dict)\nprint(gantt_result_df)\nfig, ax = plt.subplots(1, figsize=(16, 6))\nax.barh(gantt_result_df['Person'], gantt_result_df['Duration'], left=gantt_result_df['Start'])\nplt.grid()\nplt.show()\n```"]