["```py\nclass Tableau:\n\n    def __init__(self, dim, values):\n        self.dim, self.p = dim, dim\n        self.values = copy.deepcopy(values)\n        self.count = CountTableau(dim, values)\n\n    def __len__(self):\n        return self.count.sum()\n\n    def __bool__(self):\n        return (len(self) > 0)\n\n    def __getitem__(self, key):\n        \"\"\" Returns p-cells if dim(key) < self.dim \"\"\"\n        key = [key] if isinstance(key, int) else list(key)\n        if len(key) > self.dim:\n            key = key[:self.dim]\n        dim_out = self.dim - len(key)\n        while len(key) < self.dim:\n            key.append(slice(None, None, None))\n        out = self.values.copy()\n        while key:\n            out = out[key.pop(0)]\n        if dim_out == 0:\n            return out \n        return Tableau(dim_out, out)\n\n    def __setitem__(self, key, value):\n        key = [key] if isinstance(key, int) else list(key)\n        if isinstance(value, Tableau):\n            assert len(key) + value.dim == self.dim \n            value = value.values\n        def recursive_set(A, key, value):\n            i = key.pop(0)\n            if key:\n                recursive_set(A[i], key, value)\n            else:\n                A[i] = value\n        recursive_set(self.values, key, value)\n\n    def __contains__(self, loc):\n        try:\n            self[loc]\n            return True \n        except:\n            return False\n\n    def __call__(self, p):\n        self.p = p \n        return self\n\n    def __iter__(self):\n        \"\"\" for i, x in T(p):  will iterate i in I_p, and return p-cells. \"\"\"\n        def recursive_loop(A, dim, loc=None):\n            if loc is None:\n                loc = [0] * self.p\n            if dim < self.p-1:\n                for i, x in enumerate(A):\n                    loc[dim] = i\n                    yield from recursive_loop(x, dim+1, loc)\n            else:\n                for i, x in enumerate(A):\n                    loc[dim] = i \n                    yield loc \n        for index in recursive_loop(self.values, 0):\n            yield tuple(index), self[index]\n        self.p = self.dim \n\n    def __add__(self, other):\n        \"\"\" Self may be higher dimension than other \"\"\"\n        new = Tableau(self.dim, copy.deepcopy(self.values))\n        if np.isscalar(other):\n            for i, _ in new:\n                new[i] += other \n            return new \n        assert other.dim <= self.dim\n        for i, x in other:\n            if i in new:\n                new[i] = new[i] + x\n        return new \n\n    def __sub__(self, other):\n        new = Tableau(self.dim, copy.deepcopy(self.values))\n        if np.isscalar(other):\n            for i, _ in new:\n                new[i] -= other \n            return new \n        assert other.dim <= self.dim\n\n        for i, x in other:\n            if i in new:\n                new[i] -= x \n        return new         \n\n    def __mul__(self, other):\n        \"\"\" Self may be lower dimension than other \"\"\"\n        if np.isscalar(other):\n            new = Tableau(self.dim, copy.deepcopy(self.values))\n            for i, _ in new:\n                new[i] *= other \n            return new \n\n        assert self.dim <= other.dim \n        new = Tableau(other.dim, copy.deepcopy(other.values))\n        for i, x in self:\n            new[i] *= x \n        return new \n\n    def __truediv__(self, other):\n        if np.isscalar(other):\n            new = Tableau(self.dim, copy.deepcopy(self.values))\n            for i, _ in new:\n                new[i] /= other \n            return new         \n        assert self.dim == other.dim \n        new = Tableau(self.dim, copy.deepcopy(self.values))\n        for i, x in other:\n            new[i] /= x\n        return new        \n\n    def __pow__(self, n):\n        \"\"\" Defines Square of Tableau \"\"\"\n        assert n==2 \n        return self * self\n\n    def getPShell(self, p):\n        shell = Tableau(p, copy.deepcopy(self.values))\n        for i, _ in self(p):\n            shell[i] = None \n        return shell\n\n    def sum(self, p=0):\n        if p == 0:\n            total = 0\n            for _, x in self:\n                total += x \n            return total \n        S = self.getPShell(p)\n        for i, x in self(p):\n            S[i] = x.sum()\n            if not isinstance(self, CountTableau) and not any(self.count[i].values):\n                S.count[i] = 0\n        return S \n\n    def mean(self, p=0, weights=None):\n        if weights is None:\n            return self.sum(p) / self.count.sum(p)\n        weights /= weights.sum()\n        Tw = weights * self\n        return Tw.sum(p)\n\n    def sumSquares(self, p=0, weights=None):\n        if weights is None:\n            S = (self - self.mean(p))**2 \n        else:\n            S = weights * (self - self.mean(p, weights=weights))**2\n        return S.sum(p)\n\nclass CountTableau(Tableau):\n\n    def __init__(self, dim, values):\n        self.dim, self.p = dim, dim\n        self.values = copy.deepcopy(values)\n        for i, _ in self:\n            self[i] = 1\n\nclass Mask(Tableau):\n\n    def __init__(self, dim, values):\n        super().__init__(dim, values)\n        for _, x in self:\n            assert x in (0, 1)\n\n    def __len__(self):\n        return self.sum() \n\n    def __mul__(self, other):\n        new = super().__mul__(other)\n        new.count = super().__mul__(new.count)\n        return new \n\n    def __neg__(self):\n        \"\"\" Use (-M) for logical negation of M \"\"\"\n        new = Mask(self.dim, copy.deepcopy(self.values))\n        return new * (-1) + 1\n```", "```py\ndef genx(n, maxval=100):\n    return list(np.random.randint(0, maxval+1, size=n))\n\nA = [[genx(2), genx(3), genx(4), genx(2), genx(2)], [genx(3), genx(4)], [genx(3), genx(2), genx(3)], [genx(5), genx(1)], [genx(2),genx(4),genx(3),genx(2)]]\nT = Tableau(3, A)\n\nfor i, x in T(2):\n    print(i, x.values)\n\n# Outputs (contains all 2-cells of the tableau; indexed over I_2)\n# (0, 0) [31, 75]\n# (0, 1) [43, 57, 23]\n# (0, 2) [47, 53, 38, 82]\n# (0, 3) [69, 87]\n# (0, 4) [65, 23]\n# (1, 0) [42, 49, 8]\n# (1, 1) [61, 13, 69, 37]\n# (2, 0) [88, 84, 45]\n# (2, 1) [21, 64]\n# (2, 2) [83, 21, 83]\n# (3, 0) [72, 42, 54, 83, 43]\n# (3, 1) [3]\n# (4, 0) [14, 55]\n# (4, 1) [87, 49, 93, 65]\n# (4, 2) [94, 95, 15]\n# (4, 3) [27, 71]\n\nT[4].values # same as T[4, :, :].values; returns a 2-tableau\n# [[14, 55], [87, 49, 93, 65], [94, 95, 15], [27, 71]]\n\nT[4, 1].values # returns a 1-tableau\n# [87, 49, 93, 65]\n\nT[4,1,3] # returns a scalar\n# 65 \n\nB = [[genx(2,1), genx(3,1), genx(4,1), genx(2,1), genx(2,1)], [genx(3,1), genx(4,1)], [genx(3,1), genx(2,1), genx(3,1)], [genx(5,1), genx(1,1)], [genx(2,1),genx(4,1),genx(3,1),genx(2,1)]]\nM = Mask(3, B)\n\nMT = M * T\nlen(T), len(M), M.sum(), len(MT)\n# (45, 25, 25, 25)\n\nMT.mean() # average of treatment values only\n# 52.16\nMT.sumSquares(1).values # sum-of-squares at the 1st level\n# [19443.3125, 6934.4375, 9796.0, 6443.0, 30566.75]\n\nMT[4].values  # compare with T[4].values, above; this is randomly masked\n# [[0, 0], [87, 49, 0, 0], [0, 95, 15], [0, 0]]\n```", "```py\nn_strata = 5\npi = 0.3\nshape = np.random.randint(400,500, size=n_strata)\nn_t = (shape * pi).astype(int)\nn_c = shape - n_t\nA = [ list(np.random.normal(50+10*i, 10, size=shape[i]))  for i in range(n_strata)]\nZ = [ list(np.random.choice([1]*n_t[i] + [0]*n_c[i], size=shape[i], replace=False )) for i in range(n_strata)]\n\nY = Tableau(2, A)\nZ = Mask(2, Z)\n\nY = Y + (Z * 10)  # add a treatment effect of 10 to treated units\n\nYt = Z * Y \nYc = (-Z) * Y\n\ntau_hat = Yt.mean() - Yc.mean()\nprint(tau_hat)\n# 9.74\n\ndof = len(Y) - 2 * n_strata\n\nMSW = (Yt.sumSquares(1).sum() + Yc.sumSquares(1).sum()) / dof\nT = tau_hat / sqrt(MSW * (1/len(Yt) + 1/len(Yc)))\n\nT_crit = scipy.stats.t.isf(0.05, dof)\nprint(T, T_crit, T > T_crit)\n#  2.71, 1.65, True\n```", "```py\nn_cluster = 10\npi = 0.5\nc_t = int(pi * n_cluster)\nc_c = n_cluster - c_t\nshape = np.random.randint(40,50, size=n_cluster)\n\nA = [ list(np.random.normal(50+1*i, 10, size=shape[i]))  for i in range(n_cluster)]\nZ = list(np.random.choice([1]*c_t + [0]*c_c, size=n_cluster, replace=False ))\n\nY = Tableau(2, A)\nZ = Mask(1, Z)\n\nY = Y + (Z * 10)  # add a treatment effect of 10 to treated units\n\nYt = Z * Y \nYc = (-Z) * Y\n\ntau_hat = n_cluster / len(Y) * ( (Yt.sum(1)).mean() - (Yc.sum(1)).mean() )\nprint(tau_hat)\n# 15.975\n```", "```py\nn_strata = 3 \nc_shape = [4, 8, 12]\ncw = Tableau(1, c_shape)\na_t = [2, 4, 6]\n\nA = [ [  list( np.random.normal(50 + 10 * i, size=np.random.randint(100,200)) )  for j in range(c_shape[i])  ]    for i in range(n_strata)]\nZ = [  list( np.random.choice([1]*a_t[i] + [0]*a_t[i], size=c_shape[i], replace=False)    )  for i in range(n_strata)]\n\nY = Tableau(3, A)\nZ = Mask(2, Z)\n\nY = Y + (Z * 10)\n\nYt = Z * Y \nYc = (-Z) * Y\n\ntau_hat = sum(c_shape) / len(Y) * (Yt.sum(2).mean(1) - Yc.sum(2).mean(1)).mean(weights=cw) \nprint(tau_hat)\n#16.64\n```"]