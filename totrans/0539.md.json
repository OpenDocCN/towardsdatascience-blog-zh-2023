["```py\nfrom functools import lru_cache\n\n@lru_cache\ndef fibonacci(n: int) -> int:\n    return n if n < 2 else fibonacci(n - 1) + fibonacci(n - 2)\n```", "```py\n# 1\\. Maximum cache size\n@lru_cache(maxsize=1024)\ndef fibonacci(n: int) -> int:\n    return n if n < 2 else fibonacci(n - 1) + fibonacci(n - 2)\n\n# 2\\. Unlimited cache size\n@lru_cache(maxsize=None)\ndef fibonacci(n: int) -> int:\n    return n if n < 2 else fibonacci(n - 1) + fibonacci(n - 2)\n\nfrom functools import cache\n\n@cache\ndef fibonacci(n: int) -> int:\n    return n if n < 2 else fibonacci(n - 1) + fibonacci(n - 2)\n\n# 3\\. Retrieve caching information\nfibonacci.cache_info()\n\n# 4\\. Add expiration time (requires pip install cachetools)\nfrom cachetools import cached, TTLCache\n\n@cached(cache=TTLCache(maxsize=100, ttl=60*60*5), info=True)\ndef fibonacci(n: int) -> int:\n    return n if n < 2 else fibonacci(n - 1) + fibonacci(n - 2)\n```", "```py\nfrom collections import defaultdict, deque\nfrom typing import Any, Deque, Dict, Tuple\n\nclass LFUCache:\n    def __init__(self, maxsize: int | None = None):\n        \"\"\"\n        Args:\n            maxsize (int | None): Capacity of cache size, defaults to None\n        \"\"\"\n        if maxsize and maxsize < 0:\n            maxsize = 0\n        self.maxsize = maxsize\n        self.cache_dict: Dict[Any, Tuple[Any, int]] = {}\n        self.freq_dict: Dict[int, Deque[Any]] = defaultdict(lambda: deque([]))\n        self.hits, self.misses, self.curr_size = 0, 0, 0\n\n    def cache_info(self) -> Dict[str, int | None]:\n        \"\"\"Report cache statistics\"\"\"\n        return dict(\n            hits=self.hits,\n            misses=self.misses,\n            maxsize=self.maxsize,\n            currsize=self.curr_size,\n        )\n\n    def cache_clear(self) -> None:\n        \"\"\"Clear the cache and cache statistics\"\"\"\n        self.cache_dict = {}\n        self.freq_dict = defaultdict(lambda: deque([]))\n        self.hits, self.misses, self.curr_size = 0, 0, 0\n\n    def update(self, key: Any, value: Any) -> None:\n        \"\"\"Update frequency of key in cache and frequency dictionary.\n        Removes key in frequency dictionary if necessary.\n\n        Args:\n            key (Any): Argument to function\n            value (Any): Result of function\n        \"\"\"\n        _, freq = self.cache_dict[key]\n        self.cache_dict[key] = (value, freq + 1)\n        self.freq_dict[freq].remove(key)\n        self.freq_dict[freq + 1].append(key)\n        if not len(self.freq_dict[freq]):\n            del self.freq_dict[freq]\n\n    def get(self, key: Any) -> Any:\n        \"\"\"Get value by key. Updates the hits and misses statistics.\n\n        Args:\n            key (Any): Argument to function\n\n        Returns:\n            (Any)\n        \"\"\"\n        if key in self.cache_dict:\n            self.hits += 1\n            value, _ = self.cache_dict[key]\n            self.update(key, value)\n            return value\n        self.misses += 1\n        raise KeyError(f\"{key} does not exist in cache.\")\n\n    def put(self, key: Any, value: Any) -> None:\n        \"\"\"Put value by key into cache and frequency dictionary.\n        Check the capacity of the cache and delete the key-value if necessary.\n\n        Args:\n            key (Any): Argument to function\n            value (Any): Result of function\n        \"\"\"\n        if key in self.cache_dict:\n            self.update(key, value)\n        else:\n            self.cache_dict[key] = (value, 1)\n            self.freq_dict[1].append(key)\n            self.curr_size += 1\n            if self.maxsize is not None and self.curr_size > self.maxsize:\n                remove_key = self.freq_dict[min(self.freq_dict)].popleft()\n                del self.cache_dict[remove_key]\n                self.curr_size -= 1\n```", "```py\nfrom functools import wraps\nfrom typing import Callable\n\ndef lfu_cache(maxsize: int | None = None) -> Any:\n    cache = LFUCache(maxsize)\n\n    def decorator(func: Callable[..., Any]) -> Any:\n\n        @wraps(func)\n        def wrapper(*args, **kwargs) -> Callable[..., Any]:\n            key = hash(*args, **kwargs)\n            try:\n                result = cache.get(key)\n                return result\n            except KeyError:\n                result = func(*args, **kwargs)\n                cache.put(key, result)\n            return result\n\n        wrapper.cache = cache\n        wrapper.cache_info = cache.cache_info\n        wrapper.cache_clear = cache.cache_clear\n\n        return wrapper\n    return decorator\n\n# Usage\n@lfu_cache(maxsize=1024)\ndef fibonacci(n: int) -> int:\n    return n if n < 2 else fibonacci(n - 1) + fibonacci(n - 2)\n\nfibonacci.cache_info()\n```", "```py\n# Requires pip install cachetools\nfrom cachetools import cached, FIFOCache\n\n@cached(cache=FIFOCache(maxsize=100), info=True)\ndef fibonacci(n: int) -> int:\n    return n if n < 2 else fibonacci(n - 1) + fibonacci(n - 2)\n\n# Retrieve caching information\nfibonacci.cache_info()\n```"]