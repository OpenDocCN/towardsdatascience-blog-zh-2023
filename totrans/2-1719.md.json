["```py\nimport time\nfrom functools import wraps\n```", "```py\ndef retry(max_tries=3, delay_seconds=1):\n    def decorator_retry(func):\n        @wraps(func)\n        def wrapper_retry(*args, **kwargs):\n            tries = 0\n            while tries < max_tries:\n                try:\n                    return func(*args, **kwargs)\n                except Exception as e:\n                    tries += 1\n                    if tries == max_tries:\n                        raise e\n                    time.sleep(delay_seconds)\n        return wrapper_retry\n    return decorator_retry@retry(max_tries=5, delay_seconds=2)\ndef call_dummy_api():\n    response = requests.get(\"https://jsonplaceholder.typicode.com/todos/1\")\n    return response\n```", "```py\ndef memoize(func):\n    cache = {}\n    def wrapper(*args):\n        if args in cache:\n            return cache[args]\n        else:\n            result = func(*args)\n            cache[args] = result\n            return result\n    return wrapper\n```", "```py\n@memoize\ndef fibonacci(n):\n    if n <= 1:\n        return n\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)\n```", "```py\nFunction slow_fibonacci took 53.05560088157654 seconds to run.\nFunction fast_fibonacci took 7.772445678710938e-05 seconds to run.\n```", "```py\nimport time\n\ndef timing_decorator(func):\n    def wrapper(*args, **kwargs):\n        start_time = time.time()\n        result = func(*args, **kwargs)\n        end_time = time.time()\n        print(f\"Function {func.__name__} took {end_time - start_time} seconds to run.\")\n        return result\n    return wrapper\n```", "```py\n@timing_decorator\ndef my_function():\n    # some code here\n    time.sleep(1)  # simulate some time-consuming operation\n    return\n```", "```py\nmy_function()\n\n>>> Function my_function took 1.0019128322601318 seconds to run.\n```", "```py\nimport logging\nimport functools\n\nlogging.basicConfig(level=logging.INFO)\n\ndef log_execution(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        logging.info(f\"Executing {func.__name__}\")\n        result = func(*args, **kwargs)\n        logging.info(f\"Finished executing {func.__name__}\")\n        return result\n    return wrapper\n\n@log_execution\ndef extract_data(source):\n    # extract data from source\n    data = ...\n\n    return data\n\n@log_execution\ndef transform_data(data):\n    # transform data\n    transformed_data = ...\n\n    return transformed_data\n\n@log_execution\ndef load_data(data, target):\n    # load data into target\n    ...\n\ndef main():\n    # extract data\n    data = extract_data(source)\n\n    # transform data\n    transformed_data = transform_data(data)\n\n    # load data\n    load_data(transformed_data, target)\n```", "```py\nINFO:root:Executing extract_data\nINFO:root:Finished executing extract_data\nINFO:root:Executing transform_data\nINFO:root:Finished executing transform_data\nINFO:root:Executing load_data\nINFO:root:Finished executing load_data\n```", "```py\n@log_execution\n@timing_decorator\ndef my_function(x, y):\n    time.sleep(1)\n    return x + y\n```", "```py\nimport smtplib\nimport traceback\nfrom email.mime.text import MIMEText\n\ndef email_on_failure(sender_email, password, recipient_email):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            try:\n                return func(*args, **kwargs)\n            except Exception as e:\n                # format the error message and traceback\n                err_msg = f\"Error: {str(e)}\\n\\nTraceback:\\n{traceback.format_exc()}\"\n\n                # create the email message\n                message = MIMEText(err_msg)\n                message['Subject'] = f\"{func.__name__} failed\"\n                message['From'] = sender_email\n                message['To'] = recipient_email\n\n                # send the email\n                with smtplib.SMTP_SSL('smtp.gmail.com', 465) as smtp:\n                    smtp.login(sender_email, password)\n                    smtp.sendmail(sender_email, recipient_email, message.as_string())\n\n                # re-raise the exception\n                raise\n\n        return wrapper\n\n    return decorator\n\n@email_on_failure(sender_email='your_email@gmail.com', password='your_password', recipient_email='recipient_email@gmail.com')\ndef my_function():\n    # code that might fail\n```"]