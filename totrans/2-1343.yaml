- en: Introduction to asyncio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/introduction-to-asyncio-57a5a1290ce0](https://towardsdatascience.com/introduction-to-asyncio-57a5a1290ce0)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Managing I/O bound concurrency with Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@hrmnmichaels?source=post_page-----57a5a1290ce0--------------------------------)[![Oliver
    S](../Images/b5ee0fa2d5fb115f62e2e9dfcb92afdd.png)](https://medium.com/@hrmnmichaels?source=post_page-----57a5a1290ce0--------------------------------)[](https://towardsdatascience.com/?source=post_page-----57a5a1290ce0--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----57a5a1290ce0--------------------------------)
    [Oliver S](https://medium.com/@hrmnmichaels?source=post_page-----57a5a1290ce0--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----57a5a1290ce0--------------------------------)
    ·6 min read·Mar 24, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency and parallelism denote a program’s or computer’s capability to run
    multiple operations in parallel. One commonly distinguishes multi-processing (parallelism)
    and multi-threading (concurrency)— with the former describing running multiple
    processes, whereas the second denotes spawning multiple threads within the same
    process. In Python, due to the [Global Interpreter Lock](https://realpython.com/python-gil/)
    (GIL), only one thread can be executed at once, causing any multi-threaded application
    to be single core effectively. Still, e.g. for I/O bound programs (programs, in
    which more time is spent waiting for inputs — i.e. this is the bottleneck and
    not compute), also in Python multi-threading makes sense. In this post we will
    introduce [asyncio](https://docs.python.org/3/library/asyncio.html), which is
    an elegant and easy way of doing so.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/56706dacea79f62fb82537889418d6a7.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Gabriel Gusmao](https://unsplash.com/@gcsgpp?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
    on [Unsplash](https://unsplash.com/photos/pMmw3ynuXHw?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
  prefs: []
  type: TYPE_NORMAL
- en: Why asyncio?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will designate a future post for the differences between multi-processing
    and multi-threading, and how asyncio plays into this. Still we want to motivate
    its usage here. As hinted above, multi-threading is particularly useful for I/O
    bound, i.e. non-CPU bound, applications. And asyncio is one way of doing so, which
    is preferred for some use cases by many developers.
  prefs: []
  type: TYPE_NORMAL
- en: asyncio excels for I/O bound programs, for which we want to write easy, clearly
    structured, and error-resistant code. asyncio actually uses only a single thread,
    and leaves it up to the user when the currently executed piece of code will “yield”
    its execution for waiting on external inputs and allowing a different piece of
    code to be executed. This often makes the code easier to read, while also giving
    the user more control of what is executed when — while simultaneously reducing
    the risk of deadlocks and co.
  prefs: []
  type: TYPE_NORMAL
- en: Motivating Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s begin by an introductory example. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In it, we call `sleepy_function()` three times, which simply prints two things
    and otherwise sleeps for a second. In total, this program takes 3 seconds to execute.
    But of course it is pretty much a waste to have a CPU wait for 1 second without
    doing any other work. Thus it’s natural to parallelise this — which is exactly
    the definition of an I/O bound program.
  prefs: []
  type: TYPE_NORMAL
- en: 'With asyncio, the following code can be parallelised like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note asyncio is only available from Python versions 3.4 upwards, and for these
    is included in the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: In the following, we will now have a closer look at the used syntax and asyncio
    in general.
  prefs: []
  type: TYPE_NORMAL
- en: Using asyncio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Core concepts of asyncio are coroutines and tasks. Coroutines are basically
    functions, which can yield execution to the controlling asyncio thread (while
    e.g. waiting for inputs), without losing their state (a bit similar to [generator
    expressions](https://medium.com/@hrmnmichaels/generators-and-generator-expressions-in-python-a8d2e700945e)).
    Thus, in this form of concurrency the user is in full control of when context
    switches between threads (coroutines / tasks in this setting) happen, as opposed
    to classical multi-threading, where this is determined by the operating system.
    Due to this, and the fact that asyncio makes use of only a single thread — asyncio
    code is much less error prone and we (normally) don’t need to use any kind of
    locking, such as locks or mutexes.
  prefs: []
  type: TYPE_NORMAL
- en: 'A coroutine is defined using the keyword async:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It is now not enough to just call this as usual via `sample_coroutine()` —
    this won’t work. Instead, we have to order asyncio to execute this. We can do
    so via:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The next important keyword is `await`. This signals asyncio that we want to
    wait for some event, and that it can proceed executing another part of the code.
    Anything we can `await` for is called `Awaitable`, and coroutines and tasks are
    two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In above example, we first wait for 1s using `asyncio.sleep` — and then for
    `sample_coroutine_2`. Note the execution time of this program is still 1s, and
    not less somehow — but shortening this is not the point of this simple example.
  prefs: []
  type: TYPE_NORMAL
- en: Tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If however, we now want to parallelise the execution of different code blocks,
    one thing we can use is tasks. Via `asyncio.create_task` we can create a task
    from a coroutine, and then execute this via `await`. This way, we can run multiple
    coroutines in parallel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: gather
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'However, I usually find it more convenient and intuitive to use the following
    syntax involving `asyncio.gather`, which can take arbitrary many `Awaitables`
    as input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can shorten above code using the [asterix (*)](/unpacking-operators-in-python-306ae44cd480)
    operator, which unpacks the given Iterable into single arguments (and thus closing
    the gap to the introductory example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Queue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s end this post by introducing `asyncio.Queue`, a queue which is safe to
    be used in “multi-threaded” asyncio applications, and a helpful tool for many
    real-world use-cases. We use it for a slightly more complex example, in hopes
    of capping off this post by a more realistic “real-world” example.
  prefs: []
  type: TYPE_NORMAL
- en: Our example consists of one producer thread and N consumer threads. The producer
    tries to guess [ISBN numbers](https://en.wikipedia.org/wiki/ISBN), and puts them
    on the queue. The consumers remove these from the queue, and do a [GET request](https://www.w3schools.com/tags/ref_httpmethods.asp)
    to a public endpoint returning information about books with the given ISBN. If
    the consumer guesses a correct ISBN, we print the returned book information.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute the request in async mode, we use [aiohttp](https://docs.aiohttp.org/en/stable/).
    Webrequests in general are a common topic and use-case for asyncio: often, a webserver
    will concurrently run different requests, render / query different things, and
    then return the resulting webpage. Since this is not CPU bound, but most of the
    time (probably) is spent on waiting for the request results, asyncio is a good
    fit here.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Apart from what was said above, it is noteworthy to call out how to use the
    async queue. As we can see, we place items on the queue via `put_nowait()`. The
    `_nowait` suffix simply means don’t wait when the queue is full — which does not
    concern us here, as we don’t put a limit on the queue size.
  prefs: []
  type: TYPE_NORMAL
- en: Items are popped from the queue via `get()` — but need to be marked complete
    by a corresponding `tasks_done()`!
  prefs: []
  type: TYPE_NORMAL
- en: Note I tuned the number of consumers and the sleep time between generating ISBNs,
    s.t. on my laptop the queue size stays relatively constant.
  prefs: []
  type: TYPE_NORMAL
- en: '**This brings us to the end of this tutorial about asyncio. I hope this was
    an interesting read, thanks for stopping by!**'
  prefs: []
  type: TYPE_NORMAL
- en: 'PS: let me know if you by accident discovered any cool reads using the last
    sample program!'
  prefs: []
  type: TYPE_NORMAL
