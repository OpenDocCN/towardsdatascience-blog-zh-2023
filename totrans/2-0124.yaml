- en: 5 ways of Implementing Open Closed Principle with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/5-ways-of-implementing-open-closed-principle-with-python-51fd21a90772](https://towardsdatascience.com/5-ways-of-implementing-open-closed-principle-with-python-51fd21a90772)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Object Oriented Programming Principles for Data Scientists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://erdemisbilen.medium.com/?source=post_page-----51fd21a90772--------------------------------)[![Erdem
    Isbilen](../Images/6b6ca6806024725245132894b2958e49.png)](https://erdemisbilen.medium.com/?source=post_page-----51fd21a90772--------------------------------)[](https://towardsdatascience.com/?source=post_page-----51fd21a90772--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----51fd21a90772--------------------------------)
    [Erdem Isbilen](https://erdemisbilen.medium.com/?source=post_page-----51fd21a90772--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----51fd21a90772--------------------------------)
    ·9 min read·Mar 1, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1487410753331cb5a273091bd8223b81.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Tim Mossholder](https://unsplash.com/@timmossholder?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: The Open-Closed Principle (OCP) is one of the five SOLID principles of object-oriented
    programming. It states that software entities, such as classes, modules, and functions,
    should be open for extension but closed for modification. In other words, you
    should be able to add new features to your software without having to modify existing
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of the OCP is to create software that is more flexible and easier to
    maintain over time. By designing software that can be extended without modifying
    existing code, you can reduce the risk of introducing new bugs and make your code
    easier to read and understand.
  prefs: []
  type: TYPE_NORMAL
- en: How Open-Closed Principle Helps Data Scientists?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the OCP is primarily concerned with software design, it can also be applied
    to data science. Data scientists often work with large, complex data sets and
    models that need to be updated and modified over time. By following the OCP, data
    scientists can ensure that their models are easily extensible and maintainable
    over time.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of data science, a “model” typically refers to a mathematical
    or statistical representation of a real-world system or process. Models can be
    used to make predictions, classify data, or understand complex relationships between
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a data scientist might build a machine learning model to predict
    customer churn for a business based on historical customer data. The model would
    be trained on a dataset of past customer behaviour and would use that information
    to make predictions about which customers are most likely to churn in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Models can take many different forms, depending on the specific problem being
    solved and the data available. Some common types of models used in data science
    include regression models, decision trees, neural networks, and support vector
    machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, the OCP can help data scientists in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Facilitating model extension: By designing models to be open for extension,
    data scientists can easily add new features and functionality to their models
    without modifying the original code. This can help them keep their models up-to-date
    and relevant over time.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Encouraging modular design: The OCP encourages modular design, which can make
    it easier to update and modify models over time. By breaking down models into
    smaller, more manageable components, data scientists can make changes to specific
    parts of the model without affecting the rest of the code.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enhancing maintainability: By designing models that are closed for modification,
    data scientists can ensure that their code is more stable and less prone to errors.
    This can make it easier to maintain and update models over time.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 5 Ways of Implementing Open-Closed Principle In Python?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '(1) Use abstraction:'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One way to implement the OCP in Python is to use abstraction to hide implementation
    details and allow for extension without modification. In this example, we define
    an abstract base class `DataTransformer` that defines a single abstract method
    `transform`. This class serves as an abstraction for any data transformer that
    we might create in the future. We then define two concrete implementations of
    this abstract class: `StandardScalerTransformer` and `LogTransformer`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `DataPipeline` class takes a list of `DataTransformer` objects as an argument
    to its constructor. This allows us to add or remove transformers to the pipeline
    without modifying the class itself. The `run` method applies each transformer
    in the pipeline to the data sequentially.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this abstraction, we can easily create new transformers that implement
    the `transform` method and add them to the pipeline without modifying the existing
    `DataPipeline` class. This demonstrates the Open/Closed Principle in action: the
    `DataPipeline` class is open for extension (we can add new transformers to the
    pipeline) but closed for modification (we don''t need to modify the existing class
    to add new transformers).'
  prefs: []
  type: TYPE_NORMAL
- en: '(2) Use inheritance and/or composition:'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way to implement the OCP in Python is to use inheritance to extend the
    behaviour of your classes. By creating a base class with a well-defined interface,
    you can create new subclasses that inherit that interface and add new functionality.
    This allows you to extend the behaviour of your code without modifying the original
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We can implement the OCP in Python with composition rather than inheritance.
    By defining objects that contain other objects, data scientists can create code
    that is more modular and easier to extend.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we define the `DataAnalyzer` base class with abstract methods
    `preprocess` and `analyze`, which must be implemented by subclasses. We also define
    an `__init__` method that takes in the data to be analyzed.
  prefs: []
  type: TYPE_NORMAL
- en: We then define three subclasses for analyzing numerical, text, and image data,
    respectively. Each subclass overrides the `preprocess` and `analyze` methods to
    provide specialized functionality for that type of data.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `NumericalDataAnalyzer` subclass includes a `preprocess` method
    that scales the numerical data using a `StandardScaler` object, while the `TextDataAnalyzer`
    subclass includes a `preprocess` method that vectorizes the text data using a
    `TfidfVectorizer` object. Similarly, the `ImageDataAnalyzer` subclass includes
    a `preprocess` method that extracts features from the image data using a `ResNet50`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By using inheritance to create specialized subclasses and composition to include
    specialised objects within those subclasses, we can analyze each type of data
    consistently and flexibly, while adhering to the Open-Closed Principle. If we
    need to add support for a new type of data in the future, we can simply create
    a new subclass that inherits from `DataAnalyzer` and includes appropriate composition
    of specialized objects. This approach allows us to extend our program without
    modifying the existing code, making it easier to maintain and reuse.
  prefs: []
  type: TYPE_NORMAL
- en: '(3) Use plugins:'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The OCP can be applied to create a plugin architecture in Python. By defining
    a set of well-defined interfaces or abstract base classes, data scientists can
    allow other developers to write plugins that extend the functionality of their
    code without modifying the original implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we have a script that performs some data processing on a given dataset.
    We want to be able to easily add and remove different data processing steps as
    plugins, without modifying the script code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a plugin architecture to define data processing steps as plugins
    that can be loaded dynamically at runtime. Here’s some example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we define a `DataProcessingPlugin` class that defines the interface
    for data processing plugins. We also define two plugins, `RemoveDuplicatesPlugin`
    and `ImputeMissingValuesPlugin`, that implement the `DataProcessingPlugin` interface
    and define custom logic for removing duplicate rows and imputing missing values,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: We then define a `process_data` function that takes a dataset and a list of
    processing steps as inputs. The function uses the `importlib` module to load each
    processing plugin corresponding to the given steps dynamically at runtime. It
    then applies each processing plugin to the data sequentially to produce a final
    processed dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Using plugins in this way allows us to easily modify and experiment with different
    data processing steps without having to modify the `process_data` function code.
    It also makes it easier to share and reuse data processing code between different
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: '(4) Use configuration files:'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The OCP can be applied by using configuration files to control the behavior
    of a Python program. By separating configuration data from code, data scientists
    can create programs that are easier to extend and maintain. For example, a data
    scientist might define a configuration file that specifies the parameters for
    a machine learning model, allowing other developers to experiment with different
    parameter settings without modifying the original code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we have a dataset of customer reviews and we want to analyze the sentiment
    of each review using various machine learning models. We want to be able to easily
    swap out the machine learning model being used without changing the code of our
    sentiment analysis script.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a configuration file to specify which machine learning model to
    use and its associated hyperparameters. Here’s an example configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we’re using logistic regression as our machine learning model
    and specifying a regularization parameter of 1.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our sentiment analysis script can then be read in this configuration file and
    use the specified machine learning model to analyze the sentiment of each review.
    Here’s some example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we define a `load_data` function to load customer reviews from
    a CSV file, a `preprocess_data` function to preprocess the data for use with the
    machine learning model, and a `train_model` function to train the specified machine
    learning model on the preprocessed data.
  prefs: []
  type: TYPE_NORMAL
- en: We read in the configuration file using the `json.load` method and pass the
    specified machine learning model and its hyperparameters to the `train_model`
    function. This allows us to easily switch out the machine learning model being
    used by simply modifying the configuration file, without having to change any
    of the code in our sentiment analysis script.
  prefs: []
  type: TYPE_NORMAL
- en: Using configuration files to specify parameters in this way is a common pattern
    in data science, as it allows for easy modification and experimentation without
    having to modify the code.
  prefs: []
  type: TYPE_NORMAL
- en: '(5) Use dependency injection:'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The OCP can be applied by using dependency injection to allow objects to be
    created and configured dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we define three classes for data cleaning, feature engineering,
    and machine learning. Each of these classes takes a strategy as a dependency that
    is injected when creating an instance of the class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We create instances of the data cleaning and feature engineering strategies
    and inject them into instances of the `DataCleaner` and `FeatureEngineer` classes,
    respectively. This allows us to easily switch out the data cleaning and feature
    engineering strategies with different implementations, without modifying any of
    the code in our machine learning script.
  prefs: []
  type: TYPE_NORMAL
- en: We also create an instance of the `DataLoader` class, which is not injected
    with any dependencies. This is because the data loading strategy is unlikely to
    change frequently, so it does not need to be specified as a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Using dependency injection in this way allows us to easily modify and experiment
    with different data cleaning and feature engineering strategies without having
    to modify the machine learning code.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By following the Open-Closed Principle, data scientists can create code that
    is not only functional, but also modular, extensible, and easy to maintain. This
    can help to ensure the longevity and effectiveness of our data science projects,
    enabling us to more easily meet the ever-changing demands of the data science
    landscape.
  prefs: []
  type: TYPE_NORMAL
