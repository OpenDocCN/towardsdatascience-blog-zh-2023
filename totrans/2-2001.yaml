- en: The Catcher in the… Python. Catch Exceptions and Warnings with One Tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/the-catcher-in-the-python-catch-exceptions-and-warnings-with-one-tool-81714117da76](https://towardsdatascience.com/the-catcher-in-the-python-catch-exceptions-and-warnings-with-one-tool-81714117da76)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: PYTHON PROGRAMMING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Why not implement one tool for catching both exceptions and warnings in Python?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@nyggus?source=post_page-----81714117da76--------------------------------)[![Marcin
    Kozak](../Images/d7faf62e48ed81dab5d8ad92819fff54.png)](https://medium.com/@nyggus?source=post_page-----81714117da76--------------------------------)[](https://towardsdatascience.com/?source=post_page-----81714117da76--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----81714117da76--------------------------------)
    [Marcin Kozak](https://medium.com/@nyggus?source=post_page-----81714117da76--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----81714117da76--------------------------------)
    ·13 min read·May 23, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6f42c45eba05eb69d8a1a9adcc012803.png)'
  prefs: []
  type: TYPE_IMG
- en: The article discusses catching exceptions and warnings in Python. Photo by [Keith
    Johnston](https://unsplash.com/de/@acfb5071?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: 'Python has some nice approach to handling exceptions. You can catch them, raise
    them, re-raise them, raise two exceptions at the same time (or rather, one exception
    from another), log them, and to create custom errors and their hierarchy, to name
    just the most important ones. If you want to handle warnings, you can also do
    that — but you need two separate tools: one for exceptions and one for warnings.'
  prefs: []
  type: TYPE_NORMAL
- en: Read this article to learn how to write a single catcher for both exceptions
    and warnings, and how to adjust it to your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'I really like Python’s exception handling. I like its simplicity, which you
    can see for instance here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Before analyzing the function, let’s see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a88c74fc599d02c8e7b5c31090fae843.png)'
  prefs: []
  type: TYPE_IMG
- en: The multiply_str() function in action; screenshot from Python REPL. Image by
    author
  prefs: []
  type: TYPE_NORMAL
- en: The first two calls are correct. The second one is not, as we’re trying to multiply
    two strings. The third one is incorrect, too, but this time because the function
    got two integer values. They can be multiplied, but our function catches this
    scenario by noticing that the resulting object is not a string — which basically
    means something went wrong; hence the exception.
  prefs: []
  type: TYPE_NORMAL
- en: What we see here is called duck typing. We’re not checking if the input values
    are of correct types; instead, we’re doing what the function aims to do — here,
    multiply the two values. If it goes fine, then… it’s fine. Duck typing is a typical
    dynamic approach in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, however, the situation is a little more complex: the function
    will work also with two numeric values, something we’re not interested in. We
    do *not* want the function to be polymorphic: we want it to work with `x` a string
    and `n` an integer.'
  prefs: []
  type: TYPE_NORMAL
- en: We could thus check their types and raise the same exceptions as above. In the
    above version, we check the type of the return value, a faster approach. It’s
    faster because we check type of only one object (`xn`), but also only when we
    know `x` and `n` can be multiplied. So, this is not truly duck typing. Oftentimes,
    however, you will choose pure duck typing, the most natural Python approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this article, however, we’re talking about something else: catching errors,
    so let’s move on. The `multiply_str()` function multiplies a string `x` by an
    int `n`, but does so in a controlled way — meaning that if something is wrong,
    the corresponding exception is caught and raised using a custom exception. Actually,
    it does more than that:'
  prefs: []
  type: TYPE_NORMAL
- en: A customized message is added.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MultiplicationError` is raised `from TypeError`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The latter thing is interesting in the context of our discussion. In practice,
    it helps you catch errors from `multiply_str` using both `except MultiplicationError`
    and `except TypeError`. Both will catch `MultiplicationError` — even though `TypeError`
    is not (programistically) related to the former. So, this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'will catch the same error as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This can be useful in various situations, especially when one uses `multiply_str()`
    in their own code outside of the package in which `multiply_str()` is defined.
    Otherwise, the user would have to import `MultiplicationError`. It’s easier to
    try to catch `TypeError`, and this will also allow you catching `MultiplicationError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, there’s far more into using exceptions in Python. You can read more
    about custom exceptions from this article:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/should-we-use-custom-exceptions-in-python-b4b4bca474ac?source=post_page-----81714117da76--------------------------------)
    [## Should we use custom exceptions in Python?'
  prefs: []
  type: TYPE_NORMAL
- en: Python has so many built-in exceptions that we rarely need to create and use
    custom ones. Or do we?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/should-we-use-custom-exceptions-in-python-b4b4bca474ac?source=post_page-----81714117da76--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also find this article interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://betterprogramming.pub/how-to-overwrite-asserterror-in-python-and-use-custom-exceptions-c0b252989977?source=post_page-----81714117da76--------------------------------)
    [## How to Overwrite AssertionError in Python and Use Custom Exceptions'
  prefs: []
  type: TYPE_NORMAL
- en: Python’s assert statement uses AssertionError. Know how to use a different exception
    instead
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: betterprogramming.pub](https://betterprogramming.pub/how-to-overwrite-asserterror-in-python-and-use-custom-exceptions-c0b252989977?source=post_page-----81714117da76--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: But now, let’s move on to warnings.
  prefs: []
  type: TYPE_NORMAL
- en: Handling warnings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Warnings are raised and caught in a similar way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We still raise an exception when an exception was raised during multiplication,
    but when the object to return is not a string, a warning is raised. See how this
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3718005531b811c86fac54dfade5550f.png)'
  prefs: []
  type: TYPE_IMG
- en: The multiply_str() function in action, this time with both an exception and
    a warning; screenshot from Python REPL. Image by author
  prefs: []
  type: TYPE_NORMAL
- en: 'As you see, with a warning, you get the warning, but you do also get the output,
    unlike in the case of an exception. You need to remember that Python’s default
    behavior is to warn you once:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c4001c19e48aac36c42204d0c8797023.png)'
  prefs: []
  type: TYPE_IMG
- en: The default behavior is to raise a particular warning only once; screenshot
    from Python REPL. Image by author
  prefs: []
  type: TYPE_NORMAL
- en: 'It assumes you will remember you have been warned, so you’re on your own. You
    can change this behavior, but we will talk about this some other day. Changing
    this behavior is easy. Consider the below screenshot *from a new session*, with
    the same code imported as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2d8b5cca9d1fc0d4b621f9f02f6095e7.png)'
  prefs: []
  type: TYPE_IMG
- en: An “always” warning filter changes the default behavior; screenshot from Python
    REPL. Image by author
  prefs: []
  type: TYPE_NORMAL
- en: From now on, we will work with this warnings filter.
  prefs: []
  type: TYPE_NORMAL
- en: There is more into warnings than that. Let’s stop here, however, as the main
    aim we want to achieve today is implementing a joint catcher of exceptions and
    warnings.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the catcher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Okay, so we want to implement a tool that will enable us to catch both exceptions
    and warnings. First, let’s see how we can catch our custom `MultiplicationError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'and warnings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Of course, these are just some basic examples. We can do it in various ways,
    depending on what we want out joint catcher to return to the user. For the moment,
    let’s return a list with exceptions and warnings, ordered according to the time
    they were caught.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is one of the simplest examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And let’s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `divdiv()` function is, certainly, unnatural, as it always issues a warning,
    but I wanted to show a very simple example. After running incorrect command `divdiv(1,
    0)`, the catcher contains an exception and a warning.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could improve the `catch()` function a little bit. While many Pythonistas
    like returning two- or three-element tuples from functions, you can instead return
    a named tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We could define `CatchReturn` outside of the function; we could define it on
    the fly, using the following return line instead of the last two lines from the
    function above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Anyway, with this namedtuple, the function certainly returns a namedtuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The good thing is, you can ignore that it’s a namedtuple and treat it just
    like a regular tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Okay, so this is the basic version of a joint catcher. But you can do so much
    more with such catchers! Below, I present two more examples, with only basic comments.
    You can enjoy the time spent with these examples and the effort to understand
    their implementation. Should you have any questions, though, don’t hesitate to
    ask them in the comments. And if you come up with some other examples you’d like
    to share, please do so!
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Closure-based multiple catcher'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous catcher worked with a single function call. In this example, we
    will use a closure to build a catcher that can be used for many subsequent function
    calls. If a particular call goes fine, the catcher simply returns the result.
    If a warning is issued, it will return the output and log the warning. If an exception
    is raised, it will catch the exception — but it will not return at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the implementation: I used a closure. The most common example of closures
    in Python are decorators, but closures can be used for other purposes as well.
    Here, we will use them to keep state; we could do so using a class (actually,
    we will do so in the next example), but as you will see, closures offer even a
    simpler approach for that.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s see the function in action. First, we need to create an object of
    the catcher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We will now use the `all_catcher` object to call several functions. I will use
    the same `DivisionWarning` and `divdiv()` function we used above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This catcher works with functions defined as `lambda`s, though we can use a
    different structure; we will do so in the next example. Above, `x1` is `None`
    because — in addition to `DivisionWarning` — the catcher caught an exception (`ZeroDivisionError`).
    To see the `issues` list, it’s enough to call `all_catcher()` (thanks to the `if`-block
    in the definition of the `catch_one()` function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If we call a function that works fine and dandy, we will get its return value,
    and the catcher will not log anything (so its `issues` list will remain unchanged):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s add some more calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The catcher’s net should contain more than it did¹:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It does so indeed. Errors and warnings are logged here in the order of their
    catching, but this is just one of various possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Oh, one more thing. You can use more such catchers in one session/script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike `catcher1`, `catcher2` should be empty. Let’s check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As another exercise, you can use a different data structure in `catch_all()`,
    instead of a list. Or log exceptions and warnings into different lists. Or log
    using the `logging` module. Or add a timestamp to each element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Class-based catcher'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We could implement a class-based that would work the same way as our above catcher
    implemented using a closure, but I will leave you this as an exercise. Instead,
    I will show you how to do something a little more interesting, that is, implement
    a catcher which works with the `|` pipe operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pipes aren’t too popular in Python, but they do exist. You can see them in
    the `Pipe` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://github.com/JulienPalard/Pipe?source=post_page-----81714117da76--------------------------------)
    [## GitHub - JulienPalard/Pipe: A Python library to use infix notation in Python'
  prefs: []
  type: TYPE_NORMAL
- en: Module enabling a sh like infix syntax (using pipes). As an example, here is
    the solution for the 2nd Euler Project…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: github.com](https://github.com/JulienPalard/Pipe?source=post_page-----81714117da76--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: While Python is not a functional programming language, it offers various tools
    you can use to at least imitate the functional-programming paradigm. The `Pipe`
    package is a very nice example of how to do it with pipes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will, however, implement our own pipe operator, by overloading the `|` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s use this `catcher`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the basic usage. Let’s define a couple of helpers, to give us some
    flexibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Run` function can be used instead of the `lambda` syntax (below, you can
    compare the two types of calling a function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'But if you use `Print` to, obviously, print, you will see `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: But with `Print`, the catcher *only* prints and does not return anything. You
    can revise it to do both, in which case it could serve as simple debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re left with `Ignore`. It does not really ignore the function it’s ran with;
    it ignores any output from this function, catching exceptions and warnings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`Run`, `Print` and `Ignore` are just three examples, and if you have a free
    minute, think of other examples that could work with this catcher. Note I used
    an atypical — and even non-Pythonic — approach in which I named class instances
    working in a similar way to functions (okay, more or less similar, even less)
    using a capital first letter. I did this to distinguish `Print` from its built-in
    counterpart, `print`. Although the other objects do not have their counterparts
    in the standard Python library, I wanted to use the same naming convention for
    all such objects working with the catcher.'
  prefs: []
  type: TYPE_NORMAL
- en: I am not saying it’s a good approach — but I thought it was a good idea to show
    you that in some cases, you may try and use atypical syntax. However, if you decide
    to do so, to go against the grain, always think twice if what you’re doing is
    not too atypical for Python. And be prepared to defend your standpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This article intended to show why it’s worth implementing a joint catcher of
    warnings and exceptions, and to demonstrate how to implement some examples. My
    aim wasn’t to implement a tool for you to use in your projects, but rather to
    show you how to implement such tools.
  prefs: []
  type: TYPE_NORMAL
- en: This does not mean the catchers we discussed are not ready for direct use; they
    are. Nevertheless, I hope that now that you’re equipped with this knowledge, you
    will be able to implement your own catchers, adapted to your projects.
  prefs: []
  type: TYPE_NORMAL
- en: If you have any comments or suggestions — for me or for other readers — feel
    free to share them in the comments.
  prefs: []
  type: TYPE_NORMAL
- en: Footnotes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '¹ You can see a `doctest` flag in the code, since I used it to test the code
    from this article. `doctest` is a standard-library module for documentation testing.
    If you’re interested in learning more about this interesting module, you can do
    so from this article:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/python-documentation-testing-with-doctest-the-easy-way-c024556313ca?source=post_page-----81714117da76--------------------------------)
    [## Python Documentation Testing with doctest: The Easy Way'
  prefs: []
  type: TYPE_NORMAL
- en: doctest allows for documentation, unit and integration testing, and test-driven
    development.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/python-documentation-testing-with-doctest-the-easy-way-c024556313ca?source=post_page-----81714117da76--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks for reading. If you enjoyed this article, you may also enjoy other articles
    I wrote; you will see them [here](https://medium.com/@nyggus). And if you want
    to join Medium, please use my referral link below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/@nyggus/membership?source=post_page-----81714117da76--------------------------------)
    [## Join Medium with my referral link - Marcin Kozak'
  prefs: []
  type: TYPE_NORMAL
- en: Read every story from Marcin Kozak (and thousands of other writers on Medium).
    Your membership fee directly supports…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/@nyggus/membership?source=post_page-----81714117da76--------------------------------)
  prefs: []
  type: TYPE_NORMAL
