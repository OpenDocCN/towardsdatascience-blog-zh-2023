- en: Try These 3 Lesser-Known Pandas Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/try-these-3-lesser-known-pandas-functions-cfee4bc7e191](https://towardsdatascience.com/try-these-3-lesser-known-pandas-functions-cfee4bc7e191)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Improve your data processing skills using pandas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://yongcui01.medium.com/?source=post_page-----cfee4bc7e191--------------------------------)[![Yong
    Cui](../Images/475918ba9ca0ecd923abe2e7843582a9.png)](https://yongcui01.medium.com/?source=post_page-----cfee4bc7e191--------------------------------)[](https://towardsdatascience.com/?source=post_page-----cfee4bc7e191--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----cfee4bc7e191--------------------------------)
    [Yong Cui](https://yongcui01.medium.com/?source=post_page-----cfee4bc7e191--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----cfee4bc7e191--------------------------------)
    ·6 min read·Aug 28, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/bf3727e8ae6553e9f1b0037f4efe9f40.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Balázs Kétyi](https://unsplash.com/@balazsketyi?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: 'If you ask any experienced data scientist and machine learning engineer, what
    costs the most amount of time in their job? I guess many of them will say: data
    preprocessing — a step that cleans up the data and prepares it for sequential
    data analysis. The reason is simple — garbage in, garbage out. That is if you
    don’t prepare the data correctly, your “insights” of the data can hardly be meaningful.'
  prefs: []
  type: TYPE_NORMAL
- en: Although the data preprocessing step can be rather tedious, Pandas provides
    all essential functions that allow us to complete our data clean-up job relatively
    easily. However, because of its versatility, not every user knows all the functionalities
    that the pandas library has to offer. In this article, I’d like to share 3 lesser-known,
    yet super useful, functions that you can try in your data science projects.
  prefs: []
  type: TYPE_NORMAL
- en: Without further ado, let’s dive in.
  prefs: []
  type: TYPE_NORMAL
- en: '*Note: To provide context, suppose that you’re responsible for data management
    and analysis of a clothing store. The examples shown below are based on this assumption.*'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. explode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first function that I want to mention is `explode`. This function is useful
    when you deal with data in a column that contains lists. When you use `explode`
    with this column, you create multiple rows by extracting each of the elements
    in the list into separate rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a simple code example to show you how to use the `explode` function.
    Suppose that you have a data frame that stores order information. In this table,
    you have a column (i.e., the `order` column) that contains lists of items, as
    shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/d053917054ce1f4d9b05572d384308cf.png)'
  prefs: []
  type: TYPE_IMG
- en: The needed operation is to split each item of the list into a separate row for
    further data processing. Without using `explode`, a naive solution may be the
    following. We simply iterate the original rows and create multiple rows from each
    of the items in the list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/109b461e89b1c55c516889176bfcecdf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using `explode`, we can have a much cleaner solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we specify the column that we want to “explode”, which results
    in a new data frame containing the column with each row being an item of the original
    list. Using the `assert` statement, I’m showing that using explode produces the
    same result as the previous solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a side note, if you want the new data frame to have an index of 0, 1, …,
    n, you can specify `ignore_index` as `True`. The advantage of using `explode`
    compared with the naive solution is more than just a simple function call vs.
    a for loop — `explode` can also handle cases when certain rows contain a single
    item instead of a list object, such as a row like: `Chloe, Jeans`. This row can’t
    be correctly processed by the naive solution, because Jeans isn’t a list object.'
  prefs: []
  type: TYPE_NORMAL
- en: 2\. assign
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second function that I want to discuss is `assign`. This function creates
    new columns or modifies existing ones in a data frame. The major benefit of this
    function is that you can add calculated or derived columns without modifying the
    original data in place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we have a data frame containing information about the clothing store’s
    products and their prices, as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/aba9e6cd3bb20554978d743eaa4815a1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We need to calculate the discounted prices for each product by applying a discount
    percentage — for the store’s employees, we take 20% off, and for the store’s VIP
    customers, we take 10% off. Without using `assign`, we may have the following
    solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/6a2f7a55c42acf493b7aca33a42a6aa5.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we first create a copy of the data frame, such that the creation
    of new columns doesn’t change the original data frame. With the new data frame,
    we create the additional columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `assign` function combines these separate steps, resulting in a cleaner
    solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the above code, in the `assign` function, we specify the
    two additional columns and supply each with the desired calculation. The output
    data frame matches the one that we created just now. As a quick note, you call
    the `assign` function with keyword arguments, and these keywords become the new
    column names.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. interpolate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The third function I want to mention is `interpolate`, using which we can fill
    missing values in a data frame using various interpolation methods. As some of
    you may know, interpolation is a technique that estimates values based on the
    surrounding data points. In particular, when you deal with time-series data, it’s
    a common technique to fill missing values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you have a data frame that stores the sales data. However, because
    in some days, the manager forgot to enter the sales data into the source, which
    resulted in some missing values, as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/847aaeaa2929e8725bea7d5b96c991ea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we don’t use the `interpolate` function, we may identify the indices of
    missing values and locate their surrounding values, using which you can interpolate
    the missing values. As you can imagine, it’s a very complicated process. By contrast,
    you can use the `interpolate` function, which takes care of all these tedious
    steps, as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/19b0c44fd1616665f0c98528ae9336f0.png)'
  prefs: []
  type: TYPE_IMG
- en: In the interpolated data frame, you don’t see any missing values, and all of
    them are filled with interpolated values based on their surrounding values. As
    you may notice, the default interpolation method is linear, which assumes the
    changes are linear in the range of missing values, bounded by their non-missing
    neighbors. There are other interpolation methods, and you can check them out in
    the official [documentation](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.interpolate.html).
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is pretty much for this article. With the iterations of the pandas library,
    more and more functions have become available in recent versions. If you have
    some operations that you feel like complicated, look up its official documentation
    and there might be functions that are readily available for you to use, such as
    the `interpolate` function that can be used in dealing with missing data in the
    time-series analysis.
  prefs: []
  type: TYPE_NORMAL
