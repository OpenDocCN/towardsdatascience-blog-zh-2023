["```py\njohn_doe_interactions_with_specific_restaurant =\nUserInteractionsWithTaxonomy(taxonomy_of_restaurant)\n```", "```py\njohn_doe_interactions_with_specific_restaurant.click(\"Drinks\")\nchoices = john_doe_interactions_with_specific_restaurant.choices()\n# User picks 'Coca Cola' from choices and acts on it. \n# ('act' is 'order here'.)\njohn_doe_interactions_with_specific_restaurant.act('Coca Cola')\n```", "```py\nclass UserInteractionsWithTaxonomy:\n\n  def _init_(self, taxonomy):\n    self.taxonomy = taxonomy\n    self.current_node = None\n\n  def click(self, node):\n    self.current_node = node\n\n  def act(self, leaf, pc = 1):\n    # increment the leaf's counter by pc\n    # increment the counters of all of the leaf's ancestors, each by pc\n\n  def choices(self):\n    res = {}\n    for each child of self.current_node:\n      res[child] = self.score(child, self.current_node)\n    return res\n\n  def score(self,child,parent):\n    return self.counter[child]/self.counter[parent]\n```", "```py\nself.counter[child]/self.counter[parent]\n```", "```py\nclass UserInteractionsWithTaxonomy:\n\n  …\n\n  def act_randomly(self, n. pc):\n    for i in range(n):\n      leaf = leaves.sample_randomly()\n      self.act(leaf, pc)\n```", "```py\nclass UserInteractionsWithTaxonomy:\n\n  def __init__(self, taxonomy, taxonomy_model = None):\n    …\n    self.taxonomy_model = taxonomy_model\n    …\n\n  def act_on_this(self, leaf, pc = 1):\n    # Previous version of act(.) renamed\n\n  def act(self, leaf):\n    self.act_on_this(leaf)\n    if self.taxonomy_model is not None:\n      self.taxonomy_model.act_on_this(leaf)\n\n  def act_randomly(self, n. pc):\n      for i in range(n):\n        …\n        self.act_on_this(leaf, pc)\n\n  def score(self,child,parent, pcm = 1):\n    if self.taxonomy_model is None:\n      return self.counter[child]/self.counter[parent]\n    else:\n      s = self.taxonomy_model.score(child, parent)\n      pc = pcm*s\n      child_adjusted_count   = self.counter[child] + pc\n      parent_adjusted_count  = self.counter[parent] + pcm\n    return child_adjusted_count/parent_adjusted_count\n```", "```py\nrestaurant_model = UserInteractionsWithTaxonomy(taxonomy_of_restaurant)\nuser_restaurant_models = {}\nfor user in users_of_this_restaurant:\n  user_restaurant_models[user] = UserInteractionsWithTaxonomy(\n    taxonomy_of_restaurant, restaurant_model)\n```", "```py\nself.taxonomy_model.score(child, parent)\n```", "```py\nclass BagOfWords:\n\n  def _init_(self):\n    # Create self.bow\n\n  def add(self, bow):\n    for word in bow:\n      self.bow[word] += bow[word]\n```", "```py\nclass UserInteractionsWithTaxonomy():\n\n  def _init_(self, taxonomy):\n    …\n    self.user_likes = BagOfWords()\n\n  def act(self, leaf):\n    …\n    self.user_likes.add(leaf.name.bow)\n```", "```py\nclass UserInteractionsWithTaxonomy:\n\n  …\n\n  def score(self,child,parent, pcm = 1):\n    …\n    if it makes sense to score off user likes and not order frequencies:\n      return self.user_likes[parent].score(self.user_likes[child])\n    …\n```", "```py\nclass UserInteractionsWithTaxonomy:\n\n  def _init_(self, taxonomy):\n    …\n    self.user_likes = {}\n    for each internal node in the taxonomy:\n      self.user_likes[node] = BagOfWords()\n\n  def act(self, leaf):\n    …\n    for each node that is an ancestor of leaf:\n      self.user_likes[node].add(leaf.name.bow)\n```", "```py\nif it makes sense to score off user likes and not order frequencies:\n  return self.user_likes[parent].score(self.user_likes[child])\n```", "```py\nif it makes sense to score off user likes and not order frequencies:\n  return self.user_likes[parent].score(self.user_likes[child])\n```", "```py\n{ coors, light } and { light, beer } ⇒ light\n{ coors, beer } and { light, beer}   ⇒ beer\n```", "```py\nclass BagOfWords:\n\n  def _init_(self):\n    # Create self.bow\n    n = 0\n\n  def add(self, bow):\n    for word in bow:\n      self.bow[word] += bow[word]\n      n += bow[word]\n\n  def p(self, w):\n    return float(self.bow[w])/n\n\n  def score(self, user_bow):\n    words_in_common = set(user_bow.keys()) and set(self.bow.keys())\n    score = 0\n    for w in words_in_common:\n      score += user_bow[w]*log(self.p(w))\n    return score\n```", "```py\nclass UserInteractionsWithTaxonomy:\n\n  def __init__(self, taxonomy, taxonomy_model = None, uniform_acts = None):\n    …\n    self.taxonomy_model = taxonomy_model\n    self.uniform_acts   = uniform_acts\n    …\n\n  def score_using_user_preferences(self, child, parent):\n    user_score = self.user_likes[parent].score(self.user_likes[child])\n    uniform_score = self.uniform_acts.user_likes[parent].\n      score(self.user_likes[child])\n    return user_score - uniform_score\n\n  def score(self,child,parent, pcm = 1):\n    …\n    if it makes sense to score off user likes and not order frequencies:\n      return self.score_using_user_preferences(child, parent)\n    …\n```", "```py\nclass UserInteractionsWithTaxonomy:\n\n  def _init_(self, taxonomy):\n    …\n    …\n    self.user_likes[node] = BagOfWords()\n\n  def act(self, leaf):\n    …\n    for each node that is an ancestor of leaf:\n      self.user_likes[node].add(leaf.name.bow)\n\n  def score_using_user_preferences(self, child, parent):\n    user_score = self.user_likes[parent].score(self.user_likes[child])\n    uniform_score = self.uniform_acts.user_likes[parent].\n      score(self.user_likes[child])\n    return user_score - uniform_score \n```", "```py\nself.user_likes[node] = BagOfWords() ⇒\nself.user_likes[node] = UserLikes()\n\nself.user_likes[node].add(leaf.name.bow) ⇒\nself.user_likes[node].add(leaf)\n```", "```py\nclass UserLikes:\n\n  def __init__(self):\n    self.bow = BagOfWords()\n    # Additional attributes\n    self.prices = BagOfWords()\n\n  def add(self, leaf):\n    self.bow.add(leaf.name.bow)\n    self.prices.add(leaf.price.as_bow())\n\n  def score(self, user_likes):\n    # This needs some modeling discussion first.\n```", "```py\nclass UserLikes:\n\n  …\n\n  def score(self, user_likes):\n    return self.bow.score(user_likes.bow) + \n           self.prices.score(user_likes.prices)\n```", "```py\nsum_{w appears in both parent.user_likes.bow and in child.user_likes.bow}\nchild.user_likes.bow[w]*log(parent.user_likes.bow.p(w)\n+\nsum_{p appears in both parent.user_likes.prices and in child.user_likes.prices}\nchild.user_likes.prices[p]*log(parent.user_likes.prices.p(p)\n```", "```py\n(\n  sum_{w appears in both parent.user_likes.bow and in \n    child.user_likes.bow}\n    child.user_likes.bow[w]*log(parent.user_likes.bow.p(w)\n\n+\n\n  sum_{p appears in both parent.user_likes.prices and in \n    child.user_likes.prices}\n    child.user_likes.prices[p]*log(parent.user_likes.prices.p(p)\n)\n\n-\n\n(\n  sum_{w appears in both parent.uniform_user.user_likes.bow and in \n    child.uniform_user.user_likes.bow}\n    child.uniform_user.user_likes.bow[w]*log(parent.uniform_user.user_likes.bow.p(w)\n\n+\n\n  sum_{p appears in both parent.uniform_user.user_likes.prices and in \n    child.uniform_user.user_likes.prices}\n    child.uniform_user.user_likes.prices[p]*log(parent.uniform_user_likes.prices.p(p)\n)\n```", "```py\nCoors Light $5\n? Light     $8\n```", "```py\np appears in both parent.user_likes.prices and in child.user_likes.prices\n```", "```py\np is in the price ranges of both parent.user_likes.prices and of child.user_likes.prices\n```"]