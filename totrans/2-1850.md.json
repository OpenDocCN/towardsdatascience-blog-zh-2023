["```py\n# import necessary libraries\nimport tensorflow as tf\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport ssl\nssl._create_default_https_context = ssl._create_unverified_context\n\n# set random seed\nnp.random.seed(42)\n\n# load CIFAR-10 data\n(X_train, y_train), (X_test, y_test) = tf.keras.datasets.cifar10.load_data()\n\n# check data size\nassert X_train.shape == (50000, 32, 32, 3)\nassert X_test.shape == (10000, 32, 32, 3)\nassert y_train.shape == (50000, 1)\nassert y_test.shape == (10000, 1)\n\n# combine data first - we will generate test set later.\nX = np.concatenate([X_train,X_test],axis=0)\ny = np.concatenate([y_train,y_test],axis=0)\ny = np.squeeze(y)\n\nassert X.shape == (60000, 32, 32, 3)\nassert y.shape == (60000,)\n\n# check number of data in each class\nunique, counts = np.unique(y,return_counts=True)\nnp.asarray([unique,counts]).T\n```", "```py\n# Plot Class N (0-9)\n\nTARGET = # Class index here\nNUM_ARRAYS = 10\n\narrays = X[np.where(y==TARGET)]\nrandom_arrays_indices = np.random.choice(len(arrays),NUM_ARRAYS)\nrandom_arrays = arrays[random_arrays_indices]\n\nfig = plt.figure(figsize=[NUM_ARRAYS,4])\nplt.title('Class 0: Plane',fontsize = 15)\nplt.axis('off')\n\nfor index in range(NUM_ARRAYS):\n     fig.add_subplot(2, int(NUM_ARRAYS/2), index+1)\n     plt.imshow(random_arrays[index])\n```", "```py\n# initialize triplets array\ntriplets = np.empty((0,3,32,32,3),dtype=np.uint8)\n\n# get triplets for each class\nfor target in range(10):\n\n    locals()['arrays_'+str(target)] = X[np.where(y==target)].reshape(3000,2,32,32,3)\n    locals()['arrays_not_'+str(target)] = X[np.where(y!=target)]\n\n    random_indices = np.random.choice(len(locals()['arrays_not_'+str(target)]),3000)\n    locals()['arrays_not_'+str(target)] = locals()['arrays_not_'+str(target)][random_indices]\n\n    locals()['arrays_'+str(target)] = np.concatenate(\n        [\n            locals()['arrays_'+str(target)],\n            locals()['arrays_not_'+str(target)].reshape(3000,1,32,32,3)\n        ],\n        axis = 1\n    )\n\n    triplets = np.concatenate([triplets,locals()['arrays_'+str(target)]],axis=0)\n\n# check triplets size\nassert triplets.shape == (30000,3,32,32,3)\n\n# plot triplets array to visualize\nTEST_SIZE = 5\nrandom_indices = np.random.choice(len(triplets),TEST_SIZE)\n\nfig = plt.figure(figsize=[5,2*TEST_SIZE])\nplt.title('ANCHOR | POSITIVE | NEGATIVE',fontsize = 15)\nplt.axis('off')\n\nfor row,i in enumerate(range(0,TEST_SIZE*3,3)):\n    for j in range(1,4):\n        fig.add_subplot(TEST_SIZE, 3, i+j)\n        random_index = random_indices[row]\n        plt.imshow(triplets[random_index,j-1])\n\n# save triplet array\nnp.save('triplets_array.npy',triplets)\n```", "```py\n# Import all libraries\n\nimport tensorflow as tf\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom tensorflow.keras.applications import MobileNetV2\nfrom tensorflow.keras import Input, optimizers, Model\nfrom tensorflow.keras.layers import Layer, Lambda\nfrom tensorflow.keras.optimizers import Adam\nfrom tensorflow.keras import backend as K\nfrom tensorflow.keras.callbacks import EarlyStopping\nfrom tensorflow.keras.utils import plot_model\n\nfrom sklearn.metrics import precision_recall_curve, roc_curve, roc_auc_score\nfrom sklearn.model_selection import train_test_split\n\nfrom scipy import spatial\n```", "```py\ntriplets = np.load('triplets_array.npy')\n\ntriplets = triplets/255 #normalize by 255\nlabels = np.ones(len(triplets)) #create a fixed label\n\nassert triplets.shape == (30000,3,32,32,3)\n```", "```py\n# Split data into our train and test set\n\nX_train, X_test, y_train, y_test = train_test_split(\n    triplets,\n    labels,\n    test_size=0.05,\n    random_state=42\n)\n```", "```py\n# Load pretrained model for transfer learning\n\npretrained_model = MobileNetV2(\n    weights='imagenet', \n    include_top=False, \n    input_shape=(32,32,3)\n)\n\nfor layer in pretrained_model.layers:\n    layer.trainable = True\n```", "```py\n# Initialize functions for Lambda Layer\n\ndef cosine_distance(x,y):\n    x = K.l2_normalize(x, axis=-1)\n    y = K.l2_normalize(y, axis=-1)\n    distance = 1 - K.batch_dot(x, y, axes=-1)\n    return distance\n\ndef triplet_loss(templates, margin=0.4):\n\n    anchor,positive,negative = templates\n\n    positive_distance = cosine_distance(anchor,positive)\n    negative_distance = cosine_distance(anchor,negative)\n\n    basic_loss = positive_distance-negative_distance+margin\n    loss = K.maximum(basic_loss,0.0)\n\n    return loss\n```", "```py\n# Adopting the TensorFlow Functional API\n\nanchor = Input(shape=(32, 32,3), name='anchor_input')\nA = pretrained_model(anchor)\n\npositive = Input(shape=(32, 32,3), name='positive_input')\nP = pretrained_model(positive)\n\nnegative = Input(shape=(32, 32,3), name='negative_input')\nN = pretrained_model(negative)\n\nloss = Lambda(triplet_loss)([A, P, N])\n\nmodel = Model(inputs=[anchor,positive,negative],outputs=loss)\n```", "```py\n# Create a custom loss function since there are no ground truths label\n\ndef identity_loss(y_true, y_pred):\n    return K.mean(y_pred)\n\nmodel.compile(loss=identity_loss, optimizer=Adam(learning_rate=1e-4))\n\ncallbacks=[EarlyStopping(\n    patience=2, \n    verbose=1, \n    restore_best_weights=True,\n    monitor='val_loss'\n    )]\n\n# view model\nplot_model(model, show_shapes=True, show_layer_names=True, to_file='siamese_triplet_loss_model.png')\n```", "```py\n# Start training - y_train and y_test are dummy\n\nmodel.fit(\n    [X_train[:,0],X_train[:,1],X_train[:,2]],\n    y_train,\n    epochs=50, \n    batch_size=64,\n    validation_data=([X_test[:,0],X_test[:,1],X_test[:,2]],y_test),\n    callbacks=callbacks\n)\n```", "```py\nX_test_anchor = X_test[:,0]\nX_test_positive = X_test[:,1]\nX_test_negative = X_test[:,2]\n\n# extract the CNN model for inference\nsiamese_model = model.layers[3]\n\nX_test_anchor_template = np.squeeze(siamese_model.predict(X_test_anchor))\nX_test_positive_template = np.squeeze(siamese_model.predict(X_test_positive))\nX_test_negative_template = np.squeeze(siamese_model.predict(X_test_negative))\n\ny_test_targets = np.concatenate([np.ones((len(X_test),)),np.zeros((len(X_test),))])\n```", "```py\n# Get predictions in angular similarity scores\n\ndef angular_similarity(template1,template2):\n\n    score = np.float32(1-np.arccos(1-spatial.distance.cosine(template1,template2))/np.pi)\n\n    return score\n\ny_predict_targets = []\n\nfor index in range(len(X_test)):\n    similarity = angular_similarity(X_test_anchor_template[index],X_test_positive_template[index])\n    y_predict_targets.append(similarity)\n\nfor index in range(len(X_test)):\n    similarity = angular_similarity(X_test_anchor_template[index],X_test_negative_template[index])\n    y_predict_targets.append(similarity)\n```", "```py\n# Get prediction results with ROC Curve and AUC scores\n\nfpr, tpr, thresholds = roc_curve(y_test_targets, y_predict_targets)\n\nfig = plt.figure(figsize=[10,7])\nplt.plot(fpr, tpr,lw=2,label='UnoFace_v2 (AUC={:.3f})'.format(roc_auc_score(y_test_targets, y_predict_targets)))\nplt.plot([0,1],[0,1],c='violet',ls='--')\nplt.xlim([-0.05,1.05])\nplt.ylim([-0.05,1.05])\nplt.legend(loc=\"lower right\",fontsize=15)\n\nplt.xlabel('False positive rate')\nplt.ylabel('True positive rate')\nplt.title('Receiver Operating Characteristic (ROC) Curve',weight='bold',fontsize=15)\n```", "```py\n# Getting Test Pairs and their Corresponding Predictions\n\npositive_comparisons = X_test[:,[0,1]]\nnegative_comparisons = X_test[:,[0,2]]\n\npositive_predict_targets = np.array(y_predict_targets)[:1500]\nnegative_predict_targets = np.array(y_predict_targets)[1500:]\n\nassert positive_comparisons.shape == (1500,2,32,32,3)\nassert negative_comparisons.shape == (1500,2,32,32,3)\n\nassert positive_predict_targets.shape == (1500,)\nassert negative_predict_targets.shape == (1500,)\n\nnp.random.seed(21)\nNUM_EXAMPLES = 5\nrandom_index = np.random.choice(range(len(positive_comparisons)),NUM_EXAMPLES)\n```", "```py\n# Plotting Similarity Scores for Positive Comparisons \n# (Switch values and input to plot for Negative Comparisons)\n\nplt.figure(figsize=(10,4))\nplt.title('Positive Comparisons and Their Similarity Scores')\nplt.ylabel('Anchors')\nplt.yticks([])\nplt.xticks([32*x+16 for x in range(NUM_EXAMPLES)], ['.' for x in range(NUM_EXAMPLES)])\nfor i,t in enumerate(plt.gca().xaxis.get_ticklabels()):\n    t.set_color('green') \nplt.grid(None)\nanchor = np.swapaxes(positive_comparisons[:,0][random_index],0,1)\nanchor = np.reshape(anchor,[32,NUM_EXAMPLES*32,3])\nplt.imshow(anchor)\n\nplt.figure(figsize=(10,4))\nplt.ylabel('Positives')\nplt.yticks([])\nplt.xticks([32*x+16 for x in range(NUM_EXAMPLES)], positive_predict_targets[random_index])\nfor i,t in enumerate(plt.gca().xaxis.get_ticklabels()):\n    t.set_color('green') \nplt.grid(None)\npositive = np.swapaxes(positive_comparisons[:,1][random_index],0,1)\npositive = np.reshape(positive,[32,NUM_EXAMPLES*32,3])\nplt.imshow(positive)\n```"]