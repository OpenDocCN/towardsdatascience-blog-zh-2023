- en: 4 Easy-to-Implement, High-Impact Tweaks for Supercharging Your Python Code’s
    Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/4-easy-to-implement-high-impact-tweaks-for-supercharging-your-python-codes-performance-eb0652d942b7](https://towardsdatascience.com/4-easy-to-implement-high-impact-tweaks-for-supercharging-your-python-codes-performance-eb0652d942b7)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How to detect, understand, and eliminate bottlenecks in Python for a 1500x speed
    increase
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://mikehuls.medium.com/?source=post_page-----eb0652d942b7--------------------------------)[![Mike
    Huls](../Images/8f9f55a0d25db00799c5d37383b7f5b6.png)](https://mikehuls.medium.com/?source=post_page-----eb0652d942b7--------------------------------)[](https://towardsdatascience.com/?source=post_page-----eb0652d942b7--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----eb0652d942b7--------------------------------)
    [Mike Huls](https://mikehuls.medium.com/?source=post_page-----eb0652d942b7--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----eb0652d942b7--------------------------------)
    ·12 min read·Jul 12, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/63a41aba468ec040a3d1aa42518c8082.png)'
  prefs: []
  type: TYPE_IMG
- en: You Python code after this article (image by [SpaceX](https://unsplash.com/@spacex)
    on [Unsplash](https://unsplash.com/photos/-p-KCm6xB9I))
  prefs: []
  type: TYPE_NORMAL
- en: My philosophy centers around attempting simple solutions before resorting to
    complex ones. By exploring the easy methods in this article, you may find the
    performance increase you need, sparing yourself the intricacies and countless
    hours required for implementing and debugging multiprocesssing, threads or packages
    written in another language.
  prefs: []
  type: TYPE_NORMAL
- en: In this article we’ll delve into the tools and 4 methods of speeding up any
    Python code using **minimal**, **easy-to-implement techniques**. We’ll analyze
    our code, detect bottlenecks and fix them in a structured way. We’ll do this by
    **decreasing the amount of work** Python it has to do.
  prefs: []
  type: TYPE_NORMAL
- en: If you have to cross a certain distance as quickly as possible you can either
    drive faster or shorten your path. Similarly, instead of having Python perform
    a lot of operations faster, you can also reduce the number of operations.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Ultimately, you will gain a deeper understanding of code performance, acquire
    valueable skills in code analysis to avoid bottlenecks during development and
    be a better developer. Let’s code!
  prefs: []
  type: TYPE_NORMAL
- en: Contents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are analyzing our problem in three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Ain **part A** we define what we mean by performance and discuss the profiler,
    which we’ll use in the next part to measure our code.
  prefs: []
  type: TYPE_NORMAL
- en: B **Part B** revolves around using tools to **spot the bottleneck**. We **measure**
    our code and spot performance bottlenecks. We use a practical example to understand
    why our function underperforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'C in **Part C** we discuss ways to eliminate bottlenecks. In the previous parts
    we’ve learnt how to detect problem-code and analyze it so we know the cause of
    the slowdown. In this part we **discuss strategies for performance increase**:'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right data structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eliminating slow-running code (like nested loops)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: using built-in functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the end you’ll be able to apply these general strategies to any piece of
    code.
  prefs: []
  type: TYPE_NORMAL
- en: A. About performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s first get some definitions and preparation out of the way.
  prefs: []
  type: TYPE_NORMAL
- en: 1\. What is performance?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we are trying to optimize the performance of our code, first we need
    a clear definition about what we mean when we talk about performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Performance: the amount of useful work accomplished estimated in terms of
    time needed, resources used, etc](https://en.wiktionary.org/wiki/performance)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For brevity, I’ve chosen to monitor the execution speed of a function in this
    article. Memory usage and size is relevant as well but I’ve chosen to omit it
    to keep this article a bit shorter.
  prefs: []
  type: TYPE_NORMAL
- en: '[](/using-multi-stage-builds-to-make-your-docker-image-almost-10x-smaller-239068cb6fb0?source=post_page-----eb0652d942b7--------------------------------)
    [## Using multi-stage builds to make your docker image 10x smaller'
  prefs: []
  type: TYPE_NORMAL
- en: Clean up your Docker images by leaving behind unnecessary tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/using-multi-stage-builds-to-make-your-docker-image-almost-10x-smaller-239068cb6fb0?source=post_page-----eb0652d942b7--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 2\. How to measure performance?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python has a very handy tool built in called the `cProfile` . This package provides
    *deterministic profiling* of Python programs. This means that precise timings
    are made for the intervals between *all* function calls, function returns and
    exception events. This differs from *statistical profiling*, which uses random
    samples to deduce relative indications of where time is being spent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `cProfile` is really easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A quick explanation about the columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ncalls**: number of calls'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**tottime**: total time spent in the given function (excl. subfunctions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**percall**: tottime / ncalls'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**cumtime**: cumulative time spent in this function and all subfunctions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**percall**: cumtime / primitive calls'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**last column**: location -> functionname at linenumer in filename'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you see `cProfile` provides us with an easy-to-use tool to check the performance
    of our code. Let’s now focus on how to actually improve our Python code.
  prefs: []
  type: TYPE_NORMAL
- en: '[](/create-a-python-package-with-super-fast-rust-code-in-3-steps-a27389629beb?source=post_page-----eb0652d942b7--------------------------------)
    [## Create a Python Package with Super- Fast Rust Code in 3 Steps'
  prefs: []
  type: TYPE_NORMAL
- en: Extend you Python code with a package containing Rust code for a >150x performance
    increase!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/create-a-python-package-with-super-fast-rust-code-in-3-steps-a27389629beb?source=post_page-----eb0652d942b7--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 'B. Profiling: spotting and understanding bottlenecks'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s start out with some code that needs optimizing. As an example we’ll use
    a function that does a very simple thing: it takes two lists and returns *how
    many distinct items are present in both lists (case-insensitive)*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s check out this (on purpose super-sub-optimal) function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This function is clearly not a smart way to solve our problem but it will really
    nicely demonstrate how we can use `cProfile` to spot bottlenecks.
  prefs: []
  type: TYPE_NORMAL
- en: '[](/python-args-kwargs-and-all-other-ways-to-pass-arguments-to-your-function-bd2acdce72b5?source=post_page-----eb0652d942b7--------------------------------)
    [## Python args, kwargs, and All Other Ways to Pass Arguments to Your Function'
  prefs: []
  type: TYPE_NORMAL
- en: Expertly design your function parameters in 6 examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/python-args-kwargs-and-all-other-ways-to-pass-arguments-to-your-function-bd2acdce72b5?source=post_page-----eb0652d942b7--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Profiling our function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we use `cProfile` on our function, this is the result when we pass two
    lists that both contain 1,000 five-letter words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we execute a little over 2 million function calls in a little over
    half a second. Let’s first add this time to our bechmark so we have something
    to compare with later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 2\. Spotting bottlenecks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most important line is the bottom one; here we see that we call the `upper`
    method roughly **2 million times**. This is because we compare each item in list1
    with each item in list 2.
  prefs: []
  type: TYPE_NORMAL
- en: Both items need to be *stringified* and *upper-cased* in order to be compared.
    Since both lists are 1K items long this means that we must perform 1 million comparisons
    (1000x1000). The problem in this is that we `upper` both item1 and item2 a million
    times.
  prefs: []
  type: TYPE_NORMAL
- en: This means that in the best case at least `upper` will be **called 2 million**
    times. If items match there will be additional ones to check for their presense
    in the `duplicates` list and appending them (this is why there are 2,000,002 and
    not 2,000,000).
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Why is this slow?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python is loved for its ease-of-use but this comes with a downside. Under the
    hood Python memory allocation is much slower than other programming languages
    like C (in which Python is written).
  prefs: []
  type: TYPE_NORMAL
- en: '[](/why-is-python-so-slow-and-how-to-speed-it-up-485b5a84154e?source=post_page-----eb0652d942b7--------------------------------)
    [## Why Python is so slow and how to speed it up'
  prefs: []
  type: TYPE_NORMAL
- en: Take a look under the hood to see where Python’s bottlenecks lie
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/why-is-python-so-slow-and-how-to-speed-it-up-485b5a84154e?source=post_page-----eb0652d942b7--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 'Since [**strings in Python are immutable**](https://mikehuls.medium.com/python-quirks-understand-how-a-variable-can-be-modified-by-a-function-that-doesnt-return-anything-343a40cc6923),
    under the hood **a new variable** is created every time you `uppercase` . For
    all of these variables memory has to be **allocated**, which Python does **relatively
    slow**. When you then do this 2 million times you’ll start to notice the slowdown.
    Read more about Python’s design in the article above or watch this presentation
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: C. Eliminating bottlenecks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have spotted our bottleneck it’s time to speed up our code. Remember
    that our **goal** is to **make Python do less work**.
  prefs: []
  type: TYPE_NORMAL
- en: '[](/python-quirks-understand-how-a-variable-can-be-modified-by-a-function-that-doesnt-return-anything-343a40cc6923?source=post_page-----eb0652d942b7--------------------------------)
    [## Python Quirks: Understand How a Variable Can Be Modified by a Function That
    Doesn’t Return Anything'
  prefs: []
  type: TYPE_NORMAL
- en: A deep dive into how Python passes arguments and mutability to prevent unexpected
    bugs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/python-quirks-understand-how-a-variable-can-be-modified-by-a-function-that-doesnt-return-anything-343a40cc6923?source=post_page-----eb0652d942b7--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Make Python do less work — understand your code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One easy way to do less is to **uppercase each item** in the list **before
    looping** since we don’t care about the casing anyway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you see we first uppercase each item in each list. When we profile our code
    again we see that this simple change brought the number of function calls **down
    from roughly 2 million to roughly 2 thousand**. This is because now we have to
    uppercase each item in list1 **and** in list2 (1k + 1k = 2k).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We call the `upper` and `str` functions 1,000x fewer leading to a nice performance
    increase; **execution time decreased by 28x** from 523ms to 18ms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Also notice that I’ve replaced the duplicates list with a set so we don’t need
    to check if the item is already contained. Using sets will take even more work
    out of Python’s hands since sets only contain unique values by default.
  prefs: []
  type: TYPE_NORMAL
- en: '[](/args-vs-kwargs-which-is-the-fastest-way-to-call-a-function-in-python-afb2e817120?source=post_page-----eb0652d942b7--------------------------------)
    [## Args vs kwargs: which is the fastest way to call a function in Python?'
  prefs: []
  type: TYPE_NORMAL
- en: A clear demonstration of the timeit module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/args-vs-kwargs-which-is-the-fastest-way-to-call-a-function-in-python-afb2e817120?source=post_page-----eb0652d942b7--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Avoid nested loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another easy to spot bottleneck is the fact that we loop over each item in list2
    for each item in list 1\. If both lists contain 10 items this comes down to (10
    x 10=) 100 comparisons. If both lists contain 1000 items we have to do 1 million
    comparisons. You see how the number of comparisons increases exponentially relative
    to the number of inputs and how this quickly escalates our performance problems.
    *Read more about* [***Big-O notation***](https://en.wikipedia.org/wiki/Big_O_notation)*for
    more information.*
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of looping twice and comparing items we can also implement the code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example we only loop through `list_1` and check if `list_2` contains
    that value. Let’s check out the benchmark:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With two simple changes we’ve increased performance a lot but there’s a way
    to increase performance even more.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Use the right data structure— Deduplicating the lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to save even more work we can de-duplicate both lists since this brings
    down the number of comparisons we have to perform. We’ll take a short detour to
    think about a function to de-duplicate our lists. Then we’ll integrate this into
    our list-comparison-function. The first function you might come up with could
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing too special; it just goes through every item in the list and puts it
    into another list if it isn’t already in there. The bulk of the work of this function
    is in checking if a value is present in a list for deduplication purposes. If
    we take a list of **100,000 words** the function takes a **little over a minute**
    to complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[](/applying-python-multiprocessing-in-2-lines-of-code-3ced521bac8f?source=post_page-----eb0652d942b7--------------------------------)
    [## Applying Python multiprocessing in 2 lines of code'
  prefs: []
  type: TYPE_NORMAL
- en: When and how to use multiple cores to execute many times faster
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/applying-python-multiprocessing-in-2-lines-of-code-3ced521bac8f?source=post_page-----eb0652d942b7--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s **optimize** this function to use **set**s: a dataset can only contain
    unique values. This way we don’t have to let Python check if a value is already
    present in a collection; this now gets handled by the set. fter rewriting we end
    up with a more easily readable and better performing function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you see we use a set comprehension to loop through each item in the list.
    After this is done we end up with a set that contains only unique, uppercase values
    of our list. Before returning we cast it to a list. When we compare this new function
    to the old we see that it’s **over 2,800x faster!**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The reason sets are this much faster is becasue they are implemented in C (in
    which Python itself is also written). Since it’s memory is also managed by C,
    which is much more efficient. In addition the set is unordered and can only contain
    unique values, saving a lot of operations checking and ordering the items. This,
    again, takes **more work out of Python’s hands**, **increasing performance**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s implement the set in our list-matching-function and benchmark:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As you see the lists now first get deduplicated. When we benchmark we see a
    **huge performance increase**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Our function completes in **half a millisecond** instead of half a second. Still
    we might have one more trick up our sleeve for the next part
  prefs: []
  type: TYPE_NORMAL
- en: '[](/5-real-handy-python-decorators-for-analyzing-debugging-your-code-c22067318d47?source=post_page-----eb0652d942b7--------------------------------)
    [## 5 real handy python decorators for analyzing/debugging your code'
  prefs: []
  type: TYPE_NORMAL
- en: Apply these handy, general-purpose decorators directly to your code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/5-real-handy-python-decorators-for-analyzing-debugging-your-code-c22067318d47?source=post_page-----eb0652d942b7--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Using data structure functions — set intersection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One last optimization that we can add is to skip looping altogether and use
    the set’s `intersection` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As you see we end up with a nicely readable, compact function. The `intersection`
    methods returns as set of items that are present in both `set_1` and `set_2`.
    Lastly we return the length of this set. Let’s add this to our benchmark and see
    the final results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Not only is our final function a lot more readable, it’s also almost 1500x faster
    than what we started with.
  prefs: []
  type: TYPE_NORMAL
- en: '[](/cython-for-data-science-6-steps-to-make-this-pandas-dataframe-operation-over-100x-faster-1dadd905a00b?source=post_page-----eb0652d942b7--------------------------------)
    [## 6 Steps to Make this Pandas Dataframe Operation 100 Times Faster'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cython for Data Science: Combine Pandas with Cython for an incredible speed
    improvement'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/cython-for-data-science-6-steps-to-make-this-pandas-dataframe-operation-over-100x-faster-1dadd905a00b?source=post_page-----eb0652d942b7--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Further optimization?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Maybe you’ve gone through all of these steps and your code performance is still
    not good enough. Then there is the option to apply [**multi-processing**](https://mikehuls.medium.com/applying-python-multiprocessing-in-2-lines-of-code-3ced521bac8f),
    [**threads**](https://mikehuls.medium.com/thread-your-python-program-with-two-lines-of-code-3b474407dbb8)
    or even re-write a (part of a) function in a more optimized language like [**C**](https://mikehuls.medium.com/write-your-own-c-extension-to-speed-up-python-x100-626bb9d166e7),
    [**Rust**](https://mikehuls.medium.com/create-a-python-package-with-super-fast-rust-code-in-3-steps-a27389629beb)
    or [**Cython**](https://mikehuls.medium.com/cython-for-absolute-beginners-30x-faster-code-in-two-simple-steps-bbb6c10d06ad).
    The goal of this article was to not reach for the big guns right away but first
    squeeze out every little drop of performance that Python can offer. If further
    optimization is required the methods in this article will make it even faster.
  prefs: []
  type: TYPE_NORMAL
- en: '[](/advanced-multi-tasking-in-python-applying-and-benchmarking-threadpools-and-processpools-90452e0f7d40?source=post_page-----eb0652d942b7--------------------------------)
    [## Advanced multi-tasking in Python: Applying and benchmarking thread pools and
    process pools in 6…'
  prefs: []
  type: TYPE_NORMAL
- en: Safely and easily apply multi-tasking to your code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/advanced-multi-tasking-in-python-applying-and-benchmarking-threadpools-and-processpools-90452e0f7d40?source=post_page-----eb0652d942b7--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this article we’ve gone through a very practical example of **spotting**,
    **understanding** and **eliminating performance bottlenecks**. We’ve seen that
    you don’t have to make complex, structural changes to your code right away; sometimes
    easy, small, easy-to-implement changes can optimize your code a lot. When this
    is not enough there is always the option of using threads, multiple processes
    or writing a Python package in a compile language anyway.
  prefs: []
  type: TYPE_NORMAL
- en: I think the most important part is to truly understand your code, understand
    how Python works and where it is less performant and apply the right data structures.
    For this, check out my [**other articles here**](https://mikehuls.com/articles?tags=fast)or
    this [**this presentation**](https://www.youtube.com/watch?v=N7cgUnW-tZQ).
  prefs: []
  type: TYPE_NORMAL
- en: 'I hope this article was as clear as I hope it to be but if this is not the
    case please let me know what I can do to clarify further. In the meantime, check
    out my [other articles](https://mikehuls.com/articles) on all kinds of programming-related
    topics like these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Git for absolute beginners: understanding Git with the help of a video game](https://mikehuls.medium.com/git-for-absolute-beginners-understanding-git-with-the-help-of-a-video-game-88826054459a)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Create and publish your own Python package](https://mikehuls.medium.com/create-and-publish-your-own-python-package-ea45bee41cdc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Create a fast auto-documented, maintainable, and easy-to-use Python API in
    5 lines of code with FastAPI](https://mikehuls.medium.com/create-a-fast-auto-documented-maintainable-and-easy-to-use-python-api-in-5-lines-of-code-with-4e574c00f70e)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Happy coding!
  prefs: []
  type: TYPE_NORMAL
- en: — Mike
  prefs: []
  type: TYPE_NORMAL
- en: '*P.S: like what I’m doing?* [*Follow me!*](https://mikehuls.medium.com/membership)'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://mikehuls.medium.com/membership?source=post_page-----eb0652d942b7--------------------------------)
    [## Join Medium with my referral link — Mike Huls'
  prefs: []
  type: TYPE_NORMAL
- en: Read every story from Mike Huls (and thousands of other writers on Medium).
    Your membership fee directly supports Mike…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: mikehuls.medium.com](https://mikehuls.medium.com/membership?source=post_page-----eb0652d942b7--------------------------------)
  prefs: []
  type: TYPE_NORMAL
