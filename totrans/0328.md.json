["```py\ninertia = []\n\nfor k in range(1, 14):\n  inertia.append(KMeans(n_clusters=k).inertia_)\n```", "```py\nfrom kneed import KneeLocator\n\nk_elbow = KneeLocator(\n  x=range(1, 14), \n  y=inertia, \n  curve=\"convex\", \n  direction=\"decreasing\").elbow\n```", "```py\ndef bic_score(X, labels):\n  \"\"\"\n  BIC score for the goodness of fit of clusters.\n  This Python function is directly translated from the GoLang code made by the author of the paper. \n  The original code is available here: https://github.com/bobhancock/goxmeans/blob/a78e909e374c6f97ddd04a239658c7c5b7365e5c/km.go#L778\n  \"\"\"\n\n  n_points = len(labels)\n  n_clusters = len(set(labels))\n  n_dimensions = X.shape[1]\n\n  n_parameters = (n_clusters - 1) + (n_dimensions * n_clusters) + 1\n\n  loglikelihood = 0\n  for label_name in set(labels):\n    X_cluster = X[labels == label_name]\n    n_points_cluster = len(X_cluster)\n    centroid = np.mean(X_cluster, axis=0)\n    variance = np.sum((X_cluster - centroid) ** 2) / (len(X_cluster) - 1)\n    loglikelihood += \\\n      n_points_cluster * np.log(n_points_cluster) \\\n      - n_points_cluster * np.log(n_points) \\\n      - n_points_cluster * n_dimensions / 2 * np.log(2 * math.pi * variance) \\\n      - (n_points_cluster - 1) / 2\n\n  bic = loglikelihood - (n_parameters / 2) * np.log(n_points)\n\n  return bic\n```"]