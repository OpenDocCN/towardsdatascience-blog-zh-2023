- en: How to Get the Most Out of Your Quantum Bit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/how-to-get-the-most-out-of-your-quantum-bit-56d4dc535aa6](https://towardsdatascience.com/how-to-get-the-most-out-of-your-quantum-bit-56d4dc535aa6)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There’s more in a qubit than 0 and 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://pyqml.medium.com/?source=post_page-----56d4dc535aa6--------------------------------)[![Frank
    Zickert | Quantum Machine Learning](../Images/ae361c0d68d13dac21bb86c7496d2917.png)](https://pyqml.medium.com/?source=post_page-----56d4dc535aa6--------------------------------)[](https://towardsdatascience.com/?source=post_page-----56d4dc535aa6--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----56d4dc535aa6--------------------------------)
    [Frank Zickert | Quantum Machine Learning](https://pyqml.medium.com/?source=post_page-----56d4dc535aa6--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----56d4dc535aa6--------------------------------)
    ·7 min read·Jan 11, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: Do you want to get started with Quantum Machine Learning? Have a look at [**Hands-On
    Quantum Machine Learning With Python**](https://www.pyqml.com/volume1?provider=medium&origin=mostofqubit)**.**
  prefs: []
  type: TYPE_NORMAL
- en: Quantum computers are one of the most promising technologies of the 21st century.
    However, we are still in the early stages of research to figure out how to build
    reliable quantum computers on a large scale.
  prefs: []
  type: TYPE_NORMAL
- en: But quantum computers are no science fiction anymore. IBM, Google, Microsoft,
    Amazon, and many more companies have started initiatives to tap the potential
    of available quantum computers commercially.
  prefs: []
  type: TYPE_NORMAL
- en: Yet, the major challenge is the tiny number of quantum bits (qubits) of the
    current devices. While we can’t simply increase that number, we can change how
    we use the qubits.
  prefs: []
  type: TYPE_NORMAL
- en: This post proposes a new way to increase the amount of information we store
    in a qubit.
  prefs: []
  type: TYPE_NORMAL
- en: The qubit is in a state of superposition. This is a complex (as in complex numbers)
    linear relationship between its two basis states.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/404e41a8830212ae0356bdc1219619d1.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: It is not discrete but continuous. It has two dimensions, the real amplitude,
    and the phase. With a theoretically infinite accuracy, one could store an unlimited
    amount of data.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as you measure it, it is either 0 or 1\. The qubit loses its magic.
    It collapses to one of only two values.
  prefs: []
  type: TYPE_NORMAL
- en: This is a problem because when we ask a quantum for a solution, there can only
    be two possible answers. 0 or 1\. Yes or No. This limits the possibility of asking
    complicated questions.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when we aim to solve an optimization problem, we expect the system’s
    configuration that leads to the lowest cost as an answer. Therefore, we need a
    qubit for each part of the system configuration. But with the 27-qubit processors
    we can currently access, we can’t solve any problem that classical computers can’t
    solve.
  prefs: []
  type: TYPE_NORMAL
- en: When we look at the Traveling Salesman Problem, which requires n²
  prefs: []
  type: TYPE_NORMAL
- en: qubits and where n is the number of locations to visit, even the current 433-Osprey
    could only solve a problem with 21 locations.
  prefs: []
  type: TYPE_NORMAL
- en: If we are to take advantage of quantum computing in the foreseeable future,
    we need to make more of our qubits. We must not be so wasteful with the few qubits
    we have.
  prefs: []
  type: TYPE_NORMAL
- en: It wasn’t long ago that we had very few classical bits. So few that we stored
    the year of date with only two digits, which eventually caused the Y2K problem.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, being sparse with qubits may have downsides, but we’re not in a position
    where we have an abundance of qubits like we have with classical bits. So it’s
    time to recover scarcity awareness.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to extract more information from a qubit than just zero or one. In
    fact, a quantum computing technique recovers the invisible state: quantum state
    tomography.'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we measure a qubit under different observables, one for each of its
    three dimensions, and calculate the expectation value for each dimension. It allows
    us to create a density matrix that describes a complete picture of the system’s
    quantum state.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with state tomography is that the number of observables grows exponentially
    with the number of qubits. Since we have to run the circuit separately for each
    observable, this increases complexity exponentially. But avoiding such a scenario
    is the whole purpose of using a quantum computer in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there’s some light at the end of the tunnel.
  prefs: []
  type: TYPE_NORMAL
- en: We run our quantum circuits a few thousand times anyway because qubits are probabilistic.
    In this way, we want to find the most probable solution. However, as a by-product
    of these calculations, we get many answers that we do not use. However, looking
    only at the most likely result and ignoring the rest is a waste of resources.
  prefs: []
  type: TYPE_NORMAL
- en: This is especially true if we consider that the repeated execution of a circuit
    reveals much more information about the underlying quantum state. It allows us
    to calculate the expectation value. Even though this is still only a fraction
    of the entire quantum state, the expectation value is more detailed than the binary
    measurement yielding zero or one.
  prefs: []
  type: TYPE_NORMAL
- en: So if we look at the expectation value, we get a floating point between 0 and
    1\. The accuracy depends on the number of repetitions in the experiment. The more
    often we run the circuit, the more accurately we can give the number.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the following circuit yields one with a probability of 72.4%. Therefore,
    the expectation value is 0.724 (if we weigh the measurements). This is much more
    information than interpreting the result as “probably one.”
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/aa07334cf7f35ea76c5c15dbd6a14bf7.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: The caveat of this experiment is that we used the state vector simulator. This
    simulator calculates the exact quantum state. So there is no randomness at all.
    Unfortunately, we can only do this for very few qubits, and it does not apply
    to the results we would get with a real quantum computer.
  prefs: []
  type: TYPE_NORMAL
- en: The following example shows the same experiment using the QASM simulator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/85a11261e6696b4c3deaf5d1f84898ce.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: The `qasm_simulator` determines the measured values empirically. So the result
    is not entirely accurate. The higher the number of repetitions (specified by the
    shots parameter), the more precise the result becomes.
  prefs: []
  type: TYPE_NORMAL
- en: However, increasing the precision comes at the cost of executing the circuit
    more often. So, retrieving information using the expectation value is no free
    lunch.
  prefs: []
  type: TYPE_NORMAL
- en: Even worse, the qubits of a real quantum computer are prone to errors. The errors
    further blur the measurements. The following example adds such noise to the simulation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/7ba4e0eaece564391f48016b5ad34b57.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: When noise is present, the result deviates even further from the perfect result.
    And we haven’t even started working with the qubit yet. The more we work with
    the qubit, the more it is exposed to noise.
  prefs: []
  type: TYPE_NORMAL
- en: This inevitably leads to a loss of precision. However, in many cases, we do
    not need high accuracy for an answer. Coarse values are often sufficient. So we
    don’t need to know that the expected value is precisely 0.724, but it is good
    enough to see that it is around 0.7.
  prefs: []
  type: TYPE_NORMAL
- en: But what if we are not interested in a floating point but looking for a discrete
    answer?
  prefs: []
  type: TYPE_NORMAL
- en: Why don’t we interpret different expectation values as different discrete numbers?
    For example, we might interpret expectation values below 0.25 as 0, expectation
    values between 0.25 and 0.5 as 1, between 0.5 and 0.75 as 2, and above 0.75 as
    3\. So we would encode four discrete values in one qubit.
  prefs: []
  type: TYPE_NORMAL
- en: The following code shows how such a discretization works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the number of measurements, the discretization function also
    takes the number of blocks as a parameter. This indicates the number of different
    values as which the expected value is to be interpreted. Of course, we can choose
    any number of blocks. But the more numbers we encode in a qubit, the more prone
    it becomes to inaccuracies and noise.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I believe it is worthwhile to encode more than just two values in a qubit, especially
    when we are facing an extreme scarcity of qubits.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the few qubits we have are also prone to noise. Moreover, when
    we encode more than two values in a qubit, we rely even more on the correctness
    of the qubits. So the idea presented here is certainly a compromise.
  prefs: []
  type: TYPE_NORMAL
- en: Still, noise is something we can work with. It’s not easy, but we can get a
    handle on it. But we can only work with the available qubits. If that number is
    too small to represent a meaningful real-world problem, we simply cannot solve
    such problems.
  prefs: []
  type: TYPE_NORMAL
- en: So if we want to solve real-world problems, we have to make sure we have enough
    qubits, whatever tradeoff might be necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://pyqml.medium.com/membership?source=post_page-----56d4dc535aa6--------------------------------)
    [## Join Medium with my referral link - Frank Zickert | Quantum Machine Learning'
  prefs: []
  type: TYPE_NORMAL
- en: Get Started With Quantum Machine Learning (and get full access to every story
    on Medium) Get full access to all the…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: pyqml.medium.com](https://pyqml.medium.com/membership?source=post_page-----56d4dc535aa6--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Don’t miss the next episode, and subscribe to my [Substack channel](https://pyqml.substack.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Do you want to get started with Quantum Machine Learning? Have a look at [**Hands-On
    Quantum Machine Learning With Python**](https://www.pyqml.com/page?ref=medium_getmost&dest=%2F)**.**
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c3892c668b9d47f57e47f1e6d80af7b6.png)'
  prefs: []
  type: TYPE_IMG
- en: Get the first three chapters for free [here](https://www.pyqml.com/page?ref=medium_getmost&dest=%2F).
  prefs: []
  type: TYPE_NORMAL
