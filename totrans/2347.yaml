- en: When Are Songwriters Most Successful?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/when-are-songwriters-most-successful-9fdf90708e77](https://towardsdatascience.com/when-are-songwriters-most-successful-9fdf90708e77)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let’s find out with KDE plots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@lee_vaughan?source=post_page-----9fdf90708e77--------------------------------)[![Lee
    Vaughan](../Images/9f6b90bb76102f438ab0b9a4a62ffa3f.png)](https://medium.com/@lee_vaughan?source=post_page-----9fdf90708e77--------------------------------)[](https://towardsdatascience.com/?source=post_page-----9fdf90708e77--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----9fdf90708e77--------------------------------)
    [Lee Vaughan](https://medium.com/@lee_vaughan?source=post_page-----9fdf90708e77--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----9fdf90708e77--------------------------------)
    ·11 min read·Aug 22, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/91cfa91f27be316505c84cd95be8b058.png)'
  prefs: []
  type: TYPE_IMG
- en: A singer receiving a Grammy Award amid a flurry of confetti (created with the
    assistance of DALL-E2)
  prefs: []
  type: TYPE_NORMAL
- en: At what age are singer-songwriters most successful? I wondered this the other
    day when I heard an old Stevie Wonder song. My *impression* was that, like mathematicians,
    singer-songwriters peak in their mid-late 20s. But what does the *data* say?
  prefs: []
  type: TYPE_NORMAL
- en: In this *Quick Success Data Science* project, we’ll use Python, pandas, and
    the Seaborn plotting library to investigate this question. We’ll look at the careers
    of 16 prominent singer-songwriters with over 500 hits among them. We’ll also incorporate
    an attractive graphic known as the *kernel density estimate* plot into the analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Methodology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To determine when songwriters are most successful, we’ll need some guidelines.
    The plan is to examine:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Singer-songwriters including those who work with co-writers.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Singer-songwriters with decades-long careers.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A diverse selection of singer-songwriters and musical genres.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Singer-songwriters on the *Billboard Hot 100* chart.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [*Hot 100*](https://www.billboard.com/charts/hot-100/) is a weekly chart,
    published by *Billboard* magazine, that ranks the best-performing songs in the
    United States. The rankings are based on physical and digital sales, radio play,
    and online streaming. We’ll use it as a *consistent* and *objective* way to judge
    success.
  prefs: []
  type: TYPE_NORMAL
- en: The Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ll use songs written by the following highly successful artists:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/de6939ab9c5a5831a1d7f12872312682.png)'
  prefs: []
  type: TYPE_IMG
- en: List of singer-songwriters used in this project (all remaining images by the
    author).
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve recorded the age of each artist at the time of each of their hits and
    saved it as a CSV file stored on this [Gist](https://gist.github.com/rlvaugh/c3bd6aa921e7a7d930a220f565c25208).
    If they had multiple hits in the same year, their age entry was repeated for each
    hit. Here’s a glimpse at the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/03e8a8ebe71c905b25db9125169aca9c.png)'
  prefs: []
  type: TYPE_IMG
- en: The first few rows of the CSV file.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-referencing this information is tedious (ChatGPT refused to do it!). Consequently,
    a few hits written by these artists but performed by others may have been inadvertently
    excluded.
  prefs: []
  type: TYPE_NORMAL
- en: Kernel Density Estimate Plots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *kernel density estimate plot* is a method — similar to a histogram — for
    visualizing the distribution of data points. While a histogram bins and counts
    observations, a KDE plot *smooths* the observations using a Gaussian kernel. This
    produces a *continuous density estimate* where the y-values are normalized so
    that the total area under the curve equals one.
  prefs: []
  type: TYPE_NORMAL
- en: The following figure compares the two methods. How well they capture the underlying
    data depends on how the histogram is binned and how the KDE plot is smoothed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/fe3fbc38146c8c8266afd5a085909cf9.png)'
  prefs: []
  type: TYPE_IMG
- en: A KDE plot (curve) vs. a histogram (bars) for a series of observations (dots).
  prefs: []
  type: TYPE_NORMAL
- en: Unlike histograms, which don’t differentiate where a sample falls *within* a
    bin, a KDE plot draws a small Gaussian bell curve over each individual sample.
    These bell curves are then summed together to form the final curve. This makes
    KDE plots wider than histograms, with an underlying assumption that the data extends
    smoothly toward the extremes. Thus, KDE plots won’t stop abruptly at zero, even
    if that’s a hard limit to the data.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e0c272631c4094c5159b0307a2f4a922.png)'
  prefs: []
  type: TYPE_IMG
- en: The final KDE curve is built from bell curves over each individual data point.
  prefs: []
  type: TYPE_NORMAL
- en: KDE plots use *bandwidth* for the kernel smoothing process. Selecting the *proper*
    bandwidth is both important and something of an art. The smaller the bandwidth,
    the more closely the KDE plot honors the underlying data. The wider the bandwidth,
    the more the data is averaged and smoothed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/fd94544ffff5824b904278da5e92ef24.png)'
  prefs: []
  type: TYPE_IMG
- en: Example of bandwidth smoothing in a KDE plot.
  prefs: []
  type: TYPE_NORMAL
- en: Narrow bandwidths can produce rugose curves that defeat the purpose of using
    a KDE plot in the first place. They can also introduce random noise artifacts.
    On the other hand, wide bandwidths (such as 2) can smooth *too much*, causing
    important features of the data distribution, like bimodality, to be lost.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/cba44316ea2d966049d6f05c76398405.png)'
  prefs: []
  type: TYPE_IMG
- en: The impact of applying different bandwidth adjustments to the final curve.
  prefs: []
  type: TYPE_NORMAL
- en: While the seaborn library’s `kdeplot()` method uses good defaults for generating
    plots, you'll probably want to play with the `bw_adjust` parameter to tune the
    KDE plot to the story you're trying to tell.
  prefs: []
  type: TYPE_NORMAL
- en: 'So why use a KDE plot when there’s a perfectly good histogram sitting right
    there? Here are some reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: KDE plots are less cluttered than histograms and much more readable when overlaying
    multiple distributions in a single figure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: KDE plots can let you see patterns in data (such as central tendency, bimodality,
    and skew) that may be obscured in a histogram view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar to [sparklines](https://en.wikipedia.org/wiki/Sparkline), KDE plots
    are good for “quick looks” and quality control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: KDE plots are arguably more attractive than histograms and make a better choice
    for infographics aimed at the general public.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: KDE plots facilitate easy comparisons between subsets of data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more on KDE plots, see the `kdeplot()` [docs](http://seaborn.pydata.org/generated/seaborn.kdeplot.html)
    and the [*Kernel density estimation* section](http://seaborn.pydata.org/tutorial/distributions.html#tutorial-kde)
    of seaborn’s visualization guide.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this project, we’ll need to install seaborn for plotting and pandas for
    data analysis. You can install these libraries as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With conda: `conda install pandas seaborn`'
  prefs: []
  type: TYPE_NORMAL
- en: 'With pip: `pip install pandas seaborn`'
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following code was written in JupyterLab and is described *by cell*.
  prefs: []
  type: TYPE_NORMAL
- en: Importing Libraries and Loading the Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After importing the libraries, we’ll select the seaborn “whitegrid” style so
    that our plots have a consistent look. We’ll then use pandas to read the CSV file.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using a virtual environment, note that NumPy and Matplotlib are *dependencies*
    of pandas, so there’s no need to install them independently.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Because some artists had more hits than others and DataFrames need to be rectangular,
    some columns will be assigned missing values. We’ll replace these `NaN` values
    with zeros using the `fillna()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/cb2c941bef30639c7b7ffa9c2f69fbcf.png)'
  prefs: []
  type: TYPE_IMG
- en: The head of the initial DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: Melting the DataFrame
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our DataFrame is currently in “wide” format. Every artist’s name is a column
    *header,* and their ages are the column *values*. Python’s plotting libraries
    tend to prefer “long” formats. This means that the artists’ names should be *row*
    values and should be repeated for each corresponding age.
  prefs: []
  type: TYPE_NORMAL
- en: For convenience, pandas includes a method called `melt()` that converts from
    wide to long format. The `var_name` argument is used to set a new column, called
    "Name," to hold our previous column names. The `value_name` argument indicates
    that the previous column values should now be under a column named "Age."
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we’ll add a new column named “Color,” which we’ll set to “red.”
    This is a handy way to group the data for later plotting. We’ll also filter out
    `Age` values equal to zero so that we can get an accurate count of hit songs per
    artist.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/e26f6f19ef8a872d1f9fbd7ffb348f55.png)'
  prefs: []
  type: TYPE_IMG
- en: The tail of the long format melted DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: Plotting the Number of Hits per Artist
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we’ll use pandas’ `value_counts()` method to count the number of *Hot
    100* hits per artist. As part of the process, we'll sort the data in descending
    order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/6011e7b456e7dd83b1e391fea19093cf.png)'
  prefs: []
  type: TYPE_IMG
- en: The number of *Hot 100* hits by each artist over their career.
  prefs: []
  type: TYPE_NORMAL
- en: Plotting Age at the Time of Last Hit and Total Time Between Hits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we’ll plot how old each artist was at the time of their last *Hot 100*
    hit, along with the time between the first and last appearance on the chart.
  prefs: []
  type: TYPE_NORMAL
- en: Since we’ll need to find each artist’s minimum age, we’ll first set 0 values
    in the `df` DataFrame to `NaN`, so they will be ignored. Otherwise, 0 would be
    picked as the minimum age. We won't sort the results as we want to compare charts
    side-by-side, and thus want the artist names to remain in the same order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/e5e0f9f5a5037f05990b7e8141a3b765.png)'
  prefs: []
  type: TYPE_IMG
- en: Comparison of each artist’s age at the time of their last hit with the timespan
    between hits.
  prefs: []
  type: TYPE_NORMAL
- en: Takeaways from these charts are that more than half of the artists charted all
    their hits before age 50 and charted over timespans of 30 years or less.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating Age Statistics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let’s find the age when the artists were most successful. Since a single
    statistic can’t necessarily capture this, we’ll use pandas’ `mean()`, `median()`,
    and `mode()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/5c474b52264002b72bfa705b3a59ec16.png)'
  prefs: []
  type: TYPE_IMG
- en: Of the 16 singer-songwriters under investigation, the successful “sweet spot”
    appears to be around 29–33 years old.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: An assumption in this analysis is that songs are written in the same
    year that they appear on the *Hot 100* chart. Because there’ll be a lag time between
    when the song is written and when it appears on the chart, there may be a slight
    bias to *older* ages in our statistics.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Finding the Success Sweet Spot Using a KDE Plot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A visual way to find the sweet spot is with a KDE plot. We’ll use seaborn’s
    `kdeplot()` method and pass it the melted DataFrame. We'll also set the `hue`
    argument to the "Color" column, which means it will ignore the artist's name and
    plot all the age values as a single group.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/1b958ec8bee1020dde2883d222c96567.png)'
  prefs: []
  type: TYPE_IMG
- en: A KDE plot of the “Age” column for all the artists.
  prefs: []
  type: TYPE_NORMAL
- en: This plot confirms what we learned earlier, that the greatest success peaks
    at just over 30 years. The blip after 70 years represents Paul McCartney’s collaboration
    with Kanye West in 2015 when McCartney was 73 years old.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Careers with a Facet Grid
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Facet grids* are ways to create *multiple* plots with *shared* axes that display
    *different* subsets of a dataset. We’re going to make a facet grid that uses KDE
    plots to compare each artist’s hit distribution.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by calling seaborn’s `FacetGrid()` method and passing it the melted
    DataFrame and its "Name" column. We'll want to compare *all* the artists with
    no distractions, so we'll use the same color, designated by the `hue` argument,
    for each curve. By setting the `col_wrap` argument to `2`, we split the display
    into 2 columns with 8 curves in each.
  prefs: []
  type: TYPE_NORMAL
- en: With the facet grid defined, we’ll call the `kdeplot()` method and map it to
    the facet grid, designated as the `g` variable. We'll set the bandwidth adjustment
    (`bw_adjust`) to `0.4` so that we don't smooth out all the variability in the
    data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/30b1aea8999a73fd08401d6fb815a498.png)'
  prefs: []
  type: TYPE_IMG
- en: A facet grid of each artist’s KDE plot.
  prefs: []
  type: TYPE_NORMAL
- en: What a wonderful chart! Sleek and packed with information. This is where KDE
    plots come into their own.
  prefs: []
  type: TYPE_NORMAL
- en: With just a glance you can see Sting’s early success with *The Police* followed
    by a successful solo career. Johnny Cash’s bimodal distribution mirrors his struggle
    with drug addiction. Paul Simon’s later career success with the *Graceland* album
    appears as a blip at age 45\. And, as we saw in our earlier analysis, most of
    the peaks tend to cluster around ages 29–34.
  prefs: []
  type: TYPE_NORMAL
- en: Plotting a Stacked KDE Plot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way to tell a story with KDE plots is to stack them in the same panel.
    This always works better than stacking histograms.
  prefs: []
  type: TYPE_NORMAL
- en: For our current project, there are too many artists for this to work well at
    an *individual* level. But since our goal is to highlight the “success sweet spot”
    for *all* artists, it does an adequate job.
  prefs: []
  type: TYPE_NORMAL
- en: To stack the KDE plots, we just need to call the `kdeplot()` method without
    using the facet grid. An important parameter here is `common_norm`, which stands
    for "common normalization."
  prefs: []
  type: TYPE_NORMAL
- en: According to seaborn's [documentation](https://seaborn.pydata.org/generated/seaborn.kdeplot.html),
    "When `common_norm` is set to `True`, all the KDE curves will be normalized together
    using the same scale. This can be useful when you want to compare the overall
    distribution shapes of different groups. It’s particularly helpful when you have
    multiple groups with different sample sizes or different ranges of values, as
    it ensures that the curves are directly comparable in terms of their shapes."
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We definitely have different sample sizes per artist and want to compare curves,
    so we’ll set `common_norm` to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/bcb18500819245d6a2e0651acec14cd7.png)'
  prefs: []
  type: TYPE_IMG
- en: Stacked KDE plots for each artist with common normalization set to “True”.
  prefs: []
  type: TYPE_NORMAL
- en: While it’s difficult if not impossible to identify the curve for specific artists
    (even if you use a different color per artist), it’s pretty clear that the optimum
    age is around 30 years.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re curious, here’s what the plot looks like with `common_norm` set to
    `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/82de6fabe90b8d990493abb602e59bed.png)'
  prefs: []
  type: TYPE_IMG
- en: Stacked KDE plots per artist with common normalization set to “False”.
  prefs: []
  type: TYPE_NORMAL
- en: Plotting a Distribution Plot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, let’s visualize the data as a *distribution plot*. Seaborn’s `displot()`
    method provides a figure-level interface for drawing distribution plots onto a
    seaborn `FacetGrid`. It lets you choose multiple plot types, such as KDEs and
    histograms, with the `kind` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Another nice feature is the inclusion of a "rug plot," added using the `rug`
    parameter. A rug plot marks the location of data points along an axis. This lets
    you see the limits of the actual data, which may be obscured by the "tails" of
    the KDE plot.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/3a524fb9c330cb8354bc0570c7972c04.png)'
  prefs: []
  type: TYPE_IMG
- en: A Distribution Plot including both KDE and rug plots (image by the author)
  prefs: []
  type: TYPE_NORMAL
- en: I personally find this plot difficult to parse, but it does highlight the peak
    success years around age 30.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: KDE plots, with their smooth, pleasing shapes, are a great way to visualize
    univariate data. While functionally similar to histograms, they make it easier
    to see patterns in the data and to stack and compare multiple distributions in
    the same figure.
  prefs: []
  type: TYPE_NORMAL
- en: With the aid of KDE plots, we were able to show that singer-songwriters are
    most successful around the age of 30\. So, if you want to start a career as a
    singer-songwriter, don’t put it off!
  prefs: []
  type: TYPE_NORMAL
- en: Thanks!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thanks for reading and please follow me for more *Quick Success Data Science*
    projects in the future.
  prefs: []
  type: TYPE_NORMAL
