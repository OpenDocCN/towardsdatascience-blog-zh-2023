- en: Anatomy of SQL Window Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQLçª—å£å‡½æ•°çš„ç»“æ„
- en: åŸæ–‡ï¼š[https://towardsdatascience.com/anatomy-of-sql-window-functions-7256d8cf509a](https://towardsdatascience.com/anatomy-of-sql-window-functions-7256d8cf509a)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://towardsdatascience.com/anatomy-of-sql-window-functions-7256d8cf509a](https://towardsdatascience.com/anatomy-of-sql-window-functions-7256d8cf509a)
- en: Back To Basics | SQL fundamentals for beginners
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å›åˆ°åŸºç¡€ | SQLåˆå­¦è€…åŸºç¡€
- en: '[](https://iffatm.medium.com/?source=post_page-----7256d8cf509a--------------------------------)[![Iffat
    Malik](../Images/7be3b651053507de2077b3c3c9d3a408.png)](https://iffatm.medium.com/?source=post_page-----7256d8cf509a--------------------------------)[](https://towardsdatascience.com/?source=post_page-----7256d8cf509a--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----7256d8cf509a--------------------------------)
    [Iffat Malik](https://iffatm.medium.com/?source=post_page-----7256d8cf509a--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://iffatm.medium.com/?source=post_page-----7256d8cf509a--------------------------------)[![Iffat
    Malik](../Images/7be3b651053507de2077b3c3c9d3a408.png)](https://iffatm.medium.com/?source=post_page-----7256d8cf509a--------------------------------)[](https://towardsdatascience.com/?source=post_page-----7256d8cf509a--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----7256d8cf509a--------------------------------)
    [Iffat Malik](https://iffatm.medium.com/?source=post_page-----7256d8cf509a--------------------------------)'
- en: Â·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----7256d8cf509a--------------------------------)
    Â·9 min readÂ·Mar 30, 2023
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Â·å‘å¸ƒäº[Towards Data Science](https://towardsdatascience.com/?source=post_page-----7256d8cf509a--------------------------------)
    Â·é˜…è¯»æ—¶é—´9åˆ†é’ŸÂ·2023å¹´3æœˆ30æ—¥
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/cb45c6657e13eb4af98d3e3c9d64e15e.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/cb45c6657e13eb4af98d3e3c9d64e15e.png)'
- en: Image by author, created on [canva](https://www.canva.com)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œè€…æä¾›çš„å›¾ç‰‡ï¼Œåˆ›å»ºäº[canva](https://www.canva.com)
- en: In order to understand the enterprise data; you have to query it a lot. When
    I say â€˜A lotâ€™, I mean it. Working with unfamiliar piles of data is often daunting
    and itâ€™s always a good practice to take some time to explore and understand the
    data itself. Itâ€™s good to have basic data retrieval skills but knowing analytical
    functions to derive some useful insights out of your data is cherry on top of
    a cake and itâ€™s fun too!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†ç†è§£ä¼ä¸šæ•°æ®ï¼Œä½ å¿…é¡»è¿›è¡Œå¤§é‡æŸ¥è¯¢ã€‚å½“æˆ‘è¯´â€œå¤§é‡â€æ—¶ï¼Œæˆ‘æ˜¯è®¤çœŸçš„ã€‚å¤„ç†é™Œç”Ÿçš„æ•°æ®é›†å¸¸å¸¸è®©äººæ„Ÿåˆ°ç•æƒ§ï¼ŒèŠ±æ—¶é—´æ¢ç´¢å’Œç†è§£æ•°æ®æœ¬èº«æ€»æ˜¯ä¸€ä¸ªå¥½ä¹ æƒ¯ã€‚æŒæ¡åŸºæœ¬çš„æ•°æ®æ£€ç´¢æŠ€èƒ½æ˜¯å¥½çš„ï¼Œä½†äº†è§£åˆ†æå‡½æ•°ä»¥ä»æ•°æ®ä¸­æå–æœ‰ç”¨çš„è§è§£åˆ™æ˜¯é”¦ä¸Šæ·»èŠ±ï¼Œè€Œä¸”ä¹Ÿå¾ˆæœ‰è¶£ï¼
- en: I come from data visualisation back ground and itâ€™s crucial for me to not just
    understand the data but also figuring out any noteworthy findings to highlight
    it to the wider teams. Also building complex dashboards is quite often a to-and-fro
    process at where you go back to your data source to tally the data and SQL Window
    Functions have always accompanied me in my data analysis journey.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘æ¥è‡ªæ•°æ®å¯è§†åŒ–èƒŒæ™¯ï¼Œå¯¹æˆ‘è€Œè¨€ï¼Œä¸ä»…ç†è§£æ•°æ®è‡³å…³é‡è¦ï¼Œè¿˜éœ€è¦æ‰¾å‡ºå€¼å¾—æ³¨æ„çš„å‘ç°ï¼Œä»¥ä¾¿å‘æ›´å¹¿æ³›çš„å›¢é˜Ÿå±•ç¤ºã€‚æ­¤å¤–ï¼Œæ„å»ºå¤æ‚çš„ä»ªè¡¨æ¿é€šå¸¸æ˜¯ä¸€ä¸ªåå¤çš„è¿‡ç¨‹ï¼Œä½ éœ€è¦å›åˆ°æ•°æ®æºæ ¸å¯¹æ•°æ®ï¼Œè€ŒSQLçª—å£å‡½æ•°å§‹ç»ˆä¼´éšæˆ‘è¿›è¡Œæ•°æ®åˆ†æã€‚
- en: Even though they are very useful for data analysis, there is some sort of confusion
    and people are often frighten to use them. While writing a detailed guide to SQL
    Window Functions, I realised it was becoming way too descriptive and yet I did
    not want to skip details especially about the syntax and clauses used along with
    it. Itâ€™s important to understand the building blocks, yeah? So, I will try and
    break down the building blocks of Window Function in this article so that itâ€™s
    not overwhelming to process and implement it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: å°½ç®¡çª—å£å‡½æ•°å¯¹äºæ•°æ®åˆ†æéå¸¸æœ‰ç”¨ï¼Œä½†ä»æœ‰ä¸€äº›æ··æ·†ï¼Œäººä»¬é€šå¸¸å®³æ€•ä½¿ç”¨å®ƒä»¬ã€‚åœ¨ç¼–å†™SQLçª—å£å‡½æ•°çš„è¯¦ç»†æŒ‡å—æ—¶ï¼Œæˆ‘æ„è¯†åˆ°å®ƒå˜å¾—è¿‡äºæè¿°æ€§ï¼Œä½†æˆ‘åˆä¸æƒ³è·³è¿‡ç»†èŠ‚ï¼Œç‰¹åˆ«æ˜¯å…³äºè¯­æ³•å’Œä½¿ç”¨çš„å­å¥ã€‚äº†è§£æ„å»ºæ¨¡å—æ˜¯é‡è¦çš„ï¼Œå¯¹å§ï¼Ÿæ‰€ä»¥ï¼Œæˆ‘å°†å°è¯•åœ¨è¿™ç¯‡æ–‡ç« ä¸­åˆ†è§£çª—å£å‡½æ•°çš„æ„å»ºæ¨¡å—ï¼Œä»¥ä¾¿å¤„ç†å’Œå®ç°æ—¶ä¸ä¼šæ„Ÿåˆ°å‹å€’ã€‚
- en: As usual, we will be using [**classicmodels**](https://www.mysqltutorial.org/mysql-sample-database.aspx)
    MySQL sample database for demonstration, which holds the business data of a car
    retailer. Below is the ER Diagram for reference,
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€å¦‚æ—¢å¾€ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨[**classicmodels**](https://www.mysqltutorial.org/mysql-sample-database.aspx)
    MySQLæ ·æœ¬æ•°æ®åº“è¿›è¡Œæ¼”ç¤ºï¼Œè¯¥æ•°æ®åº“åŒ…å«æ±½è½¦é›¶å”®å•†çš„å•†ä¸šæ•°æ®ã€‚ä¸‹é¢æ˜¯ä¾›å‚è€ƒçš„ERå›¾ï¼Œ
- en: '![](../Images/c8eecf27187711291ef0341d63121b71.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c8eecf27187711291ef0341d63121b71.png)'
- en: Image by author
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œè€…æä¾›çš„å›¾ç‰‡
- en: First things first, What is a Window Function?
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œä»€ä¹ˆæ˜¯çª—å£å‡½æ•°ï¼Ÿ
- en: Textbook definition of a Window Function is,
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: çª—å£å‡½æ•°çš„æ•™ç§‘ä¹¦å®šä¹‰æ˜¯ï¼Œ
- en: A [Window Function](https://www.postgresql.org/docs/9.1/tutorial-window.html)
    performs calculation across a set of table rows that are somehow related to the
    current row.
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[çª—å£å‡½æ•°](https://www.postgresql.org/docs/9.1/tutorial-window.html)åœ¨ä¸å½“å‰è¡Œç›¸å…³çš„ä¸€ç»„è¡¨è¡Œä¸Šæ‰§è¡Œè®¡ç®—ã€‚'
- en: '![](../Images/6c89fab2d61fd11e8d9029890b4fcae4.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6c89fab2d61fd11e8d9029890b4fcae4.png)'
- en: 'Image source: [Masterfile](https://www.masterfile.com)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 'å›¾ç‰‡æ¥æº: [Masterfile](https://www.masterfile.com)'
- en: What do you think this little fella sees from the window? A partial view from
    the scene outside of the window of this room or building. right? Thatâ€™s exactly
    what a Window Function does. It allows you to perform calculation against a subset
    of data without aggregating current rows.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ è®¤ä¸ºè¿™ä¸ªå°å®¶ä¼™ä»çª—æˆ·é‡Œçœ‹åˆ°ä»€ä¹ˆï¼Ÿæ˜¯ä»è¿™ä¸ªæˆ¿é—´æˆ–å»ºç­‘ç‰©çš„çª—æˆ·å¤–æ™¯çš„éƒ¨åˆ†è§†å›¾ï¼Œå¯¹å§ï¼Ÿè¿™æ­£æ˜¯çª—å£å‡½æ•°çš„ä½œç”¨ã€‚å®ƒå…è®¸ä½ å¯¹æ•°æ®å­é›†è¿›è¡Œè®¡ç®—ï¼Œè€Œä¸å¯¹å½“å‰è¡Œè¿›è¡Œèšåˆã€‚
- en: Whatâ€™s the need? Why Window Function? Where does Aggregate Function fall behind?
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆéœ€è¦ï¼Ÿä¸ºä»€ä¹ˆä½¿ç”¨çª—å£å‡½æ•°ï¼Ÿèšåˆå‡½æ•°å“ªé‡Œä¸è¶³ï¼Ÿ
- en: Here is the sample data from table *PRODUCTS*, for demo purpose I have limited
    it to *PRODUCTLINEs - Planes*, *Ships* and *Trains*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯æ¥è‡ª*PRODUCTS* è¡¨çš„ç¤ºä¾‹æ•°æ®ï¼Œä¸ºäº†æ¼”ç¤ºç›®çš„ï¼Œæˆ‘å°†å…¶é™åˆ¶åœ¨*PRODUCTLINEs - é£æœº*ã€*èˆ¹åª* å’Œ *ç«è½¦*ã€‚
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![](../Images/61e40d6525d4e266551d94eb62cdfef5.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/61e40d6525d4e266551d94eb62cdfef5.png)'
- en: Image by author
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡æ¥è‡ªä½œè€…
- en: Now find out the total quantity in stock for each *PRODUCTLINE*,
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æ‰¾å‡ºæ¯ä¸ª*PRODUCTLINE* çš„æ€»åº“å­˜é‡ï¼Œ
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![](../Images/11041bbf676e50c4a5526c793f1d6d57.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11041bbf676e50c4a5526c793f1d6d57.png)'
- en: Image by author
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡æ¥è‡ªä½œè€…
- en: This is pretty straight forward. *SUM(QUANTITYINSTOCK)* summarised the data
    from multiple rows into 3 rows, since we are using *GROUP BY* clause it provided
    single row for each product line. Great! thatâ€™s expected from it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¾ˆç®€å•ã€‚*SUM(QUANTITYINSTOCK)* å°†æ¥è‡ªå¤šè¡Œçš„æ•°æ®æ€»ç»“ä¸º3è¡Œï¼Œå› ä¸ºæˆ‘ä»¬ä½¿ç”¨äº†*GROUP BY* å­å¥ï¼Œå®ƒä¸ºæ¯ä¸ªäº§å“çº¿æä¾›äº†ä¸€è¡Œã€‚å¾ˆå¥½ï¼è¿™æ­£æ˜¯é¢„æœŸçš„ç»“æœã€‚
- en: '![](../Images/7d95aec1dafadd042a3a9cfde8cd8f46.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7d95aec1dafadd042a3a9cfde8cd8f46.png)'
- en: Image by author
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡æ¥è‡ªä½œè€…
- en: Letâ€™s revamp the requirement now,
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æ¥é‡æ–°å®¡è§†éœ€æ±‚ï¼Œ
- en: Display the quantity of each product within the *PRODUCTLINE* along with the
    the total quantity in stock for that particular *PRODUCTLINE*.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æ˜¾ç¤ºæ¯ä¸ª*PRODUCTLINE* ä¸­æ¯ç§äº§å“çš„æ•°é‡ï¼Œä»¥åŠè¯¥ç‰¹å®š*PRODUCTLINE* çš„æ€»åº“å­˜é‡ã€‚
- en: Arrange the result set grouped by *PRODUCTLINE.*
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æŒ‰*PRODUCTLINE* åˆ†ç»„æ’åˆ—ç»“æœé›†ã€‚
- en: Now, can this be done with the help of Aggregate Function? We surely want the
    total quantity in stock for each *PRODUCTLINE* but we do not wish to summarise
    it all. Thatâ€™s where Window Functions come to the picture,
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: é‚£ä¹ˆè¿™å¯ä»¥é€šè¿‡èšåˆå‡½æ•°æ¥å®Œæˆå—ï¼Ÿæˆ‘ä»¬ç¡®å®æƒ³è¦æ¯ä¸ª*PRODUCTLINE* çš„æ€»åº“å­˜é‡ï¼Œä½†æˆ‘ä»¬ä¸å¸Œæœ›å°†æ‰€æœ‰æ•°æ®æ±‡æ€»ã€‚è¿™å°±æ˜¯çª—å£å‡½æ•°çš„ç”¨æ­¦ä¹‹åœ°ï¼Œ
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![](../Images/bd67da55ea2f89167ec341134c4353bf.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/bd67da55ea2f89167ec341134c4353bf.png)'
- en: Image by author
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡æ¥è‡ªä½œè€…
- en: Here, *SUM()* as a Window Function performed calculations on a set of rows but
    unlike Aggregate Function it does not summarise the result set into a single row.
    Instead, all the rows (*PRODUCTNAME, PRODUCTLINE* and *QUANTITYINSTOCK* ) maintain
    their original form/identity and the calculated row(*TOTAL_QUANTITY* ) is added
    in the result set for every row.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œï¼Œ*SUM()* ä½œä¸ºçª—å£å‡½æ•°å¯¹ä¸€ç»„è¡Œè¿›è¡Œäº†è®¡ç®—ï¼Œä½†ä¸èšåˆå‡½æ•°ä¸åŒçš„æ˜¯ï¼Œå®ƒä¸ä¼šå°†ç»“æœé›†æ€»ç»“ä¸ºä¸€è¡Œã€‚ç›¸åï¼Œæ‰€æœ‰çš„è¡Œï¼ˆ*PRODUCTNAME, PRODUCTLINE*
    å’Œ *QUANTITYINSTOCK*ï¼‰ä¿æŒå…¶åŸå§‹å½¢å¼/èº«ä»½ï¼Œå¹¶ä¸”è®¡ç®—çš„è¡Œï¼ˆ*TOTAL_QUANTITY*ï¼‰åœ¨æ¯è¡Œçš„ç»“æœé›†ä¸­æ·»åŠ ã€‚
- en: '![](../Images/8071ad99b79e89cf4af44ca4e479ca99.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8071ad99b79e89cf4af44ca4e479ca99.png)'
- en: Image by author
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡æ¥è‡ªä½œè€…
- en: Types of Window Functions
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: çª—å£å‡½æ•°çš„ç±»å‹
- en: Honestly there is no official categorisation of Window Functions but based on
    the usage, we can briefly categorise them in 3 ways,
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: è¯´å®è¯ï¼Œçª—å£å‡½æ•°æ²¡æœ‰å®˜æ–¹åˆ†ç±»ï¼Œä½†æ ¹æ®ä½¿ç”¨æƒ…å†µï¼Œæˆ‘ä»¬å¯ä»¥å¤§è‡´åˆ†ä¸º3ç§æ–¹å¼ï¼Œ
- en: '![](../Images/7b2246679c08af9fb929adf6d2aaa803.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7b2246679c08af9fb929adf6d2aaa803.png)'
- en: Image by author
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡æ¥è‡ªä½œè€…
- en: '**Aggregate Functions** - Regular Aggregate Function can be used as a Window
    Function to calculate aggregations for numeric columns within window partitions
    such as running total sales, minimum or maximum value within partition etc.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**èšåˆå‡½æ•°** - å¸¸è§„çš„èšåˆå‡½æ•°å¯ä»¥ç”¨ä½œçª—å£å‡½æ•°ï¼Œä»¥è®¡ç®—çª—å£åˆ†åŒºå†…çš„æ•°å€¼åˆ—çš„èšåˆï¼Œå¦‚è¿è¡Œæ€»é”€å”®é¢ã€åˆ†åŒºå†…çš„æœ€å°å€¼æˆ–æœ€å¤§å€¼ç­‰ã€‚'
- en: '**Ranking Functions** - These functions return a ranking value for each row
    in a partition.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**æ’åå‡½æ•°** - è¿™äº›å‡½æ•°ä¸ºåˆ†åŒºä¸­çš„æ¯ä¸€è¡Œè¿”å›ä¸€ä¸ªæ’åå€¼ã€‚'
- en: '**Value Functions** - These functions are useful for generating simple statistics
    or time series analysis.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**å€¼å‡½æ•°** - è¿™äº›å‡½æ•°å¯¹äºç”Ÿæˆç®€å•çš„ç»Ÿè®¡æ•°æ®æˆ–æ—¶é—´åºåˆ—åˆ†æéå¸¸æœ‰ç”¨ã€‚'
- en: Syntax of a Window Function
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: çª—å£å‡½æ•°çš„è¯­æ³•
- en: The common syntax of a Window Function is,
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: çª—å£å‡½æ•°çš„å¸¸è§è¯­æ³•æ˜¯ï¼Œ
- en: '![](../Images/7231354dacbfef3c29dd5f72b36ffd52.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7231354dacbfef3c29dd5f72b36ffd52.png)'
- en: Image by author
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡æ¥è‡ªä½œè€…
- en: Before we go deeper into it; letâ€™s first understand significance of each clause
    within it,
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: OVER() Clause
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*OVER()*clausespecifies a function as a Window Function and hence it must always
    be included in the statement. It defines a user-specified subset(a window)of rows
    on which the Window Function will be applied. If you do not supply anything inside
    *OVER()*, the Window Function will be applied on the entire result set.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Continuing to the above example,
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![](../Images/d74f9f4fa90c0a31e3ff7e24bcd1aa5b.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: Image by author
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Here, since we supplied empty *OVER()* clause, Window Function *SUM(QUANTITYINSTOCK)*
    was applied to all the records of *PRODUCTLINE-* *Planes*, *Ships* and *Trains*
    resulting into 105816 as *TOTAL_QUANTITY*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: PARTITION BY Clause
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*PARTITION BY* is used with *OVER* clause. It divides the query result set
    into partitions or buckets based on user specified expression and then the Window
    Function applies on each partition or bucket.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Itâ€™s optional, so if you do not specify *PARTITION BY* clause*,* thenthe function
    treats all rows as a single partition. Exactly what we did in the above example,
    we simply specified an empty *OVER()* clause without *PARTITION BY* clause and
    hence total quantity was calculated for all the *PRODUCTLINE*s.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: What happens if we do specify one,
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![](../Images/2b43c6994f508b1ce2f5a98750af1a81.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
- en: Image by author
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Since we are asking *OVER()* clause to partition the *TOTAL_QUANTITY* result-set
    based on *PRODUCYLINE*, now *SUM(QUANTITYINSTOCK)* will be calculating quantity
    in stock for each one of them .
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Now, whatâ€™s the deal with *PARTITION BY* and *GROUP BY* clauses? Are they alike
    or different?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '***GROUP BY* Clause,**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: It groups multiple rows into summarised rows based on a single or multiple columns/expressions
    (returning 1 row for each group). In simpler words, it reduces the number of rows
    in your result set.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is used along with Aggregate Functions such as SUM(), AVG(), MAX() etc.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Itâ€™s placed after the *WHERE* clause but before *HAVING, ORDER BY* clauses.
    Common syntax is,
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/dc9b0ef034c60a5544de757233b80705.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
- en: Image by author
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '***PARTITION BY* Clause,**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: It is used with *OVER()* clause in Window Function. It divides the query result
    set into partitions and then the Window Function applies on each partition.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*PARTITION BY* is similar to *GROUP BY* since it aggregates the result based
    on the expression; however, the major difference is, it will not reduce the rows
    of result-set.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Itâ€™s optional, so if you do not specify *PARTITION BY* clause*,* thenthe function
    treats all rows as a single partition.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common syntax is,
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/c17211dca2471d1fe6fa023ded8ac7b6.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
- en: Image by author
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: If we need to figure out MIN and MAX values of MSRP for each PRODUCTLINE, then
    how will the result sets differ for both GROUP BY and PARTITION BY clause,
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/892742f271023e4c70a9a45996289c6e.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: Image by author
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: ORDER BY Clause
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is used to sort the result set in either ascending or descending order within
    each partition of the result set. By default itâ€™s in ascending order.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: å®ƒç”¨äºåœ¨ç»“æœé›†çš„æ¯ä¸ªåˆ†åŒºå†…æŒ‰å‡åºæˆ–é™åºæ’åºç»“æœé›†ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œå®ƒæ˜¯å‡åºçš„ã€‚
- en: ROWS/RANGE Clause
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ROWS/RANGE å­å¥
- en: Now we already know that the key feature of a Window Function is to create a
    window or a partition of the result set using *PARTITION BY* clause and then perform
    calculations on each partition. What if we further want to create subsets within
    these partitions? Woah! partition within partition? Yes, thatâ€™s why we have *FRAME*
    clause.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å·²ç»çŸ¥é“çª—å£å‡½æ•°çš„å…³é”®ç‰¹æ€§æ˜¯ä½¿ç”¨*PARTITION BY*å­å¥åˆ›å»ºç»“æœé›†çš„çª—å£æˆ–åˆ†åŒºï¼Œç„¶ååœ¨æ¯ä¸ªåˆ†åŒºä¸Šæ‰§è¡Œè®¡ç®—ã€‚å¦‚æœæˆ‘ä»¬è¿›ä¸€æ­¥æƒ³åœ¨è¿™äº›åˆ†åŒºå†…åˆ›å»ºå­é›†å‘¢ï¼Ÿå“‡ï¼åˆ†åŒºå†…çš„åˆ†åŒºï¼Ÿæ˜¯çš„ï¼Œè¿™å°±æ˜¯æˆ‘ä»¬éœ€è¦*FRAME*å­å¥çš„åŸå› ã€‚
- en: '*FRAME* clause further defines a subset of the current partition. It uses *ROW*
    or *RANGE* to define the start and end points of this subset. It requires *ORDER
    BY* clause.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*FRAME*å­å¥è¿›ä¸€æ­¥å®šä¹‰äº†å½“å‰åˆ†åŒºçš„ä¸€ä¸ªå­é›†ã€‚å®ƒä½¿ç”¨*ROW*æˆ–*RANGE*æ¥å®šä¹‰è¿™ä¸ªå­é›†çš„èµ·ç‚¹å’Œç»ˆç‚¹ã€‚å®ƒéœ€è¦*ORDER BY*å­å¥ã€‚'
- en: Frames are determined with respect to the current row, which simply means you
    take your current rowâ€™s location as a base point and with that reference you define
    your frame within the partition.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: æ¡†æ¶æ˜¯ç›¸å¯¹äºå½“å‰è¡Œæ¥ç¡®å®šçš„ï¼Œè¿™æ„å‘³ç€ä½ å°†å½“å‰è¡Œçš„ä½ç½®ä½œä¸ºåŸºå‡†ç‚¹ï¼Œå¹¶ä»¥æ­¤ä¸ºå‚è€ƒå®šä¹‰ä½ åœ¨åˆ†åŒºå†…çš„æ¡†æ¶ã€‚
- en: '*ROWS* â€” This defines the beginning and ending of the frame by specifying the
    number of rows that precede or follow the current row.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ROWS* â€” é€šè¿‡æŒ‡å®šå½“å‰è¡Œä¹‹å‰æˆ–ä¹‹åçš„è¡Œæ•°æ¥å®šä¹‰æ¡†æ¶çš„å¼€å§‹å’Œç»“æŸã€‚'
- en: '*RANGE* â€” Contrary to the *ROWS*, *RANGE* specifies the range of values compared
    to the value of the current row to define a frame within the partition.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RANGE* â€” ä¸*ROWS*ç›¸å¯¹ï¼Œ*RANGE*æŒ‡å®šä¸å½“å‰è¡Œå€¼ç›¸æ¯”çš„å€¼èŒƒå›´ï¼Œä»¥åœ¨åˆ†åŒºå†…å®šä¹‰æ¡†æ¶ã€‚'
- en: Generic syntax is,
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: é€šç”¨è¯­æ³•æ˜¯ï¼Œ
- en: '**{ROWS | RANGE} BETWEEN <frame_starting> AND <frame_ending>**'
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**{ROWS | RANGE} BETWEEN <frame_starting> AND <frame_ending>**'
- en: '![](../Images/3849aa0e5961ada988e8b08e89b4b5b5.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3849aa0e5961ada988e8b08e89b4b5b5.png)'
- en: Image by author
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œè€…æä¾›çš„å›¾ç‰‡
- en: Before we go any further, letâ€™s understand some basic terms defining the frame.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿›ä¸€æ­¥è®¨è®ºä¹‹å‰ï¼Œè®©æˆ‘ä»¬å…ˆäº†è§£ä¸€äº›å®šä¹‰çª—å£çš„åŸºæœ¬æœ¯è¯­ã€‚
- en: '![](../Images/388516b7b3eee5b99234ba06166d2117.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/388516b7b3eee5b99234ba06166d2117.png)'
- en: 'Image source: [mysqltutorials](https://www.mysqltutorial.org)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡æ¥æºï¼š[mysqltutorials](https://www.mysqltutorial.org)
- en: '*UNBOUNDED PRECEDING* - This specifies all the rows (starting from the first
    row) before the current row in the partition.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*UNBOUNDED PRECEDING* - è¿™æŒ‡å®šäº†åˆ†åŒºä¸­å½“å‰è¡Œä¹‹å‰çš„æ‰€æœ‰è¡Œï¼ˆä»ç¬¬ä¸€è¡Œå¼€å§‹ï¼‰ã€‚'
- en: '*N PRECEDING* - This specifies â€™Nâ€™ number of rows before your current row in
    the partition.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*N PRECEDING* - è¿™æŒ‡å®šäº†åˆ†åŒºä¸­å½“å‰è¡Œä¹‹å‰çš„â€˜Nâ€™è¡Œæ•°ã€‚'
- en: '*UNBOUNDED FOLLOWING* - This specifies all the rows after your current row
    (all the way to the very last row) in the partition.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*UNBOUNDED FOLLOWING* - è¿™æŒ‡å®šäº†åˆ†åŒºä¸­å½“å‰è¡Œä¹‹åçš„æ‰€æœ‰è¡Œï¼ˆä¸€ç›´åˆ°æœ€åä¸€è¡Œï¼‰ã€‚'
- en: '*M FOLLOWING* - This specifies â€˜Mâ€™ number of rows below your current row in
    the partition.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*M FOLLOWING* - è¿™æŒ‡å®šäº†åˆ†åŒºä¸­å½“å‰è¡Œä¸‹æ–¹çš„â€˜Mâ€™è¡Œæ•°ã€‚'
- en: Letâ€™s quickly understand this with an example,
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬é€šè¿‡ä¸€ä¸ªä¾‹å­å¿«é€Ÿç†è§£ä¸€ä¸‹ï¼Œ
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](../Images/93267b9084ee0c5dc812607836e8ab52.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/93267b9084ee0c5dc812607836e8ab52.png)'
- en: Image by author
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œè€…æä¾›çš„å›¾ç‰‡
- en: '***ROWS BETWEEN 1 PRECEDING AND CURRENT ROW*** indicates the size of the frame
    on which *SUM(QUANTITYINSTOCK)* needs to be calculated within the partition.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '***ROWS BETWEEN 1 PRECEDING AND CURRENT ROW*** è¡¨ç¤ºåœ¨åˆ†åŒºå†…éœ€è¦è®¡ç®—*SUM(QUANTITYINSTOCK)*çš„æ¡†æ¶å¤§å°ã€‚'
- en: '![](../Images/1b7de0a4150d4228d546a8e58868152f.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1b7de0a4150d4228d546a8e58868152f.png)'
- en: Image by author
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œè€…æä¾›çš„å›¾ç‰‡
- en: Here are some examples of *FRAME* clauses,
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰ä¸€äº›*FRAME*å­å¥çš„ç¤ºä¾‹ï¼Œ
- en: '*ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING* â€” This means consider
    the frame from the first row of the partition to the last row of the partition.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING* â€” è¿™æ„å‘³ç€è€ƒè™‘ä»åˆ†åŒºçš„ç¬¬ä¸€è¡Œåˆ°åˆ†åŒºçš„æœ€åä¸€è¡Œçš„æ¡†æ¶ã€‚'
- en: '*ROWS BETWEEN UNBOUNDED PRECEDING AND 4 FOLLOWING* - This means consider the
    frame from the first row of the partition to 4 row after the current row.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ROWS BETWEEN UNBOUNDED PRECEDING AND 4 FOLLOWING* - è¿™æ„å‘³ç€è€ƒè™‘ä»åˆ†åŒºçš„ç¬¬ä¸€è¡Œåˆ°å½“å‰è¡Œä¹‹åçš„4è¡Œçš„æ¡†æ¶ã€‚'
- en: '*ROWS BETWEEN 4 PRECEDING AND 1 PRECEDING* - Frame will be the previous 4 rows
    up to 1 row before the current row.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ROWS BETWEEN 4 PRECEDING AND 1 PRECEDING* - çª—å£å°†æ˜¯å½“å‰è¡Œä¹‹å‰çš„4è¡Œåˆ°å½“å‰è¡Œä¹‹å‰çš„1è¡Œã€‚'
- en: The default frame differs depending on the presence or the absence of the *ORDER
    BY* clause; with it the default frame is,
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: é»˜è®¤æ¡†æ¶æ ¹æ®æ˜¯å¦å­˜åœ¨*ORDER BY*å­å¥è€Œæœ‰æ‰€ä¸åŒï¼›å¦‚æœå­˜åœ¨ï¼Œé»˜è®¤æ¡†æ¶æ˜¯ï¼Œ
- en: '*{ROWS/RANGE} BETWEEN* **UNBOUNDED PRECEDING** *AND* **CURRENT ROW**'
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*{ROWS/RANGE} BETWEEN* **UNBOUNDED PRECEDING** *AND* **CURRENT ROW**'
- en: This means consider the frame as all the rows starting from the row number one
    to the current row in the partition.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ„å‘³ç€å°†çª—å£èŒƒå›´è§†ä¸ºä»ç¬¬ä¸€è¡Œåˆ°å½“å‰è¡Œçš„æ‰€æœ‰è¡Œã€‚
- en: Without *ORDER BY* clause, the default frame as,
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæ²¡æœ‰*ORDER BY*å­å¥ï¼Œåˆ™é»˜è®¤çš„çª—å£èŒƒå›´ä¸ºï¼Œ
- en: '*{ROWS/RANGE}* BETWEEN **UNBOUNDED PRECEDING** AND **UNBOUNDED FOLLOWING**'
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*{ROWS/RANGE}* BETWEEN **UNBOUNDED PRECEDING** AND **UNBOUNDED FOLLOWING**'
- en: This simply means entire partition.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ„å‘³ç€æ•´ä¸ªåˆ†åŒºã€‚
- en: Defining a window alias,
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å®šä¹‰çª—å£åˆ«åï¼Œ
- en: If there are more than one window functions in your query which utilises the
    same window, then you might want to use window alias.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæŸ¥è¯¢ä¸­æœ‰å¤šä¸ªçª—å£å‡½æ•°ä½¿ç”¨ç›¸åŒçš„çª—å£ï¼Œåˆ™å¯èƒ½éœ€è¦ä½¿ç”¨çª—å£åˆ«åã€‚
- en: '[PRE6]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The alternate way of writing the same query by using window alias is,
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨çª—å£åˆ«åç¼–å†™ç›¸åŒæŸ¥è¯¢çš„å¦ä¸€ç§æ–¹å¼æ˜¯ï¼Œ
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ğŸ“Œ **Side Note**
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ“Œ **é™„æ³¨**
- en: During the query execution, Window Functions are performed on the result set,
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æŸ¥è¯¢æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œçª—å£å‡½æ•°ä¼šåœ¨ç»“æœé›†ä¸­æ‰§è¡Œï¼Œ
- en: '**After** *JOIN*, *WHERE* , *GROUP BY* and *HAVING* clauses and'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**åœ¨** *JOIN*ã€*WHERE*ã€*GROUP BY* å’Œ *HAVING* å­å¥ä¹‹åï¼Œ'
- en: '**Before** the *ORDER BY* clause, *LIMIT* and *SELECT DISTINCT*.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**åœ¨** *ORDER BY* å­å¥ã€*LIMIT* å’Œ *SELECT DISTINCT* ä¹‹å‰ã€‚'
- en: Conclusion
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ç»“è®º
- en: You might want to explore data from 100 different ways and Window Functions
    are just right for such analysis. This article was just the starter to understand
    basic syntax and clauses so that itâ€™s not overwhelming to Window Function, it
    surely gets better with practice.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯èƒ½å¸Œæœ›ä»100ç§ä¸åŒçš„æ–¹å¼ä¸­æ¢ç´¢æ•°æ®ï¼Œè€Œçª—å£å‡½æ•°æ­£é€‚åˆè¿™ç§åˆ†æã€‚æœ¬æ–‡åªæ˜¯äº†è§£åŸºæœ¬è¯­æ³•å’Œå­å¥çš„å…¥é—¨ï¼Œä»¥ä¾¿çª—å£å‡½æ•°ä¸ä¼šæ˜¾å¾—è¿‡äºå¤æ‚ï¼Œé€šè¿‡ç»ƒä¹ ï¼Œè‚¯å®šä¼šæ›´å¥½ã€‚
- en: Here is the detailed guide of most commonly used Window Functions,
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯æœ€å¸¸ç”¨çª—å£å‡½æ•°çš„è¯¦ç»†æŒ‡å—ï¼Œ
- en: '[](/window-functions-a-must-know-for-data-engineers-and-data-scientists-4dd3e4ad0d2?source=post_page-----7256d8cf509a--------------------------------)
    [## Window Functions â€” A must know for Data Engineers and Data Scientists'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[çª—å£å‡½æ•° â€” æ•°æ®å·¥ç¨‹å¸ˆå’Œæ•°æ®ç§‘å­¦å®¶å¿…çŸ¥](https://www.example.org/window-functions-a-must-know-for-data-engineers-and-data-scientists-4dd3e4ad0d2?source=post_page-----7256d8cf509a--------------------------------)'
- en: Back To Basics | SQL fundamentals for beginners
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: å›å½’åŸºç¡€ | åˆå­¦è€…çš„ SQL åŸºç¡€
- en: towardsdatascience.com](/window-functions-a-must-know-for-data-engineers-and-data-scientists-4dd3e4ad0d2?source=post_page-----7256d8cf509a--------------------------------)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[towardsdatascience.com](https://www.towardsdatascience.com/window-functions-a-must-know-for-data-engineers-and-data-scientists-4dd3e4ad0d2?source=post_page-----7256d8cf509a--------------------------------)'
- en: Some other useful resources,
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€äº›å…¶ä»–æœ‰ç”¨çš„èµ„æºï¼Œ
- en: '[SQL Window Function Cheat Sheet](https://learnsql.com/blog/sql-window-functions-cheat-sheet/)'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQL çª—å£å‡½æ•°é€ŸæŸ¥è¡¨](https://learnsql.com/blog/sql-window-functions-cheat-sheet/)'
- en: '[Frame Clause](https://dev.mysql.com/doc/refman/8.0/en/window-functions-frames.html)'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[çª—å£å­å¥](https://dev.mysql.com/doc/refman/8.0/en/window-functions-frames.html)'
- en: '[HackerRank](https://www.hackerrank.com) or [LeetCode](https://leetcode.com)
    to practice basic/intermediate/advance SQL problems.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[HackerRank](https://www.hackerrank.com) æˆ– [LeetCode](https://leetcode.com)
    æ¥ç»ƒä¹ åŸºç¡€/ä¸­çº§/é«˜çº§ SQL é—®é¢˜ã€‚'
- en: Happy Learning!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: å­¦ä¹ æ„‰å¿«ï¼
