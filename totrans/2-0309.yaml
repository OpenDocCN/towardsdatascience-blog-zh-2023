- en: Anatomy of SQL Window Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/anatomy-of-sql-window-functions-7256d8cf509a](https://towardsdatascience.com/anatomy-of-sql-window-functions-7256d8cf509a)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Back To Basics | SQL fundamentals for beginners
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://iffatm.medium.com/?source=post_page-----7256d8cf509a--------------------------------)[![Iffat
    Malik](../Images/7be3b651053507de2077b3c3c9d3a408.png)](https://iffatm.medium.com/?source=post_page-----7256d8cf509a--------------------------------)[](https://towardsdatascience.com/?source=post_page-----7256d8cf509a--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----7256d8cf509a--------------------------------)
    [Iffat Malik](https://iffatm.medium.com/?source=post_page-----7256d8cf509a--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----7256d8cf509a--------------------------------)
    ·9 min read·Mar 30, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/cb45c6657e13eb4af98d3e3c9d64e15e.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author, created on [canva](https://www.canva.com)
  prefs: []
  type: TYPE_NORMAL
- en: In order to understand the enterprise data; you have to query it a lot. When
    I say ‘A lot’, I mean it. Working with unfamiliar piles of data is often daunting
    and it’s always a good practice to take some time to explore and understand the
    data itself. It’s good to have basic data retrieval skills but knowing analytical
    functions to derive some useful insights out of your data is cherry on top of
    a cake and it’s fun too!
  prefs: []
  type: TYPE_NORMAL
- en: I come from data visualisation back ground and it’s crucial for me to not just
    understand the data but also figuring out any noteworthy findings to highlight
    it to the wider teams. Also building complex dashboards is quite often a to-and-fro
    process at where you go back to your data source to tally the data and SQL Window
    Functions have always accompanied me in my data analysis journey.
  prefs: []
  type: TYPE_NORMAL
- en: Even though they are very useful for data analysis, there is some sort of confusion
    and people are often frighten to use them. While writing a detailed guide to SQL
    Window Functions, I realised it was becoming way too descriptive and yet I did
    not want to skip details especially about the syntax and clauses used along with
    it. It’s important to understand the building blocks, yeah? So, I will try and
    break down the building blocks of Window Function in this article so that it’s
    not overwhelming to process and implement it.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, we will be using [**classicmodels**](https://www.mysqltutorial.org/mysql-sample-database.aspx)
    MySQL sample database for demonstration, which holds the business data of a car
    retailer. Below is the ER Diagram for reference,
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c8eecf27187711291ef0341d63121b71.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: First things first, What is a Window Function?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Textbook definition of a Window Function is,
  prefs: []
  type: TYPE_NORMAL
- en: A [Window Function](https://www.postgresql.org/docs/9.1/tutorial-window.html)
    performs calculation across a set of table rows that are somehow related to the
    current row.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/6c89fab2d61fd11e8d9029890b4fcae4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Image source: [Masterfile](https://www.masterfile.com)'
  prefs: []
  type: TYPE_NORMAL
- en: What do you think this little fella sees from the window? A partial view from
    the scene outside of the window of this room or building. right? That’s exactly
    what a Window Function does. It allows you to perform calculation against a subset
    of data without aggregating current rows.
  prefs: []
  type: TYPE_NORMAL
- en: What’s the need? Why Window Function? Where does Aggregate Function fall behind?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is the sample data from table *PRODUCTS*, for demo purpose I have limited
    it to *PRODUCTLINEs - Planes*, *Ships* and *Trains*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/61e40d6525d4e266551d94eb62cdfef5.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Now find out the total quantity in stock for each *PRODUCTLINE*,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/11041bbf676e50c4a5526c793f1d6d57.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: This is pretty straight forward. *SUM(QUANTITYINSTOCK)* summarised the data
    from multiple rows into 3 rows, since we are using *GROUP BY* clause it provided
    single row for each product line. Great! that’s expected from it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7d95aec1dafadd042a3a9cfde8cd8f46.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Let’s revamp the requirement now,
  prefs: []
  type: TYPE_NORMAL
- en: Display the quantity of each product within the *PRODUCTLINE* along with the
    the total quantity in stock for that particular *PRODUCTLINE*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Arrange the result set grouped by *PRODUCTLINE.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, can this be done with the help of Aggregate Function? We surely want the
    total quantity in stock for each *PRODUCTLINE* but we do not wish to summarise
    it all. That’s where Window Functions come to the picture,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/bd67da55ea2f89167ec341134c4353bf.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Here, *SUM()* as a Window Function performed calculations on a set of rows but
    unlike Aggregate Function it does not summarise the result set into a single row.
    Instead, all the rows (*PRODUCTNAME, PRODUCTLINE* and *QUANTITYINSTOCK* ) maintain
    their original form/identity and the calculated row(*TOTAL_QUANTITY* ) is added
    in the result set for every row.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8071ad99b79e89cf4af44ca4e479ca99.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Types of Window Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Honestly there is no official categorisation of Window Functions but based on
    the usage, we can briefly categorise them in 3 ways,
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7b2246679c08af9fb929adf6d2aaa803.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: '**Aggregate Functions** - Regular Aggregate Function can be used as a Window
    Function to calculate aggregations for numeric columns within window partitions
    such as running total sales, minimum or maximum value within partition etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ranking Functions** - These functions return a ranking value for each row
    in a partition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Value Functions** - These functions are useful for generating simple statistics
    or time series analysis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syntax of a Window Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The common syntax of a Window Function is,
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7231354dacbfef3c29dd5f72b36ffd52.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Before we go deeper into it; let’s first understand significance of each clause
    within it,
  prefs: []
  type: TYPE_NORMAL
- en: OVER() Clause
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*OVER()*clausespecifies a function as a Window Function and hence it must always
    be included in the statement. It defines a user-specified subset(a window)of rows
    on which the Window Function will be applied. If you do not supply anything inside
    *OVER()*, the Window Function will be applied on the entire result set.'
  prefs: []
  type: TYPE_NORMAL
- en: Continuing to the above example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/d74f9f4fa90c0a31e3ff7e24bcd1aa5b.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Here, since we supplied empty *OVER()* clause, Window Function *SUM(QUANTITYINSTOCK)*
    was applied to all the records of *PRODUCTLINE-* *Planes*, *Ships* and *Trains*
    resulting into 105816 as *TOTAL_QUANTITY*.
  prefs: []
  type: TYPE_NORMAL
- en: PARTITION BY Clause
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*PARTITION BY* is used with *OVER* clause. It divides the query result set
    into partitions or buckets based on user specified expression and then the Window
    Function applies on each partition or bucket.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s optional, so if you do not specify *PARTITION BY* clause*,* thenthe function
    treats all rows as a single partition. Exactly what we did in the above example,
    we simply specified an empty *OVER()* clause without *PARTITION BY* clause and
    hence total quantity was calculated for all the *PRODUCTLINE*s.
  prefs: []
  type: TYPE_NORMAL
- en: What happens if we do specify one,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/2b43c6994f508b1ce2f5a98750af1a81.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Since we are asking *OVER()* clause to partition the *TOTAL_QUANTITY* result-set
    based on *PRODUCYLINE*, now *SUM(QUANTITYINSTOCK)* will be calculating quantity
    in stock for each one of them .
  prefs: []
  type: TYPE_NORMAL
- en: Now, what’s the deal with *PARTITION BY* and *GROUP BY* clauses? Are they alike
    or different?
  prefs: []
  type: TYPE_NORMAL
- en: '***GROUP BY* Clause,**'
  prefs: []
  type: TYPE_NORMAL
- en: It groups multiple rows into summarised rows based on a single or multiple columns/expressions
    (returning 1 row for each group). In simpler words, it reduces the number of rows
    in your result set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is used along with Aggregate Functions such as SUM(), AVG(), MAX() etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s placed after the *WHERE* clause but before *HAVING, ORDER BY* clauses.
    Common syntax is,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/dc9b0ef034c60a5544de757233b80705.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: '***PARTITION BY* Clause,**'
  prefs: []
  type: TYPE_NORMAL
- en: It is used with *OVER()* clause in Window Function. It divides the query result
    set into partitions and then the Window Function applies on each partition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*PARTITION BY* is similar to *GROUP BY* since it aggregates the result based
    on the expression; however, the major difference is, it will not reduce the rows
    of result-set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s optional, so if you do not specify *PARTITION BY* clause*,* thenthe function
    treats all rows as a single partition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common syntax is,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/c17211dca2471d1fe6fa023ded8ac7b6.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: If we need to figure out MIN and MAX values of MSRP for each PRODUCTLINE, then
    how will the result sets differ for both GROUP BY and PARTITION BY clause,
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/892742f271023e4c70a9a45996289c6e.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: ORDER BY Clause
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is used to sort the result set in either ascending or descending order within
    each partition of the result set. By default it’s in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: ROWS/RANGE Clause
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we already know that the key feature of a Window Function is to create a
    window or a partition of the result set using *PARTITION BY* clause and then perform
    calculations on each partition. What if we further want to create subsets within
    these partitions? Woah! partition within partition? Yes, that’s why we have *FRAME*
    clause.
  prefs: []
  type: TYPE_NORMAL
- en: '*FRAME* clause further defines a subset of the current partition. It uses *ROW*
    or *RANGE* to define the start and end points of this subset. It requires *ORDER
    BY* clause.'
  prefs: []
  type: TYPE_NORMAL
- en: Frames are determined with respect to the current row, which simply means you
    take your current row’s location as a base point and with that reference you define
    your frame within the partition.
  prefs: []
  type: TYPE_NORMAL
- en: '*ROWS* — This defines the beginning and ending of the frame by specifying the
    number of rows that precede or follow the current row.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*RANGE* — Contrary to the *ROWS*, *RANGE* specifies the range of values compared
    to the value of the current row to define a frame within the partition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic syntax is,
  prefs: []
  type: TYPE_NORMAL
- en: '**{ROWS | RANGE} BETWEEN <frame_starting> AND <frame_ending>**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/3849aa0e5961ada988e8b08e89b4b5b5.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Before we go any further, let’s understand some basic terms defining the frame.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/388516b7b3eee5b99234ba06166d2117.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Image source: [mysqltutorials](https://www.mysqltutorial.org)'
  prefs: []
  type: TYPE_NORMAL
- en: '*UNBOUNDED PRECEDING* - This specifies all the rows (starting from the first
    row) before the current row in the partition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*N PRECEDING* - This specifies ’N’ number of rows before your current row in
    the partition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*UNBOUNDED FOLLOWING* - This specifies all the rows after your current row
    (all the way to the very last row) in the partition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*M FOLLOWING* - This specifies ‘M’ number of rows below your current row in
    the partition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s quickly understand this with an example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/93267b9084ee0c5dc812607836e8ab52.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: '***ROWS BETWEEN 1 PRECEDING AND CURRENT ROW*** indicates the size of the frame
    on which *SUM(QUANTITYINSTOCK)* needs to be calculated within the partition.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1b7de0a4150d4228d546a8e58868152f.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Here are some examples of *FRAME* clauses,
  prefs: []
  type: TYPE_NORMAL
- en: '*ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING* — This means consider
    the frame from the first row of the partition to the last row of the partition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ROWS BETWEEN UNBOUNDED PRECEDING AND 4 FOLLOWING* - This means consider the
    frame from the first row of the partition to 4 row after the current row.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ROWS BETWEEN 4 PRECEDING AND 1 PRECEDING* - Frame will be the previous 4 rows
    up to 1 row before the current row.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default frame differs depending on the presence or the absence of the *ORDER
    BY* clause; with it the default frame is,
  prefs: []
  type: TYPE_NORMAL
- en: '*{ROWS/RANGE} BETWEEN* **UNBOUNDED PRECEDING** *AND* **CURRENT ROW**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This means consider the frame as all the rows starting from the row number one
    to the current row in the partition.
  prefs: []
  type: TYPE_NORMAL
- en: Without *ORDER BY* clause, the default frame as,
  prefs: []
  type: TYPE_NORMAL
- en: '*{ROWS/RANGE}* BETWEEN **UNBOUNDED PRECEDING** AND **UNBOUNDED FOLLOWING**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This simply means entire partition.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a window alias,
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If there are more than one window functions in your query which utilises the
    same window, then you might want to use window alias.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The alternate way of writing the same query by using window alias is,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 📌 **Side Note**
  prefs: []
  type: TYPE_NORMAL
- en: During the query execution, Window Functions are performed on the result set,
  prefs: []
  type: TYPE_NORMAL
- en: '**After** *JOIN*, *WHERE* , *GROUP BY* and *HAVING* clauses and'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Before** the *ORDER BY* clause, *LIMIT* and *SELECT DISTINCT*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might want to explore data from 100 different ways and Window Functions
    are just right for such analysis. This article was just the starter to understand
    basic syntax and clauses so that it’s not overwhelming to Window Function, it
    surely gets better with practice.
  prefs: []
  type: TYPE_NORMAL
- en: Here is the detailed guide of most commonly used Window Functions,
  prefs: []
  type: TYPE_NORMAL
- en: '[](/window-functions-a-must-know-for-data-engineers-and-data-scientists-4dd3e4ad0d2?source=post_page-----7256d8cf509a--------------------------------)
    [## Window Functions — A must know for Data Engineers and Data Scientists'
  prefs: []
  type: TYPE_NORMAL
- en: Back To Basics | SQL fundamentals for beginners
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/window-functions-a-must-know-for-data-engineers-and-data-scientists-4dd3e4ad0d2?source=post_page-----7256d8cf509a--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Some other useful resources,
  prefs: []
  type: TYPE_NORMAL
- en: '[SQL Window Function Cheat Sheet](https://learnsql.com/blog/sql-window-functions-cheat-sheet/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Frame Clause](https://dev.mysql.com/doc/refman/8.0/en/window-functions-frames.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[HackerRank](https://www.hackerrank.com) or [LeetCode](https://leetcode.com)
    to practice basic/intermediate/advance SQL problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Happy Learning!
  prefs: []
  type: TYPE_NORMAL
