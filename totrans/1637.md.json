["```py\nimport math\nimport numpy as np\nimport random\nimport matplotlib.pyplot as plt\nfrom tqdm import tqdm\n\ndef blackbox(x1, y1, x2, y2, x3, y3, x4, y4):\n    return math.sqrt((x1+2)**2 + (y1-3)**2) * \\\n            math.sin(\n                math.atan2(2*(y2-4), 3*(x2+1)) * (\n                    math.cos(x3-x1) + math.sin(y3-y1)\n                    + math.cos(3*(y4+3))\n                    + math.sin(2*(x4-2))\n                ) \n            )\n```", "```py\ndef blackbox_addition(x1, y1, x2, y2, x3, y3, x4, y4):\n    return np.sin(x1) * np.cos(y1) \\\n            + np.cos(x2) * np.sin(y2) \\\n            + np.sin(x3) * np.sin(y3) \\\n            + np.cos(x4) * np.cos(y4)\n```", "```py\nclass Task:\n    def __init__(self):\n        pass\n\n    def score(self, x_arr, with_noise=True):\n        if with_noise:\n            return blackbox(*x_arr) + 0.1*np.random.randn()\n        else:\n            return blackbox(*x_arr)\n```", "```py\nclass Particle:\n    def __init__(self, idx, n_dim, param_limits=(-1,1)):\n        self.idx = idx\n        self.low = param_limits[0]\n        self.high = param_limits[1]\n        self.pos = np.random.uniform(\n            low=self.low, high=self.high, size=(n_dim,)\n        )\n        self.w = np.random.uniform(0.1, 0.5)\n        self.r1 = np.random.uniform(0, 1, size=(n_dim,))\n        self.r2 = np.random.uniform(0, 1, size=(n_dim,))\n        self.vel = np.random.normal(size=n_dim)\n        self.pbest = np.zeros(n_dim,)\n        self.pbest_fitness = -1e8\n\n    def update(self, gbest, task):\n        self.vel = self.w * self.vel \\\n                + self.r1 * (self.pbest - self.pos) \\\n                + self.r2 * (gbest - self.pos)\n\n        self.vel = np.clip(self.vel, 0.2*self.low, 0.2*self.high)\n        self.pos = np.clip(self.pos + self.vel, self.low, self.high)\n\n        fitness = task.score(self.pos)\n        if fitness > self.pbest_fitness:\n            self.pbest_fitness = fitness\n            self.pbest = deepcopy(self.pos)\n        return self.pos\n```", "```py\nclass Swarm:\n    def __init__(self, n_dim, n_population, param_limits):\n        self.n_dim = n_dim\n        self.particles = [Particle(i+1, n_dim, param_limits) for i in range(n_population)]\n        self.reset()\n\n    def reset(self):\n        self.gbest = np.zeros(self.n_dim,)\n        self.gbest_fitness = -1e8\n        self.history = {}\n\n    def update_all_particles(self, task):\n        for particle_Obj in self.particles:\n            particle_Obj.update(self.gbest, task)\n\n    def solve(self, task, num_generation):\n        self.reset()\n        for t in tqdm(range(num_generation)):\n            self.update_all_particles(task)\n            particles_pbest_fitness = [task.score(p.pos) for p in self.particles]\n            self.history[t] = dict([(p, deepcopy(p.pos)) for p in self.particles])\n            if np.max(particles_pbest_fitness) > self.gbest_fitness:\n                self.gbest_fitness = np.max(particles_pbest_fitness)\n                self.gbest_index = np.argmax(particles_pbest_fitness)\n                self.gbest_particle = self.particles[self.gbest_index]\n                self.gbest = self.gbest_particle.pos                \n        return self.gbest\n```", "```py\nposition_min, position_max = -5, 5\nswarm = Swarm(\n    n_dim=8, n_population=2000, param_limits=(position_min, position_max)\n)\nsolution = swarm.solve(task, num_iteration=200)\n\nprint(solution)\nprint(task.score(solution, with_noise=False))\n```", "```py\nbest_score = -np.inf\nsolution = None\nintervals = 11\n\nfor x1 in tqdm(np.linspace(position_min, position_max, intervals)):\n    for y1 in np.linspace(position_min, position_max, intervals):\n        for x2 in np.linspace(position_min, position_max, intervals):\n            for y2 in np.linspace(position_min, position_max, intervals):\n                for x3 in np.linspace(position_min, position_max, intervals):\n                    for y3 in np.linspace(position_min, position_max, intervals):\n                        for x4 in np.linspace(position_min, position_max, intervals):\n                            for y4 in np.linspace(position_min, position_max, intervals):\n                                sample = task.score(np.array([x1,y1,x2,y2,x3,y3,x4,y4]))\n                                if sample > best_score:\n                                    best_score = sample\n                                    solution = np.array([x1,y1,x2,y2,x3,y3,x4,y4])\n\nprint(\"solution: \", solution)\nprint(task.score(solution, with_noise=False))\n```", "```py\nx_range = np.linspace(-5, 5, 100)\ny_range = np.linspace(-5, 5, 100)\nX, Y = np.meshgrid(x_range, y_range)\nvectorized_blackbox = np.vectorize(blackbox)\n\nfor t in [1,2,3,4,5,6,8,10,12,15,20,30,50,100,200]:\n    data = np.array(list(swarm.history[t-1].values()))\n    ref = data[swarm.gbest_particle.idx-1,:]\n    heatmap = {\n        1: vectorized_blackbox(X, Y, ref[2], ref[3], ref[4], ref[5], ref[6], ref[7]),\n        2: vectorized_blackbox(ref[0], ref[1], X, Y, ref[4], ref[5], ref[6], ref[7]),\n        3: vectorized_blackbox(ref[0], ref[1], ref[2], ref[3], X, Y, ref[6], ref[7]),\n        4: vectorized_blackbox(ref[0], ref[1], ref[2], ref[3], ref[4], ref[5], X, Y)\n    }\n\n    fig, axs = plt.subplots(2, 2, figsize=(10, 10))\n    for i in range(2):\n        for j in range(2):\n            c = axs[i,j].contourf(X, Y, heatmap[2*i+j+1], vmin=0, vmax=12, levels=50, alpha=0.5)\n            axs[i,j].scatter(data[:, 2*i+j], data[:, 2*i+j+1], s=2, alpha=0.4)\n            axs[i,j].scatter(data[swarm.gbest_particle.idx-1, 2*i+j], data[swarm.gbest_particle.idx-1, 2*i+j+1], c='w', s=5, alpha=1)\n            axs[i,j].set_xlabel(\"x_%d\"%(2*i+j+1))\n            axs[i,j].set_ylabel(\"y_%d\"%(2*i+j+1))\n            axs[i,j].set_xlim([-5, 5])\n            axs[i,j].set_ylim([-5, 5])\n    fig.colorbar(c, ax=axs)\n    plt.suptitle(\"Distribution of particles at iteration %d\"%t)\n    plt.savefig(\"plot_%03d.png\"%t)\n```"]