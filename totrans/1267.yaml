- en: How to Use Map Functions for Data Science in R
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/how-to-use-map-functions-for-data-science-in-r-8180c2ed6d79](https://towardsdatascience.com/how-to-use-map-functions-for-data-science-in-r-8180c2ed6d79)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Learn powerful functional programming tools from the tidyverse
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://roryspanton.medium.com/?source=post_page-----8180c2ed6d79--------------------------------)[![Rory
    Spanton](../Images/6c35a3de7cb516aac09bc5cf417a6c70.png)](https://roryspanton.medium.com/?source=post_page-----8180c2ed6d79--------------------------------)[](https://towardsdatascience.com/?source=post_page-----8180c2ed6d79--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----8180c2ed6d79--------------------------------)
    [Rory Spanton](https://roryspanton.medium.com/?source=post_page-----8180c2ed6d79--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----8180c2ed6d79--------------------------------)
    ·7 min read·Feb 2, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7814864921e31d3a070fa03387a45857.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Z](https://unsplash.com/@dead____artist?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: All data scientists need to repeat code. Whether you’re fitting a model to multiple
    datasets or changing many values at once, running the same code many times over
    is essential.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to repeat code. But while most programmers use loops, there
    are more succinct, readable, and efficient alternatives. Enter, the `map` family
    of functions from the purrr package.
  prefs: []
  type: TYPE_NORMAL
- en: In this article, I’ll explain what mapping means, and how to use the `map`,
    `map2`, and `pmap` functions from the [purrr package](https://purrr.tidyverse.org/)
    in R.
  prefs: []
  type: TYPE_NORMAL
- en: What is “Mapping”, and How is it Done in R?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The kind of mapping that the purrr package does isn’t the geographical type
    that most people are familiar with. R has great tools for geospatial analysis,
    but that’s not what we’re talking about here.
  prefs: []
  type: TYPE_NORMAL
- en: “[Mapping](https://en.wikipedia.org/wiki/Map_(higher-order_function))” is a
    specialised term in programming that refers to applying a function repeatedly
    across a set of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: We can use a simple example to understand this. Let’s say we have a list, with
    each element containing 100 numbers. If we want to calculate the mean of each
    set of numbers, we can use `map` to do this in a straightforward way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first load in the tidyverse, which contains the purrr package that
    provides our map functions. Then, we use `map` to get the mean for each list element.
  prefs: []
  type: TYPE_NORMAL
- en: The basic `map` function takes two arguments. First, we specify the list or
    vector we want to apply a function across; in this case, `values_list`. Second,
    we name the function we want to apply; `mean`. This makes `map` a “[higher-order
    function](https://en.wikipedia.org/wiki/Higher-order_function)” because it takes
    another function as an argument. Running this code gives us the mean of each element
    from `values_list`, as shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/668e596f283a5129731a5ab8c50e5028.png)'
  prefs: []
  type: TYPE_IMG
- en: As well as naming the function we want to apply, we can also use a formula to
    define the function. This is useful when defining functions with additional arguments,
    or more complex expressions. In the code below, we use such a formula to get the
    mean of each list element even when there are missing values in the data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we define the function as a formula with the tilde (~) symbol.
    Inside `mean`, we refer to the list element used as an argument with the dot (.)
    symbol. Defining the `mean` function with a formula allows us to specify extra
    arguments like `na.rm = TRUE` which deals with the NA values in `values_list`.
    This gives a list of means like the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: Why Use Map Functions Instead of Loops?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you’re familiar with for-loops, you might be seeing the similarities between
    what `map` is doing and how you could use a loop to solve the problem above. Here
    is the same operation expressed as a loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This loop is very simple. Each iteration, it takes a new element from `values_list`
    and prints the mean of the values in that element, like the `map` example. There
    is even an [R package](https://timteafan.github.io/loopurrr/) that converts `map`
    statements into loops!
  prefs: []
  type: TYPE_NORMAL
- en: So if you can express `map` statements as loops, why should you learn about
    `map` at all?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few advantages of mapping compared with looping:'
  prefs: []
  type: TYPE_NORMAL
- en: '`map` functions are often more concise, taking up one line rather than a minimum
    of three. This means they can be used inline and within other functions more easily,
    opening up powerful new possibilities for usage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike loops, mapping forces you to define functions. This leads to neater,
    more compartmentalised code that is easy to reuse.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relating to the last point, defining functions often speeds up your code. This
    means mapping can be faster than looping (although this isn’t guaranteed).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loops still have their place, and sometimes it’s preferable to use them when
    they’re the fastest option, or when repeating very complex or unusual operations.
    That said, the `map` family can deal with more complex functions as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'How To Use map Variants: map2 and pmap'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `map2` and `pmap` functions are straightforward extensions of `map`.
  prefs: []
  type: TYPE_NORMAL
- en: map2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`map2` lets you apply a function that takes two arguments. For example, you
    could use it to fit several linear models that take x and y variables as arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here we make two vectors, `x` and `y`, containing combinations of variables
    in the `mtcars` dataset. Inside our `map2` function expression, we refer to these
    variables as `.x` and `.y`. The `get` functions simply help `lm` locate the columns
    of interest in `mtcars` using their names. This results in three linear models
    being fitted; one for each combination of variables we specified.
  prefs: []
  type: TYPE_NORMAL
- en: pmap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`pmap` lets you apply a functional expression with more than two arguments.
    Concatenating together values from three separate lists for further analysis,
    for instance.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When calling `pmap`, we wrap our inputs in a list. Each input is then referred
    to as `..1, ..2, ..3` and so on. The result is a list of concatenated values,
    shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/876e3197a99124c24e6d112463f48fca.png)'
  prefs: []
  type: TYPE_IMG
- en: How to Control the Output of map Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might have noticed that all the examples so far have returned lists as their
    output. However, it’s possible to get map functions to return different types
    of vectors and dataframes instead.
  prefs: []
  type: TYPE_NORMAL
- en: Returning to the first example in this article, we can get a list of means using
    `map`. But we can also get a flat vector of means by using the `map_dbl` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/e7c2e309bedee543e0d546e72e1743ef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The result of the code above: a vector of means, not a list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Appending “_dbl” to our map function name enables this. There are a few other
    variants like this that work with `map`, `map2`, and `pmap`. Here is a list of
    them, and what they do:'
  prefs: []
  type: TYPE_NORMAL
- en: “_dbl” returns a double vector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “_lgl” returns a logical (TRUE/FALSE) vector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “_int” returns an integer vector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “_chr” returns a character vector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “_raw” returns a raw vector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “_dfr” returns a tibble where each row is the result of a map operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “_dfc” returns a tibble where each column is the result of a map operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using these function variants to return vectors and tibbles unlocks lots of
    possibilities. I often use `map_dbl` and `map_chr` inside other tidyverse functions
    like mutate to create new columns based on custom functions. I’ve also used `map_dfr`
    and `map_dfc` to replace long loops with only one or two lines of code. These
    are great functions, and they’re without a doubt useful enough to learn and remember.
  prefs: []
  type: TYPE_NORMAL
- en: Should You Use map Functions Instead of Base-R “apply” Functions?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we’ve established, the purrr package provides a whole family of `map` functions
    that can do all sorts of things.
  prefs: []
  type: TYPE_NORMAL
- en: However, R also comes with a built-in family of mapping functions; the `apply`
    functions. These have the same functionality as purrr’s basic map functions, with
    some variations in syntax and how they treat data types going in and out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the base-R `apply` functions are widely used, I prefer the purrr `map`
    functions for a few reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: It’s easier to understand exactly what type of data `map` functions will output.
    This isn’t always the case with the base-R functions, which can sometimes behave
    unpredictably based on their input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They’re built to be compatible with other tidyverse packages, which is useful
    if they’re already part of your workflow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Purrr also includes more advanced mapping functions that the `apply` family
    can’t match. Learning `map` enables you to pick these up more easily.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are some times when you might prefer using `apply`. If you’re developing
    a package and don’t want to introduce extra dependencies, built-in functions are
    the best option. `apply` functions can also be faster than their `map` counterparts,
    so they can be worth using to repeat computationally expensive operations.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless, the `map` functions are easier for newcomers to learn, which is
    why I focused on them here. Besides, once you know how to use `map`, `apply` functions
    will be much easier to understand too.
  prefs: []
  type: TYPE_NORMAL
- en: Learning `map` functions in R is a great way to extend your data science toolset.
    Mapping often saves space when compared to looping, without sacrificing readability.
    It also applies to many tasks and makes a great standard approach for efficiently
    repeating code. So now you know how to use `map`, try it out, and enjoy one of
    the most powerful tools in the tidyverse.
  prefs: []
  type: TYPE_NORMAL
