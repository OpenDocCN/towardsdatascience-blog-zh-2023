["```py\nimport numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom typing import List, Optional\n\ndef do_regression(arr_x: List, arr_y: List) -> Optional[List]:\n    \"\"\" LinearRegression for X and Y lists \"\"\"\n    try:\n        x_in = np.array(arr_x).reshape(-1, 1)\n        y_in = np.array(arr_y).reshape(-1, 1)\n        print(f\"X: {x_in}\")\n        print(f\"y: {y_in}\")\n\n        reg = LinearRegression().fit(x_in, y_in)\n        out = reg.predict(x_in)\n        print(f\"Out: {out}\")\n        print(f\"Score: {reg.score(x_in, arr_y)}\")\n        print(f\"Coef: {reg.coef_}\")\n        return out.reshape(-1).tolist()\n    except ValueError as err:\n        print(f\"ValueError: {err}\")\n    return None\n\nif __name__ == \"__main__\":\n    print(\"App started\")\n    ret = do_regression([1,2,3,4], [5,6,7,8])\n    print(f\"LinearRegression result: {ret}\")\n```", "```py\nimport logging\n\ndef do_regression(arr_x: List, arr_y: List) -> Optional[List]:\n    \"\"\"LinearRegression for X and Y Python lists\"\"\"\n    try:\n        x_in = np.array(arr_x).reshape(-1, 1)\n        y_in = np.array(arr_y).reshape(-1, 1)\n        logging.debug(f\"X: {x_in}\")\n        ...\n\n    except ValueError as err:\n        logging.error(f\"ValueError: {err}\")\n    return None\n\nif __name__ == \"__main__\":     \n    logging.basicConfig(level=logging.DEBUG, format='%(message)s')\n\n    logging.info(\"App started\")\n    ret = do_regression([1,2,3,4], [5,6,7,8])\n    logging.info(f\"LinearRegression result: {ret}\")\n```", "```py\nERROR = 40\nWARNING = 30\nINFO = 20\nDEBUG = 10\nNOTSET = 0\n```", "```py\nlogging.basicConfig(level=logging.DEBUG,\n                    format='[%(asctime)s] %(filename)s:%(lineno)d: %(message)s')\n```", "```py\nlogging.basicConfig(level=logging.DEBUG, \n                    format='[%(asctime)s] %(message)s',\n                    handlers=[logging.FileHandler(\"debug.log\"), \n                              logging.StreamHandler()])\n```", "```py\nfrom logging.handlers import TimedRotatingFileHandler\n\n...\n\nif __name__ == \"__main__\":\n    file_handler = TimedRotatingFileHandler(\n            filename=\"debug.log\",\n            when=\"midnight\",\n            interval=1,\n            backupCount=3,\n        )\n    logging.basicConfig(level=logging.DEBUG, \n                        format='[%(asctime)s] %(message)s',\n                        handlers=[file_handler, logging.StreamHandler()])\n```", "```py\nfrom logging.handlers import SocketHandler\n\nlogging.basicConfig(level=logging.DEBUG, format='[%(asctime)s] %(message)s',\n                    handlers=[SocketHandler(host=\"127.0.0.1\", port=15001), \n                              logging.StreamHandler()])\n```", "```py\nimport socket\nimport logging\nimport pickle\nimport struct\nfrom logging import LogRecord\n\nport = 15001\nstream_handler = logging.StreamHandler()\n\ndef create_socket() -> socket.socket:\n    \"\"\"Create the socket\"\"\"\n    sock = socket.socket(socket.AF_INET)\n    sock.settimeout(30.0)\n    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    return sock\n\ndef read_socket_data(conn_in: socket.socket):\n    \"\"\"Read data from socket\"\"\"\n    while True:\n        data = conn_in.recv(4)  # Data: 4 bytes length + body\n        if len(data) > 0:\n            body_len = struct.unpack(\">L\", data)[0]\n            data = conn_in.recv(body_len)\n            record: LogRecord = logging.makeLogRecord(pickle.loads(data))\n            stream_handler.emit(record)\n        else:\n            logging.debug(\"Socket connection lost\")\n            return\n\nif __name__ == \"__main__\":\n    logging.basicConfig(level=logging.DEBUG, format='[%(asctime)s] %(message)s',\n                        handlers=[stream_handler])\n\n    sock = create_socket()\n    sock.bind((\"127.0.0.1\", port))  # Local connections only\n    sock.listen(1)  # One client can be connected\n    logging.debug(\"Logs listening thread started\")\n    while True:\n        try:\n            conn, _ = sock.accept()\n            logging.debug(\"Socket connection established\")\n            read_socket_data(conn)\n        except socket.timeout:\n            logging.debug(\"Socket listening: no data\")\n```", "```py\nfrom logging import LogRecord, Filter\n\nclass DataFilter(Filter):\n    \"\"\"Filter for logging messages\"\"\"\n\n    def filter(self, record: LogRecord) -> bool:\n        \"\"\"Save only filtered data\"\"\"\n        return \"x:\" in record.msg.lower() or \"y:\" in record.msg.lower()\n```", "```py\nfile_handler = logging.FileHandler(\"debug.log\")\nfile_handler.addFilter(DataFilter())\n\nlogging.basicConfig(level=logging.DEBUG, \n                    format='[%(asctime)s] %(message)s',\n                    handlers=[file_handler, logging.StreamHandler()])\n```"]