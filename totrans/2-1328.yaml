- en: 'Ink to Insights: Comparing SQL and Python Queries using Bookshop Analytics'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/ink-to-insights-comparing-sql-and-python-queries-using-bookshop-analytics-90e3bb200671](https://towardsdatascience.com/ink-to-insights-comparing-sql-and-python-queries-using-bookshop-analytics-90e3bb200671)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which approach is better for your exploratory data analysis?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@john_lenehan?source=post_page-----90e3bb200671--------------------------------)[![John
    Lenehan](../Images/addeeb0bacca7ddec928aa12c2a4fc53.png)](https://medium.com/@john_lenehan?source=post_page-----90e3bb200671--------------------------------)[](https://towardsdatascience.com/?source=post_page-----90e3bb200671--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----90e3bb200671--------------------------------)
    [John Lenehan](https://medium.com/@john_lenehan?source=post_page-----90e3bb200671--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----90e3bb200671--------------------------------)
    ·9 min read·Sep 1, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c7141249ee90ee12403abfe5fb98a1d2.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Ayman Yusuf](https://unsplash.com/@ayman_yusuf97?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: SQL is the bread and butter of any data scientist’s toolbox — the ability to
    quickly pull data from a data source for analysis is an essential skill for anyone
    working with large amounts of data. In this post I wanted to give some examples
    of a few basic queries I typically use in SQL, over the course of an EDA process.
    I’ll compare these queries against similar scripts in Python which produce the
    same output, as a comparison between the two approaches.
  prefs: []
  type: TYPE_NORMAL
- en: For this analysis I’ll be using some synthetic data on last year’s highest rated
    books from a hypothetical chain of bookshops (the Total Fiction Bookstore). A
    link to the github folder for this project can be found [here](https://github.com/jlenehan/Bookshop_EDA),
    where I go into the details of running the analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d202ae38130a05412bd27ed575c3a2cb.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Eugenio Mazzone](https://unsplash.com/@eugi1492?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: 'As a side note — while I mainly focus on the SQL queries in this article, it’s
    worth noting that these queries can be integrated pretty seamlessly with Python
    using the pandaSQL library (as I’ve done for this project). This can be seen in
    detail in the Jupyter notebook on this project’s GitHub link, but the structure
    of this query generally goes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: PandaSQL is a very practical library for those who have more familiarity with
    SQL querying than the typical Pandas dataset manipulation — and is often much
    easier to read, as I will show here.
  prefs: []
  type: TYPE_NORMAL
- en: The Dataset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A snippet of the dataset can be seen below — there are columns for book title
    and the year it was published, the number of pages, the genres, the book’s average
    rating, the author, number of units sold, and book revenue.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4c8759f11afac45d9c5b72ade2644986.png)'
  prefs: []
  type: TYPE_IMG
- en: Synthetic data to be analysed (data by author)
  prefs: []
  type: TYPE_NORMAL
- en: Revenue Analysis by Decade
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say I want to know which decade has published the most profitable books
    for the bookshop. The original dataset doesn’t have a column for which decade
    the books were published in — however this is relatively straightforward to input
    to the data. I run a subquery to divide the year using floor division and multiply
    by 10 to get the decade data, before aggregating and averaging the revenue by
    decade. I then order the results by total revenue to get the most profitable decades
    of published books in the bookshop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By comparison, an equivalent output in Python would look something like the
    code snippet below. I apply a lambda function which runs the floor division and
    outputs the decade, and from there I aggregate the revenue by decade and sort
    the result by total revenue.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note the greater number of separate steps there are in the python script to
    achieve the same result — the functions are awkward and difficult to understand
    on first glance. By comparison the SQL script is much clearer in its presentation,
    and much easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: I can now take this query and visualise it to get a sense of the book revenue
    trends across the decades, setting up a matplotlib graph using the following script
    — bar charts show the total revenue by decade, with a scatter plot on the secondary
    axis to show average book revenue.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The visualisation can be seen below — books published in the 1960s are apparently
    the most profitable for the bookshop, generating over $192,000 in revenue for
    Total Fiction Bookstore. By comparison, books on the list from the 1900s are more
    profitable on average, though didn’t sell as well as books from the 1960s.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/74e4067d720de7eb4e0322fcf2ec3c89.png)'
  prefs: []
  type: TYPE_IMG
- en: Total and average revenue by published decade (image by author)
  prefs: []
  type: TYPE_NORMAL
- en: Average book revenue follows a similar trend to total revenue across all decades
    of published books — with the exception of books from the 1900s and 1980s, which
    are more profitable on average but not overall.
  prefs: []
  type: TYPE_NORMAL
- en: Author Analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, suppose I want to get data on the top 10 authors in the list, ordered by
    their total generated revenue. For this query I want to know the number of books
    they’ve made that appear on the list, the total revenue they’ve generated on those
    books, their average revenue per book, and the average rating of those books in
    the bookshop. Simple enough question to answer using SQL — I can use a count statementto
    get the total number of books they’ve made, and avg statements to get the mean
    revenue and rating per author. Following that I can group these statements by
    director.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: An equivalent Python script would look like this — roughly the same length,
    but much more complex for the same output. I group the values by author before
    specifying how to aggregate each column in the agg function, then sorting the
    values by total revenue. Again, the SQL script is much clearer by comparison.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The output from this query can be seen below — Ava Mitchell leads the field,
    with a total revenue of over $152,000 from her book sales. Emma Hayes takes 2nd
    place at over $85,000, with Liam Parker close behind at over $83,000.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/fd9403ef9a01506a7a34da60f5bdb47a.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of the book author query
  prefs: []
  type: TYPE_NORMAL
- en: Visualising this in matplotlib using the following script, we can generate bar
    plots of total revenue with data points showing the average book revenue per author.
    The average rating per author is also plotted on a secondary axis.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this, we get the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/aba0c9453bcdd05265b6c7f25cb7d10e.png)'
  prefs: []
  type: TYPE_IMG
- en: Top 10 authors by revenue and rating (image by author)
  prefs: []
  type: TYPE_NORMAL
- en: This graph does point to a pretty clear assertion — revenue doesn’t correlate
    with average rating for each author. Ava Mitchell has the highest revenue but
    is at the median in terms of rating for the authors listed above. Olivia Hudson
    is highest by average rating while placing 8th in total revenue; there is no observable
    trend between an author’s revenue and their popularity.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Book Length vs Revenue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, let’s assume I want to show how book revenue differs based on the book
    length. To answer this question, I first want to divide the books equally into
    4 categories based on the book length quartiles, which will give a better idea
    of overall revenue vs book length trends.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, I define the quartiles in SQL, using a subquery to generate these values,
    before sorting the books into these buckets using a case when statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively (for SQL dialects that don’t support percentile functions, like
    SQLite), the quartiles can be calculated separately before inputting them manually
    to the case when statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Running this same query in Python, I define the percentiles using numpy before
    using the cut function to sort the books into their buckets, then sorting the
    values by book langth in pages. As before, this process is noticeably more complex
    than the equivalent script in SQL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The output to this query can be visualised as boxplots using seaborn — a snippet
    of the script used to generate the boxplots can be seen below. Note that the runtime
    buckets were manually sorted into the correct order to have them properly presented.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The boxplots can be seen below —note the median revenue for each book length
    quartile trends upwards as the books get longer. This suggests that longer books
    are more profitable at the bookshop.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/092229bc48947966640cf80587ee58c7.png)'
  prefs: []
  type: TYPE_IMG
- en: Boxplot of revenue by book length quartile (image by author)
  prefs: []
  type: TYPE_NORMAL
- en: Additionally the range of the 4th quartile is much wider compared to the other
    quartiles, indicating there’s more variation in the price point for larger books.
  prefs: []
  type: TYPE_NORMAL
- en: Final Thoughts and Further Applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To conclude, the use of SQL for data analysis queries is typically much more
    straightforward than using equivalent operations in Python; the language is easier
    to write than Python queries, while broadly capable of producing the same results.
    I wouldn’t argue that either is better than the other — I’ve used a combination
    of both languages in this analysis — rather, I believe that using a combination
    of both languages together can produce more efficient and effective data analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, given the higher clarity in writing SQL queries over queries in Python,
    I think it’s much more natural to use this when performing the initial EDA for
    a project. SQL is far easier to read and write as I’ve shown in this article,
    making it especially advantageous for these early exploratory tasks. I often use
    it when beginning on a project, and I’d recommend this approach to anyone who
    already has a decent grasp of SQL querying.
  prefs: []
  type: TYPE_NORMAL
