- en: 5 Code Optimization Techniques To Speed Up Your Programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/5-code-optimization-techniques-to-speed-up-your-programs-cc7740381bcb](https://towardsdatascience.com/5-code-optimization-techniques-to-speed-up-your-programs-cc7740381bcb)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Make your code more efficient and professional with these language-agnostic
    methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@nic-obert?source=post_page-----cc7740381bcb--------------------------------)[![Nicholas
    Obert](../Images/d70330063c9edc2f63e53f62a78f82ec.png)](https://medium.com/@nic-obert?source=post_page-----cc7740381bcb--------------------------------)[](https://towardsdatascience.com/?source=post_page-----cc7740381bcb--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----cc7740381bcb--------------------------------)
    [Nicholas Obert](https://medium.com/@nic-obert?source=post_page-----cc7740381bcb--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----cc7740381bcb--------------------------------)
    ·7 min read·Nov 29, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1538a19522e68cf19f04a0b3e4287df6.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Shubham Dhage](https://unsplash.com/@theshubhamdhage?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Make it work first, then make it fast. This is one common principle many professional
    programmers go by. At first, you may write your code using whichever approach
    seems the most intuitive to save development time on the draft. After you got
    a working implementation, you may want to optimize it by carefully choosing which
    techniques data structures work best in your specific case.
  prefs: []
  type: TYPE_NORMAL
- en: In this article, we’ll explore five language-agnostic methods you can use to
    improve your code runtime. The following concepts are generic and can be applied
    to any programming language.
  prefs: []
  type: TYPE_NORMAL
- en: Loop-invariant extraction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following Python code that checks a list of strings against a
    regular expression to find all the matches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Loops repeatedly apply a set of instructions to a varying input. With this in
    mind, can you spot any operation that doesn’t change in the code above?
  prefs: []
  type: TYPE_NORMAL
- en: 'The statement ``rex = re.compile(r’[a-z]+’)`` operates on a constant input:
    the regex string. For every iteration of the loop, this statement does exactly
    the same thing, independently from the loop’s input. If we were to extract this
    invariant statement and execute it once before the loop, the code would still
    have the same overall behavior while saving some CPU cycles.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As a rule of thumb, every variable or operation that is loop-invariant (doesn’t
    depend on the loop’s input or state) should be extracted out of the loop as long
    as the code logic remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, compilers will apply this kind of optimization to your code automatically.
    However, they are not guaranteed to always detect redundant statements, and interpreted
    languages don’t have the privilege of ahead-of-time optimization, so you should
    keep an eye on loop-invariant code.
  prefs: []
  type: TYPE_NORMAL
- en: Enum states and types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When representing a variable object state, beginner programmers might think
    of using a string. Consider the following Rust code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: While strings are an intuitive solution, there are a few problems with that.
    First, string states are vulnerable to typing errors, as shown by the last if
    statement. Also, which are the possible states?
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, we’re here to talk optimization. String comparison is terribly slow,
    as you have to check every single character to know whether they are equal. Also,
    strings require significantly more bytes to store than other alternatives. For
    example, you can use an enum to represent the object state and not worry about
    typing mistakes while harnessing the speed of integer comparison.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Enums are an abstraction based on integers and require very little memory to
    store. On top of that, enums are usually passed by value, thus avoiding the dereferencing
    overhead during operations like comparison. Many languages support enums natively,
    and most allow for such a pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Algebraic and boolean operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following code snippets that include conditional statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If-statements are compiled into conditional jump instructions, which can make
    your code notably slower when compared to linear branch execution. Sometimes,
    conditional statements can be substituted with an equivalent expression that is
    **usually** faster, depending on its length and operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the previous functions optimized using boolean and arithmetic expressions
    instead of conditionals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: However, you should always perform a benchmark on any supposedly optimized alternative
    to check whether it’s actually faster.
  prefs: []
  type: TYPE_NORMAL
- en: Memoization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No, it’s not a spelling mistake. Memoization is an algorithm optimization technique
    that consists of memorizing the output of a function along with its input. When
    dealing with resource-intensive functions that are going to be called multiple
    times, you can store the input and result in a map data structure so that you
    don’t have to compute the function again if the input is the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'A classic example of a function that can be improved with memoization is computing
    the Fibonacci sequence. Consider the following code that calculates the nth number
    of the Fibonacci sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: For small inputs `n`, the function doesn’t take much time to execute. However,
    due to its time complexity of O(2ⁿ), larger input values will result in a significantly
    longer runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider now this other approach that takes advantage of memorization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the graph below, memoization greatly improves the function
    runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c2f38a31ac40a49f8055924c8a95e31d.png)'
  prefs: []
  type: TYPE_IMG
- en: Benchmark of regular fibonacci function and memoization-optimized alternative
    (lower is faster)
  prefs: []
  type: TYPE_NORMAL
- en: This is because this memoized function’s time complexity is roughly linear.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ae8ca033430d1d41f0da25fc07432962.png)'
  prefs: []
  type: TYPE_IMG
- en: Memoized fibonacci function time complexity
  prefs: []
  type: TYPE_NORMAL
- en: Use a case-specific data structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One common example of data structure choice is the ubiquitous linked list vs
    array dilemma. Do you need the O(1) insertion time of linked lists or do you need
    the fast random indexing of arrays? When it comes to the choice of data structure,
    you have to compare the pros and cons of each option to find what fits your case
    best. Sometimes, you may even want to implement a custom-made data structure to
    fit exactly your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few other examples of common data structure choices for optimization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Copy-on-write](https://en.wikipedia.org/wiki/Copy-on-write) implementations
    (COW). Structures that implement COW allow you to efficiently and safely pass
    data around via a shared immutable reference. The data gets copied only if you
    actually try to mutate it, thus saving time on pointless operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Circular buffers](https://en.wikipedia.org/wiki/Circular_buffer) are a common
    alternative to traditional arrays when implementing queue-like behavior or for
    caching data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Lookup tables](https://en.wikipedia.org/wiki/Lookup_table) and [hash tables](https://en.wikipedia.org/wiki/Hash_table)
    are used for fast indexing of data or handling different cases efficiently without
    branching.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing tables are a combination of lookup and hash tables nested in a tree-like
    fashion that allows you to efficiently and concisely parse structured data without
    having to write intricated and error-prone code. They are extensively used in
    compilers and classification algorithms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key takeaways
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Optimizing code is not a simple job. You have to find the relevant bottlenecks
    first. Then, check carefully whether there are any redundant operations or a more
    direct approach to solve a problem. You may need to sketch your ideas out onto
    a piece of paper to better visualize algorithms, memory layouts, and data structures.
    Lastly, perform benchmarks and tests to see if you actually made your code any
    better or you broke something.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you enjoyed this article. If you have any thoughts, please share them
    in a comment. Thanks for reading!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re interested in learning more about code optimization, check out the
    following article about lookup tables and hash tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://betterprogramming.pub/get-rid-of-excessive-if-else-statements-with-lookup-and-hash-tables-c7dbed808996?source=post_page-----cc7740381bcb--------------------------------)
    [## Get Rid of Excessive If-Else Statements With Lookup and Hash Tables'
  prefs: []
  type: TYPE_NORMAL
- en: A code performance practice that is used all-over professional codebases. Learn
    to use them with these simple examples.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: betterprogramming.pub](https://betterprogramming.pub/get-rid-of-excessive-if-else-statements-with-lookup-and-hash-tables-c7dbed808996?source=post_page-----cc7740381bcb--------------------------------)
  prefs: []
  type: TYPE_NORMAL
