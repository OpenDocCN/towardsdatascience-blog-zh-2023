- en: Automated Python Application Testing Using GitHub Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: åŽŸæ–‡ï¼š[https://towardsdatascience.com/automated-python-application-testing-using-github-actions-79606f3f9eb2](https://towardsdatascience.com/automated-python-application-testing-using-github-actions-79606f3f9eb2)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How to run automatic testing on the `push` command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://philip-wilkinson.medium.com/?source=post_page-----79606f3f9eb2--------------------------------)[![Philip
    Wilkinson, Ph.D.](../Images/9811fa38963c29193b01a5cf856d014f.png)](https://philip-wilkinson.medium.com/?source=post_page-----79606f3f9eb2--------------------------------)[](https://towardsdatascience.com/?source=post_page-----79606f3f9eb2--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----79606f3f9eb2--------------------------------)
    [Philip Wilkinson, Ph.D.](https://philip-wilkinson.medium.com/?source=post_page-----79606f3f9eb2--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: Â·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----79606f3f9eb2--------------------------------)
    Â·6 min readÂ·Mar 21, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/cda5a053f31851154a45ff8b1b4be350.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Roman Synkevych ðŸ‡ºðŸ‡¦](https://unsplash.com/@synkevych?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Testing your application is a crucial step in any software development or data
    science workflow. Testing allows you to ensure that the code functions as expected,
    reduces the likelihood of bugs or errors, and increases the overall quality and
    reliability of the software.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases though testing can often be a burden and yourself or others may
    forget to run the testing suite before you commit to your repository. This is
    where automating your testing workflow through GitHub Actions comes into play,
    to reduce the manual effort required, ensure consistent testing and be able to
    detect issues early on.
  prefs: []
  type: TYPE_NORMAL
- en: In this article I will cover how to set up a GitHub Action workflow to automate
    the testing of your application. This includes creating a GitHub Action workflow,
    setting the trigger events, creating the jobs to run and adding a badge to your
    repository to show the tests are passing. By the end of this you will have a fully
    automated testing workflow that you can show to the world that your code is working
    as expected!
  prefs: []
  type: TYPE_NORMAL
- en: What is a GitHub Action?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As per the description provided by GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Actions makes it easy to automate all your software workflows, now with
    world-class CI/CD. Build, test, and deploy your code right from GitHub.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: which means that GitHub Actions is an automation platform provided by GitHub
    that focuses on automating software development workflows.
  prefs: []
  type: TYPE_NORMAL
- en: An Action itself is then a unit of code that can be executed as part of a GitHub
    Actions workflow. This aims to automate a specific task or workflow that is triggered
    by events in your GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Importantly, a GitHub Action can be written in any language, can run on any
    operating system and can interact with the code in your repository through the
    GitHub API. They can be used for a variety of tasks including automating the deployment
    of the latest builds, updating datasets in the code base, and for our purposes
    testing the latest push to the main branch.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a GitHub Action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a GitHub Action action is a relatively simple process and starts by
    creating a new directory in your GitHub repository. This takes the form of a folder
    title `.github/workflows` which is recognised by GitHub as containing actions
    that we want GitHub to undertake.
  prefs: []
  type: TYPE_NORMAL
- en: 'GitHub Actions uses YAML files that describe the action that we want GitHub
    to perform. This means that in the `.github/workflows` folder, we need to create
    a YAML file. For now we can call this `python-app.yml` and we can give it a name
    in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is the base which we will then build on to run our testing suite.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the trigger events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the file has been created, telling GitHub that we want it to run some action,
    we need to tell GitHub when we want this to take place. We do this by specifying
    the trigger events in the YAML file using the `on` key.
  prefs: []
  type: TYPE_NORMAL
- en: 'For testing, you typically want to run the full application testing suite when
    any changes are made to the application to ensure that the changes made do not
    introduce any bugs into the system. Given the best practices of Git this often
    falls at two points:'
  prefs: []
  type: TYPE_NORMAL
- en: Any pushes to the `main` application branch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any pull requests to the `main` application branch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is because the latest deployment of your application should normally come
    from the `main` branch of your repository. In our YAML file this can be specified
    using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here the `push` key is used to specify that we want the action to be run on
    a push to the `main` branch and we use the `pull_request` key to specify we want
    the testing suite to also be run when a pull request is made to the main branch.
  prefs: []
  type: TYPE_NORMAL
- en: This ensures that any changes to the main branch are fully tested before any
    deployment takes place and is run whenever the changes are made public.
  prefs: []
  type: TYPE_NORMAL
- en: Create the job to run
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have told GitHub when we want to run an action, we need to actually
    tell it what we actually want to run. This is done using the `jobs` key which
    specifies the job that will be run as part of the GitHub Action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within this `job` we need to specify three main things:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the job that we want to run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The platform we want the workflow to run on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `steps` that we want to be undertaken as part of the workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is done by first using the key `jobs:` followed by the name of the job
    we want to undertake. For now we can simply call this `build` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the `build` key, we then need to specify what platform we want the
    job to run on. In our case we can specify `runs-on: ubuntu-latest` , assuming
    that Linux is a suitable platform for our testing suite.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We then specify a series of steps that we want to undertake within this `job`
    . To run our testing suite we will need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Checkout the repository to the run platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setup Python on the environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install the dependencies required to run the testing suite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the testing suite itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This can be done with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Explaining these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '`uses: actions/checkout@v3` tells the runner that we want to use the `actions/checkout@v3`
    functionality which checks out the repository code into the job''s workspace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name: Set up Python 3.10` creates a step that setups the Python environment
    on the runner to use version 3.10.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name: Install dependencies` installs the necessary dependencies for the project
    which includes those specified in the `requirements.txt` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name: Test with pytest` Runs the testing suite using the `pytest` command
    which will fail the job if a test doesnâ€™t pass.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For this, we split up the steps using the `name` key which means that we can
    clearly identify at which point in our workflow, if any, fails. We can then use
    these names to be able to rectify any issues quickly and creates a jobs workflow
    that looks like the image below.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/dcf70df39e391c5e68eec6c5e6705c92.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: Adding a badge to your repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating the above file will tell GitHub that we want to run the testing workflow
    for our repository but the anyone looking at our repository wonâ€™t necessarily
    see that straight away. To rectify that we can create a badge that will show up
    in our README markdown document to clearly show that our tests are passing.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ffc51f73697446cece6faacc1e932c6a.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'This tells any new user at a single glance that the build on the main branch
    is stable and that the application is tested. The syntax for this badge follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For my repository that I am currently developing, this translates into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Where Iâ€™ve also added a link to the workflow file as well so that people looking
    at the repository can also see what this badge is clearly saying.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing your code is a key part of any software engineering or data science
    workflow but it can also be an easy step to forget before you push your changes
    to the main branch. To simply this process and ensure testing consistency across
    all developers, you can create a GitHub Action that will automate your testing
    workflow. In the article above we have shown how you can add this to your own
    repository in a few simple steps. An important part of this is telling new users
    of your application that you have tested your application, and this can come in
    the form of a badge that you can add to your README file.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a testing workflow can be found in my repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PhilipDW183/flask_petrol_map](https://github.com/PhilipDW183/flask_petrol_map)'
  prefs: []
  type: TYPE_NORMAL
