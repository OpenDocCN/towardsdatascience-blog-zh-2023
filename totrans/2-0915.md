# 预测 API：一个使用 Django 和 Google Trends 的示例

> 原文：[https://towardsdatascience.com/forecasting-api-an-example-with-django-and-google-trends-9b55046bd578](https://towardsdatascience.com/forecasting-api-an-example-with-django-and-google-trends-9b55046bd578)

## 构建一个 web 应用程序以预测 Google Trends 的发展趋势。

[](https://medium.com/@davide.burba?source=post_page-----9b55046bd578--------------------------------)[![Davide Burba](../Images/a1ca3cf59c2b933021fa0d978e1af522.png)](https://medium.com/@davide.burba?source=post_page-----9b55046bd578--------------------------------)[](https://towardsdatascience.com/?source=post_page-----9b55046bd578--------------------------------)[![Towards Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----9b55046bd578--------------------------------) [Davide Burba](https://medium.com/@davide.burba?source=post_page-----9b55046bd578--------------------------------)

·发布于 [Towards Data Science](https://towardsdatascience.com/?source=post_page-----9b55046bd578--------------------------------) ·阅读时间 14 分钟·2023年8月1日

--

![](../Images/8e462ec58405d206471214cd10c1d9ea.png)

“Google Trends”，由 [Giulia Roggia](https://www.instagram.com/giulia_roggia__/)。经许可使用。

+   [简介](#7d44)

+   [Django 模型](#3fbd)

+   [服务](#68d5)：[数据源](#7d4e)，[预处理](#cca9)，[机器学习](#b276)，[任务](#1912)

+   [交互层](#aeaa)：[序列化器](#f468)，[视图](#665f)，[端点](#e0f4)

+   [结论](#476d)

# 简介

## 什么是 Django？

[Django](https://www.djangoproject.com) 是一个高级 Python 网络框架。它设计得快速、安全、可扩展，因此是开发预期会增长复杂性的强大 web 应用程序的热门选择。有关 Django 的介绍，请参阅 [这个教程](https://docs.djangoproject.com/en/4.2/intro/tutorial01/)。

在这个示例中，我们将使用 [Django Rest Framework](https://www.django-rest-framework.org)（DRF），这是 Django 的一个扩展，旨在简化 [REST API](https://www.redhat.com/en/topics/api/what-is-a-rest-api) 的开发。有关 DRF 的介绍，请参阅 [这个教程](https://www.django-rest-framework.org/tutorial/quickstart/)。

## 需求

我们将通过列出一些假设的需求来开始设计我们的应用：

+   **总体目标**：实现一个系统来预测未来时间序列的值。

+   **数据**： [Google Trends](https://trends.google.com/trends/) 的周频数据，包含特征和目标，未来可能会扩展。数据应根据需求下载。

+   **预处理**：仅使用滞后值。

+   **机器学习模型**：一个全球 LightGBM 模型（如果你想了解更多关于全球与本地模型的区别，可以查看 [这篇文章](https://medium.com/towards-data-science/local-vs-global-forecasting-what-you-need-to-know-1cc29e66cae0)）。

+   **推断**：生成在线预测（与批量预测相对），但不需要提供输入特征。

*本教程中使用的完整代码可在* [*这里*](https://github.com/davide-burba/code-collection/)*获取*。

## 设置环境

让我们从列出所需的依赖项开始。

[PRE0]

我们将使用[poetry](https://python-poetry.org)来管理依赖项，使用[Docker](https://www.docker.com)来容器化项目。你可以在[这里](https://github.com/davide-burba/code-collection/tree/main/examples/api-example-django)查看本项目中使用的poetry和docker文件。

## 快速开始

如果你想跳过前面的内容，直接开始使用应用程序，你可以运行以下命令：

[PRE1]

并连接到`localhost:8000/gtrends`！

# Django模型

在本节中，我们列出了示例中使用的Django模型。

## 时间序列

对于一个预测系统，我们需要处理时间序列数据。通常我们只需要两个模型：一个用于识别每个时间序列，另一个用于存储其值。但由于**Google Trends的历史数据可能会因为归一化而每天发生变化**，我们还需要对数据进行版本控制，这会导致额外的一个模型。

我们还创建了一个模型，用于列出不同的数据源（目前只有Google Trends）。

[PRE2]

## 配置

要训练一个监督模型，我们需要一组特征和目标。我们可以将这些信息存储在一个“数据配置”中。这个过程通过以下模型完成。

[PRE3]

同样，我们需要存储预处理和机器学习（ML）模型的配置。为了简化，我们将这些存储在一个`JSONField`中：

[PRE4]

## ML模型

在这里，我们区分了ML配置和ML模型。ML配置包含关于LightGBM参数的数据，而ML模型包含所有关于数据、预处理和ML配置的信息。

一个ML模型可以在不同的数据集上进行估计（由于新数据的到来），因此我们还需要对ML模型进行版本控制。这会导致以下两个模型：

[PRE5]

`MLModelVersion`保存了指向LightGBM工件的链接在`ml_file`中，以及关于它所训练数据的信息在`metadata`中。工件存储在django设置模块中指定的位置：例如，可能是文件系统中的一个文件夹或云中的一个S3桶。

# 服务

在本节中，我们描述了包含应用逻辑的服务。根据[Django-StyleGuide](https://github.com/HackSoftware/Django-Styleguide/tree/master#overview)，将其与视图分开是最佳实践。

## 数据源

由于数据源预计将来会增长，我们将使用灵活的设计：

+   一个抽象的`DataSource`类，定义了一个接口。

+   一个`GTrendSource`类，继承自`DataSource`并实现下载Google Trends数据的细节。

+   一个`download_data`工厂用来构建`DataSource`子类。

这会产生以下模块：

[PRE6]

## 预处理

一旦数据加载完成，我们希望预处理数据以便后续训练模型或推断未来值。让我们从定义一个接口类开始。

[PRE7]

目前我们只考虑用于特征工程的滞后值。让我们创建一个实现滞后逻辑的辅助函数。

[PRE8]

现在我们需要创建一个实现基类抽象方法的类。让我们首先定义它的属性。

[PRE9]

请注意，目标本身可以作为特征使用。对于作为特征使用的目标，我们分配一个通用前缀“target”。当有多个目标时，这可能是有益的，因为它们将堆叠在相同的列中，从而减少特征的数量。

这里是构建滞后目标和特征的实现：

[PRE10]

现在我们可以将它们封装在一个`build_x`方法中：

[PRE11]

为了构建目标，我们只需将其移动`horizon`时间步：

[PRE12]

现在我们可以为所需的抽象方法提供实现：

[PRE13]

## ML

让我们定义一个非常简单的ML模块，提供两个函数用于转储和加载LightGBM模型（如果你想知道我们为何选择使用LightGBM，你可以查看[这篇文章](https://medium.com/towards-data-science/gradient-boosting-a-silver-bullet-in-forecasting-5820ba7182fd)）。

[PRE14]

# 任务

在定义API接口之前，让我们定义一些将在端点中使用的`tasks`。

## **更新时间序列**

我们首先需要存储一些时间序列数据。我们不希望每次下载一个新的数据点时都增加一个新版本到数据库中，因为这样会快速增长并产生大量重复数据。相反，我们希望将新下载的数据与最新版本进行比较，**只有当数据历史不匹配时才创建新版本**。这是在以下代码片段中完成的：

[PRE15]

我们还可以添加一个包装器，以方便地更新数据库中的所有时间序列：

[PRE16]

## 加载数据

现在我们已经存储了一些时间序列数据，我们希望能够加载它以便进行预处理。

[PRE17]

## 预处理

让我们将预处理封装成几个任务。为了简化，我们直接使用`Preprocessor`类；如果以后想添加另一个预处理类，我们可以使用与数据源相同的工厂模式。

[PRE18]

## 训练

现在我们已经有了预处理的数据，我们终于可以训练我们的LightGBM模型了。请注意，这是更简单的步骤！

[PRE19]

## 存储ML模型

现在我们可以创建一个任务，将LightGBM引擎保存以创建一个新的`MLModelVersion`。注意，我们首先将引擎转储到一个临时文件中。这只是一个技巧，以避免在任务中硬编码存储类型，而是通过Django设置动态处理。有关此主题的更多信息，请查看[FileField文档](https://docs.djangoproject.com/en/4.2/ref/models/fields/#filefield)。

[PRE20]

## 管道

我们现在可以完成训练和推断管道。由于这些管道速度较快，可以将它们简单地封装在一个函数中。然而，对于长时间运行的管道或高流量的情况，建议使用任务管理器，如 [AirFlow](https://airflow.apache.org) 或 [Celery](https://docs.celeryq.dev/en/stable/index.html)。

这是训练管道：

[PRE21]

这是推断管道：

[PRE22]

# 交互层

序列化器、视图和端点代表应用程序的“交互”层，这是最外部的层，并定义了用户如何与应用程序交互。

# 序列化器

序列化器负责序列化和反序列化数据。以下是一个简单的示例：

[PRE23]

为了简洁起见，我们只讨论那些非平凡的视图。

## 时间序列

对于时间序列，我们重写默认的创建方法，以便在创建 `TimeSeries` 对象时下载第一个版本。

[PRE24]

## 数据配置

对于数据配置，我们添加了特征和目标的链接，以便以后从单个端点创建数据配置。

[PRE25]

## 预处理

让我们在预处理配置上添加一个验证步骤，以检查是否具有预期的参数：

[PRE26]

## ML 配置

同样，让我们检查为 ML 配置提供的参数是否有效：

[PRE27]

# 视图

现在让我们定义用户如何与 API 交互。我们将定义一些动作来触发数据检索或 ML 模型训练。同样，这种做法是可以接受的，因为这些动作执行速度很快，并且我们希望在项目开始时保持简单（如果你对这种哲学感兴趣，可以查看 [YAGNI](https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it)）。然而，随着项目的增长，可能需要将这些动作异步化并使用任务管理器。

请注意，为了保持版本控制，我们不允许使用 `put` 和 `patch` 方法。

## 时间序列

让我们为时间序列建立一个视图。我们希望能够：

+   创建时间序列并列出它们

+   获取最新版本的值

+   更新值

[PRE28]

我们还希望列出一个时间序列的不同版本，并检查其值。

[PRE29]

## 配置

我们希望列出、添加和删除配置。它们的视图是直接的。

[PRE30]

## ML 模型

对于 ML 模型，我们希望能够创建和列出它们，并执行训练和推断。

[PRE31]

我们还希望列出特定 `MLModel` 的所有版本。

[PRE32]

# 端点

最后，我们可以将刚创建的视图链接到一组端点：

+   `timeseries` 用于时间序列

+   `timeseries/<id>/versions` 用于时间序列版本

+   `model-config`、`data-config`、`preprocessing-config` 用于配置对象

+   `model` 用于 ML 模型

+   `model/<id>/versions` 用于 ML 模型版本

这在以下模块中完成：

[PRE33]

请注意，我们不需要为数据检索或训练定义端点，因为这些会自动添加为“额外操作”。例如，训练模型的端点是 `model/<id>/train`。

# 结论

我们在 Django 中看到了一个预测系统的示例实现。你现在可以开始玩玩这个系统了！要开始，请按照文章开头的说明进行操作，以便你可以连接到 `localhost:8000/gtrends` 并玩转这个应用。

完成设置并训练好模型后，你应该会看到类似于这样的结果（这里我们预测的是术语 *"forecasting"*）：

![](../Images/d7b745b45f5231f07e285bda36f958c1.png)

当你预测未来值时，你应该会看到类似这样的结果：

![](../Images/682d156c586729c82d906a85f166bd52.png)

就这些，你现在可以根据需要实现不同的变体！

这里是可能改进的非详尽列表：

+   实现任务调度

+   添加更多数据源

+   添加一个 [回测](https://medium.com/towards-data-science/why-backtesting-matters-and-how-to-do-it-right-731fb9624a) 端点

+   添加更多预处理选项

+   集成 [MLFlow](https://mlflow.org/) 用于跟踪和版本控制

+   允许用一个模型训练多个预测视角

+   设置适当的网络服务器（生产环境所需）

*喜欢这篇文章吗？* [*查看我的其他文章*](https://medium.com/@davide.burba) *并关注我以获取更多内容！* [*点击这里*](https://medium.com/@davide.burba/membership) *以无限阅读文章，并且对你没有额外费用的情况下支持我*❤️
