- en: Mastering Time Series Analysis with Python Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/mastering-time-series-analysis-with-python-classes-1a4215e433f8](https://towardsdatascience.com/mastering-time-series-analysis-with-python-classes-1a4215e433f8)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Object Orienting Programming for Time Series Analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://spierre91.medium.com/?source=post_page-----1a4215e433f8--------------------------------)[![Sadrach
    Pierre, Ph.D.](../Images/0e4aab43c2b981546d552beccf2259ab.png)](https://spierre91.medium.com/?source=post_page-----1a4215e433f8--------------------------------)[](https://towardsdatascience.com/?source=post_page-----1a4215e433f8--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----1a4215e433f8--------------------------------)
    [Sadrach Pierre, Ph.D.](https://spierre91.medium.com/?source=post_page-----1a4215e433f8--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----1a4215e433f8--------------------------------)
    ·8 min read·Jan 10, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/197b5de13a8d4ab8c00930b07a2ff313.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by [Tima Miroshnichenko](https://www.pexels.com/@tima-miroshnichenko/)
    on [Pexels](https://www.pexels.com/photo/vintage-alarm-clocks-displayed-on-a-wooden-shelf-8327953/)
  prefs: []
  type: TYPE_NORMAL
- en: Time series analysis is one of the most common data science tasks. It involves
    analyzing trends in data points that are ordered temporally. There are a wide
    variety of time series data including stock market data, weather data, consumer
    demand data, and much more. Time series analysis has applications across a wide
    range of industries which makes it an essential skill for data scientists and
    data analysts.
  prefs: []
  type: TYPE_NORMAL
- en: Time series analysis involves many techniques that can’t be summarized into
    a single article. Some of the most common approaches include visualizing time
    series data through line charts, building time series forecasting models, performing
    spectral analysis for uncovering cyclic trends, analyzing seasonality trends,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: Because time series analysis involves many different techniques it naturally
    lends itself to object-oriented programming. Python classes make it easy to organize
    attributes and methods for related time series tasks. For example, if as a data
    scientist, you often perform line chart visualizations, seasonality analysis,
    and time series forecasting, classes can allow you to easily organize methods
    and attributes for these tasks.
  prefs: []
  type: TYPE_NORMAL
- en: When done well object-oriented programming can improve the readability, reusability,
    maintainability, and repeatability of time series experiments. Since classes are
    a set of methods and attributes, it makes it clear which functions are used for
    a specific purpose. This makes modifying and maintaining existing functions easy.
    Further, once you have a reliable set of methods defined in your class you can
    easily rerun experiments with different parameters, refreshed training data, and
    more with little to no need to rewrite code.
  prefs: []
  type: TYPE_NORMAL
- en: Here we will walk through how to write a class that organizes the steps within
    a time series analysis workflow. Each part of the workflow will be defined by
    a class method that completes a single task. We will look at how to define class
    methods for time series visualization, statistical testing, splitting data for
    training and testing, training a forecasting model, and validating our time series
    model.
  prefs: []
  type: TYPE_NORMAL
- en: For this work, I will be writing code in [Deepnote](https://deepnote.com/),
    which is a collaborative data science notebook that makes running reproducible
    experiments very easy.
  prefs: []
  type: TYPE_NORMAL
- en: For our modeling, we will work with the fictitious [Weather Climate Time Series
    data set](https://www.kaggle.com/datasets/sumanthvrao/daily-climate-time-series-data),
    which is publicly available on Kaggle. The data set is free to use, modify and
    share under the [Creative Commons Universal Public Domain License (CC0 1.0)](https://creativecommons.org/publicdomain/zero/1.0/).
  prefs: []
  type: TYPE_NORMAL
- en: Read in data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start, let’s navigate to Deepnote and create a new project (you can sign-up
    for free if you don’t already have an account).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a project called ‘time_series’ and a notebook within this project
    called ‘time_series_oop’. Also, let’s drag and drop the DailyDelhiClimate.csv
    file on the left-hand panel on the page where it says ‘FILES’:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ff30092b2ac95908090c8d765fe773b0.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot taken by author
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by importing the Pandas library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will define a class that allows us to read our weather data. We will
    call our python class TimeSeriesAnalysis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can define an instance of our class and access our data frame through our
    TimeSeriesAnalysis object. Let’s display the first five rows of our data:'
  prefs: []
  type: TYPE_NORMAL
- en: Embedding created by author
  prefs: []
  type: TYPE_NORMAL
- en: 'We see that we have a date object and four float columns. We have mean temperature,
    humidity, wind speed, and mean pressure. Let’s add a method to our class that
    prepares our time series. The method will take a numerical column name and return
    a time series, where data is the index and the values correspond to the selected
    column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now define a new instance of our class and access our time series data:'
  prefs: []
  type: TYPE_NORMAL
- en: Embedding created by author
  prefs: []
  type: TYPE_NORMAL
- en: Generate summary statistics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next thing we can do is add a method that generates some basic summary
    statistics for our time series. For example, we can define a class method that
    returns the mean and standard deviation for a specified column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then define a new class instance, call the get_time_series method on
    our object instance with the mean temperature columns as input, and generate summary
    statistics:'
  prefs: []
  type: TYPE_NORMAL
- en: Embedding created by author
  prefs: []
  type: TYPE_NORMAL
- en: We can do the same for humidity, wind speed and mean pressure
  prefs: []
  type: TYPE_NORMAL
- en: Embedding created by author
  prefs: []
  type: TYPE_NORMAL
- en: Visualize time series
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next thing we can is define a method that allows us to generate some visualizations.
    For our visualizations we will need to import Seaborn, Matplotlib, and the statsmodels
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s define a new class instance for mean temperature and create a line plot,
    histogram and perform seasonal decomposition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s have our method give the option to generate a histogram of target values,
    a time series line plot and time series decomposition:'
  prefs: []
  type: TYPE_NORMAL
- en: Embedding created by author
  prefs: []
  type: TYPE_NORMAL
- en: Stationarity Tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '***Adjusters Dickey-Fuller***'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another method we can add is a test for stationarity using the Dickey-Fuller
    test. Stationarity is when the mean and variance of a time series don’t change
    over time. Moreover, if a time series is stationary it doesn’t have any trends.
    Upon inspecting our plot we can see that the weather data is non-stationary since
    there are clear seasonal trends. We will use the Dickey-Fuller test to check for
    stationarity. The Dickey-Fuller Test has the following hypothesis:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Null Hypothesis**: The time series is non-stationary.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Alternative Hypothesis**: The time series is stationary.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We interpret the results in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: If the test statistic < the critical values we reject the null hypothesis
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If the test statistic >the critical values we failed to reject the null hypothesis
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The results of the test will have critical values at significance levels of
    1%, 5%, and 10%. It will also have the test statistic. Let’s define a method that
    allows us to run this test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'At the top of our notebook, let’s import the adfuller method from the stats
    models packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then call the stationarity_test method on our climate object and access
    the test results:'
  prefs: []
  type: TYPE_NORMAL
- en: Embedding created by author
  prefs: []
  type: TYPE_NORMAL
- en: We see that in each case the critical values are less than the test statistic
    which is to be expected. This means that our data is non-stationary.
  prefs: []
  type: TYPE_NORMAL
- en: '***Kwiatkowski — Phillips — Schmidt — Shin (KPSS)***'
  prefs: []
  type: TYPE_NORMAL
- en: '**Null Hypothesis**: The time series is stationary.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Alternative Hypothesis**: The time series is not stationary.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the ADF test, we interpret the results in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: If the test statistic < the critical values we reject the null hypothesis
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If the test statistic >the critical values we failed to reject the null hypothesis
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Another stationarity test is the Kwiatkowski — Phillips — Schmidt — Shin test
    (KPSS). The null hypothesis for this test is that the time series is stationary.
    The difference between ADF and KPSS is that ADF tests for stationarity while KPSS
    tests for non-stationarity. If the ADF test results in failing to reject the null
    hypothesis, you should use KPSS to confirm that the time series is non-stationary.
    Let’s extend our stationarity test method such that it gives options for both
    ADF and KPSS. Lets import the KPSS method from sstats models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then extend the definition of our stationary test method to include
    KPSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can then call the stationarity_test method on our climate object and
    access the KPSS test results:'
  prefs: []
  type: TYPE_NORMAL
- en: Embedding created by author
  prefs: []
  type: TYPE_NORMAL
- en: We see that the test statistic is less than the critical values which means
    we reject the null hypothesis. The null hypothesis states that the time series
    is stationary. This means we have evidence to support the claim that the time
    series is non-stationary.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define a method that performs ADF and KPSS tests and prints the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And we get:'
  prefs: []
  type: TYPE_NORMAL
- en: Embedding created by author
  prefs: []
  type: TYPE_NORMAL
- en: It is best to use both tests to confirm if a time series is stationary. The
    results of both tests give strong evidence that the time series is non-stationary.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, the most common methods for time series forecasting, such as
    ARIMA & SARIMA can handle non-stationary data. Typically with ARIMA models, it
    is advised to perform differencing before fitting your model. Auto ARIMA, is a
    python package that allows you to automatically search for the best differencing
    parameter. This is convenient since it is not necessary to perform a manual test
    to find the best order of differencing.
  prefs: []
  type: TYPE_NORMAL
- en: Split for training & testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When preparing data for training forecasting models it is important to split
    the data for training and testing. This helps to prevent the model from overfitting
    the data and consequently poorly generalizing. We will define the training as
    all data before July 2016 and the testing as all data points after July 2016:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Auto ARIMA model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use Auto ARIMA, first lets install the pdarima package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s import autor arima from pdarima:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then define our fit method which we will use to fit our ARIMA model
    to our training data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also define a validate method that displays performance and visualizes
    model predictions. We will use mean absolute error to evaluate performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The full class looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Embedding created by author
  prefs: []
  type: TYPE_NORMAL
- en: 'Now if we define a new instance, fit and validate our model we get:'
  prefs: []
  type: TYPE_NORMAL
- en: Embedding created by author
  prefs: []
  type: TYPE_NORMAL
- en: The code in this post is available on [GitHub](https://github.com/spierre91/deepnote/blob/main/time_series_oop.ipynb).
  prefs: []
  type: TYPE_NORMAL
- en: CONCLUSIONS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this post, we discuss how to write a class that organizes the steps of the
    time series analysis workflow. First, we defined a method that allowed us to read
    and display the data. We then defined a method to calculate the mean and standard
    deviation for the time series. Next, we defined a method that allowed us to visualize
    line plots of the time series data, histograms of the time series values, and
    seasonal decomposition of the data. Next, we wrote a class method that allowed
    us to perform statistical tests for stationarity. We used the ADF test to test
    for stationarity and the KPSS test to test for non-stationarity. Finally, we fit
    an Auto ARIMA model to the training data, validated our model, and generated visualizations
    for our predictions. I hope you found this useful. I encourage you to try applying
    these methods to your time series analysis projects!
  prefs: []
  type: TYPE_NORMAL
