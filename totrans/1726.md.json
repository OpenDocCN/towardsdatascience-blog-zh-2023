["```py\nclass SimpleObject:\n  greet_name:str\n\n  def __init__(self, name:str):\n    self.greet_name = name\n\n  def say_hello(self) -> None:\n    print(f\"Hello {self.greet_name}!\")\n\nmy_instance = SimpleObject(name=\"bob\")\nmy_instance.say_hello()\n```", "```py\n# SimpleObject is of type 'object'\nmy_instance = SimpleObject(name=\"bob\")\nprint(isinstance(my_instance, object))    # <-- True\n# but all other types as well:\nprint(isinstance(42, object))             # <-- True\nprint(isinstance('hello world', object))  # <-- True\nprint(isinstance({\"my\": \"dict\"}, object)) # <-- True\n```", "```py\nclass SimpleObject:\n  greet_name:str\n\n  def __new__(cls, *args, **kwargs):      # <-- newly added function\n    print(\"__new__ method\")               \n    return super().__new__(cls)            \n\n  def __init__(self, name:str):\n    print(\"__init__ method\")\n    self.greet_name = name\n\n  def say_hello(self) -> None:\n    print(f\"Hello {self.greet_name}!\")\n\nmy_instance = SimpleObject(name=\"bob\")\nmy_instance.say_hello()\n```", "```py\n__new__ method\n__init__ method\nHello bob!\n```", "```py\nclass SimpleObject:\n  def __new__(cls, *args, **kwargs):\n    return super().__new__(cls)\n```", "```py\n# 1\\. __new__ and __init__ are called internally\nmy_instance = SimpleObject(name='bob')\n\n# 2\\. __new__ and __init__ are called directly:\nmy_instance = SimpleObject.__new__(SimpleObject)\nmy_instance.__init__(name='bob')\nmy_instance.say_hello()\n```", "```py\nclass Point(tuple):\n\n  x: float\n  y: float\n\n  def __init__(self, x:float, y:float):\n    self.x = x\n    self.y = y\n\np = Point(1,2)    # <-- tuple expects 1 argument, got 2\n```", "```py\nclass Point(tuple):\n\n  x: float\n  y: float\n\n  def __new__(cls, x:float, y:float):    # <-- newly added method\n    return super().__new__(cls, (x, y))\n\n  def __init__(self, x:float, y:float):\n    self.x = x\n    self.y = y\n```", "```py\nclass Point(tuple):\n    x: int\n    y: int\n\n    def __new__(cls, x:float, y:float):\n      if x < 0 or y < 0:                                  # <-- filter inputs\n          raise ValueError(\"x and y must be positive\")\n      return super().__new__(cls, (x, y))\n\n    def __init__(self, x:float, y:float):\n      self.x = x\n      self.y = y\n\n    def distance_from(self, other_point: Point):          # <-- new method\n      return math.sqrt(\n        (other_point.x - self.x) ** 2 + (other_point.y - self.y) ** 2\n      )\n\np = Point(1, 2)\np2 = Point(3, 1)\nprint(p.distance_from(other_point=p2))  # <-- 2.23606797749979\n```", "```py\nclass Currency(float):\n\n    def __new__(cls, value: float, symbol: str):\n        obj = super(Currency, cls).__new__(cls, value)\n        obj.symbol = symbol\n        return obj\n\n    def __str__(self) -> str:\n        return f\"{self.symbol} {self:.2f}\"  # <-- returns symbol & float formatted to 2 decimals\n\nprice = Currency(12.768544, symbol='€')\nprint(price)                            # <-- prints: \"€ 12.74\"\n```", "```py\nprint(isinstance(price, float))        # True\nprint(f\"{price.symbol} {price * 2}\")   # prints: \"€ 25.48\"\n```", "```py\nclass Singleton:\n  _instance = None\n\n  def __new__(cls):\n    if cls._instance is None:\n      cls._instance = super(Singleton, cls).__new__(cls)\n    return cls._instance\n\nsingleton1 = Singleton()\nsingleton2 = Singleton()\n\nprint(id(singleton1))\nprint(id(singleton2))\nprint(singleton1 is singleton2)  # True\n```"]