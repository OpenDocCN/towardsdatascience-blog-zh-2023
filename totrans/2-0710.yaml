- en: Demystifying Matplotlib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/demystifying-matplotlib-3895ab229a63](https://towardsdatascience.com/demystifying-matplotlib-3895ab229a63)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Quick Success Data Science
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There’s a reason you’re confused
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@lee_vaughan?source=post_page-----3895ab229a63--------------------------------)[![Lee
    Vaughan](../Images/9f6b90bb76102f438ab0b9a4a62ffa3f.png)](https://medium.com/@lee_vaughan?source=post_page-----3895ab229a63--------------------------------)[](https://towardsdatascience.com/?source=post_page-----3895ab229a63--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----3895ab229a63--------------------------------)
    [Lee Vaughan](https://medium.com/@lee_vaughan?source=post_page-----3895ab229a63--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----3895ab229a63--------------------------------)
    ·16 min read·Nov 2, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d556e988458efce5ec0801d4c6a1fca6.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Cederic Vandenberghe on Unsplash
  prefs: []
  type: TYPE_NORMAL
- en: '*Do you struggle with Matplotlib?* If you’re a beginner, it may be because
    you haven’t taken the time to learn a few of its idiosyncrasies. If you suspect
    that’s the case, then do yourself a favor and read on! This won’t hurt or take
    too much time.'
  prefs: []
  type: TYPE_NORMAL
- en: Matplotlib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The open-source Matplotlib library dominates plotting in Python. It lets you
    generate quick and simple plots as well as elaborate, complex charts where you
    control every aspect of the display. Its popularity and maturity mean that you
    can always find helpful advice and useful code examples.
  prefs: []
  type: TYPE_NORMAL
- en: Like any powerful piece of software, Matplotlib can be, as one author put it,
    “syntactically tedious.” The simplest plots are easy, but the difficulty ramps
    up quickly. And even though resources like the [Matplotlib gallery](https://matplotlib.org/stable/gallery/index.html)
    provide helpful code samples, if you want something slightly different than what’s
    provided, you might find yourself scratching your head.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, many people use Matplotlib by copying and pasting other people’s code
    and then hacking at the edges until they get something they like. As a user once
    told me, “No matter how many times I use Matplotlib, it always feels like the
    first time!”
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, you can greatly alleviate this pain by taking the time to learn
    some key aspects of the package. So, in this article, we’ll focus on the nomenclature
    and plotting interfaces that can cause confusion. Armed with this knowledge, you
    may find Matplotlib a tool to embrace instead of one to avoid or use reluctantly.
  prefs: []
  type: TYPE_NORMAL
- en: What’s the Problem?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Based on my experience learning Matplotlib, here are three issues that cause
    confusion:'
  prefs: []
  type: TYPE_NORMAL
- en: The somewhat awkward nomenclature used for plots.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The co-existence of *two* plotting interfaces which I’ll call the *pyplot approach*
    and the *object-oriented style*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Plot manipulation methods in the two interfaces that have *similar* but *different*
    names.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s take a look at these in turn.
  prefs: []
  type: TYPE_NORMAL
- en: The Anatomy of a Plot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step in understanding Matplotlib is mastering the plot nomenclature.
    To that end, let’s dissect a plot and its components.
  prefs: []
  type: TYPE_NORMAL
- en: Plots in Matplotlib are held within a `Figure` object. This is a blank canvas
    that represents the *top-level container* for all plot elements. Besides providing
    the canvas on which the plot is drawn, the `Figure` object also controls things
    like the size of the plot, its aspect ratio, the spacing between multiple plots
    drawn on the same canvas, and the ability to output the plot as an image. The
    left-most square in the following figure represents a `Figure` object.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5dae4177989cfdba352257f3c56a46c2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Anatomy of a plot (Source: Python Tools for Scientists [1])'
  prefs: []
  type: TYPE_NORMAL
- en: The plots themselves — that is, the things that you and I think of as *figures*
    — are represented by the `Axes` class, shown in the center of the previous diagram.
    This class includes most of the figure *elements*, such as lines, polygons, markers
    (points), text, titles, and so on, as well as the methods that act on them. It
    also sets the coordinate system. A `Figure` object can contain *multiple* `Axes`
    objects, but each `Axes` object can belong to only *one* `Figure`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Axes` object should not be confused with the `Axis` element that represents
    the numerical values on, say, the x- or y-axis of a chart (right-most display
    in the previous diagram). This includes the tick marks, labels, and limits. All
    these elements are contained within the `Axes` class.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the components in the previous diagram exists within the hierarchical
    structure shown below. The lowest layer includes elements such as each axis, the
    axis tick marks and labels, and the curve (`Line2D`). The highest level is the
    `Figure` object, which serves as a container for everything below it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1056a6c5f2d8deefde74916e7c83fd60.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The hierarchy of plot components in the previous figure (Source: Python Tools
    for Scientists [1])'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because a `Figure` object can hold *multiple* `Axes` objects, you could have
    more than one `Axes` object point to the `Figure` object in the previous diagram.
    A common example of this is *subplots*, in which one `Figure` canvas holds two
    or more different plots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/52ac3c669cd55402d9336d03f0d3e8ad.png)'
  prefs: []
  type: TYPE_IMG
- en: Example of two subplots in one Figure object (designated by the red box) (by
    the author)
  prefs: []
  type: TYPE_NORMAL
- en: The pyplot and Object-oriented Approaches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two primary interfaces for plotting with Matplotlib. Using the first,
    referred to as the *pyplot approach*, you rely on Matplotlib’s internal `pyplot`
    module to *automatically* create and manage `Figure` and `Axes` objects, which
    you then manipulate with `pyplot` methods for plotting. Designed mainly for dealing
    with single plots, the `pyplot` approach reduces the amount of code that you need
    to know and write. It’s a MATLAB-like API that can be very convenient for quick,
    interactive work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/b022f8f2e3ff11016a3d8e9ee4e43ace.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of the pyplot approach (by author)
  prefs: []
  type: TYPE_NORMAL
- en: This whole plot required one line of code. The `pyplot` module made every decision
    for you, including the use of a line, the color and weight of the line, the range
    of values on each axis, and the text font and color. It also provided corresponding
    x values for each y value, with the assumption that the count starts at 0 and
    increases with a step of 1 unit.
  prefs: []
  type: TYPE_NORMAL
- en: Using the second approach, called the *object-oriented style*, you *explicitly*
    create `Figure` and `Axes` objects and then call methods on the resulting objects.
    This gives you the most control over customizing your plots and keeping track
    of multiple plots in a large program. It’s also easier to understand interactions
    with other libraries if you first create an `Axes` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/b022f8f2e3ff11016a3d8e9ee4e43ace.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of the object-oriented style (by author)
  prefs: []
  type: TYPE_NORMAL
- en: The results are identical to those obtained with the `pyplot` approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as you see the following line, you know you’re dealing with the object-oriented
    style:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fig, ax = plt.subplots()`'
  prefs: []
  type: TYPE_NORMAL
- en: The `plt.subplots()` method creates a `Figure` instance and a set of subplots
    (a NumPy array of `Axes` objects). If the number of subplots is not specified,
    a *single* subplot is returned by default.
  prefs: []
  type: TYPE_NORMAL
- en: Because *two* objects are returned, you need to *unpack* the results to *two*
    variables, called `fig` and `ax` by convention. Remember that, with the `pyplot`
    approach, these two entities are created behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: In the sections that follow, we’ll look at both approaches. However, according
    to the [Matplotlib documentation](https://matplotlib.org/stable/index.html), to
    maintain consistency you should *choose one approach and stick to it*. They suggest
    using the object-oriented style, particularly for complicated plots as well as
    for methods and scripts that are intended to be reused as part of a larger project.
  prefs: []
  type: TYPE_NORMAL
- en: It can certainly be argued that one of the reasons beginners find Matplotlib
    intimidating is that they see a *mixture* of these approaches in existing code,
    such as on question-and-answer sites like *Stack Overflow*. Because this is unavoidable,
    I suggest that you read over the descriptions for *both* approaches so that you
    can make an informed decision on which one to choose for yourself. This way, you’ll
    have an awareness of the alternate approach when you encounter it in legacy code
    or in tutorials.
  prefs: []
  type: TYPE_NORMAL
- en: Using the pyplot Approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we made a plot with `pyplot` using one line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`plt.plot(data)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Two things are worth noting here: we didn’t *explicitly* refer to `Figure`
    or `Axes` objects in the code, as `pyplot` took care of these behind the scenes.
    Nor did we specify what *elements* to show in the plot, including the ticks and
    values displayed along the x- and y-axes. Instead, Matplotlib looked at your data
    and made intelligent choices about the type of plot you wanted and how to annotate
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: Along these lines, the `plot()` method makes line charts, `scatter()` makes
    scatterplots, `bar()` makes bar charts, `hist()` makes histograms, `pie()` makes
    pie charts, and so on. You can find examples of all these in the Matplotlib [plot
    types index](https://matplotlib.org/stable/plot_types/index).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The automatic nature of pyplot’s plot creation methods is useful when you want
    to quickly explore a dataset, but the resulting plots are generally too plain
    for presentations or reports. One issue is that the default configuration of methods
    like `plt.plot()` assumes that you want the *size* of each axis to match the *range*
    of the input data (such as x from 5 to 8, rather than 0 to 10 if the data is limited
    to values between 5 and 8).
  prefs: []
  type: TYPE_NORMAL
- en: It also assumes that you don’t want a legend, title, or axis label and that
    you want lines and markers drawn in blue. This isn’t always the case, so `pyplot`
    provides many methods to embellish charts with titles, axis labels, background
    grids, and so on. We’ll look at these next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and Manipulating Plots with pyplot Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Despite being considered a simpler approach than the object-oriented style,
    `pyplot` can still produce some very elaborate plots. To demonstrate, let’s use
    some `pyplot` methods to create a more sophisticated plot than before.
  prefs: []
  type: TYPE_NORMAL
- en: A *catenary* is the shape that a chain assumes when it’s hung from both of its
    ends. It’s a common shape in nature and architecture, examples being a square
    sail under wind pressure and the famous Gateway Arch in St. Louis, Missouri. You
    can generate a catenary with the following code, where `cosh(x)` represents the
    hyperbolic cosine of the x values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/d2c67f1e0146a571bc089c0fad9c1521.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of the pyplot catenary program (by the author)
  prefs: []
  type: TYPE_NORMAL
- en: Despite being somewhat verbose, the code is quite logical and readable. All
    the plotting steps call methods on `plt`.
  prefs: []
  type: TYPE_NORMAL
- en: In Matplotlib, the elements rendered on a `Figure` canvas, such as a title,
    legend, or line, are called `Artist` *objects*. Standard graphical objects, like
    rectangles, circles, and text, are referred to as *primitive* `Artists`. The objects
    that hold the primitives, like the `Figure`, `Axes`, and `Axis` objects, are called
    *container* `Artists`.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the more common `pyplot` methods for making plots and working with `Artists`
    are listed in the tables that follow. To see a full list, visit the Matplotlib
    `pyplot` [summary page](https://matplotlib.org/stable/api/pyplot_summary.html)[.](https://matplotlib.org/stable/api/pyplot_summary.html.)
    Clicking the method names in this online list will take you to detailed information
    on the method parameters, along with example applications. To read more about
    `Artists` in general, visit the Matplotlib [artist’s page](https://matplotlib.org/stable/tutorials/intermediate/artists.html).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c15ed472ed49f7a82923e30a3e70fd93.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Some useful pyplot methods for creating plots (Source: Python Tools for Scientists
    [1])'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/70f1be4931e91f12b0ba2ca9a5c8a18f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Some useful pyplot methods for manipulating plots (Source: Python Tools for
    Scientists [1])'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the code examples in the tables represent *simple* cases. Most methods
    take many arguments, letting you fine-tune your plots with respect to properties
    like font style and size, line widths and colors, rotation angles, exploded views,
    and much more.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Subplots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we’ve been working with single figures, but there’ll be times when
    you’ll want to compare two plots side by side or bundle several charts into a
    summary display. For these occasions, Matplotlib provides the `subplot()` method.
    To see how this works, let’s begin by generating data for two different sine waves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'One way to compare these waveforms is to plot them in the same `Axes` object,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/b97e337ca338ab4fd1d18c21489bd5f3.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of the pyplot sine program (by the author)
  prefs: []
  type: TYPE_NORMAL
- en: By default, the two curves would be plotted with different colors (blue and
    orange). We overrode this with black (using the shorthand ‘k’) and “firebrick”
    red. We also forced a different line style using the `ls` parameter. Otherwise,
    both lines would have been solid. (For a list of characters available for marker
    and line styles, visit [this site](https://matplotlib.org/stable/api/_as_gen/
    matplotlib.pyplot.plot.html)).
  prefs: []
  type: TYPE_NORMAL
- en: If you’re comparing more than a few curves, a single plot can become cluttered
    and difficult to read. In those cases, you’ll want to use separate stacked plots
    created by the `subplot()` method. The following diagram describes the syntax
    for this method, in which four subplots (`Axes`) are placed in a single `Figure`
    container.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/fe0f66b24af1ff5fedb0533b152677cd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Understanding the `subplot()` method (Source: Python Tools for Scientists [1])'
  prefs: []
  type: TYPE_NORMAL
- en: The subplots will be arranged in a grid, and the first two arguments passed
    to the `subplot()` method specify the dimensions of this grid. The first argument
    represents the number of rows in the grid, the second is the number of columns,
    and the third argument is the index of the active subplot (highlighted in gray
    in the diagram).
  prefs: []
  type: TYPE_NORMAL
- en: The active subplot is the one you are currently plotting in when you call a
    method like `plot()` or `scatter()`. Unlike most things in Python, the first index
    is 1, not 0.
  prefs: []
  type: TYPE_NORMAL
- en: Matplotlib uses a concept called the “current figure” to keep track of which
    `Axes` is currently being worked on. For example, when you call `plt.plot()`,
    `pyplot` creates a new “current figure” `Axes` to plot on. When working with multiple
    subplots, the index argument tells `pyplot` which subplot represents the “current
    figure.”
  prefs: []
  type: TYPE_NORMAL
- en: For convenience, you don’t need to use commas with the `subplot()` arguments.
    For example, `plt.subplot(223)` works the same as `plt.subplot(2, 2, 3)`, although
    it’s arguably less readable.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Now, let’s plot our sine waves as two separate stacked plots. The process will
    be to call the `subplot()` method and alter its active subplot argument to change
    the current subplot. For each current subplot, the `plot()` method will post the
    data specific to that subplot, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/597adaeb9a40a61c77175c7d003f2c8d.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of pyplot sine subplot program (by the author)
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you don’t set the y limits on the second plot, `pyplot` will automatically
    scale the graph so that the two subplots look identical. Because we manually set
    the scale on the second subplot with the `ylim()` method, it’s clear that the
    second sine wave has half the amplitude of the first.
  prefs: []
  type: TYPE_NORMAL
- en: That’s a speedy look at some of the syntax for the `pyplot` approach. Now let’s
    look at the object-oriented style.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Object-Oriented Style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The object-oriented plotting style generally requires a bit more code than the
    previously described pyplot approach, but it lets you get the absolute most out
    of Matplotlib. By explicitly creating `Figure` and `Axes` objects, you’ll more
    easily control your plots, better understand interactions with other libraries,
    create plots with multiple x- and y-axes, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and Manipulating Plots with the Object-oriented Style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To become familiar with the object-oriented style, let’s re-create the catenary
    plot from earlier in the article. To demonstrate some of the style’s enhanced
    functionality, we’ll force the y-axis to pass through the center of the plot.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The previous code will create a single empty figure. To custom configure the
    plot, next call the `Axes` object’s `set()` method and pass it keyword arguments
    for a title, axis labels, and axis limits. The `set()` method is a convenience
    method that lets you set *multiple* properties at once rather than calling specific
    methods for each.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Next, we’ll move the y-axis to the center of the chart instead of along the
    side. In Matplotlib, *spines* are the lines connecting the axis tick marks and
    marking the boundaries of the area containing the plotted data.
  prefs: []
  type: TYPE_NORMAL
- en: The default position for spines is *around* a plot with the ticks and labels
    along the left and bottom margins. But spines can also be placed at arbitrary
    positions. With the object-oriented style, we can accomplish this using the `set_position()`
    method of the `Spine` subclass.
  prefs: []
  type: TYPE_NORMAL
- en: The following code first moves the left (y) axis to the `0` value on the x-axis.
    Then, the line width is set to `2` so that the axis stands out a bit from the
    background grid that we’re going to use later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line turns off the right boundary of the plot by setting its
    color to none:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The next three lines repeat this overall process for the bottom axis and top
    axis, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To finish the plot, we add a background grid and call the `plot()` method,
    passing it the x and y data and setting the line width to `3` and the color to
    `firebrick`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/840fd3319e5e127eeb786a8cef5435db.png)'
  prefs: []
  type: TYPE_IMG
- en: The line plot of a catenary built using the object-oriented style (by the author)
  prefs: []
  type: TYPE_NORMAL
- en: If you omit the code related to the spines, you can reproduce the `pyplot` version
    of this figure with essentially the same amount of code. Thus, the verbosity of
    the object-oriented style has much to do with the fact that you can do more with
    it, and people generally take advantage of this.
  prefs: []
  type: TYPE_NORMAL
- en: Methods available in the `pyplot` approach have an equivalent in the object-oriented
    style. Unfortunately, the method names are often different. For example, `title()`
    in `pyplot` becomes `set_title()`, and `xticks()` becomes `set_xticks()`. This
    is one reason why it’s good to pick one approach and stick with it.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the more common methods for making object-oriented plots are listed
    in the table that follows. You can find additional methods, such as for making
    box plots, violin plots, and more, in the [index of plot types](https://matplotlib.org/stable/plot_types/index.html)
    and in the [Matplotlib gallery](https://matplotlib.org/stable/gallery/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/26e2718d976ccab1c725594c0ca8fa5b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Some useful object-oriented methods for creating plots (Source: Python Tools
    for Scientists [1])'
  prefs: []
  type: TYPE_NORMAL
- en: Common methods for working with `Figure` and `Axes` objects are listed in the
    following tables. In many cases, these work like the `pyplot` methods, though
    the method names might be different.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7f0e52e6442fa0ad16ec5362dc829aac.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Some useful object-oriented methods for manipulating plots (Source: Python
    Tools for Scientists [1])'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/66374df39a80062f0fd1945c82c58d74.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Some useful methods for working with Axes objects (Source: Python Tools for
    Scientists [1])'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the `pyplot` section, the code examples in all these tables
    represent *simple* cases. Most methods take many arguments, letting you fine-tune
    your plots with respect to properties like font style and size, line widths and
    colors, rotation angles, exploded views, and so on. To learn more, visit the Matplotlib
    [docs](https://matplotlib.org/)[.](https://matplotlib.org/.)
  prefs: []
  type: TYPE_NORMAL
- en: Working with Subplots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like the pyplot approach, the object-oriented style supports the use of subplots.
    Although there are multiple ways to assign subplots to `Figure` and `Axes` objects,
    the `plt.subplots()` method is convenient and returns a NumPy array that lets
    you select subplots using standard indexing or with unique names such as `axs[0,
    0]` or `ax1`. Another benefit is that you can preview the subplots’ geometry prior
    to plotting any data.
  prefs: []
  type: TYPE_NORMAL
- en: The object-oriented method for creating subplots is spelled *subplots*, whereas
    the pyplot approach uses *subplot*. You can remember this by associating the simplest
    technique, pyplot, with the shortest name.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Calling `plt.subplots()` with no arguments generates a single empty plot. Technically,
    this produces a `1×1 AxesSubplot` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/bb7970a9306f72d943cd6fc463c0ffbf.png)'
  prefs: []
  type: TYPE_IMG
- en: An empty subplot (by the author)
  prefs: []
  type: TYPE_NORMAL
- en: Producing multiple subplots works like the `plt.subplot()` method, only without
    an index argument for the active subplot. The first argument indicates the number
    of rows; the second specifies the number of columns. By convention, multiple `Axes`
    are given the *plural* name, `axs`, rather than `axes` so as to avoid confusion
    with a single instance of `Axes`.
  prefs: []
  type: TYPE_NORMAL
- en: Passing the `plt.subplots()` method two arguments lets you control the number
    of subplots and their geometry. The following code generates the 2×2 grid of subplots
    shown below and stores a list of two `AxesSubplot` objects in the `axs` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/9808fd51aafa446cc8c3f2391ca38bcb.png)'
  prefs: []
  type: TYPE_IMG
- en: A 2x2 grid of subplots (by the author)
  prefs: []
  type: TYPE_NORMAL
- en: 'To activate a subplot, you can use its index. In this example, we plot on the
    second subplot in the first row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/1940e92300950f087d59de97764be13a.png)'
  prefs: []
  type: TYPE_IMG
- en: A 2x2 grid of subplots with the second subplot active (by the author)
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can name and store the subplots individually by using tuple
    unpacking for multiple `Axes`. Each row of subplots will need to be in its own
    tuple. You can then select a subplot using a name, versus a less-readable index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/2d6bf2996a09d61330ad65aa9cd98232.png)'
  prefs: []
  type: TYPE_IMG
- en: A 2x2 grid of subplots with the third subplot active (by the author)
  prefs: []
  type: TYPE_NORMAL
- en: 'In both the `pyplot` approach and object-oriented style, you can add whitespace
    around the subplots by calling the `tight_layout()` method on the `Figure` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/7288071bb53b562ca91552d92388ecad.png)'
  prefs: []
  type: TYPE_IMG
- en: The effect of the tight_layout() method on subplot spacing (by the author)
  prefs: []
  type: TYPE_NORMAL
- en: Now the subplots don’t look so cramped. For the `pyplot` approach you would
    use `plt.tight_layout()`.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative Ways to Make Subplots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No matter which technique you use, there are higher-level alternatives to help
    you split a figure into a grid of subareas. This, in turn, helps you create subplots
    that have different widths and heights. The resulting multipaneled displays are
    useful for summarizing information in presentations and reports.
  prefs: []
  type: TYPE_NORMAL
- en: 'Among these paneling tools are Matplotlib’s `[GridSpec](https://matplotlib.org/stable/api/_as_gen/matplotlib.gridspec.GridSpec.html)`
    module and its `subplot_mosaic()` method. Here’s an example built with `GridSpec`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/36c464e0f04344764af7323270e81045.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A multipanel display built with GridSpec (Source: Python Tools for Scientists
    [1])'
  prefs: []
  type: TYPE_NORMAL
- en: To read more about these tools, visit [*Working with Multiple Figures and Axes*](https://matplotlib.org/stable/users/explain/quick_start.html)
    and [*Arranging Multiple Axes in a Figure*](https://matplotlib.org/stable/users/explain/axes/arranging_axes.html)
    in the Matplotlib docs, and my `GridSpec` tutorial [article](https://betterprogramming.pub/build-an-interactive-lithium-factbook-with-gridspec-and-geopandas-e699054237a8)
    in *Better Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you program in Python, you need to know Matplotlib. To know Matplotlib, you
    need to understand its primary plotting nomenclature and its two plotting interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: The `Figure` object represents the *canvas* on which you plot. It controls things
    like the size of the plot, its aspect ratio, the padding between subplots, supertitles,
    and the ability to save the plot.
  prefs: []
  type: TYPE_NORMAL
- en: '`Figure` objects can hold multiple `Axes` objects that form what we generally
    think of as figures or diagrams. These include lines, points, text, titles, the
    plot’s coordinate system, and so on. Multiple `Axes` objects in the same `Figure`
    object constitute *subplots*.'
  prefs: []
  type: TYPE_NORMAL
- en: Within an `Axes` object, the `Axis` element represents numerical values on the
    x, y, or z axis, including tick marks, labels, and limits.
  prefs: []
  type: TYPE_NORMAL
- en: Matplotlib comes with two main approaches to making plots. The `pyplot` approach
    is designed for quick and easy plotting, such as for exploratory data analysis.
    With this approach, `Figure` and `Axes` objects are created behind the scenes
    and most decisions, such as for axis scaling, colors, line styles, etc., are made
    for you (though you can override these to a point).
  prefs: []
  type: TYPE_NORMAL
- en: For more involved plots, such as for reports and presentations, the *object-oriented
    style* explicitly creates `Figure` and `Axes` objects (by convention labeled as
    `fig`, `ax`). This provides you with more control and makes it easier to understand
    interactions with other Python libraries.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re not aware of these two paradigms for plotting, it’s easy to get confused
    when using code snippets you find online, such as on *Stack Overflow*. Because
    the methods used with each approach are similar but different, the Matplotlib
    developers recommend that you pick one approach and use it consistently.
  prefs: []
  type: TYPE_NORMAL
- en: Citations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '“Python Tools for Scientists: An Introduction to Using Anaconda, JupyterLab,
    and Python’s Scientific Libraries” ([*No Starch Press*](https://nostarch.com/real-world-python),
    2023) by Lee Vaughan.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thanks!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thanks for reading and follow me for more *Quick Success Data Science* articles
    in the future. And if you want to learn more about Matplotlib and Python’s other
    plotting libraries, check out my book, [*Python Tools for Scientists*](https://a.co/d/67VvS3G),
    available online and in fine bookstores like Barnes and Noble.
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://a.co/d/67VvS3G?source=post_page-----3895ab229a63--------------------------------)
    [## Python Tools for Scientists: An Introduction to Using Anaconda, JupyterLab,
    and Python''s Scientific…'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python Tools for Scientists: An Introduction to Using Anaconda, JupyterLab,
    and Python''s Scientific Libraries…'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: a.co](https://a.co/d/67VvS3G?source=post_page-----3895ab229a63--------------------------------)
  prefs: []
  type: TYPE_NORMAL
