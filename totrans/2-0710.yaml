- en: Demystifying Matplotlib
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 破解Matplotlib的神秘面纱
- en: 原文：[https://towardsdatascience.com/demystifying-matplotlib-3895ab229a63](https://towardsdatascience.com/demystifying-matplotlib-3895ab229a63)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/demystifying-matplotlib-3895ab229a63](https://towardsdatascience.com/demystifying-matplotlib-3895ab229a63)
- en: Quick Success Data Science
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速成功数据科学
- en: There’s a reason you’re confused
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你困惑是有原因的
- en: '[](https://medium.com/@lee_vaughan?source=post_page-----3895ab229a63--------------------------------)[![Lee
    Vaughan](../Images/9f6b90bb76102f438ab0b9a4a62ffa3f.png)](https://medium.com/@lee_vaughan?source=post_page-----3895ab229a63--------------------------------)[](https://towardsdatascience.com/?source=post_page-----3895ab229a63--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----3895ab229a63--------------------------------)
    [Lee Vaughan](https://medium.com/@lee_vaughan?source=post_page-----3895ab229a63--------------------------------)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@lee_vaughan?source=post_page-----3895ab229a63--------------------------------)[![李·沃恩](../Images/9f6b90bb76102f438ab0b9a4a62ffa3f.png)](https://medium.com/@lee_vaughan?source=post_page-----3895ab229a63--------------------------------)[](https://towardsdatascience.com/?source=post_page-----3895ab229a63--------------------------------)[![数据科学导向](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----3895ab229a63--------------------------------)
    [李·沃恩](https://medium.com/@lee_vaughan?source=post_page-----3895ab229a63--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----3895ab229a63--------------------------------)
    ·16 min read·Nov 2, 2023
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: ·发布于 [数据科学导向](https://towardsdatascience.com/?source=post_page-----3895ab229a63--------------------------------)
    ·16分钟阅读·2023年11月2日
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/d556e988458efce5ec0801d4c6a1fca6.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d556e988458efce5ec0801d4c6a1fca6.png)'
- en: Image by Cederic Vandenberghe on Unsplash
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由Cederic Vandenberghe在Unsplash上提供
- en: '*Do you struggle with Matplotlib?* If you’re a beginner, it may be because
    you haven’t taken the time to learn a few of its idiosyncrasies. If you suspect
    that’s the case, then do yourself a favor and read on! This won’t hurt or take
    too much time.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*你在使用Matplotlib时是否感到困难？* 如果你是初学者，可能是因为你没有花时间去了解它的一些特性。如果你怀疑是这样，那么请给自己一个机会，继续阅读！这不会造成伤害，也不会花费太多时间。'
- en: Matplotlib
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Matplotlib
- en: The open-source Matplotlib library dominates plotting in Python. It lets you
    generate quick and simple plots as well as elaborate, complex charts where you
    control every aspect of the display. Its popularity and maturity mean that you
    can always find helpful advice and useful code examples.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 开源的Matplotlib库在Python中主导绘图。它允许你生成快速简单的图形以及复杂的图表，你可以控制显示的每一个方面。它的流行和成熟意味着你总能找到有用的建议和有用的代码示例。
- en: Like any powerful piece of software, Matplotlib can be, as one author put it,
    “syntactically tedious.” The simplest plots are easy, but the difficulty ramps
    up quickly. And even though resources like the [Matplotlib gallery](https://matplotlib.org/stable/gallery/index.html)
    provide helpful code samples, if you want something slightly different than what’s
    provided, you might find yourself scratching your head.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 像任何强大的软件一样，Matplotlib也可以是“一些语法上的繁琐”。最简单的图形很容易，但难度很快上升。即使像[Matplotlib画廊](https://matplotlib.org/stable/gallery/index.html)这样的资源提供了有用的代码示例，如果你想要稍微不同的内容，你可能会发现自己在挠头。
- en: In fact, many people use Matplotlib by copying and pasting other people’s code
    and then hacking at the edges until they get something they like. As a user once
    told me, “No matter how many times I use Matplotlib, it always feels like the
    first time!”
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，许多人通过复制粘贴别人的代码，然后在边缘进行调整，直到得到他们喜欢的结果来使用Matplotlib。正如一位用户曾告诉我，“无论我使用Matplotlib多少次，它总是感觉像是第一次！”
- en: Fortunately, you can greatly alleviate this pain by taking the time to learn
    some key aspects of the package. So, in this article, we’ll focus on the nomenclature
    and plotting interfaces that can cause confusion. Armed with this knowledge, you
    may find Matplotlib a tool to embrace instead of one to avoid or use reluctantly.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你可以通过花时间学习这个包的一些关键方面来大大减轻这种痛苦。因此，在这篇文章中，我们将重点关注可能导致困惑的术语和绘图接口。掌握这些知识后，你可能会发现Matplotlib是一个值得拥抱的工具，而不是一个需要回避或勉强使用的工具。
- en: What’s the Problem?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题是什么？
- en: 'Based on my experience learning Matplotlib, here are three issues that cause
    confusion:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我学习Matplotlib的经验，这里有三个导致困惑的问题：
- en: The somewhat awkward nomenclature used for plots.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘图时使用的有些尴尬的术语。
- en: The co-existence of *two* plotting interfaces which I’ll call the *pyplot approach*
    and the *object-oriented style*.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我将称之为*pyplot方法*和*面向对象风格*的*两个*绘图接口的共存。
- en: Plot manipulation methods in the two interfaces that have *similar* but *different*
    names.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s take a look at these in turn.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: The Anatomy of a Plot
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step in understanding Matplotlib is mastering the plot nomenclature.
    To that end, let’s dissect a plot and its components.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Plots in Matplotlib are held within a `Figure` object. This is a blank canvas
    that represents the *top-level container* for all plot elements. Besides providing
    the canvas on which the plot is drawn, the `Figure` object also controls things
    like the size of the plot, its aspect ratio, the spacing between multiple plots
    drawn on the same canvas, and the ability to output the plot as an image. The
    left-most square in the following figure represents a `Figure` object.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5dae4177989cfdba352257f3c56a46c2.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: 'Anatomy of a plot (Source: Python Tools for Scientists [1])'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: The plots themselves — that is, the things that you and I think of as *figures*
    — are represented by the `Axes` class, shown in the center of the previous diagram.
    This class includes most of the figure *elements*, such as lines, polygons, markers
    (points), text, titles, and so on, as well as the methods that act on them. It
    also sets the coordinate system. A `Figure` object can contain *multiple* `Axes`
    objects, but each `Axes` object can belong to only *one* `Figure`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: The `Axes` object should not be confused with the `Axis` element that represents
    the numerical values on, say, the x- or y-axis of a chart (right-most display
    in the previous diagram). This includes the tick marks, labels, and limits. All
    these elements are contained within the `Axes` class.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Each of the components in the previous diagram exists within the hierarchical
    structure shown below. The lowest layer includes elements such as each axis, the
    axis tick marks and labels, and the curve (`Line2D`). The highest level is the
    `Figure` object, which serves as a container for everything below it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1056a6c5f2d8deefde74916e7c83fd60.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: 'The hierarchy of plot components in the previous figure (Source: Python Tools
    for Scientists [1])'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Because a `Figure` object can hold *multiple* `Axes` objects, you could have
    more than one `Axes` object point to the `Figure` object in the previous diagram.
    A common example of this is *subplots*, in which one `Figure` canvas holds two
    or more different plots:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/52ac3c669cd55402d9336d03f0d3e8ad.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: Example of two subplots in one Figure object (designated by the red box) (by
    the author)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: The pyplot and Object-oriented Approaches
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two primary interfaces for plotting with Matplotlib. Using the first,
    referred to as the *pyplot approach*, you rely on Matplotlib’s internal `pyplot`
    module to *automatically* create and manage `Figure` and `Axes` objects, which
    you then manipulate with `pyplot` methods for plotting. Designed mainly for dealing
    with single plots, the `pyplot` approach reduces the amount of code that you need
    to know and write. It’s a MATLAB-like API that can be very convenient for quick,
    interactive work.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![](../Images/b022f8f2e3ff11016a3d8e9ee4e43ace.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: Output of the pyplot approach (by author)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: This whole plot required one line of code. The `pyplot` module made every decision
    for you, including the use of a line, the color and weight of the line, the range
    of values on each axis, and the text font and color. It also provided corresponding
    x values for each y value, with the assumption that the count starts at 0 and
    increases with a step of 1 unit.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Using the second approach, called the *object-oriented style*, you *explicitly*
    create `Figure` and `Axes` objects and then call methods on the resulting objects.
    This gives you the most control over customizing your plots and keeping track
    of multiple plots in a large program. It’s also easier to understand interactions
    with other libraries if you first create an `Axes` object.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![](../Images/b022f8f2e3ff11016a3d8e9ee4e43ace.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
- en: Output of the object-oriented style (by author)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: The results are identical to those obtained with the `pyplot` approach.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as you see the following line, you know you’re dealing with the object-oriented
    style:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '`fig, ax = plt.subplots()`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: The `plt.subplots()` method creates a `Figure` instance and a set of subplots
    (a NumPy array of `Axes` objects). If the number of subplots is not specified,
    a *single* subplot is returned by default.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Because *two* objects are returned, you need to *unpack* the results to *two*
    variables, called `fig` and `ax` by convention. Remember that, with the `pyplot`
    approach, these two entities are created behind the scenes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: In the sections that follow, we’ll look at both approaches. However, according
    to the [Matplotlib documentation](https://matplotlib.org/stable/index.html), to
    maintain consistency you should *choose one approach and stick to it*. They suggest
    using the object-oriented style, particularly for complicated plots as well as
    for methods and scripts that are intended to be reused as part of a larger project.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: It can certainly be argued that one of the reasons beginners find Matplotlib
    intimidating is that they see a *mixture* of these approaches in existing code,
    such as on question-and-answer sites like *Stack Overflow*. Because this is unavoidable,
    I suggest that you read over the descriptions for *both* approaches so that you
    can make an informed decision on which one to choose for yourself. This way, you’ll
    have an awareness of the alternate approach when you encounter it in legacy code
    or in tutorials.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Using the pyplot Approach
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用pyplot方法
- en: 'In the previous section, we made a plot with `pyplot` using one line of code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用一行代码用`pyplot`创建了一个图表：
- en: '`plt.plot(data)`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`plt.plot(data)`'
- en: 'Two things are worth noting here: we didn’t *explicitly* refer to `Figure`
    or `Axes` objects in the code, as `pyplot` took care of these behind the scenes.
    Nor did we specify what *elements* to show in the plot, including the ticks and
    values displayed along the x- and y-axes. Instead, Matplotlib looked at your data
    and made intelligent choices about the type of plot you wanted and how to annotate
    it.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两点需要注意：我们没有*明确*在代码中引用`Figure`或`Axes`对象，因为`pyplot`在幕后处理了这些问题。我们也没有指定要在图中显示哪些*元素*，包括显示在x轴和y轴上的刻度和数值。相反，Matplotlib查看了你的数据，并对你想要的图类型及其注释做出了智能选择。
- en: Along these lines, the `plot()` method makes line charts, `scatter()` makes
    scatterplots, `bar()` makes bar charts, `hist()` makes histograms, `pie()` makes
    pie charts, and so on. You can find examples of all these in the Matplotlib [plot
    types index](https://matplotlib.org/stable/plot_types/index).
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这方面，`plot()`方法绘制折线图，`scatter()`绘制散点图，`bar()`绘制条形图，`hist()`绘制直方图，`pie()`绘制饼图等等。你可以在Matplotlib的[图表类型索引](https://matplotlib.org/stable/plot_types/index)中找到所有这些示例。
- en: The automatic nature of pyplot’s plot creation methods is useful when you want
    to quickly explore a dataset, but the resulting plots are generally too plain
    for presentations or reports. One issue is that the default configuration of methods
    like `plt.plot()` assumes that you want the *size* of each axis to match the *range*
    of the input data (such as x from 5 to 8, rather than 0 to 10 if the data is limited
    to values between 5 and 8).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`pyplot`的图表创建方法的自动特性在你想快速探索数据集时很有用，但生成的图表通常过于简单，不适合演示或报告。一大问题是，像`plt.plot()`这样的默认配置假设你希望每个轴的*大小*与输入数据的*范围*匹配（例如，如果数据限制在5到8之间，则x轴范围为5到8，而不是0到10）。'
- en: It also assumes that you don’t want a legend, title, or axis label and that
    you want lines and markers drawn in blue. This isn’t always the case, so `pyplot`
    provides many methods to embellish charts with titles, axis labels, background
    grids, and so on. We’ll look at these next.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 它还假设你不需要图例、标题或轴标签，并且希望线条和标记绘制成蓝色。这并非总是如此，因此`pyplot`提供了许多方法来装饰图表，包括标题、轴标签、背景网格等等。我们接下来会看看这些。
- en: Creating and Manipulating Plots with pyplot Methods
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用pyplot方法创建和操作图表
- en: Despite being considered a simpler approach than the object-oriented style,
    `pyplot` can still produce some very elaborate plots. To demonstrate, let’s use
    some `pyplot` methods to create a more sophisticated plot than before.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管被认为是一种比面向对象风格更简单的方法，`pyplot`仍然可以生成一些非常复杂的图表。为了演示，让我们使用一些`pyplot`方法创建比以前更复杂的图表。
- en: A *catenary* is the shape that a chain assumes when it’s hung from both of its
    ends. It’s a common shape in nature and architecture, examples being a square
    sail under wind pressure and the famous Gateway Arch in St. Louis, Missouri. You
    can generate a catenary with the following code, where `cosh(x)` represents the
    hyperbolic cosine of the x values.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*悬链线*是链条悬挂在两端时所呈现的形状。这在自然界和建筑中是常见的形状，例如在风压下的方形帆和位于密苏里州圣路易斯的著名拱门。你可以使用以下代码生成悬链线，其中`cosh(x)`表示x值的双曲余弦。'
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![](../Images/d2c67f1e0146a571bc089c0fad9c1521.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d2c67f1e0146a571bc089c0fad9c1521.png)'
- en: Output of the pyplot catenary program (by the author)
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: pyplot悬链线程序的输出（作者提供）
- en: Despite being somewhat verbose, the code is quite logical and readable. All
    the plotting steps call methods on `plt`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有些冗长，但代码逻辑清晰且可读。所有绘图步骤都调用了`plt`上的方法。
- en: In Matplotlib, the elements rendered on a `Figure` canvas, such as a title,
    legend, or line, are called `Artist` *objects*. Standard graphical objects, like
    rectangles, circles, and text, are referred to as *primitive* `Artists`. The objects
    that hold the primitives, like the `Figure`, `Axes`, and `Axis` objects, are called
    *container* `Artists`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在Matplotlib中，渲染在`Figure`画布上的元素，如标题、图例或线条，被称为`Artist` *对象*。标准图形对象，如矩形、圆形和文本，被称为*基本*
    `Artists`。持有基本对象的对象，如`Figure`、`Axes`和`Axis`对象，称为*容器* `Artists`。
- en: Some of the more common `pyplot` methods for making plots and working with `Artists`
    are listed in the tables that follow. To see a full list, visit the Matplotlib
    `pyplot` [summary page](https://matplotlib.org/stable/api/pyplot_summary.html)[.](https://matplotlib.org/stable/api/pyplot_summary.html.)
    Clicking the method names in this online list will take you to detailed information
    on the method parameters, along with example applications. To read more about
    `Artists` in general, visit the Matplotlib [artist’s page](https://matplotlib.org/stable/tutorials/intermediate/artists.html).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c15ed472ed49f7a82923e30a3e70fd93.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: 'Some useful pyplot methods for creating plots (Source: Python Tools for Scientists
    [1])'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/70f1be4931e91f12b0ba2ca9a5c8a18f.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
- en: 'Some useful pyplot methods for manipulating plots (Source: Python Tools for
    Scientists [1])'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Note that the code examples in the tables represent *simple* cases. Most methods
    take many arguments, letting you fine-tune your plots with respect to properties
    like font style and size, line widths and colors, rotation angles, exploded views,
    and much more.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Working with Subplots
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we’ve been working with single figures, but there’ll be times when
    you’ll want to compare two plots side by side or bundle several charts into a
    summary display. For these occasions, Matplotlib provides the `subplot()` method.
    To see how this works, let’s begin by generating data for two different sine waves:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'One way to compare these waveforms is to plot them in the same `Axes` object,
    like so:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![](../Images/b97e337ca338ab4fd1d18c21489bd5f3.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
- en: Output of the pyplot sine program (by the author)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: By default, the two curves would be plotted with different colors (blue and
    orange). We overrode this with black (using the shorthand ‘k’) and “firebrick”
    red. We also forced a different line style using the `ls` parameter. Otherwise,
    both lines would have been solid. (For a list of characters available for marker
    and line styles, visit [this site](https://matplotlib.org/stable/api/_as_gen/
    matplotlib.pyplot.plot.html)).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: If you’re comparing more than a few curves, a single plot can become cluttered
    and difficult to read. In those cases, you’ll want to use separate stacked plots
    created by the `subplot()` method. The following diagram describes the syntax
    for this method, in which four subplots (`Axes`) are placed in a single `Figure`
    container.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/fe0f66b24af1ff5fedb0533b152677cd.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: 'Understanding the `subplot()` method (Source: Python Tools for Scientists [1])'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: The subplots will be arranged in a grid, and the first two arguments passed
    to the `subplot()` method specify the dimensions of this grid. The first argument
    represents the number of rows in the grid, the second is the number of columns,
    and the third argument is the index of the active subplot (highlighted in gray
    in the diagram).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: The active subplot is the one you are currently plotting in when you call a
    method like `plot()` or `scatter()`. Unlike most things in Python, the first index
    is 1, not 0.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 活动子图是你当前正在绘制的子图，当你调用`plot()`或`scatter()`等方法时。与 Python 中的大多数事物不同，第一个索引是 1，而不是
    0。
- en: Matplotlib uses a concept called the “current figure” to keep track of which
    `Axes` is currently being worked on. For example, when you call `plt.plot()`,
    `pyplot` creates a new “current figure” `Axes` to plot on. When working with multiple
    subplots, the index argument tells `pyplot` which subplot represents the “current
    figure.”
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib使用称为“当前图形”的概念来跟踪当前正在处理哪个`Axes`。例如，当你调用`plt.plot()`时，`pyplot`会创建一个新的“当前图形”`Axes`进行绘制。在处理多个子图时，索引参数告诉`pyplot`哪个子图代表“当前图形”。
- en: For convenience, you don’t need to use commas with the `subplot()` arguments.
    For example, `plt.subplot(223)` works the same as `plt.subplot(2, 2, 3)`, although
    it’s arguably less readable.
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了方便，你不需要在`subplot()`参数中使用逗号。例如，`plt.subplot(223)`与`plt.subplot(2, 2, 3)`效果相同，尽管前者可能阅读性较差。
- en: 'Now, let’s plot our sine waves as two separate stacked plots. The process will
    be to call the `subplot()` method and alter its active subplot argument to change
    the current subplot. For each current subplot, the `plot()` method will post the
    data specific to that subplot, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将正弦波绘制为两个独立的堆叠图。过程是调用`subplot()`方法，并更改其活动子图参数以改变当前子图。对于每个当前子图，`plot()`方法将发布特定于该子图的数据，如下所示：
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](../Images/597adaeb9a40a61c77175c7d003f2c8d.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/597adaeb9a40a61c77175c7d003f2c8d.png)'
- en: Output of pyplot sine subplot program (by the author)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`pyplot`正弦子图程序的输出（由作者提供）'
- en: Note that if you don’t set the y limits on the second plot, `pyplot` will automatically
    scale the graph so that the two subplots look identical. Because we manually set
    the scale on the second subplot with the `ylim()` method, it’s clear that the
    second sine wave has half the amplitude of the first.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你没有设置第二个图的 y 轴限制，`pyplot`会自动调整图表，使两个子图看起来相同。由于我们使用`ylim()`方法手动设置了第二个子图的比例，因此很明显第二个正弦波的幅度是第一个的一半。
- en: That’s a speedy look at some of the syntax for the `pyplot` approach. Now let’s
    look at the object-oriented style.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一瞥`pyplot`方法的一些语法。现在让我们来看一下面向对象的风格。
- en: Using the Object-Oriented Style
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用面向对象风格
- en: The object-oriented plotting style generally requires a bit more code than the
    previously described pyplot approach, but it lets you get the absolute most out
    of Matplotlib. By explicitly creating `Figure` and `Axes` objects, you’ll more
    easily control your plots, better understand interactions with other libraries,
    create plots with multiple x- and y-axes, and more.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的绘图风格通常需要比之前描述的`pyplot`方法更多的代码，但它让你能够最大限度地利用Matplotlib。通过显式创建`Figure`和`Axes`对象，你可以更轻松地控制图表，更好地理解与其他库的交互，创建具有多个
    x 和 y 轴的图表等等。
- en: Creating and Manipulating Plots with the Object-oriented Style
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用面向对象风格创建和操作图表
- en: To become familiar with the object-oriented style, let’s re-create the catenary
    plot from earlier in the article. To demonstrate some of the style’s enhanced
    functionality, we’ll force the y-axis to pass through the center of the plot.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了熟悉面向对象的风格，让我们重新创建文章前面提到的链线图。为了演示该风格的一些增强功能，我们将强制 y 轴通过图表的中心。
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The previous code will create a single empty figure. To custom configure the
    plot, next call the `Axes` object’s `set()` method and pass it keyword arguments
    for a title, axis labels, and axis limits. The `set()` method is a convenience
    method that lets you set *multiple* properties at once rather than calling specific
    methods for each.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将创建一个空的图形。要自定义配置图表，接下来调用`Axes`对象的`set()`方法，并传递标题、轴标签和轴限制的关键字参数。`set()`方法是一个便利方法，它允许你一次设置*多个*属性，而不是为每个属性调用特定的方法。
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Next, we’ll move the y-axis to the center of the chart instead of along the
    side. In Matplotlib, *spines* are the lines connecting the axis tick marks and
    marking the boundaries of the area containing the plotted data.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将把 y 轴移到图表的中心，而不是沿着一侧。在 Matplotlib 中，*spines* 是连接轴刻度线并标记包含绘制数据的区域边界的线。
- en: The default position for spines is *around* a plot with the ticks and labels
    along the left and bottom margins. But spines can also be placed at arbitrary
    positions. With the object-oriented style, we can accomplish this using the `set_position()`
    method of the `Spine` subclass.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: The following code first moves the left (y) axis to the `0` value on the x-axis.
    Then, the line width is set to `2` so that the axis stands out a bit from the
    background grid that we’re going to use later.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following line turns off the right boundary of the plot by setting its
    color to none:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The next three lines repeat this overall process for the bottom axis and top
    axis, respectively:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To finish the plot, we add a background grid and call the `plot()` method,
    passing it the x and y data and setting the line width to `3` and the color to
    `firebrick`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![](../Images/840fd3319e5e127eeb786a8cef5435db.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: The line plot of a catenary built using the object-oriented style (by the author)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: If you omit the code related to the spines, you can reproduce the `pyplot` version
    of this figure with essentially the same amount of code. Thus, the verbosity of
    the object-oriented style has much to do with the fact that you can do more with
    it, and people generally take advantage of this.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Methods available in the `pyplot` approach have an equivalent in the object-oriented
    style. Unfortunately, the method names are often different. For example, `title()`
    in `pyplot` becomes `set_title()`, and `xticks()` becomes `set_xticks()`. This
    is one reason why it’s good to pick one approach and stick with it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Some of the more common methods for making object-oriented plots are listed
    in the table that follows. You can find additional methods, such as for making
    box plots, violin plots, and more, in the [index of plot types](https://matplotlib.org/stable/plot_types/index.html)
    and in the [Matplotlib gallery](https://matplotlib.org/stable/gallery/index.html).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/26e2718d976ccab1c725594c0ca8fa5b.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: 'Some useful object-oriented methods for creating plots (Source: Python Tools
    for Scientists [1])'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Common methods for working with `Figure` and `Axes` objects are listed in the
    following tables. In many cases, these work like the `pyplot` methods, though
    the method names might be different.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7f0e52e6442fa0ad16ec5362dc829aac.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: 'Some useful object-oriented methods for manipulating plots (Source: Python
    Tools for Scientists [1])'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/66374df39a80062f0fd1945c82c58d74.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: 'Some useful methods for working with Axes objects (Source: Python Tools for
    Scientists [1])'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the `pyplot` section, the code examples in all these tables
    represent *simple* cases. Most methods take many arguments, letting you fine-tune
    your plots with respect to properties like font style and size, line widths and
    colors, rotation angles, exploded views, and so on. To learn more, visit the Matplotlib
    [docs](https://matplotlib.org/)[.](https://matplotlib.org/.)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Working with Subplots
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like the pyplot approach, the object-oriented style supports the use of subplots.
    Although there are multiple ways to assign subplots to `Figure` and `Axes` objects,
    the `plt.subplots()` method is convenient and returns a NumPy array that lets
    you select subplots using standard indexing or with unique names such as `axs[0,
    0]` or `ax1`. Another benefit is that you can preview the subplots’ geometry prior
    to plotting any data.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 与pyplot方法类似，对象导向风格支持使用子图。尽管有多种方式可以将子图分配给`Figure`和`Axes`对象，`plt.subplots()`方法既方便又返回一个NumPy数组，使你可以使用标准索引或唯一名称如`axs[0,
    0]`或`ax1`来选择子图。另一个好处是你可以在绘制任何数据之前预览子图的几何布局。
- en: The object-oriented method for creating subplots is spelled *subplots*, whereas
    the pyplot approach uses *subplot*. You can remember this by associating the simplest
    technique, pyplot, with the shortest name.
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 创建子图的面向对象方法拼写为*subplots*，而pyplot方法使用*subplot*。你可以通过将最简单的技术（pyplot）与最短的名称联系起来记住这一点。
- en: Calling `plt.subplots()` with no arguments generates a single empty plot. Technically,
    this produces a `1×1 AxesSubplot` object.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`plt.subplots()`而不带参数会生成一个空的单图。技术上，这会生成一个`1×1 AxesSubplot`对象。
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![](../Images/bb7970a9306f72d943cd6fc463c0ffbf.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/bb7970a9306f72d943cd6fc463c0ffbf.png)'
- en: An empty subplot (by the author)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一个空的子图（作者提供）
- en: Producing multiple subplots works like the `plt.subplot()` method, only without
    an index argument for the active subplot. The first argument indicates the number
    of rows; the second specifies the number of columns. By convention, multiple `Axes`
    are given the *plural* name, `axs`, rather than `axes` so as to avoid confusion
    with a single instance of `Axes`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 生成多个子图的工作方式类似于`plt.subplot()`方法，只是不需要为活动子图提供索引参数。第一个参数表示行数；第二个参数指定列数。按照惯例，多个`Axes`被赋予*复数*名称`axs`，而不是`axes`，以避免与单个`Axes`实例混淆。
- en: Passing the `plt.subplots()` method two arguments lets you control the number
    of subplots and their geometry. The following code generates the 2×2 grid of subplots
    shown below and stores a list of two `AxesSubplot` objects in the `axs` variable.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 传递两个参数给`plt.subplots()`方法可以控制子图的数量和几何布局。以下代码生成了下面显示的2×2子图网格，并将两个`AxesSubplot`对象的列表存储在`axs`变量中。
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![](../Images/9808fd51aafa446cc8c3f2391ca38bcb.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9808fd51aafa446cc8c3f2391ca38bcb.png)'
- en: A 2x2 grid of subplots (by the author)
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一个2x2的子图网格（作者提供）
- en: 'To activate a subplot, you can use its index. In this example, we plot on the
    second subplot in the first row:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活一个子图，你可以使用它的索引。在这个例子中，我们在第一行的第二个子图上绘图：
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![](../Images/1940e92300950f087d59de97764be13a.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1940e92300950f087d59de97764be13a.png)'
- en: A 2x2 grid of subplots with the second subplot active (by the author)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一个2x2的子图网格，第二个子图处于活动状态（作者提供）
- en: 'Alternatively, you can name and store the subplots individually by using tuple
    unpacking for multiple `Axes`. Each row of subplots will need to be in its own
    tuple. You can then select a subplot using a name, versus a less-readable index:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你可以通过使用元组解包为多个`Axes`来单独命名和存储子图。每一行的子图都需要放在自己的元组中。然后，你可以通过名称选择子图，而不是使用不太易读的索引：
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![](../Images/2d6bf2996a09d61330ad65aa9cd98232.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2d6bf2996a09d61330ad65aa9cd98232.png)'
- en: A 2x2 grid of subplots with the third subplot active (by the author)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一个2x2的子图网格，第三个子图处于活动状态（作者提供）
- en: 'In both the `pyplot` approach and object-oriented style, you can add whitespace
    around the subplots by calling the `tight_layout()` method on the `Figure` object:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pyplot`方法和面向对象风格中，你可以通过在`Figure`对象上调用`tight_layout()`方法来增加子图周围的空白。
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![](../Images/7288071bb53b562ca91552d92388ecad.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7288071bb53b562ca91552d92388ecad.png)'
- en: The effect of the tight_layout() method on subplot spacing (by the author)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`tight_layout()`方法对子图间距的影响（作者提供）'
- en: Now the subplots don’t look so cramped. For the `pyplot` approach you would
    use `plt.tight_layout()`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在子图看起来不那么拥挤了。对于`pyplot`方法，你会使用`plt.tight_layout()`。
- en: Alternative Ways to Make Subplots
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建子图的替代方法
- en: No matter which technique you use, there are higher-level alternatives to help
    you split a figure into a grid of subareas. This, in turn, helps you create subplots
    that have different widths and heights. The resulting multipaneled displays are
    useful for summarizing information in presentations and reports.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用哪种技术，都有更高级的替代方法来帮助你将图形拆分为网格状的子区域。这反过来有助于你创建具有不同宽度和高度的子图。生成的多面板显示对总结演示文稿和报告中的信息非常有用。
- en: 'Among these paneling tools are Matplotlib’s `[GridSpec](https://matplotlib.org/stable/api/_as_gen/matplotlib.gridspec.GridSpec.html)`
    module and its `subplot_mosaic()` method. Here’s an example built with `GridSpec`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/36c464e0f04344764af7323270e81045.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
- en: 'A multipanel display built with GridSpec (Source: Python Tools for Scientists
    [1])'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: To read more about these tools, visit [*Working with Multiple Figures and Axes*](https://matplotlib.org/stable/users/explain/quick_start.html)
    and [*Arranging Multiple Axes in a Figure*](https://matplotlib.org/stable/users/explain/axes/arranging_axes.html)
    in the Matplotlib docs, and my `GridSpec` tutorial [article](https://betterprogramming.pub/build-an-interactive-lithium-factbook-with-gridspec-and-geopandas-e699054237a8)
    in *Better Programming*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you program in Python, you need to know Matplotlib. To know Matplotlib, you
    need to understand its primary plotting nomenclature and its two plotting interfaces.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: The `Figure` object represents the *canvas* on which you plot. It controls things
    like the size of the plot, its aspect ratio, the padding between subplots, supertitles,
    and the ability to save the plot.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '`Figure` objects can hold multiple `Axes` objects that form what we generally
    think of as figures or diagrams. These include lines, points, text, titles, the
    plot’s coordinate system, and so on. Multiple `Axes` objects in the same `Figure`
    object constitute *subplots*.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Within an `Axes` object, the `Axis` element represents numerical values on the
    x, y, or z axis, including tick marks, labels, and limits.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Matplotlib comes with two main approaches to making plots. The `pyplot` approach
    is designed for quick and easy plotting, such as for exploratory data analysis.
    With this approach, `Figure` and `Axes` objects are created behind the scenes
    and most decisions, such as for axis scaling, colors, line styles, etc., are made
    for you (though you can override these to a point).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: For more involved plots, such as for reports and presentations, the *object-oriented
    style* explicitly creates `Figure` and `Axes` objects (by convention labeled as
    `fig`, `ax`). This provides you with more control and makes it easier to understand
    interactions with other Python libraries.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: If you’re not aware of these two paradigms for plotting, it’s easy to get confused
    when using code snippets you find online, such as on *Stack Overflow*. Because
    the methods used with each approach are similar but different, the Matplotlib
    developers recommend that you pick one approach and use it consistently.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Citations
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '“Python Tools for Scientists: An Introduction to Using Anaconda, JupyterLab,
    and Python’s Scientific Libraries” ([*No Starch Press*](https://nostarch.com/real-world-python),
    2023) by Lee Vaughan.'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thanks!
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thanks for reading and follow me for more *Quick Success Data Science* articles
    in the future. And if you want to learn more about Matplotlib and Python’s other
    plotting libraries, check out my book, [*Python Tools for Scientists*](https://a.co/d/67VvS3G),
    available online and in fine bookstores like Barnes and Noble.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://a.co/d/67VvS3G?source=post_page-----3895ab229a63--------------------------------)
    [## Python Tools for Scientists: An Introduction to Using Anaconda, JupyterLab,
    and Python''s Scientific…'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Python Tools for Scientists: An Introduction to Using Anaconda, JupyterLab,
    and Python''s Scientific Libraries…'
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: a.co](https://a.co/d/67VvS3G?source=post_page-----3895ab229a63--------------------------------)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
