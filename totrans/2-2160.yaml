- en: Two Powerful Python Features to Streamline Your Code and Make It More Readable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/two-powerful-python-features-to-streamline-your-code-and-make-it-more-readable-51240f11d1a](https://towardsdatascience.com/two-powerful-python-features-to-streamline-your-code-and-make-it-more-readable-51240f11d1a)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Enhance your code quality with the beauty of match statements and object slicing.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://murtaza5152-ali.medium.com/?source=post_page-----51240f11d1a--------------------------------)[![Murtaza
    Ali](../Images/2aecff50999761022af29f9b30e2f925.png)](https://murtaza5152-ali.medium.com/?source=post_page-----51240f11d1a--------------------------------)[](https://towardsdatascience.com/?source=post_page-----51240f11d1a--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----51240f11d1a--------------------------------)
    [Murtaza Ali](https://murtaza5152-ali.medium.com/?source=post_page-----51240f11d1a--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----51240f11d1a--------------------------------)
    ·8 min read·Sep 29, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4c2222582de9c851f5249d9cc8877197.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Kevin Ku](https://unsplash.com/@ikukevk?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: There is a reason Python’s popularity has spread far and wide in the current
    tech landscape. Among modern programming languages, it is perhaps the most accessible
    for novices. And with that accessibility, it also offers plenty of power. Web
    development, data science, scientific computing — you can accomplish many a task
    with Python.
  prefs: []
  type: TYPE_NORMAL
- en: As Python has advanced over the years, its developers have put great amounts
    of effort into maintaining its readability and conciseness. Though many of its
    features may require a bit of extra effort to learn, the return on clarity and
    beauty in your code is beyond worth it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this article, we’ll look at two such features: match statements and string/list
    slicing. We’ll go over how each one works in detail, as well as consider some
    examples to build familiarity with the syntax and semantics.'
  prefs: []
  type: TYPE_NORMAL
- en: Now then, let’s get into it.
  prefs: []
  type: TYPE_NORMAL
- en: Match Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Match statements — available in Python as of version 3.10 — are a way of checking
    equality of conditions and performing some action based on the conditions [1].
    If you are coming from another language such as C or JavaScript, you might already
    be familiar with the concept as *switch* statements.
  prefs: []
  type: TYPE_NORMAL
- en: In principle, match statements are similar to conditional statements, but they
    do provide a couple of useful advantages. Let’s start by looking at the basic
    structure via a comparison with conditionals; then, we’ll talk about the advantages.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might write the following conditional statement to check someone’s name
    for a bank account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Translated to a match statement, this would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break this down line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: The first line is the same — we just define the `name` variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The keyword `match` is used to start a match statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, for the individual conditions, rather than explicitly checking equality,
    we use the `case` statement to effectively pattern match. Thus, you can think
    of `case "Yen"` as checking for the case that `name`, which we are matching, is
    equal to `"Yen"`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the last case is the wildcard case. This is specified by an underscore
    (`_`) and is effectively the `else` case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, you might ask — why use this over a traditional conditional statement?
    I initially had the same question, and would even become annoyed when people used
    match instead of standard if-else statements. However, there are advantages.
  prefs: []
  type: TYPE_NORMAL
- en: The first one is simply that it is a cleaner way to achieve the same goal. This
    may seem like a cop-out reason, but it’s actually fairly important. The entire
    spirit of Python lies in writing clean, concise code (if you don’t believe me,
    type `import this` into your Python interpreter and hit enter).
  prefs: []
  type: TYPE_NORMAL
- en: Especially with a large number of conditions, it can be cumbersome to parse
    a long chain of `if` and `elif` statements. Using match statements cleans up the
    code and makes it easier for a fellow programmer to read — a worthy achievement
    for any Python programmer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beyond this, match statements can also deconstruct certain objects directly,
    removing the need to do so manually with conditional statements. In practice,
    this means two things:'
  prefs: []
  type: TYPE_NORMAL
- en: You can automatically check types (removing the need for manual checks).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can automatically access attributes of an object within each case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s take a look at an example. Say we have the following code, which defines
    two classes for different types of cars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We have defined an instance of `Subaru` above. Now, we want to write code that
    checks what type a car is and prints out some attribute of it. Using traditional
    conditional statements, we could do so as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For our `car` variable above, this will print out `"Subaru Outback"`. If we
    translate this to a match statement, we get the following, simplified code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Match’s pattern-matching functionality enables Python to automatically check
    the type within the `case` statement, and further makes it so that the attributes
    of the object can be accessed directly. Note that this is made possible by the
    inclusion of the `__match_args__` attribute in the class definition, as it names
    the positional arguments for Python. The recommendation in the Python documentation
    is for the pattern here to mimic the one used in the `__init__` constructor when
    assigning attributes to `self`.
  prefs: []
  type: TYPE_NORMAL
- en: The match version of the code is both easier to read and less cumbersome to
    write. This is a fairly small example, but as situations get more complex, [strings
    of conditional statements can get increasingly more convoluted](https://peps.python.org/pep-0622/#rationale-and-goals)
    [2].
  prefs: []
  type: TYPE_NORMAL
- en: All of that said, do keep in mind that this feature is only available starting
    in Python version 3.10\. As such, you should encode that whatever system, application,
    or project you are writing code for does not exist in a code base that must be
    compatible with an older version of Python.
  prefs: []
  type: TYPE_NORMAL
- en: As long as that condition is met, consider using match statements. It might
    require a bit of effort, but your code will be better off for it in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: String and List Slicing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may already be somewhat familiar with this feature, but I’m willing to bet
    you aren’t using it to its full potential. Let’s start with a quick review, and
    then look into some more complex uses.
  prefs: []
  type: TYPE_NORMAL
- en: 'In its simplest form, slicing refers to a concise syntax that lets you extract
    part of a string or list in Python [3]. Here is a small example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The syntax requires using square brackets which contain the start and stop index
    separated by a colon. Remember that Python uses 0-indexing, so `1` corresponds
    to `'e'` here. Additionally, note that slicing is exclusive of the right index,
    so it goes up to `3` but does **not** include it, hence why the output is `'el'`
    and not `'ell'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to just start from the beginning or go all the way to the end of
    a string or list, you can leave the corresponding index blank:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Leaving both indices blank gives you a copy of the entire object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that with both lists and strings, slicing defines and returns a brand
    new object distinct from the original:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s get to the good stuff. With slicing, you can also use negative indices.
    If you’re unfamiliar with negative indexing, it basically enables you to start
    counting from the end of a list or string. The last letter corresponds to `-1`,
    the second-to-last letter corresponds to `-2`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can simplify code by removing the need to manually compute lengths. To
    get everything but the last letter of a string, for instance, you can just do
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, one of the most overlooked features of slicing is that you can also
    specify a third number — which specifies a “jump” of sorts. This is easiest to
    explain with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down what’s happening above:'
  prefs: []
  type: TYPE_NORMAL
- en: For clarity, we define a list with more elements than the original one we had.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the list slice, the first two numbers are `1` and `-1`. As we saw above,
    this does away with the first and last elements of the object being sliced — `my_long_list`,
    in this case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we put a `2` as the final number after an additional colon. This tells
    Python that we want to slice the list from the start to the end index, but only
    keep every other item. Putting a `3` would give us every third item, putting a
    `4` would give us every fourth item, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Combining the two things above, we can also slice lists to get the elements
    backward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And there you have it — everything you need to know about list slicing. When
    you get creative with the syntax described above, you can achieve some really
    cool behavior. For example, the following is one of the slickest ways to reverse
    a list in Python, courtesy of list slicing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Do you see how it works? As an exercise, you should review each feature of
    list slicing above and try to break down the code yourself. **Hint: Take a look
    at what it means when we leave the start and end index blank.**'
  prefs: []
  type: TYPE_NORMAL
- en: Now then, let’s talk about why you should learn this stuff at all.
  prefs: []
  type: TYPE_NORMAL
- en: As a data scientist, why is this useful?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just generally speaking, it’s important to consider readability and cleanliness
    of code when writing in Python. Using the features above will go a long way in
    helping you achieve this. As we already discussed, match statements have a couple
    of meaningful advantages over conditional statements in this regard. As for list
    slicing, it is much, much cleaner than trying to achieve the same behavior using
    some kind of convoluted loop.
  prefs: []
  type: TYPE_NORMAL
- en: But going beyond these broader benefits, let’s talk data science specifically
    for a moment.
  prefs: []
  type: TYPE_NORMAL
- en: Practically speaking, if you’re working as a data scientist, there is a fair
    probability that your formal training was not in computer science, but rather
    in something like statistics, mathematics, or even just data science itself if
    you were lucky enough to find such a program. In such programs, computer science
    is generally taught as a tool.
  prefs: []
  type: TYPE_NORMAL
- en: The focus is on learning the basic principles of programming in a way that teaches
    you enough to process data, run analyses, and build models at scale. As such,
    there is not a huge amount of time left to learn topics like “useful Python-specific
    syntactic features.” Heck, such topics are often overlooked even in a pure computer
    science class.
  prefs: []
  type: TYPE_NORMAL
- en: However, using these features can take your code to the next level, helping
    you stand out among your brilliant colleagues and deliver better results to your
    clients. Match statements and object slicing are two powerful examples, [but there
    are a host more that Python has to offer](/3-underappreciated-skills-to-make-you-a-next-level-python-programmer-a20de69b29f2)
    which I encourage you to explore.
  prefs: []
  type: TYPE_NORMAL
- en: May the code be ever in your favor — until next time, friends.
  prefs: []
  type: TYPE_NORMAL
- en: '**Want to excel at Python?** [**Get exclusive, free access to my simple and
    easy-to-read guides here**](https://witty-speaker-6901.ck.page/0977670a91)**.
    Want to read unlimited stories on Medium? Sign up with my referral link below!**'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/@murtaza5152-ali/membership?source=post_page-----51240f11d1a--------------------------------)
    [## Join Medium with my referral link - Murtaza Ali'
  prefs: []
  type: TYPE_NORMAL
- en: As a Medium member, a portion of your membership fee goes to writers you read,
    and you get full access to every story…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/@murtaza5152-ali/membership?source=post_page-----51240f11d1a--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[1] [https://docs.python.org/3.10/whatsnew/3.10.html#syntax-and-operations](https://docs.python.org/3.10/whatsnew/3.10.html#syntax-and-operations)'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] [https://peps.python.org/pep-0622/#rationale-and-goals](https://peps.python.org/pep-0622/#rationale-and-goals)'
  prefs: []
  type: TYPE_NORMAL
- en: '[3] [https://docs.python.org/3/c-api/slice.html](https://docs.python.org/3/c-api/slice.html)'
  prefs: []
  type: TYPE_NORMAL
