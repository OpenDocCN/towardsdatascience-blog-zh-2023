["```py\nnohup python3 twit_grabs.py >/dev/null 2>&1 &\n```", "```py\ntail -f -n 50 tweets_20230601220000.csv\n```", "```py\nscp pi@raspberrypi:/home/pi/Documents/Twitter/tweets_20230601220000.csv .\n```", "```py\ndf_tweets = []\nfiles = glob.glob(\"data/*.csv\")\nfor file_name in files:\n    df_tweets.append(pd.read_csv(file_name, sep=';', \n                                 usecols=['id', 'created_at', 'user_name', 'user_location', 'full_text'], \n                                 parse_dates=[\"created_at\"], \n                                 lineterminator='\\n', quoting=csv.QUOTE_NONE))\ndf = pd.concat(df_tweets).drop_duplicates('id').sort_values(by=['id'], ascending=True)\n```", "```py\ndisplay(df)\n```", "```py\ntz_offset_hours = 2\n\ndef update_timezone(t_utc: np.datetime64):\n    \"\"\" Add timezone to the UTC time \"\"\"\n    return (t_utc + np.timedelta64(tz_offset_hours, 'h')).tz_convert(None)\n\ndef get_time(dt: datetime.datetime):\n    \"\"\" Get time in HHMM format from the datetime \"\"\"\n    return dt.time().replace(\n        second=0, \n        microsecond=0)\n\ndef get_date(dt: datetime.datetime):\n    \"\"\" Get date from the datetime \"\"\"\n    return dt.date()\n\ndef get_datetime_hhmm(dt: datetime.datetime):\n    \"\"\" Get date and time in HHMM format \"\"\"\n    return dt.to_pydatetime().replace(second=0, microsecond=0)\n\ndef get_hour(dt: datetime.datetime):\n    \"\"\" Get hour from the datetime \"\"\"\n    return dt.hour\n\ndf[\"time_local\"] = df['created_at'].map(update_timezone)\ndf[\"datetime_hhmm\"] = df['time_local'].map(get_datetime_hhmm)\ndf[\"date\"] = df['time_local'].map(get_date)\ndf[\"time\"] = df['time_local'].map(get_time)\ndf[\"hour\"] = df['time_local'].map(get_hour)\n# Optionally, we can select only several days\ndf = df[(df['date'] >= datetime.date(2023, 5, 30)) & (df['date'] <= datetime.date(2023, 5, 31))].sort_values(by=['id'], ascending=True)\n# Display\ndisplay(df)\n```", "```py\nfrom bokeh.io import show, output_notebook\nfrom bokeh.plotting import figure\nfrom bokeh.models import ColumnDataSource\nfrom bokeh.models import SingleIntervalTicker, LinearAxis\nfrom bokeh.transform import factor_cmap, factor_mark, linear_cmap\nfrom bokeh.palettes import *\noutput_notebook()\n\ndef draw_summary_timeline(df_in: pd.DataFrame):\n    \"\"\" Group all messages by time and draw the timline \"\"\"\n    print(\"All messages:\", df_in.shape[0])\n    users_total = df_in['user_name'].unique().shape[0]\n    print(\"All users:\", users_total)\n    days_total = df_in['date'].unique().shape[0]\n    print(\"Days total:\", days_total)\n    print()\n\n    gr_messages = df_in.groupby(['datetime_hhmm'], as_index=False).size() # .sort_values(by=['size'], ascending=False)\n    gr_messages[\"msg_per_sec\"] = gr_messages['size'].div(60)\n    datetime_hhmm = gr_messages['datetime_hhmm']\n    amount = gr_messages['msg_per_sec']\n\n    palette = RdYlBu11\n    p = figure(x_axis_type='datetime', width=2200, height=500, \n               title=\"Messages per second\")\n    p.vbar(x=datetime_hhmm, top=amount, width=datetime.timedelta(seconds=50), line_color=palette[0])\n    p.xaxis[0].ticker.desired_num_ticks = 30\n    p.xgrid.grid_line_color = None\n    show(p) \n\ndraw_summary_timeline(df_)\n```", "```py\ndf = df[(df['date'] >= datetime.date(2023, 5, 30)) & \\\n        (df['date'] <= datetime.date(2023, 6, 5))]\n```", "```py\ndf_short = df[(df['datetime_hhmm'] >= datetime.datetime(2023, 6, 4, 23, 35, 0)) & \\\n              (df['datetime_hhmm'] <= datetime.datetime(2023, 6, 4, 23, 55, 0))]\nwith pd.option_context('display.max_colwidth', 80):\n    display(df_short[[\"created_at\", \"full_text\"]])\n```", "```py\nfrom bokeh.io import show\nfrom bokeh.plotting import figure, output_file\nfrom bokeh.models import ColumnDataSource\nfrom bokeh.transform import linear_cmap\nfrom bokeh.palettes import *\n\ndef draw_dataframe(p: figure, df_in: pd.DataFrame, color: str, legend_label: str):\n    \"\"\" Draw all messages on the 00..24 timeline \"\"\"\n    messages_per_day = df_in.groupby(['time'], as_index=False).size()    \n    days_total = df[\"date\"].unique().shape[0]\n\n    msg_time = messages_per_day['time']\n    # Data was summarized per minute, div by 60 to get seconds\n    msg_count = messages_per_day['size']/(days_total*60)  \n\n    source = ColumnDataSource(data=dict(xs=msg_time, ys=msg_count))    \n    p.vbar(x='xs', top='ys', width=datetime.timedelta(seconds=50), \n           color=color, legend_label=legend_label, source=source)        \n\ndef draw_timeline(df_filtered: pd.DataFrame, df_full: pd.DataFrame):\n    \"\"\" Draw timeline as a bargraph \"\"\"\n    p = figure(width=1600, height=400, title=\"Messages per second\", x_axis_type=\"datetime\", x_axis_label='Time')\n\n    palette = RdYlBu11\n    draw_dataframe(p, df_full, color=palette[0], legend_label=\"All values\")\n    if df_filtered is not None:\n        draw_dataframe(p, df_filtered, color=palette[1], legend_label=\"Filtered values\")\n\n    p.xgrid.grid_line_color = None\n    p.x_range.start = 0\n    p.x_range.end = datetime.time(23, 59, 59)\n    p.xaxis.ticker.desired_num_ticks = 24\n    p.toolbar_location = None\n    show(p)\n```", "```py\ndraw_timeline(df_filtered=None, df_full=df)\n```", "```py\ndef draw_user_timeline(df_in: pd.DataFrame, user_name: str):\n    \"\"\" Draw cumulative messages time for specific user \"\"\"\n    df_u = df_in[df_in[\"user_name\"] == user_name]\n\n    # Group messages by time of the day\n    messages_per_day = df_u.groupby(['time'], as_index=False).size()\n    msg_time = messages_per_day['time']\n    msg_count = messages_per_day['size']\n\n    # Draw\n    p = figure(x_axis_type='datetime', width=1600, height=150, \n               title=f\"Cumulative tweets timeline: {name} ({sum(msg_count)} messages)\")\n    p.vbar(x=msg_time, top=msg_count, width=datetime.timedelta(seconds=30), line_color='black')\n    p.xaxis[0].ticker.desired_num_ticks = 30\n    p.xgrid.grid_line_color = None\n    p.toolbar_location = None\n    p.x_range.start = datetime.time(0,0,0)\n    p.x_range.end = datetime.time(23,59,0)\n    p.y_range.start = 0\n    p.y_range.end = 1\n    p.yaxis.major_tick_line_color = None\n    p.yaxis.minor_tick_line_color = None\n    p.yaxis.major_label_text_color = None\n    show(p)\n\ndraw_user_timeline(df, user_name=\"Ell_____\")\n```", "```py\ngr_messages_per_user = df.groupby(['user_name', 'hour'], as_index=True).size()\ndisplay(gr_messages_per_user)\n```", "```py\ndef get_user_hours_dataframe(df_in: pd.DataFrame):   \n    \"\"\" Get new dataframe of users \"\"\"    \n    busy_hours = []\n    messages = []\n    hour_vectors = []\n    vectors_per_hour = [[] for _ in range(24)]\n    gr_messages_per_user = df_in.groupby(['user_name', 'hour'], as_index=True).size()\n    users = gr_messages_per_user.index.get_level_values('user_name').unique().values\n    for ind, user in enumerate(users):\n        if ind % 50000 == 0:\n            print(f\"Processing {ind} of {users.shape[0]}\")\n        hours_all = [0]*24\n        for hr, value in gr_messages_per_user[user].items():\n            hours_all[hr] = value\n\n        busy_hours.append(get_busy_hours(hours_all))\n        messages.append(sum(hours_all))\n        hour_vectors.append(np.array(hours_all))\n        hours_normalized = get_hours_normalized(hours_all)\n        for hr in range(24):\n            vectors_per_hour[hr].append(hours_normalized[hr])\n\n    print(\"Making the dataframe...\")\n    cdf = pd.DataFrame({\n        \"user_name\": users,\n        \"messages\": messages,\n        \"hours\": hour_vectors,\n        \"busy_hours\": busy_hours\n    })\n    # Add hour columns to the dataframe\n    for hr in range(24):\n        cdf[str(hr)] = vectors_per_hour[hr]\n\n    return cdf.sort_values(by=['messages'], ascending=False) \n\ndef get_hours_normalized(hours_all: List) -> np.array:\n    \"\"\" Normalize all values in list to 100% total sum\"\"\"\n    a = np.array(hours_all)\n    return (100*a/linalg.norm(a, ord=1)).astype(int)\n\ndf_users = get_user_hours_dataframe(df)\nwith pd.option_context('display.max_colwidth', None):\n    display(df_users)\n```", "```py\ndisplay(df_users[:5])\n```", "```py\n> print(df_users[\"messages\"].quantile([0.05, 0.1, 0.5, 0.9, 0.95]))\n\n0.05     1.0\n0.10     1.0\n0.50     1.0\n0.90     4.0\n0.95    10.0\n```", "```py\n df_users_filtered = df_users.copy()\n    for p in range(24):\n        df_users_filtered = df_users_filtered[(df_users_filtered[str(p)] >= 2) & \\\n                                              (df_users_filtered[str(p)] <= 5)]\n\n    display(df_users_filtered)    \n    for user_name in df_users_filtered[\"user_name\"].values:\n        draw_user_timeline(df, user_name)\n```", "```py\ndf_users[\"night\"] = df_users[\"23\"] + df_users[\"0\"] + df_users[\"1\"] + df_users[\"2\"] + df_users[\"3\"] + df_users[\"4\"] + df_users[\"5\"] + df_users[\"6\"]\ndf_users[\"morning\"] = df_users[\"7\"] + df_users[\"8\"] + df_users[\"9\"] + df_users[\"10\"]\ndf_users[\"day\"] = df_users[\"11\"] + df_users[\"12\"] + df_users[\"13\"] + df_users[\"14\"] + df_users[\"15\"] + df_users[\"16\"] + df_users[\"17\"] + df_users[\"18\"]\ndf_users[\"evening\"] = df_users[\"19\"] + df_users[\"20\"] + df_users[\"21\"] + df_users[\"22\"]\n```", "```py\ndf_users_ = df_users[(df_users['messages'] > 10)]\ndf_ = df[df[\"user_name\"].isin(df_users_[\"user_name\"])]\n```", "```py\ndf_users_filtered = df_users_[df_users_['morning'] >= 50]\n\nprint(f\"Users: {100*df_users_filtered.shape[0]/df_users_.shape[0]}%\")\ndf_filtered = df_[df_[\"user_name\"].isin(df_users_filtered[\"user_name\"])]\ndraw_timeline(df_filtered, df_)\n```", "```py\ndf_users_filtered = df_users_[df_users_['evening'] >= 80]\n```", "```py\nfor user_name in df_users_filtered[:5][\"user_name\"].values:\n    draw_user_timeline(df_, user_name)\n```"]