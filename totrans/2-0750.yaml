- en: Do Discretized Qubits Work In Practice?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/do-discretized-qubits-work-in-practice-60acf19fc68c](https://towardsdatascience.com/do-discretized-qubits-work-in-practice-60acf19fc68c)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What if a qubit is more than just 0 or 1?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://pyqml.medium.com/?source=post_page-----60acf19fc68c--------------------------------)[![Frank
    Zickert | Quantum Machine Learning](../Images/ae361c0d68d13dac21bb86c7496d2917.png)](https://pyqml.medium.com/?source=post_page-----60acf19fc68c--------------------------------)[](https://towardsdatascience.com/?source=post_page-----60acf19fc68c--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----60acf19fc68c--------------------------------)
    [Frank Zickert | Quantum Machine Learning](https://pyqml.medium.com/?source=post_page-----60acf19fc68c--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----60acf19fc68c--------------------------------)
    ·9 min read·Jan 18, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: Do you want to get started with Quantum Machine Learning? Have a look at [**Hands-On
    Quantum Machine Learning With Python**](https://www.pyqml.com/volume1?provider=medium&origin=discretizedqubit)**.**
  prefs: []
  type: TYPE_NORMAL
- en: Machine learning models have become increasingly complex and, therefore, hard
    to train. Take ChatGPT, for instance. On a single GPU, its training would have
    taken 355 years.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum computing is a promising technology that could accelerate the training
    of such models. Yet, it comes with its own set of challenges.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum bits (qubits) are the basic unit we use inside a quantum computer. Unlike
    classical bits, which are either 0 or 1, quantum bits are in a complex linear
    relationship between their two basis states |0⟩ and |1⟩, called superposition.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d4ac85b337301a61c12c7e25e0d8faca.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: This makes them extremely powerful. First, this relationship is not discrete
    but continuous, meaning the qubit can assume any value between the two basis states.
    Second, the relationship builds upon complex numbers — these are two-dimensional
    constructs — which exceed the capabilities of the one-dimensional numbers we’re
    used to working with.
  prefs: []
  type: TYPE_NORMAL
- en: But there’s a problem. There always is — unfortunately.
  prefs: []
  type: TYPE_NORMAL
- en: Once we measure a qubit, it collapses to either of its basis states. Inevitably,
    all we see is 0 or 1.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, we only have very few qubits. And the qubits we have are prone to
    errors. We say they are noisy.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, we — the algorithm developers — can’t increase the number of available
    qubits. This challenge remains with the hardware manufacturers such as IBM. But,
    we can use the few qubits we have as efficiently as possible.
  prefs: []
  type: TYPE_NORMAL
- en: To this end, I [have proposed discretizing the expectation value](https://medium.com/towards-data-science/how-to-get-the-most-out-of-your-quantum-bit-56d4dc535aa6)
    and thus encoding more than two values by a qubit.
  prefs: []
  type: TYPE_NORMAL
- en: '[](/how-to-get-the-most-out-of-your-quantum-bit-56d4dc535aa6?source=post_page-----60acf19fc68c--------------------------------)
    [## How To Get The Most Out Of Your Quantum Bit'
  prefs: []
  type: TYPE_NORMAL
- en: There’s more in a qubit than 0 and 1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/how-to-get-the-most-out-of-your-quantum-bit-56d4dc535aa6?source=post_page-----60acf19fc68c--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: The expectation value results from the repeated execution of a circuit and measuring
    the qubit. So, for instance, if a qubit is 1 in only three out of ten executions,
    its expectation value is `0.3`.
  prefs: []
  type: TYPE_NORMAL
- en: The following function takes the `counts` object that results from running a
    quantum circuit in Qiskit — IBM’s quantum development kit. The `blocks` parameter
    denotes the number of discrete values we want to use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This function loops through all items in the `counts` object. These items are
    key-value pairs, such as `0: 300` where the key (`0`) represents the measurement,
    and the value (`300`) represents the number of times we observed it.'
  prefs: []
  type: TYPE_NORMAL
- en: We multiply each key with its value and multiply that by the number of blocks
    and decrease that value a little bit (multiply by `0.999`). This means we regard
    a value that resides at the exact line between two discrete values as the lower
    one.
  prefs: []
  type: TYPE_NORMAL
- en: The overall discretized value is the total sum of all weighted values divided
    by the total sum of all unweighted values.
  prefs: []
  type: TYPE_NORMAL
- en: This is but a short function. Yet, let’s see how it performs in practice.
  prefs: []
  type: TYPE_NORMAL
- en: First, we write a helper function that creates the `counts` object for us.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This function takes the number of `blocks`, the `steps`, and the `current` step
    as parameters. I’ll explain these in a minute. First, let’s look into the definition
    of the function. We create a quantum circuit with a single qubit and apply a rotation
    around the Y-axis.
  prefs: []
  type: TYPE_NORMAL
- en: '[This post](https://pyqml.medium.com/how-to-precisely-control-your-qubits-in-qiskit-357f44780725)
    explains this operator in detail.'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://pyqml.medium.com/how-to-precisely-control-your-qubits-in-qiskit-357f44780725?source=post_page-----60acf19fc68c--------------------------------)
    [## How To Precisely Control Your Qubits In Qiskit'
  prefs: []
  type: TYPE_NORMAL
- en: The RY operator in practice
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: pyqml.medium.com](https://pyqml.medium.com/how-to-precisely-control-your-qubits-in-qiskit-357f44780725?source=post_page-----60acf19fc68c--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, the `ry` gate rotates the default state |0⟩ to a state that represents
    a certain probability of measuring the qubit as 1\. Here, this probability is
    `(current+0.5)/steps`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we define a `backend` and `execute` the quantum circuit to obtain the
    `result` that provides the `counts` that we `discretize`.
  prefs: []
  type: TYPE_NORMAL
- en: The behavior of this helper function becomes apparent when we use it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this code is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: So, what happens here?
  prefs: []
  type: TYPE_NORMAL
- en: First, we define to discretize the expectation value of our qubit into four
    `blocks`. We want to evaluate this function with 20 `steps`. So, we run the circuit
    for each current step (`x`).
  prefs: []
  type: TYPE_NORMAL
- en: The first rows of the output denote the `counts` printed inside `discretize`
    function. As you see, the probability of measuring the qubit as 1 increases as
    the probability of measuring it as 0 decreases. The probability represents the
    ratio between the current step and the total number of steps. This is what we
    calculate by `prob_to_angle((current+0.5)/steps)`.
  prefs: []
  type: TYPE_NORMAL
- en: The next line shows the list of discretized values. As we see, the first five
    items correspond to the value `0`, the next five to the value `1` and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The last output shows the distribution of discretized values. Each value from
    `0` to `3` appears five times. Since we have 20 steps, is demonstrates that the
    discretization works fine.
  prefs: []
  type: TYPE_NORMAL
- en: But this is not a real test yet. We used the `statevector_simulator` that prepares
    the perfect quantum state and the exact `counts` corresponding to it.
  prefs: []
  type: TYPE_NORMAL
- en: But, measuring quantum states can only be done empirically in reality. We can’t
    compute the perfect quantum state of a larger quantum circuit. If we could, there
    was no reason to build and use a quantum computer.
  prefs: []
  type: TYPE_NORMAL
- en: So, the next helper function uses the `qasm_simulator` that creates the `counts`
    empirically.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There are only two differences. First, we use the `qasm_simulator` instead of
    the `statevector_simulator`. Second, we measure the qubits after we applied the
    `ry` gate.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We see that the `counts` are not as perfectly distributed anymore. However,
    the discretization still works. We see each discrete value exactly five times.
  prefs: []
  type: TYPE_NORMAL
- en: But we are not there yet. Even though we see statistical deviations in the results,
    the `qasm_simulator` simulates a noise-free quantum computer. But we do not have
    such devices yet.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, our current devices are prone to errors. They are noisy. So, let’s
    add some noise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: While the circuit remains the same, we create another backend this time. We
    create a simulator that exhibits the same noise as IBM’s quantum computer in Quito.
    This is a five-qubit quantum computer available through the IBM cloud.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We see the `counts` to deviate even further from the correct values. And as
    a consequence, we see that we get one wrong discretization. We take one `3` for
    a `2`, in the case of `{0: 284, 1: 716}`. Certainly, we would not have seen an
    error if we only interpreted the `counts` as either 0 or 1\. The item in question
    certainly is rather 1 than 0.'
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, the result is not too bad. In fact, let’s see what happens if we
    interpret the expectation value not as four but as eight values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We would expect to see each discretized value exactly three times. So, even
    though the results are not entirely unreasonable, we see a significant number
    of errors here.
  prefs: []
  type: TYPE_NORMAL
- en: So, discretized expectation values increase the susceptibility to noise. But,
    error mitigation techniques, such as the zero-noise extrapolation technique (ZNE)
    or Clifford Data Regression (CDR), help us mitigate the negative effect of noise.
  prefs: []
  type: TYPE_NORMAL
- en: '[](/how-to-implement-quantum-error-mitigation-with-qiskit-and-mitiq-e2f6a933619c?source=post_page-----60acf19fc68c--------------------------------)
    [## How To Implement Quantum Error Mitigation With Qiskit And Mitiq'
  prefs: []
  type: TYPE_NORMAL
- en: Learn how to implement the Clifford Data Regression
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/how-to-implement-quantum-error-mitigation-with-qiskit-and-mitiq-e2f6a933619c?source=post_page-----60acf19fc68c--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nevertheless, the ability to encode four or even eight instead of only two values
    could be a decisive factor when using current quantum computers. While we can’t
    easily increase the number of available qubits, we can use appropriate techniques,
    such as discretization. When combined with error mitigation techniques, we could
    possibly make our tiny number of qubits appear much bigger.
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://pyqml.medium.com/membership?source=post_page-----60acf19fc68c--------------------------------)
    [## Join Medium with my referral link - Frank Zickert | Quantum Machine Learning'
  prefs: []
  type: TYPE_NORMAL
- en: Get Started With Quantum Machine Learning (and get full access to every story
    on Medium) Get full access to all the…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: pyqml.medium.com](https://pyqml.medium.com/membership?source=post_page-----60acf19fc68c--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Don’t miss the next episode, and subscribe to my [Substack channel](https://pyqml.substack.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Do you want to get started with Quantum Machine Learning? Have a look at [**Hands-On
    Quantum Machine Learning With Python**](https://www.pyqml.com/volume1?provider=medium&origin=discretizedqubit)**.**
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c3892c668b9d47f57e47f1e6d80af7b6.png)'
  prefs: []
  type: TYPE_IMG
- en: Get the first three chapters for free [here](https://www.pyqml.com/volume1?provider=medium&origin=discretizedqubit).
  prefs: []
  type: TYPE_NORMAL
