- en: An Introduction to Polars for Pandas Users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://towardsdatascience.com/an-introduction-to-polars-for-pandas-users-2a52b2a03017](https://towardsdatascience.com/an-introduction-to-polars-for-pandas-users-2a52b2a03017)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Demonstrating how to use the new blazing fast DataFrame library for interacting
    with tabular data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://dkhundley.medium.com/?source=post_page-----2a52b2a03017--------------------------------)[![David
    Hundley](../Images/1779ef96ec3d338f8fe4a9567ba7b194.png)](https://dkhundley.medium.com/?source=post_page-----2a52b2a03017--------------------------------)[](https://towardsdatascience.com/?source=post_page-----2a52b2a03017--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----2a52b2a03017--------------------------------)
    [David Hundley](https://dkhundley.medium.com/?source=post_page-----2a52b2a03017--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ¬∑Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----2a52b2a03017--------------------------------)
    ¬∑17 min read¬∑Mar 5, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/703b01459d9d9be0836f9fc0c45e973d.png)'
  prefs: []
  type: TYPE_IMG
- en: Title card created by the author
  prefs: []
  type: TYPE_NORMAL
- en: If you‚Äôre like me, you may be hearing a lot of hype about this new [Polars](https://www.pola.rs)
    library but are not sure what it is or how to get started. If you‚Äôre totally new
    to it, the simplest way to understand Polars is that it is a very fast alternative
    to the more traditional Pandas DataFrame library. We‚Äôll be focusing on the Python
    implementation of Polars for this post, but be aware it is also written to work
    with the growingly popular Rust language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before proceeding, let me be the first to address the cautious optimism I have
    with any new software like this. There‚Äôs always this big question: ‚ÄúWill this
    become mainstream?‚Äù I‚Äôve unfortunately seen too many times where a really cool
    piece of software got a lot of hype in the beginning only to fade away later on.
    In regards to Polars, I think it is way too soon to make that determination for
    the long term, but I will give an assessment on my personal thoughts about Polars
    at the end of this post.'
  prefs: []
  type: TYPE_NORMAL
- en: This introductory guide is specifically written for people who are already familiar
    with the Pandas library, and I will be doing a direct compare / contrast of the
    Polars versus Pandas syntax and performance. If you would like to follow along
    more seamlessly, [please find my code here in GitHub](https://github.com/dkhundley/ds-quick-tips/blob/master/016_intro_to_polars/intro_to_polars.ipynb).
    For demonstration purposes, we will be making use of the [classic Titanic dataset](https://www.tensorflow.org/datasets/catalog/titanic).
    Also for context around the performance metrics I‚Äôll be showing, I am performing
    all this work on a standard 2021 MacBook Pro with M1 Pro chip. (I did also test
    this on a Microsoft Surface Pro 9 running Windows 11 and can confirm it all worked
    there similarly.)
  prefs: []
  type: TYPE_NORMAL
- en: 'One final note before jumping into the bulk of this post: Polars is still VERY
    early in its lifecycle, so don‚Äôt be surprised if even 6 months from now contents
    of this post are outdated.'
  prefs: []
  type: TYPE_NORMAL
- en: Okay, let‚Äôs jump into exploring Polars! üêª‚Äç‚ùÑÔ∏è
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fortunately, installing Polars is very easy. You can install Polars as you would
    any other Python library. Here is the specific command you can use to install
    Polars from PyPI.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: At times throughout this guide, we will have to make some translations back
    and forth between Pandas and Polars. (Yes, this is not ideal and something I would
    prefer to avoid, but for the time being, this is the only way around some issues
    I ran into.) In order to do this, you will also need to install the PyArrow Python
    libary. Similar to installing Polars, we can run the following command to install
    PyArrow from PyPI.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This last installation step is optional, but you may find it useful for future
    work. As mentioned in the introduction, I intend to demonstrate the performance
    of Pandas compared to Polars, and doing this work in a Jupyter notebook, we could
    run the Jupyter magic command `%% time` to output the runtime of each specific
    cell. This can naturally become very tedious to type, and fortunately, we can
    install a special Jupyter extension that will automatedly display the runtime
    of each cell in a tiny line of text below each run cell. In order to do that,
    we‚Äôll need to run the following 3 commands in your CLI.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: What the commands above enable is a new toggle in the Jupyter user interface
    that will properly display the runtime for each cell run. To enable this in the
    Jupyter notebook inferface, navigate to `Cell > Execution Timings` and select
    `Toggle Visibility (all)`. The screenshot below also demonstrates this appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d994115ff6980b9841e5028199f2f595.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot captured by the author
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this first section, we‚Äôll demonstrate a few common commands that many data
    scientists and machine learning engineers prefer to run at the outset of working
    with any new dataset. As a reminder, we will be working with the Titanic dataset,
    which I have already saved to my local computer as a CSV file in an adjacent directory.
  prefs: []
  type: TYPE_NORMAL
- en: Importing Pandas and Polars
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of course, the first thing we‚Äôll want to do is to import each of the respective
    Python libraries appropriately. As Pandas users are aware, Pandas is almost aliased
    as `pd` when imported. Likewise, Polars is also often aliased with the two letters
    `pl`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Loading Data from a CSV File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout this post, you‚Äôll find that Polars and Pandas can sometimes have
    very different ways of doing things and other times the syntax will be the exact
    same. Fortunately, this first instance is the exact same from Pandas to Polars.
    Here is the code demonstrating that similarity.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Before proceeding forward, let‚Äôs start talking about the performance of these
    libraries. As you can see in the screenshot below, the Polars load was 1 millisecond
    faster than the Pandas load. Transparently, I got different results each time
    I ran these cells, but I can say that Polars was consistently faster. This will
    be a recurring theme throughout this whole post.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a81ee9ee2adf7aa1ef5a518cd505c450.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot captured by the author
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the First Rows of Each DataFrame
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Immediately after loading a CSV, the first thing I like to do is view the first
    few rows of the DataFrame just to get a sense of what I‚Äôm working with. From a
    syntax perspective, Pandas users will immediately find themselves at home with
    Polars‚Äô implementation as its the exact same.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: While the syntax is the same, the output is interestingly different between
    Pandas and Polars, and for the most part, I actually really like how Polars displays
    the output here. As you can see below, Polars displays the data type of each respective
    feature directly below the name of each feature. Moreover, the syntax of string-based
    columns shows the values wrapped in double quotes. I personally really love this
    because Pandas isn‚Äôt overtly clear about the data types of each column, especially
    when it comes to strings. The only odd quirk about Polars is that it doesn‚Äôt display
    the index values of each row off to the left as Pandas does. To be clear, the
    index values are still intact; they just aren‚Äôt displayed in this view. (Also
    notice that Polars ran twice as fast as Pandas in this instance.)
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/77491e9e6f6e522038c99211c9ed321e.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot captured by the author
  prefs: []
  type: TYPE_NORMAL
- en: Viewing Information about the DataFrame
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, the syntax of both libraries has been the same, but we now come to
    the point where they begin to radically diverge in functionality. Pandas users
    will be familiar with two functions that each show respective information about
    the DataFrame: `info()` and `describe()`. `info()` shows things like the feature
    names, data types, and null values, while `describe()` shows general statistics
    associated to each feature like mean and standard deviation. Here is the Pandas
    code and a screenshot of the output of each respective function.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/7257c3eeb2171b3849283f789eb764f0.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot captured by the author
  prefs: []
  type: TYPE_NORMAL
- en: Polars takes a very different turn from Pandas in this regard. For starters,
    there is no `info()` command. Instead, it takes the `describe()` command and more
    or less mashes the outputs we‚Äôre used to seeing across Pandas‚Äô `info()` and `describe()`
    functions into a single output. Below is what that looks like.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/17664d4ae512f1016ed06d2128f64a1b.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot captured by the author
  prefs: []
  type: TYPE_NORMAL
- en: To be honest, I don‚Äôt know how I feel about this implementation. On one hand,
    I think the Polars output makes it clearer how many nulls there are since you
    have to do a bit of mental math to understand how many nulls there are in the
    Pandas output. But on the other hand, Polars loses information provided by Pandas
    like the interquartile range values. Notice also that in the Pandas `describe()`
    output, it rightfully excludes string-based columns whereas Polars keeps them
    in there. I typically wouldn‚Äôt care, but if you look at the ‚Äúmin‚Äù and ‚Äúmax‚Äù values
    for the ‚ÄúSex‚Äù feature, for example, it gives some‚Ä¶ well‚Ä¶ unsavory results!
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the Value Counts of a Specific Feature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another thing I like to do when first getting started with a dataset using categorical
    data is to look at the value counts associated to each categorical feature. Fortunately,
    we‚Äôre back to a similar syntax that Pandas users will be familiar with, except
    you‚Äôll notice the output is a little different.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/220da36c5be2321c116817c435d79ce2.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot captured by the author
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the Polars output is actually a little more informative because
    it includes the number of null values whereas the Pandas output doesn‚Äôt talk about
    the null values at all. This is one instance where I have to give Polars a clean
    win. This is really handy!
  prefs: []
  type: TYPE_NORMAL
- en: Data Wrangling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we‚Äôve explored some very preliminary commands, let‚Äôs move into some
    more complex functionality with data wrangling. We‚Äôll explore a few common wrangling
    tactics in this section and continue our comparison between Pandas and Polars
    along the way.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a Slice of the DataFrame
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember how I mentioned that it was odd that Polars doesn‚Äôt show the index
    values for each row in the `head()` output but that they are still there? We can
    prove that here by demonstrating how to get a slice of each DataFrame. Fortunately,
    the syntax and output for Polars and Pandas is the exact same here. Also, doing
    a quick check in on our performance metrics, notice how Polars executed this slicing
    twice as fast as Pandas.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/5a9d0db740d6c18e987436ad631640cd.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot captured by the author
  prefs: []
  type: TYPE_NORMAL
- en: Filtering the DataFrame by Feature Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of everything we‚Äôll be demonstrating in this post, this is the area in which
    we can perform similar functionality in many different ways. I‚Äôm not going to
    attempt to demonstrate all of them, so I chose the following way to show that
    Polars can emulate similar functionality to Pandas but with syntax that is just
    a little bit different. Below is the code to pull out all rows representing teenagers
    on the Titanic. (The output is a bit long since there are 95 teenagers, so I won‚Äôt
    show the output. Just know that the output is indeed the same.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, there are several different ways we could achieve the same results in
    Pandas and Polars with different syntax. The one thing I do want to highlight
    is that [the official Polars documentation](https://pola-rs.github.io/polars/py-polars/html/reference/dataframe/api/polars.DataFrame.filter.html#polars.DataFrame.filter)
    demonstrates what I did above using what I perceive as an odd choice of syntax.
    Where I use `df_polars[''Age'']` to reference the ‚ÄúAge‚Äù column in the Polars DataFrame,
    the official documentation instead recommends using this syntax: `pl.col(''Age'')`.
    The output is the exact same, so it‚Äôs not as if either is wrong. You would think
    that Polars would want to demonstrate things as closely as possible to Pandas
    since most people using Polars will be Pandas users, and as I successfully demonstrated,
    the class choice of `df_polars[''Age'']` worked just fine. This actually occurs
    quite a bit in the Polars documentation, so be aware that though the documentation
    may say one thing, you might be able to get away with a more classic syntax you‚Äôre
    already used to.'
  prefs: []
  type: TYPE_NORMAL
- en: Filling Null Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thus far, our experience with Polars has ranged from neutral to positive. With
    this particular piece of functionality, we unfortunately begin to stray into some
    negative territory. Filling a column with null values is relatively straightforward
    in Pandas, and we can even apply this filling directly in place with the `inplace`
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Polars unfortunately is a bit odd here. First, there is no equivalent of the
    `inplace` parameter, and this is actually a recurring theme throughout Polars
    as we‚Äôll see again later in the post. Moreover, Polars actually has two different
    functions for filling null values: `fill_null()` and `fill_nan()`. Looking at
    the documentation for each, I honestly can‚Äôt tell you why you would choose one
    over the other. (Of course, this could very well be my own ignorance.) In the
    code block below, I make use of the `fill_null()` function to the same effect
    as Pandas‚Äô `fillna()`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Grouping Data by Feature Names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to get a deeper understanding of the data, it is very common for data
    practitioners to group data together to understand how groups of data may share
    new insights with us. Pandas users will be very familiar with the `groupby()`
    function in this regard. Unfortunately, Polars also does have a `groupby()` function,
    but its output is very different. Pandas users will find this difference to be
    jarring, and I transparently could not find a way to emulate the Pandas output
    using a different Polars syntax. (Granted, I admittedly didn‚Äôt try very hard.
    üòÖ) See below how the same syntax produces very different results across each library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/787392a5661e492c2433c0acafb38a14.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot captured by the author
  prefs: []
  type: TYPE_NORMAL
- en: Feature Engineering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While feature engineering could certainly be considered a type of data wrangling,
    I decided to separate this into its own respective section as it correlates to
    other work I‚Äôve done in the past. As part of [this notebook on GitHub](https://github.com/dkhundley/titanic-byoc/blob/main/notebooks/feature-engineering.ipynb),
    I demonstrated how one might perform feature engineering on the Titanic dataset.
    We won‚Äôt be covering every bit of feature engineering in this section, but we‚Äôll
    demonstrate a few things so you can get a sense of how this same work compares
    in Pandas and Polars. We‚Äôll start fresh again by reloading each DataFrame from
    scratch with this code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Dropping Unnecessary Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In almost every dataset you‚Äôll work with, you‚Äôll find features that are irrelevant
    and need dropped before passing into any machine learning algorithm. While this
    is not difficult to do in Polars, recall that Polars functions do not have a similar
    `inplace` parameter that would allow us to update the Polars DataFrame in place.
    Here is the syntax for dropping features in both libraries.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: One-Hot Encoding Categorical Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember at the beginning when I mentioned we‚Äôd have to install PyArrow to translate
    our Polars DataFrame into a Pandas DataFrame? Well, here is our first instance
    of why we have to do that. I personally prefer to use [Category Encoder‚Äôs implementation
    of one-hot encoding](https://contrib.scikit-learn.org/category_encoders/onehot.html)
    for my one-hot encoding work. For context, here‚Äôs how you would import that after
    installing it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If we were to perform one-hot encoding on the ‚ÄúSex‚Äù (aka gender) feature using
    Pandas, here is what the syntax would look like.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, Category Encoder‚Äôs `OneHotEncoder` isn‚Äôt set up to work with
    Polars. If we were to run the following line as is, we‚Äôd see the error in the
    screenshot below it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/2f75467a70dbf45a14f5592e0f666ca0.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot captured by the author
  prefs: []
  type: TYPE_NORMAL
- en: There is a workaround for this, but unfortunately this will not be the first
    time we‚Äôll run into a breaking issue like this. Below is the full workaround for
    using Polars to perform a one-hot encoding. Notice that prior to fitting the Polars
    DataFrame to the `OneHotEncoder` object, we will first have to translate it into
    a Pandas DataFrame. Then after the conversion, we can simply translate it back
    into a Polars DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Finally, note that Polars‚Äô implementation of the `concat()` function is just
    a little bit different from Pandas. Where Pandas uses the `axis` parameter to
    indicate how to perform the concatenation, Polars uses `how` and string-based
    values instead. I personally prefer how Polars implemented this here.
  prefs: []
  type: TYPE_NORMAL
- en: Binning Numerical Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The way in which I chose to perform to feature engineer the ‚ÄúAge‚Äù feature was
    by binning it into appropriate age groups. For example, people aged 13 to 19 would
    be classified as teenagers whereas anybody over age 60 was considered an elder.
    Pandas has a very nice function called `cut()` that does this binning appropriately
    per the inputs you provide it. Here is the syntax for doing just that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Polars does offer its own implementation of `cut()`, but its output is radically
    different than Pandas to the point where I personally find it unusable. Here is
    the syntax and output of that code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/dc0c1a4929db2da4a03c4721c8ef94ed.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot captured by the author
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the output, it actually does appear that the binning worked, but
    it did a few weird things. First, it wouldn‚Äôt take my semantic names established
    by the `bin_labels` array. Second, it didn‚Äôt preserve the order of the rows as
    they were passed into the function. Instead, you can see that the Polars output
    has now sorted by the values in ascending order starting with the lowest value
    (aka the youngest age). I‚Äôm sure I could find a workaround for the first issue,
    but second issue renders this output useless for me. The temptation would be to
    match the ages to the original DataFrame, but as you can see in this simple output,
    lines 4 and 5 have the same `0.75` value. While this might be fine in this particular
    use case, this practice could be dangerous for a different dataset.
  prefs: []
  type: TYPE_NORMAL
- en: '(Note: As I was drafting this post, I upgraded from Polars 0.16.8 to 0.16.10,
    in which the Polars `cut()` function is now being deprecated in favor of using
    the Polars Series implementation of `cut()`. It doesn‚Äôt seem that this new implementation
    fixes the issue, and at the time of this publication, [a GitHub issue](https://github.com/pola-rs/polars/issues/4286)
    has been noted requesting to add the row index preservation. In general, this
    is a good reminder that Polars in an early state!)'
  prefs: []
  type: TYPE_NORMAL
- en: Predictive Modeling with Machine Learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This final section will be brief because, unfortunately, this is where Polars
    ultimately falls flat for me, at least at the point when this post is published.
    Similarly to how I created a Jupyter notebook for feature engineering in a previous
    Titanic project, I will attempt to emulate the same steps I completed in [my original
    Titanic predictive modeling notebook](https://github.com/dkhundley/titanic-byoc/blob/main/notebooks/predictive-modeling.ipynb).
  prefs: []
  type: TYPE_NORMAL
- en: Performing a Train-Test Split
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The hallmark of any good machine learning practice, the code below demonstrates
    how to perform a train-test (or train-validation) split to have holdout set to
    later use for model validation. Since we‚Äôll be making use of Scikit-Learn‚Äôs `train_test_split`
    function, there‚Äôs not much to note here since the syntax is the exact same for
    both the Pandas and Polars DataFrames. I suppose I just wanted to highlight that
    this works with Polars out of the box today without any special workarounds. üòÉ
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Performing Predictive Modeling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We finally come to the point where Polars unfortunately falls off the rails.
    In the code below, I demonstrate how you would fit the Pandas DataFrames to Scikit-Learn‚Äôs
    Random Forest Classifier, which should produce the output in that nice blue box.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/cf94b6c20626534769b49c6d1e7848ce.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot captured by the author
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, I hit a brick wall when attempting to do this same thing with
    the Polars DataFrame. When I attempt to run the code block below, I get the error
    you see in the screenshot below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/564dc0c090ee1d6eb0a650bdcad85558.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot captured by the author
  prefs: []
  type: TYPE_NORMAL
- en: I spent a solid hour combing Scikit-Learn‚Äôs source code to understand what was
    going on here and am still not quite sure why it is not reading the Polars DataFrame‚Äôs
    shapes consistently as the Pandas DataFrames. When running commands like `df_polars.shape`
    and other similar ones, it consistently displays the same output as the correlative
    Pandas commands. It was definitely a head scratcher.
  prefs: []
  type: TYPE_NORMAL
- en: Now transparently, Scikit-Learn was the only algorithmic library I tried for
    this experiment. You may experience different results with other algorithmic libraries
    like XGBoost or LightGBM, but I‚Äôm honestly inclined to believe that most ‚Äî if
    not all ‚Äî will have the same issue I saw with Scikit-Learn. (That‚Äôs an admittedly
    naive assumption, so check my work please! üòÇ)
  prefs: []
  type: TYPE_NORMAL
- en: Concluding Thoughts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally speaking, I really liked what I saw with Polars. We consistently saw
    speedier performance from Polars, and while this was a relatively trivial use
    case, I can imagine those performance gains can be significantly appreciated at
    scale. I also really liked other things like how they display the data types of
    each feature when displaying the data using a function like `head()`. It‚Äôs little
    things like that are way more appreciated by people like me than one might expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, I can‚Äôt recommend Polars in its current state for a ‚Äúprime time‚Äù
    machine learning production scenario. (Reminder: The most recent version at the
    time of this publication is 0.16.10). The hiccups I saw with the `cut()` function
    and inability to integrate with Category Encoders or Scikit-Learn‚Äôs Random Forest
    Classifier are unfortunately deal breakers for me. I imagine this hurdle exists
    with many other libraries accustomed to Pandas today.'
  prefs: []
  type: TYPE_NORMAL
- en: If I were a more pure data analyst not doing machine learning, maybe Polars
    could pass in that particular context. It seems like where Polars gets into the
    most trouble for now is when it tries to integrate with other libraries. (Which,
    of course, is not Polars‚Äô fault!) I can see where a data analyst might use Polars
    and nothing else, and in that case, be careful and go for it. (Be careful not
    to get `cut()`! üòÇ)
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the day, I simply appreciate how good folks out there are dedicated
    to making something that was already good even better. When Numpy and Pandas were
    originally introduced, the performance gain over vanilla Python was staggering,
    so much so that it seemed as if it couldn‚Äôt get any better than that. And then
    along comes Polars and demonstrates to us that we can do even better. That‚Äôs just
    awesome. Thank you, Polars team, for your hard work, and I look forward to seeing
    how Polars evolves! üêª‚Äç‚ùÑÔ∏è
  prefs: []
  type: TYPE_NORMAL
