- en: An Introduction to Polars for Pandas Users
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 《Pandas 用户的 Polars 介绍》
- en: 原文：[https://towardsdatascience.com/an-introduction-to-polars-for-pandas-users-2a52b2a03017](https://towardsdatascience.com/an-introduction-to-polars-for-pandas-users-2a52b2a03017)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/an-introduction-to-polars-for-pandas-users-2a52b2a03017](https://towardsdatascience.com/an-introduction-to-polars-for-pandas-users-2a52b2a03017)
- en: Demonstrating how to use the new blazing fast DataFrame library for interacting
    with tabular data
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展示如何使用这个全新的、极速的 DataFrame 库与表格数据进行交互
- en: '[](https://dkhundley.medium.com/?source=post_page-----2a52b2a03017--------------------------------)[![David
    Hundley](../Images/1779ef96ec3d338f8fe4a9567ba7b194.png)](https://dkhundley.medium.com/?source=post_page-----2a52b2a03017--------------------------------)[](https://towardsdatascience.com/?source=post_page-----2a52b2a03017--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----2a52b2a03017--------------------------------)
    [David Hundley](https://dkhundley.medium.com/?source=post_page-----2a52b2a03017--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://dkhundley.medium.com/?source=post_page-----2a52b2a03017--------------------------------)[![David
    Hundley](../Images/1779ef96ec3d338f8fe4a9567ba7b194.png)](https://dkhundley.medium.com/?source=post_page-----2a52b2a03017--------------------------------)[](https://towardsdatascience.com/?source=post_page-----2a52b2a03017--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----2a52b2a03017--------------------------------)
    [David Hundley](https://dkhundley.medium.com/?source=post_page-----2a52b2a03017--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----2a52b2a03017--------------------------------)
    ·17 min read·Mar 5, 2023
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·发表于 [Towards Data Science](https://towardsdatascience.com/?source=post_page-----2a52b2a03017--------------------------------)
    ·17 min 阅读·2023年3月5日
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/703b01459d9d9be0836f9fc0c45e973d.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/703b01459d9d9be0836f9fc0c45e973d.png)'
- en: Title card created by the author
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 标题卡由作者创建
- en: If you’re like me, you may be hearing a lot of hype about this new [Polars](https://www.pola.rs)
    library but are not sure what it is or how to get started. If you’re totally new
    to it, the simplest way to understand Polars is that it is a very fast alternative
    to the more traditional Pandas DataFrame library. We’ll be focusing on the Python
    implementation of Polars for this post, but be aware it is also written to work
    with the growingly popular Rust language.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像我一样，可能会听到很多关于这个新 [Polars](https://www.pola.rs) 库的宣传，但不确定它是什么或如何开始使用。如果你完全陌生，理解
    Polars 最简单的方式是，它是一个比传统的 Pandas DataFrame 库更快的替代品。本文将专注于 Polars 的 Python 实现，但请注意，它也可以与越来越流行的
    Rust 语言一起使用。
- en: 'Before proceeding, let me be the first to address the cautious optimism I have
    with any new software like this. There’s always this big question: “Will this
    become mainstream?” I’ve unfortunately seen too many times where a really cool
    piece of software got a lot of hype in the beginning only to fade away later on.
    In regards to Polars, I think it is way too soon to make that determination for
    the long term, but I will give an assessment on my personal thoughts about Polars
    at the end of this post.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我首先表达我对任何新软件的谨慎乐观态度。总是有一个大问题：“这会变得主流吗？”不幸的是，我已经见证了太多次一款很酷的软件在最初引起了大量关注，但后来却逐渐消失。关于
    Polars，我认为现在做出长期的判断为时尚早，但我将在本文的末尾提供我对 Polars 的个人看法。
- en: This introductory guide is specifically written for people who are already familiar
    with the Pandas library, and I will be doing a direct compare / contrast of the
    Polars versus Pandas syntax and performance. If you would like to follow along
    more seamlessly, [please find my code here in GitHub](https://github.com/dkhundley/ds-quick-tips/blob/master/016_intro_to_polars/intro_to_polars.ipynb).
    For demonstration purposes, we will be making use of the [classic Titanic dataset](https://www.tensorflow.org/datasets/catalog/titanic).
    Also for context around the performance metrics I’ll be showing, I am performing
    all this work on a standard 2021 MacBook Pro with M1 Pro chip. (I did also test
    this on a Microsoft Surface Pro 9 running Windows 11 and can confirm it all worked
    there similarly.)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本介绍指南专门为那些已经熟悉 Pandas 库的人编写，我将直接比较 Polars 和 Pandas 的语法和性能。如果你希望更顺畅地跟随，请 [在 GitHub
    上查找我的代码](https://github.com/dkhundley/ds-quick-tips/blob/master/016_intro_to_polars/intro_to_polars.ipynb)。为了演示的目的，我们将使用
    [经典的 Titanic 数据集](https://www.tensorflow.org/datasets/catalog/titanic)。另外，为了说明我展示的性能指标，我将在一台标准的
    2021 年 MacBook Pro M1 Pro 芯片上进行所有操作。（我还在运行 Windows 11 的 Microsoft Surface Pro
    9 上进行了测试，并确认它的表现类似。）
- en: 'One final note before jumping into the bulk of this post: Polars is still VERY
    early in its lifecycle, so don’t be surprised if even 6 months from now contents
    of this post are outdated.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入文章主体之前的最后一点说明：Polars 仍处于非常早期的生命周期阶段，所以即使 6 个月后，本文的内容也可能已经过时，不要感到惊讶。
- en: Okay, let’s jump into exploring Polars! 🐻‍❄️
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们开始探索 Polars 吧！ 🐻‍❄️
- en: Installation
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装
- en: Fortunately, installing Polars is very easy. You can install Polars as you would
    any other Python library. Here is the specific command you can use to install
    Polars from PyPI.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，安装 Polars 非常简单。你可以像安装其他 Python 库一样安装 Polars。这里是从 PyPI 安装 Polars 的具体命令。
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: At times throughout this guide, we will have to make some translations back
    and forth between Pandas and Polars. (Yes, this is not ideal and something I would
    prefer to avoid, but for the time being, this is the only way around some issues
    I ran into.) In order to do this, you will also need to install the PyArrow Python
    libary. Similar to installing Polars, we can run the following command to install
    PyArrow from PyPI.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本指南的过程中，我们有时需要在 Pandas 和 Polars 之间进行一些转换。（是的，这并不理想，我更愿意避免这种情况，但目前，这是解决我遇到的一些问题的唯一方法。）为此，你还需要安装
    PyArrow Python 库。与安装 Polars 类似，我们可以运行以下命令从 PyPI 安装 PyArrow。
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This last installation step is optional, but you may find it useful for future
    work. As mentioned in the introduction, I intend to demonstrate the performance
    of Pandas compared to Polars, and doing this work in a Jupyter notebook, we could
    run the Jupyter magic command `%% time` to output the runtime of each specific
    cell. This can naturally become very tedious to type, and fortunately, we can
    install a special Jupyter extension that will automatedly display the runtime
    of each cell in a tiny line of text below each run cell. In order to do that,
    we’ll need to run the following 3 commands in your CLI.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的安装步骤是可选的，但你可能会发现它对未来的工作很有用。正如介绍中提到的，我打算演示 Pandas 与 Polars 的性能对比，而在 Jupyter
    notebook 中进行这项工作时，我们可以运行 Jupyter 魔法命令`%% time`来输出每个特定单元格的运行时间。这自然会变得非常繁琐，幸运的是，我们可以安装一个特殊的
    Jupyter 扩展，它会在每个运行的单元格下方自动显示一个小文本行来显示运行时间。为此，我们需要在你的 CLI 中运行以下 3 个命令。
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What the commands above enable is a new toggle in the Jupyter user interface
    that will properly display the runtime for each cell run. To enable this in the
    Jupyter notebook inferface, navigate to `Cell > Execution Timings` and select
    `Toggle Visibility (all)`. The screenshot below also demonstrates this appropriately.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令所启用的是 Jupyter 用户界面中的一个新切换按钮，它可以正确显示每个单元格运行的运行时间。要在 Jupyter notebook 界面中启用此功能，导航到
    `Cell > Execution Timings` 并选择 `Toggle Visibility (all)`。下面的截图也恰当地演示了这一点。
- en: '![](../Images/d994115ff6980b9841e5028199f2f595.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d994115ff6980b9841e5028199f2f595.png)'
- en: Screenshot captured by the author
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 作者捕捉的截图
- en: Getting Started
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用
- en: In this first section, we’ll demonstrate a few common commands that many data
    scientists and machine learning engineers prefer to run at the outset of working
    with any new dataset. As a reminder, we will be working with the Titanic dataset,
    which I have already saved to my local computer as a CSV file in an adjacent directory.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将展示一些常见命令，许多数据科学家和机器学习工程师在处理任何新数据集时都喜欢先运行这些命令。作为提醒，我们将使用 Titanic 数据集，我已经将其保存为
    CSV 文件在一个相邻的目录中。
- en: Importing Pandas and Polars
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入 Pandas 和 Polars
- en: Of course, the first thing we’ll want to do is to import each of the respective
    Python libraries appropriately. As Pandas users are aware, Pandas is almost aliased
    as `pd` when imported. Likewise, Polars is also often aliased with the two letters
    `pl`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们首先需要适当地导入各自的 Python 库。正如 Pandas 用户所知道的，Pandas 在导入时几乎被别名为 `pd`。同样，Polars
    也通常用两个字母 `pl` 作为别名。
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Loading Data from a CSV File
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 CSV 文件加载数据
- en: Throughout this post, you’ll find that Polars and Pandas can sometimes have
    very different ways of doing things and other times the syntax will be the exact
    same. Fortunately, this first instance is the exact same from Pandas to Polars.
    Here is the code demonstrating that similarity.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇文章中，你会发现 Polars 和 Pandas 有时在做事情的方式上会非常不同，而有时语法则完全相同。幸运的是，这第一次示例中从 Pandas
    到 Polars 的语法是完全相同的。下面的代码展示了这种相似性。
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Before proceeding forward, let’s start talking about the performance of these
    libraries. As you can see in the screenshot below, the Polars load was 1 millisecond
    faster than the Pandas load. Transparently, I got different results each time
    I ran these cells, but I can say that Polars was consistently faster. This will
    be a recurring theme throughout this whole post.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a81ee9ee2adf7aa1ef5a518cd505c450.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: Screenshot captured by the author
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the First Rows of Each DataFrame
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Immediately after loading a CSV, the first thing I like to do is view the first
    few rows of the DataFrame just to get a sense of what I’m working with. From a
    syntax perspective, Pandas users will immediately find themselves at home with
    Polars’ implementation as its the exact same.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: While the syntax is the same, the output is interestingly different between
    Pandas and Polars, and for the most part, I actually really like how Polars displays
    the output here. As you can see below, Polars displays the data type of each respective
    feature directly below the name of each feature. Moreover, the syntax of string-based
    columns shows the values wrapped in double quotes. I personally really love this
    because Pandas isn’t overtly clear about the data types of each column, especially
    when it comes to strings. The only odd quirk about Polars is that it doesn’t display
    the index values of each row off to the left as Pandas does. To be clear, the
    index values are still intact; they just aren’t displayed in this view. (Also
    notice that Polars ran twice as fast as Pandas in this instance.)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/77491e9e6f6e522038c99211c9ed321e.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: Screenshot captured by the author
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Viewing Information about the DataFrame
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, the syntax of both libraries has been the same, but we now come to
    the point where they begin to radically diverge in functionality. Pandas users
    will be familiar with two functions that each show respective information about
    the DataFrame: `info()` and `describe()`. `info()` shows things like the feature
    names, data types, and null values, while `describe()` shows general statistics
    associated to each feature like mean and standard deviation. Here is the Pandas
    code and a screenshot of the output of each respective function.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![](../Images/7257c3eeb2171b3849283f789eb764f0.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
- en: Screenshot captured by the author
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Polars takes a very different turn from Pandas in this regard. For starters,
    there is no `info()` command. Instead, it takes the `describe()` command and more
    or less mashes the outputs we’re used to seeing across Pandas’ `info()` and `describe()`
    functions into a single output. Below is what that looks like.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](../Images/17664d4ae512f1016ed06d2128f64a1b.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: Screenshot captured by the author
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: To be honest, I don’t know how I feel about this implementation. On one hand,
    I think the Polars output makes it clearer how many nulls there are since you
    have to do a bit of mental math to understand how many nulls there are in the
    Pandas output. But on the other hand, Polars loses information provided by Pandas
    like the interquartile range values. Notice also that in the Pandas `describe()`
    output, it rightfully excludes string-based columns whereas Polars keeps them
    in there. I typically wouldn’t care, but if you look at the “min” and “max” values
    for the “Sex” feature, for example, it gives some… well… unsavory results!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，我对这个实现的感受有些复杂。一方面，我认为 Polars 的输出更清楚地显示了空值的数量，因为你需要做一点心理数学来理解 Pandas 输出中的空值数量。但另一方面，Polars
    丢失了 Pandas 提供的信息，如四分位数范围值。还要注意，在 Pandas 的 `describe()` 输出中，它合理地排除了基于字符串的列，而 Polars
    仍然保留它们。我通常不会在意，但如果你看看“性别”特征的“最小”和“最大”值，例如，它给出了一些……嗯……不太令人愉快的结果！
- en: Displaying the Value Counts of a Specific Feature
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示特定特征的值计数
- en: Another thing I like to do when first getting started with a dataset using categorical
    data is to look at the value counts associated to each categorical feature. Fortunately,
    we’re back to a similar syntax that Pandas users will be familiar with, except
    you’ll notice the output is a little different.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件我喜欢在开始使用分类数据集时做的事情是查看每个分类特征的值计数。幸运的是，我们回到了 Pandas 用户会熟悉的类似语法，只是你会注意到输出略有不同。
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![](../Images/220da36c5be2321c116817c435d79ce2.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/220da36c5be2321c116817c435d79ce2.png)'
- en: Screenshot captured by the author
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 作者截图
- en: As you can see, the Polars output is actually a little more informative because
    it includes the number of null values whereas the Pandas output doesn’t talk about
    the null values at all. This is one instance where I have to give Polars a clean
    win. This is really handy!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Polars 的输出实际上更具信息性，因为它包含了空值的数量，而 Pandas 的输出完全没有提到空值。这是一个我必须承认 Polars
    绝对胜出的例子。这真的很方便！
- en: Data Wrangling
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据整理
- en: Now that we’ve explored some very preliminary commands, let’s move into some
    more complex functionality with data wrangling. We’ll explore a few common wrangling
    tactics in this section and continue our comparison between Pandas and Polars
    along the way.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探索了一些非常初步的命令，让我们进入数据整理的更复杂功能。在本节中，我们将探讨一些常见的整理策略，并继续比较 Pandas 和 Polars。
- en: Getting a Slice of the DataFrame
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取 DataFrame 的切片
- en: Remember how I mentioned that it was odd that Polars doesn’t show the index
    values for each row in the `head()` output but that they are still there? We can
    prove that here by demonstrating how to get a slice of each DataFrame. Fortunately,
    the syntax and output for Polars and Pandas is the exact same here. Also, doing
    a quick check in on our performance metrics, notice how Polars executed this slicing
    twice as fast as Pandas.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我提到过 Polars 在 `head()` 输出中没有显示每行的索引值，但它们仍然存在吗？我们可以通过演示如何获取每个 DataFrame 的切片来证明这一点。幸运的是，Polars
    和 Pandas 的语法和输出在这里完全相同。此外，快速查看我们的性能指标，注意到 Polars 执行切片的速度是 Pandas 的两倍。
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![](../Images/5a9d0db740d6c18e987436ad631640cd.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5a9d0db740d6c18e987436ad631640cd.png)'
- en: Screenshot captured by the author
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 作者截图
- en: Filtering the DataFrame by Feature Values
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按特征值过滤 DataFrame
- en: Of everything we’ll be demonstrating in this post, this is the area in which
    we can perform similar functionality in many different ways. I’m not going to
    attempt to demonstrate all of them, so I chose the following way to show that
    Polars can emulate similar functionality to Pandas but with syntax that is just
    a little bit different. Below is the code to pull out all rows representing teenagers
    on the Titanic. (The output is a bit long since there are 95 teenagers, so I won’t
    show the output. Just know that the output is indeed the same.)
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将在这篇文章中展示的所有内容中，这是我们可以以多种不同方式执行相似功能的领域。我不会尝试演示所有方法，因此我选择了以下方式来展示 Polars 如何以略有不同的语法模拟
    Pandas 的相似功能。下面是提取所有代表泰坦尼克号上青少年的行的代码。（由于有 95 名青少年，输出有点长，因此我不会显示输出。只需知道输出确实是相同的。）
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Again, there are several different ways we could achieve the same results in
    Pandas and Polars with different syntax. The one thing I do want to highlight
    is that [the official Polars documentation](https://pola-rs.github.io/polars/py-polars/html/reference/dataframe/api/polars.DataFrame.filter.html#polars.DataFrame.filter)
    demonstrates what I did above using what I perceive as an odd choice of syntax.
    Where I use `df_polars[''Age'']` to reference the “Age” column in the Polars DataFrame,
    the official documentation instead recommends using this syntax: `pl.col(''Age'')`.
    The output is the exact same, so it’s not as if either is wrong. You would think
    that Polars would want to demonstrate things as closely as possible to Pandas
    since most people using Polars will be Pandas users, and as I successfully demonstrated,
    the class choice of `df_polars[''Age'']` worked just fine. This actually occurs
    quite a bit in the Polars documentation, so be aware that though the documentation
    may say one thing, you might be able to get away with a more classic syntax you’re
    already used to.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以通过不同的语法在 Pandas 和 Polars 中实现相同的结果。我想强调的是，[官方 Polars 文档](https://pola-rs.github.io/polars/py-polars/html/reference/dataframe/api/polars.DataFrame.filter.html#polars.DataFrame.filter)演示了我上面做的事情，使用了我认为比较奇怪的语法。当我使用`df_polars['Age']`来引用
    Polars DataFrame 中的“Age”列时，官方文档推荐使用这种语法：`pl.col('Age')`。输出是完全相同的，所以说哪一种都是对的也未必。你会觉得
    Polars 应该尽可能地展示与 Pandas 类似的内容，因为大多数使用 Polars 的人都是 Pandas 用户，正如我成功展示的那样，`df_polars['Age']`的类选择效果很好。这在
    Polars 文档中实际上很常见，因此请注意，尽管文档可能说一回事，但你可能可以使用你已经熟悉的更经典的语法。
- en: Filling Null Values
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 填充 Null 值
- en: Thus far, our experience with Polars has ranged from neutral to positive. With
    this particular piece of functionality, we unfortunately begin to stray into some
    negative territory. Filling a column with null values is relatively straightforward
    in Pandas, and we can even apply this filling directly in place with the `inplace`
    parameter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们对 Polars 的体验从中性到积极。遗憾的是，在这个特定的功能上，我们开始进入一些负面领域。在 Pandas 中，用 null 值填充一列是相对简单的，我们甚至可以直接使用`inplace`参数来完成填充。
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Polars unfortunately is a bit odd here. First, there is no equivalent of the
    `inplace` parameter, and this is actually a recurring theme throughout Polars
    as we’ll see again later in the post. Moreover, Polars actually has two different
    functions for filling null values: `fill_null()` and `fill_nan()`. Looking at
    the documentation for each, I honestly can’t tell you why you would choose one
    over the other. (Of course, this could very well be my own ignorance.) In the
    code block below, I make use of the `fill_null()` function to the same effect
    as Pandas’ `fillna()`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Polars 在这里有点奇怪。首先，没有`inplace`参数的等效项，这实际上是 Polars 中一个反复出现的主题，我们稍后会再次看到。此外，Polars
    实际上有两个不同的填充 null 值的函数：`fill_null()`和`fill_nan()`。查看每个函数的文档，我诚实地告诉你我不明白为什么选择其中一个而不是另一个。（当然，这可能是我自己的无知。）在下面的代码块中，我使用了`fill_null()`函数，其效果与
    Pandas 的`fillna()`相同。
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Grouping Data by Feature Names
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按特征名称分组数据
- en: In order to get a deeper understanding of the data, it is very common for data
    practitioners to group data together to understand how groups of data may share
    new insights with us. Pandas users will be very familiar with the `groupby()`
    function in this regard. Unfortunately, Polars also does have a `groupby()` function,
    but its output is very different. Pandas users will find this difference to be
    jarring, and I transparently could not find a way to emulate the Pandas output
    using a different Polars syntax. (Granted, I admittedly didn’t try very hard.
    😅) See below how the same syntax produces very different results across each library.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更深入地理解数据，数据从业者通常会将数据分组以了解数据组可能带来的新见解。在这方面，Pandas 用户会非常熟悉`groupby()`函数。不幸的是，Polars
    确实也有一个`groupby()`函数，但它的输出却大相径庭。Pandas 用户会发现这种差异很突兀，我坦率地说没有找到使用不同 Polars 语法来模拟
    Pandas 输出的方法。（当然，我承认我没有尝试得很认真。😅）见下文，如何用相同的语法在每个库中产生截然不同的结果。
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![](../Images/787392a5661e492c2433c0acafb38a14.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/787392a5661e492c2433c0acafb38a14.png)'
- en: Screenshot captured by the author
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 作者截图
- en: Feature Engineering
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特征工程
- en: While feature engineering could certainly be considered a type of data wrangling,
    I decided to separate this into its own respective section as it correlates to
    other work I’ve done in the past. As part of [this notebook on GitHub](https://github.com/dkhundley/titanic-byoc/blob/main/notebooks/feature-engineering.ipynb),
    I demonstrated how one might perform feature engineering on the Titanic dataset.
    We won’t be covering every bit of feature engineering in this section, but we’ll
    demonstrate a few things so you can get a sense of how this same work compares
    in Pandas and Polars. We’ll start fresh again by reloading each DataFrame from
    scratch with this code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然特征工程确实可以被视为数据处理的一种类型，但我决定将其分开成独立的部分，因为它与我过去做的其他工作相关。作为 [GitHub 上这个笔记本](https://github.com/dkhundley/titanic-byoc/blob/main/notebooks/feature-engineering.ipynb)
    的一部分，我展示了如何对 Titanic 数据集进行特征工程。我们不会在这一部分覆盖每一个特征工程，但我们会展示一些内容，以便你可以了解这些相同的工作在 Pandas
    和 Polars 中的比较。我们将通过使用以下代码从头开始重新加载每个 DataFrame 来重新开始。
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Dropping Unnecessary Features
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除不必要的特征
- en: In almost every dataset you’ll work with, you’ll find features that are irrelevant
    and need dropped before passing into any machine learning algorithm. While this
    is not difficult to do in Polars, recall that Polars functions do not have a similar
    `inplace` parameter that would allow us to update the Polars DataFrame in place.
    Here is the syntax for dropping features in both libraries.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎所有你会处理的数据集中，你都会发现一些无关的特征，这些特征在传递给任何机器学习算法之前需要被删除。虽然在 Polars 中这并不困难，但请记住，Polars
    的函数没有类似 `inplace` 参数，这样我们就无法就地更新 Polars DataFrame。下面是两种库中删除特征的语法。
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: One-Hot Encoding Categorical Features
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对分类特征进行独热编码
- en: Remember at the beginning when I mentioned we’d have to install PyArrow to translate
    our Polars DataFrame into a Pandas DataFrame? Well, here is our first instance
    of why we have to do that. I personally prefer to use [Category Encoder’s implementation
    of one-hot encoding](https://contrib.scikit-learn.org/category_encoders/onehot.html)
    for my one-hot encoding work. For context, here’s how you would import that after
    installing it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我最开始提到我们必须安装 PyArrow 以将我们的 Polars DataFrame 转换为 Pandas DataFrame 吗？好吧，这就是我们必须这么做的第一个实例。我个人更喜欢使用
    [Category Encoder 的独热编码实现](https://contrib.scikit-learn.org/category_encoders/onehot.html)
    来进行独热编码。为了说明，这里是安装后如何导入它。
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If we were to perform one-hot encoding on the “Sex” (aka gender) feature using
    Pandas, here is what the syntax would look like.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 Pandas 对“性别”（即性别）特征进行独热编码，以下是语法示例。
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Unfortunately, Category Encoder’s `OneHotEncoder` isn’t set up to work with
    Polars. If we were to run the following line as is, we’d see the error in the
    screenshot below it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Category Encoder 的 `OneHotEncoder` 并未设置为与 Polars 一起使用。如果我们直接运行以下代码，我们会看到下面截图中的错误。
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![](../Images/2f75467a70dbf45a14f5592e0f666ca0.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2f75467a70dbf45a14f5592e0f666ca0.png)'
- en: Screenshot captured by the author
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 作者截图
- en: There is a workaround for this, but unfortunately this will not be the first
    time we’ll run into a breaking issue like this. Below is the full workaround for
    using Polars to perform a one-hot encoding. Notice that prior to fitting the Polars
    DataFrame to the `OneHotEncoder` object, we will first have to translate it into
    a Pandas DataFrame. Then after the conversion, we can simply translate it back
    into a Polars DataFrame.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种解决方法，但不幸的是，这不会是我们第一次遇到类似的破坏性问题。下面是使用 Polars 执行独热编码的完整解决方法。请注意，在将 Polars DataFrame
    拟合到 `OneHotEncoder` 对象之前，我们首先需要将其转换为 Pandas DataFrame。然后在转换后，我们可以简单地将其转换回 Polars
    DataFrame。
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Finally, note that Polars’ implementation of the `concat()` function is just
    a little bit different from Pandas. Where Pandas uses the `axis` parameter to
    indicate how to perform the concatenation, Polars uses `how` and string-based
    values instead. I personally prefer how Polars implemented this here.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，Polars 的 `concat()` 函数的实现与 Pandas 有些不同。Pandas 使用 `axis` 参数来指示如何执行连接，而
    Polars 则使用 `how` 和基于字符串的值。我个人更喜欢 Polars 在这里的实现。
- en: Binning Numerical Data
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数值数据分箱
- en: The way in which I chose to perform to feature engineer the “Age” feature was
    by binning it into appropriate age groups. For example, people aged 13 to 19 would
    be classified as teenagers whereas anybody over age 60 was considered an elder.
    Pandas has a very nice function called `cut()` that does this binning appropriately
    per the inputs you provide it. Here is the syntax for doing just that.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择执行“年龄”特征工程的方式是将其分箱为适当的年龄组。例如，13至19岁的人被分类为青少年，而60岁以上的人被认为是老年人。Pandas有一个非常好的函数叫做`cut()`，可以根据你提供的输入正确地进行分箱。这是执行此操作的语法。
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Polars does offer its own implementation of `cut()`, but its output is radically
    different than Pandas to the point where I personally find it unusable. Here is
    the syntax and output of that code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Polars确实提供了自己实现的`cut()`函数，但其输出与Pandas的差异非常大，以至于我个人觉得无法使用。这是该代码的语法和输出。
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![](../Images/dc0c1a4929db2da4a03c4721c8ef94ed.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/dc0c1a4929db2da4a03c4721c8ef94ed.png)'
- en: Screenshot captured by the author
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 作者捕获的截图
- en: Looking at the output, it actually does appear that the binning worked, but
    it did a few weird things. First, it wouldn’t take my semantic names established
    by the `bin_labels` array. Second, it didn’t preserve the order of the rows as
    they were passed into the function. Instead, you can see that the Polars output
    has now sorted by the values in ascending order starting with the lowest value
    (aka the youngest age). I’m sure I could find a workaround for the first issue,
    but second issue renders this output useless for me. The temptation would be to
    match the ages to the original DataFrame, but as you can see in this simple output,
    lines 4 and 5 have the same `0.75` value. While this might be fine in this particular
    use case, this practice could be dangerous for a different dataset.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 看输出结果，实际上看起来分箱操作确实有效，但它做了一些奇怪的事情。首先，它没有使用我通过`bin_labels`数组建立的语义名称。其次，它没有保持传入函数的行顺序。相反，你可以看到Polars的输出现在已经按照从最低值（即最年轻的年龄）开始的升序排序。我相信我可以找到第一个问题的解决方法，但第二个问题使得这个输出对我来说毫无用处。诱惑是将年龄与原始DataFrame匹配，但正如你在这个简单的输出中看到的，行4和行5有相同的`0.75`值。虽然在这个特定用例中可能没问题，但这种做法对不同的数据集可能是危险的。
- en: '(Note: As I was drafting this post, I upgraded from Polars 0.16.8 to 0.16.10,
    in which the Polars `cut()` function is now being deprecated in favor of using
    the Polars Series implementation of `cut()`. It doesn’t seem that this new implementation
    fixes the issue, and at the time of this publication, [a GitHub issue](https://github.com/pola-rs/polars/issues/4286)
    has been noted requesting to add the row index preservation. In general, this
    is a good reminder that Polars in an early state!)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: （注：在我草拟这篇文章时，我从Polars 0.16.8升级到0.16.10，在这个版本中，Polars的`cut()`函数现在被弃用，取而代之的是使用Polars
    Series实现的`cut()`。似乎这个新实现没有解决问题，在发布时，[一个GitHub问题](https://github.com/pola-rs/polars/issues/4286)已被指出请求添加行索引保留。一般来说，这是一个很好的提醒，Polars仍处于早期阶段！）
- en: Predictive Modeling with Machine Learning
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器学习中的预测建模
- en: This final section will be brief because, unfortunately, this is where Polars
    ultimately falls flat for me, at least at the point when this post is published.
    Similarly to how I created a Jupyter notebook for feature engineering in a previous
    Titanic project, I will attempt to emulate the same steps I completed in [my original
    Titanic predictive modeling notebook](https://github.com/dkhundley/titanic-byoc/blob/main/notebooks/predictive-modeling.ipynb).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的部分将简要介绍，因为不幸的是，这是Polars最终对我来说表现不佳的地方，至少在发布这篇文章的时候是这样。类似于我在之前的Titanic项目中为特征工程创建Jupyter笔记本的方式，我将尝试模拟在[我原来的Titanic预测建模笔记本](https://github.com/dkhundley/titanic-byoc/blob/main/notebooks/predictive-modeling.ipynb)中完成的相同步骤。
- en: Performing a Train-Test Split
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行训练-测试拆分
- en: The hallmark of any good machine learning practice, the code below demonstrates
    how to perform a train-test (or train-validation) split to have holdout set to
    later use for model validation. Since we’ll be making use of Scikit-Learn’s `train_test_split`
    function, there’s not much to note here since the syntax is the exact same for
    both the Pandas and Polars DataFrames. I suppose I just wanted to highlight that
    this works with Polars out of the box today without any special workarounds. 😃
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 任何良好的机器学习实践的标志，下面的代码演示了如何进行训练-测试（或训练-验证）拆分，以保留数据集用于后续模型验证。由于我们将使用Scikit-Learn的`train_test_split`函数，这里没有太多需要注意的，因为Pandas和Polars
    DataFrames的语法完全相同。我只是想强调，今天这在Polars中开箱即用，无需任何特殊的解决方法。 😃
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Performing Predictive Modeling
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行预测建模
- en: We finally come to the point where Polars unfortunately falls off the rails.
    In the code below, I demonstrate how you would fit the Pandas DataFrames to Scikit-Learn’s
    Random Forest Classifier, which should produce the output in that nice blue box.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于来到了 Polars 不幸出错的地方。在下面的代码中，我演示了如何将 Pandas DataFrames 适配到 Scikit-Learn 的随机森林分类器，这应该会在那个漂亮的蓝色框中产生输出。
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![](../Images/cf94b6c20626534769b49c6d1e7848ce.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/cf94b6c20626534769b49c6d1e7848ce.png)'
- en: Screenshot captured by the author
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 作者捕获的截图
- en: Unfortunately, I hit a brick wall when attempting to do this same thing with
    the Polars DataFrame. When I attempt to run the code block below, I get the error
    you see in the screenshot below.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，当尝试用 Polars DataFrame 做同样的事情时，我遇到了瓶颈。当我尝试运行下面的代码块时，我收到了下图中的错误。
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![](../Images/564dc0c090ee1d6eb0a650bdcad85558.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/564dc0c090ee1d6eb0a650bdcad85558.png)'
- en: Screenshot captured by the author
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 作者捕获的截图
- en: I spent a solid hour combing Scikit-Learn’s source code to understand what was
    going on here and am still not quite sure why it is not reading the Polars DataFrame’s
    shapes consistently as the Pandas DataFrames. When running commands like `df_polars.shape`
    and other similar ones, it consistently displays the same output as the correlative
    Pandas commands. It was definitely a head scratcher.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我花了一个小时仔细检查 Scikit-Learn 的源代码，以了解这里发生了什么，但仍然不太确定为什么它无法像 Pandas DataFrames 一样一致地读取
    Polars DataFrame 的形状。当运行像 `df_polars.shape` 这样的命令时，它始终显示与相关 Pandas 命令相同的输出。这确实让人困惑。
- en: Now transparently, Scikit-Learn was the only algorithmic library I tried for
    this experiment. You may experience different results with other algorithmic libraries
    like XGBoost or LightGBM, but I’m honestly inclined to believe that most — if
    not all — will have the same issue I saw with Scikit-Learn. (That’s an admittedly
    naive assumption, so check my work please! 😂)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在透明地说，Scikit-Learn 是我为此实验尝试的唯一算法库。你可能会在其他算法库如 XGBoost 或 LightGBM 中遇到不同的结果，但老实说，我倾向于相信大多数
    — 如果不是全部的话 — 都会有与 Scikit-Learn 相同的问题。（这是一个坦率的天真假设，所以请检查我的工作！😂）
- en: Concluding Thoughts
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: Generally speaking, I really liked what I saw with Polars. We consistently saw
    speedier performance from Polars, and while this was a relatively trivial use
    case, I can imagine those performance gains can be significantly appreciated at
    scale. I also really liked other things like how they display the data types of
    each feature when displaying the data using a function like `head()`. It’s little
    things like that are way more appreciated by people like me than one might expect.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，我对 Polars 的表现非常满意。我们 consistently 看到 Polars 的性能更快，虽然这是一个相对简单的用例，但我可以想象这些性能提升在大规模应用时会显著感受到。我也非常喜欢其他功能，比如使用
    `head()` 函数时显示每个特征的数据类型。像这样的细节比预期的更受我们这些人喜欢。
- en: 'Unfortunately, I can’t recommend Polars in its current state for a “prime time”
    machine learning production scenario. (Reminder: The most recent version at the
    time of this publication is 0.16.10). The hiccups I saw with the `cut()` function
    and inability to integrate with Category Encoders or Scikit-Learn’s Random Forest
    Classifier are unfortunately deal breakers for me. I imagine this hurdle exists
    with many other libraries accustomed to Pandas today.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，基于目前的状态，我无法推荐 Polars 用于“黄金时间”的机器学习生产场景。（提醒：截至本出版时，最新版本为 0.16.10）。我发现的 `cut()`
    函数问题以及无法与 Category Encoders 或 Scikit-Learn 的随机森林分类器集成对我来说都是无法接受的。我想这种障碍在现在习惯使用
    Pandas 的许多其他库中也存在。
- en: If I were a more pure data analyst not doing machine learning, maybe Polars
    could pass in that particular context. It seems like where Polars gets into the
    most trouble for now is when it tries to integrate with other libraries. (Which,
    of course, is not Polars’ fault!) I can see where a data analyst might use Polars
    and nothing else, and in that case, be careful and go for it. (Be careful not
    to get `cut()`! 😂)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我是一名纯粹的数据分析师，而不是进行机器学习，或许 Polars 可以在那个特定的环境下使用。目前，Polars 遇到的最大麻烦似乎是在尝试与其他库集成时。（这当然不是
    Polars 的错！）我能理解数据分析师可能只使用 Polars 而没有其他库，在这种情况下，请小心使用。（小心不要被 `cut()` 陷阱困住！😂）
- en: At the end of the day, I simply appreciate how good folks out there are dedicated
    to making something that was already good even better. When Numpy and Pandas were
    originally introduced, the performance gain over vanilla Python was staggering,
    so much so that it seemed as if it couldn’t get any better than that. And then
    along comes Polars and demonstrates to us that we can do even better. That’s just
    awesome. Thank you, Polars team, for your hard work, and I look forward to seeing
    how Polars evolves! 🐻‍❄️
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 到头来，我只是非常感激那些优秀的人们致力于让已经很好的东西变得更好。当Numpy和Pandas最初推出时，相比于普通的Python，其性能提升是令人惊叹的，甚至让人觉得再也无法更好。然而，Polars的出现向我们展示了我们可以做得更好。这真是太棒了。感谢Polars团队的辛勤工作，我期待着看到Polars的发展！🐻‍❄️
