- en: An Introduction to Polars for Pandas Users
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ã€ŠPandas ç”¨æˆ·çš„ Polars ä»‹ç»ã€‹
- en: åŸæ–‡ï¼š[https://towardsdatascience.com/an-introduction-to-polars-for-pandas-users-2a52b2a03017](https://towardsdatascience.com/an-introduction-to-polars-for-pandas-users-2a52b2a03017)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://towardsdatascience.com/an-introduction-to-polars-for-pandas-users-2a52b2a03017](https://towardsdatascience.com/an-introduction-to-polars-for-pandas-users-2a52b2a03017)
- en: Demonstrating how to use the new blazing fast DataFrame library for interacting
    with tabular data
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å±•ç¤ºå¦‚ä½•ä½¿ç”¨è¿™ä¸ªå…¨æ–°çš„ã€æé€Ÿçš„ DataFrame åº“ä¸è¡¨æ ¼æ•°æ®è¿›è¡Œäº¤äº’
- en: '[](https://dkhundley.medium.com/?source=post_page-----2a52b2a03017--------------------------------)[![David
    Hundley](../Images/1779ef96ec3d338f8fe4a9567ba7b194.png)](https://dkhundley.medium.com/?source=post_page-----2a52b2a03017--------------------------------)[](https://towardsdatascience.com/?source=post_page-----2a52b2a03017--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----2a52b2a03017--------------------------------)
    [David Hundley](https://dkhundley.medium.com/?source=post_page-----2a52b2a03017--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://dkhundley.medium.com/?source=post_page-----2a52b2a03017--------------------------------)[![David
    Hundley](../Images/1779ef96ec3d338f8fe4a9567ba7b194.png)](https://dkhundley.medium.com/?source=post_page-----2a52b2a03017--------------------------------)[](https://towardsdatascience.com/?source=post_page-----2a52b2a03017--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----2a52b2a03017--------------------------------)
    [David Hundley](https://dkhundley.medium.com/?source=post_page-----2a52b2a03017--------------------------------)'
- en: Â·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----2a52b2a03017--------------------------------)
    Â·17 min readÂ·Mar 5, 2023
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Â·å‘è¡¨äº [Towards Data Science](https://towardsdatascience.com/?source=post_page-----2a52b2a03017--------------------------------)
    Â·17 min é˜…è¯»Â·2023å¹´3æœˆ5æ—¥
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/703b01459d9d9be0836f9fc0c45e973d.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/703b01459d9d9be0836f9fc0c45e973d.png)'
- en: Title card created by the author
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: æ ‡é¢˜å¡ç”±ä½œè€…åˆ›å»º
- en: If youâ€™re like me, you may be hearing a lot of hype about this new [Polars](https://www.pola.rs)
    library but are not sure what it is or how to get started. If youâ€™re totally new
    to it, the simplest way to understand Polars is that it is a very fast alternative
    to the more traditional Pandas DataFrame library. Weâ€™ll be focusing on the Python
    implementation of Polars for this post, but be aware it is also written to work
    with the growingly popular Rust language.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ åƒæˆ‘ä¸€æ ·ï¼Œå¯èƒ½ä¼šå¬åˆ°å¾ˆå¤šå…³äºè¿™ä¸ªæ–° [Polars](https://www.pola.rs) åº“çš„å®£ä¼ ï¼Œä½†ä¸ç¡®å®šå®ƒæ˜¯ä»€ä¹ˆæˆ–å¦‚ä½•å¼€å§‹ä½¿ç”¨ã€‚å¦‚æœä½ å®Œå…¨é™Œç”Ÿï¼Œç†è§£
    Polars æœ€ç®€å•çš„æ–¹å¼æ˜¯ï¼Œå®ƒæ˜¯ä¸€ä¸ªæ¯”ä¼ ç»Ÿçš„ Pandas DataFrame åº“æ›´å¿«çš„æ›¿ä»£å“ã€‚æœ¬æ–‡å°†ä¸“æ³¨äº Polars çš„ Python å®ç°ï¼Œä½†è¯·æ³¨æ„ï¼Œå®ƒä¹Ÿå¯ä»¥ä¸è¶Šæ¥è¶Šæµè¡Œçš„
    Rust è¯­è¨€ä¸€èµ·ä½¿ç”¨ã€‚
- en: 'Before proceeding, let me be the first to address the cautious optimism I have
    with any new software like this. Thereâ€™s always this big question: â€œWill this
    become mainstream?â€ Iâ€™ve unfortunately seen too many times where a really cool
    piece of software got a lot of hype in the beginning only to fade away later on.
    In regards to Polars, I think it is way too soon to make that determination for
    the long term, but I will give an assessment on my personal thoughts about Polars
    at the end of this post.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ç»§ç»­ä¹‹å‰ï¼Œè®©æˆ‘é¦–å…ˆè¡¨è¾¾æˆ‘å¯¹ä»»ä½•æ–°è½¯ä»¶çš„è°¨æ…ä¹è§‚æ€åº¦ã€‚æ€»æ˜¯æœ‰ä¸€ä¸ªå¤§é—®é¢˜ï¼šâ€œè¿™ä¼šå˜å¾—ä¸»æµå—ï¼Ÿâ€ä¸å¹¸çš„æ˜¯ï¼Œæˆ‘å·²ç»è§è¯äº†å¤ªå¤šæ¬¡ä¸€æ¬¾å¾ˆé…·çš„è½¯ä»¶åœ¨æœ€åˆå¼•èµ·äº†å¤§é‡å…³æ³¨ï¼Œä½†åæ¥å´é€æ¸æ¶ˆå¤±ã€‚å…³äº
    Polarsï¼Œæˆ‘è®¤ä¸ºç°åœ¨åšå‡ºé•¿æœŸçš„åˆ¤æ–­ä¸ºæ—¶å°šæ—©ï¼Œä½†æˆ‘å°†åœ¨æœ¬æ–‡çš„æœ«å°¾æä¾›æˆ‘å¯¹ Polars çš„ä¸ªäººçœ‹æ³•ã€‚
- en: This introductory guide is specifically written for people who are already familiar
    with the Pandas library, and I will be doing a direct compare / contrast of the
    Polars versus Pandas syntax and performance. If you would like to follow along
    more seamlessly, [please find my code here in GitHub](https://github.com/dkhundley/ds-quick-tips/blob/master/016_intro_to_polars/intro_to_polars.ipynb).
    For demonstration purposes, we will be making use of the [classic Titanic dataset](https://www.tensorflow.org/datasets/catalog/titanic).
    Also for context around the performance metrics Iâ€™ll be showing, I am performing
    all this work on a standard 2021 MacBook Pro with M1 Pro chip. (I did also test
    this on a Microsoft Surface Pro 9 running Windows 11 and can confirm it all worked
    there similarly.)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬ä»‹ç»æŒ‡å—ä¸“é—¨ä¸ºé‚£äº›å·²ç»ç†Ÿæ‚‰ Pandas åº“çš„äººç¼–å†™ï¼Œæˆ‘å°†ç›´æ¥æ¯”è¾ƒ Polars å’Œ Pandas çš„è¯­æ³•å’Œæ€§èƒ½ã€‚å¦‚æœä½ å¸Œæœ›æ›´é¡ºç•…åœ°è·Ÿéšï¼Œè¯· [åœ¨ GitHub
    ä¸ŠæŸ¥æ‰¾æˆ‘çš„ä»£ç ](https://github.com/dkhundley/ds-quick-tips/blob/master/016_intro_to_polars/intro_to_polars.ipynb)ã€‚ä¸ºäº†æ¼”ç¤ºçš„ç›®çš„ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨
    [ç»å…¸çš„ Titanic æ•°æ®é›†](https://www.tensorflow.org/datasets/catalog/titanic)ã€‚å¦å¤–ï¼Œä¸ºäº†è¯´æ˜æˆ‘å±•ç¤ºçš„æ€§èƒ½æŒ‡æ ‡ï¼Œæˆ‘å°†åœ¨ä¸€å°æ ‡å‡†çš„
    2021 å¹´ MacBook Pro M1 Pro èŠ¯ç‰‡ä¸Šè¿›è¡Œæ‰€æœ‰æ“ä½œã€‚ï¼ˆæˆ‘è¿˜åœ¨è¿è¡Œ Windows 11 çš„ Microsoft Surface Pro
    9 ä¸Šè¿›è¡Œäº†æµ‹è¯•ï¼Œå¹¶ç¡®è®¤å®ƒçš„è¡¨ç°ç±»ä¼¼ã€‚ï¼‰
- en: 'One final note before jumping into the bulk of this post: Polars is still VERY
    early in its lifecycle, so donâ€™t be surprised if even 6 months from now contents
    of this post are outdated.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ·±å…¥æ–‡ç« ä¸»ä½“ä¹‹å‰çš„æœ€åä¸€ç‚¹è¯´æ˜ï¼šPolars ä»å¤„äºéå¸¸æ—©æœŸçš„ç”Ÿå‘½å‘¨æœŸé˜¶æ®µï¼Œæ‰€ä»¥å³ä½¿ 6 ä¸ªæœˆåï¼Œæœ¬æ–‡çš„å†…å®¹ä¹Ÿå¯èƒ½å·²ç»è¿‡æ—¶ï¼Œä¸è¦æ„Ÿåˆ°æƒŠè®¶ã€‚
- en: Okay, letâ€™s jump into exploring Polars! ğŸ»â€â„ï¸
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: å¥½çš„ï¼Œè®©æˆ‘ä»¬å¼€å§‹æ¢ç´¢ Polars å§ï¼ ğŸ»â€â„ï¸
- en: Installation
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å®‰è£…
- en: Fortunately, installing Polars is very easy. You can install Polars as you would
    any other Python library. Here is the specific command you can use to install
    Polars from PyPI.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: å¹¸è¿çš„æ˜¯ï¼Œå®‰è£… Polars éå¸¸ç®€å•ã€‚ä½ å¯ä»¥åƒå®‰è£…å…¶ä»– Python åº“ä¸€æ ·å®‰è£… Polarsã€‚è¿™é‡Œæ˜¯ä» PyPI å®‰è£… Polars çš„å…·ä½“å‘½ä»¤ã€‚
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: At times throughout this guide, we will have to make some translations back
    and forth between Pandas and Polars. (Yes, this is not ideal and something I would
    prefer to avoid, but for the time being, this is the only way around some issues
    I ran into.) In order to do this, you will also need to install the PyArrow Python
    libary. Similar to installing Polars, we can run the following command to install
    PyArrow from PyPI.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ¬æŒ‡å—çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬æœ‰æ—¶éœ€è¦åœ¨ Pandas å’Œ Polars ä¹‹é—´è¿›è¡Œä¸€äº›è½¬æ¢ã€‚ï¼ˆæ˜¯çš„ï¼Œè¿™å¹¶ä¸ç†æƒ³ï¼Œæˆ‘æ›´æ„¿æ„é¿å…è¿™ç§æƒ…å†µï¼Œä½†ç›®å‰ï¼Œè¿™æ˜¯è§£å†³æˆ‘é‡åˆ°çš„ä¸€äº›é—®é¢˜çš„å”¯ä¸€æ–¹æ³•ã€‚ï¼‰ä¸ºæ­¤ï¼Œä½ è¿˜éœ€è¦å®‰è£…
    PyArrow Python åº“ã€‚ä¸å®‰è£… Polars ç±»ä¼¼ï¼Œæˆ‘ä»¬å¯ä»¥è¿è¡Œä»¥ä¸‹å‘½ä»¤ä» PyPI å®‰è£… PyArrowã€‚
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This last installation step is optional, but you may find it useful for future
    work. As mentioned in the introduction, I intend to demonstrate the performance
    of Pandas compared to Polars, and doing this work in a Jupyter notebook, we could
    run the Jupyter magic command `%% time` to output the runtime of each specific
    cell. This can naturally become very tedious to type, and fortunately, we can
    install a special Jupyter extension that will automatedly display the runtime
    of each cell in a tiny line of text below each run cell. In order to do that,
    weâ€™ll need to run the following 3 commands in your CLI.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åçš„å®‰è£…æ­¥éª¤æ˜¯å¯é€‰çš„ï¼Œä½†ä½ å¯èƒ½ä¼šå‘ç°å®ƒå¯¹æœªæ¥çš„å·¥ä½œå¾ˆæœ‰ç”¨ã€‚æ­£å¦‚ä»‹ç»ä¸­æåˆ°çš„ï¼Œæˆ‘æ‰“ç®—æ¼”ç¤º Pandas ä¸ Polars çš„æ€§èƒ½å¯¹æ¯”ï¼Œè€Œåœ¨ Jupyter
    notebook ä¸­è¿›è¡Œè¿™é¡¹å·¥ä½œæ—¶ï¼Œæˆ‘ä»¬å¯ä»¥è¿è¡Œ Jupyter é­”æ³•å‘½ä»¤`%% time`æ¥è¾“å‡ºæ¯ä¸ªç‰¹å®šå•å…ƒæ ¼çš„è¿è¡Œæ—¶é—´ã€‚è¿™è‡ªç„¶ä¼šå˜å¾—éå¸¸ç¹çï¼Œå¹¸è¿çš„æ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥å®‰è£…ä¸€ä¸ªç‰¹æ®Šçš„
    Jupyter æ‰©å±•ï¼Œå®ƒä¼šåœ¨æ¯ä¸ªè¿è¡Œçš„å•å…ƒæ ¼ä¸‹æ–¹è‡ªåŠ¨æ˜¾ç¤ºä¸€ä¸ªå°æ–‡æœ¬è¡Œæ¥æ˜¾ç¤ºè¿è¡Œæ—¶é—´ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬éœ€è¦åœ¨ä½ çš„ CLI ä¸­è¿è¡Œä»¥ä¸‹ 3 ä¸ªå‘½ä»¤ã€‚
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What the commands above enable is a new toggle in the Jupyter user interface
    that will properly display the runtime for each cell run. To enable this in the
    Jupyter notebook inferface, navigate to `Cell > Execution Timings` and select
    `Toggle Visibility (all)`. The screenshot below also demonstrates this appropriately.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸Šè¿°å‘½ä»¤æ‰€å¯ç”¨çš„æ˜¯ Jupyter ç”¨æˆ·ç•Œé¢ä¸­çš„ä¸€ä¸ªæ–°åˆ‡æ¢æŒ‰é’®ï¼Œå®ƒå¯ä»¥æ­£ç¡®æ˜¾ç¤ºæ¯ä¸ªå•å…ƒæ ¼è¿è¡Œçš„è¿è¡Œæ—¶é—´ã€‚è¦åœ¨ Jupyter notebook ç•Œé¢ä¸­å¯ç”¨æ­¤åŠŸèƒ½ï¼Œå¯¼èˆªåˆ°
    `Cell > Execution Timings` å¹¶é€‰æ‹© `Toggle Visibility (all)`ã€‚ä¸‹é¢çš„æˆªå›¾ä¹Ÿæ°å½“åœ°æ¼”ç¤ºäº†è¿™ä¸€ç‚¹ã€‚
- en: '![](../Images/d994115ff6980b9841e5028199f2f595.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d994115ff6980b9841e5028199f2f595.png)'
- en: Screenshot captured by the author
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œè€…æ•æ‰çš„æˆªå›¾
- en: Getting Started
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å¼€å§‹ä½¿ç”¨
- en: In this first section, weâ€™ll demonstrate a few common commands that many data
    scientists and machine learning engineers prefer to run at the outset of working
    with any new dataset. As a reminder, we will be working with the Titanic dataset,
    which I have already saved to my local computer as a CSV file in an adjacent directory.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸€éƒ¨åˆ†ï¼Œæˆ‘ä»¬å°†å±•ç¤ºä¸€äº›å¸¸è§å‘½ä»¤ï¼Œè®¸å¤šæ•°æ®ç§‘å­¦å®¶å’Œæœºå™¨å­¦ä¹ å·¥ç¨‹å¸ˆåœ¨å¤„ç†ä»»ä½•æ–°æ•°æ®é›†æ—¶éƒ½å–œæ¬¢å…ˆè¿è¡Œè¿™äº›å‘½ä»¤ã€‚ä½œä¸ºæé†’ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ Titanic æ•°æ®é›†ï¼Œæˆ‘å·²ç»å°†å…¶ä¿å­˜ä¸º
    CSV æ–‡ä»¶åœ¨ä¸€ä¸ªç›¸é‚»çš„ç›®å½•ä¸­ã€‚
- en: Importing Pandas and Polars
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å¯¼å…¥ Pandas å’Œ Polars
- en: Of course, the first thing weâ€™ll want to do is to import each of the respective
    Python libraries appropriately. As Pandas users are aware, Pandas is almost aliased
    as `pd` when imported. Likewise, Polars is also often aliased with the two letters
    `pl`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œæˆ‘ä»¬é¦–å…ˆéœ€è¦é€‚å½“åœ°å¯¼å…¥å„è‡ªçš„ Python åº“ã€‚æ­£å¦‚ Pandas ç”¨æˆ·æ‰€çŸ¥é“çš„ï¼ŒPandas åœ¨å¯¼å…¥æ—¶å‡ ä¹è¢«åˆ«åä¸º `pd`ã€‚åŒæ ·ï¼ŒPolars
    ä¹Ÿé€šå¸¸ç”¨ä¸¤ä¸ªå­—æ¯ `pl` ä½œä¸ºåˆ«åã€‚
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Loading Data from a CSV File
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ä» CSV æ–‡ä»¶åŠ è½½æ•°æ®
- en: Throughout this post, youâ€™ll find that Polars and Pandas can sometimes have
    very different ways of doing things and other times the syntax will be the exact
    same. Fortunately, this first instance is the exact same from Pandas to Polars.
    Here is the code demonstrating that similarity.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ç¯‡æ–‡ç« ä¸­ï¼Œä½ ä¼šå‘ç° Polars å’Œ Pandas æœ‰æ—¶åœ¨åšäº‹æƒ…çš„æ–¹å¼ä¸Šä¼šéå¸¸ä¸åŒï¼Œè€Œæœ‰æ—¶è¯­æ³•åˆ™å®Œå…¨ç›¸åŒã€‚å¹¸è¿çš„æ˜¯ï¼Œè¿™ç¬¬ä¸€æ¬¡ç¤ºä¾‹ä¸­ä» Pandas
    åˆ° Polars çš„è¯­æ³•æ˜¯å®Œå…¨ç›¸åŒçš„ã€‚ä¸‹é¢çš„ä»£ç å±•ç¤ºäº†è¿™ç§ç›¸ä¼¼æ€§ã€‚
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Before proceeding forward, letâ€™s start talking about the performance of these
    libraries. As you can see in the screenshot below, the Polars load was 1 millisecond
    faster than the Pandas load. Transparently, I got different results each time
    I ran these cells, but I can say that Polars was consistently faster. This will
    be a recurring theme throughout this whole post.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a81ee9ee2adf7aa1ef5a518cd505c450.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: Screenshot captured by the author
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the First Rows of Each DataFrame
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Immediately after loading a CSV, the first thing I like to do is view the first
    few rows of the DataFrame just to get a sense of what Iâ€™m working with. From a
    syntax perspective, Pandas users will immediately find themselves at home with
    Polarsâ€™ implementation as its the exact same.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: While the syntax is the same, the output is interestingly different between
    Pandas and Polars, and for the most part, I actually really like how Polars displays
    the output here. As you can see below, Polars displays the data type of each respective
    feature directly below the name of each feature. Moreover, the syntax of string-based
    columns shows the values wrapped in double quotes. I personally really love this
    because Pandas isnâ€™t overtly clear about the data types of each column, especially
    when it comes to strings. The only odd quirk about Polars is that it doesnâ€™t display
    the index values of each row off to the left as Pandas does. To be clear, the
    index values are still intact; they just arenâ€™t displayed in this view. (Also
    notice that Polars ran twice as fast as Pandas in this instance.)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/77491e9e6f6e522038c99211c9ed321e.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: Screenshot captured by the author
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Viewing Information about the DataFrame
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, the syntax of both libraries has been the same, but we now come to
    the point where they begin to radically diverge in functionality. Pandas users
    will be familiar with two functions that each show respective information about
    the DataFrame: `info()` and `describe()`. `info()` shows things like the feature
    names, data types, and null values, while `describe()` shows general statistics
    associated to each feature like mean and standard deviation. Here is the Pandas
    code and a screenshot of the output of each respective function.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![](../Images/7257c3eeb2171b3849283f789eb764f0.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
- en: Screenshot captured by the author
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Polars takes a very different turn from Pandas in this regard. For starters,
    there is no `info()` command. Instead, it takes the `describe()` command and more
    or less mashes the outputs weâ€™re used to seeing across Pandasâ€™ `info()` and `describe()`
    functions into a single output. Below is what that looks like.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](../Images/17664d4ae512f1016ed06d2128f64a1b.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: Screenshot captured by the author
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: To be honest, I donâ€™t know how I feel about this implementation. On one hand,
    I think the Polars output makes it clearer how many nulls there are since you
    have to do a bit of mental math to understand how many nulls there are in the
    Pandas output. But on the other hand, Polars loses information provided by Pandas
    like the interquartile range values. Notice also that in the Pandas `describe()`
    output, it rightfully excludes string-based columns whereas Polars keeps them
    in there. I typically wouldnâ€™t care, but if you look at the â€œminâ€ and â€œmaxâ€ values
    for the â€œSexâ€ feature, for example, it gives someâ€¦ wellâ€¦ unsavory results!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: è¯´å®è¯ï¼Œæˆ‘å¯¹è¿™ä¸ªå®ç°çš„æ„Ÿå—æœ‰äº›å¤æ‚ã€‚ä¸€æ–¹é¢ï¼Œæˆ‘è®¤ä¸º Polars çš„è¾“å‡ºæ›´æ¸…æ¥šåœ°æ˜¾ç¤ºäº†ç©ºå€¼çš„æ•°é‡ï¼Œå› ä¸ºä½ éœ€è¦åšä¸€ç‚¹å¿ƒç†æ•°å­¦æ¥ç†è§£ Pandas è¾“å‡ºä¸­çš„ç©ºå€¼æ•°é‡ã€‚ä½†å¦ä¸€æ–¹é¢ï¼ŒPolars
    ä¸¢å¤±äº† Pandas æä¾›çš„ä¿¡æ¯ï¼Œå¦‚å››åˆ†ä½æ•°èŒƒå›´å€¼ã€‚è¿˜è¦æ³¨æ„ï¼Œåœ¨ Pandas çš„ `describe()` è¾“å‡ºä¸­ï¼Œå®ƒåˆç†åœ°æ’é™¤äº†åŸºäºå­—ç¬¦ä¸²çš„åˆ—ï¼Œè€Œ Polars
    ä»ç„¶ä¿ç•™å®ƒä»¬ã€‚æˆ‘é€šå¸¸ä¸ä¼šåœ¨æ„ï¼Œä½†å¦‚æœä½ çœ‹çœ‹â€œæ€§åˆ«â€ç‰¹å¾çš„â€œæœ€å°â€å’Œâ€œæœ€å¤§â€å€¼ï¼Œä¾‹å¦‚ï¼Œå®ƒç»™å‡ºäº†ä¸€äº›â€¦â€¦å—¯â€¦â€¦ä¸å¤ªä»¤äººæ„‰å¿«çš„ç»“æœï¼
- en: Displaying the Value Counts of a Specific Feature
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: æ˜¾ç¤ºç‰¹å®šç‰¹å¾çš„å€¼è®¡æ•°
- en: Another thing I like to do when first getting started with a dataset using categorical
    data is to look at the value counts associated to each categorical feature. Fortunately,
    weâ€™re back to a similar syntax that Pandas users will be familiar with, except
    youâ€™ll notice the output is a little different.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: å¦ä¸€ä»¶æˆ‘å–œæ¬¢åœ¨å¼€å§‹ä½¿ç”¨åˆ†ç±»æ•°æ®é›†æ—¶åšçš„äº‹æƒ…æ˜¯æŸ¥çœ‹æ¯ä¸ªåˆ†ç±»ç‰¹å¾çš„å€¼è®¡æ•°ã€‚å¹¸è¿çš„æ˜¯ï¼Œæˆ‘ä»¬å›åˆ°äº† Pandas ç”¨æˆ·ä¼šç†Ÿæ‚‰çš„ç±»ä¼¼è¯­æ³•ï¼Œåªæ˜¯ä½ ä¼šæ³¨æ„åˆ°è¾“å‡ºç•¥æœ‰ä¸åŒã€‚
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![](../Images/220da36c5be2321c116817c435d79ce2.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/220da36c5be2321c116817c435d79ce2.png)'
- en: Screenshot captured by the author
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œè€…æˆªå›¾
- en: As you can see, the Polars output is actually a little more informative because
    it includes the number of null values whereas the Pandas output doesnâ€™t talk about
    the null values at all. This is one instance where I have to give Polars a clean
    win. This is really handy!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚ä½ æ‰€çœ‹åˆ°çš„ï¼ŒPolars çš„è¾“å‡ºå®é™…ä¸Šæ›´å…·ä¿¡æ¯æ€§ï¼Œå› ä¸ºå®ƒåŒ…å«äº†ç©ºå€¼çš„æ•°é‡ï¼Œè€Œ Pandas çš„è¾“å‡ºå®Œå…¨æ²¡æœ‰æåˆ°ç©ºå€¼ã€‚è¿™æ˜¯ä¸€ä¸ªæˆ‘å¿…é¡»æ‰¿è®¤ Polars
    ç»å¯¹èƒœå‡ºçš„ä¾‹å­ã€‚è¿™çœŸçš„å¾ˆæ–¹ä¾¿ï¼
- en: Data Wrangling
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ•°æ®æ•´ç†
- en: Now that weâ€™ve explored some very preliminary commands, letâ€™s move into some
    more complex functionality with data wrangling. Weâ€™ll explore a few common wrangling
    tactics in this section and continue our comparison between Pandas and Polars
    along the way.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å·²ç»æ¢ç´¢äº†ä¸€äº›éå¸¸åˆæ­¥çš„å‘½ä»¤ï¼Œè®©æˆ‘ä»¬è¿›å…¥æ•°æ®æ•´ç†çš„æ›´å¤æ‚åŠŸèƒ½ã€‚åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†æ¢è®¨ä¸€äº›å¸¸è§çš„æ•´ç†ç­–ç•¥ï¼Œå¹¶ç»§ç»­æ¯”è¾ƒ Pandas å’Œ Polarsã€‚
- en: Getting a Slice of the DataFrame
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è·å– DataFrame çš„åˆ‡ç‰‡
- en: Remember how I mentioned that it was odd that Polars doesnâ€™t show the index
    values for each row in the `head()` output but that they are still there? We can
    prove that here by demonstrating how to get a slice of each DataFrame. Fortunately,
    the syntax and output for Polars and Pandas is the exact same here. Also, doing
    a quick check in on our performance metrics, notice how Polars executed this slicing
    twice as fast as Pandas.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: è®°å¾—æˆ‘æåˆ°è¿‡ Polars åœ¨ `head()` è¾“å‡ºä¸­æ²¡æœ‰æ˜¾ç¤ºæ¯è¡Œçš„ç´¢å¼•å€¼ï¼Œä½†å®ƒä»¬ä»ç„¶å­˜åœ¨å—ï¼Ÿæˆ‘ä»¬å¯ä»¥é€šè¿‡æ¼”ç¤ºå¦‚ä½•è·å–æ¯ä¸ª DataFrame çš„åˆ‡ç‰‡æ¥è¯æ˜è¿™ä¸€ç‚¹ã€‚å¹¸è¿çš„æ˜¯ï¼ŒPolars
    å’Œ Pandas çš„è¯­æ³•å’Œè¾“å‡ºåœ¨è¿™é‡Œå®Œå…¨ç›¸åŒã€‚æ­¤å¤–ï¼Œå¿«é€ŸæŸ¥çœ‹æˆ‘ä»¬çš„æ€§èƒ½æŒ‡æ ‡ï¼Œæ³¨æ„åˆ° Polars æ‰§è¡Œåˆ‡ç‰‡çš„é€Ÿåº¦æ˜¯ Pandas çš„ä¸¤å€ã€‚
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![](../Images/5a9d0db740d6c18e987436ad631640cd.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5a9d0db740d6c18e987436ad631640cd.png)'
- en: Screenshot captured by the author
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œè€…æˆªå›¾
- en: Filtering the DataFrame by Feature Values
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: æŒ‰ç‰¹å¾å€¼è¿‡æ»¤ DataFrame
- en: Of everything weâ€™ll be demonstrating in this post, this is the area in which
    we can perform similar functionality in many different ways. Iâ€™m not going to
    attempt to demonstrate all of them, so I chose the following way to show that
    Polars can emulate similar functionality to Pandas but with syntax that is just
    a little bit different. Below is the code to pull out all rows representing teenagers
    on the Titanic. (The output is a bit long since there are 95 teenagers, so I wonâ€™t
    show the output. Just know that the output is indeed the same.)
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬å°†åœ¨è¿™ç¯‡æ–‡ç« ä¸­å±•ç¤ºçš„æ‰€æœ‰å†…å®¹ä¸­ï¼Œè¿™æ˜¯æˆ‘ä»¬å¯ä»¥ä»¥å¤šç§ä¸åŒæ–¹å¼æ‰§è¡Œç›¸ä¼¼åŠŸèƒ½çš„é¢†åŸŸã€‚æˆ‘ä¸ä¼šå°è¯•æ¼”ç¤ºæ‰€æœ‰æ–¹æ³•ï¼Œå› æ­¤æˆ‘é€‰æ‹©äº†ä»¥ä¸‹æ–¹å¼æ¥å±•ç¤º Polars å¦‚ä½•ä»¥ç•¥æœ‰ä¸åŒçš„è¯­æ³•æ¨¡æ‹Ÿ
    Pandas çš„ç›¸ä¼¼åŠŸèƒ½ã€‚ä¸‹é¢æ˜¯æå–æ‰€æœ‰ä»£è¡¨æ³°å¦å°¼å…‹å·ä¸Šé’å°‘å¹´çš„è¡Œçš„ä»£ç ã€‚ï¼ˆç”±äºæœ‰ 95 åé’å°‘å¹´ï¼Œè¾“å‡ºæœ‰ç‚¹é•¿ï¼Œå› æ­¤æˆ‘ä¸ä¼šæ˜¾ç¤ºè¾“å‡ºã€‚åªéœ€çŸ¥é“è¾“å‡ºç¡®å®æ˜¯ç›¸åŒçš„ã€‚ï¼‰
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Again, there are several different ways we could achieve the same results in
    Pandas and Polars with different syntax. The one thing I do want to highlight
    is that [the official Polars documentation](https://pola-rs.github.io/polars/py-polars/html/reference/dataframe/api/polars.DataFrame.filter.html#polars.DataFrame.filter)
    demonstrates what I did above using what I perceive as an odd choice of syntax.
    Where I use `df_polars[''Age'']` to reference the â€œAgeâ€ column in the Polars DataFrame,
    the official documentation instead recommends using this syntax: `pl.col(''Age'')`.
    The output is the exact same, so itâ€™s not as if either is wrong. You would think
    that Polars would want to demonstrate things as closely as possible to Pandas
    since most people using Polars will be Pandas users, and as I successfully demonstrated,
    the class choice of `df_polars[''Age'']` worked just fine. This actually occurs
    quite a bit in the Polars documentation, so be aware that though the documentation
    may say one thing, you might be able to get away with a more classic syntax youâ€™re
    already used to.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: å†æ¬¡ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ä¸åŒçš„è¯­æ³•åœ¨ Pandas å’Œ Polars ä¸­å®ç°ç›¸åŒçš„ç»“æœã€‚æˆ‘æƒ³å¼ºè°ƒçš„æ˜¯ï¼Œ[å®˜æ–¹ Polars æ–‡æ¡£](https://pola-rs.github.io/polars/py-polars/html/reference/dataframe/api/polars.DataFrame.filter.html#polars.DataFrame.filter)æ¼”ç¤ºäº†æˆ‘ä¸Šé¢åšçš„äº‹æƒ…ï¼Œä½¿ç”¨äº†æˆ‘è®¤ä¸ºæ¯”è¾ƒå¥‡æ€ªçš„è¯­æ³•ã€‚å½“æˆ‘ä½¿ç”¨`df_polars['Age']`æ¥å¼•ç”¨
    Polars DataFrame ä¸­çš„â€œAgeâ€åˆ—æ—¶ï¼Œå®˜æ–¹æ–‡æ¡£æ¨èä½¿ç”¨è¿™ç§è¯­æ³•ï¼š`pl.col('Age')`ã€‚è¾“å‡ºæ˜¯å®Œå…¨ç›¸åŒçš„ï¼Œæ‰€ä»¥è¯´å“ªä¸€ç§éƒ½æ˜¯å¯¹çš„ä¹Ÿæœªå¿…ã€‚ä½ ä¼šè§‰å¾—
    Polars åº”è¯¥å°½å¯èƒ½åœ°å±•ç¤ºä¸ Pandas ç±»ä¼¼çš„å†…å®¹ï¼Œå› ä¸ºå¤§å¤šæ•°ä½¿ç”¨ Polars çš„äººéƒ½æ˜¯ Pandas ç”¨æˆ·ï¼Œæ­£å¦‚æˆ‘æˆåŠŸå±•ç¤ºçš„é‚£æ ·ï¼Œ`df_polars['Age']`çš„ç±»é€‰æ‹©æ•ˆæœå¾ˆå¥½ã€‚è¿™åœ¨
    Polars æ–‡æ¡£ä¸­å®é™…ä¸Šå¾ˆå¸¸è§ï¼Œå› æ­¤è¯·æ³¨æ„ï¼Œå°½ç®¡æ–‡æ¡£å¯èƒ½è¯´ä¸€å›äº‹ï¼Œä½†ä½ å¯èƒ½å¯ä»¥ä½¿ç”¨ä½ å·²ç»ç†Ÿæ‚‰çš„æ›´ç»å…¸çš„è¯­æ³•ã€‚
- en: Filling Null Values
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å¡«å…… Null å€¼
- en: Thus far, our experience with Polars has ranged from neutral to positive. With
    this particular piece of functionality, we unfortunately begin to stray into some
    negative territory. Filling a column with null values is relatively straightforward
    in Pandas, and we can even apply this filling directly in place with the `inplace`
    parameter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å¯¹ Polars çš„ä½“éªŒä»ä¸­æ€§åˆ°ç§¯æã€‚é—æ†¾çš„æ˜¯ï¼Œåœ¨è¿™ä¸ªç‰¹å®šçš„åŠŸèƒ½ä¸Šï¼Œæˆ‘ä»¬å¼€å§‹è¿›å…¥ä¸€äº›è´Ÿé¢é¢†åŸŸã€‚åœ¨ Pandas ä¸­ï¼Œç”¨ null å€¼å¡«å……ä¸€åˆ—æ˜¯ç›¸å¯¹ç®€å•çš„ï¼Œæˆ‘ä»¬ç”šè‡³å¯ä»¥ç›´æ¥ä½¿ç”¨`inplace`å‚æ•°æ¥å®Œæˆå¡«å……ã€‚
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Polars unfortunately is a bit odd here. First, there is no equivalent of the
    `inplace` parameter, and this is actually a recurring theme throughout Polars
    as weâ€™ll see again later in the post. Moreover, Polars actually has two different
    functions for filling null values: `fill_null()` and `fill_nan()`. Looking at
    the documentation for each, I honestly canâ€™t tell you why you would choose one
    over the other. (Of course, this could very well be my own ignorance.) In the
    code block below, I make use of the `fill_null()` function to the same effect
    as Pandasâ€™ `fillna()`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å¹¸çš„æ˜¯ï¼ŒPolars åœ¨è¿™é‡Œæœ‰ç‚¹å¥‡æ€ªã€‚é¦–å…ˆï¼Œæ²¡æœ‰`inplace`å‚æ•°çš„ç­‰æ•ˆé¡¹ï¼Œè¿™å®é™…ä¸Šæ˜¯ Polars ä¸­ä¸€ä¸ªåå¤å‡ºç°çš„ä¸»é¢˜ï¼Œæˆ‘ä»¬ç¨åä¼šå†æ¬¡çœ‹åˆ°ã€‚æ­¤å¤–ï¼ŒPolars
    å®é™…ä¸Šæœ‰ä¸¤ä¸ªä¸åŒçš„å¡«å…… null å€¼çš„å‡½æ•°ï¼š`fill_null()`å’Œ`fill_nan()`ã€‚æŸ¥çœ‹æ¯ä¸ªå‡½æ•°çš„æ–‡æ¡£ï¼Œæˆ‘è¯šå®åœ°å‘Šè¯‰ä½ æˆ‘ä¸æ˜ç™½ä¸ºä»€ä¹ˆé€‰æ‹©å…¶ä¸­ä¸€ä¸ªè€Œä¸æ˜¯å¦ä¸€ä¸ªã€‚ï¼ˆå½“ç„¶ï¼Œè¿™å¯èƒ½æ˜¯æˆ‘è‡ªå·±çš„æ— çŸ¥ã€‚ï¼‰åœ¨ä¸‹é¢çš„ä»£ç å—ä¸­ï¼Œæˆ‘ä½¿ç”¨äº†`fill_null()`å‡½æ•°ï¼Œå…¶æ•ˆæœä¸
    Pandas çš„`fillna()`ç›¸åŒã€‚
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Grouping Data by Feature Names
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: æŒ‰ç‰¹å¾åç§°åˆ†ç»„æ•°æ®
- en: In order to get a deeper understanding of the data, it is very common for data
    practitioners to group data together to understand how groups of data may share
    new insights with us. Pandas users will be very familiar with the `groupby()`
    function in this regard. Unfortunately, Polars also does have a `groupby()` function,
    but its output is very different. Pandas users will find this difference to be
    jarring, and I transparently could not find a way to emulate the Pandas output
    using a different Polars syntax. (Granted, I admittedly didnâ€™t try very hard.
    ğŸ˜…) See below how the same syntax produces very different results across each library.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†æ›´æ·±å…¥åœ°ç†è§£æ•°æ®ï¼Œæ•°æ®ä»ä¸šè€…é€šå¸¸ä¼šå°†æ•°æ®åˆ†ç»„ä»¥äº†è§£æ•°æ®ç»„å¯èƒ½å¸¦æ¥çš„æ–°è§è§£ã€‚åœ¨è¿™æ–¹é¢ï¼ŒPandas ç”¨æˆ·ä¼šéå¸¸ç†Ÿæ‚‰`groupby()`å‡½æ•°ã€‚ä¸å¹¸çš„æ˜¯ï¼ŒPolars
    ç¡®å®ä¹Ÿæœ‰ä¸€ä¸ª`groupby()`å‡½æ•°ï¼Œä½†å®ƒçš„è¾“å‡ºå´å¤§ç›¸å¾„åº­ã€‚Pandas ç”¨æˆ·ä¼šå‘ç°è¿™ç§å·®å¼‚å¾ˆçªå…€ï¼Œæˆ‘å¦ç‡åœ°è¯´æ²¡æœ‰æ‰¾åˆ°ä½¿ç”¨ä¸åŒ Polars è¯­æ³•æ¥æ¨¡æ‹Ÿ
    Pandas è¾“å‡ºçš„æ–¹æ³•ã€‚ï¼ˆå½“ç„¶ï¼Œæˆ‘æ‰¿è®¤æˆ‘æ²¡æœ‰å°è¯•å¾—å¾ˆè®¤çœŸã€‚ğŸ˜…ï¼‰è§ä¸‹æ–‡ï¼Œå¦‚ä½•ç”¨ç›¸åŒçš„è¯­æ³•åœ¨æ¯ä¸ªåº“ä¸­äº§ç”Ÿæˆªç„¶ä¸åŒçš„ç»“æœã€‚
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![](../Images/787392a5661e492c2433c0acafb38a14.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/787392a5661e492c2433c0acafb38a14.png)'
- en: Screenshot captured by the author
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œè€…æˆªå›¾
- en: Feature Engineering
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç‰¹å¾å·¥ç¨‹
- en: While feature engineering could certainly be considered a type of data wrangling,
    I decided to separate this into its own respective section as it correlates to
    other work Iâ€™ve done in the past. As part of [this notebook on GitHub](https://github.com/dkhundley/titanic-byoc/blob/main/notebooks/feature-engineering.ipynb),
    I demonstrated how one might perform feature engineering on the Titanic dataset.
    We wonâ€™t be covering every bit of feature engineering in this section, but weâ€™ll
    demonstrate a few things so you can get a sense of how this same work compares
    in Pandas and Polars. Weâ€™ll start fresh again by reloading each DataFrame from
    scratch with this code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: è™½ç„¶ç‰¹å¾å·¥ç¨‹ç¡®å®å¯ä»¥è¢«è§†ä¸ºæ•°æ®å¤„ç†çš„ä¸€ç§ç±»å‹ï¼Œä½†æˆ‘å†³å®šå°†å…¶åˆ†å¼€æˆç‹¬ç«‹çš„éƒ¨åˆ†ï¼Œå› ä¸ºå®ƒä¸æˆ‘è¿‡å»åšçš„å…¶ä»–å·¥ä½œç›¸å…³ã€‚ä½œä¸º [GitHub ä¸Šè¿™ä¸ªç¬”è®°æœ¬](https://github.com/dkhundley/titanic-byoc/blob/main/notebooks/feature-engineering.ipynb)
    çš„ä¸€éƒ¨åˆ†ï¼Œæˆ‘å±•ç¤ºäº†å¦‚ä½•å¯¹ Titanic æ•°æ®é›†è¿›è¡Œç‰¹å¾å·¥ç¨‹ã€‚æˆ‘ä»¬ä¸ä¼šåœ¨è¿™ä¸€éƒ¨åˆ†è¦†ç›–æ¯ä¸€ä¸ªç‰¹å¾å·¥ç¨‹ï¼Œä½†æˆ‘ä»¬ä¼šå±•ç¤ºä¸€äº›å†…å®¹ï¼Œä»¥ä¾¿ä½ å¯ä»¥äº†è§£è¿™äº›ç›¸åŒçš„å·¥ä½œåœ¨ Pandas
    å’Œ Polars ä¸­çš„æ¯”è¾ƒã€‚æˆ‘ä»¬å°†é€šè¿‡ä½¿ç”¨ä»¥ä¸‹ä»£ç ä»å¤´å¼€å§‹é‡æ–°åŠ è½½æ¯ä¸ª DataFrame æ¥é‡æ–°å¼€å§‹ã€‚
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Dropping Unnecessary Features
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: åˆ é™¤ä¸å¿…è¦çš„ç‰¹å¾
- en: In almost every dataset youâ€™ll work with, youâ€™ll find features that are irrelevant
    and need dropped before passing into any machine learning algorithm. While this
    is not difficult to do in Polars, recall that Polars functions do not have a similar
    `inplace` parameter that would allow us to update the Polars DataFrame in place.
    Here is the syntax for dropping features in both libraries.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å‡ ä¹æ‰€æœ‰ä½ ä¼šå¤„ç†çš„æ•°æ®é›†ä¸­ï¼Œä½ éƒ½ä¼šå‘ç°ä¸€äº›æ— å…³çš„ç‰¹å¾ï¼Œè¿™äº›ç‰¹å¾åœ¨ä¼ é€’ç»™ä»»ä½•æœºå™¨å­¦ä¹ ç®—æ³•ä¹‹å‰éœ€è¦è¢«åˆ é™¤ã€‚è™½ç„¶åœ¨ Polars ä¸­è¿™å¹¶ä¸å›°éš¾ï¼Œä½†è¯·è®°ä½ï¼ŒPolars
    çš„å‡½æ•°æ²¡æœ‰ç±»ä¼¼ `inplace` å‚æ•°ï¼Œè¿™æ ·æˆ‘ä»¬å°±æ— æ³•å°±åœ°æ›´æ–° Polars DataFrameã€‚ä¸‹é¢æ˜¯ä¸¤ç§åº“ä¸­åˆ é™¤ç‰¹å¾çš„è¯­æ³•ã€‚
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: One-Hot Encoding Categorical Features
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å¯¹åˆ†ç±»ç‰¹å¾è¿›è¡Œç‹¬çƒ­ç¼–ç 
- en: Remember at the beginning when I mentioned weâ€™d have to install PyArrow to translate
    our Polars DataFrame into a Pandas DataFrame? Well, here is our first instance
    of why we have to do that. I personally prefer to use [Category Encoderâ€™s implementation
    of one-hot encoding](https://contrib.scikit-learn.org/category_encoders/onehot.html)
    for my one-hot encoding work. For context, hereâ€™s how you would import that after
    installing it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: è¿˜è®°å¾—æˆ‘æœ€å¼€å§‹æåˆ°æˆ‘ä»¬å¿…é¡»å®‰è£… PyArrow ä»¥å°†æˆ‘ä»¬çš„ Polars DataFrame è½¬æ¢ä¸º Pandas DataFrame å—ï¼Ÿå¥½å§ï¼Œè¿™å°±æ˜¯æˆ‘ä»¬å¿…é¡»è¿™ä¹ˆåšçš„ç¬¬ä¸€ä¸ªå®ä¾‹ã€‚æˆ‘ä¸ªäººæ›´å–œæ¬¢ä½¿ç”¨
    [Category Encoder çš„ç‹¬çƒ­ç¼–ç å®ç°](https://contrib.scikit-learn.org/category_encoders/onehot.html)
    æ¥è¿›è¡Œç‹¬çƒ­ç¼–ç ã€‚ä¸ºäº†è¯´æ˜ï¼Œè¿™é‡Œæ˜¯å®‰è£…åå¦‚ä½•å¯¼å…¥å®ƒã€‚
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If we were to perform one-hot encoding on the â€œSexâ€ (aka gender) feature using
    Pandas, here is what the syntax would look like.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬ä½¿ç”¨ Pandas å¯¹â€œæ€§åˆ«â€ï¼ˆå³æ€§åˆ«ï¼‰ç‰¹å¾è¿›è¡Œç‹¬çƒ­ç¼–ç ï¼Œä»¥ä¸‹æ˜¯è¯­æ³•ç¤ºä¾‹ã€‚
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Unfortunately, Category Encoderâ€™s `OneHotEncoder` isnâ€™t set up to work with
    Polars. If we were to run the following line as is, weâ€™d see the error in the
    screenshot below it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å¹¸çš„æ˜¯ï¼ŒCategory Encoder çš„ `OneHotEncoder` å¹¶æœªè®¾ç½®ä¸ºä¸ Polars ä¸€èµ·ä½¿ç”¨ã€‚å¦‚æœæˆ‘ä»¬ç›´æ¥è¿è¡Œä»¥ä¸‹ä»£ç ï¼Œæˆ‘ä»¬ä¼šçœ‹åˆ°ä¸‹é¢æˆªå›¾ä¸­çš„é”™è¯¯ã€‚
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![](../Images/2f75467a70dbf45a14f5592e0f666ca0.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2f75467a70dbf45a14f5592e0f666ca0.png)'
- en: Screenshot captured by the author
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œè€…æˆªå›¾
- en: There is a workaround for this, but unfortunately this will not be the first
    time weâ€™ll run into a breaking issue like this. Below is the full workaround for
    using Polars to perform a one-hot encoding. Notice that prior to fitting the Polars
    DataFrame to the `OneHotEncoder` object, we will first have to translate it into
    a Pandas DataFrame. Then after the conversion, we can simply translate it back
    into a Polars DataFrame.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰ä¸€ç§è§£å†³æ–¹æ³•ï¼Œä½†ä¸å¹¸çš„æ˜¯ï¼Œè¿™ä¸ä¼šæ˜¯æˆ‘ä»¬ç¬¬ä¸€æ¬¡é‡åˆ°ç±»ä¼¼çš„ç ´åæ€§é—®é¢˜ã€‚ä¸‹é¢æ˜¯ä½¿ç”¨ Polars æ‰§è¡Œç‹¬çƒ­ç¼–ç çš„å®Œæ•´è§£å†³æ–¹æ³•ã€‚è¯·æ³¨æ„ï¼Œåœ¨å°† Polars DataFrame
    æ‹Ÿåˆåˆ° `OneHotEncoder` å¯¹è±¡ä¹‹å‰ï¼Œæˆ‘ä»¬é¦–å…ˆéœ€è¦å°†å…¶è½¬æ¢ä¸º Pandas DataFrameã€‚ç„¶ååœ¨è½¬æ¢åï¼Œæˆ‘ä»¬å¯ä»¥ç®€å•åœ°å°†å…¶è½¬æ¢å› Polars
    DataFrameã€‚
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Finally, note that Polarsâ€™ implementation of the `concat()` function is just
    a little bit different from Pandas. Where Pandas uses the `axis` parameter to
    indicate how to perform the concatenation, Polars uses `how` and string-based
    values instead. I personally prefer how Polars implemented this here.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œè¯·æ³¨æ„ï¼ŒPolars çš„ `concat()` å‡½æ•°çš„å®ç°ä¸ Pandas æœ‰äº›ä¸åŒã€‚Pandas ä½¿ç”¨ `axis` å‚æ•°æ¥æŒ‡ç¤ºå¦‚ä½•æ‰§è¡Œè¿æ¥ï¼Œè€Œ
    Polars åˆ™ä½¿ç”¨ `how` å’ŒåŸºäºå­—ç¬¦ä¸²çš„å€¼ã€‚æˆ‘ä¸ªäººæ›´å–œæ¬¢ Polars åœ¨è¿™é‡Œçš„å®ç°ã€‚
- en: Binning Numerical Data
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: æ•°å€¼æ•°æ®åˆ†ç®±
- en: The way in which I chose to perform to feature engineer the â€œAgeâ€ feature was
    by binning it into appropriate age groups. For example, people aged 13 to 19 would
    be classified as teenagers whereas anybody over age 60 was considered an elder.
    Pandas has a very nice function called `cut()` that does this binning appropriately
    per the inputs you provide it. Here is the syntax for doing just that.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘é€‰æ‹©æ‰§è¡Œâ€œå¹´é¾„â€ç‰¹å¾å·¥ç¨‹çš„æ–¹å¼æ˜¯å°†å…¶åˆ†ç®±ä¸ºé€‚å½“çš„å¹´é¾„ç»„ã€‚ä¾‹å¦‚ï¼Œ13è‡³19å²çš„äººè¢«åˆ†ç±»ä¸ºé’å°‘å¹´ï¼Œè€Œ60å²ä»¥ä¸Šçš„äººè¢«è®¤ä¸ºæ˜¯è€å¹´äººã€‚Pandasæœ‰ä¸€ä¸ªéå¸¸å¥½çš„å‡½æ•°å«åš`cut()`ï¼Œå¯ä»¥æ ¹æ®ä½ æä¾›çš„è¾“å…¥æ­£ç¡®åœ°è¿›è¡Œåˆ†ç®±ã€‚è¿™æ˜¯æ‰§è¡Œæ­¤æ“ä½œçš„è¯­æ³•ã€‚
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Polars does offer its own implementation of `cut()`, but its output is radically
    different than Pandas to the point where I personally find it unusable. Here is
    the syntax and output of that code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Polarsç¡®å®æä¾›äº†è‡ªå·±å®ç°çš„`cut()`å‡½æ•°ï¼Œä½†å…¶è¾“å‡ºä¸Pandasçš„å·®å¼‚éå¸¸å¤§ï¼Œä»¥è‡³äºæˆ‘ä¸ªäººè§‰å¾—æ— æ³•ä½¿ç”¨ã€‚è¿™æ˜¯è¯¥ä»£ç çš„è¯­æ³•å’Œè¾“å‡ºã€‚
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![](../Images/dc0c1a4929db2da4a03c4721c8ef94ed.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/dc0c1a4929db2da4a03c4721c8ef94ed.png)'
- en: Screenshot captured by the author
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œè€…æ•è·çš„æˆªå›¾
- en: Looking at the output, it actually does appear that the binning worked, but
    it did a few weird things. First, it wouldnâ€™t take my semantic names established
    by the `bin_labels` array. Second, it didnâ€™t preserve the order of the rows as
    they were passed into the function. Instead, you can see that the Polars output
    has now sorted by the values in ascending order starting with the lowest value
    (aka the youngest age). Iâ€™m sure I could find a workaround for the first issue,
    but second issue renders this output useless for me. The temptation would be to
    match the ages to the original DataFrame, but as you can see in this simple output,
    lines 4 and 5 have the same `0.75` value. While this might be fine in this particular
    use case, this practice could be dangerous for a different dataset.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: çœ‹è¾“å‡ºç»“æœï¼Œå®é™…ä¸Šçœ‹èµ·æ¥åˆ†ç®±æ“ä½œç¡®å®æœ‰æ•ˆï¼Œä½†å®ƒåšäº†ä¸€äº›å¥‡æ€ªçš„äº‹æƒ…ã€‚é¦–å…ˆï¼Œå®ƒæ²¡æœ‰ä½¿ç”¨æˆ‘é€šè¿‡`bin_labels`æ•°ç»„å»ºç«‹çš„è¯­ä¹‰åç§°ã€‚å…¶æ¬¡ï¼Œå®ƒæ²¡æœ‰ä¿æŒä¼ å…¥å‡½æ•°çš„è¡Œé¡ºåºã€‚ç›¸åï¼Œä½ å¯ä»¥çœ‹åˆ°Polarsçš„è¾“å‡ºç°åœ¨å·²ç»æŒ‰ç…§ä»æœ€ä½å€¼ï¼ˆå³æœ€å¹´è½»çš„å¹´é¾„ï¼‰å¼€å§‹çš„å‡åºæ’åºã€‚æˆ‘ç›¸ä¿¡æˆ‘å¯ä»¥æ‰¾åˆ°ç¬¬ä¸€ä¸ªé—®é¢˜çš„è§£å†³æ–¹æ³•ï¼Œä½†ç¬¬äºŒä¸ªé—®é¢˜ä½¿å¾—è¿™ä¸ªè¾“å‡ºå¯¹æˆ‘æ¥è¯´æ¯«æ— ç”¨å¤„ã€‚è¯±æƒ‘æ˜¯å°†å¹´é¾„ä¸åŸå§‹DataFrameåŒ¹é…ï¼Œä½†æ­£å¦‚ä½ åœ¨è¿™ä¸ªç®€å•çš„è¾“å‡ºä¸­çœ‹åˆ°çš„ï¼Œè¡Œ4å’Œè¡Œ5æœ‰ç›¸åŒçš„`0.75`å€¼ã€‚è™½ç„¶åœ¨è¿™ä¸ªç‰¹å®šç”¨ä¾‹ä¸­å¯èƒ½æ²¡é—®é¢˜ï¼Œä½†è¿™ç§åšæ³•å¯¹ä¸åŒçš„æ•°æ®é›†å¯èƒ½æ˜¯å±é™©çš„ã€‚
- en: '(Note: As I was drafting this post, I upgraded from Polars 0.16.8 to 0.16.10,
    in which the Polars `cut()` function is now being deprecated in favor of using
    the Polars Series implementation of `cut()`. It doesnâ€™t seem that this new implementation
    fixes the issue, and at the time of this publication, [a GitHub issue](https://github.com/pola-rs/polars/issues/4286)
    has been noted requesting to add the row index preservation. In general, this
    is a good reminder that Polars in an early state!)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ï¼ˆæ³¨ï¼šåœ¨æˆ‘è‰æ‹Ÿè¿™ç¯‡æ–‡ç« æ—¶ï¼Œæˆ‘ä»Polars 0.16.8å‡çº§åˆ°0.16.10ï¼Œåœ¨è¿™ä¸ªç‰ˆæœ¬ä¸­ï¼ŒPolarsçš„`cut()`å‡½æ•°ç°åœ¨è¢«å¼ƒç”¨ï¼Œå–è€Œä»£ä¹‹çš„æ˜¯ä½¿ç”¨Polars
    Serieså®ç°çš„`cut()`ã€‚ä¼¼ä¹è¿™ä¸ªæ–°å®ç°æ²¡æœ‰è§£å†³é—®é¢˜ï¼Œåœ¨å‘å¸ƒæ—¶ï¼Œ[ä¸€ä¸ªGitHubé—®é¢˜](https://github.com/pola-rs/polars/issues/4286)å·²è¢«æŒ‡å‡ºè¯·æ±‚æ·»åŠ è¡Œç´¢å¼•ä¿ç•™ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œè¿™æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„æé†’ï¼ŒPolarsä»å¤„äºæ—©æœŸé˜¶æ®µï¼ï¼‰
- en: Predictive Modeling with Machine Learning
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æœºå™¨å­¦ä¹ ä¸­çš„é¢„æµ‹å»ºæ¨¡
- en: This final section will be brief because, unfortunately, this is where Polars
    ultimately falls flat for me, at least at the point when this post is published.
    Similarly to how I created a Jupyter notebook for feature engineering in a previous
    Titanic project, I will attempt to emulate the same steps I completed in [my original
    Titanic predictive modeling notebook](https://github.com/dkhundley/titanic-byoc/blob/main/notebooks/predictive-modeling.ipynb).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åçš„éƒ¨åˆ†å°†ç®€è¦ä»‹ç»ï¼Œå› ä¸ºä¸å¹¸çš„æ˜¯ï¼Œè¿™æ˜¯Polarsæœ€ç»ˆå¯¹æˆ‘æ¥è¯´è¡¨ç°ä¸ä½³çš„åœ°æ–¹ï¼Œè‡³å°‘åœ¨å‘å¸ƒè¿™ç¯‡æ–‡ç« çš„æ—¶å€™æ˜¯è¿™æ ·ã€‚ç±»ä¼¼äºæˆ‘åœ¨ä¹‹å‰çš„Titanicé¡¹ç›®ä¸­ä¸ºç‰¹å¾å·¥ç¨‹åˆ›å»ºJupyterç¬”è®°æœ¬çš„æ–¹å¼ï¼Œæˆ‘å°†å°è¯•æ¨¡æ‹Ÿåœ¨[æˆ‘åŸæ¥çš„Titanicé¢„æµ‹å»ºæ¨¡ç¬”è®°æœ¬](https://github.com/dkhundley/titanic-byoc/blob/main/notebooks/predictive-modeling.ipynb)ä¸­å®Œæˆçš„ç›¸åŒæ­¥éª¤ã€‚
- en: Performing a Train-Test Split
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: æ‰§è¡Œè®­ç»ƒ-æµ‹è¯•æ‹†åˆ†
- en: The hallmark of any good machine learning practice, the code below demonstrates
    how to perform a train-test (or train-validation) split to have holdout set to
    later use for model validation. Since weâ€™ll be making use of Scikit-Learnâ€™s `train_test_split`
    function, thereâ€™s not much to note here since the syntax is the exact same for
    both the Pandas and Polars DataFrames. I suppose I just wanted to highlight that
    this works with Polars out of the box today without any special workarounds. ğŸ˜ƒ
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ä»»ä½•è‰¯å¥½çš„æœºå™¨å­¦ä¹ å®è·µçš„æ ‡å¿—ï¼Œä¸‹é¢çš„ä»£ç æ¼”ç¤ºäº†å¦‚ä½•è¿›è¡Œè®­ç»ƒ-æµ‹è¯•ï¼ˆæˆ–è®­ç»ƒ-éªŒè¯ï¼‰æ‹†åˆ†ï¼Œä»¥ä¿ç•™æ•°æ®é›†ç”¨äºåç»­æ¨¡å‹éªŒè¯ã€‚ç”±äºæˆ‘ä»¬å°†ä½¿ç”¨Scikit-Learnçš„`train_test_split`å‡½æ•°ï¼Œè¿™é‡Œæ²¡æœ‰å¤ªå¤šéœ€è¦æ³¨æ„çš„ï¼Œå› ä¸ºPandaså’ŒPolars
    DataFramesçš„è¯­æ³•å®Œå…¨ç›¸åŒã€‚æˆ‘åªæ˜¯æƒ³å¼ºè°ƒï¼Œä»Šå¤©è¿™åœ¨Polarsä¸­å¼€ç®±å³ç”¨ï¼Œæ— éœ€ä»»ä½•ç‰¹æ®Šçš„è§£å†³æ–¹æ³•ã€‚ ğŸ˜ƒ
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Performing Predictive Modeling
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: æ‰§è¡Œé¢„æµ‹å»ºæ¨¡
- en: We finally come to the point where Polars unfortunately falls off the rails.
    In the code below, I demonstrate how you would fit the Pandas DataFrames to Scikit-Learnâ€™s
    Random Forest Classifier, which should produce the output in that nice blue box.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç»ˆäºæ¥åˆ°äº† Polars ä¸å¹¸å‡ºé”™çš„åœ°æ–¹ã€‚åœ¨ä¸‹é¢çš„ä»£ç ä¸­ï¼Œæˆ‘æ¼”ç¤ºäº†å¦‚ä½•å°† Pandas DataFrames é€‚é…åˆ° Scikit-Learn çš„éšæœºæ£®æ—åˆ†ç±»å™¨ï¼Œè¿™åº”è¯¥ä¼šåœ¨é‚£ä¸ªæ¼‚äº®çš„è“è‰²æ¡†ä¸­äº§ç”Ÿè¾“å‡ºã€‚
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![](../Images/cf94b6c20626534769b49c6d1e7848ce.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/cf94b6c20626534769b49c6d1e7848ce.png)'
- en: Screenshot captured by the author
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œè€…æ•è·çš„æˆªå›¾
- en: Unfortunately, I hit a brick wall when attempting to do this same thing with
    the Polars DataFrame. When I attempt to run the code block below, I get the error
    you see in the screenshot below.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å¹¸çš„æ˜¯ï¼Œå½“å°è¯•ç”¨ Polars DataFrame åšåŒæ ·çš„äº‹æƒ…æ—¶ï¼Œæˆ‘é‡åˆ°äº†ç“¶é¢ˆã€‚å½“æˆ‘å°è¯•è¿è¡Œä¸‹é¢çš„ä»£ç å—æ—¶ï¼Œæˆ‘æ”¶åˆ°äº†ä¸‹å›¾ä¸­çš„é”™è¯¯ã€‚
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![](../Images/564dc0c090ee1d6eb0a650bdcad85558.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/564dc0c090ee1d6eb0a650bdcad85558.png)'
- en: Screenshot captured by the author
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œè€…æ•è·çš„æˆªå›¾
- en: I spent a solid hour combing Scikit-Learnâ€™s source code to understand what was
    going on here and am still not quite sure why it is not reading the Polars DataFrameâ€™s
    shapes consistently as the Pandas DataFrames. When running commands like `df_polars.shape`
    and other similar ones, it consistently displays the same output as the correlative
    Pandas commands. It was definitely a head scratcher.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘èŠ±äº†ä¸€ä¸ªå°æ—¶ä»”ç»†æ£€æŸ¥ Scikit-Learn çš„æºä»£ç ï¼Œä»¥äº†è§£è¿™é‡Œå‘ç”Ÿäº†ä»€ä¹ˆï¼Œä½†ä»ç„¶ä¸å¤ªç¡®å®šä¸ºä»€ä¹ˆå®ƒæ— æ³•åƒ Pandas DataFrames ä¸€æ ·ä¸€è‡´åœ°è¯»å–
    Polars DataFrame çš„å½¢çŠ¶ã€‚å½“è¿è¡Œåƒ `df_polars.shape` è¿™æ ·çš„å‘½ä»¤æ—¶ï¼Œå®ƒå§‹ç»ˆæ˜¾ç¤ºä¸ç›¸å…³ Pandas å‘½ä»¤ç›¸åŒçš„è¾“å‡ºã€‚è¿™ç¡®å®è®©äººå›°æƒ‘ã€‚
- en: Now transparently, Scikit-Learn was the only algorithmic library I tried for
    this experiment. You may experience different results with other algorithmic libraries
    like XGBoost or LightGBM, but Iâ€™m honestly inclined to believe that most â€” if
    not all â€” will have the same issue I saw with Scikit-Learn. (Thatâ€™s an admittedly
    naive assumption, so check my work please! ğŸ˜‚)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨é€æ˜åœ°è¯´ï¼ŒScikit-Learn æ˜¯æˆ‘ä¸ºæ­¤å®éªŒå°è¯•çš„å”¯ä¸€ç®—æ³•åº“ã€‚ä½ å¯èƒ½ä¼šåœ¨å…¶ä»–ç®—æ³•åº“å¦‚ XGBoost æˆ– LightGBM ä¸­é‡åˆ°ä¸åŒçš„ç»“æœï¼Œä½†è€å®è¯´ï¼Œæˆ‘å€¾å‘äºç›¸ä¿¡å¤§å¤šæ•°
    â€” å¦‚æœä¸æ˜¯å…¨éƒ¨çš„è¯ â€” éƒ½ä¼šæœ‰ä¸ Scikit-Learn ç›¸åŒçš„é—®é¢˜ã€‚ï¼ˆè¿™æ˜¯ä¸€ä¸ªå¦ç‡çš„å¤©çœŸå‡è®¾ï¼Œæ‰€ä»¥è¯·æ£€æŸ¥æˆ‘çš„å·¥ä½œï¼ğŸ˜‚ï¼‰
- en: Concluding Thoughts
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç»“è®º
- en: Generally speaking, I really liked what I saw with Polars. We consistently saw
    speedier performance from Polars, and while this was a relatively trivial use
    case, I can imagine those performance gains can be significantly appreciated at
    scale. I also really liked other things like how they display the data types of
    each feature when displaying the data using a function like `head()`. Itâ€™s little
    things like that are way more appreciated by people like me than one might expect.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€èˆ¬æ¥è¯´ï¼Œæˆ‘å¯¹ Polars çš„è¡¨ç°éå¸¸æ»¡æ„ã€‚æˆ‘ä»¬ consistently çœ‹åˆ° Polars çš„æ€§èƒ½æ›´å¿«ï¼Œè™½ç„¶è¿™æ˜¯ä¸€ä¸ªç›¸å¯¹ç®€å•çš„ç”¨ä¾‹ï¼Œä½†æˆ‘å¯ä»¥æƒ³è±¡è¿™äº›æ€§èƒ½æå‡åœ¨å¤§è§„æ¨¡åº”ç”¨æ—¶ä¼šæ˜¾è‘—æ„Ÿå—åˆ°ã€‚æˆ‘ä¹Ÿéå¸¸å–œæ¬¢å…¶ä»–åŠŸèƒ½ï¼Œæ¯”å¦‚ä½¿ç”¨
    `head()` å‡½æ•°æ—¶æ˜¾ç¤ºæ¯ä¸ªç‰¹å¾çš„æ•°æ®ç±»å‹ã€‚åƒè¿™æ ·çš„ç»†èŠ‚æ¯”é¢„æœŸçš„æ›´å—æˆ‘ä»¬è¿™äº›äººå–œæ¬¢ã€‚
- en: 'Unfortunately, I canâ€™t recommend Polars in its current state for a â€œprime timeâ€
    machine learning production scenario. (Reminder: The most recent version at the
    time of this publication is 0.16.10). The hiccups I saw with the `cut()` function
    and inability to integrate with Category Encoders or Scikit-Learnâ€™s Random Forest
    Classifier are unfortunately deal breakers for me. I imagine this hurdle exists
    with many other libraries accustomed to Pandas today.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å¹¸çš„æ˜¯ï¼ŒåŸºäºç›®å‰çš„çŠ¶æ€ï¼Œæˆ‘æ— æ³•æ¨è Polars ç”¨äºâ€œé»„é‡‘æ—¶é—´â€çš„æœºå™¨å­¦ä¹ ç”Ÿäº§åœºæ™¯ã€‚ï¼ˆæé†’ï¼šæˆªè‡³æœ¬å‡ºç‰ˆæ—¶ï¼Œæœ€æ–°ç‰ˆæœ¬ä¸º 0.16.10ï¼‰ã€‚æˆ‘å‘ç°çš„ `cut()`
    å‡½æ•°é—®é¢˜ä»¥åŠæ— æ³•ä¸ Category Encoders æˆ– Scikit-Learn çš„éšæœºæ£®æ—åˆ†ç±»å™¨é›†æˆå¯¹æˆ‘æ¥è¯´éƒ½æ˜¯æ— æ³•æ¥å—çš„ã€‚æˆ‘æƒ³è¿™ç§éšœç¢åœ¨ç°åœ¨ä¹ æƒ¯ä½¿ç”¨
    Pandas çš„è®¸å¤šå…¶ä»–åº“ä¸­ä¹Ÿå­˜åœ¨ã€‚
- en: If I were a more pure data analyst not doing machine learning, maybe Polars
    could pass in that particular context. It seems like where Polars gets into the
    most trouble for now is when it tries to integrate with other libraries. (Which,
    of course, is not Polarsâ€™ fault!) I can see where a data analyst might use Polars
    and nothing else, and in that case, be careful and go for it. (Be careful not
    to get `cut()`! ğŸ˜‚)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘æ˜¯ä¸€åçº¯ç²¹çš„æ•°æ®åˆ†æå¸ˆï¼Œè€Œä¸æ˜¯è¿›è¡Œæœºå™¨å­¦ä¹ ï¼Œæˆ–è®¸ Polars å¯ä»¥åœ¨é‚£ä¸ªç‰¹å®šçš„ç¯å¢ƒä¸‹ä½¿ç”¨ã€‚ç›®å‰ï¼ŒPolars é‡åˆ°çš„æœ€å¤§éº»çƒ¦ä¼¼ä¹æ˜¯åœ¨å°è¯•ä¸å…¶ä»–åº“é›†æˆæ—¶ã€‚ï¼ˆè¿™å½“ç„¶ä¸æ˜¯
    Polars çš„é”™ï¼ï¼‰æˆ‘èƒ½ç†è§£æ•°æ®åˆ†æå¸ˆå¯èƒ½åªä½¿ç”¨ Polars è€Œæ²¡æœ‰å…¶ä»–åº“ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè¯·å°å¿ƒä½¿ç”¨ã€‚ï¼ˆå°å¿ƒä¸è¦è¢« `cut()` é™·é˜±å›°ä½ï¼ğŸ˜‚ï¼‰
- en: At the end of the day, I simply appreciate how good folks out there are dedicated
    to making something that was already good even better. When Numpy and Pandas were
    originally introduced, the performance gain over vanilla Python was staggering,
    so much so that it seemed as if it couldnâ€™t get any better than that. And then
    along comes Polars and demonstrates to us that we can do even better. Thatâ€™s just
    awesome. Thank you, Polars team, for your hard work, and I look forward to seeing
    how Polars evolves! ğŸ»â€â„ï¸
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°å¤´æ¥ï¼Œæˆ‘åªæ˜¯éå¸¸æ„Ÿæ¿€é‚£äº›ä¼˜ç§€çš„äººä»¬è‡´åŠ›äºè®©å·²ç»å¾ˆå¥½çš„ä¸œè¥¿å˜å¾—æ›´å¥½ã€‚å½“Numpyå’ŒPandasæœ€åˆæ¨å‡ºæ—¶ï¼Œç›¸æ¯”äºæ™®é€šçš„Pythonï¼Œå…¶æ€§èƒ½æå‡æ˜¯ä»¤äººæƒŠå¹çš„ï¼Œç”šè‡³è®©äººè§‰å¾—å†ä¹Ÿæ— æ³•æ›´å¥½ã€‚ç„¶è€Œï¼ŒPolarsçš„å‡ºç°å‘æˆ‘ä»¬å±•ç¤ºäº†æˆ‘ä»¬å¯ä»¥åšå¾—æ›´å¥½ã€‚è¿™çœŸæ˜¯å¤ªæ£’äº†ã€‚æ„Ÿè°¢Polarså›¢é˜Ÿçš„è¾›å‹¤å·¥ä½œï¼Œæˆ‘æœŸå¾…ç€çœ‹åˆ°Polarsçš„å‘å±•ï¼ğŸ»â€â„ï¸
