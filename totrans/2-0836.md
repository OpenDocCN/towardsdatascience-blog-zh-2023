# 进化算法 — 突变解释

> 原文：[https://towardsdatascience.com/evolutionary-algorithm-mutations-explained-4a3b5c2d49de](https://towardsdatascience.com/evolutionary-algorithm-mutations-explained-4a3b5c2d49de)

## 包含代码实现的插图，以TSP为例

[](https://medium.com/@byjameskoh?source=post_page-----4a3b5c2d49de--------------------------------)[![James Koh, PhD](../Images/8e7af8b567cdcf24805754801683b426.png)](https://medium.com/@byjameskoh?source=post_page-----4a3b5c2d49de--------------------------------)[](https://towardsdatascience.com/?source=post_page-----4a3b5c2d49de--------------------------------)[![Towards Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----4a3b5c2d49de--------------------------------) [James Koh, PhD](https://medium.com/@byjameskoh?source=post_page-----4a3b5c2d49de--------------------------------)

·发表于[Towards Data Science](https://towardsdatascience.com/?source=post_page-----4a3b5c2d49de--------------------------------) ·8分钟阅读·2023年11月7日

--

![](../Images/1f3a72402d15dee37703769569019834.png)

图片由DALL·E 3根据提示“绘制一个科幻风格的图像，描绘突变。左侧显示‘前’的状态，右侧显示‘后’的状态。”创建。

这是对[进化算法 — 选择解释](/evolutionary-algorithm-selections-explained-2515fb8d4287?sk=a4cd1504b6098f82f004db32567c8832)的延续。

如果你希望对基于预突变表示的重组和突变有一个高层次的理解，本文将作为独立文献满足你的需求。

然而，为了了解每个步骤的完整细节，首先阅读上面链接的文章将会有帮助，然后再继续阅读这里的内容。

结合上一篇文章中的代码片段，你将能够在个人计算机上解决著名的旅行商问题（TSP）。更重要的是，你将欣赏到幕后发生的所有细节。

# 达成共识

在第一部分中，我概述了进化算法框架如下：

![](../Images/dbe66fc1a36b486b957647fe9fcaf5b8.png)

作者提供的图像

在回顾了EA中使用的一些术语之后，我们深入探讨了初始化适当基因型的细节（第3.1节，针对<1>）以及轮盘赌和锦标赛选择（第3.2节，针对<2>）。

我们现在将继续第3.3节。

# 3.3 — 变异

变异可以是单基因型的（涉及单一基因型）或双基因型的（涉及两个基因型）。目标是得到新的基因型，期望它们的适应度高于前任基因型。

统计学帮助我们实现这一希望。纯粹通过运气，某些基因型可能更好，而其他的可能更差。通过与父本选择（第3.2节）和生存选择（第3.4节）协同工作，“成功”的次数远远超过“失败”。

在第3.3.1节和第3.3.2节中，我们关注对**基于排列的基因型**的变异。

从技术上讲，重组过程可以涉及两个以上的父本，但更多并不一定更好[1]，本文的范围保持在两个父本。

# 3.3.1 — 重组

这涉及两个父本基因型。

与可以使用单点或多点交叉进行重组的二进制表示不同，排列表示的重组并不那么简单。

![](../Images/25c5ed543025bc665d13bd5d52aa0a24.png)

对基于排列的基因型进行强制交叉的结果。

假设我们有一个从0到5的排列，来自两个父本（一个是红色的，另一个是粉色的）。一次交叉会导致某些索引的重复，以及其他索引的缺失。这不能成为TSP的解决方案。

我们做的是应用部分映射交叉。

在下面的示例中，第一个后代[0, 1, 3, 5, 2, 4]是从第一个（红色）父本的左侧部分中获得的，保持原样，并与第二个（粉色）父本中尚未使用的索引组合，保持相对顺序。这给我们带来了[0, 1]（来自红色）和[3, 5, 2, 4]（来自粉色）的组合。

![](../Images/2cd36cc77305b66e82d58d77671badf3.png)

部分映射交叉的过程。图片由作者提供。

动机如下：

1.  红色父本[**0**，**1**，4，3，5，2]已经具有良好的（或至少是不错的）适应度，因此被选择作为父本。

1.  保留基因型的一部分并打乱其余部分可能会导致改进。

1.  我们利用粉色父本[**3**，**5**，1，**2**，0，**4**]也有良好的适应度——它访问了3，然后是5，然后是2，然后是4。

1.  我们不是随机打乱红色父本的尾部，而是按照粉色父本访问的顺序对其进行打乱。

当两个父本互换时，情况也是如此。因此，得到了两个后代。

请注意，切割可以在基因型的任何位置发生，概率相等。如果切割只在中间进行，我们就会失去在随后的代中获得多样化后代的机会。没有人能确定前半部分是理想的并且应该保留——它可能只是前四分之一，或者也许是前三分之四。因此，所有选项都应保留，最终交给统计学处理。

# 3.3.2 — 突变

仍然在进化算法的‘**变异**’方面，我们转向适用于个体基因型的变化。

![](../Images/0e6a3ee425f7ac3fca12d699ee620d30.png)

基于排列的基因型可能发生的突变。

如果基因型包含一个排列序列，所应用的变化必须涉及某种重新排序。执行位翻转或增加/减少单个数字是不切实际的。

一种方法是随机选择一个数字（例如，“2”）并将其移到序列的开始或结束。另一种方法是随机选择两个数字并交换它们的位置。

这里的想法是对单个基因型做出最小的改动，希望使一个已经很好的解决方案变得更好。这种变异在解决方案几乎完美的情况下尤其有用，只有某一点不太对。

这是第3.3.1节（重组）和第3.3.2节（突变）的代码。

[PRE0]

# 3.4 — 生存选择

在广泛讨论了父代选择和变异之后，我们进入进化算法的第三个支柱，即选择哪些个体进入下一代。

第一种方法是将所有父代和后代放在一起，选择最适应的个体来填充下一代。这里的问题是我们在“稀释”进化效果。在经历了父代选择、重组和突变之后，产生的后代中有相当一部分会被丢弃。这其中有些“*前进两步，后退一步*”的成分。

第二种方法是（在一定程度上）模仿自然。所有父代将“死亡”并从种群中消失，下一代完全由后代组成。这里的问题是最好的后代不一定比最好的父代更好——移除所有父代可能会让我们离理想解决方案更远。

因此，通常会采取中间道路。我们从父代中选择最好的个体，并对它们的副本进行突变，希望通过一些扰动进一步改进解决方案。然后，我们生成足够的后代以填补下一代剩余的位置，而不会丢弃任何个体。

具体来说，在第3.3节的`##... 精英策略；保留最佳个体及其变体 ...`组件中，我们可以做如下操作：

[PRE1]

# 3.5 — 终止

也许你的公司要求你应用进化算法解决一个行业问题，并且有一个预算限制。或者，你知道最佳目标值（但不知道给出这个值的解决方案）。

在这种情况下，一旦结果足够好，可能需要进行提前终止。

如果没有特定的数字需要寻找，并且我们不确定什么是“足够好”，一种方法是当在一定代数中改进量小于某个阈值时停止迭代。

如果资源不是问题，那么你应该关注的是*过早*终止，而不是*过晚*终止。进行额外的迭代并运行更多的进化是有益的。就像在深度学习中一样，我们会保留与最佳迭代对应的解决方案，而不是最后的迭代。

# 4\. 获得结果

## 4.1 表示TSP

让我们为旅行销售员问题构建一个类，以简化实施过程。

[PRE2]

## 4.2 训练和观察

将上述代码片段组合成一个单一的`Evolutionary`类，然后可以应用以下方法来找到TSP的解决方案。

[PRE3]

如果你保存了中间结果，你可以使用我分享的代码[这里](https://medium.com/towards-data-science/a-cornerstone-of-rl-td-%CE%BB-and-3-big-names-2e547b37c05)将截图图像组合成一个gif。

恭喜！你现在具备了使用进化算法解决NP难题的知识。

这与文章开头展示的gif相同。这是上述代码共享的结果。

# 结论

在这篇文章中，你了解了进化算法的运行原理，以及每个组件的功能。除了高层次的概念，我们还深入探讨了实现过程，配以可视化、代码和具体数据。

# 参考文献

[1] A. E. Eiben, P. E. Raue, 和 Z. Ruttkay, [具有多父代重组的遗传算法](https://link.springer.com/chapter/10.1007/3-540-58484-6_252) (1994)，在国际并行问题解决自然会议上
