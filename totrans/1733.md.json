["```py\nclass MyClass:\n    pass\n```", "```py\nclass MyClass:\n    def __init__(self, value):\n        self.value = value\n```", "```py\ndef foo(x: MyClass, n: int) -> list[MyClass]:\n    return [x] * n\n```", "```py\nclass MyClass(dict):\n    @staticmethod\n    def say_hello(self):\n        print(\"Hello!\")\n```", "```py\n>>> class StrAndRepr:\n...     def __repr__(self): return f\"I am __repr__\"\n...     def __str__(self): return \"I am __str__\"\n>>> str_and_repr = StrAndRepr()\n>>> str_and_repr\nI am __repr__\n>>> print(str_and_repr)\nI am __str__\n```", "```py\n>>> class MyClass: ...\n>>> inst = MyClass()\n>>> inst.__repr__()\n'<__main__.MyClass object at 0x7f...>'\n>>> inst.__str__()\n'<__main__.MyClass object at 0x7f...>'\n>>> inst.__repr__() == repr(inst)\nTrue\n>>> inst.__str__() == str(inst)\nTrue\n```", "```py\n>>> str(inst) == repr(inst)\nTrue\n```", "```py\n>>> class StrAndRepr:\n...     def __repr__(self): return \"I am repr of StrAndRepr\"\n...     def __str__(self): return \"I am str of StrAndRepr\"\n>>> class OnlyStr:\n...     def __str__(self): return \"I am str of OnlyStr\"\n>>> class OnlyRepr:\n...     def __repr__(self): return \"I am repr of OnlyRepr\"\n>>> class NeietherStrNorRepr: ...\n```", "```py\n>>> str_and_repr = StrAndRepr()\n>>> str(str_and_repr)\n'I am str of StrAndRepr'\n>>> repr(str_and_repr)\n'I am repr of StrAndRepr'\n\n>>> only_str = OnlyStr()\n>>> str(only_str)\n'I am str of OnlyStr'\n>>> repr(only_str)\n'<__main__.OnlyStr object at 0x7f...>'\n\n>>> only_repr = OnlyRepr()\n>>> str(only_repr)\n'I am repr of OnlyRepr'\n>>> repr(only_repr)\n'I am repr of OnlyRepr'\n\n>>> neither_str_nor_repr = NeietherStrNorRepr()\n>>> str(neither_str_nor_repr)\n'<__main__.NeietherStrNorRepr object at 0x7...>'\n>>> repr(neither_str_nor_repr)\n'<__main__.NeietherStrNorRepr object at 0x7f...>'\n```", "```py\ndef __repr__(self) -> str:\n    ...\n\ndef __str__(self) -> str:\n    ...\n```", "```py\n>>> class StrWithParams:\n...     def __str__(self, value):\n...         return f\"StrWithParams with value of {value}\"\n```", "```py\n>>> inst = StrWithParams()\n>>> inst.__str__(10)\n'StrWithParams with value of 10'\n```", "```py\n>>> str(inst, value=10)\nTraceback (most recent call last):\n    ...\nTypeError: 'value' is an invalid keyword argument for str()\n>>> print(inst)\nTraceback (most recent call last):\n    ...\nTypeError: StrWithParams.__str__() missing 1 required positional argument: 'value'\n>>> print(inst, value=10)\nTraceback (most recent call last):\n    ...\nTypeError: 'value' is an invalid keyword argument for print()\n```", "```py\n>>> inst\n<__main__.StrWithParams object at 0x7f...>\n```", "```py\n>>> class StrNotStr:\n...     def __str__(self):\n...         return 10\n>>> inst = StrNotStr()\n>>> inst.__str__()\n10\n>>> str(inst)\nTraceback (most recent call last):\n    ...\nTypeError: __str__ returned non-string (type int)\n```", "```py\n>>> class ReprWithParams:\n...     def __repr__(self, value):\n...         return f\"ReprWithParams with value of {value}\"\n>>> inst = ReprWithParams()\n>>> inst.__repr__(10)\n'ReprWithParams with value of 10'\n>>> repr(inst, value=10)\nTraceback (most recent call last):\n    ...\nTypeError: repr() takes no keyword arguments\n>>> inst\nTraceback (most recent call last):\n    ...\nTypeError: ReprWithParams.__repr__() missing 1 required positional argument: 'value'\n\n>>> class ReprNotStr:\n...     def __repr__(self):\n...         return 10\n>>> inst = ReprNotStr()\n>>> inst.__repr__()\n10\n>>> repr(inst)\nTraceback (most recent call last):\n    ...\nTypeError: __repr__ returned non-string (type int)\n```", "```py\nfrom typing import Optional\n\nclass Point:\n    def __init__(\n        self,\n        x: float,\n        y: float,\n        group: Optional[str] = None,\n        comment: Optional[str] = None) -> None:\n        self.x = x\n        self.y  = y\n        self.group = group\n        self.comment = comment\n\n    def distance(self, other: \"Point\") -> float:\n        \"\"\"Calculates the Euclidean distance between two Point instances.\n\n        Args:\n            other: Another Point instance.\n\n        Returns:\n            The distance between two Point instances, as a float.\n\n        >>> p1 = Point(1, 2)\n        >>> p2 = Point(3, 4)\n        >>> p1.distance(p2)\n        2.8284271247461903\n        >>> p1.distance(Point(0, 0))\n        2.23606797749979\n        \"\"\"\n        dx = self.x - other.x\n        dy = self.y - other.y\n        return (dx**2 + dy**2)**.5\n\n    def __str__(self) -> str:\n        \"\"\"String representation of self.\n\n        >>> p1 = Point(1, 2, \"c\", \"Needs checking\")\n        >>> p1\n        Point(x=1, y=2, group=c)\n        Comment: Needs checking\n        >>> print(p1)\n        Point(1, 2, c)\n\n        When group is None, __str__() and __repr__() will\n        provide different representations:\n        >>> p2 = Point(1, 2, None)\n        >>> p2\n        Point(x=1, y=2, group=None)\n        >>> print(p2)\n        Point(1, 2)\n        \"\"\"\n        if self.group is not None:\n            return f\"Point({self.x}, {self.y}, {self.group})\"\n        return f\"Point({self.x}, {self.y})\"\n\n    def __repr__(self) -> str:\n        msg = (\n            f\"Point(x={self.x}, y={self.y}, \"\n            f\"group={self.group})\"\n        )\n        if self.comment is not None:\n            msg += (\n                \"\\n\"\n                f\"Comment: {self.comment}\"\n            )\n        return msg\n\n    def __eq__(self, other) -> bool:\n        \"\"\"Compare self with another object.\n\n        Group must be provided for comparisons.\n        Comment is not used.\n\n        >>> Point(1, 2, \"g\") == 1\n        False\n        >>> Point(1, 2, \"c\") == Point(1, 2, \"c\")\n        True\n        >>> Point(1, 2) == Point(1, 2)\n        False\n        >>> Point(1, 2) == Point(1, 3, \"s\")\n        False\n        \"\"\"\n        if not isinstance(other, Point):\n            return False\n        if self.group is None:\n            return False\n        return (\n            self.group == other.group\n            and self.x == other.x\n            and self.y == other.y\n        )\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n```", "```py\n>>> p1 = Point(1, 2, \"c\", \"Needs checking\")\n>>> p1\nPoint(x=1, y=2, group=c)\nComment: Needs checking\n>>> print(p1)\nPoint(1, 2, c)\n```", "```py\nPoint(x=1, y=2, group=c)\nComment: Needs checking\n```", "```py\n'Point(1, 2, c)'\n```", "```py\n>>> str(p1)\n'Point(1, 2, c)'\n>>> p1_recreated_from_str = Point(1, 2, \"c\")\n>>> p1\nPoint(x=1, y=2, group=c)\nComment: Needs checking\n>>> p1_recreated_from_str\nPoint(x=1, y=2, group=c)\n```", "```py\n>>> p1 == p1_recreated_from_str\nTrue\n```", "```py\n>>> p1\nPoint(x=1, y=2, group=c)\nComment: Needs checking\n>>> p1_recreated_from_repr = Point(\n...     1, 2, \"c\", comment=\"Needs checking\")\n>>> p1_recreated_from_repr\nPoint(x=1, y=2, group=c)\nComment: Needs checking\n```"]