["```py\n# setting the random seed for reproducibility\nimport random\nrandom.seed(493)\n\n# for reading the xml file\nimport xml.etree.ElementTree as ET\n\n# for manipulating dataframes\nimport pandas as pd\nimport numpy as np\n\n# for working with timestamps\nimport datetime as dt\nfrom dateutil.parser import parse\n\n# for modeling\nfrom sklearn import preprocessing\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.model_selection import train_test_split\nfrom imblearn.over_sampling import SMOTE\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.metrics import classification_report\nfrom sklearn.metrics import roc_auc_score\nfrom sklearn.metrics import roc_curve\nfrom sklearn import metrics\n\n# for time-series forecasting\nimport matplotlib.pyplot as plt\nfrom prophet import Prophet\n\n# for visualizations\n%matplotlib inline\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nsns.set(style=\"whitegrid\")\n\n# to print out all the outputs\nfrom IPython.core.interactiveshell import InteractiveShell\nInteractiveShell.ast_node_interactivity = \"all\"\n\n# set display options\npd.set_option('display.max_columns', None)\npd.set_option('display.max_rows', None)\npd.set_option('display.max_colwidth', None)\n```", "```py\n# create element tree object\ntree = ET.parse('export.xml')\n\n# extract the attributes for every health record\nroot = tree.getroot()\nrecord_list = [x.attrib for x in root.iter('Record')]\n```", "```py\n# create the dataframe\ndf = pd.DataFrame(record_list)\n```", "```py\n# shorter observation names\ndf['type'] = df['type'].str.replace('HKQuantityTypeIdentifier', '')\ndf['type'] = df['type'].str.replace('HKCategoryTypeIdentifier', '')\n```", "```py\ndf['type'].value_counts()\n```", "```py\ndf1 = df.loc[df['type'] == 'BloodGlucose']\ndf1 = df1[['startDate', 'value']]\n```", "```py\ndf1[\"startDate\"] = pd.to_datetime(df1[\"startDate\"])\n\n# value is numeric, NaN if fails\ndf1['value'] = pd.to_numeric(df1['value'], errors='coerce')\n\n# some records do not measure anything, just count occurences\n# filling with 1.0 (= one time) makes it easier to aggregate\ndf1['value'] = df1['value'].fillna(1.0)\n```", "```py\ndf1.to_csv('blood_glucose.csv', index=False)\n```", "```py\n# rename date column\ndf2 = df1.rename(columns={'startDate':'timestamp'})\n\n# extract time components from the timestamp column\ndf2['year'] = df2.timestamp.dt.year\ndf2['month'] = df2.timestamp.dt.month\ndf2['day'] = df2.timestamp.dt.day\ndf2['hour'] = df2.timestamp.dt.hour\n\n# extract time attributes from the timestamp column\ndf2['day_of_year'] = df2.timestamp.dt.dayofyear\ndf2['week_of_year'] = df2.timestamp.dt.weekofyear\ndf2['day_of_week'] = df2.timestamp.dt.dayofweek\n```", "```py\n# extract weekday characteristic from the day of the week column\ndf2['weekday'] = np.where(df2['day_of_week'] < 5, True, False)\n\n# extract part of the day from the hour column\ndef get_day_period(x):\n    if x in range(6,12):\n        return 'Morning'\n    elif x in range(12,18):\n        return 'Afternoon'\n    elif x in range(18,23):\n        return 'Evening'\n    else:\n        return 'Late night'\n\ndf2['part_of_day'] = df2['hour'].apply(get_day_period)\n```", "```py\n# extract blood glucose level from the value column\ndef get_status(row):\n    if row['value'] < 70:\n        val = \"Low\"\n    elif row['value'] <= 180:\n        val = \"Normal\"\n    else:\n        val = \"High\"\n    return val\n\ndf2['status'] = df2.apply(get_status, axis=1)\n```", "```py\n# creates a new column and designates a row as either high or low\ndf2['high'] = np.where(df2['status'] != 'High', '0', '1').astype('int32')\n```", "```py\ndf2 = df2.drop(columns=['status', 'timestamp'])\n```", "```py\nplt.rcParams[\"figure.figsize\"] = [10, 6]\nplt.rcParams[\"figure.autolayout\"] = True\n```", "```py\nshow_values(df2, ['year'])\n```", "```py\nyears = [2020, 2021, 2022, 2023]\n```", "```py\ndef show_violin(df, year):\n    ax = sns.violinplot(x=\"part_of_day\",\n                        y=\"value\",\n                        hue=\"weekday\",\n                        split=True,\n                        data=df[df['year'] == year],\n                        order=['Morning', 'Afternoon', 'Evening', 'Late night'])\n    ax.set_title('Distribution of Blood Glucose Value per Part of the Day ' + str(year), fontsize=16)\n\n    # Set label for x-axis\n    plt.ylabel( \"Blood Glucose\" , size = 12 )\n    plt.xlabel( \"Part of the Day\" , size = 12 )\n\n    plt.legend(title='Weekday?', loc='upper right')\n    plt.show()\n```", "```py\nfor year in years:\n    show_violin(df2, year)\n```", "```py\ndef show_violin_no_legend(df, year):\n    ax = sns.violinplot(x=\"part_of_day\",\n                        y=\"value\",\n                        hue=\"weekday\",\n                        split=True,\n                        data=df[df['year'] == year],\n                        order=['Morning', 'Afternoon', 'Evening', 'Late night'])\n    ax.set_title('Distribution of Blood Glucose Value per Part of the Day Over the Years', fontsize=16)\n\n    # Set label for x-axis\n    plt.ylabel( \"Blood Glucose\" , size = 12 )\n    plt.xlabel( \"Part of the Day\" , size = 12 )\n    ax.get_legend().remove()\n```", "```py\ndf3 = df2.drop(columns=['value'])\n```", "```py\ncategorical_vars = ['month', 'weekday', 'part_of_day']\n\nfor var in categorical_vars:\n    cat_list='var'+'_'+var\n    cat_list = pd.get_dummies(df3[var], prefix=var)\n    dfx=df3.join(cat_list)\n    df3=dfx\n\ndata_vars=df3.columns.values.tolist()\nto_keep=[i for i in data_vars if i not in categorical_vars]\n\ndf4=df3[to_keep]\ndf4.columns.values\n```", "```py\nshow_values(df4, ['high'])\n```", "```py\nX = df4.loc[:, df4.columns != 'high']\ny = df4.loc[:, df4.columns == 'high']\n\nos = SMOTE(random_state=493)\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=493)\n\ncolumns = X_train.columns\nos_data_X,os_data_y=os.fit_resample(X_train, y_train)\nos_data_X = pd.DataFrame(data=os_data_X,columns=columns )\nos_data_y= pd.DataFrame(data=os_data_y,columns=['high'])\n\n# we can check the numbers of our data\nprint(\"length of oversampled data is \",len(os_data_X))\nprint(\"Number of no subscription in oversampled data\",len(os_data_y[os_data_y['high']==0]))\nprint(\"Number of subscription\",len(os_data_y[os_data_y['high']==1]))\nprint(\"Proportion of no subscription data in oversampled data is \",len(os_data_y[os_data_y['high']==0])/len(os_data_X))\nprint(\"Proportion of subscription data in oversampled data is \",len(os_data_y[os_data_y['high']==1])/len(os_data_X))\n```", "```py\ncols=['hour',\n 'month_1',\n 'month_2',\n 'month_3',\n 'month_4',\n 'month_5',\n 'month_6',\n 'month_7',\n 'month_8',\n 'month_9',\n 'month_10',\n 'month_11',\n 'month_12',\n 'weekday_False',\n 'weekday_True',\n 'part_of_day_Afternoon',\n 'part_of_day_Evening',\n 'part_of_day_Late night',\n 'part_of_day_Morning']\n```", "```py\nX=os_data_X[cols]\ny=os_data_y['high']\n```", "```py\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=493)\n\nlogreg = LogisticRegression(solver=\"liblinear\")\nlogreg.fit(X_train, y_train)\n```", "```py\ny_pred = logreg.predict(X_test)\nprint('Accuracy of logistic regression classifier on test set: {:.2f}'.format(logreg.score(X_test, y_test)))\n```", "```py\nconfusion_matrix = confusion_matrix(y_test, y_pred)\nprint(confusion_matrix)\n```", "```py\ndf5 = pd.read_csv('blood_glucose.csv', parse_dates=True, infer_datetime_format=True)\n```", "```py\ndf5 = df5.rename(columns={'startDate':'ds', 'value':'y'})\n```", "```py\ndf5[\"ds\"] = pd.to_datetime(df5[\"ds\"])\ndf5['ds'] = df5['ds'].dt.tz_localize(None)\n```", "```py\ndf6=df5.set_index('ds').resample('D').agg(y=('y', 'mean'))\ndf6 = df6.reset_index()\n```", "```py\nmodel = Prophet()\nmodel.fit(df6)\ndf6_forecast = model.make_future_dataframe(periods=12, freq='MS')\ndf6_forecast = model.predict(df6_forecast)\nplt.figure(figsize=(18, 6))\nmodel.plot(df5_forecast, xlabel = 'Timestamp', ylabel = 'Glucose')\nplt.title('Blood Glucose')\n```", "```py\nmodel.plot_components(df6_forecast)\n```"]