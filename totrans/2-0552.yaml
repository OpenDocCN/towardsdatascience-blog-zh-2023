- en: 'Enabling a Marketplace for AI Agents: Discovery and Matchmaking'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/constraints-composition-for-autogpt-240a3fa00ab4](https://towardsdatascience.com/constraints-composition-for-autogpt-240a3fa00ab4)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Discovery of AI Agents capable of executing a given User Task
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://debmalyabiswas.medium.com/?source=post_page-----240a3fa00ab4--------------------------------)[![Debmalya
    Biswas](../Images/4b985e2a5b362a4b962d3ad29665dfea.png)](https://debmalyabiswas.medium.com/?source=post_page-----240a3fa00ab4--------------------------------)[](https://towardsdatascience.com/?source=post_page-----240a3fa00ab4--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----240a3fa00ab4--------------------------------)
    [Debmalya Biswas](https://debmalyabiswas.medium.com/?source=post_page-----240a3fa00ab4--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----240a3fa00ab4--------------------------------)
    ·8 min read·May 2, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/31436955cfbacc8502f3d448e3a5df24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig: Exploring the unknown by Soma Biswas ([Flickr](https://www.flickr.com/photos/somabiswas/52006785817/in/dateposted/),
    republished with permission)'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The discussion around ChatGPT, has now evolved into AutoGPT. While ChatGPT [1]
    is primarily a Chatbot that can generate text responses, AutoGPT is a more powerful
    AI Agent that can execute complex tasks, e.g., make a sale, plan a trip, make
    a flight booking, book a contractor to do a house job, order a pizza.
  prefs: []
  type: TYPE_NORMAL
- en: AutoGPT follows a long history of research around Autonomous Agents, especially,
    Goal Oriented Agents [2, 3].
  prefs: []
  type: TYPE_NORMAL
- en: Given a user task, AutoGPT aims to identify (compose) an agent (group of agents)
    capable to executing the given task.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'A high-level approach to solving such complex tasks involves: (a) decomposition
    of the given complex task into (a hierarchy or workflow of) simple tasks, followed
    by (b) composition [4] of agents able to execute the simple(r) tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: This can be achieved in a **dynamic** or **static** manner. In the dynamic approach,
    given a complex user task, the system comes up with a plan to fulfill the request
    depending on the capabilities of available agents at run-time. In the static approach,
    given a set of agents, composite agents are defined manually at design-time combining
    their capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: The main focus of this article is on the discovery aspect of agents, i.e., identifying
    the agent(s) capable of executing a given task. This implies that there exists
    a marketplace / registry of agents, with a well-defined description of the agent
    capabilities and constraints.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We outline a Constraints Model to capture/specify the constraints of services
    provided by an AI Agent inSection **2**. We have seen similar efforts in the past
    before with Web Services — Universal Description, Discovery and Integration (UDDI)registries
    and API marketplaces. However, the descriptions captured in XML or JSON are too
    static, and lack the necessary semantic information for a capabilities / task
    requirements “negotiation” during their discovery.
  prefs: []
  type: TYPE_NORMAL
- en: '***For example****,*let us consider a House Painting Agent *C* whose services
    can be reserved online (via credit card). Given this, the fact that the user requires
    a valid credit card is a constraint, and the fact that the user’s house will be
    painted within a certain timeframe are its capabilities. In addition, we also
    need to consider any constraints of *C* during the actual execution phase, e.g.,
    the fact that *C* can only provide the service on weekdays (and not on weekends).
    The above restriction might be a problem if the user specified task requires getting
    the work done during weekends. In general, constraints refer to the conditions
    that need to be satisfied to initiate an execution and capabilities reflect the
    expected outcome after the execution terminates.'
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Agent Constraints Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 2.1 Constraints Specification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An agent P provides a set of services *{S_1, S_2, . . . , S_n}*. Each service
    S in turn has a set of associated constraints *{C_1, C_2, . . . , C_m}*. The constraints
    are specified as **logic predicates** in the service description of the corresponding
    service published by its agent. For each constraint C of a service S, the constraint
    values maybe
  prefs: []
  type: TYPE_NORMAL
- en: a single value (e.g., price of a service),
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: list of values (e.g., list of destinations served by an airline), or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: range of values (e.g., minimum and maximum values).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The constraint values are specified as facts containing the applicable values.
    More precisely, a service S provided by P having constraints *{C_1, C_2, . . .
    , C_m}* is specified as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '*S(Y, X_1, X_2, . . . , X_m):-'
  prefs: []
  type: TYPE_NORMAL
- en: C_1(Y, X_1),
  prefs: []
  type: TYPE_NORMAL
- en: C_2(Y, list_2), member(X_2, list_2),
  prefs: []
  type: TYPE_NORMAL
- en: . . .,
  prefs: []
  type: TYPE_NORMAL
- en: C_m(Y, minVal_m, maxVal_m), X_m ≥ minVal_m, X_m ≤ maxVal_m.
  prefs: []
  type: TYPE_NORMAL
- en: C_1(P, value(C_1)).
  prefs: []
  type: TYPE_NORMAL
- en: C_2(P, list(C_2)).
  prefs: []
  type: TYPE_NORMAL
- en: . . .
  prefs: []
  type: TYPE_NORMAL
- en: C_m(P, min(C_m), max(C_m)).*
  prefs: []
  type: TYPE_NORMAL
- en: '**For example**, the fact that an airline ABC provides vegetarian meals and
    has facilities for handicapped people on only some of its flights (to selected
    destinations) can be represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*flight(Airlines,X,Y):-'
  prefs: []
  type: TYPE_NORMAL
- en: veg_meals(Airlines, Destination_List), member(X, Destination_List),
  prefs: []
  type: TYPE_NORMAL
- en: hnd_facilities(Airlines, Destination_List), member(Y, Destination_List).
  prefs: []
  type: TYPE_NORMAL
- en: veg_meals(‘ABC’, [‘Paris’, ‘Rennes’]).
  prefs: []
  type: TYPE_NORMAL
- en: hnd_facilities(‘ABC’, [‘Paris’, ‘Grenoble’]).*
  prefs: []
  type: TYPE_NORMAL
- en: 'In the above snippet, ‘member(X,Y)’ is a system defined predicate which holds
    if X is an element of the set Y. Now, let us consider “related” constraints or
    scenarios where there exists a relationship among the constraints. By default,
    the above example assumes an AND relation among the constraints (both veg_meals
    and hnd_facilities predicates have to be satisfied). The operators studied in
    literature for the composition of logic programs are: AND, OR, ONE-OR-MORE, ZERO-OR-MORE
    and any nesting of the above.'
  prefs: []
  type: TYPE_NORMAL
- en: We only consider the operators AND, OR and any level of nesting of both to keep
    the framework simple (ONE-OR-MORE and ZERO-OR-MORE can be expressed in terms of
    OR).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'An example of an OR relation among the constraints is as follows: Airline ABC
    allows airport lounge access at intermediate stopovers only if the passenger holds
    a business class ticket or is a member of their frequent flier programme. The
    above scenario can be represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*lounge_access(Airlines, X):-'
  prefs: []
  type: TYPE_NORMAL
- en: ticket_type(‘ABC’, X, ’Business’).
  prefs: []
  type: TYPE_NORMAL
- en: lounge_access(Airlines, Y):-
  prefs: []
  type: TYPE_NORMAL
- en: frequent_flier(Airlines, FF_List), member(Y, FF_List).*
  prefs: []
  type: TYPE_NORMAL
- en: 'We briefly consider the following qualifiers which may be specified in conjunction
    with the constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Validity period*: Period until when the constraints are valid. The validity
    period qualifier can be used to optimize matchmaking. Basically, there is no need
    to repeat the entire matchmaking process for each and every request. Once an agent/service
    provider is found suitable, it remains so until the validity period of at least
    one of its “relevant” constraints expires.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Accountability*: The commitment of an agent towards providing a specific service
    (levels of commitment). For example, an agent may be willing to accept the responsibility
    of providing its advertised services under any circumstance; or that it is capable
    of providing the services, but not willing to accept responsibility if something
    goes wrong.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Non-functional*: Qualifiers related to non-functional aspects, such as, transactions,
    security, monitoring (performance), etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.2 Constraints Composition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The composite agent aggregates services offered by different agents and provides
    a unique interface to them (without any modification to the capabilities of the
    services, as such). In other words, the composite agent acts as a broker for the
    aggregated set of services.
  prefs: []
  type: TYPE_NORMAL
- en: The aggregated services may have different capabilities or the same capability
    with different constraints (as shown by the following example scenario).
  prefs: []
  type: TYPE_NORMAL
- en: '**Scenario**: Agent XYZ composing the flight services offered by Airlines ABC
    and DEF.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Airlines ABC:'
  prefs: []
  type: TYPE_NORMAL
- en: '*flight(Airlines, X):-'
  prefs: []
  type: TYPE_NORMAL
- en: hnd_facilities(Airlines, Destination_List), member(X, Destination_List).
  prefs: []
  type: TYPE_NORMAL
- en: hnd_facilities(‘ABC’, [‘Marseilles’, ‘Grenoble’]).*
  prefs: []
  type: TYPE_NORMAL
- en: 'Airlines DEF:'
  prefs: []
  type: TYPE_NORMAL
- en: '*flight(Airlines, X):-'
  prefs: []
  type: TYPE_NORMAL
- en: hnd_facilities(Airlines, Destination_List), member(X, Destination_List).
  prefs: []
  type: TYPE_NORMAL
- en: hnd_facilities(‘DEF’, [‘Rennes’, ‘Paris’]).*
  prefs: []
  type: TYPE_NORMAL
- en: 'Composite Agent XYZ:'
  prefs: []
  type: TYPE_NORMAL
- en: '*flight(Airlines, X):-'
  prefs: []
  type: TYPE_NORMAL
- en: hnd_facilities(Airlines, Destination_List), member(X, Destination_List),
  prefs: []
  type: TYPE_NORMAL
- en: Airlines:= ‘XYZ’.
  prefs: []
  type: TYPE_NORMAL
- en: hnd_facilities(‘ABC’, [‘Marseilles’, ‘Grenoble’]).
  prefs: []
  type: TYPE_NORMAL
- en: flight(Airlines, X):-
  prefs: []
  type: TYPE_NORMAL
- en: hnd_facilities(Airlines, Destination_List), member(X, Destination_List),
  prefs: []
  type: TYPE_NORMAL
- en: Airlines:= ‘XYZ’.
  prefs: []
  type: TYPE_NORMAL
- en: hnd_facilities(‘DEF’, [‘Rennes’, ‘Paris’]).*
  prefs: []
  type: TYPE_NORMAL
- en: The addition of the clauses Airlines:= ‘XYZ’ in the above snippet ensures that
    the binding returned to the outside world is agent XYZ while the agent XYZ internally
    delegates the actual processing to the agents ABC/DEF. Another point highlighted
    by the above example is that
  prefs: []
  type: TYPE_NORMAL
- en: composition may lead to relaxation of constraints, e.g., the composite agent
    XYZ can offer flights with facilities for handicapped people to more destinations
    (Marseilles, Grenoble, Rennes and Paris) than offered by either of the component
    agents ABC (Marseilles, Grenoble)/DEF (Rennes, Paris).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 3\. Agent Services Discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**3.1 Matchmaking**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a user task G, matchmaking consists of finding agents capable of executing
    G’s (sub-)tasks. The (sub-)tasks of G might have their own constraints. Given
    this,
  prefs: []
  type: TYPE_NORMAL
- en: the required matchmaking for G can be achieved with the help of a logic program
    execution engine by posing (tasks of) G’s constraints as a goal against the logic
    program corresponding to the service constraints of the respective agents.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A logic program execution engine specifies, not only if a goal can be satisfied,
    but also all the possible bindings for any unbounded variables of the goal. In
    case of multiple possible bindings (multiple agents capable of executing the same
    task), the agents can be ranked using some user defined preference criteria or
    the user may be consulted directly to select the most optimum among them.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2 Approximate Matchmaking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we consider the scenario where matchmaking was unsuccessful,
    i.e., there does not exist a set of agents capable of executing the given task
    G.
  prefs: []
  type: TYPE_NORMAL
- en: Given this, it makes sense to allow some inconsistency while selecting an agent.
    Note that inconsistency is often allowed by real-life systems, e.g. flight reservation
    systems allow flights to be overbooked, but only up to a limited number of seats.
    Thus, the key here is **bounded inconsistency**.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, for a goal *G = {T_1, T_2, . . . , T_n}*, the selected agent for
    one of the tasks T_i does not have to be a perfect match as long as their accumulated
    inconsistency is within a specified limit. Note that the inconsistency induced
    by an agent may also have a counter effect on (reduce) the inconsistency induced
    by another task T_j .
  prefs: []
  type: TYPE_NORMAL
- en: 'For a given goal *G = {T_1, T_2, . . . , T_n}*, approximate matchmaking can
    be achieved as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Determine the common constraints*: A constraint *C* is common with respect
    to *G*, if more than one task of *G* has constraints based on *C*. For example,
    if tasks *T_1* and *T_2* need to be completed within 3 and 4 days respectively,
    then they have a common time based constraint. Studies have shown that most constraints
    in real-life scenarios are based on the constraints: location, price, quantity
    or time.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each common constraint *C*, define a temporary variable *q_C* (to keep track
    of the inconsistency with respect to *C*). Initially, *q_C = 0*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For each task *T_i* and a common constraint *C*: Let *vC_i* denote the constraint
    value of *T_i* with respect to *C*. For example, *vTime_1 = 3* denotes the completion
    time constraint value of *T_1*. Delete the C constraint of *T_i* from the constraints
    specification of *G*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform matchmaking based on the reduced goal (with the common constraint predicates
    deleted in the above step).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the matchmaking was successful: [Note that if matchmaking was unsuccessful
    for the reduced goal, then it would definitely have been unsuccessful for the
    original goal.] Let *P(T_i)* denote the agent selected to execute *T_i*. For each
    deleted common constraint *C* of *T_i* (Step 3), get the best possible constraint
    value *vBestC_i* of *P(T_i)*, and compute *q_C = q_C + (vC_i − vBestC_i)*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For example, let us assume that *P(T_1)* and *P(T_2)* need at least 5 and 1
    days, respectively to complete their work. Given this, *q_t = 0 + (vC_1 − vBestC_1)
    + (vC_2 − vBestC_2) = (3 − 5) + (4 − 1) = 1*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The matchmaking results are valid if and only if for each common constraint
    *C, q_C > 0*. For example, *P(T_1)* and *P(T_2)* are valid matches for the tasks
    *T_1* and *T_2* respectively, as *q_t > 0*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that this matching would not have been possible without the (approximate)
    extension as *P(T_1)* violates (takes 5 days) the completion time constraint (3
    days) of *T_1*. For simplicity, we have only considered numeric value based constraints
    in the above algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this article, we focused on the discovery aspect of Autonomous AI Agents.
    To execute a complex task, a pre-requisite is a registry of agents, specifying
    their service( s) capabilities and constraints. We outlined a constraints based
    model to specify agent services.
  prefs: []
  type: TYPE_NORMAL
- en: We showed how the constraints of a composite agent can be derived and described
    in a manner consistent with respect to the constraints of its component agents.
    Finally, we discussed approximate matchmaking, and showed how the notion of bounded
    inconsistency can be exploited to discover agents more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: D. Biswas. *ChatGPT, and its Enterprise Applications*. ([Data Driven Investor](https://medium.datadriveninvestor.com/will-chatgpt-disrupt-enterprise-ai-7b83b7591c1e))
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A. Bordes, et. al. *Goal oriented Chatbots: Learning End-to-End Goal-Oriented
    Dialog, 2016* ([article](https://arxiv.org/abs/1605.07683))'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'E. Ricciardelli, D. Biswas. *Self-improving Chatbots based on Reinforcement
    Learning*. in: 4th Multidisciplinary Conference on Reinforcement Learning and
    Decision Making, 2019 ([Towards Data Science](/self-improving-chatbots-based-on-reinforcement-learning-75cca62debce))'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'D. Biswas. *Compositional AI: The Future of Enterprise AI*. 2021 ([Towards
    Data Science](/compositional-ai-the-future-of-enterprise-ai-3d5289dfa888))'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: F. Casati, et. al. *Adaptive and Dynamic Service Composition in eFlow*. HP Technical
    Report, HPL-2000–39, March, 2000.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'J.S. Park, et. al. *Generative Agents: Interactive Simulacra of Human Behavior,*
    2023([article](https://arxiv.org/abs/2304.03442))'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Related articles in the **ChatGPT/AutoGPT** series:'
  prefs: []
  type: TYPE_NORMAL
- en: D. Biswas*. ChatGPT, and its implications for Enterprise AI.* ([Data Driven
    Investor](https://medium.datadriveninvestor.com/will-chatgpt-disrupt-enterprise-ai-7b83b7591c1e))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: D. Biswas. *Privacy Risks of ChatGPT.* ([Data Driven Investor](https://medium.datadriveninvestor.com/privacy-risks-of-chatgpt-3f838320954a))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: D. Biswas*. Contextualizing Large Language Models (LLMs) with Enterprise Data.*
    ([Data Driven Investor](https://medium.datadriveninvestor.com/contextualizing-large-language-models-llms-with-enterprise-data-419e252fcbb7))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
