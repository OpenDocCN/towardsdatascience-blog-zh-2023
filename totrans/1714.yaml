- en: 'Python Callables: The Basics and the Secrets'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/python-callables-the-basics-and-the-secrets-ba88bf0729aa](https://towardsdatascience.com/python-callables-the-basics-and-the-secrets-ba88bf0729aa)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: PYTHON PROGRAMMING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Learn how powerful Python callables can be.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@nyggus?source=post_page-----ba88bf0729aa--------------------------------)[![Marcin
    Kozak](../Images/d7faf62e48ed81dab5d8ad92819fff54.png)](https://medium.com/@nyggus?source=post_page-----ba88bf0729aa--------------------------------)[](https://towardsdatascience.com/?source=post_page-----ba88bf0729aa--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----ba88bf0729aa--------------------------------)
    [Marcin Kozak](https://medium.com/@nyggus?source=post_page-----ba88bf0729aa--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----ba88bf0729aa--------------------------------)
    ·10 min read·Oct 27, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/16289801bda2c8ec8dfa0b3a3bba76f4.png)'
  prefs: []
  type: TYPE_IMG
- en: In Python, there are many callables to choose from. Photo by [Pavan Trikutam](https://unsplash.com/@ptrikutam?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: In programming languages, callable objects are typically associated with functions,
    and for good reason. Functions are perhaps the best examples of callable objects,
    but they are not the only ones. In Python, there are many other callable types,
    which can be incredibly useful and powerful. You can also create your own callable
    objects. This article is about both.
  prefs: []
  type: TYPE_NORMAL
- en: '*A callable* is an object that can be called using a pair of parentheses, like
    for example below, where we use the built-in function `sum()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A call to a callable, depending on its definition, can be
  prefs: []
  type: TYPE_NORMAL
- en: without any arguments, as in `no_args_callable()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: or a series of positional and/or keyword arguments, as in `args_callable(arg1,
    arg2)`, `args_callable(arg1, arg2=value2)` or `args_callable(arg1=value1, arg2=value2)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Above, I described a callable as a noun. The word *callable*, however, is also
    used as an adjective, meaning *being a callable*. Therefore, a callable is the
    same as a callable object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python has a built-in function , `callable()`, that checks if an object is
    callable, or — in other words — if it’s a callable. Consider the following examples
    of actual callables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The below objects are not callables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The positive examples above were about functions, which are what most people
    associate with callables. However, in fact, every Python class is callable. If
    you know the basics of object-oriented programming in Python, you know that to
    create an instance of a class, you do the following:¹
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This looks exactly like a call, and it is — and that is why Python classes are
    callables.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code shows that the `Empty` class is callable, but the truth is, every
    single Python class is callable. However, in Python terminology, the term “callable
    classes” is usually used to indicate something different: a class whose instances
    are callable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Empty` class is callable, but its instances are not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This code throws `TypeError`, because instances of the `Empty` class are not
    callable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To make a class’s instances callable, you need to implement a `.__call__()`
    method. We do so below, although the method is empty — it does nothing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you see, nothing happened — which basically means that `Empty()` return `None`.
    This time, however, no error was thrown, as instances of `EmptyCallable` are indeed
    callable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: Every Python class is callable, meaning that calling it creates a new
    instance of the class. However, not all instances of Python classes are callable.
    To make an instance callable, you must implement the `__call__()` method in the
    class body. We typically name a class as callable only when its instances are
    callable, even if theoretically this is not fully correct.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples of callables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes the best way of showing something is… to do it. Hence, I will provide
    a list of examples of callables, and then we will discuss when it is useful to
    make an object callable.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the most obvious examples and work our way down to less common
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: '*Regular and lambda functions*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Classes and class instances*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Functions from the operator module*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Partial objects*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Decorators*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Closures*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Let’s pause here for a moment. This code line requires some explanation.
  prefs: []
  type: TYPE_NORMAL
- en: I would never recommend writing this code. The only advantage to doing so is
    that it demonstrates your understanding of Python intricacies. However, it should
    never be written in production code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Do you see what’s happening? The `mult` function is an example of a closure:
    a function that returns a function, and the inner function can access free variables
    in the outer function’s scope, even after the outer function, `mult()`, has returned.'
  prefs: []
  type: TYPE_NORMAL
- en: If you are familiar with the `operator` module, you know that some of its functions
    are closures. Examples include `mul`, `add`, `itemgetter`, and `methodcaller`.
    It’s good to be familiar with closures and to understand how they work, as understanding
    them elevates your Python skills to a deeper level.
  prefs: []
  type: TYPE_NORMAL
- en: Closures can be very useful in Python and are used in many different ways, but
    that is not the topic of this article. We will discuss them another time. What
    matters to us now is that *a closure is callable and returns a callable*, which
    is the same thing we observed for the `decorator` decorator above.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s rewrite the closure to make it more readable; it will be easier to see
    what’s happening and why closures both are and return callable objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Definitely cleaner. If you noticed that decorators are just specific examples
    of closures, you’re right. Anyway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: So, *closures are* and *closures return* callables.
  prefs: []
  type: TYPE_NORMAL
- en: For a short moment, I’d like to return to `functools.partial`. Any discussion
    of callables in Python must not ignore them — as partial objects constitute an
    extremely useful tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s yet another subject that deserves a dedicated article, so I will only
    show some simple examples of these powerful callables. [The official Python documentation](https://docs.python.org/3/library/functools.html#functools.partial)
    explains partial objects as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The partial() is used for partial function application which “freezes” some
    portion of a function’s arguments and/or keywords resulting in a new object with
    a simplified signature.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Hence, you can achieve similar things as you do with closures. Remember this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can achieve the same in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create a new callable with some (even all, if that’s what you need)
    of the arguments being assigned particular values. You can use it also to change
    the default values of a function’s arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Technically, partial objects are not functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: They are callables, and they are [*partial objects*](https://docs.python.org/3/library/functools.html#functools.partial).
    It’s worth to mention also `functools.partialmethod()`, which creates partial
    objects to be used as class methods, unlike `functools.partial()`, whose objects
    are used as functions. If you’re interested, I hope to publish the dedicated article
    in the near future; and for the moment, you can read [the official documentation](https://docs.python.org/3/library/functools.html#functools.partialmethod).
  prefs: []
  type: TYPE_NORMAL
- en: When to make an object callable?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As shown above, not only is Python full of callable objects, but also we can
    create them with ease. The following article shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/a-callable-float-fun-and-creativity-in-python-7a311ccd742d?source=post_page-----ba88bf0729aa--------------------------------)
    [## A Callable Float? Fun and Creativity in Python'
  prefs: []
  type: TYPE_NORMAL
- en: To learn being creative, we’ll implement callable floating-point numbers in
    Python.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/a-callable-float-fun-and-creativity-in-python-7a311ccd742d?source=post_page-----ba88bf0729aa--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: I show there how to implement a callable class, `Float`, that inherits from
    `float`. The class’s instances are callable, so we’re talking about callable floating-point
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why bother at all? What can you achieve that way? Consider this example taken
    from the above article, and if you’re interested in the implementation of the
    `Float` class, you’ll find it there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: So, you can call a `Float` number and provide a function as an argument, and
    the function will be applied to the number kept by the instance. The article in
    question did not make a point that such a callable class is useful; nor do I want
    to make it here. Not trying to prove a class like that makes sense, the article
    discussed creativity in Python and showed the fun of Python coding.
  prefs: []
  type: TYPE_NORMAL
- en: Why am I mentioning this, then? Because the article does show something else.
    It shows that you can create callable objects with ease. The point is to know
    not only how to do it, but also — if not mainly — when to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Some examples when you may want to create a callable are as provided below.
    I will omit the most obvious one, like a need of creating a function or a class.
  prefs: []
  type: TYPE_NORMAL
- en: Function-like objects. For example, you might want to create a function-like
    object that takes arguments and returns a value, but that also has additional
    state or behavior. Closures, decorators and context managers are good examples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design patterns that use callable objects. [The Strategy pattern](https://en.wikipedia.org/wiki/Strategy_pattern)
    is a perfect example; it allows you to define a family of algorithms, encapsulate
    each one, and make them interchangeable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic functions and dynamic callables. This means creating a function or a
    callable at runtime. Callable objects allow you to do this easily.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This was pretty technical and theoretical, so let’s analyze a practical example.
    Imagine you have a class `ClassifyTextTo` that aims to classify a text into several
    categories. Let’s ignore implementation details, instead focusing on the class’s
    design. We can write the following prototype of this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `.pipeline()` method explains the whole process:'
  prefs: []
  type: TYPE_NORMAL
- en: the text is read from `self.path`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the text is preprocessed, to make it ready for the classification model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the classification model is run; it’s configured in `self.config`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the model is diagnosed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a report is created and logged
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The class works for a particular text — or more specifically — for a particular
    file located in `path`. So, for each file you create an instance of the class
    and run the pipeline, like here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have more such texts, you can do it in a loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'or, simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note that we’re creating as many instances of `ClassifyTextTo` as we have texts.
    Do we need to do so?
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have a pipeline to run in a class, oftentimes creating a callable
    class is a natural thing to do. Consider this alternative prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the implementation does not look all that different, the difference
    is significant and lies in the design. While `ClassifyTextTo` needed to create
    an instance per path, `CallClassifyTextTo` doesn’t. If the configuration is the
    same for all texts, we can use just one instance. In fact, we could do so even
    if the configuration needed to change from path to path, but that way we would
    lose the big advantage of the design — using the very same instance for each path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This is a natural thing because now we have the `classify` object, which is
    callable, thanks to the `.__call__()` method in the `ClassifyTextTo` class. It’s
    a little cheaper than the first approach, as it creates only one instance of the
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important thing for me is that calling `classify()` per path is a
    natural thing to do, as it means running the whole pipeline for path after path.
    I like the simplicity of this design:'
  prefs: []
  type: TYPE_NORMAL
- en: The instance of the `CallClassifyTextTo` class represents a particular model,
    not a path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a model is an action, and calling the instance does represent this action,
    just like calling a function does.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I am not saying this is the only correct approach. In programming, oftentimes
    several approaches will be correct. In such cases, I use several criteria to decide
    which one to use:'
  prefs: []
  type: TYPE_NORMAL
- en: code readability and simplicity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: how well the code design reflects the actual objects and actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the team’s and my own preferences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We discussed the basics and intricacies of callables in Python programming.
    I’d say that you need to know both if you want to be an advanced Python developer.
    Lucky for us, they are not as difficult as they may seem at first glance.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, I’m just talking about understanding how callables work
    in Python. This is not the same as understanding every single scenario in which
    they can be used. For instance, closures are quite a complex topic, and understanding
    them is a totally different thing from understanding how to create classes with
    callable instances. Often, the only closures you will use are decorators, but
    one day you may need to use them for other scenarios. One example is [the](https://github.com/nyggus/rounder)
    `[rounder](https://github.com/nyggus/rounder)` [package](https://github.com/nyggus/rounder)
    and the `_do()`function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://github.com/nyggus/rounder/blob/main/rounder/rounder.py?source=post_page-----ba88bf0729aa--------------------------------)
    [## rounder/rounder/rounder.py at main · nyggus/rounder'
  prefs: []
  type: TYPE_NORMAL
- en: Python package for rounding floats and complex numbers in complex Python objects.
    - rounder/rounder/rounder.py at main…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: github.com](https://github.com/nyggus/rounder/blob/main/rounder/rounder.py?source=post_page-----ba88bf0729aa--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, I hope this article helped you understand the basics of Python
    callables and take a look at some of their intricacies. From now on, in your Python
    work, remember that Python callables can be quite powerful and consider whether
    using them can improve the code design of your project.
  prefs: []
  type: TYPE_NORMAL
- en: Footnotes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ¹ The `Empty` class does nothing. However, this does not mean that it cannot
    have any sensible uses. For example, it could serve as a sentinel, that is, an
    object that is used to indicate a specific state or condition. `None` is the best-known
    example of a sentinel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks for reading. If you enjoyed this article, you may also enjoy other articles
    I wrote; you will see them [here](https://medium.com/@nyggus). And if you want
    to join Medium, please use my referral link below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/@nyggus/membership?source=post_page-----ba88bf0729aa--------------------------------)
    [## Join Medium with my referral link - Marcin Kozak'
  prefs: []
  type: TYPE_NORMAL
- en: As a Medium member, a portion of your membership fee goes to writers you read,
    and you get full access to every story…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/@nyggus/membership?source=post_page-----ba88bf0729aa--------------------------------)
  prefs: []
  type: TYPE_NORMAL
