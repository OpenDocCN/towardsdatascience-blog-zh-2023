["```py\n!pip install confluent-kafka\n```", "```py\nfrom confluent_kafka import Producer\nimport socket\n\nconf = {\n    'bootstrap.servers': \"localhost:9092\",\n    'client.id': socket.gethostname()\n}\n\nproducer = Producer(conf)\n```", "```py\ndef acked(err, msg):\n    if err is not None:\n        print(\"Failed to deliver message: %s: %s\" % (str(msg), str(err)))\n    else:\n        print(\"Message produced: %s\" % (str(msg)))\n\nproducer.produce(\"SomeTopic\", key=\"key1\", value=\"Hello\", callback=acked)     \nproducer.poll(1)   # Maximum time (1s) to block while waiting for events\n```", "```py\nproducer.produce(\"SomeTopic\", key=\"key2\", value=\"World\", callback=acked)     \nproducer.poll(1)\n```", "```py\nfrom confluent_kafka import Consumer\n\nconf = {\n    'bootstrap.servers': \"localhost:9092\",\n    'group.id': \"1\",\n    'auto.offset.reset': 'latest'\n}\n\nconsumer = Consumer(conf)\n```", "```py\nfrom confluent_kafka import KafkaError, KafkaException\n\ndef consume(consumer, topics):    \n    try:\n        consumer.subscribe(topics)\n        # use this as a way to stop the loop\n        t = threading.currentThread()\n        while getattr(t, \"run\", True):\n            msg = consumer.poll(timeout=5.0)\n            if msg is None: \n                continue\n\n            if msg.error():\n                if msg.error().code() == KafkaError._PARTITION_EOF:\n                    # End of partition event\n                    sys.stderr.write('%% %s [%d] reached end at offset %d\\n' %\n                                     (msg.topic(), msg.partition(), msg.offset()))\n                elif msg.error():\n                    raise KafkaException(msg.error())\n            else:\n                key = msg.key().decode(\"utf-8\")\n                data = msg.value().decode(\"utf-8\")\n                print(key, data)\n    finally:\n        # Close down consumer to commit final offsets.\n        consumer.close()\n```", "```py\nimport threading\nthread = threading.Thread(target=consume, \n                          args=(consumer, [\"SomeTopic\"]))\nthread.start()\n```", "```py\nkey1 Hello\nkey2 World\n```", "```py\nthread.run = False\n```", "```py\ndef send_message(topic, datetime, temp1, temp2):\n    producer.produce(topic, key=\"key\", value=f\"{datetime},{temp1},{temp2}\", callback=acked)\n    producer.poll(1)\n```", "```py\nimport threading\nimport datetime\nimport random\n\ndef update():\n    threading.Timer(2.0, update).start()     # call update() every 5s\n    send_message('SensorData',\n                 datetime.datetime.utcnow(), # datetime in UTC\n                 random.uniform(20, 39),     # temperature1\n                 random.uniform(10, 29))     # temperature2\n\nupdate()\n```", "```py\nfrom confluent_kafka import Consumer\n\nconf = {\n    'bootstrap.servers': \"localhost:9092\",\n    'group.id': \"1\",\n    'auto.offset.reset': 'latest'\n}\n\nconsumer = Consumer(conf)\n```", "```py\nfrom confluent_kafka import KafkaError, KafkaException\n\nimport time\nimport plotly.graph_objects as go\nimport numpy as np\n\n# initialize a plot\nfig = go.FigureWidget()\n\n# add two scatter plots\nfig.add_scatter(fill='tozeroy')\nfig.add_scatter(fill='tozeroy')\n```", "```py\ndef consume(consumer, topics):\n    counter = 0\n    x  = []   # datetime\n    y1 = []   # first temp\n    y2 = []   # second temp\n    n  = 12   # the number of points to display on the plot\n    try:\n        consumer.subscribe(topics)        \n        t = threading.currentThread()\n        while getattr(t, \"run\", True):\n            msg = consumer.poll(timeout=2.0)\n            if msg is None:         \n                continue\n\n            if msg.error():\n                if msg.error().code() == KafkaError._PARTITION_EOF:\n                    # End of partition event\n                    sys.stderr.write('%% %s [%d] reached end at offset %d\\n' %\n                                     (msg.topic(), msg.partition(), msg.offset()))\n                elif msg.error():\n                    raise KafkaException(msg.error())\n            else:\n                data = msg.value().decode(\"utf-8\")\n                x.append(data.split(',')[0])          # datetime\n                y1.append(float(data.split(',')[1]))  # first temp\n                y2.append(float(data.split(',')[2]))  # second temp\n\n                #---display the last n points---                \n                # first scatter plot\n                fig.data[0].x = x[-n:]                # datetime\n                fig.data[0].y = y1[-n:]               # temp                \n                # second scatter plot\n                fig.data[1].x = x[-n:]                # datetime\n                fig.data[1].y = y2[-n:]               # temp\n    finally:\n        # Close down consumer to commit final offsets.\n        consumer.close()\n\ndisplay(fig)\n```", "```py\ndata = msg.value().decode(\"utf-8\")\n                x.append(data.split(',')[0])          # datetime\n                y1.append(float(data.split(',')[1]))  # first temp\n                y2.append(float(data.split(',')[2]))  # second temp\n```", "```py\n #---display the last n points---                \n                # first scatter plot\n                fig.data[0].x = x[-n:]                # datetime\n                fig.data[0].y = y1[-n:]               # temp                \n\n                # second scatter plot\n                fig.data[1].x = x[-n:]                # datetime\n                fig.data[1].y = y2[-n:]               # temp\n```", "```py\nimport threading\nthread = threading.Thread(target=consume, args=(consumer, [\"SensorData\"]))\nthread.start()\n```", "```py\nthread.run = False\n```"]