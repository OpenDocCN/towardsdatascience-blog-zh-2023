- en: Initialize Rust Constants at Runtime with lazy_static
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/initialize-rust-constants-at-runtime-with-lazy-static-e05b1df46c79](https://towardsdatascience.com/initialize-rust-constants-at-runtime-with-lazy-static-e05b1df46c79)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Define non-constant static variables with lazy initialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@nic-obert?source=post_page-----e05b1df46c79--------------------------------)[![Nicholas
    Obert](../Images/d70330063c9edc2f63e53f62a78f82ec.png)](https://medium.com/@nic-obert?source=post_page-----e05b1df46c79--------------------------------)[](https://towardsdatascience.com/?source=post_page-----e05b1df46c79--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----e05b1df46c79--------------------------------)
    [Nicholas Obert](https://medium.com/@nic-obert?source=post_page-----e05b1df46c79--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----e05b1df46c79--------------------------------)
    ·4 min read·Aug 5, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d3a48ff6643b48687887a2af35a5c63e.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Christian Lue](https://unsplash.com/@christianlue?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: It’s no secret that initializing constants at compile time is a good practice
    in programming. Not only do you reduce the initialization overhead, but you also
    make it easier for the compiler to cleverly optimize your code by knowing the
    value of the constant in advance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, however, it’s impossible to initialize every constant at compile
    time since it requires performing non-constant operations or fetching data available
    only at runtime. For instance, say we make repetitive use of the number `√7` in
    our program. Instead of calculating it every time, it would be better to define
    a constant for it like follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This code, however, is invalid. The Rust compiler returns the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The same happens if we try to initialize a constant with an environment variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'From the Rust compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, certain constants that would be useful to initialize at compile
    time require non-constant operations. This is where Rust’s `lazy_static` crate
    comes in handy. `lazy_static` allows you to define global static variables that
    get initialized lazily, meaning that their values only get set upon their first
    actual usage at runtime. Lazy statics only need to be initialized the first time
    they’re used and, since this is a one-time operation, their runtime initialization
    overhead is negligible.
  prefs: []
  type: TYPE_NORMAL
- en: In this article, we’ll take a look at how to use Rust’s `lazy_static` crate
    to lazily initialize global constants and a few of their use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Use lazy_static
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use the `lazy_static` crate, you simply add it to your project dependencies
    by
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you added the crate, you can import the `lazy_static!` macro in your source
    files like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To define lazy statics, enclose all the declarations within the `lazy_static!`
    macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'By doing this, you declare a global static reference to a lazily initialized
    value. To use these “lazy constants”, you can just dereference them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now you can effectively use the `lazy_static` crate to initialize global constants
    at runtime. Keep reading to learn how it works.
  prefs: []
  type: TYPE_NORMAL
- en: What is lazy initialization?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When do lazy statics get initialized? In computing, the term lazy usually means
    that work is done exclusively if and when it’s required. Otherwise, lazy operations
    aren’t performed. In the case of lazy statics, they are initialized just before
    their first usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it clearer, take a look at the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'All these lazy static initializations have side effects: they print stuff to
    the console. Using these side effects, we can detect when their values are actually
    initialized.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And the output order shows when each operation is performed at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the first output line, no lazy static is initialized before
    it’s actually needed. The second and third output lines show that the initialization
    is performed exactly before the value is used.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth line highlights the fact that no initialization is required for already
    used lazy statics since their value is stored.
  prefs: []
  type: TYPE_NORMAL
- en: Also, did you notice that `UNUSED_LAZY_STATIC` was never initialized? That’s
    because lazy operations are performed only if they’re actually needed.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This article was meant to be a basic tutorial on the `lazy_static` crate and
    its most popular feature. For more information, read the [official documentation](https://docs.rs/lazy_static/latest/lazy_static/).
  prefs: []
  type: TYPE_NORMAL
- en: I hope you enjoyed this article. If you have anything to add, please share your
    thoughts in a comment. Thanks for reading!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to learn more about low-level programming, I highly recommend checking
    out this story below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://betterprogramming.pub/heres-how-the-cpu-handles-if-statements-and-branching-95cfd42af9c?source=post_page-----e05b1df46c79--------------------------------)
    [## Here’s How the CPU Handles If Statements and Branching'
  prefs: []
  type: TYPE_NORMAL
- en: 'Know why if statements are disliked and how they actually work. Spoiler: they
    aren’t that bad'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: betterprogramming.pub](https://betterprogramming.pub/heres-how-the-cpu-handles-if-statements-and-branching-95cfd42af9c?source=post_page-----e05b1df46c79--------------------------------)
  prefs: []
  type: TYPE_NORMAL
