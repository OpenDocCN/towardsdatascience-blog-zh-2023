["```py\nfrom abc import ABC, abstractmethod\n\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\nfrom lightgbm import LGBMRegressor\nfrom scipy import optimize, stats\nfrom scipy.interpolate import PchipInterpolator\nfrom sklearn.datasets import load_diabetes\n```", "```py\nclass QuantileMatcherBase(ABC):\n    @abstractmethod\n    def fit_one(self, alphas, quant_values):\n        pass\n\n    @abstractmethod\n    def predict_one(self, alphas):\n        pass\n\ndef quantile_matcher_factory(match, **kwargs) -> QuantileMatcherBase:\n    matcher_map = {\n        \"normal\": QuantileMatcherNormCurvFit,\n        \"half_normal\": QuantileMatcherHalfNormCurvFit,\n        \"cubic_interpolation\": QuantileMatcherCubicInterpolation,\n    }\n    if match not in matcher_map:\n        raise ValueError(f\"Unknown matcher {match}\")\n\n    return matcher_map[match](**kwargs)\n```", "```py\nclass QuantileMatcherNormCurvFit(QuantileMatcherBase):\n    \"\"\"Normal distribution quantile matcher.\"\"\"\n\n    def __init__(self):\n        self.params = None\n\n    def fit_one(self, alphas, quant_values):\n        self.params, _ = optimize.curve_fit(\n            lambda x, mu, sigma: stats.norm.isf(x, mu, sigma),\n            alphas,\n            1 - quant_values,\n        )\n\n    def predict_one(self, alphas):\n        return 1 - stats.norm.isf(alphas, *self.params) \n```", "```py\nclass QuantileMatcherHalfNormCurvFit(QuantileMatcherBase):\n    \"\"\"Half-Normal distribution quantile matcher.\"\"\"\n\n    def __init__(self):\n        self.below = QuantileMatcherNormCurvFit()\n        self.above = QuantileMatcherNormCurvFit()\n\n    def fit_one(self, alphas, quant_values):\n        self.below.fit_one(alphas[alphas<=0.5],quant_values[alphas<=0.5])\n        self.above.fit_one(alphas[alphas>=0.5],quant_values[alphas>=0.5])\n        # trick to ensure same median\n        mu = (self.below.params[0] + self.above.params[0]) / 2\n        self.below.params[0] = mu\n        self.above.params[0] = mu\n\n    def predict_one(self, alphas):\n        pred = self.above.predict_one(alphas)\n        pred_below = self.below.predict_one(alphas)\n        pred[alphas<0.5] = pred_below[alphas<0.5]\n        return pred\n```", "```py\nclass QuantileMatcherCubicInterpolation(QuantileMatcherBase):\n    \"\"\"Increasing cubic interpolation quantile matcher.\"\"\"\n    def __init__(self):\n        self.params = None\n\n    def fit_one(self, alphas, quant_values):\n        self.interp = PchipInterpolator(alphas, quant_values)\n\n    def predict_one(self, alphas):\n        return self.interp(alphas) \n```", "```py\nclass ProbLGBMRegressor:\n    _forbidden_keys = (\n        \"objective\",\n        \"objective_type\",\n        \"app\",\n        \"application\",\n        \"loss\",\n        \"alpha\",\n    )\n\n    def __init__(\n        self, \n        alphas=np.array([0.01, 0.1, 0.25, 0.5, 0.75, 0.9, 0.99]), \n        **lgbm_args\n    ):\n        self.alphas = alphas\n\n        for key in self._forbidden_keys:\n            if key in lgbm_args:\n                raise ValueError(f\"{key} parameter is not allowed.\")\n\n        self._models = {}\n        for alpha in self.alphas:\n            self._models[alpha] = LGBMRegressor(\n                objective=\"quantile\", alpha=alpha, **lgbm_args\n            )\n\n    def fit(self, x, y):\n        for alpha in self.alphas:\n            self._models[alpha].fit(x, y)\n\n    def predict_raw(self, x):\n        return pd.DataFrame(\n            {alpha: model.predict(x) for alpha, model in self._models.items()}\n        )\n\n    def predict_cdf(\n        self,\n        x,\n        inference_alphas=np.linspace(0.001, 0.999, 999),\n        match=\"normal_curve_fit\",\n        **matcher_params,\n    ):\n        # Compute predictions for the limited set of quantiles.\n        raw_preds = self.predict_raw(x)\n\n        # Estimate the cumulative distribution for each sample.\n        matcher = quantile_matcher_factory(match, **matcher_params)\n        predictions = []\n        for _, row in raw_preds.iterrows():\n            matcher.fit_one(self.alphas, row.values)\n            preds = matcher.predict_one(inference_alphas)\n            predictions.append(preds)\n\n        return pd.DataFrame(predictions, columns=inference_alphas)\n```", "```py\nx,y = load_diabetes(return_X_y=True, as_frame=True)\n\n# Fit a regressor\nprob_lgbm = ProbLGBMRegressor()\nprob_lgbm.fit(x,y)\n\n# Predict the distributions with all methods\npredicted_cdf = {}\nfor match in [\"normal\",\"half_normal\",\"cubic_interpolation\"]:\n    predicted_cdf[match] = prob_lgbm.predict_cdf(x, match=match)\n\n# For visualization purposes, we predict also the \"raw\" values\npredicted_raw = prob_lgbm.predict_raw(x)\n```", "```py\ndef get_fig_cumulative_distribution_function(predicted_cdf, predicted_raw, idx):\n    # Small artifact to ensure same range in figures\n    max_limit = max([pred.iloc[idx, -1] for pred in predicted_cdf.values()]) + 5\n    min_limit = max([pred.iloc[idx, 0] for pred in predicted_cdf.values()]) - 5\n\n    # Create traces for each distribution.\n    trace = []\n    for match, pred_cdf in predicted_cdf.items():\n        x = [min_limit] + list(pred_cdf.iloc[idx].values) + [max_limit]\n        y = [0] + list(pred_cdf.columns) + [1]\n        trace.append(go.Scatter(x=x, y=y, mode=\"lines\", name=match.title()))\n\n    # Add trace for raw quantile predictions.\n    trace.append(\n        go.Scatter(\n            x=predicted_raw.iloc[idx],\n            y=predicted_raw.columns,\n            mode=\"markers\",\n            name=\"Raw Predictions\",\n            marker={\"size\": 10},\n        )\n    )\n\n    # Create the figure\n    fig = go.Figure(trace)\n    fig.update_layout(\n        title=\"Cumulative Distribution Functions\",\n        yaxis_title=\"alpha\",\n        xaxis_title=\"quantile\",\n    )\n    # Set x-axis limits\n    fig.update_xaxes(range=(min_limit, max_limit))\n    return fig\n```", "```py\ndef get_fig_probability_distribution_function(predicted_cdf, idx):\n    trace = []\n\n    for match, pred_cdf in predicted_cdf.items():\n        quantiles = pred_cdf.iloc[idx].values\n        icdf_values = pred_cdf.columns.values\n\n        # Estimate the PDF using finite differences\n        diff_icdf = np.diff(icdf_values)\n        diff_quantiles = np.diff(quantiles)\n        pdf_est = diff_icdf / diff_quantiles\n\n        # Create a Plotly figure for the estimated PDF\n        trace.append(\n            go.Scatter(\n                x=quantiles[:-1],\n                y=pdf_est,\n                mode=\"lines\",\n                fill=\"tozeroy\",\n                name=match,\n            )\n        )\n\n    fig = go.Figure(data=trace)\n\n    # Add labels and title\n    fig.update_layout(\n        xaxis_title=\"Quantiles\",\n        yaxis_title=\"Estimated PDF\",\n        title=\"Estimated Probability Density Function\",\n    )\n    return fig\n```"]