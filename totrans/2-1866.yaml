- en: 'Simulation 101: Conductive Heat Transfer'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/simulation-101-conductive-heat-transfer-a4f09b3e16b4](https://towardsdatascience.com/simulation-101-conductive-heat-transfer-a4f09b3e16b4)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A gentle introduction to computational physics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@ln8378?source=post_page-----a4f09b3e16b4--------------------------------)[![Le
    Nguyen](../Images/05289b40bb528d5ba2a0ee00d1a75990.png)](https://medium.com/@ln8378?source=post_page-----a4f09b3e16b4--------------------------------)[](https://towardsdatascience.com/?source=post_page-----a4f09b3e16b4--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----a4f09b3e16b4--------------------------------)
    [Le Nguyen](https://medium.com/@ln8378?source=post_page-----a4f09b3e16b4--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----a4f09b3e16b4--------------------------------)
    ·11 min read·Jul 25, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: Conduction, or heat transfer between objects, is something we experience everyday.
    Putting a pan on the stove or sitting on a hot park bench gives us an intuitive
    sense of conductive heat transfer but here we will formalize the process and build
    a basic computational framework to simulate it. Conduction is an excellent first
    simulation problem to tackle because it uses the basic tools found in many computational
    physics problems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/56a8db8885ed2a6a492829258bf71be3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this article we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a mesh grid to represent materials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn basic heat transfer equations and their computational equivalents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the values in our mesh grid based on the underlying physics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulate conductive heat transfer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Mesh Grid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A mesh grid is a computational tool used to discretize a continuous space. That
    is, we can’t perform calculations on all time and space in our problem, so we
    chose a representative subset of points, usually at regular intervals, to look
    at instead.
  prefs: []
  type: TYPE_NORMAL
- en: In figure 1 below we can see an example of a mesh grid. Here a space is subdivided
    into evenly spaced cells which is common practice is physics simulation. Instead
    of running calculations/simulation on the entire surface we can now work with
    only our grid points which makes our problem more feasible.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/091c6165eab1e8ad9f7fbf4a442a7b92.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: [Example of a mesh grid](https://www.javatpoint.com/numpy-meshgrid).
    In a simulation we break up our space into such a grid and compute values at every
    dotted grid point.'
  prefs: []
  type: TYPE_NORMAL
- en: The mesh grid above was created using Python’s [numpy meshgrid](https://numpy.org/doc/stable/reference/generated/numpy.meshgrid.html)
    function which can take in a set of 1 dimensional arrays and create a mesh grid
    for us. For our simulation, we want to model a 2 dimensional surface, so we are
    going to generate 2 arrays filled with the starting values we want with a length
    of how many intervals we want to evaluate our simulation on. See the code snippet
    below where we create a 100x100 mesh grid of zeros as the basis of our simulation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Before moving on from mesh grids, it’s important to note that every point on
    our grid is typically not a single value. Usually at every grid point we want
    an array of values that represent the properties we will be working with. In our
    heat transfer simulation we will need to know material properties as well as the
    temperature at every point on our mesh grid. So all the points on our grid will
    be an array that contains information like temperature, material density, material
    conductivity and anything else we need to know.
  prefs: []
  type: TYPE_NORMAL
- en: An easy way to make a mesh grid that is an array of arrays is to create multiple
    mesh grids that contain a single value at each point and then stack then together
    as seen in figure 2.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/00a13058fa4048ad02826d3e041a8799.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2: Stacking 2 mesh grids to create a new mesh grid that contain multiple
    values per point.'
  prefs: []
  type: TYPE_NORMAL
- en: Numpy comes in handy here again with the [dstack function](https://numpy.org/doc/stable/reference/generated/numpy.dstack.html)
    which will stack two arrays element wise for us. Below is a code snippet that
    will create 2 mesh grids and stack them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: With the tools to create our own mesh grid to represent our simulation environment,
    we can move on to the physics.
  prefs: []
  type: TYPE_NORMAL
- en: Basics of Heat Transfer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will first start with the 1 dimensional time dependent heat conduction equation.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/26511d568a3aa31890f1f6ef4e237aaa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Equation 1: [1-dimensional time dependent heat conduction equation](http://geodynamics.usc.edu/~becker/teaching/557/problem_sets/problem_set_fd_explicit.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: The equation states the the change in temperature over time is based on the
    material’s thermal properties scaled by the change in temperature across the material
    (technically the change of the change of the temperature since it is a 2nd derivative).
    We don’t need to worry about the thermal properties of the material since they
    can be found in [look up tables](https://www.engineersedge.com/heat_transfer/thermal_diffusivity_table_13953.htm).
    What we need to do is convert the derivatives in the equation into something we
    can handle computationally. Luckily for us, this can be done with the [finite
    difference method](https://en.wikipedia.org/wiki/Finite_difference_method) which
    will convert equation 1 into equation 2 below.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5b26e32f4604194293c7e3c0eb85df35.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Equation 2: Computational [1-dimensional time dependent heat conduction equation](http://geodynamics.usc.edu/~becker/teaching/557/problem_sets/problem_set_fd_explicit.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: Equation 2 is a computational equivalent of the time dependent heat conduction
    equation that we can use to update the temperature in our simulation. Going through
    each cell in our mesh grid, we can update the temperature of that cell by its
    current temperature plus the difference in temperature between that cell and its
    neighboring cells (here i represents the mesh grid index) scaled by the thermal
    properties of the material and a time step of our choosing.
  prefs: []
  type: TYPE_NORMAL
- en: Equation 1 & 2 are the 1-dimenstional heat equation but we want to run our simulation
    in 2-dimensions. Adding in a 2nd dimension is straight forward, especially having
    the computational version of the heat equation, we just need to add in all neighboring
    cells as seen below in equation 3.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0fa2ef2d25cc0a89bec1e3530d5b063f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Equation 3: [Computational 2-dimenstional time dependent heat conduction equation](https://resources.system-analysis.cadence.com/blog/msa2022-using-the-2d-finite-difference-method-for-heat-transfer-analysis).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have translated the time dependent heat conduction equation into
    a computational expression, we can use it to update our mesh grid.
  prefs: []
  type: TYPE_NORMAL
- en: Updating Our Mesh Grid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s first initialize a mesh grid using the tools we have developed so far.
    We know we need at least 2 features to plug into our temperature equation which
    is a current temperature and a thermal diffusivity constant for a material of
    our choosing. We will start with our material being at room temperature (20°C),
    and our material will be copper which has a thermal diffusivity of 1.11x10^-2
    cm²/s. We fill 2 mesh grids with these values and stack them to make our overall
    mesh.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In our specific case, our mesh grid is symmetric (the feature values are the
    same in the x and y direction), so defining our x and y grid separately is not
    needed but it is still good practice because we will not always have such symmetry
    when we simulate. Now that we have our material represented by a mesh grid we
    need to add heat to it (as we saw in our physics equations, there has to be a
    difference in temperature for heat to transfer). To add heat to our material,
    we need to select the cells in our mesh grid we want to heat up and add value
    to their temper index. We will continue to keep things basic and add heat, let’s
    say 1000°C, in a square from index 35–65 in both the X and Y direction. The code
    to do this and a resulting plot of this can be seen below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/1dfcaf285776fa345b28ef8eaeb95860.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3: Visualization of added heat to our mesh grid.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve added a patch of heat to our mesh grid, which is a good start but now
    we need to evolve our system through time to see how the heat transfers. We will
    need to develop a few more tools to do this. The first will be a find neighbors’
    temperature function, which given a cell can get the temperature off all neighboring
    cells. This function is given below and loops over all 8 bordering cells of a
    given cell but ignores the corners to only retrieve cells that are up, down, left
    and right. Another thing we have to consider when looking at all of a cell’s neighbors
    is **boundary conditions** or what we want to do when we hit the end of our grid.
    If we are at a grid cell that is already at the edge of the grid, looking for
    all of its neighbors will throw an error since they don’t all exist. We can handle
    this with a try except statement in our loop which will give our boundary condition
    when we try to look for a cell that does not exist. Our boundary condition can
    be filled with the temperature we want to assume outside of our grid. In our simulation,
    we are going to say this is room temperature, so when we calculate the heat transfer
    at our mesh grid edges, room temperature will always be given as a neighboring
    value to an edge cell.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The next function we have to develop will implement the 2-dimensional time dependent
    heat conduction equation we found in the last section. We solved for the computational
    equivalent for this equation so the implementation is straight forward and given
    below. The function completes the heat conduction equation by taking in the temperature
    of a given cell, the temperature of the cells around it, a time step of our choosing,
    and the thermal diffusivity of the cell material.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The last function we need will combine the two previous functions to loop over
    every cell in our mesh grid and update its temperature. For every cell in our
    grid we first run “getNeighbors” to get all of the neighboring temperatures and
    then we pass the neighboring temperatures plus the current cell temperature and
    other arguments to update the cell’s temperature.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we can use our heat transfer equation to update our original mesh grid.
    The final code snippet will update our grid with a 30 second time step and compare
    the before and after.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/f0156e44fc119b4ec8a142e6352d3009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4: Updating our mesh grid with our heat transfer heat with a 30 second
    time step.'
  prefs: []
  type: TYPE_NORMAL
- en: We now have all the tools need to run conductive heat transfer simulations,
    we will run a few in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Simulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With all of out simulation tools created, all we have to do is put our heat
    transfer equation inside of a loop and evolve the system for as many time steps
    as we want. The code to do this is given as well as a function to visualize our
    simulation as a gif.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/4e729ac1eb63dbdbd183ca4fef031961.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5: Gif of our conductive heat transfer simulation'
  prefs: []
  type: TYPE_NORMAL
- en: And there we have it. We have ran a simulation of conductive heat transfer and
    visualized it (with the cool “inferno” color map). With the generalized set of
    tools we developed, we can run many different simulations with different time
    steps, starting temperatures, materials and geometries. The next and final section
    will show off a couple more scenarios made with our tools.
  prefs: []
  type: TYPE_NORMAL
- en: Example Scenarios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following is a simulation of a sheet of brass and steel being welded together.
    What is interesting is the brass (left side) has about 3x the thermal conductivity
    as steel (right side) and we can see the difference in the material properties
    as the heat dissipates.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we can add heat into out simulation iteratively as well by adding
    to the temperature layer of our mesh grid inside of our simulating loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/22de145ce9c61740c40c45b9c1a481db.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6: Simulation of welding brass and steel together.'
  prefs: []
  type: TYPE_NORMAL
- en: Bruner
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here a stove top burner is being simulated by adding a circular patch of heat
    to the mesh grid. The heat is being added gradually (3°C per second) until the
    burner is turned off and allowed to cool.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e669c13ee6e98c5e9439482054ca727c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7: Simulation of a stove top burner being heated up and turned off.'
  prefs: []
  type: TYPE_NORMAL
- en: Full Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[1]Finite difference example: 1D explicit heat equation [http://geodynamics.usc.edu/~becker/teaching/557/problem_sets/problem_set_fd_explicit.pdf](http://geodynamics.usc.edu/~becker/teaching/557/problem_sets/problem_set_fd_explicit.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] Using the 2D Finite Difference Method for Heat Transfer Analysis [https://resources.system-analysis.cadence.com/blog/msa2022-using-the-2d-finite-difference-method-for-heat-transfer-analysis](https://resources.system-analysis.cadence.com/blog/msa2022-using-the-2d-finite-difference-method-for-heat-transfer-analysis)'
  prefs: []
  type: TYPE_NORMAL
- en: '[3] Heat Conduction Equation [https://cecs.wright.edu/~sthomas/htchapter02.pdf](https://cecs.wright.edu/~sthomas/htchapter02.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[4] Unless otherwise cited, all figures in this article were created by the
    author.'
  prefs: []
  type: TYPE_NORMAL
