- en: Understanding Predictive Maintenance — Data Acquisition and Signal Denoising
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/understanding-predictive-maintenance-data-acquisition-and-signal-denoising-0309b1b103a7](https://towardsdatascience.com/understanding-predictive-maintenance-data-acquisition-and-signal-denoising-0309b1b103a7)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[](https://marcin-staskopl.medium.com/?source=post_page-----0309b1b103a7--------------------------------)[![Marcin
    Stasko](../Images/5142b9a260a1cce7c6a2ebcc16f46fbb.png)](https://marcin-staskopl.medium.com/?source=post_page-----0309b1b103a7--------------------------------)[](https://towardsdatascience.com/?source=post_page-----0309b1b103a7--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----0309b1b103a7--------------------------------)
    [Marcin Stasko](https://marcin-staskopl.medium.com/?source=post_page-----0309b1b103a7--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----0309b1b103a7--------------------------------)
    ·10 min read·Nov 8, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7b22da632d98376927dfee8109eb915f.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Michael Dziedzic](https://unsplash.com/@lazycreekimages?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Article purpose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I want to start a series of articles to give you hands-on experience in predictive
    maintenance and make it easy for you to get into signal processing. In this article,
    we’ll concentrate on getting data and cleaning up the signals. If you find certain
    parts interesting, I’ll think about going into more detail. In the next part of
    this article, I’ve got some practical exercises for you. You can use the code
    I’ve prepared to do your own experiments and learn by doing.
  prefs: []
  type: TYPE_NORMAL
- en: Data science of predictive maintanance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Predictive maintenance in data science is like having a super-smart way of taking
    care of machines. Instead of fixing things after they break, we use fancy computer
    programs and past data to predict when something might go wrong. It’s a bit like
    having a crystal ball for machines! By doing this, companies can save money and
    keep their important machines working longer. This method involves keeping a close
    eye on machines, collecting data in real-time, and using clever computer programs
    to tell us when it’s time to do maintenance. So, instead of waiting for something
    to break, we can fix it before it causes a big problem. It’s like giving machines
    a health check before they get sick!
  prefs: []
  type: TYPE_NORMAL
- en: '**Data acquisition and handling**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../Images/f753388b03155782659dccb5e7e513e3.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Mika Baumeister](https://unsplash.com/@mbaumi?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Everything starts from data. We need to dive a little into communication theory
    principles, such as the Shannon–Hartley theorem and Nyquist rate, for ensuring
    accurate and efficient transmission of sensor data.
  prefs: []
  type: TYPE_NORMAL
- en: Shannon–Hartley Theorem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Shannon–Hartley Theorem is like a rulebook for how much information can
    be sent through a communication channel without getting messed up. It tells us
    that the width of the channel, or how much data it can handle, is super important.
    So, before choosing devices or tools to monitor things like machines or sensors,
    we need to make sure the channel is wide enough to handle all the data we want
    without losing quality.
  prefs: []
  type: TYPE_NORMAL
- en: To make things even better, we can be smart about how we use the channel. It’s
    like finding the best way to arrange our data so that we use the channel space
    most efficiently. This is called optimizing spectral efficiency. So, when picking
    sensors, we should choose ones that work really well within the available channel
    space.
  prefs: []
  type: TYPE_NORMAL
- en: Theorem Application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Assess Channel Bandwidth** Before selecting sensors, carefully check how
    much data the communication channel can handle. If it’s not wide enough, consider
    upgrading the channel or finding sensors that require less bandwidth.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Optimize Sensor Selection**'
  prefs: []
  type: TYPE_NORMAL
- en: Choose sensors that are efficient in using the available channel space. Some
    sensors might be better at transmitting data without taking up too much room in
    the channel.
  prefs: []
  type: TYPE_NORMAL
- en: '**Nyquist Rate**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../Images/4dab382f3b7385c3dd5ef7552e10b4c2.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Jair Lázaro](https://unsplash.com/@jairlazarofuentes?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: The Nyquist Rate is like a speed limit for how fast we should collect data with
    our sensors. If we collect data too slowly, we might miss important details about
    how things are working. So, when we set up systems to keep an eye on things with
    sensors or smart devices, we need to make sure we’re collecting data at a speed
    that accurately shows us what’s happening and doesn’t create confusion.
  prefs: []
  type: TYPE_NORMAL
- en: We have to ensure that the sensors are collecting data at a speed that follows
    the Nyquist Rate. This means collecting data fast enough to capture all the essential
    details without missing anything important.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e45fa2e374da79c901bbf3838983b638.png)'
  prefs: []
  type: TYPE_IMG
- en: Nyquist law
  prefs: []
  type: TYPE_NORMAL
- en: Ensure the **sensor can measure (***fs***) at least twice as fast as the fastest
    change (***fmax***) in what you’re monitoring**. This prevents missing important
    details and guarantees accurate measurements. Choose a sensor with a speed that
    matches what you want to measure.
  prefs: []
  type: TYPE_NORMAL
- en: '**Nyquist`s super heroes — Antialiasing Filters**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To avoid any confusion or errors, we use something like special filters, called
    antialiasing filters. These filters help our sensors focus on the important parts
    of the information and remove any extra noise or confusing details. It’s like
    using a magnifying glass to see things clearly. So, when we’re using sensors all
    the time to watch over machines, we should make sure these filters are in place
    to give us the best and most accurate information. But what is aliasing and anti-aliasing?
  prefs: []
  type: TYPE_NORMAL
- en: Aliasing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/cf11c418aa06b76dc6bd49131881e139.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Aliasing and anti-aliasing comparison source: [https://www.zilliondesigns.com/](https://www.zilliondesigns.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you are trying to take a picture of a car moving really fast. However,
    your camera takes only one picture every second. Now, if the car is moving really,
    really fast, it might be at a completely different spot by the time you take the
    next picture. As a result, when you look at the pictures, the car seems to be
    in weird places because you missed how it moved between each picture. This strange
    effect where things look different than they actually are is called aliasing.
  prefs: []
  type: TYPE_NORMAL
- en: Anti-Aliasing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, imagine you have a magical camera that can take lots of pictures really
    quickly. Instead of taking one picture per second, it takes many pictures in that
    same second, capturing every little detail of the car’s movement. When you look
    at these pictures, you see a smooth and accurate representation of how the car
    moved. This process of making sure you capture all the details and avoid the weird
    effects of aliasing is called anti-aliasing.
  prefs: []
  type: TYPE_NORMAL
- en: In simpler terms, anti-aliasing is like having a super-fast camera to make sure
    things look as they should without any strange distortions or blurriness. It helps
    in creating clear and accurate images, especially when things are moving quickly
    or changing rapidly.
  prefs: []
  type: TYPE_NORMAL
- en: Ok but why it is important in signal processing? These animation will show you
    how we can use it to denoise the real signal and catch the “core” of these signal.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7061a8d29d9f295f93d674b46daf8195.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works in signal processing source:siemens.com
  prefs: []
  type: TYPE_NORMAL
- en: Hand`s on experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../Images/da9e4576f89845ebf930228990243644.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [shraga kopstein](https://unsplash.com/@sfkopstein?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dive into the code and get our hands dirty! First, we’ll generate a sample
    signal and set up a plotting function for visualization. In this case, we’ll work
    with a basic sine wave and experiment with its parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Next we will create example of signal antialliasing using one of the simple
    filter like Butterworth.
  prefs: []
  type: TYPE_NORMAL
- en: Think of the Butterworth filter as a gatekeeper for different frequencies in
    our signal. It allows low frequencies to pass through while reducing higher frequencies.
    Adjusting parameters like filter order and cutoff frequency fine-tunes its selectiveness.
    This helps us prevent issues like aliasing, ensuring a cleaner signal representation.
    Let’s see it in action in our code!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: And let`s run an experiment
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/25900ab2516c5f2b2a737c8387878ec9.png)'
  prefs: []
  type: TYPE_IMG
- en: Output from this experiment
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to sampling, our pure sine wave doesn’t look as “beautiful” as
    we might expect. Some parts are cut off, and this is because of the sampling process.
  prefs: []
  type: TYPE_NORMAL
- en: I encourage you to replicate this code and experiment with the parameters. It’s
    a lot of fun!
  prefs: []
  type: TYPE_NORMAL
- en: We can also play with different types of filters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We will modify our plot function a little to gather all the results in one plot.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/6775881a236e12f67682f2fc672a33ba.png)'
  prefs: []
  type: TYPE_IMG
- en: In the beautiful pure sine wave, certain effects might not be clearly visible.
    Let’s introduce some noise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: And run the experiment one more time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can observe the power of denoising and understand how various filters
    work.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/95444bfb056fc8fe8a957d93d48dc5e8.png)'
  prefs: []
  type: TYPE_IMG
- en: In this experiment, we precisely identify the function we generated (a pure
    sine wave). While investigating the actual data, we aim to determine the function
    describing our phenomenon, such as failure signals or continuously increasing
    equipment wear. Noise will always be present in our data, and understanding how
    to handle it is crucial.
  prefs: []
  type: TYPE_NORMAL
- en: Seasonal decomposition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Seasonal decomposition is a powerful technique used in signal processing to
    understand the different components of a signal and investigate its seasonal patterns.
    Signals, in this context, can represent various phenomena, such as economic data,
    environmental variables, or even electrical signals. The goal of seasonal decomposition
    is to break down a complex signal into its fundamental parts, making it easier
    to analyze and interpret.
  prefs: []
  type: TYPE_NORMAL
- en: 'A signal typically consists of three main components: the trend, the seasonal
    component, and the residual (or noise). The trend represents the long-term behavior
    or overall pattern of the signal, the seasonal component captures repetitive patterns
    that occur at regular intervals, and the residual is the leftover variation or
    noise that cannot be explained by the trend or seasonality.'
  prefs: []
  type: TYPE_NORMAL
- en: By decomposing a signal into these components, analysts can gain insights into
    the underlying patterns and trends, helping them make more informed decisions.
    This process is particularly valuable in fields such as finance, climate science,
    and manufacturing, where understanding seasonal variations is crucial for accurate
    forecasting and effective decision-making.
  prefs: []
  type: TYPE_NORMAL
- en: In this exploration of seasonal decomposition, we’ll delve into the methodology
    of breaking down signals, examining each component individually, and learning
    how to investigate and interpret the insights gained from this analytical approach.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/9a31d6bb4e859b3647f61745f604c30f.png)'
  prefs: []
  type: TYPE_IMG
- en: Make our sine wave more interesting by adding cool signals. I’ll tweak the signal
    generation to imitate equipment wear and tear, picturing it like parts of a machine
    gradually wearing down over time. This might result in more vibrations due to
    increased friction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Start the experiment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/462fe7b242aae071998bfa86bf336461.png)'
  prefs: []
  type: TYPE_IMG
- en: Wow! In our original noisy signal, we couldn’t find anything. However, after
    breaking it down into parts, we discovered the trend component, which is now clearly
    visible. This is a sign.
  prefs: []
  type: TYPE_NORMAL
- en: What next?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next article we will investigate why checking the stationarity is important,
    what are unit roots and play with the feature engineering. Follow me to does not
    miss it :)
  prefs: []
  type: TYPE_NORMAL
