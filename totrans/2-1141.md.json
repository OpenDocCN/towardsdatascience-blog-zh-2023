["```py\ndef get_fraud_cluster(df, AttendingPhysician, MaxHops):\n    \"\"\"\n    Returns fraudulent claims associated with the given AttendingPhysician \n    and beneficiaries served up to a maximum number of hops or convergence\n\n        Parameters:\n            df (DataFrame): A Pandas DataFrame with claims data.\n            AttendingPhysician (str): ID of attending physician to start with as the root node.\n            MaxHops (int): Maximum number of hops.\n\n        Returns:\n            df (DataFrame): A Pandas Dataframe containing fraudulent claims associated \n            with supplied AttendingPhysician up to a maximum number of hops away.\n    \"\"\"\n    # Initial variables\n    prev_cluster_size = 0\n    current_cluster_size = 1\n    i = 0\n\n    # Add initial physician to set_physicians\n    set_physicians = set([AttendingPhysician])\n    set_beneficiaries = set()\n\n    while prev_cluster_size < current_cluster_size and i < MaxHops:\n\n        prev_cluster_size = len(set_physicians) + len(set_beneficiaries)\n\n        # Get fraudulent physicians with claims associated with fraudulent beneficiaries\n        fraud_physicians = df[\n            (df.BeneID.isin(set_beneficiaries)) &\n            (df.PotentialFraud == 1)\n        ][\"AttendingPhysician\"].unique()\n        new_fraud_physicians = set(fraud_physicians).difference(set_physicians)\n\n        # Update set with new fraudulent physicians\n        set_physicians.update(new_fraud_physicians)\n\n        # Get fraudulent beneficiaries with claims associated with fraudulent physicians\n        fraud_beneficiaries = df[\n            (df.AttendingPhysician.isin(set_physicians)) &\n            (df.PotentialFraud == 1)\n        ][\"BeneID\"].unique()\n        new_fraud_beneficiaries = set(fraud_beneficiaries).difference(set_beneficiaries)\n        # Upate set with new fraudulent beneficiaries\n        set_beneficiaries.update(new_fraud_beneficiaries)\n\n        # update variables\n        i += 1\n        current_cluster_size = len(set_physicians) + len(set_beneficiaries)\n\n    # Final dataset of physicians and beneficiaries in sets with fraudulent claims\n    df_results = df[\n        (df.AttendingPhysician.isin(set_physicians)) &\n        (df.BeneID.isin(set_beneficiaries)) &\n        (df.PotentialFraud == 1)\n    ]\n\n    return df_results\n```", "```py\n# Initialize empty networkx graph\nG = nx.Graph()\n\n# Build graph from df\nfor row in df.itertuples():\n  # Add nodes for beneficiaries\n  G.add_node(row.BeneID, label=(\"BeneID\", row.BeneID, row.ClaimStartDt))\n  # Assign a different node label (for node color later on) for root Physician\n  if RootPhysicianID and row.AttendingPhysician == RootPhysicianID:\n      G.add_node(row.AttendingPhysician, label=(\"RootPhysician\", row.AttendingPhysician, row.ClaimStartDt))\n  else:\n      G.add_node(row.AttendingPhysician, label=(\"AttendingPhysician\", row.AttendingPhysician, row.ClaimStartDt))\n  # Add edges\n  G.add_edge(row.BeneID, row.AttendingPhysician, label=(row.BeneID, row.AttendingPhysician, row.ClaimStartDt))\n\n# Get positions\npos = nx.spring_layout(G)\n\nprint(\"Finished building graph (G).\")\n```", "```py\n# Grab unique months in dataset \nmonths = [\n    i.to_timestamp(\"D\") for i in pd.to_datetime(\n        df[\"ClaimStartDt\"]\n    ).dt.to_period(\"M\").sort_values().unique()\n]\n```", "```py\n# Loop through months\nfor month in months:\n    month_str = month.strftime(\"%Y-%m\")\n\n    # Duplicate original graph for a new graph in current month\n    new_G = G.copy()\n\n    # Extract nodes and edges to remove \n    nodes_to_remove = [\n        node for node in new_G.nodes() \n        if \"label\" in new_G.nodes[node] \n        and new_G.nodes[node][\"label\"][-1] >= month\n    ]\n    edges_to_remove = [\n        (u, v) for u, v, data in new_G.edges(data=True) \n        if \"label\" in data and data[\"label\"][-1] >= month\n    ]\n\n    # Remove self-loops\n    for u, v, label in new_G.edges(data=True):\n        if u == v:\n            new_G.remove_edge(u, v)\n\n    # Remove nodes and edges from new graph\n    new_G.remove_edges_from(edges_to_remove)\n    new_G.remove_nodes_from(nodes_to_remove)\n```", "```py\ndef plot_graph(G, pos, fig):\n    # Define colors with hex codes\n    color_mappings = {\n        \"BeneID\": \"#66bfbf\", # teal green\n        \"AttendingPhysician\": \"#fecea8\",  # light orange\n        \"RootPhysician\": \"#f76b8a\", # pinkish red\n    }\n\n    # Select nodes\n    node_x = [pos[node][0] for node in G.nodes() if node in pos]\n    node_y = [pos[node][1] for node in G.nodes() if node in pos]\n\n    # Select edges\n    edge_x = []\n    edge_y = []\n    for u, v, label in G.edges(data=True):\n        if u in pos and v in pos:\n            x0, y0 = pos[u]\n            x1, y1 = pos[v]\n            edge_x.extend([x0, x1, None])\n            edge_y.extend([y0, y1, None])\n\n    # Additional text to show on hover\n    node_text = [data[\"label\"] for node, data in G.nodes(data=True)]\n    node_colors = [color_mappings.get(data[\"label\"][0]) for node, data in G.nodes(data=True)]\n\n    # Add nodes and edges to plot\n    fig.add_trace(\n        go.Scatter(\n            x=edge_x, \n            y=edge_y,\n            mode=\"lines\",\n            line=dict(color=\"gray\"),\n            name=\"Edges\"\n        )\n    )\n    fig.add_trace(\n        go.Scatter(\n            x=node_x,\n            y=node_y,\n            mode=\"markers\",\n            marker=dict(size=10, color=node_colors),\n            text=node_text,\n            hoverinfo=\"text\",\n            opacity=0.8,\n            name=\"Nodes\",\n        )\n    )\n\n    return fig\n```", "```py\n# Plot new graph for this month and add to figure\nfig = plot_graph(G=new_G, pos=pos, fig=fig)\n```", "```py\n# Configure slider\nsteps = []\nfor i, month in enumerate(months):\n    idx = i * 2   # multiply by 2 because one trace is for nodes and one is for edges\n    month_str = month.strftime(\"%Y-%m\")\n    visibility = [False] * len(months) * 2   # Make all traces not visible by default\n    visibility[idx] = True   # Make trace for nodes visible\n    visibility[idx + 1] = True    # Make trace for edges visible\n    step = dict(\n        method=\"update\",\n        label=\"Month: %s\" % month_str,\n        args=[{\"visible\": visibility}],\n    )\n    steps.append(step)\n\n# Make first graph visible\nfig.data[1].visible = True\n```", "```py\n# Update figure settings\nfig.update_layout(\n    title=\"Time Series Graph Visualization for Root PhysicianID = %s\" % RootPhysicianID,\n    showlegend=False,\n    hovermode=\"closest\",\n    xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n    yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n    sliders=[\n        dict(\n            active=0,\n            steps=steps,\n            pad={\"t\": 50}\n        ),\n    ],\n)\n```", "```py\nplotly.offline.plot(fig, filename=\"./graph_viz.html\")\n```"]