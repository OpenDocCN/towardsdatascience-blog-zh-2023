- en: 'Fourier-transform for Time Series : Plotting Complex Numbers'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/fourier-transform-for-time-series-plotting-complex-numbers-9743ffe8a8bb](https://towardsdatascience.com/fourier-transform-for-time-series-plotting-complex-numbers-9743ffe8a8bb)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Plot the Fourier-transform algorithm to understand it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://mocquin.medium.com/?source=post_page-----9743ffe8a8bb--------------------------------)[![Yoann
    Mocquin](../Images/b30a0f70c56972aabd2bc0a74baa90bb.png)](https://mocquin.medium.com/?source=post_page-----9743ffe8a8bb--------------------------------)[](https://towardsdatascience.com/?source=post_page-----9743ffe8a8bb--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----9743ffe8a8bb--------------------------------)
    [Yoann Mocquin](https://mocquin.medium.com/?source=post_page-----9743ffe8a8bb--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----9743ffe8a8bb--------------------------------)
    ·12 min read·Jul 28, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/181123c59bab3c833c451456239aa279.png)'
  prefs: []
  type: TYPE_IMG
- en: Most of the time, people have trouble handling the Fourier transform of a signal
    because of its complex form. Except for very specific cases, the Fourier transform
    of a time series is most of the time a complex-numbered sequence — and complex
    numbers are not always simple to grasp, especially when you are not used to handling
    those kinds of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**In this post, I want to show a few ways to visualize the Fourier transform
    of a 1D sequence of real numbers**, which is what you handle 99% of the time,
    especially in data analysis and time series.'
  prefs: []
  type: TYPE_NORMAL
- en: '*All images by author.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This post is the third of my Fourier-transform for time-series. Check out the
    previous posts here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Review how the convolution relate to the Fourier transform and how fast it
    is:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[](/fourier-transform-for-time-series-fast-convolution-explained-with-numpy-5a16834a2b99?source=post_page-----9743ffe8a8bb--------------------------------)
    [## Fourier transform for time-series: fast convolution explained with numpy'
  prefs: []
  type: TYPE_NORMAL
- en: 10000-times faster convolution using Fourier transform
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/fourier-transform-for-time-series-fast-convolution-explained-with-numpy-5a16834a2b99?source=post_page-----9743ffe8a8bb--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 'Deepen your understanding of convolution using image examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[](/fourier-transform-for-time-series-about-image-convolution-and-scipy-5e8fa1279603?source=post_page-----9743ffe8a8bb--------------------------------)
    [## Fourier-Transform for Time Series: About Image Convolution and SciPy'
  prefs: []
  type: TYPE_NORMAL
- en: Fourier-transform convolution also applies to images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/fourier-transform-for-time-series-about-image-convolution-and-scipy-5e8fa1279603?source=post_page-----9743ffe8a8bb--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 'Before diving into the actual computing and plotting of 1D Fourier transforms,
    we’ll review a few basic concepts of complex numbers that are crucial to what’s
    next. As you’ll see, complex numbers are actually pretty simple: just consider
    them as a vector of 2 numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The end goal of this post is to make you more comfortable with the actual
    numbers behind your Fourier transforms.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Quick review of complex numbers**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any complex number can be represented with its canonical form, using 2 real
    values, a and b, respectively called their “**real**” and “**imaginary**” parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9289bc5bd13b7390319bceb90686d260.png)'
  prefs: []
  type: TYPE_IMG
- en: 'where ***i*** is the unit complex number with the well-known property that
    if you square it, you get -1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/42ffe759428c2848d4164270de86d843.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also rewrite the above equation for Z as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/eebfdab3054bba1565cc3f91d24de57c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'or again using dot product of vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/de16d6fb4573ad3d2290258568b6dbe0.png)'
  prefs: []
  type: TYPE_IMG
- en: If we were to represent Z on an (x, y) plane with the x-axis for the real part
    (1) and the y-axis for the imaginary part (i), we’d plot Z as a vector from (0,
    0) to (a, b).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use NumPy and Matplotlib to plot an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/b822fb5f161d67848d67b5d8ed770e7c.png)'
  prefs: []
  type: TYPE_IMG
- en: Plot of 2 complex numbers as vectors (red and blue), and their sum (green).
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, it is easy to represent the complex numbers Z1​ and Z2​ as
    vectors on a 2D plane. Consequently, we can easily compute and plot the sum of
    2 complex numbers: we just sum the vectors. And that’s really all there is to
    remember; everything that follows is just fancy notations and plotting, along
    with some useful mathematical properties.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to represent the same vector is using the polar notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0b20714bef1a8d3828bda3b269513959.png)'
  prefs: []
  type: TYPE_IMG
- en: where ∣Z∣ is called the “module” of Z, and θ is called the “argument” (I’ll
    usually call this variable the “phase angle”). Geometrically, the module represents
    the length of the vector, and its phase angle represents the angle of the vector
    with respect to the Ox axis, also called the direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a direct correspondence between the canonical notation (a, b) and
    the polar notation (module, phase); it’s just another way to write the same vector.
    Indeed, remember that the complex exponential is just the sum of a cosine and
    an imaginary sine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/07a16dedb0de41fb96a58dd68dd640e5.png)'
  prefs: []
  type: TYPE_IMG
- en: so if we plot this complex number, the real part is cos⁡(θ) and the imaginary
    part is sin⁡(θ); its coordinates in the complex plane are (cos⁡(θ),sin⁡(θ)). Extending
    this idea to any complex number, we get a real part ∣Z∣cos⁡(θ) and an imaginary
    part ∣Z∣sin⁡(θ).
  prefs: []
  type: TYPE_NORMAL
- en: 'With NumPy, we can easily compute the real, imaginary, module, and phase components
    of a complex number. We can even check that both notations lead to the exact same
    complex number. Indeed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we know that complex numbers behave just like vectors, we can use
    what we know about vectors and apply it to complex numbers. For example, when
    we add 2 complex numbers, their sum is just the complex number corresponding to
    the sum of the underlying vectors. Let’s use Python again to see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/69b4fed6d137feee95c6c401123f9c35.png)'
  prefs: []
  type: TYPE_IMG
- en: Plot of sum of 2 complex numbers (left) and mean (right).
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the mean of complex numbers is just the sum of the vectors, scaled
    along its direction by the number of vectors. Scaling a vector corresponds to
    decreasing or increasing its length, but not changing its direction. For a scale
    factor K:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/daecd83859ec308d987bb141d3ad48ab.png)'
  prefs: []
  type: TYPE_IMG
- en: which is a new complex number with a new length ∣Z′∣=K∣Z∣ (i.e., we scaled the
    module), but with the same phase angle (i.e., the vector has the same direction).
  prefs: []
  type: TYPE_NORMAL
- en: '**So remember:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**The same complex number Z can be represented as Z=a+ib or Z=∣Z∣e^(−iθ), where
    ∣Z∣ represents the length of the vector, and θ its direction.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Summing/averaging complex numbers behaves exactly like summing/averaging
    vectors.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vector approach to Fourier-transform**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s review the formula for the Fourier transform in the context of a discrete
    sample sequence, called the Discrete Fourier Transform (DFT):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4d7b02beaad1bd8b28558be4d2a15bcf.png)'
  prefs: []
  type: TYPE_IMG
- en: with
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5fbec66517ed0c83c835fd5b4457bac8.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that several definitions exist using either none, 1/N​, or 1/N**0.5 as
    the scaling coefficient. I usually prefer using no scaling factor, but in this
    post, I’ll use the 1/N​ scaling factor as in the equation above.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s describe what this equation tells us :'
  prefs: []
  type: TYPE_NORMAL
- en: The k-th element of the Fourier transform (X[k]) is a complex number, given
    by the mean of a set of complex numbers (the Zkn​s).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Using what we now know about complex numbers and vectors, we can obtain the
    k-th coefficient of the Fourier transform just by plotting all the little complex
    numbers Zkn​, summing them (like regular vector sum), and scaling down the result
    by 1/N​.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use Python to plot an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/cec2693f95f5003721a00f05aafe2316.png)'
  prefs: []
  type: TYPE_IMG
- en: Input sequence we want to compute the Fourier transform (left) and visual computing
    of the Fourier coefficient X[k=1] (right).
  prefs: []
  type: TYPE_NORMAL
- en: '**On the left** is the input sequence for which we want to compute the Fourier
    transform coefficients, X[k] for k=0 to N−1\. To better understand what’s happening,
    a color is used for each sample.'
  prefs: []
  type: TYPE_NORMAL
- en: '**On the right**, all the vectors Zkn​ for k=1 are represented, each with a
    corresponding color. Notice that the length of vector Zkn​ is given by x[n]. These
    vectors are plotted twice: once starting from (0,0), and once where they are added
    cumulatively. The total sum corresponds to the end of the yellow arrow, which
    is equal to the red vector. This red vector represents the Fourier transform coefficient
    X[k=1].'
  prefs: []
  type: TYPE_NORMAL
- en: 'This way, we get the vector representing the k-th coefficient of the Fourier
    transform: in other words, we just computed the value of X[k]. We can use the
    same steps to compute each coefficient, looping over k.'
  prefs: []
  type: TYPE_NORMAL
- en: '**In the example below**, we compute the little vector families for all k=0
    to N−1\. For each value of k, we plot all the small vectors Zks​, the cumulative
    vector sum, as well as the final total sum in red. This way, the final red arrow
    represents the value of the Fourier transform for that value of k: again, it is
    just a complex number with a certain module and a certain phase angle. **In other
    words, the red arrow for any k is just the vector representation of X[k].**'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we check that our ‘hand’ computation of the Fourier coefficients leads
    to the same values as numpy’s.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/4553f990dfc9b80cd8a83df3a8cd5ba8.png)'
  prefs: []
  type: TYPE_IMG
- en: Visual computing representation of all Fourier coefficients, for k=0 to N-1\.
    The final value of X[k] is given as the sum of all the colored vectors for that
    value of k.
  prefs: []
  type: TYPE_NORMAL
- en: 'And that’s it : **the Fourier coefficient X[k] is given by the red arrow, for
    each value of k.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Few things to notice :'
  prefs: []
  type: TYPE_NORMAL
- en: '**For k=0**, all vectors are aligned with each other on the x-axis, hence they
    add up exactly, as the sum of real values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For k=1 and k=9**, the colored vectors neatly add up giving a complex sum
    vector.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For other values of k**, the little vectors basically cancel each others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know how to visually compute each element of the Fourier transform,
    the end result is the whole discrete Fourier transform sequence, which is another
    sequence of complex numbers. In the next part, we are going to plot this whole
    complex sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '**Plotting the Fourier Transform Sequence**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know how the Fourier-transform coefficients X[k] are computed,
    both mathematically and visually, the result is a sequence of complex numbers
    X[k], which we can plot in various ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Plot the real and imaginary parts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plot the module and phase angle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plot the 2D vectors, along a third axis representing the index kk.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the numpy functions seen above, we can easily extract all these features
    and plot them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/319b737786e1a6ed988b7fa1791e176e.png)'
  prefs: []
  type: TYPE_IMG
- en: Input sequence (top-right), and 3 ways to represent its Fourier transform.
  prefs: []
  type: TYPE_NORMAL
- en: '**First up is the 3D plot**: the z-axis represents each index of the Fourier-transform
    sequence k in X[k]. On each of those z=kz=k XY-planes, the vector X[k] is plotted,
    with the real part on the x-axis and the imaginary part on the y-axis. That being
    said, notice how the X[k] coefficients are almost purely real, with vectors almost
    aligned with the y-axis, indicating a very small imaginary part. This is because
    our input sequence is almost perfectly symmetric, hence its Fourier-transform
    is almost purely real (that’s a property we’ll explore in-depth another time).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Second is the Real and Imaginary part plot**: Another way to visualize a
    Fourier-transform sequence is to plot its real and imaginary parts. This is pretty
    much the same as the values you’ll see if you align the 3D plot view either to
    the x-axis or the y-axis. Although it’s easier to understand intuitively and compare
    with the 3D plot, it isn’t used that much.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Finally, the Module and Phase angle plot**: Remember that the module is literally
    the length of each vector, and the phase angles represent their directions. The
    module values are easier to understand from the 3D plot, as it simply gives the
    length of the vectors, but not so much from the real/imaginary plot. Regarding
    the phase angles,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wrapup**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the key points you should absolutely remember:'
  prefs: []
  type: TYPE_NORMAL
- en: Complex numbers are just vectors, with a real part on the x-axis and an imaginary
    part on the y-axis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'They behave like vectors: you know what adding and scaling vectors mean, so
    you know how it acts on complex numbers as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can use various representations/decompositions of a complex number: as
    a 2D vector, or extract its real/imaginary part, its length with its module, and
    its direction with its phase angle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Fourier-transform is a sequence of complex numbers: each of these complex
    numbers is itself a sum (or average) of a sequence of other complex numbers with
    modules (i.e., length) x[n]x[n] and phase angles (i.e., direction) −2πkn/N:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/da6266c541a50ec8129c6881a338295b.png)'
  prefs: []
  type: TYPE_IMG
- en: with
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5fbec66517ed0c83c835fd5b4457bac8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you liked this post, check out my other posts: I usually try to explain
    concepts using simple numpy and maplotlib code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://mocquin.medium.com/one-sample-t-test-visually-explained-415c31744e14?source=post_page-----9743ffe8a8bb--------------------------------)
    [## One-sample t-test, visually explained'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to one of the most famous statistical tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'mocquin.medium.com](https://mocquin.medium.com/one-sample-t-test-visually-explained-415c31744e14?source=post_page-----9743ffe8a8bb--------------------------------)
    [](/pca-lda-ica-a-components-analysis-algorithms-comparison-c5762c4148ff?source=post_page-----9743ffe8a8bb--------------------------------)
    [## PCA/LDA/ICA : a components analysis algorithms comparison'
  prefs: []
  type: TYPE_NORMAL
- en: Review the concepts and differences between these famous algorithms.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'towardsdatascience.com](/pca-lda-ica-a-components-analysis-algorithms-comparison-c5762c4148ff?source=post_page-----9743ffe8a8bb--------------------------------)
    [](/pca-whitening-vs-zca-whitening-a-numpy-2d-visual-518b32033edf?source=post_page-----9743ffe8a8bb--------------------------------)
    [## PCA-whitening vs ZCA-whitening : a numpy 2d visual'
  prefs: []
  type: TYPE_NORMAL
- en: The process of whitening data consists in a transformation such that the transformed
    data has identity matrix as…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/pca-whitening-vs-zca-whitening-a-numpy-2d-visual-518b32033edf?source=post_page-----9743ffe8a8bb--------------------------------)
    [](/300-times-faster-resolution-of-finite-difference-method-using-numpy-de28cdade4e1?source=post_page-----9743ffe8a8bb--------------------------------)
    [## 300-times faster resolution of Finite-Difference Method using numpy
  prefs: []
  type: TYPE_NORMAL
- en: Finite-difference method is a powerfull technique to solve complex problems,
    and numpy makes it fast !
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/300-times-faster-resolution-of-finite-difference-method-using-numpy-de28cdade4e1?source=post_page-----9743ffe8a8bb--------------------------------)
    [](https://medium.com/analytics-vidhya/deep-dive-into-seaborn-palettes-7b5fae5a258e?source=post_page-----9743ffe8a8bb--------------------------------)
    [## Deep dive into seaborn palettes
  prefs: []
  type: TYPE_NORMAL
- en: Drowning in seaborn palettes ?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/analytics-vidhya/deep-dive-into-seaborn-palettes-7b5fae5a258e?source=post_page-----9743ffe8a8bb--------------------------------)
    [](/interactive-plotting-the-well-know-rc-circuit-in-jupyter-d153c0e9d3a?source=post_page-----9743ffe8a8bb--------------------------------)
    [## Interactive plotting the well-know RC-circuit in Jupyter
  prefs: []
  type: TYPE_NORMAL
- en: Another step into ipywidgets and matplotlib
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/interactive-plotting-the-well-know-rc-circuit-in-jupyter-d153c0e9d3a?source=post_page-----9743ffe8a8bb--------------------------------)
  prefs: []
  type: TYPE_NORMAL
