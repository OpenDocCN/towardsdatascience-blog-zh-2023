- en: Animating Spatial Movement in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/animating-spatial-movement-in-python-ccf4e9462a0f](https://towardsdatascience.com/animating-spatial-movement-in-python-ccf4e9462a0f)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How to turn an origin-destination matrix into a mesmerizing animation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@haavardwallinaagesen?source=post_page-----ccf4e9462a0f--------------------------------)[![Håvard
    Wallin Aagesen](../Images/45b79e090806b39359781b56710cbe77.png)](https://medium.com/@haavardwallinaagesen?source=post_page-----ccf4e9462a0f--------------------------------)[](https://towardsdatascience.com/?source=post_page-----ccf4e9462a0f--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----ccf4e9462a0f--------------------------------)
    [Håvard Wallin Aagesen](https://medium.com/@haavardwallinaagesen?source=post_page-----ccf4e9462a0f--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----ccf4e9462a0f--------------------------------)
    ·6 min read·Nov 23, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/61608028da72395e20f21dca85cb6f13.png)'
  prefs: []
  type: TYPE_IMG
- en: Static map of movements from bike sharing data. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: Spatial data is inherently visual, and the advances in visualizing (geo-)spatial
    data in Python has made it very easy to quickly plot maps of all shapes and forms.
    Even creating animations of charts and simple maps is quite easily possible. Choropleth
    maps in particular, with static polygons and changing colours, there are ready-made
    functions to do.
  prefs: []
  type: TYPE_NORMAL
- en: But, when it comes to movement data and animating lines, the task is a bit more
    cumbersome. Here I will try to give an example of how I have tried to solve animating
    spatial movement data in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Initial Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start, we need some (line-)data with timestamps; in this example I will use
    bike sharing data from the bike sharing system in Oslo, Norway. The data is openly
    available under the [Norwegian Licence for Open Government Data (NLOD) 2.0](https://data.norge.no/nlod/no/2.0#_lisensavtalens_innledning)/Open
    Government License, from the homepage of [Oslo Bysykkel.](https://oslobysykkel.no/en/open-data)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/354963fa584d5a2b6b724da8d3e451e4.png)'
  prefs: []
  type: TYPE_IMG
- en: The first five rows of the initial dataset. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: As the data consist of the start and end points of the trips, we need to create
    a line between the points, and for that we can use the implementation of Dijkstra’s
    algorithm in NetworkX.
  prefs: []
  type: TYPE_NORMAL
- en: Creating movement lines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can create the movement lines, we need a network of streets that we
    can use to for a shortest path calculation. With `osmnx` we can retrieve a bike
    network from OpenStreetMap for the area we are interested in. We will use the
    extent of the bike trip data as our study area.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To calculate the shortest path with Dijkstra’s Algorithm we can create a function
    which we will apply to our dataframe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now apply the function to the dataframe. To do so, we create Shapely
    Points for the start and end points, and then use these in function to calculate
    the path between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/628ce3f468ef6e39878eb79efadd9dda.png)'
  prefs: []
  type: TYPE_IMG
- en: Dataset now with shortest path. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start splitting the lines up into points along the path, we can prepare
    the time data so that it can be displayed nicely in our final animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/b9fcef2d05b905ca87e58a624d7b9c63.png)'
  prefs: []
  type: TYPE_IMG
- en: One of the rows calculated into the shortest path between the start and end
    point. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting up lines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our movement lines, the idea is to create a dot along this
    line at a set interval so that we can plot the points in order based on the time.
  prefs: []
  type: TYPE_NORMAL
- en: The following `line_to_points()`-function goes through each of the lines in
    our dataframe and splits the line up into segments based on the duration of the
    bike trips. In this example, each line is split up after 15 seconds and a point
    is created at that location.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With the `line_to_points()`-function we create a new dataframe with only the
    points we want to animate with a timestamp that we can iterate over when we do
    the plotting.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/e750c61c1ce08d551aa47f1deb9fa32d.png)'
  prefs: []
  type: TYPE_IMG
- en: Lines converted into timestamped points. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: Animating the movements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to plot the new point data we create a geodataframe which contain
    the timestamp, size of the point, and the coordinates for each point.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The essential goal here is now to create a plot for each timestamp in the new
    geodataframe and late combine all these plots into a GIF-animation. To do that,
    we create a function which will plot a single row in the geodataframe, and at
    the same time plot all the previous rows with a small dot size. That way we get
    the largest dot for the current time while still seeing the previous dots, giving
    an impression of the entire path up to that point.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can now use the list of timestamps that we created before, `times`, and iterate
    over each timestamp and run the function `plot_minute()` to make a map for each
    of the timestamps of data we have.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/1286f6e36dd46e7bfadee393deec629f.png)'
  prefs: []
  type: TYPE_IMG
- en: One of the plotted maps at a single minute. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: Converting to GIF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The result of running `plot_minute()` for all our timestamps is that we now
    have a folder full of .png maps. There are several ways to animate a sequence
    of pngs, and on a UNIX-based system you can run the `convert` program in bash.
    Depending on the parameters set for the plots, the resulting file sizes of the
    pngs and the animation itself can get very large, so it might be necessary to
    resize to reduce the file size.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can take a look at the final result:'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this article I have shown you one way of turning a points dataset of mobility
    into an animated map based on the shortest path algorithm, using just a few common
    Python libraries.
  prefs: []
  type: TYPE_NORMAL
- en: The solution will work for any origin-destination matrix with an accompanying
    network and bike sharing data is accessible for many cities around the world.
    Hopefully it can inspire you to explore bike sharing patterns and urban structure
    in other cities!
  prefs: []
  type: TYPE_NORMAL
