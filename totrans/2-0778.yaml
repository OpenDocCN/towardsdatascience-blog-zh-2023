- en: Easy CDK Deep Learning EC2 Instances
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/easy-cdk-deep-learning-ec2-instances-f30fbeec1ea3](https://towardsdatascience.com/easy-cdk-deep-learning-ec2-instances-f30fbeec1ea3)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Deploying an EC2 instance for deep learning is easy with CDK
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://nbertagnolli.medium.com/?source=post_page-----f30fbeec1ea3--------------------------------)[![Nicolas
    Bertagnolli](../Images/6f2ee2f49fae47f1dd89d8484303b20c.png)](https://nbertagnolli.medium.com/?source=post_page-----f30fbeec1ea3--------------------------------)[](https://towardsdatascience.com/?source=post_page-----f30fbeec1ea3--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----f30fbeec1ea3--------------------------------)
    [Nicolas Bertagnolli](https://nbertagnolli.medium.com/?source=post_page-----f30fbeec1ea3--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----f30fbeec1ea3--------------------------------)
    ·10 min read·Jan 18, 2023
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5946aec4ae6ed299708df43b4bca69d2.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
- en: The rough overview of what we are building today.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a data scientist I often have to run jobs on GPUs in the cloud and I have
    a visceral hate for clicking through UIs. In the past when I needed a GPU instance
    for some one-off model training I laboriously navigated through AWS’ UI. Not anymore!
    Now it’s easy to create an EC2 stack that knows how to install and instantiate
    everything you need. In this tutorial we’ll use AWS CDK to create an EC2 instance.
    We’ll protect that EC2 instance on a private subnet in a VPC and only allow inbound
    traffic. We’ll then connect to this instance using AWS [Secure Session Manager](https://docs.aws.amazon.com/systems-manager/latest/userguide/what-is-systems-manager.html)
    (SSM). This is cool because in the past if you wanted your machine to be on a
    purely private network you needed a bastion host, with SSM this is no longer the
    case! All of the code for this tutorial can be found here. At the end of all of
    this you’ll be able to run a few commands and have a fully functioning Data Science
    ready secure EC2 instance with a JupyterLab interface.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: All code for this tutorial can be found [here](https://github.com/nbertagnolli/ds-ec2).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: CDK
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CDK is the cloud development kit created by AWS. It allows us to create resources
    in the cloud using languages like python or typescript. It’s really easy to use
    and it’s free unlike services like [Pulumi](https://www.pulumi.com/) (What I use
    in production). However, CDK is just a wrapper around CloudFormation so you inherit
    all of the limitations of that system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: If you’re interested in learning a bit more about CDK I’d recommend following
    this [tutorial](https://cdkworkshop.com/30-python.html). It will walk you through
    everything you need to setup CDK and create a very simple API. It’s well worth
    the read if you haven’t. I’m going to assume that you’ve completed the `New Project`
    section of that tutorial and setup CDK on your local machine. From here on out
    we’ll focus on creating the EC2 instance.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对了解 CDK 多一些感兴趣，我建议你查看这个 [教程](https://cdkworkshop.com/30-python.html)。它会指导你完成设置
    CDK 和创建一个非常简单的 API 所需的一切。如果你还没有读过，这值得一读。我假设你已经完成了该教程的 `New Project` 部分，并在本地机器上设置了
    CDK。从现在开始，我们将重点关注创建 EC2 实例。
- en: Create a project folder
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个项目文件夹
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once inside the new folder we can instantiate our project.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 进入新文件夹后，我们可以实例化我们的项目。
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will create a bunch of files but there are really only two that you need
    to focus on and that’s app.py and ds_ec2_stack.py.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一堆文件，但实际上你只需要关注两个文件，即 app.py 和 ds_ec2_stack.py。
- en: app.py defines the CDK app and is the entry point for deployment. If you want
    to deploy multiple interconnected stacks this is the place to edit. We won’t be
    doing much here though.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: app.py 定义了 CDK 应用程序，并且是部署的入口点。如果你想部署多个互联的堆栈，这就是需要编辑的地方。不过，我们这里不会做太多的操作。
- en: ds_ec2_stack.py is where we will define our stack and resources. It’s the workhorse
    of this whole system so let’s get started by editing this file and adding what
    we want!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ds_ec2_stack.py 是我们定义堆栈和资源的地方。这是整个系统的工作马，所以让我们开始编辑这个文件并添加我们想要的内容！
- en: '![](../Images/3b68739884b5fe95b013ff56ba8fd9cf.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3b68739884b5fe95b013ff56ba8fd9cf.png)'
- en: Activate your environment and install the CDK libraries.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 激活你的环境并安装 CDK 库。
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Creating the EC2 instance and other resources.
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 EC2 实例和其他资源。
- en: If you don’t care about the particulars of CDK and what is happening skip down
    to Deploying the stack and just clone the repository.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不在乎 CDK 的细节和发生了什么，可以跳到部署堆栈部分并直接克隆仓库。
- en: 'Otherwise, the code below needs to:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，下面的代码需要：
- en: 1\. Create a VPC
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1\. 创建 VPC
- en: We create a VPC for all of our resources to live in.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为所有资源创建一个 VPC。
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 2\. Assign permissions for the instance to use SSM
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2\. 为实例分配使用 SSM 的权限
- en: We create an IAM role for this instance which allows us to add a managed policy
    giving the instance the ability to be connected to through SSM.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为这个实例创建一个 IAM 角色，这使我们能够添加一个托管策略，赋予实例通过 SSM 连接的能力。
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 3\. Create a Security Group
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3\. 创建一个安全组
- en: We want our instance to be on a private subnet and only allow inbound traffic.
    This helps with security because nothing in our instance can leave our network.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的实例位于私有子网中，并只允许入站流量。这有助于安全性，因为实例中的任何内容都不能离开我们的网络。
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 4\. Install all of the python libraries we care about
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4\. 安装我们关心的所有 Python 库
- en: One thing that is nice about using CDK is we can setup custom logic around installing
    Python dependencies. I have mine setup to install a bunch of common libraries
    that I use so once I connect to the instance it’s ready to go. We can do that
    using CDK by using [ec2.MultipartUserData()](https://docs.aws.amazon.com/cdk/api/v1/python/aws_cdk.aws_ec2/MultipartUserData.html).
    This is just a fancy way of passing in user data to the instance to allow it to
    run some configuration for you.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 CDK 的一个优点是我们可以设置有关安装 Python 依赖项的自定义逻辑。我已经设置了安装我使用的许多常用库，因此一旦我连接到实例，它就可以立即使用。我们可以使用
    CDK 来做到这一点，通过 [ec2.MultipartUserData()](https://docs.aws.amazon.com/cdk/api/v1/python/aws_cdk.aws_ec2/MultipartUserData.html)。这只是一个传递用户数据到实例的高级方式，以便它为你运行一些配置。
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a requirements.txt file in your project next to app.py. For me my file
    looks like:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目中创建一个 `requirements.txt` 文件，位于 app.py 旁边。对我来说，我的文件如下：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Then load in a requirements.txt file so we know which packages to install.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后加载 `requirements.txt` 文件，以便我们知道要安装哪些软件包。
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 5\. Add some block storage so we can load in some data
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5\. 添加一些块存储，以便我们可以加载一些数据
- en: The default disk space on the EC2 instances is kind of small and usually I want
    a few GB’s of data loaded onto the instance to do my work. This attaches an EBS
    volume for additional disk space.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: EC2 实例上的默认磁盘空间有点小，通常我希望在实例上加载几 GB 的数据来进行工作。这会附加一个 EBS 卷以提供额外的磁盘空间。
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 6\. Get the correct machine image for our instance type
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6\. 获取适合我们实例类型的正确机器镜像
- en: If we are running a CPU instance we can use AmazonLinux
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行的是 CPU 实例，我们可以使用 AmazonLinux
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If we are running a GPU we need to use a generic_linux MachineImage and pass
    it the AMI for the deep learning instance we want. For example, if deploying in
    us-west-2 we could use ami-0a83cbb39db39cb3e.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 7\. Create the EC2 instance
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last step is to instantiate the ec2 instance with everything we’ve made
    so far.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Final Stack
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final stack I use is here. You’ll notice there is some additional logic.
    This logic checks whether the desired instance is a GPU or a CPU and then selects
    the correct stack components.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Deploying the Stack
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To deploy your stack run you’ll need to set two environment variables. `INSTANCE_TYPE`
    and `AWS_AMI` if you are using a GPU. If you want to deploy with the defaults
    you don’t need to set either of them. As an example of deploying a GPU instance
    run:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will create all of the resources we’ve specified so far through CloudFormation.
    Once it’s completed you can log into the console and see your instance.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/dcbf9327c36039f7e88d9d24277da0ea.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
- en: Grab the instance id from column two you’ll need it later to connect to the
    instance through SSM.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Setting up SSM
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SSM allows us to use AWS IAM roles to manage access to instances. This is nice
    because we don’t have to open any ssh ports and can put the instance entirely
    on a private subnet, which is really nice from a security perspective. To enable
    SSM to work we need to modify our `.ssh/config` file with the following lines:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Don’t worry too much about this fancy command. It basically allows SSM to connect
    to the remote instance using Secure Shell(SSH) without opening an inbound port.
    Now to connect to the instance we can run:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you want to avoid the UI you can use the following command to get all EC2
    instance ids from AWS.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Setting up a remote notebook
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JupyterLab provides a pretty nice interface for working on these remote servers.
    I like to setup a lab session and then connect to it through SSM. On your remote
    instance create a screen to hold the jupyter session so it’s easy to find and
    manage later.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Make sure you’re in a folder where you have read and write permissions by default
    your EC2 instance will put you in `/usr/bin`If you run the following command this
    will put you in your user folder which should have read and write permissions
    for Jupyter.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now inside your screen create the JupyterLab instance. This command will create
    a JupyterLab session running on port 8123\. We’ll use this port later to connect
    through SSM.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now exit out of this connection (ctrl + d should work) and on your local machine
    run:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Make sure the port in this command matches the previous one. This will open
    a tunnel to your instance through SSM and forward all traffic on port 8123\. Now
    just go to localhost:8123 in your browser and Voila! You have a connection to
    your remote instance and can do all of the fun jupyterlab things there.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ded179477c714df40c6e060c7199c0f8.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
- en: What you should see on connecting to your instance.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Tearing things down
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you’re done with everything and want to destroy your instance simply run
    `cdk destroy.` This command will clean up everything you deployed in that stack.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成所有操作并且想要销毁你的实例，只需运行 `cdk destroy`。此命令将清理你在该堆栈中部署的所有内容。
- en: Next Steps and Caveats
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下一步和注意事项
- en: Hopefully this makes it easy for you to start and manage EC2 instances for yourself.
    I’ve found it to be a very nice way of interacting with EC2 instances. There are
    a few things you should keep in mind. This script creates a VPC. Often times AWS
    limits the number of custom VPCs you can have in a region to 5 so if you want
    to create multiple instances it’s pretty inefficient to generate a VPC for every
    instance (and by inefficient I mean don’t do it…). The goal here is personal development
    not a large shared team. Let me know in the comments if you want me to write another
    post on creating that shared VPC.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这能帮助你轻松地开始和管理 EC2 实例。我发现这是一种非常好的与 EC2 实例交互的方式。你需要记住一些事情。这个脚本创建了一个 VPC。通常，AWS
    限制了你在一个区域中可以拥有的自定义 VPC 的数量为 5，因此，如果你想创建多个实例，为每个实例生成一个 VPC 是相当低效的（我的意思是不要这么做……）。这里的目标是个人开发，而不是一个大型共享团队。如果你希望我写另一篇关于创建共享
    VPC 的文章，请在评论中告诉我。
- en: As next steps try and get the AMI automatically from AWS instead of hardcoding
    it. Try and use CfnParameters instead of environment variables for the instance
    type. Try and create a shared VPC instance. All of these would be good projects
    to improve the above code. Happy building!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步，尝试从 AWS 自动获取 AMI，而不是硬编码。尝试使用 CfnParameters 而不是环境变量来指定实例类型。尝试创建一个共享 VPC 实例。所有这些都是改善上述代码的好项目。祝构建愉快！
