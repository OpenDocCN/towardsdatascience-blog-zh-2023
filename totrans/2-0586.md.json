["```py\nimport cv2\nfrom PIL import Image\nfrom sklearn.cluster import KMeans\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport requests\nimport json\nfrom urllib.parse import urlparse\nfrom io import BytesIO\n\nclass ColorAnalyzer:\n    '''\n    This class analyzes the predominant colors in an image \n    using K-Means clustering based on the RGB color paradigm.\n\n    Attributes:\n        url_or_path (str): The URL or local file path of the image.\n        num_clusters (int): The number of clusters to identify as predominant colors.\n        scaling_factor (int): The percentage by which to scale the image for preprocessing.\n        image (numpy.ndarray): The loaded and preprocessed image.\n        pixels (numpy.ndarray): Reshaped image data for clustering.\n        image_rgb (numpy.ndarray): Resized image in RGB format.\n        centroids (numpy.ndarray): Centroids (predominant colors) obtained through clustering.\n        percentages (numpy.ndarray): Percentage of pixels belonging to each cluster.\n        labels (numpy.ndarray): Labels indicating cluster membership for each pixel.\n        sorted_colors (numpy.ndarray): Predominant colors sorted by cluster size.\n        sorted_percentages (numpy.ndarray): Percentages of pixels per cluster, sorted by cluster size.\n    '''\n    def __init__(self, url_or_path, num_clusters=4, scaling_factor=10):\n        '''\n        Initializes the ImageColorAnalyzer with the provided parameters.\n\n        Args:\n            url_or_path (str): The URL or local file path of the image.\n            num_clusters (int, optional): The number of clusters to identify as predominant colors (default is 5).\n            scaling_factor (int, optional): The percentage by which to scale the image for preprocessing (default is 10).\n        '''\n        self.url_or_path = url_or_path\n        self.num_clusters = num_clusters\n        self.scaling_factor = scaling_factor\n        self.image = self.load_image()\n        self.pixels, self.image_rgb = self.preprocess_image()\n        self.centroids, self.percentages, self.labels = self.find_clusters()\n        self.sorted_colors, self.sorted_percentages = self.sort_clusters_by_size()\n\n    def load_image(self):\n        '''\n        Load the image into a 2D array from the local path or URL.\n\n        Returns:\n            numpy.ndarray: The loaded image.\n\n        Raises:\n            Exception: If the URL does not exist or is broken, or if the image path is invalid.\n        '''\n        # If the input image path is a URL \n        if self.is_url():\n\n            # Get the response\n            response = requests.get(self.url_or_path)\n\n            # If there is a problem in getting the response..\n            if response.status_code != 200:\n\n                # ..raise an exception\n                raise Exception('URL does not exist or it is broken.')\n\n            # Try to extract the image from the URL\n            try:\n\n                # Get PIL image object file from the response \n                image = Image.open(BytesIO(response.content))\n\n                # Convert image from PIL to OpenCV format\n                image = cv2.cvtColor(np.array(image), cv2.COLOR_RGB2BGR)\n\n            # If an error occurs in processing the URL..\n            except:\n\n                # ..raise an exception\n                raise Exception('URL may not contain an image.')\n\n        # If the input image path is not a URL\n        else:\n\n            # Try to load the image\n            try:\n\n                # Load the image from a local path\n                image = cv2.imread(self.url_or_path)\n\n            # If there is a problem reading the local path..\n            except:\n\n                # ..raise an exception\n                raise Exception('Invalid image path.')\n\n        # return the loaded image\n        return image\n\n    def is_url(self):\n        '''\n        Check if the input path is URL.\n\n        Returns:\n            bool: True if the path is a URL, False otherwise.\n        '''\n        # Return True if the path is a URL, False otherwise\n        return 'http' in urlparse(self.url_or_path).scheme\n\n    def preprocess_image(self):\n        '''\n        Resize the image to improve processing speed.\n\n        Returns:\n            tuple: \n                Resized image data for clustering\n                Image for plotting.\n        '''\n        # Resize the image by the scaling factor for performances\n        width = int(self.image.shape[1] * self.scaling_factor / 100)\n        height = int(self.image.shape[0] * self.scaling_factor / 100)\n        resized_img = cv2.resize(\n            self.image, (width, height), interpolation=cv2.INTER_AREA)\n\n        # Convert the image back to RGB\n        image_rgb = cv2.cvtColor(resized_img, cv2.COLOR_BGR2RGB)\n\n        # Extract pixels as 2D array for clustering\n        pixels = image_rgb.reshape(-1, 3)\n\n        # Return array for clustering and image for plotting\n        return pixels, image_rgb\n\n    def find_clusters(self):\n        '''\n        Find predominant colors through clustering.\n\n        Returns:\n            tuple: \n                centroids (predominant colors)\n                percentages of pixels per cluster\n                labels of each point.           \n        '''\n        # Instantiate clustering model\n        kmeans = KMeans(n_clusters=self.num_clusters, n_init=10)\n\n        # Fit the model on the image and get labels\n        labels = kmeans.fit_predict(self.pixels)\n\n        # Get centroids (predominant colors)\n        centroids = kmeans.cluster_centers_.round(0).astype(int)\n\n        # Get percentage of pixels belonging to each cluster\n        percentages = np.bincount(labels) / len(self.pixels) * 100\n\n        # Return:\n        #   - centroids \n        #   - percentage of pixels per cluster        \n        #   - labels of each point\n        return centroids, percentages, labels\n\n    def sort_clusters_by_size(self):\n        '''\n        Sort predominant colors and percentages \n        of pixels per cluster by cluster size \n        in descending order.\n\n        Returns:\n            tuple: \n                Predominant colors sorted by cluster size\n                Percentages of pixels per cluster sorted by cluster size.\n        '''\n        sorted_indices = np.argsort(self.percentages)[::-1]\n        sorted_colors = self.centroids[sorted_indices]\n        sorted_percentages = self.percentages[sorted_indices]\n        return sorted_colors, sorted_percentages\n\n    def plot_image(self):\n        '''\n        Plot the preprocessed image (resized).\n        '''\n        plt.imshow(self.image_rgb)\n        plt.title('Preprocessed Image')\n        plt.axis('off')\n        plt.show()\n\n    def plot_3d_clusters(self, width=15, height=12):\n        '''\n        Plot a 3D visualization of the clustering.\n\n        Args:\n            width (int, optional): Width of the plot (default is 15).\n            height (int, optional): Height of the plot (default is 12).\n        '''\n        # Prepare figure\n        fig = plt.figure(figsize=(width, height))\n        ax = fig.add_subplot(111, projection='3d')\n\n        # Plot point labels with their cluster's color\n        for label, color in zip(np.unique(self.labels), self.centroids):\n            cluster_pixels = self.pixels[self.labels == label]\n            r, g, b = color\n            ax.scatter(cluster_pixels[:, 0], \n                       cluster_pixels[:, 1], \n                       cluster_pixels[:, 2], \n                       c=[[r/255, g/255, b/255]],  \n                       label=f'Cluster {label+1}')\n\n        # Display title, axis labels and legend\n        ax.set_title('3D Cluster Visualization')\n        ax.set_xlabel('r')\n        ax.set_ylabel('g')\n        ax.set_zlabel('b')\n        plt.legend()\n        plt.show()\n\n    def plot_predominant_colors(self, width=12, height=8):\n        '''\n        Plot a bar chart of predominant colors \n        ordered by presence in the picture.\n\n        Args:\n            width (int, optional): Width of the plot (default is 12).\n            height (int, optional): Height of the plot (default is 8).\n        '''\n        # Prepare color labels for the plot\n        color_labels = [f'Color {i+1}' for i in range(self.num_clusters)]\n\n        # Prepare figure\n        plt.figure(figsize=(width, height))\n\n        # Plot bars\n        bars = plt.bar(color_labels, \n                       self.sorted_percentages, \n                       color=self.sorted_colors / 255.0, \n                       edgecolor='black')\n\n        # Add percentage of each bar on the plot\n        for bar, percentage in zip(bars, \n                                   self.sorted_percentages):\n            plt.text(\n                bar.get_x() + bar.get_width() / 2,\n                bar.get_height(), \n                f'{percentage:.2f}%', \n                ha='center', \n                va='bottom')\n\n        # Display title and axis labels\n        plt.title(f'Top {self.num_clusters} Predominant Colors')\n        plt.xlabel('Colors')\n        plt.ylabel('Percentage of Pixels')\n        plt.xticks(rotation=45)\n        plt.show()\n\n    def get_predominant_colors(self):\n        '''\n        Return a list of predominant colors.\n        Each color is a JSON object with RGB code and percentage.\n        '''\n        # Prepare output list\n        colors_json = []\n\n        # For each predominant color\n        for color, percentage in zip(self.sorted_colors, \n                                     self.sorted_percentages):\n            # Get the RGB code\n            r, g, b = color\n\n            # Prepare JSON object\n            color_entry = {'color': {'R': f'{r}', \n                                     'G': f'{g}', \n                                     'B': f'{b}'}, \n                           'percentage': f'{percentage:.2f}%'}\n\n            # Append JSON object to color list\n            colors_json.append(color_entry)\n\n        # Return the results\n        return colors_json\n```", "```py\ncolors_extractor = ColorAnalyzer(\n  'https://fastly.picsum.photos/id/63/5000/2813.jpg?hmac=HvaeSK6WT-G9bYF_CyB2m1ARQirL8UMnygdU9W6PDvM',\n  num_clusters=4)\n```", "```py\ncolors_extractor.plot_image()\n```", "```py\ncolors_extractor.plot_predominant_colors()\n```", "```py\ncolors_extractor.plot_3d_clusters()\n```", "```py\nprint(json.dumps(\n    colors_extractor.get_predominant_colors(), \n    indent=3)\n)\n```", "```py\n[\n   {\n      \"color\": {\n         \"R\": \"140\",\n         \"G\": \"15\",\n         \"B\": \"19\"\n      },\n      \"percentage\": \"54.56%\"\n   },\n   {\n      \"color\": {\n         \"R\": \"231\",\n         \"G\": \"37\",\n         \"B\": \"47\"\n      },\n      \"percentage\": \"35.55%\"\n   },\n   {\n      \"color\": {\n         \"R\": \"163\",\n         \"G\": \"111\",\n         \"B\": \"63\"\n      },\n      \"percentage\": \"6.78%\"\n   },\n   {\n      \"color\": {\n         \"R\": \"211\",\n         \"G\": \"201\",\n         \"B\": \"186\"\n      },\n      \"percentage\": \"3.11%\"\n   }\n]\n```", "```py\n# Different image\ncolors_extractor = ColorAnalyzer(\n  'https://fastly.picsum.photos/id/165/2000/1333.jpg?hmac=KK4nT-Drh_vgMxg3hb7rOd6peHRIYmxMg0IEyxlTVFg',\n  num_clusters=4) \n\n# Plot resized original image\ncolors_extractor.plot_image()\n\n# 3D plot of the centroids and data points\ncolors_extractor.plot_3d_clusters()\n\n# Bar chart of predominant colors\ncolors_extractor.plot_predominant_colors()\n\n# Predominant colors as list of JSON\nprint(json.dumps(\n    colors_extractor.get_predominant_colors(), \n    indent=3)\n)\n```", "```py\ncolors-extractor/\n├── api/\n│   ├── __init__.py\n│   └── endpoints.py\n├── dto/\n│   ├── __init__.py\n│   └── image_data.py\n├── service/\n│   ├── __init__.py\n│   └── image_analyzer.py\n├── notebooks/\n│   └── extract_colors.ipynb\n├── main.py\n├── requirements.txt\n├── Dockerfile\n└── README.md\n```", "```py\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom api.endpoints import router as api_router\n\n# Create a FastAPI application instance\napp = FastAPI()\n\napp.add_middleware(\n    CORSMiddleware,            # Add Cross-Origin Resource Sharing (CORS) middleware to handle browser security restrictions\n    allow_origins = ['*'],     # Allow requests from all origins (insecure, for development only)\n    allow_credentials = True,  # Allow credentials like cookies in the requests\n    allow_methods = ['*'],     # Allow all HTTP methods (GET, POST, etc.)\n    allow_headers = ['*'],     # Allow all headers in requests\n)\n\n# Define a GET request handler for the root endpoint ('/')\n@app.get('/')\n# Define an asynchronous function for the root endpoint\nasync def root():\n    # Return a JSON response with a message\n    return {'message': 'API for color extraction from images.'}\n\n# Include the API router with a prefix of '/api'\napp.include_router(api_router, prefix='/api')\n```", "```py\nfrom fastapi import APIRouter, HTTPException\nfrom service.image_analyzer import ColorAnalyzer\nfrom dto.image_data import ColorExtractionRequest, ColorExtractionResponse\nimport logging \n\n# Define the router for the FastAPI app\nrouter = APIRouter()\n\n# Logging configuration\nlogging.basicConfig(\n    format = '%(levelname)s:     %(asctime)s, %(module)s, %(processName)s, %(message)s', \n    level = logging.INFO)\n\n# Instantiate logger\nlogger = logging.getLogger(__name__)\n\n# Define a POST request handler for the '/colors' endpoint\n@router.post(\n        '/colors',                                 # Endpoint name\n        response_model = ColorExtractionResponse,  # Data model for the response \n        tags = ['Colors Extraction']               # Tag used for documentation\n        )\n# Define an asynchronous function accepting a 'ColorExtractionRequest' as request body\nasync def colors(input_data: ColorExtractionRequest):\n    '''\n    Analyze an image and return predominant colors.\n\n    Parameters:\n      - input_data[ColorExtractionRequest]: Request data including 'url_or_path' (str) and 'num_clusters' (int, optional).\n\n    Returns:\n      - ImageAnalysisResponse: Response data containing a list of predominant colors.\n\n    Example Usage:\n      - Send a POST request with JSON data containing the 'url_or_path' parameter to extract colors from an image.\n    '''\n\n    # Log request information\n    logger.info(f'Analysis for image key: {input_data.url_or_path}.')\n    logger.info(f'Requested colors: {input_data.num_clusters}.')\n\n    # Perform the color extraction\n    try:\n\n        # Instantiate the ColorAnalyzer class for image processing\n        color_json = ColorAnalyzer(\n                input_data.url_or_path, \n                input_data.num_clusters\n            ).get_predominant_colors()\n\n        logger.info(f'Analysis completed.')\n\n        # Return the predominant colors\n        return {'predominant_colors': color_json}\n\n    # If an error occurs\n    except Exception as e:\n\n        # Log the error message \n        logger.error(f'Exception in image processing: {str(e)}.')\n\n        # Raise an exception\n        raise HTTPException(status_code = 500, detail = str(e))\n```", "```py\nfrom pydantic import BaseModel\nfrom typing import List\n\nclass Color(BaseModel):\n    '''\n    Color representation as RGB values.\n    '''\n    R: int\n    G: int\n    B: int\n\nclass ColorInfo(BaseModel):\n    '''\n    Information about a color: RGB and percentage of pixels across image.\n    '''\n    color: Color\n    percentage: str\n\nclass ColorExtractionRequest(BaseModel):\n    '''\n    Colors extraction request.\n    '''\n    url_or_path: str\n    num_clusters: int = 4 # Default to 4 most predominant colors if not provided\n\nclass ColorExtractionResponse(BaseModel):\n    '''\n    Color extraction response from an image analysis request.\n    '''\n    predominant_colors: List[ColorInfo]\n```", "```py\n# Use the official Python image as the base image\nFROM python:3.8-slim\n\n# Set the working directory\nWORKDIR /colors-extractor\n\n# Copy the requirements.txt file and install dependencies\nCOPY requirements.txt requirements.txt\nRUN pip install -r requirements.txt\n\n# Copy the project files into the container\nCOPY . .\n\n# Expose the port that the FastAPI app will listen on\nEXPOSE 8000\n\n# Command to run the FastAPI app using Uvicorn (handled by Dockerfile)\nCMD [\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n```", "```py\n# Move into the project directory\ncd colors-extractor\n\n# Create Docker image\ndocker build -t colors-extractor .\n\n# Execute Docker container\ndocker run -d -p 8000:8000 colors-extractor\n```", "```py\ndocker ps\n```", "```py\ndocker logs <container_id>\n```", "```py\ncurl --location 'http://localhost:8000/api/colors' \\\n--header 'Content-Type: application/json' \\\n--data '{\n    \"url_or_path\": \"https://fastly.picsum.photos/id/63/5000/2813.jpg?hmac=HvaeSK6WT-G9bYF_CyB2m1ARQirL8UMnygdU9W6PDvM\",\n    \"num_clusters\": 3\n}'\n```", "```py\n{\n  \"predominant_colors\": [\n    {\n      \"color\": {\n        \"R\": 140,\n        \"G\": 16,\n        \"B\": 19\n      },\n      \"percentage\": \"54.97%\"\n    },\n    {\n      \"color\": {\n        \"R\": 231,\n        \"G\": 37,\n        \"B\": 47\n      },\n      \"percentage\": \"35.55%\"\n    },\n{\n      \"color\": {\n        \"R\": 180,\n        \"G\": 142,\n        \"B\": 104\n      },\n      \"percentage\": \"9.47%\"\n    }\n  ]\n}\n```"]