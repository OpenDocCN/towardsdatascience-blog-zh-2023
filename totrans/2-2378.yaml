- en: 'Why SOLID Design Matters: Avoid Code Smells and Write Maintainable Code'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/why-solid-design-matters-avoid-code-smells-and-write-maintainable-code-553b3c6c0ca8](https://towardsdatascience.com/why-solid-design-matters-avoid-code-smells-and-write-maintainable-code-553b3c6c0ca8)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use the SOLID principles to design readable, scalable, and maintainable software
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.knulst.de/?source=post_page-----553b3c6c0ca8--------------------------------)[![Paul
    Knulst](../Images/9fcb767d927a1fe53ee739c584fdf92c.png)](https://medium.knulst.de/?source=post_page-----553b3c6c0ca8--------------------------------)[](https://towardsdatascience.com/?source=post_page-----553b3c6c0ca8--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----553b3c6c0ca8--------------------------------)
    [Paul Knulst](https://medium.knulst.de/?source=post_page-----553b3c6c0ca8--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----553b3c6c0ca8--------------------------------)
    ·11 min read·Jan 6, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b4c330587de200d1eb6c4001a63fe8ba.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Markus Spiske](https://unsplash.com/@markusspiske?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
    / [Unsplash](https://unsplash.com/s/photos/code-javascript?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SOLID is an acronym for five principles of object-oriented design, that were
    first outlined by Robert C. Martin in the early 2000s. These principles can help
    developers to create more maintainable and scalable software systems. The five
    principles are:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/90521a414adf6b65d9386cf3bcc7250f.png)'
  prefs: []
  type: TYPE_IMG
- en: All five SOLID principles — visualized by author
  prefs: []
  type: TYPE_NORMAL
- en: In this article, I want to showcase the power of the SOLID principles for building
    readable and maintainable software applications. Furthermore, I will provide practical
    examples of how to apply the SOLID principles with TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: These examples will demonstrate how the SOLID principles can be used to design
    and build better, more scalable applications.
  prefs: []
  type: TYPE_NORMAL
- en: Whether you are a developer, a data scientist, or a user of decentralized applications,
    these examples will provide a valuable starting point for applying the SOLID principles
    to your code.
  prefs: []
  type: TYPE_NORMAL
- en: Single Responsibility Principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each module should have one and only one reason to change.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '- Robert C. Martin'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Single Responsibility Principle is a principle of object-oriented design
    that states that a class or module should have only one responsibility or reason
    to change. This means a class should have a narrowly-defined scope and should
    not take on too many responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: In TypeScript, the Single Responsibility Principle can be applied by dividing
    a large and complex class into smaller and more focused ones, each with its well-defined
    responsibility. For example, consider a class responsible for managing user account
    information, including their profile details, preferences, and payment information.
    This class may have many methods for handling different aspects of the user account,
    such as updating their profile, managing their preferences, and processing payments.
  prefs: []
  type: TYPE_NORMAL
- en: To apply the Single Responsibility Principle, we can break this large class
    into several smaller ones, each with a specific responsibility. For example, we
    might have a `UserProfile` class responsible for managing the user profile information,
    a `UserPreferences` class responsible for managing their preferences, and a `UserPayments`
    class responsible for processing their payments. Each of these classes would have
    a narrowly-defined scope, and they would be easier to maintain and extend than
    the original, monolithic class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how these classes might be implemented in TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Within this example, every class has a narrowly-defined responsibility and a
    well-defined interface. The `UserProfile` class is responsible for managing the
    user profile information, the `UserPreferences` class is responsible for managing
    their preferences, and the `UserPayments` class is responsible for processing
    their payments.
  prefs: []
  type: TYPE_NORMAL
- en: This makes it easier to understand the purpose and behavior of each class, and
    it also makes it easier to extend and maintain the code.
  prefs: []
  type: TYPE_NORMAL
- en: Open/Closed Principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modules should be open for extension but closed for modification.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '- Robert C. Martin'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Open/Closed Principle is a principle of object-oriented design that says
    that a class should be open for extension but closed for modification. This means
    that the class should be designed in such a way that new behavior can be added
    with inheritance or composition, without changing the existing code.
  prefs: []
  type: TYPE_NORMAL
- en: In TypeScript, the Open/Closed Principle can be applied using abstract classes,
    interfaces, and polymorphism to create a flexible and extensible design. For example,
    consider a simple `Shape` class representing different geometric shapes, such
    as circles, squares, and triangles. This class might have a `draw()` method that
    can be used to render any shape on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: To apply the Open/Closed Principle, we can define an abstract `Shape` class
    that contains shared behavior of all shapes, such as a `draw()` method. We can
    then define subclasses for each specific type of shape, such as `Circle`, `Square`,
    and `Triangle`, which inherit from the `Shape` class and override the `draw()`
    method to provide their specific behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how this might be implemented in TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `Shape` class is open for extension because new subclasses
    can be defined to add new behavior. We could define a `Rectangle` class that extends
    the `Shape` class and overrides the `draw()` method to provide its specific behavior.
    However, the `Shape` class is closed to modifications, because we cannot change
    the existing code in the `Shape` class without breaking the subclasses that extend
    it.
  prefs: []
  type: TYPE_NORMAL
- en: This makes the code more flexible and maintainable because we can add new behavior
    without changing the existing code.
  prefs: []
  type: TYPE_NORMAL
- en: Liskov Substitution Principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use interfaces/protocols to separate interchangeable parts.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '- Robert C. Martin'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Liskov Substitution Principle is a principle of object-oriented design that
    states that objects in a program should be replaceable with instances of their
    subtypes without altering the correctness of the program. This means that subclasses
    should be able to extend or override the behavior of their parent classes without
    breaking the parent class’s contract.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, the Liskov Substitution Principle is a way to ensure that subtypes
    are substitutable for their base types, meaning that any program written to use
    a base type should be able to run without modification if a subtype is used instead.
  prefs: []
  type: TYPE_NORMAL
- en: In TypeScript, the Liskov Substitution Principle can be applied by defining
    a class and ensuring that subclasses extend it. For example, consider a simple
    `Vehicle` class that represents different types of vehicles, such as cars, motorcycles,
    or boats. This `Vehicle` class might include the `startEngine()` method, as well
    as other methods or properties that are common to all vehicles. We can then define
    subclasses for each specific type of vehicle, such as `Car` or `Motocycle`, which
    extends the `Vehicle` class and provide their behavior for the `startEngine()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how this might be implemented in TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `Car` and `Motorcycle` classes are subtypes of the `Vehicle`
    class. The `useVehicle()` function expects an object of type `Vehicle`, but because
    of the Liskov Substitution Principle, we can pass an object of type `Car` or `Motorcycle`
    to this function, and it will work correctly.
  prefs: []
  type: TYPE_NORMAL
- en: This is because `Car` and `Motorcycle` are substitutable for `Vehicle` – that
    is, objects of type `Car` and `Motorcycle` can be used wherever objects of type
    `Vehicle` are expected, without altering the desired properties of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Interface Segregation Principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clients should not be forced to depend upon interfaces that they do not use.”
    — Robert C. Martin
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Interface Segregation Principle is a principle of object-oriented design
    that states that clients of an object should not be forced to depend on methods
    they do not use. This means that the interfaces of a class should be designed
    in such a way that each interface serves a specific purpose and is used by a specific
    client. This principle helps to reduce the amount of unused code in a program,
    making it more efficient and easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: The motivation for this principle is to avoid the problem of monolithic interfaces,
    which define many methods that may not be relevant for all clients. This can lead
    to client code that is bloated and hard to maintain because it is forced to implement
    or mock unused methods to satisfy the interface contract.
  prefs: []
  type: TYPE_NORMAL
- en: To apply the Interface Segregation Principle, it is best to define multiple
    small and focused interfaces, rather than a single, monolithic interface. This
    allows each client to implement only necessary methods, without being forced to
    implement unused methods. This can lead to a more modular and maintainable design
    because the interfaces are more closely aligned with the needs of their clients.
  prefs: []
  type: TYPE_NORMAL
- en: In TypeScript, the Interface Segregation Principle can be applied by creating
    small, specific interfaces for each type of object in a program.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider a program that has two types of objects: `Cat` and `Fish`.
    A fish object might have a `eat()` method, while a cat object might have `eat()`
    and `move()` methods. To follow the Interface Segregation Principle, we could
    create two separate interfaces for `Cat` and `Fish`, each with its unique methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `Eating` and `Moving` interfaces are defined. The `Eating`
    interface has a single method, `eat()`, while the `Moving` interface has a single
    method, `move()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Cat` class is defined as a subtype of `Eating` and `Moving` – that is,
    it implements both interfaces. This means that the `Cat` class is required to
    implement the `eat()` and `move()` methods with a specific implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The `Fish` class is defined as a subtype of the `Eating` interface. This means
    that the `Fish` class is only required to implement the `eat()` method. The `Fish`
    class provides an implementation for this method, but it does not need to implement
    the `move()` method because fish do not move the same way as other animals.
  prefs: []
  type: TYPE_NORMAL
- en: The Interface Segregation Principle helps to improve the design of a program
    by breaking down large, general interfaces into smaller, more specific ones.
  prefs: []
  type: TYPE_NORMAL
- en: This can make a program more efficient and easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Inversion Principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Entities must depend on abstractions, not on concretions. It states that the
    high-level module must not depend on the low-level module, but they should depend
    on abstractions.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '- Robert C. Martin'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Dependency Inversion Principle is a software design principle that states
    that high-level modules should not depend on low-level modules, but rather both
    should depend on abstractions. This principle helps to improve the flexibility
    and maintainability of a program, by allowing different parts of the program to
    evolve independently.
  prefs: []
  type: TYPE_NORMAL
- en: 'In TypeScript, the Dependency Inversion Principle can be applied by defining
    abstractions (interfaces or abstract classes) that define the contract for different
    parts of the program. For example, consider a program that has a `Database` class
    and a `UserService` class. The `UserService` class might depend on the `Database`
    class to store and retrieve user data. To follow the Dependency Inversion Principle,
    we could define an abstract `DataStore` interface that the `Database` class implements,
    and have the `UserService` class depends on the `DataStore` interface instead
    of the `Database` class directly. This way, the `UserService` class is not tied
    to a specific implementation of a data store, and can be used with any class that
    implements the `DataStore` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `UserService` class depends on the `DataStore` interface,
    and can work with any class that implements that interface. This allows us to
    change the implementation of the `Database` class without affecting the `UserService`
    class, or to use a different class altogether as long as it implements the `DataStore`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: If applying the Dependency Inversion Principle the design of a program will
    be improved by decoupling high-level modules from low-level ones and making both
    depend on abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: This can make a program more flexible and easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Beware! Avoid Common Misconceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unfortunately, there are several misconceptions about the SOLID principles and
    they are easily used wrong.
  prefs: []
  type: TYPE_NORMAL
- en: One common misconception is that they should be followed blindly without considering
    the specific needs and constraints of the project at hand. But, in reality, these
    principles are guidelines that can help developers to create more maintainable
    and scalable software. SOLID principles should always be applied with care and
    judgment.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the Single Responsibility Principle can sometimes be violated to
    improve the performance or simplicity of a class.
  prefs: []
  type: TYPE_NORMAL
- en: Another common misconception is that the SOLID principles apply only to object-oriented
    languages, such as Kotlin, TypeScript, Java, or C++. This is wrong because these
    principles are language-agnostic and can be applied to any software system, regardless
    of the programming paradigm or language used.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the SOLID principles are no silver bullet that can solve every
    problem in software design. These principles are just one tool among many that
    can help developers to create better software.
  prefs: []
  type: TYPE_NORMAL
- en: '**They should be used with other design principles and practices, such as refactoring,
    testing, and continuous integration.**'
  prefs: []
  type: TYPE_NORMAL
- en: Closing Notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In conclusion, the SOLID principles are a set of guidelines that can help developers
    create more maintainable, extendable, and understandable software by focusing
    on creating classes and modules that are single-purpose, well-encapsulated, and
    easy to modify.
  prefs: []
  type: TYPE_NORMAL
- en: By adhering to the SOLID principles, developers can save time and effort in
    the long run by writing code that is easier to maintain and adapt over time.
  prefs: []
  type: TYPE_NORMAL
- en: It is paramount to understand that these principles should not be strictly followed
    in all situations. They should be treated more like guidelines that can be applied
    in different ways depending on the specific use case in the project.
  prefs: []
  type: TYPE_NORMAL
- en: As a developer, it’s important to approach the SOLID principles with a flexible
    and open mind. By doing this, you can make the most out of these guidelines and
    use them to create better software.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, SOLID principles are no new or revolutionary idea in software design.
    These principles are based on decades of experience and research in the field
    of object-oriented design, and they build on the work of many other software developers
    and researchers who came before.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to dive deeper into the topic of how to develop readable, scalable,
    and maintainable code, check out this video (and the following 5). It’s the first
    lesson of “Coding Better World Together” by Robert C. Martin who promoted the
    SOLID principles.
  prefs: []
  type: TYPE_NORMAL
- en: The first lesson of “Coding Better World Together” by Robert C. Martin
  prefs: []
  type: TYPE_NORMAL
- en: Finally, what do you think about the SOLID principles? Also, do you have any
    questions regarding any of the five principles? I would love to hear your thoughts
    and answer your questions. Please share everything in the comments.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to connect with me on [my blog](https://www.paulsblog.dev), [LinkedIn](https://www.linkedin.com/in/paulknulst/),
    [Twitter](https://twitter.com/paulknulst), and [GitHub](https://github.com/paulknulst).
  prefs: []
  type: TYPE_NORMAL
