- en: Git 101 — From Terminologies to Architecture and Workflows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/git-101-from-terminologies-to-architecture-and-workflows-78cb6d735798](https://towardsdatascience.com/git-101-from-terminologies-to-architecture-and-workflows-78cb6d735798)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Git behind-the-scenes and how to use Git efficiently
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://kayjanwong.medium.com/?source=post_page-----78cb6d735798--------------------------------)[![Kay
    Jan Wong](../Images/28e803eca6327d97b6aa97ee4095d7bd.png)](https://kayjanwong.medium.com/?source=post_page-----78cb6d735798--------------------------------)[](https://towardsdatascience.com/?source=post_page-----78cb6d735798--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----78cb6d735798--------------------------------)
    [Kay Jan Wong](https://kayjanwong.medium.com/?source=post_page-----78cb6d735798--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----78cb6d735798--------------------------------)
    ·7 min read·May 21, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/abc3db02185eba249984afdc9e69a784.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Roman Synkevych](https://unsplash.com/@synkevych?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: So you have learned and know about `git add`, `git commit`, and `git push`,
    but what does each step achieve — and what is happening in your *local* and *remote*
    repository? What are different merging strategies and branching strategies you
    can use to harness the power of Git to do much more?
  prefs: []
  type: TYPE_NORMAL
- en: After pouring through numerous articles simply showing Git commands, I feel
    that it is important to know the architecture of Git to truly appreciate and understand
    what is happening. This article will touch on the basic terminologies of Git,
    building up to Git architecture, and finally, different common Git workflows that
    you can consider adopting for your next coding project!
  prefs: []
  type: TYPE_NORMAL
- en: Table of Contents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[What is Git](https://medium.com/p/78cb6d735798/#34c1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Git Terminologies](https://medium.com/p/78cb6d735798/#d4b5)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Git Architecture](https://medium.com/p/78cb6d735798/#3d8c)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Branching, Merging, and Merge Conflicts](https://medium.com/p/78cb6d735798/#c5e6)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Git Workflows](https://medium.com/p/78cb6d735798/#414a)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In short, Git is a tool that helps with version control which enables teams
    to manage their code in an agile manner — from tracking the history of code changes
    to handling conflicts in code changes and much more.
  prefs: []
  type: TYPE_NORMAL
- en: Taking it one step further, Git can also be used with Continuous Integration
    Continuous Deployment (CICD) tools since the codebase is well-maintained and versioned
    (if used properly). Deployment can be automatically triggered upon code change
    using tools such as GitHub Actions — but this is not in the scope of this article.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**: GitHub, GitLab, and Bitbucket are hosting services for Git repositories,
    not to be confused with Git itself!'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Git Terminologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before diving into Git architecture, a few terminologies are frequently mentioned
    and it would be good to have them defined.
  prefs: []
  type: TYPE_NORMAL
- en: '**Repository**: A data structure that stores documents and codes, made up of
    a series of commits over time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Branch**: An independent line of project development'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Commit**: One version of the project; a snapshot of the project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pull Request**: Request to merge a branch into another branch'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Merge**: Combined work of separate branches'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To put it together, while working on a project, you will usually *branch* out
    to make changes and *commit* your changes after it is completed. After which,
    you will raise a *pull request* for your branch to be *merged* with the main *repository*.
  prefs: []
  type: TYPE_NORMAL
- en: The existence of independent branches and pull requests to approve code changes
    allow teams to scale their work while maintaining a stable repository
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There are also terminologies on Git actions that you can perform. Note that
    there is a concept of *local* and *remote*, which will be explained in the later
    section.
  prefs: []
  type: TYPE_NORMAL
- en: '**Clone**: Local copy of a remote repository'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fork**: Copy remote repository to own account, both repositories are remote'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fetch**: Retrieves new objects and references from the remote repository'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pull**: Fetches and merges commit locally'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Push**: Adds new objects and references to the remote repository'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stash**: Save files in the working tree for later access'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in the previous section, there is a concept of *local* and *remote*.
    **Remote repositories** refer to the location of all commits of the project, usually
    hosted in a data center or cloud (i.e., GitHub). **Local repositories**, on the
    other hand, refer to the location of commits of the project on your local machine
    (i.e., laptop) and are made up of 3 separate ‘areas’,
  prefs: []
  type: TYPE_NORMAL
- en: '**Working tree**: Location of directories and files of a single commit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Staging area**: Location of files planned for next commit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Local repository**: Location of all commits of the project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To put it into action, when you perform `git checkout`, it places directories
    and files into the *working tree*. After making changes, performing `git add`
    transfers the modified files to the *staging area*. After which you can perform
    `git commit` to add a message to the changes made and changes are committed to
    the *local repository*. Finally, performing `git push` pushes the changes in the
    *local repository* to the *remote repository*.
  prefs: []
  type: TYPE_NORMAL
- en: Branching, Merging, and Merge Conflicts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Branching Strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A branch is a set of commits that trace back to the project’s first commit and
    is typically used to isolate work amongst team members as they can work on separate
    independent branches.
  prefs: []
  type: TYPE_NORMAL
- en: There are two types of branches. **Short-lived branches** contain small changes
    to the project, such as implementing a feature, bug fix, hotfix, etc. Whereas
    **long-lived branches** can last for the life of the project, such as the master,
    develop, or release branch.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, branches should be deleted after merging to prevent a continuous increase
    in the number of branches. In case of accidental deletion, branches can be restored
    — only if the branch exists in someone’s local repository.
  prefs: []
  type: TYPE_NORMAL
- en: Merging Strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Merging combines the work of multiple independent branches. It is good practice
    to use small and frequent merges to avoid merge conflict. There are 4 types of
    merge — and the merging policy to follow usually depends on the team commit history
    policies.
  prefs: []
  type: TYPE_NORMAL
- en: '**Fast-forward (FF) Merge**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f4c615f9fad1fafe72eefe5c46ea4fc8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig 1: Fast-Forward Merge Example — Image by author'
  prefs: []
  type: TYPE_NORMAL
- en: Moves the base branch label to the tip of the merged branch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only possible if no other commits have been made to the base branch — otherwise
    perform a `git pull` before performing any `git push`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is considered the strictest merge policy as it ensures code modifications
    are always compatible as the latest changes are always fetched first
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Merge Commit**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ece98a1ca9c690db6a06f040300a3728.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig 2: Merge Commit Example — Image by author'
  prefs: []
  type: TYPE_NORMAL
- en: Combines commits at the tips of merged branches, resulting in non-linear commit
    graphs as merge commit has multiple parents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This may result in merge conflict when multiple commits are combined and both
    branches change the same thing in different ways
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the automatic behaviour of Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Squash Merge**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/67bdef675af8ea9e50d53d5c66a9370a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig 3: Squash Merge Example — Image by author'
  prefs: []
  type: TYPE_NORMAL
- en: Merges the tip of the merged branch onto the tip of the base branch (can be
    using fast-forward merge or merge commit), and reduces multiple commits into a
    single commit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This may result in deleted commits as commits B and C will eventually be garbage
    collected when the branch is deleted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**To be done with caution!** This rewrites commit history and we should not
    rewrite history that has been shared'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rebase**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2c62a0a1eb6a626217c1b7208434aac9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig 4: Rebase Example — Image by author'
  prefs: []
  type: TYPE_NORMAL
- en: Moves commits in merged branch to a new parent and commits will have different
    IDs due to different ancestor chain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ‘new’ commits in the merged branch can be fast-forwarded and do not require
    a merge commit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When performing rebasing, this may result in merge conflict when both branches
    change the same thing in different ways
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**To be done with caution!** This rewrites commit history and we should not
    rewrite history that has been shared'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merge Conflicts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the earlier section, we noticed that merge commit and rebasing may result
    in a merge conflict, a situation when two branches change the same thing in different
    ways.
  prefs: []
  type: TYPE_NORMAL
- en: Resolving a merge conflict involves 3 commits — the tip of the base branch,
    the tip of the merge branch, and a common ancestor between the base and merge
    branch. The conflicting parts are surrounded by conflict markers as such,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When attempting a merge, the files with conflicts are modified by Git and placed
    in the working tree. The merge conflict must be resolved manually before staging,
    committing, and merging again.
  prefs: []
  type: TYPE_NORMAL
- en: Git Workflows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides deciding on the type of merging strategy to implement for your projects,
    there are also 4 types of Git workflow based on the team preference, size of the
    team, size of the project, etc.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Workflow / Centralized Workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Type**: Single central repository (no branches)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How**: Each member clones the repository, works on code locally, commits,
    and pushes their changes to the central repository'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suitable for small projects and small teams since there is no code review or
    pull request involved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feature Branch Workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Type**: Single central repository (with feature branches)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How**: Each member creates a branch for every new functionality, and merges
    the completed changes with the main branch'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recommended workflow as there are code review, pull request, and discussion
    involved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forking Workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Type**: Multiple remote repositories (by forking)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How**: Team members fork the repository, making a duplicate copy of the repository.
    Members do not need write access to the original repository and are free to modify
    the forked repository in any manner to add features or tailor the repository to
    another use case or project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This workflow allows the maintainer of the repository to accept commits from
    any developer without giving them access to the official codebase, useful for
    open-source projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gitflow Workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Type**: Single central repository (with short-lived and long-running branches)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How**: There is a use of short-lived branches for features or hotfixes, and
    long-running branches for development and releases. Feature branches are created
    from the develop branch, and merged back to develop branch when it is completed.
    For release, features in develop branch are merged back to the main branch and
    only the main branch is used for releases'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This workflow allows for the safe and continuous release of the project through
    releases and hotfixes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git is imperative as long as you are working on any codebase. Even with or without
    a project team, version control is still important to manage your code! Hope this
    article shed light on how Git works under the hood with Git architecture, the
    different branching and merging strategies, and finally the different workflows
    you can use for your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Related Links
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Git Documentation: [https://git-scm.com/doc](https://git-scm.com/doc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Version Control with Git (Coursera): [https://www.coursera.org/learn/version-control-with-git](https://www.coursera.org/learn/version-control-with-git)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
