["```py\nimport math\nfrom random import randint, uniform, random\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nplt.style.use('dark_background')\n%matplotlib qt\n\n# Set the radius of the galactic disc (scaling factor):\nSCALE = 350  # Use range of 200 - 700.\n```", "```py\ndef build_spiral_stars(b, r, rot_fac, fuz_fac):\n    \"\"\"Return list of (x,y,z) points for a logarithmic spiral.\n\n    b = constant for spiral direction and \"openness\"\n    r = scale factor (galactic disc radius)\n    rot_fac = factor to rotate each spiral arm\n    fuz_fac = randomly shift star position; applied to 'fuzz' variable\n    \"\"\"\n    fuzz = int(0.030 * abs(r))  # Scalable initial amount to shift locations.\n    num_stars = 1000\n    spiral_stars = []\n    for i in range(0, num_stars):\n        theta = math.radians(i)\n        x = r * math.exp(b*theta) * math.cos(theta - math.pi * rot_fac)\\\n            - randint(-fuzz, fuzz) * fuz_fac\n        y = r * math.exp(b*theta) * math.sin(theta - math.pi * rot_fac)\\\n            - randint(-fuzz, fuzz) * fuz_fac\n        z = uniform((-SCALE / (SCALE * 3)), (SCALE / (SCALE * 3)))\n        spiral_stars.append((x, y, z))\n    return spiral_stars\n```", "```py\n# Assign scale factor, rotation factor, and fuzz factor for spiral arms.\n# Each arm is a pair: leading arm + trailing arm:\narms_info = [(SCALE, 1, 1.5), (SCALE, 0.91, 1.5), \n             (-SCALE, 1, 1.5), (-SCALE, -1.09, 1.5),\n             (-SCALE, 0.5, 1.5), (-SCALE, 0.4, 1.5), \n             (-SCALE, -0.5, 1.5), (-SCALE, -0.6, 1.5)]\n```", "```py\ndef build_spiral_arms(b, arms_info):\n    \"\"\"Return lists of point coordinates for galactic spiral arms.\n\n    b = constant for spiral direction and \"openness\"\n    arms_info = list of scale, rotation, and fuzz factors\n    \"\"\"\n    leading_arms = []\n    trailing_arms = []\n    for i, arm_info in enumerate(arms_info):\n        arm = build_spiral_stars(b=b, \n                                 r=arm_info[0], \n                                 rot_fac=arm_info[1], \n                                 fuz_fac=arm_info[2])\n        if i % 2 != 0:\n            leading_arms.extend(arm)\n        else:\n            trailing_arms.extend(arm)            \n    return leading_arms, trailing_arms\n```", "```py\ndef spherical_coords(num_pts, radius):\n    \"\"\"Return list of uniformly distributed points in a sphere.\"\"\"\n    position_list = []\n    for _ in range(num_pts):\n        coords = np.random.normal(0, 1, 3)\n        coords *= radius\n        coords[2] *= 0.02  # Reduce z range for matplotlib default z-scale.\n        position_list.append(list(coords))\n    return position_list\n```", "```py\ndef build_core_stars(scale_factor):\n    \"\"\"Return lists of point coordinates for galactic core stars.\"\"\"\n    core_radius = scale_factor / 15\n    num_rim_stars = 3000\n    outer_stars = spherical_coords(num_rim_stars, core_radius)\n    inner_stars = spherical_coords(int(num_rim_stars/4), core_radius/2.5)\n    return (outer_stars + inner_stars)\n```", "```py\ndef haze(scale_factor, r_mult, z_mult, density):\n    \"\"\"Generate uniform random (x,y,z) points within a disc for 2-D display.\n\n    scale_factor = galactic disc radius\n    r_mult = scalar for radius of disc\n    z_mult = scalar for z values\n    density = multiplier to vary the number of stars posted\n    \"\"\"\n    haze_coords = []\n    for _ in range(0, scale_factor * density):\n        n = random()\n        theta = uniform(0, 2 * math.pi)\n        x = round(math.sqrt(n) * math.cos(theta) * scale_factor) / r_mult\n        y = round(math.sqrt(n) * math.sin(theta) * scale_factor) / r_mult\n        z = np.random.uniform(-1, 1) * z_mult\n        haze_coords.append((x, y, z))\n    return haze_coords\n```", "```py\n# Create lists of star positions for galaxy:\nleading_arm, trailing_arm = build_spiral_arms(b=-0.3, arms_info=arms_info)\ncore_stars = build_core_stars(SCALE)\ninner_haze_stars = haze(SCALE, r_mult=2, z_mult=0.5, density=5)\nouter_haze_stars = haze(SCALE, r_mult=1, z_mult=0.3, density=5) \n\n# Plot stars in 3D using matplotlib:\nfig, ax = plt.subplots(1, 1, \n                       subplot_kw={'projection': '3d'}, \n                       figsize=(12, 12))\nax.set_axis_off()\nax.set_zlim (-15, 15)\n\nax.scatter(*zip(*leading_arm), c='w', marker='.', s=5)\nax.scatter(*zip(*trailing_arm), c='w', marker='.', s=2)\nax.scatter(*zip(*core_stars), c='w', marker='.', s=1)\nax.scatter(*zip(*inner_haze_stars), c='w', marker='.', s=1)\nax.scatter(*zip(*outer_haze_stars), c='lightgrey', marker='.', s=1)\n```", "```py\nimport matplotlib.path as mpath\nstar = mpath.Path.unit_regular_star(6)\n```", "```py\ndef spherical_coords(num_pts, radius):\n    \"\"\"Return list of uniformly distributed points in a sphere.\"\"\"\n    position_list = []\n    for _ in range(num_pts):\n        coords = np.random.normal(0, 1, 3) \n        coords *= radius \n        position_list.append(list(coords))\n    return position_list\n\nrim_radius = 2\nnum_rim_stars = 3000\nrim_stars = spherical_coords(num_rim_stars, rim_radius)\ncore_stars = spherical_coords(int(num_rim_stars/4), rim_radius/2.5)\n\nfig, ax = plt.subplots(1, 1, subplot_kw={'projection':'3d'})\nax.axis('off')\nax.scatter(*zip(*core_stars), s=0.5, c='white')\nax.scatter(*zip(*rim_stars), s=0.1, c='white')\nax.set_xlim(-(rim_radius * 4), (rim_radius * 4))\nax.set_ylim(-(rim_radius * 4), (rim_radius * 4))\nax.set_zlim(-(rim_radius * 3), (rim_radius * 3))\nax.set_aspect('auto')\n```"]