["```py\nfrom sklearn.datasets import make_classification\nfrom imblearn.over_sampling import SMOTE\n\nX_train, y_train = make_classification(n_samples=500, n_features=5, n_informative=3)\nX_res, y_res = SMOTE().fit_resample(X_train, y_train)\n```", "```py\nfrom collections import Counter\nfrom typing import List\n\nimport numpy as np\nimport pandas as pd\nfrom scipy.cluster.hierarchy import linkage, fcluster\nfrom scipy.spatial.distance import pdist\n\nclass ICLL:\n    \"\"\"\n    Imbalanced Classification via Layered Learning\n    \"\"\"\n\n    def __init__(self, model_l1, model_l2):\n        \"\"\"\n        :param model_l1: Predictive model for the first layer\n        :param model_l2: Predictive model for the second layer\n        \"\"\"\n        self.model_l1 = model_l1\n        self.model_l2 = model_l2\n        self.clusters = []\n        self.mixed_arr = np.array([])\n\n    def fit(self, X: pd.DataFrame, y: np.ndarray):\n        \"\"\"\n        :param X: Explanatory variables\n        :param y: binary target variable\n        \"\"\"\n        assert isinstance(X, pd.DataFrame)\n        X = X.reset_index(drop=True)\n\n        if isinstance(y, pd.Series):\n            y = y.values\n\n        self.clusters = self.clustering(X=X)\n\n        self.mixed_arr = self.cluster_to_layers(clusters=self.clusters, y=y)\n\n        y_l1 = y.copy()\n        y_l1[self.mixed_arr] = 1\n\n        X_l2 = X.loc[self.mixed_arr, :]\n        y_l2 = y[self.mixed_arr]\n\n        self.model_l1.fit(X, y_l1)\n        self.model_l2.fit(X_l2, y_l2)\n\n    def predict(self, X):\n        \"\"\"\n        Predicting new instances\n        \"\"\"\n\n        yh_l1, yh_l2 = self.model_l1.predict(X), self.model_l2.predict(X)\n\n        yh_f = np.asarray([x1 * x2 for x1, x2 in zip(yh_l1, yh_l2)])\n\n        return yh_f\n\n    def predict_proba(self, X):\n        \"\"\"\n        Probabilistic predictions\n        \"\"\"\n\n        yh_l1_p = self.model_l1.predict_proba(X)\n        try:\n            yh_l1_p = np.array([x[1] for x in yh_l1_p])\n        except IndexError:\n            yh_l1_p = yh_l1_p.flatten()\n\n        yh_l2_p = self.model_l2.predict_proba(X)\n        yh_l2_p = np.array([x[1] for x in yh_l2_p])\n\n        yh_fp = np.asarray([x1 * x2 for x1, x2 in zip(yh_l1_p, yh_l2_p)])\n\n        return yh_fp\n\n    @classmethod\n    def cluster_to_layers(cls, clusters: List[np.ndarray], y: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Defining the layers from clusters\n        \"\"\"\n\n        maj_cls, min_cls, both_cls = [], [], []\n        for clst in clusters:\n            y_clt = y[np.asarray(clst)]\n\n            if len(Counter(y_clt)) == 1:\n                if y_clt[0] == 0:\n                    maj_cls.append(clst)\n                else:\n                    min_cls.append(clst)\n            else:\n                both_cls.append(clst)\n\n        both_cls_ind = np.array(sorted(np.concatenate(both_cls).ravel()))\n        both_cls_ind = np.unique(both_cls_ind)\n\n        if len(min_cls) > 0:\n            min_cls_ind = np.array(sorted(np.concatenate(min_cls).ravel()))\n        else:\n            min_cls_ind = np.array([])\n\n        both_cls_ind = np.unique(np.concatenate([both_cls_ind, min_cls_ind])).astype(int)\n\n        return both_cls_ind\n\n    @classmethod\n    def clustering(cls, X, method='ward'):\n        \"\"\"\n        Hierarchical clustering analysis\n        \"\"\"\n\n        d = pdist(X)\n\n        Z = linkage(d, method)\n        Z[:, 2] = np.log(1 + Z[:, 2])\n        sZ = np.std(Z[:, 2])\n        mZ = np.mean(Z[:, 2])\n\n        clust_labs = fcluster(Z, mZ + sZ, criterion='distance')\n\n        clusters = []\n        for lab in np.unique(clust_labs):\n            clusters.append(np.where(clust_labs == lab)[0])\n\n        return clusters\n```", "```py\nimport pandas as pd\nfrom sklearn.datasets import make_classification\nfrom sklearn.ensemble import RandomForestClassifier as RFC\n\n# https://github.com/vcerqueira/blog/blob/main/src/icll.py\nfrom src.icll import ICLL\n\n# creating a dummy data set\nX, y = make_classification(n_samples=500, n_features=5, n_informative=3)\nX = pd.DataFrame(X)\n\n# creating a instance of the model\nicll = ICLL(model_l1=RFC(), model_l2=RFC())\n# training\nicll.fit(X, y)\n# probabilistic predictions\nprobs = icll.predict_proba(X)\n```", "```py\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import roc_curve, roc_auc_score\nfrom imblearn.over_sampling import SMOTE\n\n# loading diabetes dataset https://github.com/vcerqueira/blog/tree/main/data\ndata = pd.read_csv('data/pima.csv')\n\nX, y = data.drop('target', axis=1), data['target']\nX = X.fillna(X.mean())\n\n# train test split\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.33, random_state=42)\n\n# resampling with SMOTE\nX_res, y_res = SMOTE().fit_resample(X_train, y_train)\n\n# creating the models\nsmote = RFC()\nicll = ICLL(model_l1=RFC(), model_l2=RFC())\n\n# training \nsmote.fit(X_res, y_res)\nicll.fit(X_train, y_train)\n\n# inference\nsmote_probs = smote.predict_proba(X_test)\nicll_probs = icll.predict_proba(X_test)\n```"]