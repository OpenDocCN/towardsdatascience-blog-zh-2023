- en: Julia Magic Too Few People Know About
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/julia-magic-too-few-people-know-about-330a7039a11a](https://towardsdatascience.com/julia-magic-too-few-people-know-about-330a7039a11a)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Some less known capabilities of the Julia programming language.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://emmaccode.medium.com/?source=post_page-----330a7039a11a--------------------------------)[![Emma
    Boudreau](../Images/f7201d012b733643d6e97957f73fd1fa.png)](https://emmaccode.medium.com/?source=post_page-----330a7039a11a--------------------------------)[](https://towardsdatascience.com/?source=post_page-----330a7039a11a--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----330a7039a11a--------------------------------)
    [Emma Boudreau](https://emmaccode.medium.com/?source=post_page-----330a7039a11a--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----330a7039a11a--------------------------------)
    ·10 min read·Oct 15, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b22e53ebd32ae5b1747afc050ab2696b.png)'
  prefs: []
  type: TYPE_IMG
- en: (image by author)
  prefs: []
  type: TYPE_NORMAL
- en: introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As far as programming languages and their paradigms go, Julia’s take is incredibly
    unique. Comparing Julia to the slough of other multi-paradigm programming languages
    that are popular today, Julia is radically different by many comparisons. This
    is especially the case in paradigm, or how the types of the language (which hold
    the data,) work with functions or methods in the language. There are a number
    of different solutions that have been proposed for this, and every language tends
    to sit in one category — though not necessarily firmly. Most modern languages
    have bridged multiple programming concepts through these paradigms, and this makes
    most modern programming languages multi-paradigm. Under this umbrella, the Julia
    language would also be included.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although Julia is a multi-paradigm programming language, it is built in a unique
    paradigm centered around multiple dispatch. This is not to say this paradigm is
    entirely novel, the basis of this paradigm is found in the Standard Meta Language
    (SML). I actually, because of Julia, went back and tried that language ages ago
    — it was a very interesting experience, and if you would like to read more about
    what transpired with that here is a link to that article:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/getting-introduced-to-sml-a-weird-polymorphic-language-originated-in-1983-797ff9d6622e?source=post_page-----330a7039a11a--------------------------------)
    [## Getting Introduced to SML: A Weird Polymorphic Language Originated in 1983'
  prefs: []
  type: TYPE_NORMAL
- en: Trying my luck at writing and compiling some basic code with the SML language
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/getting-introduced-to-sml-a-weird-polymorphic-language-originated-in-1983-797ff9d6622e?source=post_page-----330a7039a11a--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of really cool things that Julia can do that are entirely unique
    to the language. This paradigm and its feature set brings a lot of excitement
    and new capabilities to a programming language, but also creates a lot of hurdles.
    Taking advantage of these complexities can mean a lot when it comes to Data Science.
    With capability comes complexity, and with certain nuances of Julia that are somewhat
    unique it might be tricky for users to get a full Julia experience. There is a
    lot to learn, and Julia is a seriously awesome language to work with, so it is
    worth taking advantage of!
  prefs: []
  type: TYPE_NORMAL
- en: As far as Data Science goes, Julia is the new kid on the block, but its community
    development has been solid and the language only gets more and more promising
    day by day. That being said, when using Julia in your Data Science projects it
    really comes in handy to know the language well. This is especially the case considering
    just how much Science stuff is in Julia’s `Base` . Julia has been designed with
    Data Science in mind, so learning Julia in this way is going to be very helpful
    towards mastering Data Science in the language!
  prefs: []
  type: TYPE_NORMAL
- en: '[olive notebook](https://github.com/ChifiSource/OliveNotebooks.jl/blob/main/julia/random/less_known_jl.jl)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: initialized arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One thing that I sometimes forget that Julia features is initialized arguments.
    This allows us to have an argument that is obtained with some work. This has applications
    all over the places and I find this incredibly useful. This is very useful for
    creating a default that pulls data from another provided argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here we made an `index` argument which will always be the `length` of `vec`
    by default. Useful! This is quite a lot better, in my opinion, than the solution
    that is found in languages without this feature. That considered, I really appreciate
    this feature being in Julia — a new Julia user could certainly miss it, and an
    experienced user could certainly forget it is there — but when the situation is
    correct, it is a really nice thing to have and makes a far superior API!
  prefs: []
  type: TYPE_NORMAL
- en: checking methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Methods` in Julia carries a connotation somewhat unique to the language and
    its paradigm. In Julia, methods are defined as function names alongside the types
    of the arguments that method of that function is written for. In other words,'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the example above, `example` is a function and `example(::Any)` is its first
    method. See we not only defined the function, but also its first method. We can
    get these methods into a `Base.MethodList` using the `methods` method. This is
    useful for any introspection we might want to do, and the display of the `MethodList`
    is really helpful for learning the dispatches of functions. The significant upside
    to Julia’s system is that less functions get built — more methods get built. The
    significant downside is that this means you need to learn multiple methods for
    each function and how it applies to each type. Fortunately, something like this
    is really helpful towards learning these things.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/74524d8f7019eec3f9e2db8f59ad775e.png)'
  prefs: []
  type: TYPE_IMG
- en: (image by author)
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also certainly applications of method introspection outside of just
    learning the functions, however. This is the basis for my project Olive’s **multiple
    dispatch** notebook. For this case, I used the method list to search for new ways
    to build cells — making loading extensions as easy as defining methods. If you
    would like to view that project, here is a link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://github.com/ChifiSource/Olive.jl?source=post_page-----330a7039a11a--------------------------------)
    [## GitHub - ChifiSource/Olive.jl: pure julia notebooks'
  prefs: []
  type: TYPE_NORMAL
- en: pure julia notebooks. Contribute to ChifiSource/Olive.jl development by creating
    an account on GitHub.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: github.com](https://github.com/ChifiSource/Olive.jl?source=post_page-----330a7039a11a--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: With Julia we can easily examine any function and its methods — as well as essentially
    everything else in `Main` . Introspection is very prominent in this language and
    is very useful in this language, so this is certainly another feature in Julia
    that I appreciate substantially.
  prefs: []
  type: TYPE_NORMAL
- en: '[](/runtime-introspection-julias-most-powerful-best-kept-secret-bf845e282367?source=post_page-----330a7039a11a--------------------------------)
    [## Runtime Introspection: Julia’s Most Powerful, Best-Kept Secret'
  prefs: []
  type: TYPE_NORMAL
- en: A look at using introspection to work with types in Julia
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/runtime-introspection-julias-most-powerful-best-kept-secret-bf845e282367?source=post_page-----330a7039a11a--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: The most important piece to this puzzle is the field `sig` on the `Method` type.
    Using this, we can denote things about the methods from within our code, and this
    can be very useful in some instances.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This signature contains the type of our `Function` and the type of each argument,
    this example has one, `Any` .
  prefs: []
  type: TYPE_NORMAL
- en: deleting methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Something I find really cool about Julia is that we can both add **and** delete
    methods. In essence, this means any `Method` can be replaced, methods can be removed
    for certain instances. The Base portion of Julia, or any other Julia package that
    is added is incredibly open-ended on what you can do. From within Julia we can
    `import` and extend with some methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We can also delete methods. For a long time I had no idea this could be done,
    and when this is the case I am always eccentric to be sharing it. Now that we
    have `cd` imported, we use `Base.delete_method` on a `Method` of that function
    to remove it. We retrieve this `Method` using the `methods` method — *jeeze*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: dispatch a parameter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another really great aspect of Julia is the type parameters. Parameters are
    a **distinction of type** that tell us something about how the structure was constructed.
    For example, the following `Vector` has a parameter denoting the type of its elements,
    `Int64` .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This comes in handy in multiple capacities. For new users, I see parameters
    as a common barrier to learning Julia — it is understandable that a lack of familiarity
    with type parameters could make this daunting. They are quire useful however,
    and relatively straightforward to use. These parameters are used to create parametric
    multiple dispatch, or parametric polymorphism — generic functions that mutate
    multiple types based on parameters. This is also a very powerful feature in Julia.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Another really cool aspect to this is that we can dispatch based on super-types.
    This means at any point in our abstraction hierarchy we may use multiple dispatch
    to encompass all the types below. For example, we want all `Real` numbers to be
    arguments… We do this by using the sub-type operator, `<:` , before the abstract
    type in our parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now `example` can be used with any `Vector` containing sub-types of `Real`.
    If we do not use the sub-type. With this, we can write a method as generically
    as possible. As a result, Julia projects take a lot less code — this paradigm
    makes it incredibly easy to pinpoint exactly the thing you need and write a method
    for it. The icing on the cake is being able to do that with any `Method` .
  prefs: []
  type: TYPE_NORMAL
- en: AWESOME comprehensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Julia has **the best** comprehensions of any programming language I have ever
    used. This is partially due to Julia’s expressive syntax, which contributes in
    a variety of ways. For example, Julia’s parsing does not care about white-space
    — we can also wrap anything in a begin and an end. With how useful (and fast)
    comprehensions are in Julia, I rarely see reason to use a traditional `for` loop.
    The exception is when I want to use `continue` or `break` . Another reason these
    are so useful in that sense is because they always produce a `Vector` return.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: There are few programming languages where comprehensions are quite so flexible.
    This is something that I think more users ought to try taking advantage of. In
    the example above we have an entire conditional and a return with no appending
    or anything like that. This is a really nice feature of Julia, and can make code
    incredibly concise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/bafd2956f639f5cf1a848c9bf2f02845.png)'
  prefs: []
  type: TYPE_IMG
- en: (image by author)
  prefs: []
  type: TYPE_NORMAL
- en: expr examination
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to meta-programming, Julia is a language that carries many possibilities
    along with it. With some Julia experience, we might get familiar with the basics
    of meta-programming in Julia. This is done primarily using `eval` and `Meta.parse`
    .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`Meta` is a `Module` inside `Base` , this is a distinguished method from `Base.parse`
    . While this is a more basic form of this type of examination, we can also look
    further into an `Expr` by looking into its field.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b1606459ff634a3d8dd91b009f78ada9.png)'
  prefs: []
  type: TYPE_IMG
- en: The main two fields on the `Expr` tyoe are `head` and `args`. In this context,
    `head` is the function call and `args` are the arguments provided.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: eval is a field of module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For these last 3, we will be moving to the REPL as in some cases we need the
    terminal for these examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to scoping, Julia has all you need — as many languages do. Julia,
    like most other languages of its type, uses lexical scoping. This is a scope which
    is descending, like a mountain it gets smaller as you go further up in the levels
    of scoping. This means that anytime you open a new scope it can access the scope
    above it but not the scope below it. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the example above, `Example` is in a new scope below `Main` . This means
    that `Example` can access `Main` , but `Main` cannot access `Example` . Thus,
    `y` is defined in `Example` , but `x` is not defined in `Main` . A new scope like
    this is opened anytime we perform most actions in programming — looping, conditionals,
    and method calls all establish a new level of scope and have their own scope.
    This is an important thing to consider when programming in any language.
  prefs: []
  type: TYPE_NORMAL
- en: In Julia, modules are containers which contain names, which are essentially
    just fields. These names are everything defined within that module. Inside of
    each module, we also have a local `eval` . As a result, in the case of our `Example`
    function from earlier, `Example.eval` is a function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: piping operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another really cool thing that I often forget Julia comes with is the ability
    to pipe functions. Piping allows us to chain together several function calls very
    easily in a way that is incredibly readable. With pipes, we turn several function
    calls on one thing into a single line of code. Piping in Julia is also easy and
    concise. This is done using the `|>` pipe operator in a pragmatic fashion, function
    by function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s pipe a number through these two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: redirecting standard output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last thing I wanted to talk about that is surprisingly easy in Julia is
    redirecting IO. In other languages, such as Python, this is a surprisingly daunting
    feat that requires a lot of knowledge and work. In Julia, this is a simple method
    call that is incredibly easy to use. To redirect standard output in Julia, we
    simply use the `redirect_stdout` method! The only challenge to this is that this
    `Method` takes an `IOStream` or a `Pipe` . Only a `Pipe` is in memory, so the
    easiest use-case is to use this to write to a file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a lot that can be done with this, there is a lot more if this can
    be stored in memory. I have an entire article which goes into a lot of detail
    on this function and all of the ways to use it. If you would like to learn more
    about this, here is a link to that article:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://chifi.dev/redirecting-output-in-julia-the-rundown-7a1c814f842f?source=post_page-----330a7039a11a--------------------------------)
    [## Redirecting Output In Julia: The Rundown'
  prefs: []
  type: TYPE_NORMAL
- en: Everything you need to know about redirecting STDIO in Julia.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: chifi.dev](https://chifi.dev/redirecting-output-in-julia-the-rundown-7a1c814f842f?source=post_page-----330a7039a11a--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Julia’s greatest strength is how its many features play on its core paradigm.
    Julia’s greatest weakness is that these many features create a barrier for new
    users and using them. Furthered, this might make new users more prone to get lost
    in code. Julia’s syntax is able to make code as condensed as possible while still
    being very legible, but there is still a problem if you don’t know how to read
    it. That being said, there is a lot of Julia and some of my favorite things about
    Julia are things that people have no idea even exist! Hopefully sharing these
    was helpful on this day! Thank you for reading!
  prefs: []
  type: TYPE_NORMAL
