- en: 'Understanding Predictive Maintenance — Wave Data: Feature Engineering (Part
    2)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/understanding-predictive-maintenance-wave-data-feature-engineering-part-2-spectral-3eced3bdbb3e](https://towardsdatascience.com/understanding-predictive-maintenance-wave-data-feature-engineering-part-2-spectral-3eced3bdbb3e)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Feature engineering of spectral data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://marcin-staskopl.medium.com/?source=post_page-----3eced3bdbb3e--------------------------------)[![Marcin
    Stasko](../Images/5142b9a260a1cce7c6a2ebcc16f46fbb.png)](https://marcin-staskopl.medium.com/?source=post_page-----3eced3bdbb3e--------------------------------)[](https://towardsdatascience.com/?source=post_page-----3eced3bdbb3e--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----3eced3bdbb3e--------------------------------)
    [Marcin Stasko](https://marcin-staskopl.medium.com/?source=post_page-----3eced3bdbb3e--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----3eced3bdbb3e--------------------------------)
    ·12 min read·Dec 1, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f135b31634608fd3f588fd8593f13524.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Evie S.](https://unsplash.com/@evieshaffer?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Article Purpose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the second part of the article about Wave Data Feature Engineering.
    We are going to focus on the spectral features. Have you got any thoughts to add?
    Feel free to share!
  prefs: []
  type: TYPE_NORMAL
- en: This article is part of the series Understanding Predictive Maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: '[Check the whole series in this link](https://marcin-staskopl.medium.com/list/understanding-predictive-maintenance-series-e1f44d8a0cc3).
    Ensure you don’t miss out on new articles by following me. All images without
    captions were created by me.'
  prefs: []
  type: TYPE_NORMAL
- en: Frequency-Domain Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Transitioning to the frequency domain, we employ techniques like the `Fast Fourier
    Transform (FFT)` to convert time-domain signals. Extracted features include `dominant
    frequency`, `spectral entropy`, and `spectral kurtosis`. `Power Spectral Density
    (PSD)` and `Harmonic Ratios` offer insights into power distribution and harmonic
    relationships.
  prefs: []
  type: TYPE_NORMAL
- en: '`FFT (Fast Fourier Transform`) Convert the time-domain signal to the frequency
    domain. Extract features from the resulting spectrum, such as `dominant frequency`,
    `spectral entropy`, and `spectral kurtosis`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Power Spectral Density (PSD)` Describes how the power of a signal is distributed
    over frequency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plan for the next article
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wavelet Transform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Demodulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recurrence Quantification Analysis (RQA)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the signal for experiments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I will use exactly the same as in the previous part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/understanding-predictive-maintenance-wave-data-feature-engineering-part-1-fd22b6a19323?source=post_page-----3eced3bdbb3e--------------------------------)
    [## Understanding Predictive Maintenance — Wave Data: Feature Engineering (Part
    1)'
  prefs: []
  type: TYPE_NORMAL
- en: All the information you need to start learning about wave-data signal processing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/understanding-predictive-maintenance-wave-data-feature-engineering-part-1-fd22b6a19323?source=post_page-----3eced3bdbb3e--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s generate the signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Fast Fourier Transform (FFT) and Short-Time Fourier Transform (STFT)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../Images/1ebe66b97175a466eabf1d456011f01d.png)'
  prefs: []
  type: TYPE_IMG
- en: FFT equation (Latex compiled)
  prefs: []
  type: TYPE_NORMAL
- en: Signal Representation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start with our signal, which is essentially a series of data points representing
    how the signal changes over time. This could be a sound wave, a sequence of numbers,
    or any other data that varies with time.
  prefs: []
  type: TYPE_NORMAL
- en: Discrete Fourier Transform (DFT)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `FFT` is a more efficient way of computing something called the `Discrete
    Fourier Transform (DFT)`. The `DFT` takes our signal and expresses it as a sum
    of sinusoidal functions, each representing a different frequency component. This
    is where the magic happens.
  prefs: []
  type: TYPE_NORMAL
- en: Divide and Conquer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of directly computing the `DFT` for the entire signal, `FFT` takes advantage
    of the fact that a `DFT` of any composite signal can be expressed as the combination
    of `DFTs` of its subparts. It divides the signal into smaller sections, computes
    the `DFT` for each section, and then combines them.
  prefs: []
  type: TYPE_NORMAL
- en: Butterfly Operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The magic of `FFT` lies in a process called the butterfly operation. It’s like
    a dance move where the computed frequencies are paired up and combined in a specific
    way. This happens recursively until we have the final frequency components of
    the entire signal.
  prefs: []
  type: TYPE_NORMAL
- en: Efficiency Boost
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The key to `FFT’s` speed is its ability to dramatically reduce the number of
    computations needed compared to the straightforward `DFT` approach. By exploiting
    the symmetries and patterns in the signal, `FFT` efficiently calculates the frequency
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Time for code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we can apply the theory into practice in simple code lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`len(fft_result)` This is the length of the `FFT` result, which is essentially
    the number of points in the frequency domain. The `FFT` operation transforms a
    time-domain signal into a frequency-domain signal and `len(fft_result)` gives
    you the number of frequency bins.'
  prefs: []
  type: TYPE_NORMAL
- en: '`1/sampling_rate` This is the inverse of the sampling rate `sampling_rate`,
    representing the time interval between samples in the original time-domain signal.
    The sampling rate is the number of samples per second.'
  prefs: []
  type: TYPE_NORMAL
- en: '`np.fft.fftfreq()` This function generates the frequencies corresponding to
    the `FFT` result. It takes two parameters. The first one is the length of the
    result `len(fft_result)`, and the second one is the sampling interval `1/sampling_rate`.
    It returns an array of frequencies.'
  prefs: []
  type: TYPE_NORMAL
- en: But do not worry. Using these two lines, the whole ‘magic’ will happen
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/3030c1c4798e8b9fcbda10af3930d6ca.png)'
  prefs: []
  type: TYPE_IMG
- en: Vibration signal and their FFT representation (code output)
  prefs: []
  type: TYPE_NORMAL
- en: In the plot, we notice a central signal at 0, flanked by two mirrored symmetrical
    signals on the positive and negative sides. This indicates that our signal is
    comprised of a single distinct wave. Before delving into experiments, let’s first
    explore the concept of symmetry, and afterward, we can conduct experiments with
    various signals.
  prefs: []
  type: TYPE_NORMAL
- en: Behind the scenes — FFT symmetry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is happening on the backstage? We have some math and theoretical concepts.
    Let’s make it easy.
  prefs: []
  type: TYPE_NORMAL
- en: In many real-world scenarios, signals are composed of real numbers. In the time
    domain, these signals can be represented as a sequence of values. When you take
    the `FFT` of a real-valued signal, the resulting frequency spectrum is symmetric.
  prefs: []
  type: TYPE_NORMAL
- en: '`Complex conjugate pairs` the symmetry comes from the fact that the `FFT` involves
    complex numbers. For every positive frequency component, there is a corresponding
    negative frequency component with the same magnitude. These pairs of frequencies
    are complex conjugates of each other.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Mirrored information` The positive frequencies represent the information about
    how the signal oscillates in one direction, while the negative frequencies represent
    the same information but in the opposite direction. The `FFT` captures both directions,
    and that’s why the plot looks symmetrical'
  prefs: []
  type: TYPE_NORMAL
- en: In summary, the symmetry in the `FFT` is a consequence of the mathematical properties
    of real-valued signals and complex numbers in the context of the `FFT`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start the next experiments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we understand the basic concepts of the `FFT`. Let’s simulate 2 signals
    with different parameters connected together
  prefs: []
  type: TYPE_NORMAL
- en: 'We will generate a second similar signal we will only focus on Frequency and
    amplitude:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s create a combined signal and plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/57fcc4acb0bbc1da2b258f81c8c4080c.png)'
  prefs: []
  type: TYPE_IMG
- en: Combined signal (code output)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s make `FFT` and plot results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/c3b80f5f648cbc24fc6d72e112363819.png)'
  prefs: []
  type: TYPE_IMG
- en: FFT representation of combined_signal (code output)
  prefs: []
  type: TYPE_NORMAL
- en: Now you can see we have the same amplitude height but 2 more signals equally
    offset. `First signal = 10Hz` `Second signal = 20Hz`
  prefs: []
  type: TYPE_NORMAL
- en: The X-axis position is adjusted for signal frequency. Let`s introduce the third
    signal = 100 Hz and plot.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/3cd43922bf37343c8adcf90dd4856560.png)'
  prefs: []
  type: TYPE_IMG
- en: Combined_signal and additional 3rd signal component (code output)
  prefs: []
  type: TYPE_NORMAL
- en: As we can see our “new” signal is now much more offset due to the higher frequency
    value
  prefs: []
  type: TYPE_NORMAL
- en: What will happen if we add a fourth signal with a different amplitude
  prefs: []
  type: TYPE_NORMAL
- en: Make a new signal and plot it together
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/c0d325be9a1adc62419489c1b4808b4b.png)'
  prefs: []
  type: TYPE_IMG
- en: Combined_signal and additional 4th signal component (code output)
  prefs: []
  type: TYPE_NORMAL
- en: Now you can see our Amplitude spectrum is twice higher due to amplitude values
    1 and 2
  prefs: []
  type: TYPE_NORMAL
- en: Power Spectral Density (PSD)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/b00673857b4efd91c46ac5fe5eeb8a52.png)'
  prefs: []
  type: TYPE_IMG
- en: Power Spectral Density equation (Latex compiled)
  prefs: []
  type: TYPE_NORMAL
- en: '`PSD` is like taking a special snapshot of a signal and understanding how much
    power it has at different frequencies. It helps us see the energy distribution
    across the musical or vibration spectrum. We have 2 main `PSD` estimation methods,
    `Welch` and `Barlett`.'
  prefs: []
  type: TYPE_NORMAL
- en: For the experiments, we will create a new combined signal just for the sake
    of clarity and improved visualization (not close frequency to see clear peaks)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Welch Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/e0c7425232613e3a00a4f136fe2eff10.png)'
  prefs: []
  type: TYPE_IMG
- en: PSD Welch method equation (Latex compiled)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/71123b22b52b72afc783b1b5d44cbd5f.png)'
  prefs: []
  type: TYPE_IMG
- en: The Welch method divides the signal into overlapping segments and averages the
    periodograms. This approach provides a trade-off between accuracy and computational
    complexity. However, it may sacrifice frequency resolution for improved variance
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: Bartlett Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/6417a61e18e8d766fc42940367a55f98.png)'
  prefs: []
  type: TYPE_IMG
- en: PSD Bartlett estimation equation (Latex compiled)
  prefs: []
  type: TYPE_NORMAL
- en: '`Bartlett method` is a specific case of the `Welch` method with no overlap
    between segments. While offering simplicity and reduced computational load, it
    shares a similar trade-off between accuracy and frequency resolution with the
    `Welch` method.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/03d02678e1a4eb3dc4d1eabac31746b1.png)'
  prefs: []
  type: TYPE_IMG
- en: The graphical explanation about the differences
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1aa12142a80c595b49817dc0697ae9f6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'image source and my recommendation: [https://www.researchgate.net/figure/Welchs-and-Bartletts-methods-for-power-spectral-density-estimation-The-Bartletts_fig1_349283231](https://www.researchgate.net/figure/Welchs-and-Bartletts-methods-for-power-spectral-density-estimation-The-Bartletts_fig1_349283231)'
  prefs: []
  type: TYPE_NORMAL
- en: Short-Time Fourier Transform (STFT) — windowing + FFT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/19373aa6276e4a8135eb90a7f89c9985.png)'
  prefs: []
  type: TYPE_IMG
- en: Short-Time Fourier Transform equation (Latex compiled)
  prefs: []
  type: TYPE_NORMAL
- en: Why it is useful in predictive maintenance?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`STFT` analysis enables engineers to scrutinize the frequency components of
    signals, such as vibrations or acoustic emissions from machinery. The distinct
    frequency patterns associated with various faults or abnormalities allow for the
    early detection of potential issues, contributing to minimizing downtime and maintenance
    costs.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the primary advantages of `STFT` in predictive maintenance is its ability
    to identify fault signatures early on. This is particularly crucial as `STFT`
    can detect low-amplitude vibrations or subtle changes in signals, providing an
    early warning system that allows practitioners to address issues before they escalate.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, `STFT` plays a pivotal role in distinguishing between normal and
    anomalous frequency patterns. By establishing baseline frequency spectra through
    a comparison of healthy and faulty equipment, engineers can efficiently identify
    deviations and signal impending problems, forming the foundation for effective
    predictive maintenance strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s make some code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Woooh, just “one” line! Power of python. In this function, we have to play with
    2 important parameters with funny names `nperseg` and `noverlap`.
  prefs: []
  type: TYPE_NORMAL
- en: '`nperseg` (**N**umber of **P**oints p**er** **Seg**ment).'
  prefs: []
  type: TYPE_NORMAL
- en: This parameter determines the size of each time window or segment. A larger
    `nperseg` one results in better frequency resolution but poorer time resolution,
    and a smaller `nperseg` one provides better time resolution but poorer frequency
    resolution. In other words, it affects the trade-off between time and frequency
    resolution. In the example, `nperseg=256` it means that each time window is 256
    points long.
  prefs: []
  type: TYPE_NORMAL
- en: '`noverlap` (**N**umber of **Overlap**ping Points).'
  prefs: []
  type: TYPE_NORMAL
- en: This parameter controls the overlap between consecutive time windows. Overlapping
    windows help in capturing the dynamic changes in the signal over time. If `noverlap`
    is set to a value less than `nperseg`, the windows overlap. In the example, `noverlap=128`
    means that each time window overlaps with the previous one by 128 points.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s plot it
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/b0c897371d42fd8124b6a9a71d0129be.png)'
  prefs: []
  type: TYPE_IMG
- en: STFT results spectrogram of combined_signal (code output)
  prefs: []
  type: TYPE_NORMAL
- en: We have to use `Sxx` with basically is spectrogram output(`Sxx[i, j]`) We can
    easily spot our 4 signals combined together. The thicker the ribbon the higher
    the amplitude we have
  prefs: []
  type: TYPE_NORMAL
- en: '`Spectogram Grid (Sxx)` Imagine a big grid like a piece of graph paper.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Grid Rows (up and down)` Each row in the grid represents a different sound
    frequency, like high or low tones. Higher rows might represent high-pitched sounds,
    and lower rows could be for low-pitched sounds.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Grid Columns (left to right)` Each column in the grid represents a different
    moment in time, like a snapshot. As you move from left to right, you’re looking
    at how the sound changes over time.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Colors in the Grid` The colors in the grid tell you how loud or strong each
    frequency is at each moment. Bright colors might mean loud sounds and dull colors
    might mean quieter sounds.'
  prefs: []
  type: TYPE_NORMAL
- en: What will happen if one of our signals will be much stronger?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s reframe the explanation in the context of predictive maintenance and simulate
    a scenario where we modify the fourth signal with a significantly higher amplitude,
    resembling a potential fault or anomaly in the machinery.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/22eb5899181c5e00363103f5a145c3ac.png)'
  prefs: []
  type: TYPE_IMG
- en: FFT results of combined_signal with component created using significantly higher
    amplitude (code output)
  prefs: []
  type: TYPE_NORMAL
- en: Now, observe our new signal, which is significantly dominant. This doesn’t imply
    that the other signals have vanished, but their presence is overshadowed by the
    amplitude of the prominent signal, making them appear more like noise in comparison.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/a0d2e8a1cb05d06e81b0959c4b78963f.png)'
  prefs: []
  type: TYPE_IMG
- en: STFT results spectrogram of combined_signal with component created using significantly
    higher amplitude (code output)
  prefs: []
  type: TYPE_NORMAL
- en: In the spectrogram results, a conspicuous and intense line emerges, indicating
    a potential precursor to future machinery failure. In normal operational conditions,
    our machinery produces a background spectrum. However, as wear and tear progress
    or a component is on the verge of failure, deviations from this normal state become
    noticeable. To delve deeper into this, we might explore training a Convolutional
    Neural Network (CNN) to analyze these spectral patterns and identify distinctive
    signatures associated with impending failures. After the articles about feature
    engineering, I am going to start the modeling series.
  prefs: []
  type: TYPE_NORMAL
- en: This is the end of part 2 of the wave data feature engineering. In the next
    article, I am going to cover.
  prefs: []
  type: TYPE_NORMAL
- en: Wavelet Transform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Demodulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recurrence Quantification Analysis (RQA)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This article is part of the series Understanding Predictive Maintenance. Due
    to your great feedback and recommendation, I have a plan to make the book. If
    there is something that is worth extending or including just let me know. I am
    considering all your feedback.
  prefs: []
  type: TYPE_NORMAL
- en: '[Check the whole series in this link](https://marcin-staskopl.medium.com/list/understanding-predictive-maintenance-series-e1f44d8a0cc3).
    Ensure you don’t miss out on new articles by following me.'
  prefs: []
  type: TYPE_NORMAL
