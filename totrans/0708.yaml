- en: Demystifying Dependence and Why it Is Important in Causal Inference and Causal
    Validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/demystifying-dependence-and-why-it-is-important-in-causal-inference-and-causal-validation-4263b18d5f04](https://towardsdatascience.com/demystifying-dependence-and-why-it-is-important-in-causal-inference-and-causal-validation-4263b18d5f04)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A step-by-step guide in understanding the concept of dependence and how to apply
    it to validate directed acyclic graphs using Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://grahamharrison-86487.medium.com/?source=post_page-----4263b18d5f04--------------------------------)[![Graham
    Harrison](../Images/c6bfe00c6e0cfcdf3bd042c7fdc03554.png)](https://grahamharrison-86487.medium.com/?source=post_page-----4263b18d5f04--------------------------------)[](https://towardsdatascience.com/?source=post_page-----4263b18d5f04--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----4263b18d5f04--------------------------------)
    [Graham Harrison](https://grahamharrison-86487.medium.com/?source=post_page-----4263b18d5f04--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----4263b18d5f04--------------------------------)
    ·16 min read·Nov 11, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2acee73c46470784e1400ed88bbbe08b.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Ana Municio](https://unsplash.com/@lamunix?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash)
    on [Unsplash](https://unsplash.com/photos/gray-and-brown-stones-on-gray-ground-PbzntH58GLQ?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash)
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Causal Inference is an emergent branch of data science concerned with determining
    the cause-and-effect relationship between events and outcomes and it has the potential
    to significantly add to the value that machine learning can generate for organisations.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a traditional machine learning algorithm can predict which loan
    customers are likely to default thereby enabling proactive intervention with customers.
    However, although this algorithm will be useful to reduce loan defaults, it will
    have no concept of why they occurred and whilst pro-active intervention is useful
    knowing the reasons for defaults would enable the underlying cause to be addressed.
    In this world pro-active intervention may no longer be necessary because the factors
    that lead to defaulting have been permanently cured.
  prefs: []
  type: TYPE_NORMAL
- en: This is the promise of Causal Inference and why it has the potential to deliver
    significant impact and outcomes to those organisations that can harness that potential.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of different approaches but the most common approach typically
    starts by augmenting the data with a “Directed Acyclic Graph” which encapsulates
    and visualises the causal relationships in the data and then uses causal inference
    techniques to ask “what-if” type questions.
  prefs: []
  type: TYPE_NORMAL
- en: The Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Directed Acyclic Graph (DAG) that encapsulates the causal relationships in
    the data is typically constructed manually (or semi-manually) by data scientists
    and domain experts working together. Hence the DAG could be wrong which would
    invalidate any causal calculations leading to flawed conclusions and potentially
    incorrect decisions.
  prefs: []
  type: TYPE_NORMAL
- en: The Opportunity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A range of techniques exist for “Causal Validation” (the process of validating
    the DAG against the data) and if these techniques work they can minimise or eliminate
    errors in the DAG thereby ensuring that the calculations and conclusions are error-free.
  prefs: []
  type: TYPE_NORMAL
- en: The Way Forward
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The statistical concept of dependence between random variables can be used to
    ascertain whether a relationship that exists in the DAG also exists in the data;
    if it does exist the DAG is more likely to be correct and if not it is more likely
    to be incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to need an example DAG to work through the problem which has enough
    nodes and links to enable a deep exploration of causal validation …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/cd401cc91ab871411a3df74e01fef9cc.png)'
  prefs: []
  type: TYPE_IMG
- en: Example DAG that will be used throughout the article — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: Each node in a DAG is either having a causal effect on other node(s) or other
    node(s) are having a causal effect on it and the direction of the arrow is the
    direction of the causal effect. For example, one of the causes of “B” is “C” and
    one of the causes of “C” is “F”.
  prefs: []
  type: TYPE_NORMAL
- en: The example DAG is fictitious hence the node letters / names are unimportant,
    however “X” is intended to be the “treatment”, “Y” is the “effect,” and all the
    other nodes are having some causal impact that would, in a real-world example,
    obscure the true effects of X on Y.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the light-blue nodes have no inputs (exogenous in causal terminology)
    and the dark-blue nodes have one or more inputs (endogenous in the terminology).
  prefs: []
  type: TYPE_NORMAL
- en: To get started we will also need some data that matches the DAG. The dataset
    below is entirely synthetic and has been generated by the author. It exactly encapsulates
    and matches the structure suggested by the DAG and contains no erroneous or faulty
    relationships …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/23142b03ead0c51efecb36617405554e.png)'
  prefs: []
  type: TYPE_IMG
- en: Synthetic, fictitious dataset that is associated with the DAG — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: Another thing we need before we can get started is a way of extending the pandas
    `DataFrame` and `Series` classes with custom methods so that the code we write
    is clean, concise and easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a link to one of my previous articles that provides an end-to-end tutorial
    on how to extend data frames and why it is a useful thing to do …
  prefs: []
  type: TYPE_NORMAL
- en: '[](/how-to-extend-pandas-dataframes-with-custom-methods-to-supercharge-code-functionality-readability-f4ae983ad715?source=post_page-----4263b18d5f04--------------------------------)
    [## How to Extend Pandas DataFrames with Custom Methods to Supercharge Code Functionality
    & Readability'
  prefs: []
  type: TYPE_NORMAL
- en: A step-by-step guide to extending pandas DataFrames with custom methods including
    full examples for implementing…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/how-to-extend-pandas-dataframes-with-custom-methods-to-supercharge-code-functionality-readability-f4ae983ad715?source=post_page-----4263b18d5f04--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Dependence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One definition of dependence is as follows …
  prefs: []
  type: TYPE_NORMAL
- en: Dependence between two random variables means that the occurrence or value of
    one variable affects the occurrence or value of the other. Variables are considered
    dependent if the occurrence or value of one variable provides information about
    the occurrence or value of the other variable.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To unpack this, let’s take another look at our example DAG and consider the
    causal factors that affect node Y …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/290380d5018508aeb10f34dcc346a75b.png)'
  prefs: []
  type: TYPE_IMG
- en: DAG with causal factors affecting Y highlighted — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: In this visualisation we can see that node Y is caused by (and hence dependent
    on) 5 different factors — C , E , F , G and X.
  prefs: []
  type: TYPE_NORMAL
- en: Now lets take another look at the data that the DAG is representing …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a87ef178b3188e067c9b179e369a2885.png)'
  prefs: []
  type: TYPE_IMG
- en: Review of the first 5 rows of data from the df_causal DataFrame — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: This synthetic data set was created by the author to facilitate the article
    so I happen to know that the relationship between node Y and those dependent factors
    is as follows …
  prefs: []
  type: TYPE_NORMAL
- en: '**Y = 3C + 3E + 2F + 2.5G + 1.5X + ε**'
  prefs: []
  type: TYPE_NORMAL
- en: '(Note: ε represents the error term)'
  prefs: []
  type: TYPE_NORMAL
- en: … and this can be tested and verified by picking a row (in this case I have
    chosen the 3rd row) applying that formula to the data …
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We can now see why and how Y is dependent on C, E, F, G and X. If the value
    of one of those dependent variables changes, the value of Y will also change.
    We can also see from the DAG that Y should not be dependent (for example) on node
    D because there is no link between D and Y.
  prefs: []
  type: TYPE_NORMAL
- en: The statement “Y is dependent on C, E, F, G and X” can be represented in a mathematical
    formula as follows …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a94fa5224968e1d531aa8cde4caa2c17.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: … and the statement “Y is independent of D” is represented as follows …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/04b9fcfec170531347cc5aa88c9d4409.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: The ⫫ symbol is called a “double up-tack” but the ⫫̸ symbol does not have a
    commonly accepted name so I have adopted “slashed double up-tack” through personal
    preference.
  prefs: []
  type: TYPE_NORMAL
- en: Some articles and texts use a single up-tack (⊥ and ⊥̸) instead of double up-tacks
    but double up-tacks are more common hence that is the standard that I have adopted
    and used throughout this article and the associated Python code.
  prefs: []
  type: TYPE_NORMAL
- en: To recap then, statistical dependence between two random variables means that
    “the occurrence or value of one variable affects the occurrence or value of the
    other” and we now know how this looks visually in the DAG, how to represent it
    as a mathematical formula (e.g. **Y = 3C + 3E + 2F + 2.5G + 1.5X + ε**) and also
    how to represent it using the slashed double up-tack notation (e.g. Y ⫫̸ C, E,
    F, G, X).
  prefs: []
  type: TYPE_NORMAL
- en: From Dependence to Causal Validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Causal Inference typically starts with a set of data and then augments that
    data with a DAG. There are emerging techniques that can reverse engineer a DAG
    from the data but they are not accurate or consistent hence the most common approach
    to developing a DAG is to ask the domain experts what they think the causal relationships
    are and then to validate or test that DAG against the data and amend it as necessary
    if validation fails.
  prefs: []
  type: TYPE_NORMAL
- en: The DAG has proposed that Y is dependent on C, E, F, G and X and if this dependency
    exists in the data then there will be confidence that the causal links pointing
    into node Y are valid and correct and there is a mathematical notation that can
    be used to represent this as follows …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7d1be63d07a51c7371b0adc52771cd4a.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: This scary-looking formula is actually very simple to understand. The “G” subscript
    of the first slashed double up-tack dependency symbol means “in the graph” (i.e.
    the DAG) and the second “D” subscript means “in the data” (note that I have seen
    a “P” subscript in some of the literature but “D” makes more sense to me so that
    is what I have adopted).
  prefs: []
  type: TYPE_NORMAL
- en: Armed with that knowledge, the whole formula can be read as “If Y is dependent
    on C, E, F, G and X in the graph then Y should also be dependent on C, E, F, G
    and X in the data.
  prefs: []
  type: TYPE_NORMAL
- en: It follows then that we just need a mechanism in Python that can detect dependencies
    in the data. That mechanism can then be used to check each node in the DAG that
    has in-coming connections and if dependencies are detected in the data that match
    those in the DAG we can be reasonably confident that there are no spurious connections
    (causal links) and that the DAG is a valid representation of the data in this
    respect.
  prefs: []
  type: TYPE_NORMAL
- en: Observing Dependence in the Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s start by visualising the relationships that exist in the data between
    C, E, F, G and X and our node of interest Y …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5f5c35ed6754ce4e6677ada75543ef7f.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: The chart on the right is plotting Y on the x axis and separate lines for C,
    E, F, G and X on the y axis. If Y is dependent on these other variables then changing
    the value of one of them should change the value of Y. This means that there should
    be a positive or negative co-efficient and the lines should exhibit a noticeable
    slope (either upwards or downwards).
  prefs: []
  type: TYPE_NORMAL
- en: Given that there are definite slopes we can see that 𝑌⫫̸ 𝐶,𝐸,𝐹,𝐺,𝑋 is true i.e.
    that Y is dependent on C, E, F, G and X **in the data**.
  prefs: []
  type: TYPE_NORMAL
- en: If however there is no dependence then changing the value of a variable would
    have little or no effect on Y, the co-efficient should be close to zero and the
    line should have no slope i.e. it should be flat.
  prefs: []
  type: TYPE_NORMAL
- en: This can be demonstrated by adding the relationship between Y and D to the chart
    remembering that there is no causal link from D to Y in the DAG so there should
    be no relationship between Y and D in the data either …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/29419ca82d443e6ace8f4bfb53ad7158.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: This is looking exactly how we would expect it. C, E, F, G and X all have clear
    slopes and either a negative or positive co-efficient clearly showing that if
    the value of those variables changes, the value of Y will be changed so Y is dependent
    on those variables.
  prefs: []
  type: TYPE_NORMAL
- en: However the slope for D is flat and the co-efficient is very small (just -0.029)
    so changing the value of D will have a negligible effect on the value of Y and
    hence the causal relationship 𝑌⫫𝐷 (Y is independent of D) exists in the data.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Dependency in the Data in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The proposed method for detecting dependencies in the data uses the ols class
    from the statsmodels.formula.api library to perform an ordinary least squares
    (OLS) regression.
  prefs: []
  type: TYPE_NORMAL
- en: The ols class can be fitted to a data set and the the coefficients or slopes
    that exist in the data can be extracted and interpreted. Here is how it is done
    …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b7e7c7a721ec0164576975dd169b8a0b.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: The key data in the summary is the middle table which provides some analysis
    of the variables C, E, F, G and X in respect of their relationship with Y. For
    example the ols analysis is proposing the following -
  prefs: []
  type: TYPE_NORMAL
- en: 𝑌=2.03𝐶+3.02𝐸+1.84𝐹+6.33𝐺+1.54𝑋−25.2
  prefs: []
  type: TYPE_NORMAL
- en: and this is not too far away from the formula that I used to create the dataset
    which was …
  prefs: []
  type: TYPE_NORMAL
- en: 𝑌=3𝐶+3𝐸+2𝐹+2.5𝐺+1.5𝑋+ε
  prefs: []
  type: TYPE_NORMAL
- en: The biggest difference is for node G but for the purposes of validation the
    magnitude of the co-efficient is not really important, just that a coefficient
    exists and that the slope is not flat.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the `coef` column the other item of interest is the `P>|t|` or p-value
    column which works as follows ...
  prefs: []
  type: TYPE_NORMAL
- en: The null hypothesis is that there is no relationship between the variable (e.g.
    E) and the dependent variable (e.g. Y)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the p-value is greater than the alpha (usually set at 0.05) then the null
    hypothesis is rejected i.e. there is a relationship i.e. there is dependence.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For example the p-values for E, G and X are all below 0.05 so the null hypothesis
    can be rejected and dependence can be assumed.
  prefs: []
  type: TYPE_NORMAL
- en: But what about C ad F? C has a p-value of 0.076 which is slightly above alpha
    and F has a value if 0.275 which is significantly above our chosen alpha (0.05).
  prefs: []
  type: TYPE_NORMAL
- en: We could just increase alpha until we conclude that all of the variables are
    dependent but that approach will not work very well in the long run as it will
    start concluding dependence where none exists.
  prefs: []
  type: TYPE_NORMAL
- en: When I did the original development I almost gave up at this point assuming
    that ols could not be used as a reliable method to detect dependence across my
    DAGs and data but then I took another look at the ols analysis.
  prefs: []
  type: TYPE_NORMAL
- en: A co-efficient can be observed for all 5 variables, but the p-value is conclusive
    in only 3 out of the 5\. I then swapped to using the `coef` but further on down
    the line I found instances where the p-value worked but the `coef` did not.
  prefs: []
  type: TYPE_NORMAL
- en: After many frustrating hours and a lot of trial-and-error I came established
    a method which uses both values and that exhibits a high degree of accuracy that
    has been rigorously tested against a lot of different data and DAGs.
  prefs: []
  type: TYPE_NORMAL
- en: Here is the method that I use to detect dependency …
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The test I have adopted through trial and error is as follows …
  prefs: []
  type: TYPE_NORMAL
- en: If the p-value is greater than 0.05 AND the co-efficient is less than or equal
    to 1.0 then assume no dependency, otherwise assume dependency.
  prefs: []
  type: TYPE_NORMAL
- en: This approach does not follow the statistical approach which would be just to
    consider the p-value in isolation but a significant amount of testing has suggested
    that it works very reliably.
  prefs: []
  type: TYPE_NORMAL
- en: Optimising the Python Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One drawback with the approach above is that the formula is embedded in the
    code i.e. in `ols_formula = "Y ~ C + E + F + G + X"` and also in the declarations
    of `dependent_variable` and `variables` and this will lead to code repetition
    in a real-world example.
  prefs: []
  type: TYPE_NORMAL
- en: It would be much better if a way could be found to extend the `DataFrame` class
    to be able to perform dependency tests generically on any dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately it is easy to add custom methods to the `DataFrame` class by using
    a technique called "monkey patching". If you would like a step-by-step tutorial
    please take a look at my tutorial article ...
  prefs: []
  type: TYPE_NORMAL
- en: '[](/how-to-extend-pandas-dataframes-with-custom-methods-to-supercharge-code-functionality-readability-f4ae983ad715?source=post_page-----4263b18d5f04--------------------------------)
    [## How to Extend Pandas DataFrames with Custom Methods to Supercharge Code Functionality
    & Readability'
  prefs: []
  type: TYPE_NORMAL
- en: A step-by-step guide to extending pandas DataFrames with custom methods including
    full examples for implementing…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/how-to-extend-pandas-dataframes-with-custom-methods-to-supercharge-code-functionality-readability-f4ae983ad715?source=post_page-----4263b18d5f04--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Here is the optimised code that enables any dependency test to be executed against
    any dataset …
  prefs: []
  type: TYPE_NORMAL
- en: Once the `DataFrame` class has been extended with the `dependence` method, it
    is trivially easy to test any dependency test.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can try out 𝑌⫫̸𝐶,𝐸,𝐹,𝐺,𝑋 which should validate as `True` with
    no errors ...
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/45d9d09bd277f3fffb2a4a67b27e5075.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: We can try out 𝑌⫫̸𝐶,𝐸,𝐹,𝐺,𝑋,𝐷 which should validate as `False` indicating that
    "D" is an error because Y is not dependent on it ...
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d473cc439c247524f601e2832e64bba9.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: These tests both pass and the success rate is very high across all of the DAGs
    and datasets I have tried out to ascertain the accuracy of this approach.
  prefs: []
  type: TYPE_NORMAL
- en: Bringing it All Together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To summarise, the relatively small code-base presented above achieves an impressive
    outcome i.e. to enable any dependency test to be carried out on any dataset to
    indicate whether that test passes or not and where it fails to specifically highlight
    the errors.
  prefs: []
  type: TYPE_NORMAL
- en: However, more is needed. Let’s assume that when we consulted our domain experts
    the DAG they produced contained an error and that those experts had assumed that
    a causal link (or dependency) existed from node D to node Y.
  prefs: []
  type: TYPE_NORMAL
- en: The proposed DAG would now look like this …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/22a4b93964ccce5e5112f983fcfb1719.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: Armed with our new capability we can easily test the DAG out for node Y as follows
    …
  prefs: []
  type: TYPE_NORMAL
- en: … and as we have seen in the results above node “D” will be accurately identified
    as an “error”. We have therefore identified a “spurious edge” i.e. a link that
    exists in the DAG but that does not exist in the data and this tells us that the
    DAG must be adjusted to removed that spurious edge in order to be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: It therefore follows that the following must hold …
  prefs: []
  type: TYPE_NORMAL
- en: Start with a proposed DAG.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Iterate over all nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute a dependency test for all incoming connections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accumulate a list of all errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The accumulated list of errors will instantly indicate all spurious edges /
    connections / dependencies which must be removed from the proposed DAG to produce
    a new DAG that is free of all spurious edges (i.e. dependencies that exist in
    the DAG but not in the data).
  prefs: []
  type: TYPE_NORMAL
- en: The code to achieve this is as follows …
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Full Algorithm to Detect Spurious Edges in the DAG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With these few lines of code it is now possible to test any DAG (represented
    by a set of edges) against any data (represented by a pandas `DataFrame`) to see
    if there are any "spurious" edges in the DAG that do not exist in the data.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by testing the case where the DAG correctly represents all of the
    causal links in the data (remembering that `df_causal` correctly represents the
    DAG as it was synthetically created by the author to be an exact representation)
    ...
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: No errors were detected where the DAG matches the data.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s add a non-existent causal link D => Y into our DAG and re-run the
    code …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/22a4b93964ccce5e5112f983fcfb1719.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The “spurious” edge was correctly identified in the DAG! But what about when
    there are multiple spurious causal relationships in the DAG that do not exist
    in the data? Will our algorithm still perform?
  prefs: []
  type: TYPE_NORMAL
- en: To test this out a second non-existent causal link A => E is added to the DAG
    …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/73746a399cf9cbe55e900a81eb48321f.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This test has also passed. If two spurious causal relationships are added to
    the DAG that do not exist in the data they are both correctly detected and identified
    as errors.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Algorithm to Destruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These promising results give rise to the question “So, just how accurate is
    this methods?” i.e. how many spurious causal relationships can continue to be
    added to the DAG before it fails to detect them correctly.
  prefs: []
  type: TYPE_NORMAL
- en: To answer this questions the author devised a challenging test that started
    by identifying every single valid causal link that could exist in the DAG but
    that does not. In the case of this particular DAG the full set of possible links
    looks like this …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/803272ebb3328bbd0dba172ff00f907b.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: A test harness was then used to randomly select any 3 of the possible missing
    links at the same time, and to repeat that test for different sets in order to
    ascertain the accuracy of the validation algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: The results are astounding. The simple algorithm presented here detects any
    combination of 3 spurious links (using the example DAG and data) with 100% accuracy.
    Even changing the test to select any 12 of the possible spurious links together
    produces an accuracy of 90%!
  prefs: []
  type: TYPE_NORMAL
- en: 'Bonus Section: Separate vs. Combined Dependency Testing'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the article the set of dependencies for a given node has been established
    by looking at all of the “parent” nodes and then creating a single statement of
    dependences, for example …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a94fa5224968e1d531aa8cde4caa2c17.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering if the same set of tests are equivalent …
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d4b3396d6463ee1d91826993c5af3e17.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: One of the challenges the author faced was to assume that these separate tests
    are equivalent to the single overall test when detecting spurious edges but trial-and-error
    during testing led to the firm conclusion that this is not the case.
  prefs: []
  type: TYPE_NORMAL
- en: When looking for the spurious edge Y => D the implementing the 𝑌⫫̸𝐶,𝐸,𝐹,𝐺,𝑋,𝐷
    test was 100% reliable but testing separately for 𝑌⫫̸𝐷 does not work and this
    was proven by executing many rounds of automated testing to compare the accuracy
    of the two methods.
  prefs: []
  type: TYPE_NORMAL
- en: The assumption is that because the formula that encapsulates the relationships
    between these variables is **𝑌 = 3𝐶 + 3𝐸 + 2𝐹 + 2.5𝐺 + 1.5𝑋 + ε** the OLS test
    which underpins the implementation of dependency needs to consider all of the
    variables together and this also bears out another truism in causal inference
    …
  prefs: []
  type: TYPE_NORMAL
- en: '**it is very difficult or maybe even impossible to reverse engineer a DAG from
    the data but when a “first stab” has been made that gets most of the way there
    the task becomes achievable**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The morale of this section is: consider all of the incoming relationships for
    each node together when testing for dependency because if they are tested separately
    it simply does not work.'
  prefs: []
  type: TYPE_NORMAL
- en: Connect and Get in Touch …
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you enjoyed this article, you can get unlimited access to thousands more
    by becoming a Medium member for just $5 a month by [clicking on my referral link](https://grahamharrison-86487.medium.com/membership)
    (I will receive a proportion of the fees if you sign up using this link at no
    extra cost to you).
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://grahamharrison-86487.medium.com/membership?source=post_page-----4263b18d5f04--------------------------------)
    [## Join Medium with my referral link - Graham Harrison'
  prefs: []
  type: TYPE_NORMAL
- en: As a Medium member, a portion of your membership fee goes to writers you read,
    and you get full access to every story…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: grahamharrison-86487.medium.com](https://grahamharrison-86487.medium.com/membership?source=post_page-----4263b18d5f04--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: … or connect by …
  prefs: []
  type: TYPE_NORMAL
- en: '[Subscribing to a free e-mail whenever I publish a new story](https://grahamharrison-86487.medium.com/subscribe).'
  prefs: []
  type: TYPE_NORMAL
- en: '[Taking a quick look at my previous articles](https://grahamharrison-86487.medium.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: '[Downloading my free strategic data-driven decision making framework](https://relentless-originator-3199.ck.page/5f4857fd12).'
  prefs: []
  type: TYPE_NORMAL
- en: Visiting my data science website — [The Data Blog](https://www.the-data-blog.co.uk/).
  prefs: []
  type: TYPE_NORMAL
