["```py\nfrom pydantic import BaseModel, Field\n\nclass CalendarEventInput(BaseModel):\n    summary: str = Field(description=\"The title of the event\")\n    location: str = Field(description=\"The location of the event\")\n    description: str = Field(description=\"The description of the event\")\n    start: EventDateTime = Field(description=\"The start datetime of the event\")\n    end: EventDateTime = Field(description=\"The end datetime of the event\")\n    attendees: List[Attendee] = Field(description=\"The attendees of the event\")\n    reminders: Reminders = Field(description=\"The reminders of the event\")\n    conferenceDataVersion: int = Field(\n        description=\"Set to `1` if you need to create a new Google Meet link.\")\n    recurrence: List[str] = Field(\n        description=\"A list of RRULE, EXRULE, RDATE and EXDATE lines for a\"\n                    \" recurring event, as specified in RFC5545\")\n```", "```py\nfrom typing import List\nfrom dataclasses import dataclass\n\n@dataclass()\nclass EventDateTime:\n    dateTime: str\n    timeZone: str\n\n@dataclass()\nclass Attendee:\n    displayName: str\n    email: str\n    optional: bool\n\n@dataclass()\nclass ReminderOverride:\n    method: str\n    minutes: str\n\n@dataclass()\nclass Reminders:\n    useDefault: bool\n    overrides: List[ReminderOverride]\n```", "```py\nfrom langchain.tools.base import BaseTool\nfrom googleapiclient.discovery import build\n\nclass CalendarEventTool(BaseTool):\n    name: str = \"calendar_event\"\n    description: str = \"Useful tool for creating new Google calendar events\"\n    args_schema: Type[BaseModel] = CalendarEventInput\n\n    def _create_event(self, calendar_id: str, body: dict,\n                      conferenceDataVersion: int):\n        \"\"\"Create a new Google calendar event.\n\n        Args:\n            calendar_id (str): The calendar id.\n            body (str): The event body.\n            conferenceDataVersion (int): Set to `1` to create a new Google\n                Meet Event.\n\n        Returns:\n            dict: The event response.\n        \"\"\"\n        service = build(\"calendar\", \"v3\", credentials=get_credentials())\n        event = (service.events()  # type: ignore\n                        .insert(calendarId=calendar_id, body=body,\n                                conferenceDataVersion=conferenceDataVersion)\n                        .execute())\n\n        return event\n\n    def _run(self, summary: str, location: str, description: str,\n             start: EventDateTime, end: EventDateTime,\n             attendees: List[Attendee], reminders: Reminders,\n             conferenceDataVersion: int, recurrence: List[str]):\n        \"\"\"Run the CalendarEventTool with the given parameters.\n\n        Args:\n            summary (str): The summary or title of the event.\n            location (str): The location of the event.\n            description (str): The description or details of the event.\n            start (EventDateTime): The start date and time of the event.\n            end (EventDateTime): The end date and time of the event.\n            attendees (List[Attendee]): A list of attendees for the event.\n            reminders (Reminders): The reminders for the event.\n            conferenceDataVersion (int): The version of the conference data.\n            recurrence (List[str]): A list of recurrence rules for the event.\n        \"\"\"\n        body = create_request_body(summary, location, description,\n                                   start, end, attendees, reminders,\n                                   recurrence)\n        event = self._create_event(CALENDAR_ID, body, conferenceDataVersion)\n\n    def _arun(self):\n        raise NotImplementedError(\"calendar_event does not support async\")\n```", "```py\nimport random\nimport string\n\nfrom typing import List\n\ndef _create_attendee_list(attendees):\n    attendee_list = [{\"displayName\": attendee.displayName,\n                      \"email\": attendee.email,\n                      \"optional\": attendee.optional}\n                     for attendee in attendees]\n    return attendee_list\n\ndef _create_reminder_list(reminders):\n    reminder_list = {\"useDefault\": reminders.useDefault,\n                     \"overrides\": [{\"method\": override.method,\n                                    \"minutes\": override.minutes}\n                                   for override in reminders.overrides]}\n    return reminder_list\n\ndef create_request_body(summary: str, location: str, description: str,\n                        start: EventDateTime, end: EventDateTime,\n                        attendees: List[Attendee], reminders: Reminders,\n                        recurrence: List[str]) -> dict:\n    attendee_list = _create_attendee_list(attendees)\n    reminder_list = _create_reminder_list(reminders)\n    request_id = ''.join(random.choice(string.ascii_letters) for _ in range(8))\n\n    body = {\n        \"summary\": summary,\n        \"location\": location,\n        \"description\": description,\n        \"start\": {\n            \"dateTime\": start.dateTime,\n            \"timeZone\": start.timeZone\n        },\n        \"end\": {\n            \"dateTime\": end.dateTime,\n            \"timeZone\": end.timeZone\n        },\n        \"attendees\": attendee_list,\n        \"reminders\": reminder_list,\n        \"conferenceData\": {\n            \"createRequest\": {\n                \"requestId\": request_id,\n                \"conferenceSolutionKey\": {\n                    \"type\": \"hangoutsMeet\"\n                }\n            }\n        },\n        \"recurrence\": [r for r in recurrence]}\n\n    return body\n```", "```py\nimport os\n\nfrom typing import Union\nfrom pathlib import Path\n\nimport google.oauth2.credentials as oauth2\nimport google.auth.external_account_authorized_user as auth\n\nfrom google.oauth2.credentials import Credentials\nfrom google.auth.transport.requests import Request\nfrom google_auth_oauthlib.flow import InstalledAppFlow\n\nHOME = Path.home()\nTOKEN_FILE = \"token.json\"\nCREDS_FILE = \"credentials.json\"\nSCOPES = [\"https://www.googleapis.com/auth/calendar\"]\n\ndef get_credentials() -> Union[oauth2.Credentials, auth.Credentials]:\n    creds = None\n\n    # If token.json exists, read it and check if it's valid\n    if os.path.exists(TOKEN_FILE):\n        creds = Credentials.from_authorized_user_file(TOKEN_FILE, SCOPES)\n\n    # If there's no valid token.json, refresh it or create a new one\n    if not creds or not creds.valid:\n        if creds and creds.expired and creds.refresh_token:\n            creds.refresh(Request())\n        else:\n            flow = InstalledAppFlow.from_client_secrets_file(\n                CREDS_FILE, SCOPES)\n            creds = flow.run_local_server(port=0)\n        with open(TOKEN_FILE, \"w\") as token:\n            token.write(creds.to_json())\n\n    return creds\n```", "```py\nfrom langchain.chat_models import ChatOpenAI\nfrom langchain.agents import AgentType, initialize_agent\n\n# Initialize the language model\nllm = ChatOpenAI(temperature=0, model_name=\"gpt-4-0613\")  # type: ignore\n\n# Define the list of tools that the agent can use\ntools = [CalendarEventTool()]\n\n# Initialize the agent\nagent = initialize_agent(tools, llm,\n                         agent=AgentType.OPENAI_FUNCTIONS,\n                         verbose=True)\n\nuser_input = input(f\"{Emojis.ASSISTANT} How can I assist you today?\\n\"\n                   f\"{Emojis.USER} > \")\nagent.run(input=user_input)\n```"]