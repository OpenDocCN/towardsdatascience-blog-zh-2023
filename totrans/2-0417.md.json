["```py\ndocker pull postgres\n```", "```py\ndocker run -itd -e POSTGRES_USER=jkaub -e POSTGRES_PASSWORD=jkaub -p 5432:5432 -v ~/db:/var/lib/postgresql/data --name station-db postgres\n```", "```py\ndocker ps \n```", "```py\nCONTAINER ID   IMAGE           COMMAND                  CREATED         STATUS        PORTS                    NAMES\ncb0840806636   postgres        \"docker-entrypoint.s…\"   2 minutes ago   Up 2minutes   0.0.0.0:5432->5432/tcp   station-db\n```", "```py\ndocker exec -it station-db bash\n```", "```py\nroot@cb0840806636:/#\n```", "```py\npsql -U jkaub -d jkaub\n```", "```py\nCREATE DATABASE stations;\n```", "```py\n\\l\n```", "```py\njkaub=# \\l\n                                             List of databases\n   Name    | Owner | Encoding |  Collate   |   Ctype    | ICU Locale | Locale Provider | Access privileges \n-----------+-------+----------+------------+------------+------------+-----------------+-------------------\n stations  | jkaub | UTF8     | en_US.utf8 | en_US.utf8 |            | libc            |\n```", "```py\npip install psycopg2 sqlalchemy\n```", "```py\nfrom sqlalchemy import create_engine\n\nengine = create_engine('postgresql://jkaub:jkaub@localhost/stations')\n\n# test the connection by executing a simple query\nwith engine.connect() as conn:\n    result = conn.execute('SELECT 1')\n    print(result.fetchone())\n```", "```py\nengine = create_engine('postgresql://jkaub:jkaub@localhost/stations')\n```", "```py\n# test the connection by executing a simple query\nwith engine.connect() as conn:\n    result = conn.execute('SELECT 1')\n    print(result.fetchone())\n```", "```py\npip install uvicorn\npip install fastapi\npip install sqlmodel\npip install geoalchemy2\n```", "```py\napi/\n  |-- app/\n    |-- __init__.py\n    |-- models.py\n```", "```py\nfrom sqlmodel import Field, SQLModel\nfrom datetime import datetime\nfrom typing import Optional\n\nclass Cities(SQLModel, table=True):\n    id: Optional[int] = Field(default=None, primary_key=True)\n    postal_code: str\n    name: str\n    lat: float\n    lon: float\n```", "```py\nfrom datetime import datetime\n\n...\n\nclass GasPrices(SQLModel, table=True):\n    id: Optional[int] = Field(default=None, primary_key=True)\n    station_id: str\n    oil_id: str\n    nom: str\n    valeur: float\n    maj: datetime = Field(default_factory=datetime.utcnow)\n\nclass Stations(SQLModel, table=True):\n    station_id: str = Field(primary_key=True)\n    latitude: float\n    longitude: float\n    cp: str\n    city: str\n    adress: str\n```", "```py\napi/\n  |-- app/\n    |-- __init__.py\n    |-- models.py\n    |-- services.py\n```", "```py\nfrom sqlmodel import SQLModel, create_engine\nimport models\n\nDATABASE_URL = 'postgresql://jkaub:jkaub@localhost/stations'\n\nengine = create_engine(DATABASE_URL)\n\ndef create_db_and_tables():\n    SQLModel.metadata.create_all(engine)\n```", "```py\napi/\n  |-- app/\n    |-- __init__.py\n    |-- main.py\n    |-- models.py\n    |-- services.py\n```", "```py\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi import FastAPI, HTTPException\nfrom models import Cities, Stations, GasPrices\nfrom services import engine, create_db_and_tables\n\n#We create an instance of FastAPI\napp = FastAPI()\n\n#We define authorizations for middleware components\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"http://localhost:3000\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n#We use a callback to trigger the creation of the table if they don't exist yet\n#When the API is starting\n@app.on_event(\"startup\")\ndef on_startup():\n    create_db_and_tables()\n```", "```py\nallow_origins=[\"*\"],\n```", "```py\nuvicorn main:app --reload\n```", "```py\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n```", "```py\n\\c stations\n```", "```py\n\\dt\n```", "```py\n List of relations\n Schema |      Name       | Type  | Owner \n--------+-----------------+-------+-------\n public | cities          | table | jkaub\n public | gasprices       | table | jkaub\n public | stations        | table | jkaub\n```", "```py\n\\d cities\n```", "```py\n Column    |       Type        | Collation | Nullable |              Default  \n\n-------------+-------------------+-----------+----------+-----------------------\n-------------\n id          | integer           |           | not null | nextval('cities_id_seq\n'::regclass)\n postal_code | character varying |           | not null | \n name        | character varying |           | not null | \n lat         | double precision  |           | not null | \n lon         | double precision  |           | not null | \nIndexes:\n    \"cities_pkey\" PRIMARY KEY, btree (id)\n```", "```py\nfrom sqlmodel import Session\n\n...\n\n@app.post(\"/add-city/\")\ndef add_city(city: Cities):\n    with Session(engine) as session:\n        session.add(city)\n        session.commit()\n        session.refresh(city)\n        return city\n```", "```py\n@app.post(\"/add-city/\")\n```", "```py\ndef add_city(city: Cities):\n```", "```py\nwith Session(engine) as session:\n```", "```py\n session.add(city)\n  session.commit()\n  session.refresh(city)\n```", "```py\nreturn city\n```", "```py\nimport requests\n\nurl='http://127.0.0.1:8000/add-city/'\n\njson = {\n    'postal_code': '01400',\n    'name':\"L'Abergement-Clémenciat\",\n    'lat':46.1517,\n    'lon':4.9306\n}\n\nreq = requests.post(url, json=json)\n```", "```py\nINFO:     127.0.0.1:33960 - \"POST /add-gas-price/ HTTP/1.1\" 200 OK\n```", "```py\nSELECT * FROM cities LIMIT 1;\n```", "```py\n id | postal_code |          name           |   lat   |  lon   \n----+-------------+-------------------------+---------+--------\n  1 | 01400       | L'Abergement-Clémenciat | 46.1517 | 4.9306\n```", "```py\nfrom fastapi import FastAPI, HTTPException\n\n...\n\n@app.post(\"/add-city/\")\nasync def add_city(city: Cities):\n    with Session(engine) as session:\n\n        #New code block\n        exist = session.query(Cities).filter(\n            Cities.postal_code == city.postal_code).first()\n        if exist:\n            raise HTTPException(\n                status_code=400, detail=\"Postal code already exists\")\n        #New code block\n\n        session.add(city)\n        session.commit()\n        session.refresh(city)\n        return city\n```", "```py\nexist = session.query(Cities).filter(\n            Cities.postal_code == city.postal_code).first()\n```", "```py\nINFO:     127.0.0.1:49076 - \"POST /add-city/ HTTP/1.1\" 400 Bad Request\n```", "```py\n@app.post(\"/add-station/\")\nasync def add_station(station: Stations):\n    with Session(engine) as session:\n        exist = session.query(Stations).filter(\n            Stations.station_id == station.station_id).first()\n        if exist:\n            raise HTTPException(\n                status_code=400, detail=\"Station already exists\")\n\n        session.add(station)\n        session.commit()\n        session.refresh(station)\n\n        return station\n\n@app.post(\"/add-gas-price/\")\nasync def add_station(gasPrice: GasPrices):\n    with Session(engine) as session:\n        exist = session.query(GasPrices). \\\n            filter(GasPrices.oil_id == gasPrice.oil_id). \\\n            filter(GasPrices.maj == gasPrice.maj). \\\n            first()\n        if exist:\n            raise HTTPException(\n                status_code=400, detail=\"Entry already exists\")\n\n        session.add(gasPrice)\n        session.commit()\n        session.refresh(gasPrice)\n        return gasPrice\n```", "```py\nimport request\nfrom data_parsing import get_data\n\nBASE_API_URL = 'http://127.0.0.1:8000'\n\n#get_data is the function designed in part I to pull the xml from the opendata\n#source and convert them in Dataframes\nstations, gas = get_data()\n\n#Pushing stations data\nto_push = stations[['latitude','longitude','cp','adress','city','station_id']].to_dict('records')\n\nurl=f'{BASE_API_URL}/add-station/'\nfor elmt in to_push:\n    req = requests.post(url, json=elmt)\n\n#Pushing gasprices data\nto_push = gas.to_dict('records')\n\nurl=f'{BASE_API_URL}/add-gas-price/'\nfor elmt in to_push:\n    req = requests.post(url, json=elmt)\n```", "```py\ndocker pull postgis\ndocker kill stations\ndocker rm stations\ndocker run -itd -e POSTGRES_USER=jkaub -e POSTGRES_PASSWORD=jkaub -p 5432:5432 -v ~/db:/var/lib/postgresql/data --name station-db postgis/postgis:latest\n```", "```py\ndocker exec -it station-db bash\n```", "```py\npsql -U jkaub -d jkaub\n```", "```py\n\\c stations\n```", "```py\nCREATE EXTENSION postgis;\n```", "```py\nALTER TABLE stations ADD COLUMN geom geometry(Point, 4326);\n```", "```py\nUPDATE stations SET geom = ST_SetSRID(ST_MakePoint(longitude, latitude), 4326);\n```", "```py\nSELECT * FROM stations LIMIT 1;\n```", "```py\n station_id | latitude | longitude |  cp   | city  |        adress         |                              geom                        \n------------+----------+-----------+-------+-------+-----------------------+----------------------------------------------------\n 26110004   |    44.36 |     5.127 | 26110 | NYONS | 31 Avenue de Venterol | 0101000020E6100000355EBA490C821440AE47E17A142E4640\n```", "```py\nfrom typing import Any\nfrom geoalchemy2.types import Geometry\n\nclass Stations(SQLModel, table=True):\n    station_id: str = Field(primary_key=True)\n    latitude: float\n    longitude: float\n    cp: str\n    city: str\n    adress: str\n    geom: Optional[Any] = Field(sa_column=Column(Geometry('GEOMETRY')))\n```", "```py\nfrom geoalchemy2.elements import WKTElement\n\n@app.post(\"/add-station/\")\nasync def add_station(station: Stations):\n    with Session(engine) as session:\n        exist = session.query(Stations).filter(\n            Stations.station_id == station.station_id).first()\n        if exist:\n            raise HTTPException(\n                status_code=400, detail=\"Station already exists\")\n\n        #New code block\n        point = f\"POINT({station.longitude} {station.latitude})\"\n        station.geom = WKTElement(point, srid=4326)\n        #New code block\n\n        session.add(station)\n        session.commit()\n        session.refresh(station)\n\n        #This is only done to return a clean dictionnar with a proper json format\n        to_return = {}\n        to_return[\"station_id\"] = station.station_id\n        to_return[\"latitude\"] = station.latitude\n        to_return[\"longitude\"] = station.longitude\n        to_return[\"cp\"] = station.cp\n        to_return['city'] = station.city\n        to_return[\"adress\"] = station.adress\n\n        return to_return\n```", "```py\n{  \n  \"lat\": 49.1414,\n  \"lon\": 2.5087,\n  \"city\": \"Orry-la-Ville\",\n  \"station_infos\": [\n    {\n      \"address\": \"Zi Route de Crouy 60530 Neuilly-en-Thelle\",\n      \"price_per_L\": 1.58,\n      \"price_tank\": 95,\n      \"delta_average\": 25.1,\n      \"better_average\": 1,\n      \"google_map_link\": \"https://www.google.com/maps/search/?api=1&query=Zi+Route+de+Crouy+60530+Neuilly-en-Thelle\",\n      \"distance\": 19.140224654602328,\n      \"latitude\": 49.229,\n      \"longitude\": 2.282\n    }, ...\n  ]\n}\n```", "```py\nhttp://localhost:8000/stations/?oil_type=SP98&postal_code=60560\n```", "```py\n@app.get(\"/stations/\")\nasync def get_prices(oil_type: str, postal_code: str):\n  with Session(engine) as session:\n    ...\n```", "```py\ncity = session.query(Cities).filter(\n         Cities.postal_code == postal_code\n       ).first()\nif not city:\n    raise HTTPException(\n        status_code=404, detail=\"Postal Code not found\")\n```", "```py\nstations = session.query(\n    Stations.station_id, Stations.adress,  Stations.cp, Stations.city,\n    Stations.latitude, Stations.longitude,\n).filter(\n    ST_Distance(\n        Stations.geom.ST_GeogFromWKB(),\n        WKTElement(f\"POINT({city.lon} {city.lat})\",\n                   srid=4326).ST_GeogFromWKB()\n    ) < 30000).subquery()\n```", "```py\n price_wanted_gas = session.query(GasPrices).filter(\n      GasPrices.nom == oil_type\n  ).subquery()\n```", "```py\nlast_price = session.query(\n    price_wanted_gas.c.station_id,\n    func.max(price_wanted_gas.c.maj).label(\"max_maj\")\n    ).group_by(price_wanted_gas.c.station_id) \\\n     .subquery()\n```", "```py\nlast_price_full = session.query(price_wanted_gas).join(\n    last_price,\n    and_(\n        price_wanted_gas.c.station_id == last_price.c.station_id,\n        price_wanted_gas.c.maj == last_price.c.max_maj\n    )\n).subquery()\n```", "```py\nstations_with_price = session.query(stations, last_price_full).join(\n    last_price_full,\n    stations.c.station_id == last_price_full.c.station_id\n).all()\n```", "```py\nprices = [float(e[\"valeur\"]) for e in stations_with_price]\navg_price = float(np.median(prices))\n\noutput = {\n    \"lat\": city.lat,\n    \"lon\": city.lon,\n    \"city\": pretify_address(city.name),\n    \"station_infos\": sorted([extend_dict(x, avg_price, city.lat, city.lon) for x in stations_with_price], key=lambda x: -(x['delta_average']))\n}\n\nreturn output\n```", "```py\nstations-project/\n  |-- db/\n  |-- api/\n    |-- app/\n    |-- requirements.txt\n    |-- Dockerfile\n  |-- update_scripts/\n  |-- front/\n  |-- docker-compose.yml\n```", "```py\nFROM python:3.9\n\nWORKDIR /code\n\nCOPY ./requirements.txt /code/requirements.txt\n\nCOPY ./app /code/app\n\nRUN pip install --no-cache-dir -r requirements.txt\n\nEXPOSE 80\n\nCMD [\"uvicorn\", \"app.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"80\"]\n```", "```py\nfastapi==0.94.0\nGeoAlchemy2==0.13.1\nnumpy==1.24.2\nSQLAlchemy==1.4.41\nsqlmodel==0.0.8\nuvicorn==0.20.0\npsycopg2==2.9.5\n```", "```py\ndocker build -t fast-api-stations .\n```", "```py\nversion: \"3\"\n\nservices:\n  fastapi:\n    image: fast-api-stations\n    ports:\n      - \"8000:80\"\n\n  stationdb:\n    image: postgis/postgis\n    environment:\n      POSTGRES_USER: jkaub\n      POSTGRES_PASSWORD: jkaub\n      POSTGRES_DB: stations\n    volumes:\n      - ./db:/var/lib/postgresql/data\n```", "```py\nDATABASE_URL = 'postgresql://jkaub:jkaub@stationdb/stations'\n```", "```py\ndocker-compose up\n```", "```py\nhttp://localhost:8000/docs\n```"]