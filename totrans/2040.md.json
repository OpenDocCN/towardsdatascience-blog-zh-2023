["```py\npip install gravis\n```", "```py\npip install numpy, matplotlib, networkx\n```", "```py\ndef get_new_test_graph():\n    NUM_NODES = 50\n    p = 0.5\n    seed = 1\n    test_graph = nx.dual_barabasi_albert_graph(n=NUM_NODES, p=p, seed=seed, m1=2, m2=1)\n\n    # add node properties\n    nx.set_node_attributes(test_graph, dict(test_graph.degree()), name='degree')\n    nx.set_node_attributes(test_graph, nx.betweenness_centrality(test_graph), name='betweenness_centrality')\n\n    for node, data in test_graph.nodes(data=True):\n        data['node_identifier'] = str(uuid.uuid4())\n        data['feature1'] = np.random.random()\n        data['feature2'] = np.random.randint(0, high=100)\n        data['feature3'] = 1 if np.random.random() > 0.5 else 0\n\n    # add edge properties\n    for _, _, data in test_graph.edges(data=True):\n        data['feature1'] = np.random.random()\n        data['feature2'] = np.random.randint(0, high=100)\n\n    return test_graph\n```", "```py\ntest_graph = get_new_test_graph()\nnx.draw(test_graph)\n```", "```py\nimport gravis as gv \n\ngv.d3(\n    test_graph, \n\n    # graph specs\n    graph_height=500,\n\n    # node specs\n    node_size_data_source=\"betweenness_centrality\",\n    use_node_size_normalization=True,\n    node_size_normalization_min=15,\n    node_size_normalization_max=35,\n    show_node_label=True,\n    node_label_data_source='node_identifier',\n\n    # edge specs\n    edge_size_data_source='feature1',\n    use_edge_size_normalization=True,\n    edge_size_normalization_min=1,\n    edge_size_normalization_max=5,\n\n    # force-directed graph specs\n    many_body_force_strength=-500\n)\n```", "```py\n # node specs\n    node_size_data_source=\"betweenness_centrality\",\n    use_node_size_normalization=True,\n    node_size_normalization_min=15,\n    node_size_normalization_max=35,\n```", "```py\n # edge specs\n    edge_size_data_source='feature1',\n    use_edge_size_normalization=True,\n    edge_size_normalization_min=1,\n    edge_size_normalization_max=5,\n```", "```py\nclass MplColorHelper:\n\n    def __init__(self, cmap_name, start_val, stop_val):\n        self.cmap_name = cmap_name\n        self.cmap = plt.get_cmap(cmap_name)\n        self.norm = mpl.colors.Normalize(vmin=start_val, vmax=stop_val)\n        self.scalarMap = cm.ScalarMappable(norm=self.norm, cmap=self.cmap)\n\n    def get_rgba(self, val):\n        return self.scalarMap.to_rgba(val, bytes=True)\n\n    def get_rgb_str(self, val):\n        r, g, b, a = self.get_rgba(val)\n        return f\"rgb({r},{g},{b})\"\n```", "```py\n# the matplotlib colourmap we want to use\nCM_NAME = \"winter\"\n\n# initialise colour helper\nvals = nx.get_node_attributes(test_graph, 'betweenness_centrality').values()\nbetweenness_min, betweenness_max = min(vals), max(vals)\nnode_colors = MplColorHelper(CM_NAME, betweenness_min, betweenness_max)\n\n# get rgb string for each node\nfor node, data in test_graph.nodes(data=True):\n    data['color'] = node_colors.get_rgb_str(data['betweenness_centrality'])\n```", "```py\n# initialise colour helper \nvals = nx.get_edge_attributes(test_graph, 'feature1').values()\nval_min, val_max = min(vals), max(vals)\nedge_colors = MplColorHelper(CM_NAME, val_min, val_max)\n\n# get rgb string for each node\nfor u, v, data in test_graph.edges(data=True):\n    data['color'] = edge_colors.get_rgb_str(data['feature1'])\n```", "```py\n# node features\nfor node, data in test_graph.nodes(data=True):\n    data['click'] = (\n        f\"Node: {data['node_identifier']}\"\n        \"\\nNode Features:\" +\n        f\"\\nfeature 1: {data['feature1']:.3f}\" + \n        f\"\\nfeature 2: {data['feature2']:.3f}\" + \n        f\"\\nfeature 3: {data['feature3']:.3f}\" + \n        f\"\\nBetweenness Centrality: {data['betweenness_centrality']:.3f}\" + \n        f\"\\nDegree: {data['degree']}\"\n    )\n\n# edge features\nfor u, v, data in test_graph.edges(data=True):\n  data['click'] = (\n        f\"Edge: {test_graph.nodes[u]['node_identifier']} -> {test_graph.nodes[v]['node_identifier']}\" +\n        f\"\\nEdge Features:\" + \n        f\"\\nfeature 1: {data['feature1']}\" + \n        f\"\\nfeature 2: {data['feature2']}\"\n    )\n```", "```py\nfig = gv.d3(test_graph, *args, **kwargs)\nfig.export_html(\"graph_to_export.html\")\n```", "```py\ndef get_new_test_digraph():\n    NUM_NODES = 50\n    # We change the graph generator function here\n    test_graph = nx.scale_free_graph(n=NUM_NODES, seed=0, alpha=0.5, beta=0.2, gamma=0.3)\n\n    # add node properties\n    nx.set_node_attributes(test_graph, dict(test_graph.degree()), name='degree')\n    nx.set_node_attributes(test_graph, nx.betweenness_centrality(test_graph), name='betweenness_centrality')\n\n    for node, data in test_graph.nodes(data=True):\n\n        # assign node type so we have heterogeneous graph\n        data['node_type'] = 0 if node < 25 else 1\n\n        # same as before, a add ther node features.\n        data['node_identifier'] = str(uuid.uuid4())\n        data['feature1'] = np.random.random()\n        data['feature2'] = np.random.randint(0, high=100)\n        data['feature3'] = 1 if np.random.random() > 0.5 else 0\n\n    # add edge properties\n    for u, v, data in test_graph.edges(data=True):\n        data['feature1'] = np.random.random()\n        data['feature2'] = np.random.randint(0, high=100)\n\n    return test_graph\n```", "```py\nfor node, data in test_graph.nodes(data=True):\n\n    data['node_type'] = 0 if node < 25 else 1 # add this line \n```", "```py\nfor node, data in test_graph.nodes(data=True):\n    data['value'] = data['betweenness_centrality'] # node size\n    data['label'] = data['node_identifier'] \n    data['title'] = (\n        f\"Node: {data['node_identifier']}\"\n        \"\\nNode Features:\" +\n        f\"\\nfeature 1: {data['feature1']}\" + \n        f\"\\nfeature 2: {data['feature2']}\" + \n        f\"\\nfeature 3: {data['feature3']}\" + \n        f\"\\nBetweenness Centrality: {data['betweenness_centrality']}\" + \n        f\"\\nDegree: {data['degree']}\"\n    ) \n    data['color'] = node_colors.get_rgb_str(data['betweenness_centrality'])\n\n    ## add this line to specify shape. \n    data['shape'] = 'dot' if data['node_type'] == 0 else 'rectangle'\n```", "```py\n gv.d3(\n    test_graph, \n\n    graph_height=700,\n\n    node_size_data_source=\"betweenness_centrality\",\n    use_node_size_normalization=True,\n    node_size_normalization_min=15,\n    node_size_normalization_max=35,\n    show_node_label=False,\n    node_label_data_source='node_identifier',\n\n    edge_size_data_source='feature1',\n    use_edge_size_normalization=True,\n    edge_size_normalization_min=1,\n    edge_size_normalization_max=5,\n\n    # Specify curvature to differentiate between the multiple\n    # edges between two nodes.\n    edge_curvature=-0.5,\n\n    many_body_force_strength=-500\n)\n```"]