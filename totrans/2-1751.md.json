["```py\nsongPopularity = pd.read_csv(‘./data/song_data.csv’)\n```", "```py\nfeatures = ['song_duration_ms', \n            'acousticness', 'danceability', \n            'energy', 'instrumentalness', \n            'key', 'liveness', 'loudness', \n            'audio_mode', 'speechiness', \n            'tempo', 'time_signature', 'audio_valence']\n\ntarget = 'song_popularity'\n\nsongPopularityFeatures = songPopularity[features]\nsongPopularityTarget = songPopularity[target]\n```", "```py\nX_train, X_test, y_train, y_test = train_test_split(songPopularityFeatures, songPopularityTarget, test_size = 0.2)\n```", "```py\nimport torch\n\ndef dataframe_to_tensor(df):\n    return torch.tensor(df.values, dtype=torch.float32)\n\n# Transform DataFrames into PyTorch tensors using the function\nX_train = dataframe_to_tensor(X_train)\nX_test = dataframe_to_tensor(X_test)\ny_train = dataframe_to_tensor(y_train)\ny_test = dataframe_to_tensor(y_test)\n```", "```py\nfrom torch import nn\n\nclass LinearRegressionModel(nn.Module):\n    '''\n    Torch Module class.\n    Initializes weight randomly and gets trained via train method.\n    '''\n    def __init__(self, optimizer):\n        super().__init__()\n        self.optimizer = optimizer\n\n        # Initialize Weights and Bias\n        self.weights = nn.Parameter(\n            torch.randn(1, 5, dtype=torch.float),\n            requires_grad=True)\n\n        self.bias = nn.Parameter(\n            torch.randn(1, 5, dtype=torch.float),\n            requires_grad=True\n            )\n```", "```py\nself.weights = nn.Parameter(\n torch.randn(1, 13, dtype=torch.float),\n requires_grad=True)\n\nself.bias = nn.Parameter(\n            torch.randn(1, dtype=torch.float),\n            requires_grad=True\n            )\n```", "```py\ndef forward(self, x: torch.Tensor) -> torch.Tensor:\n        return (self.weights * x + self.bias).sum(axis=1)\n```", "```py\n def trainModel(\n            self,\n            epochs: int,\n            X_train: torch.Tensor,\n            X_test: torch.Tensor,\n            y_train: torch.Tensor,\n            y_test: torch.Tensor,\n            lr: float\n            ):\n        '''\n        Trains linear model using pytorch.\n        Evaluates the model against test set for every epoch.\n        '''\n        torch.manual_seed(42)\n        # Create empty loss lists to track values\n        self.train_loss_values = []\n        self.test_loss_values = []\n\n        loss_fn = nn.L1Loss()\n\n        if self.optimizer == 'SGD':\n            optimizer = torch.optim.SGD(\n                params=self.parameters(),\n                lr=lr\n                )\n        elif self.optimizer == 'Adam':\n            optimizer = torch.optim.Adam(\n                params=self.parameters(),\n                lr=lr\n                )\n\n        for epoch in range(epochs):\n            self.train()\n            y_pred = self(X_train)\n            loss = loss_fn(y_pred, y_train)\n            optimizer.zero_grad()\n            loss.backward()\n            optimizer.step()\n\n            # Set the model in evaluation mode\n            self.eval()\n            with torch.inference_mode():\n                self.evaluate(X_test, y_test, epoch, loss_fn, loss)\n```", "```py\nself.train()\ny_pred = self(X_train)\nloss = loss_fn(y_pred, y_train)\noptimizer.zero_grad()\nloss.backward()\noptimizer.step()\n```", "```py\ndef evaluate(self, X_test, y_test, epoch_nb, loss_fn, train_loss):\n        '''\n        Evaluates current epoch performance on the test set.\n        '''\n        test_pred = self(X_test)\n        test_loss = loss_fn(test_pred, y_test.type(torch.float))\n        if epoch_nb % 10 == 0:\n            self.train_loss_values.append(train_loss.detach().numpy())\n            self.test_loss_values.append(test_loss.detach().numpy())\n            print(f\"Epoch: {epoch_nb} - MAE Train Loss: {train_loss} - MAE Test Loss: {test_loss} \")\n```", "```py\nadam_model = LinearRegressionModel('Adam')\n\nadam_model.trainModel(200, X_train, X_test, y_train, y_test, 0.001)\n```", "```py\nsgd_model = LinearRegressionModel(‘SGD’)\nsgd_model.trainModel(500, X_train, X_test, y_train, y_test, 0.001)\n```"]