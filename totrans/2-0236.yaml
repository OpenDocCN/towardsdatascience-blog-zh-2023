- en: A step-by-step guide to develop a map-based application (Part I)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/a-step-by-step-guide-to-develop-a-map-based-application-part-i-757766b04f77](https://towardsdatascience.com/a-step-by-step-guide-to-develop-a-map-based-application-part-i-757766b04f77)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The proof-of-concept — Build a minimalist demo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@jacky.kaub?source=post_page-----757766b04f77--------------------------------)[![Jacky
    Kaub](../Images/e66c699ee5a9d5bbd58a1a72d688234a.png)](https://medium.com/@jacky.kaub?source=post_page-----757766b04f77--------------------------------)[](https://towardsdatascience.com/?source=post_page-----757766b04f77--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----757766b04f77--------------------------------)
    [Jacky Kaub](https://medium.com/@jacky.kaub?source=post_page-----757766b04f77--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----757766b04f77--------------------------------)
    ·19 min read·Jan 24, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c4b4a0fc6043af44431cec2c84ae5ec0.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [GeoJango Maps](https://unsplash.com/@geojango_maps?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Maps are a powerful tool for visualizing and understanding geographic data but
    they need specific skills to be designed efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: In this step-by-step guide, we are going to take a deep dive into building a
    map-based application to show the customers prices of gas stations around them.
    We will cover the different key steps of a product, from original proof of concept
    (POC) to the minimum viable product (MVP)
  prefs: []
  type: TYPE_NORMAL
- en: 'Articles of the series:'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Part I: The proof-of-concept — Build a minimalist demo'
  prefs: []
  type: TYPE_NORMAL
- en: '[Part II: How to use React to build web apps (Static Layout)](/a-step-by-step-guide-to-develop-a-map-based-application-part-ii-6d3fa7dbd8b9)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Part III: Add Interactivity to your webapps with React](/a-step-by-step-guide-to-develop-a-map-based-application-part-iii-ad501c4aa35b)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Part IV: Build a back-end with PostgreSQL, FastAPI, and Docker](https://medium.com/towards-data-science/build-a-back-end-with-postgresql-fastapi-and-docker-7ebfe59e4f06)'
  prefs: []
  type: TYPE_NORMAL
- en: What this article covers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this article, the first of the series, we are preparing the proof of concept
    of our application.
  prefs: []
  type: TYPE_NORMAL
- en: We just got an idea that we would like to turn into something valuable but we
    don’t know yet if this is feasible. We need to look for data, evaluate their relevance
    and build something basic that will demonstrate if the original idea is feasible.
  prefs: []
  type: TYPE_NORMAL
- en: Also, and more than everything, we need to demonstrate to deciders (that are
    not necessarily technical people) that the project can be valuable.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3f462e024b926f4473e0fa64d13a86ec.png)'
  prefs: []
  type: TYPE_IMG
- en: From POC to MVP, Author Illustration
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, due to the specificity of that particular project, we will see
    in this article the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to parse a .xml file into tabular data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filter and combine DataFrames based on distances between points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a basic map with plotly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add interactions to the map with ipywidgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the article, we will have an interactive map that could be presented
    for POC demos before deciding to go further on product development.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2bb40a987b30833a48970e5b9573fde1.png)'
  prefs: []
  type: TYPE_IMG
- en: Illustration of the product at the end of the POC phase, Author Illustration
  prefs: []
  type: TYPE_NORMAL
- en: The complete code of this whole POC is available in [my github](https://github.com/jkaub/fuel-station-viewer-poc).
  prefs: []
  type: TYPE_NORMAL
- en: A bit of context around the app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the current economic situation, we observe high volatility of gas prices
    in the stations. We also see — at least where I come from in France — shortages
    driven by strikes and some malicious station owners taking the opportunity of
    this to increase their prices to overly high levels. With this in mind, prices
    at the stations can become an important criterion for many people who need to
    refill.
  prefs: []
  type: TYPE_NORMAL
- en: 'The good news is: in France, real-time gas station prices are accessible through
    the open data policy implemented in the country. The data, in its raw format,
    is not of interest to many as not understandable instantaneously. Instead, it
    would need to be made available and displayed via a proper user interface so the
    right information is filtered and understandable in an eye blink.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to build this user interface: a web app allowing users to retrieve
    oil prices for stations around them. I am focusing here on the french market (because
    the data is open publicly and easy to access), but our work will be easily reproducible
    for other types of data anywhere in the world.'
  prefs: []
  type: TYPE_NORMAL
- en: A quick word about the datasets used
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In its politic of open data, France maintains many datasets in free access.
    In particular, we are going to use the [Fuel prices in France — Instant flow Dataset](https://www.data.gouv.fr/fr/datasets/prix-des-carburants-en-france-flux-instantane/)
    under [*Open Licence V2*](https://www.etalab.gouv.fr/wp-content/uploads/2018/11/open-licence.pdf)
    and can be reused for commercial purposes.
  prefs: []
  type: TYPE_NORMAL
- en: We are also going to use the [Communal Administrative division API](https://geo.api.gouv.fr/decoupage-administratif/communes)
    for information relative to cities, also under [*Open Licence V2*](https://www.etalab.gouv.fr/wp-content/uploads/2018/11/open-licence.pdf)*.*
  prefs: []
  type: TYPE_NORMAL
- en: Access the data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our adventure starts here: navigating in the jungle of open data, we found
    this interesting dataset about gas prices. We don’t know yet what it looks like
    and what data it contains.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple files are available for download as illustrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e4cff22b555f376ee41d94203d0ab25b.png)'
  prefs: []
  type: TYPE_IMG
- en: A translated version of the page containing the datasets, Author Illustration
  prefs: []
  type: TYPE_NORMAL
- en: 'The first mistake to avoid here is to overflow our project with too much data:
    it is not because it is available that we need it.'
  prefs: []
  type: TYPE_NORMAL
- en: Here, typically, we only want to demonstrate the possibility of showing the
    “instant” prices to users, we don’t aim at making a historical prices analysis.
    Thus, exploring historical data will be, at least for now, a waste of time and
    we are going to focus only on the instantaneous flow datasets.
  prefs: []
  type: TYPE_NORMAL
- en: '*Time is a precious resource, and many ideas will never turn into actual products.
    It is important to be efficient and make sure we focus only on the concept we
    want to showcase.*'
  prefs: []
  type: TYPE_NORMAL
- en: According to the documentation, the dataset contains information such as addresses,
    postal codes, coordinates, and prices, among with other information less useful
    for the POC (like other services proposed).
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving the data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The instant data feed can be retrieved via a download link which will download
    a zip file containing a file locally in your computer.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://donnees.roulez-eco.fr/opendata/instantane](https://donnees.roulez-eco.fr/opendata/instantane)'
  prefs: []
  type: TYPE_NORMAL
- en: This is nice, but even if we are in the POC phase we need to anticipate some
    of the constraints we will have later in the project that could be “killer”. In
    particular here, assuming we will update our data at least once a day, we don’t
    want the update to be done manually and we need to assess a way to access the
    data automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, we can load the zip directly in python combining **urllib** and **zipfile**
    libraries to perform operations on .zip files directly from an URL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Explore the .xml file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: XML is a markup language commonly used for data storage and data exchanges.
    Even if newer formats such as JSON tend to gain more and more popularity, XML
    remains used widely in many applications and industries and it is still relevant
    to have a sense of how it works.
  prefs: []
  type: TYPE_NORMAL
- en: A .xml file forms tree structures, that start at the “root” and branch to child
    elements. Each element has its own attributes and its possible own children.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a look at the file by opening it in a simple text editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first line of the file gives some metadata, such as the encoding used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here it says that to read the file, we need to use an ISO-8859–1 encoding, which
    will be useful when we will have to parse the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The .xml is then composed of different elements with multiple levels of depths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here the pdv element represents our oil station. Inside the tag, there is several
    parameters which are the attributes of the element (id, latitude, longitude, postal
    code…)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Each pdv has also multiple children:'
  prefs: []
  type: TYPE_NORMAL
- en: 'adresse: the address of the station'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ville: the city of the station'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'horaires: the hours of openings of the station'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'services: representing extra services provided such as car wash, ATM, etc…'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'prix: the price of each fuel type (available as attributes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This data structure can be represented by the tree below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9f2f85ad3b626e4c92380817627b367c.png)'
  prefs: []
  type: TYPE_IMG
- en: Data structure of our .xml, Author illustration
  prefs: []
  type: TYPE_NORMAL
- en: From .xml to tabular data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This tree data structure is not fitted for easy manipulations and we want to
    parse it to a tabular version, which will be more convenient for later filtering
    and aggregation operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To store the data efficiently, we will create two tables:'
  prefs: []
  type: TYPE_NORMAL
- en: A table to represent oil stations and their metadata (address, city, etc…)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A table to represent fuels, their stations, and their prices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use a tool such as [https://dbdiagram.io/](https://dbdiagram.io/) to
    design your data structure.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6dc962abf8fdbff8b32eb921545a3143.png)'
  prefs: []
  type: TYPE_IMG
- en: Sample view of the data structure, Author illustration
  prefs: []
  type: TYPE_NORMAL
- en: In this POC phase, we will not set up a SQL server and simply store the data
    in memory in pandas DataFrames to go fast. We could also store it locally in a
    .csv as a starting point, but the file is light, so no need to go there for now.
  prefs: []
  type: TYPE_NORMAL
- en: When we will explore the MVP of the app, we will set up the database in a cleaner
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing the .xml file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point we know the data structure we want to reach, we just have to parse
    the file properly.
  prefs: []
  type: TYPE_NORMAL
- en: Before going further, I want to raise your attention to the fact that you should
    be particularly careful when using automated parsers as they could potentially
    dismiss part of the data available in the file.
  prefs: []
  type: TYPE_NORMAL
- en: For example, using the built-in pandas.read_xml() method, without any specific
    tuning, would return an incomplete DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The code above would result in the DataFrame below, where most of the information
    is missing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b3fab0dadf81889dfa9ed4b0436bdecb.png)'
  prefs: []
  type: TYPE_IMG
- en: Parsing quickly with pd.read_xml and default parameters don’t produce the relevant
    result
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we are going to code our own data extractor, which will give us the
    opportunity to review recursive functions and is based on the python **xml** library.
  prefs: []
  type: TYPE_NORMAL
- en: '*Note: Even if we are in the POC, it is important to make the effort of keeping
    a clean code structure. We are going to build a proper set of functions for the
    data loading module that could be re-used with very few adaptations later in the
    process. It doesn’t cost extra time, but it will save a lot of work for the MVP.*'
  prefs: []
  type: TYPE_NORMAL
- en: To parse properly the file we use the **xml** library. Let’s start by accessing
    our root element, *pdv_list*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The root variable contains the element pdv_list
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And the children elements can be simply accessed by iteration (in our case
    each child will be an element “pdv”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In order to handle the data whatever the order, we will create a station dictionary
    that will contain all the metadata that we want to keep for our “stations” table
    as well as an oil_type dictionary for our “oil_type” dataset.
  prefs: []
  type: TYPE_NORMAL
- en: To keep things clean, depending on the level of complexity of each node we will
    design custom functions. The code below illustrates how our custom parser work.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This set of functions will return those two DataFrames and should be relatively
    easy to modify in the future if we want to use SQL tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b13f95130db7436f8ea5db182bdd8429.png)'
  prefs: []
  type: TYPE_IMG
- en: Sample DataFrame for the oil_type, Author Illustration
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/687a0cd1082bed5369df37166a8f5ccf.png)'
  prefs: []
  type: TYPE_IMG
- en: Sample DataFrame for the stations, Author Illustration
  prefs: []
  type: TYPE_NORMAL
- en: Filter functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At that point, we have latitudes, longitudes, and prices for all the stations.
    We don’t want to show everything to the users, only the stations proposing relevant
    gas types around them.
  prefs: []
  type: TYPE_NORMAL
- en: In the coming part, we will develop all the functions to go from the raw datasets
    to the filtered ones.
  prefs: []
  type: TYPE_NORMAL
- en: Calculate the distance between two points from lat/lon coordinates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Latitudes and Longitudes are expressed in degrees, and as the distance is calculated
    on the surface of the globe, simple Euclidean geometry cannot be applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'To calculate the distance between two points, we are going to use the [Haversine
    formula](https://en.wikipedia.org/wiki/Haversine_formula):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Whether the function comes from you or another developer, don’t forget to test
    it to verify that the resulting output is correct.
  prefs: []
  type: TYPE_NORMAL
- en: In my case, I am verifying using the Google Earth distance feature and checking
    the distance between two cities for which I know latitude and longitude, and confirming
    the function returns the expected output.
  prefs: []
  type: TYPE_NORMAL
- en: Filter the dataset based on a point identified with lat/lon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can now create a function that filters the station dataset based on the haversine_distance
    from a source lat/lon.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: I tested the function around my place to check that I retrieve well the stations
    available around, which is well the case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/1084c1ff11d6fe24ab0b58297ce7d4c5.png)'
  prefs: []
  type: TYPE_IMG
- en: Sample dataset filtered around my village, Author Illustration
  prefs: []
  type: TYPE_NORMAL
- en: Filter by gas type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A user will be only interested in the stations selling the type of gas used
    in his car. We can now perform a join between station_id and our gas types to
    retrieve and filter the rows by gas type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/b2fd4e0c1246c92bbc10809ce336336c.png)'
  prefs: []
  type: TYPE_IMG
- en: Illustration of the results after applying the filter_dataset_by_gas_type, showing
    only some relevant columns. Author Illustration
  prefs: []
  type: TYPE_NORMAL
- en: Getting coordinates and postal codes of french cities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What we have now is not bad but not enough: we don’t want our users to write
    themselves the latitude and longitude of their location which is not something
    accessible easily.'
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we want a feature to get the lat/lon as easily as possible. There is
    many ways of doing this and many API ( like Google Map API ) provide already information
    accessible at different degree of complexity (and different degree of prices…).
    For a POC we want to stay simple, so we are just going to look for a dataset with
    coordinates of city centers based on their postal codes.
  prefs: []
  type: TYPE_NORMAL
- en: '*Note: We have a dataset of stations that includes information about coordinates
    and postal codes, but it is limited to only cities that have gas stations. We
    aim to make the dataset as comprehensive as possible.*'
  prefs: []
  type: TYPE_NORMAL
- en: After a bit of research, I figured out another open dataset to use, accessible
    via an API that allows us to quickly retrieve exactly what we need. As mentioned
    in the introduction, those data are also under an open license and can be used
    freely.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/93d8d26d117f73cd064449674249057c.png)'
  prefs: []
  type: TYPE_IMG
- en: Sample DataFrame for our cities_df, Author Illustration
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now develop our final brick: a function that will take as input 3 parameters
    (a postal code, a distance, and a type of gas) and that will return the prices
    of gas stations around (I’ll assume for now stations_df, cities_df, and gas_type_df
    as a global variable, but I’ll package everything properly in a class at the end
    of the article).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Tested again on my city (note there is one more station here, probably due
    to a slight difference in the lat/lon from the postal_code -> lat/lon):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/fd99711201975aa4909678d4198c9336.png)'
  prefs: []
  type: TYPE_IMG
- en: CP dataset sample, Author Illustration
  prefs: []
  type: TYPE_NORMAL
- en: 'There is something also important to note here: while gas types will be accessible
    via a finite dropdown list, it is the user’s responsibility to write a correct
    postal code. If the postal code is not correct, the sub_cities DataFrame will
    be empty, and accessing its first element will raise an error.'
  prefs: []
  type: TYPE_NORMAL
- en: We prefer to handle this case by catching the error with our own custom Exception,
    which will be easier to integrate later in the MVP.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Using a postal code with the wrong format or with a value not in our database
    will generate this error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/dfa7151fd1bf0bf803c45a383d88a783.png)'
  prefs: []
  type: TYPE_IMG
- en: Illustration of our custom exception, Author Illustration
  prefs: []
  type: TYPE_NORMAL
- en: Build a simple demonstrator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, so good, we demonstrated the possibility to access quickly the relevant
    information in the database by simply using a postal code, a distance, and a fuel
    type.
  prefs: []
  type: TYPE_NORMAL
- en: We are still using some python functions here which might be ugly to show to
    the management or to investors. To prove to them that it is worth pushing the
    project forward in the next stage of development, we want to integrate this in
    a small demonstrator.
  prefs: []
  type: TYPE_NORMAL
- en: We could create a small dashboard that runs locally using **plotly** and **dash**
    but the fastest way would be to simply [create a small widget in a notebook](https://medium.com/@jacky.kaub/build-custom-widgets-with-ipywidgets-and-plotly-a454cb3b2b4f).
    A more advanced dashboard will be then demonstrated during the prototyping phase.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a map in a notebook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are multiple ways to display a map in a Jupyter Notebook, like the excellent
    **folium** library (check [this post](https://medium.com/datasciencearth/map-visualization-with-folium-d1403771717)
    if you want more info about the lib).
  prefs: []
  type: TYPE_NORMAL
- en: In my case, I prefer to use plotly in anticipation ofthe next stages of development
    where we will embed the [plotly map](https://plotly.com/python/maps/) directly
    in our User Interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part is very important in our development: it has to give a “wow” feeling
    to people to who you will demonstrate if you want a chance to reach later stages
    of development. You might have the best idea in the world, but if the package
    is ugly, people won’t buy it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make something clean, this is the information we want to display in our
    map:'
  prefs: []
  type: TYPE_NORMAL
- en: The coordinate of the center of the city used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A transparent circle showing the perimeter of the research
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The coordinates of the stations providing the type of fuel requested
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more clarity, we are also going to map the color of the station to the deviation
    of the price from the average
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A simple map with Scattermapbox
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Plotly has an integration of [Mapbox GL JS](https://www.mapbox.com/), allowing
    us to build a [tiled-base map](https://en.wikipedia.org/wiki/Tiled_web_map) that
    will handle operations such as navigation in the map and zooms without using excessive
    CPU resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build a map we need two ingredients:'
  prefs: []
  type: TYPE_NORMAL
- en: A trace containing the data to visualize and compatible with maps (here go.Scattermapbox)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A layout, including a map layer. This is done by specifying a Mapbox dictionary.
    Note: you will need a free Mapbox token to access the Mapbox tiles used for the
    map background.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The example below shows a simple map (we use FigureWidget rather than Figure
    to integrate later this map directly in our widget)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This code, when applied to our pre-filtered dataset, will result in :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6eb00fad5431b7490d3bee2b88cac995.png)'
  prefs: []
  type: TYPE_IMG
- en: Output from the plotly map, Author Illustration
  prefs: []
  type: TYPE_NORMAL
- en: Not very fancy yet, but it’s a good start.
  prefs: []
  type: TYPE_NORMAL
- en: Adding price indicators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can simply add other traces to our map to add more information to our base
    map.
  prefs: []
  type: TYPE_NORMAL
- en: As it is not possible to change directly the color of the icons, we are going
    to add an extra ScatterMapBox with circle points for which we can modify the color.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/174ddfc59c4aa73589120b6c8506e63f.png)'
  prefs: []
  type: TYPE_IMG
- en: Output from the plotly map with price mapped, Author Illustration
  prefs: []
  type: TYPE_NORMAL
- en: Don’t underestimate the importance of the color map you chose. There are multiple
    ways in which you can represent information and the message will not be necessarily
    the same. We are using here a [divergence colormap](https://www.kennethmoreland.com/color-maps/),
    which is good for showing the relative difference of price from the average of
    the sample. I also leverage a classic human bias that associate red tones with
    something bad (here high prices) and green with something good (low prices).
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example this is the result obtained with the default colormap:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a38e7b95170f11fcba8a4ba323ff2480.png)'
  prefs: []
  type: TYPE_IMG
- en: An example NOT to follow about mapping color to prices, , Author Illustration
  prefs: []
  type: TYPE_NORMAL
- en: Add the position of the user and the research perimeter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adding the position of the user is the simplest part, we can just add a red
    dot that will symbolize the center posi**t**ion of the research.
  prefs: []
  type: TYPE_NORMAL
- en: The research perimeter is a bit more complicated. We will represent the circle
    using another Scattermapbox with latitudes and longitudes at the edge of the circle.
    To do so, we need first a function to calculate, from a coordinate and a radius,
    the coordinates of the perimeter of the circle.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We can now generate a list of points, and add them as a new trace to our graph.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/a84e4ff8fb1971685dc01cbebc232af9.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding the research parameter area and the position of the user, Author Illustration
  prefs: []
  type: TYPE_NORMAL
- en: Final packaging in a widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are almost done with our demonstrator, we just need to add a bit of interactivity.
    To do so, I am going to package everything we did so far and include 3 components
    to control the type of fuel, the distance of research, and the postal code.
  prefs: []
  type: TYPE_NORMAL
- en: I will skip the full packaging, I am only putting everything we saw so far in
    a general class to handle the different states. If you are not familiar with interactive
    notebook using **ipywidgets**, you can check [this list of article](https://medium.com/@jacky.kaub/list/jupyter-notebook-widgets-bad265ffc7bf)s.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The callbacks will all do the same thing: observe a change, update the filtered
    dataset, and update the figure. For example, here is the _on_distance callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Finally, let’s have a look at the method to update the figure. Once the dataset
    is filtered, we are generating a new figure and update the key elements of our
    current figure with the new traces generated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: And that’s it! We can just add a “public” method display that will be called
    in the notebook to display the widget, and our demo is now ready to be shown.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/2bb40a987b30833a48970e5b9573fde1.png)'
  prefs: []
  type: TYPE_IMG
- en: Our POC demo in action, Author Illustration
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This last chapter concludes the first part of our product development, aka the
    Proof of Concept.
  prefs: []
  type: TYPE_NORMAL
- en: We built step by step the first demo that we can use to demonstrate the potential
    of our idea. This demo, done in a small amount of time, is still minimalist and
    we will have to develop the concept further in the next development phase, the
    Prototyping.
  prefs: []
  type: TYPE_NORMAL
- en: In that next phase of development, we will modify this minimalist widget to
    make it a real web application with more features and usable locally on your computer.
  prefs: []
  type: TYPE_NORMAL
