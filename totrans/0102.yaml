- en: 5 easy Python features you can start using today to write better code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://towardsdatascience.com/5-easy-python-features-you-can-start-using-today-to-write-better-code-b62e21190633](https://towardsdatascience.com/5-easy-python-features-you-can-start-using-today-to-write-better-code-b62e21190633)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I‚Äôve been using Python for 8+ years. Here are a few Python features I love,
    which makes your code refreshing and efficient.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://thushv89.medium.com/?source=post_page-----b62e21190633--------------------------------)[![Thushan
    Ganegedara](../Images/3fabfa37132f7d3a9e7679c3b8d7e061.png)](https://thushv89.medium.com/?source=post_page-----b62e21190633--------------------------------)[](https://towardsdatascience.com/?source=post_page-----b62e21190633--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----b62e21190633--------------------------------)
    [Thushan Ganegedara](https://thushv89.medium.com/?source=post_page-----b62e21190633--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ¬∑Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----b62e21190633--------------------------------)
    ¬∑7 min read¬∑Jul 19, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/41822c8a9c950dbeb77a5353e33dc731.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Chris Ried](https://unsplash.com/@cdr6934?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
    on [Unsplash](https://unsplash.com/photos/ieic5Tq8YMk?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
  prefs: []
  type: TYPE_NORMAL
- en: You have to admit, seeing a comment like ‚Äú*This is super clean* üòé‚Äù or ‚Äú*Didn‚Äôt
    know this could be done this way*‚Äù on your code or pull request fills you with
    a wonderful feeling. Personal experience has taught me, embracing good software
    engineering principles and making the most of the existing language functionality
    is the recipe for good code that others will feel grateful for.
  prefs: []
  type: TYPE_NORMAL
- en: As an MLE I use Python day in and day out. Python is a great option for ML practitioners
    due to its low barrier to entry combined with the massive ecosystem of scientific
    tooling.
  prefs: []
  type: TYPE_NORMAL
- en: This means that, an individual with little to no software engineering knowledge
    can quickly start using Python.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This last statement can be said in two different tones of voice; positive or
    negative (try it!).
  prefs: []
  type: TYPE_NORMAL
- en: It may look like it‚Äôs a blessing at first, but in the grand scheme of things,
    the lack of the confinements of software engineering principles (e.g. Types, Objects)
    dissuade the engineers (MLE) or scientists (DS/AS) from writing good code (Trust
    me, we already got a bad reputation among software engineers as not-so-good engineers).
    This inevitably leads to unreadable, unmaintainable and untestable spaghetti code
    in most cases. And worse, one-day it becomes some unsuspecting victim‚Äôs worst
    nightmare to reuse this evil code. And you may even see a domino effect, where
    code built on top of bad code leads to ‚Ä¶ more bad code. Ultimately, this could
    even lead to organizational headaches down the track.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom line is, doing something in Python is easy, but doing something the
    right way in Python is difficult. After 8+ years grappling with Python, I‚Äôm still
    learning different (and better) ways to improve my code. I‚Äôve been blessed with
    good software engineers that would constructively criticize my code, when I do
    things in inefficient manner. Count your blessings if you have the same support.
    Here, I‚Äôm going to share a few levers you can pull to take your Python skills
    to the next level.
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Dataclasses help to remove the clutter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Say you want to manage a list of students with their heights. You may use a
    list of tuples to do this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: But what if you want to add other attributes like the weight, grade and gender
    later on? There‚Äôs no possible way for you to use the above data structure without
    getting a headache and making tons of mistakes. You may use a dictionary, but
    still it‚Äôs clunky. A better solution is, using `dataclasses`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So much cleaner! Then you simply instantiate a bunch of `Student` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Then you can access attributes with, `students[0].name` like syntax. No more
    relying on obscure knowledge like, name is at `0th` position or using error-prone
    string keys (should you use a dictionary). There‚Äôs many other cool things you
    can do with `dataclasses`. Such as,
  prefs: []
  type: TYPE_NORMAL
- en: Make objects immutable (By using `@dataclasses.dataclass(frozen=True`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining getters and setters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use of the `dataclasses.field` for additional support for an attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert to a dictionary (`.asdict()`) or tuple (`.astuple()`) for serialization
    and for compatibility reasons.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can read more about `dataclasses` [here](https://docs.python.org/3/library/dataclasses.html).
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Compare in Python with style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reduction and sorting is such an important part of any machine learning project.
    You probably are using `min` , `max` or `sorted` functions on lists of simple
    data types e.g. `str`, `float`, etc. But did you know that there‚Äôs a neat trick
    that increases the purview of the problems that can be solved using these basic
    functions?
  prefs: []
  type: TYPE_NORMAL
- en: You can use `min` , `max` and `sorted` to solve problems creatively using a
    special argument called `key` . The key allows you to define the logic to extract
    a ‚Äú*comparison key*‚Äù from each item in your iterable.
  prefs: []
  type: TYPE_NORMAL
- en: Say you wanted to sort the following list of student heights,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Even cooler, say you had a `dataclasses.dataclass` instead of this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Looks slick. Perhaps you want to find the student with the maximum height.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Did you know that, you could even simulate the `argmax` operation in plain Python?
    For those who don‚Äôt know, the `argmax` gives the index of the maximum value in
    a list/array. Again such an imperative computation in lot of algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There‚Äôs been many occasions in my life where I was writing many lines of code,
    which I could‚Äôve achieved by simply paying more attention to the key.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Make defaultdict your default
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using dictionaries, there‚Äôs a handy variant of the standard dictionary
    that may make your life easier. Say you want to manage how stock prices changed
    over 3 years. Assume the original format is the following.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And you want to convert this to a dictionary. You can do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This gets the job done, no doubt. But here‚Äôs a more elegant version of the same
    code using `defaultdict`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Woah, the code is much cleaner this way. No more worrying about whether the
    value is already instantiated or not. And it really shows you know your Python
    and data structures.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Say ‚ÄúI do‚Äù to the itertools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`itertools` is a built-in Python library for performing advance iterating over
    data structures with easy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have had times in your life, where you want to iterate multiple lists
    to create a single list. In Python you might do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Would you believe that, with `itertools`, it is a one-liner?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Say you want to remove students that are less than 170cm tall. With `itertools`
    that‚Äôs another one liner.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There are many other useful functions such as `accumulate`, `islice`, `starmap`,
    etc. You can checkout more [here](https://docs.python.org/3/library/itertools.html).
    Use `itertools`, rather than reinventing the wheel that leads to unwieldy and
    inefficient code. By using `itertools` you get the added benefit of speed, as
    it has efficient CPython based implementation of its functionality underneath.
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Packing/Unpacking arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Packing and unpacking is achieved via the star (`*`) and double star (`**`)
    operators. The easiest way to understand this concept is using functions. You
    can define a function with packed arguments or unpacked arguments. Let‚Äôs say we
    define the following two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When calling `f1` you can only pass 3 parameters in, where `f2` can accept
    an arbitrary number of parameters, which are packed to a tuple `args`. So you‚Äôd
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: All of these would work. If you want dictionary, where the key is the argument
    and the value is the parameter passed, you use the double star operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To see how much better this is, here‚Äôs your alternative for writing `f2` would
    be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: That double parentheses is already giving me shivers! Using `*args` is much
    sweeter.
  prefs: []
  type: TYPE_NORMAL
- en: '`zip()` is a real-life function that accepts an arbitrary number of iterables.
    It creates several new lists by taking the first item of each iterable, the second
    item from each iterable and so on. For the following example, `zip()` lets you
    interchange between the two formats;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is a surprisingly common necessity when you work with data. Remember our
    student example above? Say we just needed the sorted list of student names. we
    can simply zip the tuples to two lists.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It‚Äôs bringing the layout of data from format 1 to format 2 and discarding the
    second list (as that will contain all the heights).
  prefs: []
  type: TYPE_NORMAL
- en: So, if you‚Äôre developing a function that needs to work with an arbitrary number
    of argument, use argument packing. It‚Äôs more elegant than passing a tuple or a
    dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Those are 5 things that you can do differently next time you write an ML model
    in Python. Sticking with good software engineering principles and language standards
    gives a common ground for a group of engineers and scientists to work cohesively
    and iterate rapidly. By choosing to become better software engineers, you‚Äôll also
    be lighting the way for your colleagues to do the same, which will enable friction-less
    collaborations among individuals and teams.
  prefs: []
  type: TYPE_NORMAL
- en: If you enjoyed this story, feel free [subscribe](https://thushv89.medium.com/membership)
    to Medium, and you will get notifications to fresh content from me, as well as
    unlock full access to thousands of engaging stories from other authors.
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://thushv89.medium.com/membership?source=post_page-----b62e21190633--------------------------------)
    [## Join Medium with my referral link - Thushan Ganegedara'
  prefs: []
  type: TYPE_NORMAL
- en: As a Medium member, a portion of your membership fee goes to writers you read,
    and you get full access to every story‚Ä¶
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: thushv89.medium.com](https://thushv89.medium.com/membership?source=post_page-----b62e21190633--------------------------------)
  prefs: []
  type: TYPE_NORMAL
