- en: Grover‚Äôs Quantum Search Algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://towardsdatascience.com/grovers-quantum-search-algorithm-54c427315768](https://towardsdatascience.com/grovers-quantum-search-algorithm-54c427315768)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Quantum Computing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A visual explanation of one of the first quantum algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@danjackho?source=post_page-----54c427315768--------------------------------)[![Dan
    Jackson](../Images/d7b923d6f0462d8226dd7ded7488ba9c.png)](https://medium.com/@danjackho?source=post_page-----54c427315768--------------------------------)[](https://towardsdatascience.com/?source=post_page-----54c427315768--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----54c427315768--------------------------------)
    [Dan Jackson](https://medium.com/@danjackho?source=post_page-----54c427315768--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ¬∑Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----54c427315768--------------------------------)
    ¬∑16 min read¬∑May 23, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7d2e92f1b38559616e6d4b40772d403a.png)'
  prefs: []
  type: TYPE_IMG
- en: Close-up image of an IBM cryostat refrigeration system for a quantum computer.
    Image by [IBM/Graham Carlow](https://newsroom.ibm.com/media-quantum-innovation?keywords=quantum&l=100).
  prefs: []
  type: TYPE_NORMAL
- en: G**rover‚Äôs algorithm** is one of the earliest proposed quantum algorithms to
    demonstrate a quantum advantage, in this case a quadratic ‚Äòspeed-up‚Äô, over its
    classical analogue. Developed by ***Lov Grover*** [1] in 1996, the algorithm was
    a breakthrough in the field of quantum computing, following in the tracks of similar
    algorithms such as [***Shor‚Äôs algorithm***](https://en.wikipedia.org/wiki/Shor%27s_algorithm)
    and the [***Deutsch-Jozsa algorithm***](https://en.wikipedia.org/wiki/Deutsch%E2%80%93Jozsa_algorithm).
    In this article, we‚Äôll visually explain how Grover‚Äôs algorithm works, and we‚Äôll
    mathematically show how it demonstrates a ***quantum ‚Äòspeed-up‚Äô*** over the best
    classical search algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: The Problem of Unstructured Searching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: However, first let‚Äôs introduce the problem that Grover‚Äôs algorithm addresses.
    Imagine we have access to an ***unstructured database***, or list, containing
    *N* ***elements***, each of which is represented by a ***unique n-bit string ID
    denoted*** *x*. The list can thus contain at most *N* = 2*‚Åø* elements. We are
    tasked with finding a particular ***‚Äúmarked‚Äù*** element from the database with
    a particular bit-string *x‚ÇÄ.*
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6d2900ce402d0dd3f417f0588c64f21b.png)'
  prefs: []
  type: TYPE_IMG
- en: Simplified diagram of an N-element database with the marked element shown in
    red. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: To find the marked element, we will have to ***query*** the database by requesting
    the ID number *x* of an element in the database and checking if it is equal to
    the target ID number *x‚ÇÄ.* In the unlikely case that it does then we have successfully
    found the marked element with a single query!
  prefs: []
  type: TYPE_NORMAL
- en: However, the queried element most likely will not match the target that we are
    looking for on the first try. Especially if the database contains many elements
    (i.e. *N* is large). Therefore, we will have to continue to query the database
    repeatedly until there is a match *x = x‚ÇÄ* and we successfully find the target
    element.
  prefs: []
  type: TYPE_NORMAL
- en: '***Note:*** *When ‚Äòchecking‚Äô the ID number of an element we do not know what
    the target ID x‚ÇÄ is. We just have some method of determining if the queried ID
    number x is equal to x‚ÇÄ. Thus, ‚Äòfinding the marked element‚Äô is also equivalent
    to determining what x‚ÇÄ actually is.*'
  prefs: []
  type: TYPE_NORMAL
- en: Classical Unstructured Search Algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To ‚Äúcheck‚Äù the ID number *x* of a certain element suppose we have access to
    a ***function* *f(x)*** which takes in an *n*-bit string *x* and ***outputs***
    ***‚Äò0‚Äô*** if it is not equal to the target bit-string, and ***outputs ‚Äò1‚Äô*** if
    it is. Since we have no knowledge of what the target bit-string *x‚ÇÄ* actually
    is, the function is described as a ***black-box function***. We can define this
    function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3f9513ca48b3f842541006bbd368d419.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, to find the marked element we iteratively query each element in the database
    and apply *f(x)* to check if it‚Äôs the target.
  prefs: []
  type: TYPE_NORMAL
- en: In the ***best-case scenario,*** we find the target after a single query.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the ***worst-case scenario,*** we must query the database *N* times, i.e.
    we must query each element in the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***On average,*** we must make *N/2* queries to find the marked element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In general, we can say that if we make ***k distinct queries*** to the database
    the ***probability of finding the marked element*** is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9f286cb21767f9219e509f39b7c87f22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Therefore, if we wish to succeed with a probability of ùùê then we will have
    to make *k* ‚â• ùùê*N* queries. Overall, we can define the ***query complexity***of
    the classical search algorithm using [***Big-O notation***](https://en.wikipedia.org/wiki/Big_O_notation)as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e266c1924ca8fadae3c94600bfea6ae8.png)'
  prefs: []
  type: TYPE_IMG
- en: Grover‚Äôs Quantum Search Algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section we‚Äôll dive into the theory behind how Grover‚Äôs quantum search
    algorithm finds a marked element in an unstructured database with a query complexity
    of:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7e639780417fb20f745f0e936f88920d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The algorithm describes how to apply a set of ***quantum operators or*** [***quantum
    gates***](https://en.wikipedia.org/wiki/Quantum_logic_gate) in a [***quantum circuit***](https://en.wikipedia.org/wiki/Quantum_circuit)
    on *n* qubits which are initially in a ***zero state***:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/fe1f4b011879098e473e4e0ebe3070bb.png)'
  prefs: []
  type: TYPE_IMG
- en: The quantum circuit will transform the ***initial*** *n* qubit state into a
    ***final*** *n* qubit state which is equal to the target quantum state with a
    ***high probability***. Then, measuring the final quantum state will return the
    target ID bit-string *x‚ÇÄ (with high probability).*
  prefs: []
  type: TYPE_NORMAL
- en: Quantum Gates & Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Oracle Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The oracle operator is the quantum gate equivalent of the black-box function
    *f(x)* used in the classical algorithm. The oracle will act on an *n*-qubit quantum
    state ***|****x***‚ü©** and ***add a negative phase*** to the state if it is equal
    to the target state ***|****x‚ÇÄ***‚ü©** and leave it unchanged otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0988fb29827027b76392b645d258068d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To see how this is linked to the black-box function *f(x)* we can also represent
    the oracle operation as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a61e05cff64d697e613157604737a1de.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we think about it carefully, we can see that the oracle operator is equivalent
    to the [***diagonal identity operator***](https://en.wikipedia.org/wiki/Identity_matrix)(*which
    in matrix form has only diagonal terms which are equal to 1*) with the element
    corresponding to the target state ***|****x‚ÇÄ***‚ü©** possessing a negative sign.
    As such, we can write the oracle operator as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/394b59f0849b2600c8d58bbb2fd54f32.png)'
  prefs: []
  type: TYPE_IMG
- en: A quick check can verify that this representation is indeed equal to the two
    above it.
  prefs: []
  type: TYPE_NORMAL
- en: The oracle is the ***core of the algorithm*** and defines the computational
    problem being solved. In essence, it simply ***verifies potential solutions to
    the given problem***. As such, Grover‚Äôs algorithm can be used to solve any problem
    which can be represented using a black-box function and so it can be applied to
    much more than just unstructured search problems.
  prefs: []
  type: TYPE_NORMAL
- en: The Phase Inverter Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The phase inverter operator is similar to the oracle operator, except rather
    than adding a negative phase to the state if it‚Äôs equal to the target state ***|****x‚ÇÄ***‚ü©**
    it instead ***adds a negative phase to the state if it‚Äôs equal to the*** ***n-qubit
    zero state*** ***|0*‚ü©**. As before, the state is left unchanged otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d9739a16ed953ab4b18259a6ba022740.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The phase inverter operator can also be expressed as the ***diagonal identity
    operator*** with the element corresponding to the zero state possessing a negative
    phase:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e06482dd648dd0feb0e9a400deb49fb7.png)'
  prefs: []
  type: TYPE_IMG
- en: Grover‚Äôs Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Grover‚Äôs operator ***D*** is obtained by applying a [***Hadamard operator***](https://en.wikipedia.org/wiki/Hadamard_transform)on
    all *n* qubits before and after applying the ***phase inverter operator*** and
    then adding a negative phase, i.e. adding a negative sign. It can be expressed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8f4ee654d13b1fd02b77b30abcec573f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Where the Hadamard operator simply puts all *n* qubits into an ***equal superposition***
    of possible *N = 2‚Åø* states. We can substitute in our alternative representation
    for the phase inverter operator to obtain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d5c169b7db56f02987f99f6d8c6d9515.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Where the action of the Hadamard operation on a single qubit in the zero state
    puts it into the following single qubit superposition state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/819807144479c10cbabf66af3e7c23dd.png)'
  prefs: []
  type: TYPE_IMG
- en: Inversion and Reflection Operator Representations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get a clearer and more intuitive understanding of the action of the oracle
    operator, phase inverter operator, and Grover‚Äôs D operator on the *n*-qubit quantum
    state let‚Äôs first take a brief detour to explore two general classes of operators
    known as ***inversion and reflection operators***.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might guess, inversion and reflection operators perform an ***‚Äòinversion‚Äô***
    or a ***‚Äòreflection‚Äô*** of a quantum state about some other quantum state |ùúì‚ü©.
    They are expressed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ad4d685d22fccf20cfb6c40092a50325.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To see how these two forms of operators act on a state let us consider their
    ***action on an arbitrary state*** which is ***decomposed into orthogonal components***:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0fc09fb6afaf138686cfc38f6caf2fa4.png)'
  prefs: []
  type: TYPE_IMG
- en: Inversion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It‚Äôs easy to check that applying the inversion operator to the arbitrary state
    above results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ef2654a86b2be4a773602b0a5ae40dfd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that the the sign in front of the |ùúì‚ü© component of the state has
    been flipped. This corresponds to a ***‚Äòreflection‚Äô*** of the overall state |ùúô‚ü©
    about the orthogonal |ùúì‚ü© state. We can visualise this below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2a761b65c0cf6ac49468370def344345.png)'
  prefs: []
  type: TYPE_IMG
- en: Animation of the inversion operation on an arbitrary state |ùúô‚ü©. Yellow axis
    indicates the axis of reflection. Gif by author.
  prefs: []
  type: TYPE_NORMAL
- en: Reflection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similarly if we apply the reflection operator to the arbitrary state then we
    obtain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/232cfec8fd5ca5a0e4d0aa6fdf7f29eb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Where we now find the sign has flipped for the orthogonal component. This sign
    flip corresponds to a reflection of the overall state |ùúô‚ü© about the |ùúì‚ü© state.
    We can visualise this below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/305f450e77694012d24ca444e9cbc977.png)'
  prefs: []
  type: TYPE_IMG
- en: Animation of the reflection operation on an arbitrary state |ùúô‚ü©. Yellow axis
    indicates axis of reflection. Gif by author.
  prefs: []
  type: TYPE_NORMAL
- en: The Oracle, Phase Inverter, and Grover‚Äôs D Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With our new understanding of inversion and reflection operators let us represent
    the oracle operator, phase inverter operator, and Grover‚Äôs D operator as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d2a8d4794a43831de3470134673c3821.png)'
  prefs: []
  type: TYPE_IMG
- en: The Quantum Algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have developed a solid understanding of the core concepts and quantum
    operators involved in Grover‚Äôs algorithm we can begin examining how the algorithm
    works. The complete algorithm is described below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9d5259173b89ec9078f83c7576e70153.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The ***complete*** [***unitary operator***](https://en.wikipedia.org/wiki/Unitary_matrix)
    describing the algorithm is therefore:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/125a5879e591b82ac1f2508a1e237333.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And so the ***final quantum state*** that our *n* qubits are in at the end
    of the algorithm is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/16d4d07c1a4706815f79cbc5c1cc8207.png)'
  prefs: []
  type: TYPE_IMG
- en: If our algorithms works as it should, the final state above should be equal
    to the ***target state*** ***|****x‚ÇÄ***‚ü©** with high probability. Then, measuring
    the final state of each qubit should give us the target ID bit-string *x‚ÇÄ.*
  prefs: []
  type: TYPE_NORMAL
- en: 'The quantum circuit representing the algorithm is illustrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6640631e3fe6df7c3b8a2a3ef5dfdb78.png)'
  prefs: []
  type: TYPE_IMG
- en: Diagram of the quantum circuit corresponding to Grover‚Äôs algorithm. Image by
    author.
  prefs: []
  type: TYPE_NORMAL
- en: Grover Iteration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The action of each of the *T* ***‚ÄòGrover iterations‚Äô*** on an *n*-qubit state
    is described by the operators in brackets. We‚Äôll combine them into a Grover operator
    *G*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a9725ce91225ca0aabeade915b715459.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Which we can express in terms of ***inversion and reflection operators*** as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/06c065db47a2791e64a7fc5616da7609.png)'
  prefs: []
  type: TYPE_IMG
- en: Where the 2*nd* last term indicates a reflection about the orthogonal |+‚Åø**‚ü©**
    state. We can say that the |*x‚ÇÄ***‚ü©** and |+‚Åø**‚ü©** states ***span a 2D subspace
    of the Hilbert space*** *(the total N* = *2‚Åø state space of our n-qubits)*and
    that the reflection operations in each Grover iteration take place in this 2D
    subspace.
  prefs: []
  type: TYPE_NORMAL
- en: A Geometric Explanation of The Algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let‚Äôs consider the action of each Grover iteration *G* on some arbitrary state
    |ùúÅ‚ü© in the 2D subspace spanned by |*x‚ÇÄ***‚ü©** and |+‚Åø**‚ü©**. We can express the
    arbitrary state |ùúÅ‚ü© in terms of the state |+‚Åø**‚ü©** and its orthogonal counterpart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e1de6102b4b9a328f03657bd4181b32b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, the target state |*x‚ÇÄ***‚ü©** can be written as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/475ab20782c0a992ae8a761c950a5efb.png)'
  prefs: []
  type: TYPE_IMG
- en: The initial state |ùúÅ‚ü© and the target state |*x‚ÇÄ***‚ü©** can then be plotted on
    a graph of the 2D subspace with the axes representing the orthogonal |+‚Åø**‚ü©**
    components. This is illustrated below with the relevant angles between states
    indicated.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/24bd59b54bea886f678a8d932adfb565.png)'
  prefs: []
  type: TYPE_IMG
- en: Illustration of the 2D subspace spanned by some arbitrary initial state and
    the target state. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we inspect the Grover iteration operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/26526a2ca91928bd5ea8718d9389b717.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The action of each Grover iteration on some initial state can be understood
    graphically as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '***Reflection*** of the |ùúÅ‚ü© state about the |*x‚ÇÄ***‚ü©** state.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***Reflection*** of the resulting state about the orthogonal axis.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Thus, if we initially have an angle of ùúΩ between the state and the target state,
    we first have to ***subtract*** -2ùúΩ ***upon reflection*** about the |*x‚ÇÄ***‚ü©**
    state and then ***add*** +2(ùúΩ ‚Äî ùõæ) ***upon reflection*** about the vertical orthogonal
    axis. The final angle is therefore given by:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/685dda9829875c05850ee5cc2cc10232.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In other words:'
  prefs: []
  type: TYPE_NORMAL
- en: With each Grover iteration the angle between the *n*-qubit quantum state |ùúÅ‚ü©
    and the target state |*x‚ÇÄ***‚ü©** decreases by 2ùõæ.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This can be more clearly understood using the animation below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3cdf10320e72ea39de2b3f2ee6186212.png)'
  prefs: []
  type: TYPE_IMG
- en: Animation of the action of a Grover iteration on some initial arbitrary state.
    Gif by author.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, to put our initial quantum state |ùúÅ‚ü© into the target state |*x‚ÇÄ***‚ü©**
    we just have to ***repeatedly apply Grover iterations*** and then stop once the
    state |ùúÅ‚ü© is ***as close to*** the target state |*x‚ÇÄ***‚ü©** as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, as discussed previously we do not begin with some initial ***arbitrary***
    state |ùúÅ‚ü© to which we apply our Grover iterations. As shown by ***steps 1 and
    2*** we actually begin with the initial state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/95576615dd5c7458ff5218d02949706f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The ***initial angle ùúΩ*** between the initial state |ùúÅ‚ü© and the target state
    |*x‚ÇÄ***‚ü©** is found by the [***inner product***](https://en.wikipedia.org/wiki/Inner_product_space):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a7297c5f7f02d2a11f41c3abd18470ad.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, we can also easily show that the angle ùõæ between the target state
    |*x‚ÇÄ***‚ü©** and the orthogonal axis is given by:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1331bfe4e6486d4b50cca9f5b43ad43f.png)'
  prefs: []
  type: TYPE_IMG
- en: Thus, as the database size *N* increases, i.e.***in the limit of a very large
    set size N,*** we get the following**:**
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/264b5d1774e68175b614e2e15770958b.png)'
  prefs: []
  type: TYPE_IMG
- en: Similarly, we can also say ***(using the*** [***small angle approximation***](https://en.wikipedia.org/wiki/Small-angle_approximation)***)***
    that in the limit of large *N:*
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7dc1cc1c3613176e392d3878a4c98f09.png)'
  prefs: []
  type: TYPE_IMG
- en: Query Complexity Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So with these initial angles, ***approximately how many Grover iterations will
    we require for the initial state to arrive at or get as close as possible to the
    target state |x‚ÇÄ‚ü©?***
  prefs: []
  type: TYPE_NORMAL
- en: 'Since each Grover iteration reduces the angle between the state and the target
    state by 2ùõæ and the initial angle is ùúã/*2* we can show that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/33af3e36ce558a025fc3d64673099d45.png)'
  prefs: []
  type: TYPE_IMG
- en: Where *T* represents the number of Grover iterations and thus also the number
    of ***queries k to the oracle***. However, we should note that this is ***just
    an approximation***. A more precise derivation of the optimal number of Grover
    iterations will be presented in the following section. Nevertheless, the ***query
    complexity*** can be found and expressed in [***Big-O notation***](https://en.wikipedia.org/wiki/Big_O_notation)***:***
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2aee03c8f292d23a0f149abf1acacfd8.png)'
  prefs: []
  type: TYPE_IMG
- en: '***A*** ***quadratic speed-up over the classical query complexity***! The graph
    below compares the classical query complexity to the quantum query complexity
    and indicates the point of quantum advantage.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/91e5993d556f6910260d6a49466ed36f.png)'
  prefs: []
  type: TYPE_IMG
- en: Classical query complexity vs. quantum query complexity, with the point of quantum
    advantage indicated in yellow. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: Success Probability Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: However, the probability of successfully arriving at the target state |*x‚ÇÄ***‚ü©**
    is strongly dependent on the total system size *N* and the number of Grover iterations
    applied *T*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, the success probability doesn‚Äôt approach unity with increasingly many
    Grover iterations but rather ***oscillates*!** To see why, let‚Äôs first consider
    the probability that the ***final state*** |ùúÅ‚ü© is in the ***target state*** |*x‚ÇÄ***‚ü©**
    using:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0b61d52c1dfe3b84012e756072e057d3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We know the ***inner-product*** can be expressed in its more familiar geometric
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/af3f30c4a14d022625c6bc5c90a90bb9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using the ***final angle*** between the state |ùúÅ‚ü© and the target state |*x‚ÇÄ***‚ü©**
    after *T* Grover iterations. We also already know this angle is given by:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9dd8de7129053098b54abd0edf273e70.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And using the relation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/971f2a36de24cc7f2a745465f7916c77.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Gives us the following expression for the final angle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/56dc08d61502177e7ec78b6a5e51d207.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can substitute this into the inner-product to get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/32fd9a9f51d2036495c00e92ef06e464.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Which finally gives us the following expression for the probability of successfully
    putting the final state into the target state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/92c2866ce3af73b3384c249e89f1a334.png)'
  prefs: []
  type: TYPE_IMG
- en: Using this equation, ***we can plot the probability of success as a function
    of the number of Grover iterations*** for some system size *N* to see that the
    success probability does indeed oscillate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/770b3bfa0f36bf5d6e7c98f9eb932986.png)'
  prefs: []
  type: TYPE_IMG
- en: Probability of success as a function of the number of Grover iterations. Image
    by author.
  prefs: []
  type: TYPE_NORMAL
- en: To see why this oscillation occurs we can once again plot the state |ùúÅ‚ü© and
    the target state |*x‚ÇÄ***‚ü©** on a graph and apply many Grover iterations to see
    how the state ***behaves*** over many iterations *T*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/49b6756dce6a97928d80a6f001c5bc2a.png)'
  prefs: []
  type: TYPE_IMG
- en: Animation of the behaviour of the state over many Grover iterations. Gif by
    author.
  prefs: []
  type: TYPE_NORMAL
- en: We can see that as the state approaches the target state at an angular rate
    of 2ùõæ per Grover iteration it actually reaches a minimum point at which the sign
    of the angle between the state and the target state flips. Thus, the state begins
    to ‚Äòspiral‚Äô away from the target state.
  prefs: []
  type: TYPE_NORMAL
- en: At every system size *N* there exists an **optimal number of Grover iterations
    *T* which maximises the probability of success**.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We can find this optimal number by setting the probability of success to 1 and
    re-arranging to find *T.*
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3d7560bedc2e93af7d504e8246e79257.png)'
  prefs: []
  type: TYPE_IMG
- en: However, this optimal number of iterations must be an ***integer value*** so
    there will often be some ***small truncation error*** as a result of rounding
    to the nearest integer.
  prefs: []
  type: TYPE_NORMAL
- en: We can observe the effect of this truncation error by ***plotting the success
    probability as a function of set size N***and using the ***optimal number of Grover
    iterations rounded to the nearest integer.***
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2a91fc9bf8ce3c67f244d6dd1d8ceaac.png)'
  prefs: []
  type: TYPE_IMG
- en: Success probability as a function of system size N using nearest-integer optimal
    Grover iteration T values. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: 'Where the blue curve shows the success probability and the red curve shows
    an ***envelope approximation*** of the success probability ***as a function of
    set size N***. As shown in the graph, the success probability scales according
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4d228af4a883b3ee349a6aa4e86ccf78.png)'
  prefs: []
  type: TYPE_IMG
- en: Thus, as the set size *N* gets larger the ***probability of success approaches
    unity!***
  prefs: []
  type: TYPE_NORMAL
- en: 'We can perhaps gain a clearer understanding of why this trend in the success
    probability occurs if we once again plot the oscillating probability of success
    as a function of Grover iterations, but this time we‚Äôll show only the integer
    values of *T*. For a set size of *N=7,* we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a873a730df412c67c63cd0ea9ce76a87.png)'
  prefs: []
  type: TYPE_IMG
- en: Success probability as a function of truncated nearest integer Grover iterations,
    set size N=7\. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the ***‚Äòfrequency‚Äô of the oscillation*** in the success probability
    is such that for the first cycle of oscillation shown above the ***nearest integer
    Grover iterations (the vertical lines) do not align with the peak of the oscillation.
    Therefore, the success probability cannot reach unity.***
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we do the same for a set size of *N=100* we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0f22bda4829378c87fe1214f6809e966.png)'
  prefs: []
  type: TYPE_IMG
- en: Success probability as a function of truncated nearest integer Grover iterations,
    set size N=100\. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: 'Increasing the set size *N* has effectively ***decreased the ‚Äòfrequency‚Äô***
    of the oscillations such that the ***optimal nearest integer Grover iteration
    can get much closer to the peak of oscillation.*** This pattern becomes even more
    clear if we increase the set size further to *N = 800*, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3df9aca387fb16ce12e23dfcd36e0191.png)'
  prefs: []
  type: TYPE_IMG
- en: Success probability as a function of truncated nearest integer Grover iterations,
    set size N=800\. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, as *N* tends to infinity, the optimal nearest integer Grover iteration
    T approaches the peak of the oscillation and the success probability approaches
    unity.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this article, we explored in great detail the theory behind how Grover‚Äôs
    quantum search algorithm achieves a quadratic speed-up over traditional classical
    search algorithms. However, in theory Grover‚Äôs algorithm can be applied to a much
    greater range of algorithms than just unstructured searches. More generally, the
    algorithm can offer a speed up to any ***black-box problem*** which involves satisfying
    some constraint, as checked by the oracle operator, or any problem which inherently
    involves an ***exhaustive search***. As such, one potential application of the
    algorithm that has received extensive interest is that of ***quantum cryptography***.
    In particular, Grover‚Äôs algorithm may offer a quantum speed to the exhaustive
    searches intrinsic to many ***brute-force attack*** algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: However, the query complexity of Grover‚Äôs algorithm only overtakes that of its
    classical counterpart after a particular system size *N* is realised. Currently,
    near-term quantum computers are far from being able to supply the large numbers
    of noise-free qubits required for such a quantum advantage. Nevertheless, with
    continued progress in the fields of quantum computing and quantum engineering
    over the coming decades it seems likely that long-term fault-tolerant quantum
    computers will reach the complexity and sophistication needed to realise the promises
    of Grover‚Äôs quantum search algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '**Thanks for reading!** If you enjoyed this article and want to read more about
    physics, quantum mechanics, and quantum computing then give me a follow and check
    out some of my other articles! And if you ***really*** enjoyed it you can buy
    me a coffee (if you‚Äôd like) at [https://bmc.link/danjackho5](https://bmc.link/danjackho5),
    I‚Äôd really appreciate it!'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if you want to keep reading about maths and physics on Medium then
    why not sign up to become a Medium member using the following link [https://medium.com/@danjackho/membership](https://medium.com/@danjackho/membership).
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/@danjackho/quantum-physics-101-the-schr%C3%B6dinger-equation-in-its-various-forms-3c9f3bcd68ee?source=post_page-----54c427315768--------------------------------)
    [## The Schr√∂dinger Equation in its Various Forms'
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps no equation in quantum mechanics is as ubiquitous as the Schr√∂dinger
    equation.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'medium.com](https://medium.com/@danjackho/quantum-physics-101-the-schr%C3%B6dinger-equation-in-its-various-forms-3c9f3bcd68ee?source=post_page-----54c427315768--------------------------------)
    [](https://medium.com/@danjackho/the-quantum-harmonic-oscillator-diracs-approach-f847569b9df0?source=post_page-----54c427315768--------------------------------)
    [## The Quantum Harmonic Oscillator: Dirac‚Äôs Approach'
  prefs: []
  type: TYPE_NORMAL
- en: How this fundamental model in physics becomes quantised and how we can apply
    Dirac‚Äôs ‚Äòladder method‚Äô to find its energy‚Ä¶
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/@danjackho/the-quantum-harmonic-oscillator-diracs-approach-f847569b9df0?source=post_page-----54c427315768--------------------------------)
    [](https://medium.com/@danjackho/the-mathematics-of-quantum-teleportation-explained-3db2b9066c7a?source=post_page-----54c427315768--------------------------------)
    [## The Mathematics of Quantum Teleportation Explained
  prefs: []
  type: TYPE_NORMAL
- en: The mathematics behind how the quantum state of a particle can be ‚Äòtransferred‚Äô
    to a distant particle using quantum‚Ä¶
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/@danjackho/the-mathematics-of-quantum-teleportation-explained-3db2b9066c7a?source=post_page-----54c427315768--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[1] Grover, Lov K. ‚ÄúA fast quantum mechanical algorithm for database search.‚Äù
    *Proceedings of the twenty-eighth annual ACM symposium on Theory of computing*.
    1996.'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] Linden, Noah. *Lecture Notes,* *‚ÄúQuantum Computation‚Äù*. 2022.'
  prefs: []
  type: TYPE_NORMAL
