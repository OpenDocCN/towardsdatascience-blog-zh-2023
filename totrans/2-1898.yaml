- en: Speed Up your Python Skills
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://towardsdatascience.com/speed-up-your-python-skills-in-2023-e680f4c56f37](https://towardsdatascience.com/speed-up-your-python-skills-in-2023-e680f4c56f37)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Seven tips to take you to the next level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://tinztwinspro.medium.com/?source=post_page-----e680f4c56f37--------------------------------)[![Janik
    and Patrick Tinz](../Images/a08aa54f553f606ef5df86f9411c36ac.png)](https://tinztwinspro.medium.com/?source=post_page-----e680f4c56f37--------------------------------)[](https://towardsdatascience.com/?source=post_page-----e680f4c56f37--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----e680f4c56f37--------------------------------)
    [Janik and Patrick Tinz](https://tinztwinspro.medium.com/?source=post_page-----e680f4c56f37--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ¬∑Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----e680f4c56f37--------------------------------)
    ¬∑9 min read¬∑Jan 16, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/509f2e1b0475dabe336a49f134d00b80.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Emile Perron](https://unsplash.com/@emilep?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: '**Python** is the most widely used programming language in the data science
    domain, and its popularity continues to grow. The entire data science field has
    grown enormously in recent years.'
  prefs: []
  type: TYPE_NORMAL
- en: In this article, we will show you seven tips on how to improve your Python skills.
    It‚Äôs often the little things that make a big difference. The tips will enrich
    your life as a Data Scientist. That‚Äôs why we give you seven tips that you can
    put into practice right now. **Be curious!**
  prefs: []
  type: TYPE_NORMAL
- en: As a Data Scientist, you often have to deal with large amounts of data. For
    this reason, you must code efficiently in terms of run time and memory. Your Python
    code should also be well-structured and easy to read. The tips will help you to
    write efficient and readable Python code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tip 1: Speed up NumPy'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[NumPy](https://numpy.org) is a Python library to work efficiently with arrays.
    It also offers fast and optimised vectorised operations. But! It does not support
    parallel processing. As an alternative to NumPy, you can use [NumExpr](https://numexpr.readthedocs.io/en/latest/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: NumExpr achieves significantly better performance than NumPy because it supports
    multi-threading. Furthermore, it avoids allocating memory for intermediate results.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you have to install the packages NumPy and NumExpr. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Look at the example and try it out.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Wow! The statement is performed approx. 5x faster with NumExpr. So if you want
    to speed up your NumPy statements, this gives you a way to do it.
  prefs: []
  type: TYPE_NORMAL
- en: NumExpr works best when you have large arrays. It also develops its maximum
    performance if you have a powerful computer with many cores. For this reason,
    we recommend NumExpr when these two conditions are present. For small array operations,
    you can also use NumPy, as the performance differences are very minimal. The reason
    is that NumExpr splits the array operands into small chunks. These chunks easily
    fit into the CPU cache. The chunks are distributed among the available cores of
    the CPU, allowing parallel execution.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn more about NumExpr, check out [NumExpr‚Äôs GitHub](https://github.com/pydata/numexpr)
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tip 2: Fast alternative to pandas apply()'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The pandas apply() function can execute functions along an axis of a data frame.
    Many programmers use the apply() function in combination with lambda functions.
    But how can you increase the performance of an apply() function?
  prefs: []
  type: TYPE_NORMAL
- en: You can use the package swifter. This package applies functions very quickly
    to data frames or series. The pandas apply() function runs on one core, and the
    swifter provides multiple core support.
  prefs: []
  type: TYPE_NORMAL
- en: First, you need to install the swifter package.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: After the installation you can try it out directly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This simple example shows that the swifter.apply() function has a faster run
    time. The difference is particularly noticeable on powerful computers with multiple
    cores. If you need a performance boost in your next project, consider the swifter
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tip 3: Using Built-in Python Functions'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often you implement a function and don‚Äôt know that it already exists in Python.
    Especially if you come from other programming languages such as C or C++. First,
    you should always check if a Python built-in function already exists. Python built-in
    functions are much faster than custom implementations, so you should always use
    them. The following example demonstrates this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the code above, we replicate a list of four entries 10 million times, so
    we get a list of 40 million entries. Then we convert the strings in the list to
    lower case. You can see that the built-in function is about 17 times faster. Especially
    with large amounts of data, this tip brings an enormous increase in performance.
    So use built-in functions!
  prefs: []
  type: TYPE_NORMAL
- en: There are many more built-in functions, such as min(), max(), all(), etc. Do
    your own research if you need a specific Python function. **It‚Äôs worth it!**
  prefs: []
  type: TYPE_NORMAL
- en: 'Tip 4: Use list comprehension instead of loops'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programmers often use lists in combination with loops to store calculated results.
    However, this approach is not efficient in terms of run time. For this reason,
    it is better to use list comprehension, which has better performance. The following
    example shows the difference in performance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: What do we learn from this example? Use list comprehension when possible. List
    comprehension is somewhat controversial in programming. Some programmers find
    the syntax hard to read, as one line of code expresses all statements. In our
    opinion, the syntax is clear and concise. It is a matter of taste, but the performance
    is better with a list comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: A list comprehension begins with an opening bracket [. Then there is the calculation
    from the for-loop. Then comes the loop header with three elements (keyword for,
    run variable, length of the loop). The list comprehension is closed with a closing
    bracket ]. Once you understand the syntax, you can write for-loops much more compactly.
  prefs: []
  type: TYPE_NORMAL
- en: But what about in terms of memory usage? How can we reduce the memory space?
    It is especially advisable with large lists if we want to perform further operations
    on them. In our example, we store 10000000 values in the list. But do we have
    to save all entries directly, or do we only need them when required?
  prefs: []
  type: TYPE_NORMAL
- en: In these cases, we can use generators. A generator creates a list item when
    needed. As a result, a generator requires less memory and has a better run time.
    Take a look at the following example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can do all the operations as in the previous example. The only difference
    is that we now use () instead of []. Instead of a list, we store a generator.
    This approach is more memory efficient. Check if you can use list comprehension
    or generators in your projects. They can improve performance and reduce memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tip 5: Merge dicts with double asterisk syntax **'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How do you merge dictionaries? You can do that with a one-liner. We use the
    asterisk syntax **. In the following example, you can see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: First, we define two dictionaries with identical and different key-value pairs.
    The foundation of Tesla was in 2003, so dict_2 is more up-to-date. If both dictionaries
    contain the same key and different values, then the value of the last dictionary
    is used. After merging, the new dictionary contains all three key-value pairs.
    The syntax is concise and compact, so merging is very easy. And the best thing
    is that you can merge three or more dictionaries. This trick can save a lot of
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Another method is the update method. This method updates the first dictionary
    and does not create a copy. Take a look at the following example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The disadvantage of the update method is that you can only use one dictionary
    for updating. If you want to merge dictionaries in the future, remember this tip.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tip 6: Do not import unnecessary modules'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have heard this tip many times, but it can significantly improve the
    performance of your code. It is not necessary to import entire libraries. You
    usually only need certain functions of it. In addition, your code takes a long
    time to start because the entire library has to import first. That should not
    be the case. In addition, you then have to access individual functions via the
    dot notation. That is very inefficient, and you should avoid dot notation. The
    following examples demonstrate this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use math.exp() function with the dot notation. That leads
    to poor performance of your code. Also, we have imported the entire math library,
    although we only need the exp() function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we import the exp() function without the dot notation. By using
    this trick, we can halve the run time of our code. Wow. That‚Äôs great!
  prefs: []
  type: TYPE_NORMAL
- en: 'Tip 7: Use just-in-time compiler'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Numba](https://numba.readthedocs.io/en/stable/index.html) is a just-in-time
    (jit) compiler that works well with NumPy loops, arrays and functions. Decorators
    are used to instruct Numba to compile certain functions with Numba. Numba compiles
    decorated functions just-in-time into machine code so that all or part of the
    code runs at the speed of native machine code.'
  prefs: []
  type: TYPE_NORMAL
- en: First we have to install Numba via pip.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After successful installation, you can use Numba. Take a look at the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that the decorator above the foo function speeds up the code. The
    decorator *nopython=True* indicates that the compilation will run without the
    involvement of the Python interpreter. Numba speeds up the execution of the loop
    and the NumPy trigonometric functions. However, it can not use with all Python
    functions. The followings are the advantages and disadvantages of [Numba](https://numba.readthedocs.io/en/stable/user/5minguide.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '***Cons:***'
  prefs: []
  type: TYPE_NORMAL
- en: Numba does not support pandas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unsupported code is executed via the interpreter and has the additional Numba
    overhead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only unofficial support on M1/Arm64.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Pros:***'
  prefs: []
  type: TYPE_NORMAL
- en: Very good support for NumPy arrays and functions, and loops.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for Nvidia CUDA. It can use well for the development of neural networks
    based on NumPy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cons and pros show that Numba should be used primarily for NumPy operations.
    In addition, you should always check at the beginning whether Numba is suitable
    for the respective implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this article we have learned how to increase the efficiency of your code
    in terms of run time and memory. Lessons learned:'
  prefs: []
  type: TYPE_NORMAL
- en: NumPy does not support parallel processing. You can use NumExpr for that.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pandas apply() function can be accelerated by swifter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check if there are built-in functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use list comprehension instead of loops. Check if generators are suitable for
    your project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merge dicts with double asterisk syntax **.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not import unnecessary modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have run time problems, you can use just-in-time compilers. Just-in-time
    compilers speed up your code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: üëâüèΩ [**You can find all our Freebies on our digital products page!**](https://shop.tinztwins.de/)
  prefs: []
  type: TYPE_NORMAL
- en: üëâüèΩ [**Join our free weekly Magic AI newsletter for the latest AI updates!**](https://magicai.tinztwins.de)
  prefs: []
  type: TYPE_NORMAL
- en: '[**Subscribe for free**](https://tinztwinspro.medium.com/subscribe) **to get
    notified when we publish a new story:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://tinztwinspro.medium.com/subscribe?source=post_page-----e680f4c56f37--------------------------------)
    [## Get an email whenever Janik and Patrick Tinz publishes.'
  prefs: []
  type: TYPE_NORMAL
- en: Get an email whenever Janik and Patrick Tinz publishes. By signing up, you will
    create a Medium account if you don‚Äôt‚Ä¶
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: tinztwinspro.medium.com](https://tinztwinspro.medium.com/subscribe?source=post_page-----e680f4c56f37--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Learn more about us on our [About page](https://medium.com/@tinztwinspro/about).
    Don‚Äôt forget to follow us on [X](https://twitter.com/tinztwins). Thanks so much
    for reading. If you liked this article, feel free to share it. **Have a great
    day!**
  prefs: []
  type: TYPE_NORMAL
- en: Sign up for a Medium membership using [our link](https://tinztwinspro.medium.com/membership)
    to read unlimited Medium stories.
  prefs: []
  type: TYPE_NORMAL
