- en: Having Trouble Understanding Quantum Machine Learning?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: åœ¨ç†è§£é‡å­æœºå™¨å­¦ä¹ æ—¶é‡åˆ°å›°éš¾å—ï¼Ÿ
- en: åŸæ–‡ï¼š[https://towardsdatascience.com/having-trouble-understanding-quantum-machine-learning-ce8a941d8c70](https://towardsdatascience.com/having-trouble-understanding-quantum-machine-learning-ce8a941d8c70)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://towardsdatascience.com/having-trouble-understanding-quantum-machine-learning-ce8a941d8c70](https://towardsdatascience.com/having-trouble-understanding-quantum-machine-learning-ce8a941d8c70)
- en: Implementing the Quantum Approximate Optimization Algorithm using functional
    programming
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ä½¿ç”¨å‡½æ•°å¼ç¼–ç¨‹å®ç°é‡å­è¿‘ä¼¼ä¼˜åŒ–ç®—æ³•
- en: '[](https://pyqml.medium.com/?source=post_page-----ce8a941d8c70--------------------------------)[![Frank
    Zickert | Quantum Machine Learning](../Images/ae361c0d68d13dac21bb86c7496d2917.png)](https://pyqml.medium.com/?source=post_page-----ce8a941d8c70--------------------------------)[](https://towardsdatascience.com/?source=post_page-----ce8a941d8c70--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----ce8a941d8c70--------------------------------)
    [Frank Zickert | Quantum Machine Learning](https://pyqml.medium.com/?source=post_page-----ce8a941d8c70--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://pyqml.medium.com/?source=post_page-----ce8a941d8c70--------------------------------)[![Frank
    Zickert | Quantum Machine Learning](../Images/ae361c0d68d13dac21bb86c7496d2917.png)](https://pyqml.medium.com/?source=post_page-----ce8a941d8c70--------------------------------)[](https://towardsdatascience.com/?source=post_page-----ce8a941d8c70--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----ce8a941d8c70--------------------------------)
    [Frank Zickert | Quantum Machine Learning](https://pyqml.medium.com/?source=post_page-----ce8a941d8c70--------------------------------)'
- en: Â·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----ce8a941d8c70--------------------------------)
    Â·7 min readÂ·Mar 2, 2023
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Â·å‘è¡¨äº[Towards Data Science](https://towardsdatascience.com/?source=post_page-----ce8a941d8c70--------------------------------)
    Â·é˜…è¯»æ—¶é—´7åˆ†é’ŸÂ·2023å¹´3æœˆ2æ—¥
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: Do you want to get started with Quantum Machine Learning? Have a look at [**Hands-On
    Quantum Machine Learning With Python**](https://www.pyqml.com/volume1?provider=medium&origin=troubleunderstanding)**.**
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: æƒ³è¦å¼€å§‹é‡å­æœºå™¨å­¦ä¹ å—ï¼Ÿè¯·æŸ¥çœ‹[**åŠ¨æ‰‹é‡å­æœºå™¨å­¦ä¹ ä¸Python**](https://www.pyqml.com/volume1?provider=medium&origin=troubleunderstanding)**ã€‚**
- en: This article will explain the most important parts of the Quantum Approximate
    Optimization Algorithm (QAOA). QAOA is a machine learning algorithm that you can
    use to solve combinatorial optimization problems.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬æ–‡å°†è§£é‡Šé‡å­è¿‘ä¼¼ä¼˜åŒ–ç®—æ³•ï¼ˆQAOAï¼‰ä¸­æœ€é‡è¦çš„éƒ¨åˆ†ã€‚QAOAæ˜¯ä¸€ç§æœºå™¨å­¦ä¹ ç®—æ³•ï¼Œä½ å¯ä»¥ç”¨æ¥è§£å†³ç»„åˆä¼˜åŒ–é—®é¢˜ã€‚
- en: The special thing is this algorithm caters to the specificities of quantum computers
    â€” a new kind of computer that promises exponential speedups in problem-solving.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ç‰¹åˆ«ä¹‹å¤„åœ¨äºï¼Œè¿™ä¸ªç®—æ³•è¿åˆäº†é‡å­è®¡ç®—æœºçš„ç‰¹æ€§â€”â€”ä¸€ç§æ‰¿è¯ºåœ¨è§£å†³é—®é¢˜ä¸Šæä¾›æŒ‡æ•°çº§åŠ é€Ÿçš„æ–°å‹è®¡ç®—æœºã€‚
- en: Even though quantum machine learning (QML) â€” that is, using quantum computing
    to solve machine learning algorithms â€” is one of the most promising technologies,
    **it is as challenging!**
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: å°½ç®¡é‡å­æœºå™¨å­¦ä¹ ï¼ˆQMLï¼‰â€”â€”å³ä½¿ç”¨é‡å­è®¡ç®—æ¥è§£å†³æœºå™¨å­¦ä¹ ç®—æ³•â€”â€”æ˜¯æœ€æœ‰å‰æ™¯çš„æŠ€æœ¯ä¹‹ä¸€ï¼Œ**å®ƒä¹ŸåŒæ ·å…·æœ‰æŒ‘æˆ˜æ€§ï¼**
- en: Therefore, this article aims to explain the concepts underlying QAOA in an accessible
    way.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæœ¬æ–‡æ—¨åœ¨ä»¥ä¸€ç§æ˜“äºç†è§£çš„æ–¹å¼è§£é‡ŠQAOAçš„åŸºæœ¬æ¦‚å¿µã€‚
- en: Quantum computing, optimization, and machine learning rely heavily on mathematics.
    Unless youâ€™re a mathematician, it will be a daunting endeavor.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: é‡å­è®¡ç®—ã€ä¼˜åŒ–å’Œæœºå™¨å­¦ä¹ éƒ½åœ¨å¾ˆå¤§ç¨‹åº¦ä¸Šä¾èµ–äºæ•°å­¦ã€‚é™¤éä½ æ˜¯æ•°å­¦å®¶ï¼Œå¦åˆ™è¿™å°†æ˜¯ä¸€ä¸ªä»¤äººæœ›è€Œç”Ÿç•çš„ä»»åŠ¡ã€‚
- en: Fortunately, some QML libraries, such as IBM Qiskit, solve this problem. They
    provide easy-to-use interfaces and hide all the complexity from you.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: å¹¸è¿çš„æ˜¯ï¼Œä¸€äº›QMLåº“ï¼Œæ¯”å¦‚IBM Qiskitï¼Œè§£å†³äº†è¿™ä¸ªé—®é¢˜ã€‚å®ƒä»¬æä¾›äº†æ˜“äºä½¿ç”¨çš„æ¥å£ï¼Œå¹¶å°†æ‰€æœ‰å¤æ‚æ€§éšè—åœ¨ä½ ä¹‹å¤–ã€‚
- en: As I showed in [my previous post](https://medium.com/@pyqml/quantum-wildfire-fighting-e828497b7b89),
    they even take care of the problem formulation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚æˆ‘åœ¨[æˆ‘ä¹‹å‰çš„å¸–å­](https://medium.com/@pyqml/quantum-wildfire-fighting-e828497b7b89)ä¸­æ‰€å±•ç¤ºçš„ï¼Œå®ƒä»¬ç”šè‡³å¤„ç†äº†é—®é¢˜çš„å…¬å¼åŒ–ã€‚
- en: In that post, I used the **Quantum Approximate Optimization Algorithm** (QAOA)
    to solve a combinatorial optimization problem â€” how to respond to wildfires.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨é‚£ç¯‡å¸–å­ä¸­ï¼Œæˆ‘ä½¿ç”¨äº†**é‡å­è¿‘ä¼¼ä¼˜åŒ–ç®—æ³•**ï¼ˆQAOAï¼‰æ¥è§£å†³ä¸€ä¸ªç»„åˆä¼˜åŒ–é—®é¢˜â€”â€”å¦‚ä½•åº”å¯¹é‡ç«ã€‚
- en: '![](../Images/de8c69995f2f0c7f748fdc4cd94a6927.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/de8c69995f2f0c7f748fdc4cd94a6927.png)'
- en: Image by the author using Stable Diffusion
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡ç”±ä½œè€…ä½¿ç”¨Stable Diffusionç”Ÿæˆ
- en: The only thing you have to do is to specify the individual values of your problem.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å”¯ä¸€éœ€è¦åšçš„å°±æ˜¯æŒ‡å®šé—®é¢˜çš„ä¸ªä½“å€¼ã€‚
- en: It is too good to be true, no?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç®€ç›´å¤ªå¥½äº†ï¼Œä¸æ˜¯å—ï¼Ÿ
- en: '![](../Images/62d3fb053da8cc4693d4388f3321913d.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/62d3fb053da8cc4693d4388f3321913d.png)'
- en: Even though these libraries let you use quantum machine learning without bothering
    about math, quantum mechanics, or anything complicated, they likewise do not teach
    you much.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: å°½ç®¡è¿™äº›åº“è®©ä½ å¯ä»¥ä½¿ç”¨é‡å­æœºå™¨å­¦ä¹ è€Œä¸å¿…æ‹…å¿ƒæ•°å­¦ã€é‡å­åŠ›å­¦æˆ–å…¶ä»–å¤æ‚çš„ä¸œè¥¿ï¼Œä½†å®ƒä»¬åŒæ ·ä¸ä¼šæ•™ä½ å¤ªå¤šã€‚
- en: If you want to understand how an algorithm works, youâ€™re right back to where
    you started. If the Qiskit library is that good, why donâ€™t you look at their examples
    to understand how the QAOA works?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ æƒ³äº†è§£ä¸€ä¸ªç®—æ³•æ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Œä½ å°±ä¼šå›åˆ°æœ€åˆçš„åœ°æ–¹ã€‚å¦‚æœQiskitåº“å¦‚æ­¤å‡ºè‰²ï¼Œä¸ºä»€ä¹ˆä¸æŸ¥çœ‹ä»–ä»¬çš„ç¤ºä¾‹æ¥ç†è§£QAOAæ˜¯å¦‚ä½•å·¥ä½œçš„å‘¢ï¼Ÿ
- en: The following figure depicts an excerpt of their example.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹å›¾å±•ç¤ºäº†ä»–ä»¬ç¤ºä¾‹çš„ä¸€éƒ¨åˆ†ã€‚
- en: '![](../Images/e4b744e73e5e0faef07b00748930ba71.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e4b744e73e5e0faef07b00748930ba71.png)'
- en: Taken from the [Qiskit documentation](https://qiskit.org/textbook/ch-applications/qaoa.html)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: æ‘˜è‡ª [Qiskitæ–‡æ¡£](https://qiskit.org/textbook/ch-applications/qaoa.html)
- en: I think thereâ€™s not much to add, is there?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘è®¤ä¸ºæ²¡æœ‰ä»€ä¹ˆéœ€è¦æ·»åŠ çš„ï¼Œæ˜¯å—ï¼Ÿ
- en: â€¦
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: â€¦
- en: A little, perhaps.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹Ÿè®¸ä¸€ç‚¹ç‚¹ã€‚
- en: So, let me offer you an alternative explanation. One that does not ask for a
    math degree. But one that exploits the expressiveness of functional programming
    (in Python).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥ï¼Œè®©æˆ‘ç»™ä½ æä¾›ä¸€ä¸ªæ›¿ä»£çš„è§£é‡Šã€‚ä¸€ä¸ªä¸éœ€è¦æ•°å­¦å­¦ä½çš„è§£é‡Šã€‚ä½†ä¸€ä¸ªåˆ©ç”¨å‡½æ•°å¼ç¼–ç¨‹ï¼ˆåœ¨Pythonä¸­ï¼‰çš„è¡¨è¾¾åŠ›çš„è§£é‡Šã€‚
- en: The story of functional programming is quickly told.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: å‡½æ•°å¼ç¼–ç¨‹çš„æ•…äº‹è®²èµ·æ¥å¾ˆå¿«ã€‚
- en: Functional programming breaks down an application into a set of functions. Ideally,
    functions only take inputs and produce outputs and have no internal state that
    affects the output produced for a given input.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: å‡½æ•°å¼ç¼–ç¨‹å°†åº”ç”¨ç¨‹åºåˆ†è§£ä¸ºä¸€ç»„å‡½æ•°ã€‚ç†æƒ³æƒ…å†µä¸‹ï¼Œå‡½æ•°åªæ¥æ”¶è¾“å…¥å¹¶äº§ç”Ÿè¾“å‡ºï¼Œå¹¶ä¸”æ²¡æœ‰å½±å“ç»™å®šè¾“å…¥äº§ç”Ÿçš„è¾“å‡ºçš„å†…éƒ¨çŠ¶æ€ã€‚
- en: In that sense, the QAOA algorithm is a function that solves a `problem` by `optimize`ing
    a set of `params`. In other words, we aim to find the best values for these `params`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ä»è¿™ä¸ªæ„ä¹‰ä¸Šè®²ï¼ŒQAOAç®—æ³•æ˜¯ä¸€ä¸ªé€šè¿‡`optimize`ä¸€ç»„`params`æ¥è§£å†³`problem`çš„å‡½æ•°ã€‚æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬çš„ç›®æ ‡æ˜¯æ‰¾åˆ°è¿™äº›`params`çš„æœ€ä½³å€¼ã€‚
- en: To decide which `params` are best, we `assess` them based on the result we obtain
    from `compute` ing a (quantum) `circuit` that uses these `params` to encode the
    problem (`problem_circuit`) and its solution (`ansatz_circuit`).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†å†³å®šå“ªäº›`params`æœ€ä½³ï¼Œæˆ‘ä»¬æ ¹æ®ä»`compute`å¾—åˆ°çš„ç»“æœæ¥`assess`è¿™äº›`params`ï¼Œè¯¥ç»“æœæ¥è‡ªä½¿ç”¨è¿™äº›`params`ç¼–ç é—®é¢˜ï¼ˆ`problem_circuit`ï¼‰åŠå…¶è§£å†³æ–¹æ¡ˆï¼ˆ`ansatz_circuit`ï¼‰çš„ï¼ˆé‡å­ï¼‰`circuit`ã€‚
- en: This is what Qiskitâ€™s description refers to as a **variational algorithm.**
    It uses a classical optimization algorithm that makes queries to a quantum computer.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°±æ˜¯Qiskitæè¿°ä¸­æåˆ°çš„**å˜åˆ†ç®—æ³•**ã€‚å®ƒä½¿ç”¨ä¸€ç§ç»å…¸ä¼˜åŒ–ç®—æ³•æ¥å‘é‡å­è®¡ç®—æœºå‘å‡ºæŸ¥è¯¢ã€‚
- en: And this is the code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°±æ˜¯ä»£ç ã€‚
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Pretty neat, isnâ€™t it?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸å½“ä¸é”™ï¼Œä¸æ˜¯å—ï¼Ÿ
- en: Letâ€™s proceed to the innermost function, `to_circuit`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ç»§ç»­æ·±å…¥åˆ°æœ€å†…å±‚çš„å‡½æ•°`to_circuit`ã€‚
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This function takes the `problem` and the `params`. We use the size of the `problem`
    to determine the number of quantum bits (qubits) in our quantum circuit.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªå‡½æ•°æ¥æ”¶`problem`å’Œ`params`ã€‚æˆ‘ä»¬ä½¿ç”¨`problem`çš„å¤§å°æ¥ç¡®å®šé‡å­ç”µè·¯ä¸­é‡å­æ¯”ç‰¹ï¼ˆqubitsï¼‰çš„æ•°é‡ã€‚
- en: A qubit is the basic unit of computation in a quantum computer. Even though
    its internal state is pretty complicated, when you look at it, it is either 0
    or 1 â€” just like a regular bit.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªé‡å­æ¯”ç‰¹æ˜¯é‡å­è®¡ç®—æœºä¸­çš„åŸºæœ¬è®¡ç®—å•ä½ã€‚å°½ç®¡å…¶å†…éƒ¨çŠ¶æ€éå¸¸å¤æ‚ï¼Œä½†å½“ä½ æŸ¥çœ‹å®ƒæ—¶ï¼Œå®ƒè¦ä¹ˆæ˜¯0ï¼Œè¦ä¹ˆæ˜¯1â€”â€”å°±åƒæ™®é€šçš„æ¯”ç‰¹ä¸€æ ·ã€‚
- en: We start with applying the Hadamard gate (`h`) to all qubits. This puts the
    qubits into a state where they are equally likely to result in 0 and 1.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä»å¯¹æ‰€æœ‰é‡å­æ¯”ç‰¹åº”ç”¨Hadamardé—¨ï¼ˆ`h`ï¼‰å¼€å§‹ã€‚è¿™å°†é‡å­æ¯”ç‰¹ç½®äºä¸€ä¸ªçŠ¶æ€ï¼Œå…¶ä¸­å®ƒä»¬æœ‰ç›¸ç­‰çš„å¯èƒ½æ€§äº§ç”Ÿ0æˆ–1ã€‚
- en: Then, we append two sub-circuits using the functions `problem_circuit` and `ansatz_circuit`.
    This is what Qiskitâ€™s explanation refers to as *â€œthe unitary U(Î²,Î³) has a specific
    form and is composed of two unitaries U(Î²) and U(Î³)...â€*
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œæˆ‘ä»¬ä½¿ç”¨`problem_circuit`å’Œ`ansatz_circuit`å‡½æ•°é™„åŠ ä¸¤ä¸ªå­ç”µè·¯ã€‚è¿™å°±æ˜¯Qiskitè§£é‡Šä¸­æåˆ°çš„*â€œå•ä½çŸ©é˜µU(Î²,Î³)å…·æœ‰ç‰¹å®šçš„å½¢å¼ï¼Œå¹¶ç”±ä¸¤ä¸ªå•ä½çŸ©é˜µU(Î²)å’ŒU(Î³)ç»„æˆâ€¦â€¦â€*
- en: The first function `problem_circuit` adds a quantum circuit representing the
    problem we aim to solve.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬ä¸€ä¸ªå‡½æ•°`problem_circuit`æ·»åŠ äº†ä¸€ä¸ªé‡å­ç”µè·¯ï¼Œè¡¨ç¤ºæˆ‘ä»¬æƒ³è¦è§£å†³çš„é—®é¢˜ã€‚
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this case, we loop through all `relations` in our `problem`. Apparently,
    we expect a `relation` to consist of a pair of integer values (`i, j`). We apply
    the `rzz` gate on the two qubits at these positions. The `rzz` gate is a parameterized
    (by parameter `gamma`) rotation around the ZZ-axis of a two-qubit system.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬éå†`problem`ä¸­çš„æ‰€æœ‰`relations`ã€‚æ˜¾ç„¶ï¼Œæˆ‘ä»¬æœŸæœ›ä¸€ä¸ª`relation`ç”±ä¸€å¯¹æ•´æ•°å€¼ï¼ˆ`i, j`ï¼‰ç»„æˆã€‚æˆ‘ä»¬åœ¨è¿™äº›ä½ç½®çš„ä¸¤ä¸ªé‡å­æ¯”ç‰¹ä¸Šåº”ç”¨`rzz`é—¨ã€‚`rzz`é—¨æ˜¯ä¸€ä¸ªå‚æ•°åŒ–ï¼ˆç”±å‚æ•°`gamma`ï¼‰çš„æ—‹è½¬é—¨ï¼Œç»•ç€ä¸¤ä¸ªé‡å­æ¯”ç‰¹ç³»ç»Ÿçš„ZZè½´æ—‹è½¬ã€‚
- en: The second function `ansatz_circuit` adds a quantum circuit representing the
    solution to our problem.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬äºŒä¸ªå‡½æ•°`ansatz_circuit`æ·»åŠ äº†ä¸€ä¸ªé‡å­ç”µè·¯ï¼Œè¡¨ç¤ºæˆ‘ä»¬é—®é¢˜çš„è§£å†³æ–¹æ¡ˆã€‚
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This time, we loop through all parts of our problem and apply the `rx` gate
    on the respective qubit. This is a parameterized (by parameter `beta`) rotation
    around the X-axis of a qubit.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸€æ¬¡ï¼Œæˆ‘ä»¬éå†é—®é¢˜çš„æ‰€æœ‰éƒ¨åˆ†ï¼Œå¹¶åœ¨ç›¸åº”çš„é‡å­æ¯”ç‰¹ä¸Šåº”ç”¨`rx`é—¨ã€‚è¿™æ˜¯ä¸€ä¸ªä»¥å‚æ•°`beta`ä¸ºå‚æ•°çš„ç»•Xè½´çš„æ—‹è½¬ã€‚
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Essentially, these circuits use the two `params` (called `beta` and `gamma`)
    to create a quantum circuit that produces a particular quantum state that Qiskit
    describes vividly as **|ğœ“(ğ›½,ğ›¾)âŸ©**. Here, ğœ“ (â€œpsiâ€) is a placeholder for a quantum
    state. ğ›½ and ğ›¾ are the parameters that define this state.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬è´¨ä¸Šï¼Œè¿™äº›ç”µè·¯ä½¿ç”¨ä¸¤ä¸ª`params`ï¼ˆç§°ä¸º`beta`å’Œ`gamma`ï¼‰æ¥åˆ›å»ºä¸€ä¸ªé‡å­ç”µè·¯ï¼Œè¯¥ç”µè·¯äº§ç”ŸQiskitç”ŸåŠ¨æè¿°çš„ç‰¹å®šé‡å­æ€**|ğœ“(ğ›½,ğ›¾)âŸ©**ã€‚è¿™é‡Œï¼Œğœ“ï¼ˆâ€œpsiâ€ï¼‰æ˜¯é‡å­æ€çš„å ä½ç¬¦ã€‚ğ›½å’Œğ›¾æ˜¯å®šä¹‰æ­¤çŠ¶æ€çš„å‚æ•°ã€‚
- en: This quantum circuit creates a state that could result in any value, good or
    bad. Of course, we would prefer to create meaningful results. Therefore, we need
    a measure of â€œgoodness.â€ Thatâ€™s the purpose of the `assess` function.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªé‡å­ç”µè·¯åˆ›å»ºäº†ä¸€ä¸ªçŠ¶æ€ï¼Œå¯èƒ½äº§ç”Ÿä»»ä½•å€¼ï¼Œæ— è®ºå¥½åã€‚å½“ç„¶ï¼Œæˆ‘ä»¬å¸Œæœ›ç”Ÿæˆæœ‰æ„ä¹‰çš„ç»“æœã€‚å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªâ€œå¥½åâ€åº¦é‡ã€‚è¿™å°±æ˜¯`assess`å‡½æ•°çš„ç›®çš„ã€‚
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Given our `problem`, we calculate the `performance` of a result that we obtained
    from executing the quantum circuit. We look at the `relations` inside the `problem`
    definition and decrease (note lower is better here) the performance if the qubits
    representing this `relation` are not equal (`solution[i] != solution[j]`). Remember,
    a qubit either results in 0 or 1\. So, `solution[i]` and `solution[j]` are either
    0 or 1.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: æ ¹æ®æˆ‘ä»¬çš„`problem`ï¼Œæˆ‘ä»¬è®¡ç®—ä»æ‰§è¡Œé‡å­ç”µè·¯å¾—åˆ°çš„ç»“æœçš„`performance`ã€‚æˆ‘ä»¬æŸ¥çœ‹`problem`å®šä¹‰ä¸­çš„`relations`ï¼Œå¹¶åœ¨é‡å­æ¯”ç‰¹è¡¨ç¤ºçš„`relation`ä¸ç›¸ç­‰æ—¶ï¼ˆ`solution[i]
    != solution[j]`ï¼‰é™ä½ï¼ˆæ³¨æ„ï¼Œè¿™é‡Œè¾ƒä½ä¸ºæ›´å¥½ï¼‰æ€§èƒ½ã€‚è®°ä½ï¼Œé‡å­æ¯”ç‰¹çš„ç»“æœæ˜¯0æˆ–1ã€‚æ‰€ä»¥ï¼Œ`solution[i]`å’Œ`solution[j]`è¦ä¹ˆæ˜¯0ï¼Œè¦ä¹ˆæ˜¯1ã€‚
- en: Now, with the ability to create circuits and assess their results, we can feed
    a classical optimization algorithm. This algorithm repeatedly evaluates different
    values and their results, based on which it moves towards values that promise
    better results.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œé€šè¿‡åˆ›å»ºç”µè·¯å¹¶è¯„ä¼°å…¶ç»“æœï¼Œæˆ‘ä»¬å¯ä»¥è¾“å…¥ä¸€ä¸ªç»å…¸ä¼˜åŒ–ç®—æ³•ã€‚è¿™ä¸ªç®—æ³•é‡å¤è¯„ä¼°ä¸åŒçš„å€¼åŠå…¶ç»“æœï¼Œå¹¶åŸºäºæ­¤å‘äº§ç”Ÿæ›´å¥½ç»“æœçš„å€¼ç§»åŠ¨ã€‚
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'So, letâ€™s look at the structure of the problem. We used two characteristics
    of it: `size` and `relations`. So, letâ€™s create a `class` to hold these data.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: é‚£ä¹ˆï¼Œè®©æˆ‘ä»¬çœ‹çœ‹é—®é¢˜çš„ç»“æ„ã€‚æˆ‘ä»¬ä½¿ç”¨äº†å®ƒçš„ä¸¤ä¸ªç‰¹å¾ï¼š`size`å’Œ`relations`ã€‚å› æ­¤ï¼Œè®©æˆ‘ä»¬åˆ›å»ºä¸€ä¸ª`class`æ¥å­˜å‚¨è¿™äº›æ•°æ®ã€‚
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Finally, we need to formulate the instance of our problem and feed it into the
    `qaoa` algorithm.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œæˆ‘ä»¬éœ€è¦åˆ¶å®šæˆ‘ä»¬é—®é¢˜çš„å®ä¾‹å¹¶å°†å…¶è¾“å…¥åˆ°`qaoa`ç®—æ³•ä¸­ã€‚
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We define the problem to consist of three nodes (`0, 1, 2`) and a couple of
    relations. The nodes `0, 1` and `1, 2` are connected. The following listing denotes
    the output.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å®šä¹‰é—®é¢˜ç”±ä¸‰ä¸ªèŠ‚ç‚¹ï¼ˆ`0, 1, 2`ï¼‰å’Œå‡ ä¸ªå…³ç³»ç»„æˆã€‚èŠ‚ç‚¹`0, 1`å’Œ`1, 2`æ˜¯è¿æ¥çš„ã€‚ä»¥ä¸‹åˆ—è¡¨è¡¨ç¤ºè¾“å‡ºã€‚
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `nfev` denotes the number of iterations. And most importantly, `x` represents
    the `params` values that produced the best results.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`nfev`è¡¨ç¤ºè¿­ä»£æ¬¡æ•°ã€‚æœ€é‡è¦çš„æ˜¯ï¼Œ`x`è¡¨ç¤ºäº§ç”Ÿæœ€ä½³ç»“æœçš„`params`å€¼ã€‚'
- en: To see what these values mean, we feed these values back into the circuit and
    look at the result.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: è¦äº†è§£è¿™äº›å€¼çš„æ„ä¹‰ï¼Œæˆ‘ä»¬å°†è¿™äº›å€¼åé¦ˆåˆ°ç”µè·¯ä¸­å¹¶è§‚å¯Ÿç»“æœã€‚
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![](../Images/3a6ff4cbb0e450f344ca2432af9e16e4.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3a6ff4cbb0e450f344ca2432af9e16e4.png)'
- en: Image by author
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œè€…æä¾›çš„å›¾ç‰‡
- en: 'The output shows that two solutions occur more frequently: `010` and `101`.
    So, these denote the solution to the problem specified.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: è¾“å‡ºæ˜¾ç¤ºä¸¤ä¸ªè§£å†³æ–¹æ¡ˆå‡ºç°å¾—æ›´é¢‘ç¹ï¼š`010`å’Œ`101`ã€‚å› æ­¤ï¼Œè¿™äº›è¡¨ç¤ºäº†æŒ‡å®šé—®é¢˜çš„è§£å†³æ–¹æ¡ˆã€‚
- en: When we look back into `assess` function, we see that we value each `relation`
    as `-1` if the two connected nodes have different values. Further, we defined
    `0, 1` and `1, 2` to be connected.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æˆ‘ä»¬å›é¡¾`assess`å‡½æ•°æ—¶ï¼Œæˆ‘ä»¬çœ‹åˆ°å¦‚æœä¸¤ä¸ªè¿æ¥çš„èŠ‚ç‚¹å…·æœ‰ä¸åŒçš„å€¼ï¼Œæˆ‘ä»¬å°†æ¯ä¸ª`relation`çš„å€¼å®šä¸º`-1`ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬å®šä¹‰äº†`0, 1`å’Œ`1,
    2`ä¸ºè¿æ¥çš„ã€‚
- en: Thus, the best solutions are those where these connected nodes have different
    values. And these are `010` and `101`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæœ€ä½³è§£å†³æ–¹æ¡ˆæ˜¯é‚£äº›è¿æ¥èŠ‚ç‚¹å…·æœ‰ä¸åŒå€¼çš„æ–¹æ¡ˆã€‚è¿™äº›æ˜¯`010`å’Œ`101`ã€‚
- en: This problem is known as Max-Cut. It is the same problem solved in Qiskitâ€™s
    example and could be considered the â€œHello Worldâ€ of combinatorial optimization.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªé—®é¢˜è¢«ç§°ä¸ºMax-Cutã€‚è¿™æ˜¯Qiskitç¤ºä¾‹ä¸­è§£å†³çš„ç›¸åŒé—®é¢˜ï¼Œå¯ä»¥è¢«è®¤ä¸ºæ˜¯ç»„åˆä¼˜åŒ–çš„â€œHello Worldâ€ã€‚
- en: Conclusion
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç»“è®º
- en: This post explains the essential parts of the Quantum Approximate Optimization
    Algorithm (QAOA). Even though it is neither the first nor the only explanation,
    it does not require you to study mathematics first.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬æ–‡è§£é‡Šäº†é‡å­è¿‘ä¼¼ä¼˜åŒ–ç®—æ³•ï¼ˆQAOAï¼‰çš„åŸºæœ¬éƒ¨åˆ†ã€‚è™½ç„¶è¿™ä¸æ˜¯ç¬¬ä¸€ä¸ªä¹Ÿä¸æ˜¯å”¯ä¸€çš„è§£é‡Šï¼Œä½†å®ƒä¸è¦æ±‚ä½ å…ˆå­¦ä¹ æ•°å­¦ã€‚
- en: A non-mathematical explanation has quite a few advantages.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: éæ•°å­¦æ€§çš„è§£é‡Šæœ‰ç›¸å½“å¤šçš„ä¼˜ç‚¹ã€‚
- en: It is much more accessible to most of us.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¿™å¯¹äºæˆ‘ä»¬å¤§å¤šæ•°äººæ¥è¯´è¦å®¹æ˜“å¾—å¤šã€‚
- en: It is hands-on. We directly solved a problem with it.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€é—¨å®è·µè¯¾ç¨‹ã€‚æˆ‘ä»¬ç›´æ¥ç”¨å®ƒè§£å†³äº†ä¸€ä¸ªé—®é¢˜ã€‚
- en: You can see how the parts of the algorithm fit together.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä½ å¯ä»¥çœ‹åˆ°ç®—æ³•çš„å„ä¸ªéƒ¨åˆ†å¦‚ä½•é…åˆåœ¨ä¸€èµ·ã€‚
- en: Do you want to get started with Quantum Machine Learning? Have a look at [**Hands-On
    Quantum Machine Learning With Python**](https://www.pyqml.com/volume1?provider=medium&origin=troubleunderstanding)**.**
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: æƒ³è¦å¼€å§‹é‡å­æœºå™¨å­¦ä¹ å—ï¼Ÿçœ‹çœ‹[**ç”¨ Python å®è·µé‡å­æœºå™¨å­¦ä¹ **](https://www.pyqml.com/volume1?provider=medium&origin=troubleunderstanding)**ã€‚**
- en: '![](../Images/c3892c668b9d47f57e47f1e6d80af7b6.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c3892c668b9d47f57e47f1e6d80af7b6.png)'
- en: Get the first three chapters [for free](https://www.pyqml.com/volume1?provider=medium&origin=troubleunderstanding).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: å…è´¹è·å–å‰ä¸‰ç«  [ç‚¹å‡»è¿™é‡Œ](https://www.pyqml.com/volume1?provider=medium&origin=troubleunderstanding)ã€‚
- en: 'The brand-new **Volume 2: Combinatorial Optimization** is all about how to
    solve optimization problems using the Variational Quantum Eigensolver and the
    **Quantum Approximate Optimization Algorithm**.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: å…¨æ–°**ç¬¬2å·ï¼šç»„åˆä¼˜åŒ–**å®Œå…¨è®²è§£äº†å¦‚ä½•ä½¿ç”¨å˜åˆ†é‡å­æœ¬å¾æ±‚è§£å™¨å’Œ**é‡å­è¿‘ä¼¼ä¼˜åŒ–ç®—æ³•**æ¥è§£å†³ä¼˜åŒ–é—®é¢˜ã€‚
- en: '[Claim your copy now](https://www.pyqml.com/volume2?provider=medium&origin=troubleunderstanding).'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[ç«‹å³ç´¢å–æ‚¨çš„å‰¯æœ¬](https://www.pyqml.com/volume2?provider=medium&origin=troubleunderstanding)ã€‚'
- en: '![](../Images/301b7c95ad0fe4b0dcbb7e3cf0fdc708.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/301b7c95ad0fe4b0dcbb7e3cf0fdc708.png)'
