- en: 'Setting up Python Projects: Part VI'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://towardsdatascience.com/setting-up-python-projects-part-vi-cbdbf28eff53](https://towardsdatascience.com/setting-up-python-projects-part-vi-cbdbf28eff53)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Mastering the Art of Python Project Setup: A Step-by-Step Guide'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://johschmidt42.medium.com/?source=post_page-----cbdbf28eff53--------------------------------)[![Johannes
    Schmidt](../Images/e0cacf7ff37f339a9bf8bd33c7c83a4d.png)](https://johschmidt42.medium.com/?source=post_page-----cbdbf28eff53--------------------------------)[](https://towardsdatascience.com/?source=post_page-----cbdbf28eff53--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----cbdbf28eff53--------------------------------)
    [Johannes Schmidt](https://johschmidt42.medium.com/?source=post_page-----cbdbf28eff53--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ¬∑Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----cbdbf28eff53--------------------------------)
    ¬∑26 min read¬∑Apr 10, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1093eac93ddb53f3ce2570a3fa7c32bf.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Amira El Fohail](https://unsplash.com/@amirasartistry?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Whether you‚Äôre a seasoned developer or just getting started with üêç **Python**,
    it‚Äôs important to know how to build robust and maintainable projects. This tutorial
    will guide you through the process of setting up a Python project using some of
    the most popular and effective tools in the industry. You will learn how to use
    [GitHub](https://github.com/) and [GitHub Actions](https://github.com/features/actions)
    for version control and continuous integration, as well as other tools for testing,
    documentation, packaging and distribution. The tutorial is inspired by resources
    such as [Hypermodern Python](https://medium.com/@cjolowicz/hypermodern-python-d44485d9d769)
    and [Best Practices for a new Python project](https://mitelman.engineering/blog/python-best-practice/automating-python-best-practices-for-a-new-project/).
    However, this is not the only way to do things and you might have different preferences
    or opinions. The tutorial is intended to be beginner-friendly but also cover some
    advanced topics. In each section, you will automate some tasks and add badges
    to your project to show your progress and achievements.
  prefs: []
  type: TYPE_NORMAL
- en: The repository for this series can be found at [github.com/johschmidt42/python-project-johannes](https://github.com/johschmidt42/python-project-johannes)
  prefs: []
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**OS**: Linux, Unix, macOS, Windows (WSL2 with e.g. Ubuntu 20.04 LTS)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tools**: python3.10, bash, git, tree'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version Control System (VCS) Host**: [GitHub](https://github.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous Integration (CI) Tool**: [GitHub Actions](https://github.com/features/actions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is expected that you are familiar with the versioning control system (VCS)
    [git](https://git-scm.com/). If not, here‚Äôs a refresher for you: [Introduction
    to Git](https://realpython.com/python-git-github-intro/)'
  prefs: []
  type: TYPE_NORMAL
- en: Commits will be based on [best practices for git commits](https://deepsource.io/blog/git-best-practices/)
    & [Conventional commits](https://www.conventionalcommits.org/en/v1.0.0/). There
    is the [conventional commit plugin](https://plugins.jetbrains.com/plugin/13389-conventional-commit)
    for PyCharm or a [VSCode Extension](https://github.com/vivaxy/vscode-conventional-commits)
    that help you to write commits in this format.
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Part I (GitHub, IDE)](https://johschmidt42.medium.com/setting-up-python-projects-part-i-408603868c08)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Part II (Formatting, Linting, CI)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Part III (Testing, CI)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Part IV (Documentation, CI/CD)](https://johschmidt42.medium.com/setting-up-python-projects-part-iv-82059eba4ca4)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Part V (Versioning & Releases, CI/CD)](https://medium.com/@johschmidt42/setting-up-python-projects-part-v-206df3c1e3d3)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part VI (Containerisation, Docker, CI/CD)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containerisation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dockerfile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker stages (*base, builder, production*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container registries (*ghcr.io*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker push
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CI (*build.yml & build_and_push.yml*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Badge (*Build*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bonus (*trivy*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this article, we will explore the concept of **containerisation**, its benefits,
    and how it can be used with **Docker** to create and manage containerised applications.
    We will use **GitHub Actions** to continuously build Docker images & upload them
    to our repository when a new version is released.
  prefs: []
  type: TYPE_NORMAL
- en: Containerisation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containerisation is a modern technology that has revolutionised the way software
    applications are developed, deployed, and managed. It has gained widespread adoption
    in recent years due to its ability to solve some of the biggest challenges in
    software development and deployment.
  prefs: []
  type: TYPE_NORMAL
- en: In simple terms, containerisation is a process of packaging an application and
    all its dependencies into a single **container**. This container is a lightweight,
    portable, and self-sufficient unit that can be run consistently across different
    computing environments. It provides an isolated environment for the application,
    ensuring that it runs consistently, regardless of the underlying infrastructure.
    It allows developers to create applications that are scalable, portable, and easy
    to manage. Additionally, containers provide an extra layer of security by isolating
    applications from the host system. If you hear someone say the phrase ‚Äú*it works
    on my computer*‚Äù, it is no longer valid because you can and should test your application
    in a Docker container. This ensures that it works consistently across different
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, containerisation is a powerful technology that allows developers
    to create containerised applications that are reliable, efficient, and easy to
    manage, allowing them to focus on developing great software.
  prefs: []
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker is a popular containerisation platform that allows developers to create,
    deploy, and run containerised applications. It provides a range of tools and services
    that make it easy to package and deploy applications in a containerised format.
    With Docker, developers can create, test, and deploy applications in a matter
    of minutes, instead of days or weeks.
  prefs: []
  type: TYPE_NORMAL
- en: To create such an containerised application with docker we need to
  prefs: []
  type: TYPE_NORMAL
- en: Build a **Docker image** from a **Dockerfile**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **container** from the Docker image
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For this we will use the docker CLI.
  prefs: []
  type: TYPE_NORMAL
- en: Dockerfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Dockerfile is a text file that contains all commands needed to build a given
    image. It adheres to a specific format and set of instructions which you can find
    about [here](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal for this section here is to create a Dockerfile that **builds a wheel
    of our Python package**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This Dockerfile is essentially a set of instructions that tells Docker how to
    build a container for a Python application. It starts with a base image `python:3.10-slim`
    which is a slim version of the Python 3.10 image that has already been pre-built
    with some basic libraries and dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: The first instruction `WORKDIR /app` sets the working directory to `/app` inside
    the container where the application will be placed.
  prefs: []
  type: TYPE_NORMAL
- en: The next instruction `ENV POETRY_VERSION=1.2.0` sets an environment variable
    called `POETRY_VERSION` to `1.2.0` which will be used in the next command to install
    the Poetry package manager.
  prefs: []
  type: TYPE_NORMAL
- en: The `RUN pip install "poetry==$POETRY_VERSION"` command installs the Poetry
    package manager inside the container, which is used to manage dependencies for
    Python applications.
  prefs: []
  type: TYPE_NORMAL
- en: The next instruction `COPY ["pyproject.toml", "poetry.lock", "README.md", "./"]`
    copies the project files (including the `pyproject.toml`, `poetry.lock` and `README.md`)
    to the container.
  prefs: []
  type: TYPE_NORMAL
- en: The `README.md` file is required as there is a reference in the pyproject.toml.
    Without it we wouldn‚Äôt be able to build a wheel.
  prefs: []
  type: TYPE_NORMAL
- en: The instruction `COPY ["src/", "src/"]` copies the source code of the application
    to the container.
  prefs: []
  type: TYPE_NORMAL
- en: The `RUN poetry build --format wheel` command builds a [Python wheel](https://realpython.com/python-wheels/)
    package for the Python application using the `poetry.lock` file and the source
    code of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last instruction `RUN pip install dist/*.whl` installs the package
    by using `pip` and installs the generated `.whl` package file which is located
    inside the `dist` directory.
  prefs: []
  type: TYPE_NORMAL
- en: '**In summary**, this Dockerfile sets up a container with Python 3.10 and Poetry
    installed, copies the application source code and dependencies, builds a package
    wheel and installs it.'
  prefs: []
  type: TYPE_NORMAL
- en: '**This will not yet run the application**. But don‚Äôt worry, we will update
    it in the next sections. We must first understand the flow of using Docker.'
  prefs: []
  type: TYPE_NORMAL
- en: Docker image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have created a **Dockerfile** that contains the instructions to build a Docker
    image. Why do we need a **Docker image** again**?** Because itallows us to build
    D**ocker containers**!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs run the **docker build** command to create our image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This command is used to build a Docker image from a Dockerfile and tag it with
    a specified name and version. Let‚Äôs break down the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker build`: This is the command used to build Docker images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--file Dockerfile`: This option specifies the path and name of the Dockerfile
    used for building the image. In this case, it is simply named `Dockerfile`, so
    it''s using the default name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--tag project:latest`: This option specifies the name and version of the image
    to be created. In this case, the image name is `project` and its version is `latest`.
    `project` is the name given to the image, and `latest` is the version number.
    You can replace `project` and `latest` with the name and version of your choice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.`: This specifies the build context, which is the location of the files used
    for building the image. In this case, `.` refers to the current directory where
    the command is executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, when this command is executed, Docker reads the Dockerfile in the current
    directory and uses it to build a new image named `project:latest`. We can find
    additional information about the resulting image (& other images) by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Our image is **271 mb** in size. The size will be reduced later on.
  prefs: []
  type: TYPE_NORMAL
- en: Docker container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can create/run a Docker container from a Docker image using the `docker
    run` command. The command requires one parameter which is the name of the image.
    For example, if your image is named `myimage`, you can run it with the following
    [command](https://docs.docker.com/language/python/run-containers/): `docker run
    myimage`'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run our application like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'it will open an Python terminal (you can close the session with **CTRL + D**
    or **CMD + D**; The `-it` option is used to run a container in interactive mode
    with a pseudo-TTY (terminal emulation). This allows you to interact with the container‚Äôs
    shell and see its output in real-time. The `-rm` option is used to remove the
    container automatically when it exits.):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Why does it open a Python session? That is, because the entrypoint of the docker
    image defaults to the Python interpreter in the standard **python:3.10-slim**
    image. If we want to have a look inside the container, we must overwrite the entrypoint.
    Because **bash** is installed by default on this build, we can run the docker
    container and get inside it with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: So we overwrite the entrypoint with **/bin/bash**.
  prefs: []
  type: TYPE_NORMAL
- en: 'And now we can check the content that is inside our container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can check the installed packages with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Great, we can jump inside a container, which is really good for troubleshooting.
    But how do we make it **run our application?** And where is our app installed?
    By default, packages can be found in the **site-packages** directory of the Python
    installation. To find that information we can use the **pip show** command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Since **uvicorn**, our ASGI server implementation, is installed by default,
    we can **cd** into */usr/local/lib/python3.10/site-packages/example_app*
  prefs: []
  type: TYPE_NORMAL
- en: 'and run the application with the **uvicorn command**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: where `app:app` follows the pattern `<file_name>:<variable_name>` .
  prefs: []
  type: TYPE_NORMAL
- en: 'The application runs on **port 80** within the docker container with **1 worker**.
    To be accessible on the host (your machine), we need to expose the container port
    and publish it to the host. This can be done by adding adding the `--expose` and
    `--publish` flag to the docker run command. Alternatevily, we can have the container
    expose a certain port by defining this in the **Dockerfile**. We will do this
    in a second. Before that, here‚Äôs what we‚Äôre gonna do:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our application can be found in the site-packages directory. This requires
    us to change the directory before we can run the `uvicorn app:app` command. If
    we want to avoid changing the directory, we can instead create a file that imports
    the app for us. Here‚Äôs an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `main.py` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'where we import the application in a `main.py` so that uvicorn can use it.
    If we now copy this file to our `/app` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: we can run the app with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Great. Now let‚Äôs set this command as an **entrypoint** when starting a container.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We now copy the `main.py` file to the `/app` directory. The `EXPOSE` instruction
    informs Docker that the container listens on the specified network ports at runtime.
    In this case, it is exposing **port 80**.
  prefs: []
  type: TYPE_NORMAL
- en: The `CMD` instruction specifies what command to run within the container. Here,
    it is running the command `uvicorn main:app --host 0.0.0.0 --port 80 --workers
    1`. This command starts a uvicorn server with the `main:app` application, listening
    on host `0.0.0.0` and port `80`, with `1` worker.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then run a container with the **docker run** command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `-p` flag in the `docker run` command is used to publish a container‚Äôs port
    to the host. In this case, it is mapping port `9000` on the host to port `80`
    on the container. This means that any traffic sent to port `9000` on the host
    will be forwarded to port `80` on the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'We see that our application that is running in the container can be reached:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e59351dbabffba38db50b6de0d405edf.png)'
  prefs: []
  type: TYPE_IMG
- en: fastAPI application running in a Docker container ‚Äî Image by author
  prefs: []
  type: TYPE_NORMAL
- en: '**Important remark**: Instead of uvicorn, I recommend using [**gunicorn**](https://gunicorn.org/)
    for production builds! For completeness, this is how the Dockerfile would look
    like instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: What‚Äôs the difference between these two?
  prefs: []
  type: TYPE_NORMAL
- en: Uvicorn is an ASGI server that supports the ASGI protocol. It is built on [uvloop](https://uvloop.readthedocs.io/)
    and [httptools](https://pypi.org/project/httptools/) and is known for its performance
    benefits. [However, its capabilities as a process manager leave much to be desired](https://stackoverflow.com/questions/66362199/what-is-the-difference-between-uvicorn-and-gunicornuvicorn).
  prefs: []
  type: TYPE_NORMAL
- en: Gunicorn, on the other hand, is a mature and fully-featured server and process
    manager. [It is a pre-fork worker model ported from Ruby‚Äôs Unicorn project and
    is broadly compatible with various web frameworks](https://stackshare.io/stackups/gunicorn-vs-uvicorn).
  prefs: []
  type: TYPE_NORMAL
- en: Docker stages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker stages are a feature that allows you to create multiple stages in your
    Dockerfile. Each stage can have its own **base image** and set of instructions.
    You can selectively copy artifacts from one stage to another, leaving behind everything
    you don‚Äôt want in a target stage. [This feature is useful because it allows you
    to optimize your Docker images by reducing their size and complexity](https://docs.docker.com/build/building/multi-stage/).
  prefs: []
  type: TYPE_NORMAL
- en: 'With Docker stages we can (and should!) optimize our Docker image. So what
    we want to achieve is this:'
  prefs: []
  type: TYPE_NORMAL
- en: poetry should not be in the production build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the production build should only contain as little as necessary to run the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And this is how we‚Äôre going to do it: We create a clean **base** stage. From
    the base stage we have a **builder** stage that installs poetry and builds the
    wheel. Another stage, **production,** can copy this artifact (.whl file) from
    the build stage and use it. This way we avoid having poetry installed in the production
    build and also limit it to have only the essentials, therby reducing the size
    of the final image.'
  prefs: []
  type: TYPE_NORMAL
- en: About poetry in Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are different strategies that I‚Äôve seen with poetry in combination with
    Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a **virtual environment** and then copying the whole **venv** from
    one stage to another.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating **requirements.txt** files from the **poetry.lock** file and using
    these to pip install the requirements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first case, Poetry is installed when building the image. In the second
    case, poetry is not installed within the docker build but Poetry needs to be used
    to create the requirements.txt files.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, we need Poetry to be installed in some way ‚Äî either in the Docker
    image or on the host that runs the docker build command.
  prefs: []
  type: TYPE_NORMAL
- en: Having Poetry inside Docker will slightly increase the build time while having
    it outside of Docker will require you install Poetry on the host and add additional
    steps for the build process (creating the requirements.txt files from poetry.lock).
    In the context of a Docker build **CI pipeline**, the Poetry installation on the
    host machine could be cached and the build process will be generally faster. Both
    approaches have their advantages and disadvantages, and the best approach will
    depend on your specific needs and preferences.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of this tutorial, I will keep it simple and use the **venv strategy**
    described above**.** So here‚Äôs the new Dockfile with stages (To identiy the different
    stages seperated by the **FROM** statement, I highlited the lines in **bold**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This Dockerfile defines a multi-stage build with three stages: `base`, `builder`,
    and `production`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `base` stage starts from a Python 3.10-slim image and sets the working directory
    to `/app`. It also sets an environment variable to ignore a warning about running
    pip as the root user and updates pip to the latest version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `builder` stage starts from the `base` stage and installs Poetry using pip.
    It then copies the application files and uses Poetry to build a wheel for the
    application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `production` stage starts from the `base` stage again and exposes port 80\.
    It copies the wheel built in the `builder` stage and installs it using pip. It
    also copies the entrypoint of the app and sets the command to run the app using
    uvicorn.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can now re-build our Docker image with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We can specify the stage we would like to build with the `--target` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file size is now **~70 Mb** less, with a total of **197MB**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: And we can run it with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The API will be available under [http://localhost:9000](http://localhost:9000)
    in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e59351dbabffba38db50b6de0d405edf.png)'
  prefs: []
  type: TYPE_IMG
- en: fastAPI application running in a Docker container ‚Äî Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Container registries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A container registry is a repository or collection of repositories used to store
    and access container images. Container registries can support container-based
    application development, often as part of [DevOps](https://realpython.com/learning-paths/python-devops/)
    processes. They can connect directly to container orchestration platforms like
    [Docker and Kubernetes](https://www.redhat.com/en/topics/cloud-native-apps/what-is-a-container-registry).
  prefs: []
  type: TYPE_NORMAL
- en: The most popular container registry is [Docker Hub](https://hub.docker.com/).
    Every Cloud Provider has its own. ACR for Azure, ECR for AWS and many many more.
    GitHub has its own package registry solution called [GitHub Packages](https://github.com/features/packages).
  prefs: []
  type: TYPE_NORMAL
- en: As we‚Äôve done basically everything on GitHub so far, we will use **GitHub Packages**
    in this tutorial.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b0a73063d4391300e8a9464b7428d8fa.png)'
  prefs: []
  type: TYPE_IMG
- en: GitHub Packages ‚Äî Image by author
  prefs: []
  type: TYPE_NORMAL
- en: It has a free tier for a normal user on GitHub. This allows us to use up to
    **500 MB** of storage for our containers. That‚Äôs enough for our application.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e7f3be91fed4338dffe25a8f439b1f19.png)'
  prefs: []
  type: TYPE_IMG
- en: GitHub Packages Pricing with free tier ‚Äî Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Docker push
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `docker push` command is used to **upload** a Docker image to a container
    registry. This allows you to share your images with others or deploy them to different
    environments. The command takes the name of the image you want to push and the
    name of the registry you want to push it to as arguments. You need to be logged
    in to the registry before you can push an image to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to push a Docker image to a container registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tag** (rename) your image with the registry name: `docker tag project:latest
    <registry-name>/<project>:latest`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Log in** to the container registry: `docker login <registry-url>`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Push** your image to the registry: `docker push <registry-name>/<project>:latest`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will push the image to [GitHub Packages](https://github.com/features/packages):'
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GitHub Packages only supports authentication using a personal access token (February,
    2023). But we created a personal access token (PAT) in [Part V](https://medium.com/@johschmidt42/setting-up-python-projects-part-v-206df3c1e3d3),
    so we can use it here as well.
  prefs: []
  type: TYPE_NORMAL
- en: We need to [login to the container registry](https://docs.github.com/en/packages/learn-github-packages/connecting-a-repository-to-a-package)
    with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: It‚Äôs a shell command that uses a pipe to connect two commands. A pipe is a symbol
    (`|`) that redirects the output of one command to the input of another command.
    In this case, the first command is `echo $(CR_PAT)`, which prints the value of
    the CR_PAT variable to the standard output. The second command is `docker login
    ghcr.io -u johschmidt42 --password-stdin`, which logs in to ghcr.io using johschmidt42
    as the username and reading the password from the standard input. By using a pipe,
    the output of the echo command becomes the input of the docker login command,
    which means that the value of the CR_PAT variable is used as the password for
    logging in.
  prefs: []
  type: TYPE_NORMAL
- en: Let‚Äôs add this to our Makefile
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We need to write a little if-else statement in **bash** so that this target
    login requires us to set the **CR_PAT** first.
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows us to login like so now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'For anyone confused by the bash command. Here‚Äôs an explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: The shell command uses an if-else statement to check a condition and execute
    different actions accordingly. The condition is `[ -z "$(CR_PAT)" ]`, which means
    ‚Äúis the CR_PAT variable empty?‚Äù. The `-z` flag tests for zero length. The `$(CR_PAT)`
    part expands the value of the CR_PAT variable inside the brackets. If the condition
    is true, then the action after `then` is executed, which is `echo "CR_PAT is not
    set"`. This prints a message to the standard output. If the condition is false,
    then the action after `else` is executed, which is `echo $(CR_PAT) | docker login
    ghcr.io -u johschmidt42 --password-stdin`. The `\` at the end of each line means
    that the command continues on the next line. The `fi` at the end marks the end
    of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we‚Äôre logged in, we need to rename the docker file so that we can
    push it to the remote registry using the docker tag command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see information about our docker images with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now try to push the image to the registry, it will **fail**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: That‚Äôs because our token does **not have the expected scopes**. The message
    does not tell us which scopes (permissions) it requires but we can find this information
    in the [documentation](https://docs.github.com/en/packages/learn-github-packages/about-permissions-for-github-packages).
  prefs: []
  type: TYPE_NORMAL
- en: 'So we need to add these scopes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**read:packages**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**delete:packages**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/9682e27fb5857d928ec8fe542b048447.png)'
  prefs: []
  type: TYPE_IMG
- en: GH_TOKEN ‚Äî Image by author
  prefs: []
  type: TYPE_NORMAL
- en: 'And now we‚Äôre seeing it being pushed to the container registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In GitHub, under `profile` there is now a docker image in the `packages` tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/25a9b41841631d08d4b4b72b2d989d7f.png)'
  prefs: []
  type: TYPE_IMG
- en: Your profile ‚Äî Image by author
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/13cdc769731c3e98adcb44db40eeebb4.png)'
  prefs: []
  type: TYPE_IMG
- en: GitHub packages ‚Äî Image by author
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on it, allows us to [connect the package to our repository](https://docs.github.com/en/packages/learn-github-packages/connecting-a-repository-to-a-package):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/58796861176d35ba8a3fdc5b6a770cc7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'GitHub packages: Connect Repository ‚Äî Image by author'
  prefs: []
  type: TYPE_NORMAL
- en: 'And now this docker image can be found in the landing page of the repo [github.com/johschmidt42/python-project-johannes](https://github.com/johschmidt42/python-project-johannes):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b2edcc5b423274b3b003ef82b3cf2c1d.png)'
  prefs: []
  type: TYPE_IMG
- en: GitHub Packages Front page ‚Äî image by author
  prefs: []
  type: TYPE_NORMAL
- en: 'Excellent. We have created a Docker Image, pushed it to the remote repository,
    linked it to our current version and now everyone who wants to test our application
    can do so by running the docker pull command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'CI/CD:'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CI/CD stands for Continuous Integration and Continuous Deployment. With Docker
    images, CI/CD can automate the process of building, testing, and deploying images.
    In this tutorial, we‚Äôll focus on continuously building our Docker image and pushing
    it to a remote container registry (CI) whenever there‚Äôs a new version. However,
    we won‚Äôt be deploying the image (CD) in this tutorial (stay tuned for a future
    blog post). Our Docker container will be built when:'
  prefs: []
  type: TYPE_NORMAL
- en: A commit is made to a branch with an open PR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A commit is made to the default branch (main)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new release is created (this will push the image to the container registry)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first action helps us catch bugs early on. The second action enables us
    to create and use a badge in our README.md file. The last action creates a new
    version of the Docker image and pushes it to the container registry. The overall
    flow of actions is summarised here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/209a22eeb95a99285f547c1d8c4d1c1d.png)'
  prefs: []
  type: TYPE_IMG
- en: GitHub Actions Flow ‚Äî Image by author
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs create the `build` pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: This GitHub Actions workflow builds a Docker image. It is triggered when there
    is a **push** or **pull request** to the **main** branch or when the workflow
    is called. The job is named ‚ÄúBuild‚Äù and has two steps. The first step checks out
    the repository using the `actions/checkout` action. The second step builds the
    Docker image by running the `make build` command. That‚Äôs it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/fd3b515554b5a6ab99aa8bef6cf90ad3.png)'
  prefs: []
  type: TYPE_IMG
- en: Workflow run ‚Äî Image by author
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to update the `orchestrator.yml` accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: The orchestrator is triggered when we push to the branch `main` .
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d38ab40f35c7b716ece3e7f38daff267.png)'
  prefs: []
  type: TYPE_IMG
- en: orchestrator.yml ‚Äî image by author
  prefs: []
  type: TYPE_NORMAL
- en: 'To build a new docker image with every **new version** released in our GitHub
    repository, we need to create a new GitHub actions workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: This is a GitHub Actions workflow that builds and pushes a Docker image to the
    GitHub Container Registry (ghcr.io) when a release is published. The job named
    ‚Äúbuild_and_push‚Äù has three steps. The first step checks out the repository using
    the `actions/checkout` action. The second step logs in to the GitHub Container
    Registry using the `docker/login-action`. The third step builds and pushes the
    Docker image using the `docker/build-push-action`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ad45621c6d66fd7de9d92e98106efd2b.png)'
  prefs: []
  type: TYPE_IMG
- en: build_and_push ‚Äî image by author
  prefs: []
  type: TYPE_NORMAL
- en: Please note that, in order to login to GitHub Container Registry using [docker/login-action@v2](https://github.com/docker/login-action),
    we need to provide the secret **GH_TOKEN**, which is the PAT, we defined in [Part
    V](https://medium.com/@johschmidt42/setting-up-python-projects-part-v-206df3c1e3d3).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a brief explanation of the parameters used in the last step [docker/build-push-action@4](https://github.com/docker/build-push-action):'
  prefs: []
  type: TYPE_NORMAL
- en: '`context: .` specifies the build context as the current directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`push: true` specifies that the image should be pushed to the registry after
    it is built.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tags: ghcr.io/${{ github.repository }}:${{ github.ref_name }}` specifies the
    tag for the image. In this case, it is tagged with the name of the repository
    and the branch or tag name that triggered the workflow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`labels:` specifies labels for the image. In this case, it sets labels for
    the source, title, and version of the image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`target: production` specifies the target stage to build in a multi-stage Dockerfile.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`github-token: ${{ secrets.GH_TOKEN }}` specifies the GitHub token to use for
    authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can see our new docker image on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1e486e3903a579d596a11e18564e76b0.png)'
  prefs: []
  type: TYPE_IMG
- en: Images on GitHub ‚Äî image by author
  prefs: []
  type: TYPE_NORMAL
- en: 'Badge:'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this part, we will add a badge to our repo as we‚Äôve done it before in the
    other parts. This time for the **build** pipeline. We can retrieve the badge when
    we click on a *build.yml* workflow run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2254ff4eefb21d7614ed6bb5b9e8d2b0.png)'
  prefs: []
  type: TYPE_IMG
- en: Create a status badge ‚Äî image by author
  prefs: []
  type: TYPE_NORMAL
- en: Create a status badge from the workflow file on GitHub
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6ccdfb3057da98e8f6219e21e1ca646c.png)'
  prefs: []
  type: TYPE_IMG
- en: Copy status badge Markdown ‚Äî Image by author
  prefs: []
  type: TYPE_NORMAL
- en: and select the main branch. The badge markdown can be copied and added to the
    *README.md:*
  prefs: []
  type: TYPE_NORMAL
- en: 'Our landing page of the GitHub now looks like this ‚ù§:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ad2f4bc39f781c797b22d04a748a73a7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fifth badge in README.md: Build ‚Äî Image by author'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to know how this magically shows the current status of the last
    pipeline run in *main*, have a look the commit [statuses API](https://docs.github.com/en/rest/commits/statuses)
    on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: That concludes the core portion of this tutorial! We successfully created a
    **Dockerfile** and used it to build an **Docker image** that enables us to run
    our application in a **Docker container**. Additionally, we implemented a **CI/CD**
    pipeline that automatically builds our Docker images and pushes them to the **container
    registry**. To top it off, we added a badge to our *README.md* file to proudly
    display our functional build pipeline to the world!
  prefs: []
  type: TYPE_NORMAL
- en: That was the last part! Did this tutorial help you to build a Python project
    on GitHub? Any suggestions for improvement? Let me know your thoughts!
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://johschmidt42.medium.com/membership?source=post_page-----cbdbf28eff53--------------------------------)
    [## Join Medium with my referral link - Johannes Schmidt'
  prefs: []
  type: TYPE_NORMAL
- en: Read every story from Johannes Schmidt (and thousands of other writers on Medium).
    Your membership fee directly‚Ä¶
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: johschmidt42.medium.com](https://johschmidt42.medium.com/membership?source=post_page-----cbdbf28eff53--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Bonus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Clean up:'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some useful commands, that you can use when using the Docker CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To stop all containers & remove them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove all unused docker images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Vulnerability scanning in Docker images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vulnerability scanning is a crucial step in ensuring the **security** of your
    docker images. It helps you identify and fix any potential weaknesses or risks
    that could compromise your application or data. One of the tools that can help
    you is [**trivy**](https://github.com/aquasecurity/trivy).
  prefs: []
  type: TYPE_NORMAL
- en: This open-source tool is a simple and fast **vulnerability scanner for docker
    images** that supports multiple formats and sources. I will demonstrate how to
    use it locally. Ideally, you should consider creating a GitHub actions workflow
    that runs whenever you build a docker image!
  prefs: []
  type: TYPE_NORMAL
- en: We first should install **trivy** according to the [documentation](https://aquasecurity.github.io/trivy/v0.43/getting-started/installation/).
    After building the production docker image with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: we can scan the built image with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This will download the latest known vulnerabilites from a database and scan
    the image. The output will be shown in a table `--format table` with only the
    findings that have either CRITICAL or HIGH severity `--severity CRITICAL,HIGH`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'There or **2 OS libraries** with the severity **HIGH**. Both don‚Äôt provide
    a version we can upgrade to (see *Fixed Version* column) in order to fix the vulnerability
    in our docker image. So here‚Äôs how we‚Äôre going to deal with them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**linux-libc-dev**:'
  prefs: []
  type: TYPE_NORMAL
- en: This is a package that is not required for our application to run. So it‚Äôs probably
    best to **uninstall** it!
  prefs: []
  type: TYPE_NORMAL
- en: '**perl-base**'
  prefs: []
  type: TYPE_NORMAL
- en: This OS package provides the Perl interpreter and is required for other libraries
    that our application uses. That means that we cannot uninstall it and we cannot
    fix it. Hence, we must **accept the risk**. Accepting known vulnerabilites should
    be acknowledged and approved by management. We can then add the vunerability,
    e.g. CVE-2023‚Äì31484, to a .*trivyignore* file run the scanner again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the command again (this time including the .*trivyignore* file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'No vulnerabilites of severity HIGH or CRITICAL are reported anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Cheers!
  prefs: []
  type: TYPE_NORMAL
