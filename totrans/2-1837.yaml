- en: 'Setting up Python Projects: Part VI'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '设置 Python 项目: 第六部分'
- en: 原文：[https://towardsdatascience.com/setting-up-python-projects-part-vi-cbdbf28eff53](https://towardsdatascience.com/setting-up-python-projects-part-vi-cbdbf28eff53)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/setting-up-python-projects-part-vi-cbdbf28eff53](https://towardsdatascience.com/setting-up-python-projects-part-vi-cbdbf28eff53)
- en: 'Mastering the Art of Python Project Setup: A Step-by-Step Guide'
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '掌握 Python 项目设置的艺术: 一步一步的指南'
- en: '[](https://johschmidt42.medium.com/?source=post_page-----cbdbf28eff53--------------------------------)[![Johannes
    Schmidt](../Images/e0cacf7ff37f339a9bf8bd33c7c83a4d.png)](https://johschmidt42.medium.com/?source=post_page-----cbdbf28eff53--------------------------------)[](https://towardsdatascience.com/?source=post_page-----cbdbf28eff53--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----cbdbf28eff53--------------------------------)
    [Johannes Schmidt](https://johschmidt42.medium.com/?source=post_page-----cbdbf28eff53--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://johschmidt42.medium.com/?source=post_page-----cbdbf28eff53--------------------------------)[![Johannes
    Schmidt](../Images/e0cacf7ff37f339a9bf8bd33c7c83a4d.png)](https://johschmidt42.medium.com/?source=post_page-----cbdbf28eff53--------------------------------)[](https://towardsdatascience.com/?source=post_page-----cbdbf28eff53--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----cbdbf28eff53--------------------------------)
    [Johannes Schmidt](https://johschmidt42.medium.com/?source=post_page-----cbdbf28eff53--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----cbdbf28eff53--------------------------------)
    ·26 min read·Apr 10, 2023
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·发布于 [Towards Data Science](https://towardsdatascience.com/?source=post_page-----cbdbf28eff53--------------------------------)
    ·阅读时间 26 分钟·2023年4月10日
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/1093eac93ddb53f3ce2570a3fa7c32bf.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1093eac93ddb53f3ce2570a3fa7c32bf.png)'
- en: Photo by [Amira El Fohail](https://unsplash.com/@amirasartistry?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由 [Amira El Fohail](https://unsplash.com/@amirasartistry?utm_source=medium&utm_medium=referral)
    提供，来源于 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: Whether you’re a seasoned developer or just getting started with 🐍 **Python**,
    it’s important to know how to build robust and maintainable projects. This tutorial
    will guide you through the process of setting up a Python project using some of
    the most popular and effective tools in the industry. You will learn how to use
    [GitHub](https://github.com/) and [GitHub Actions](https://github.com/features/actions)
    for version control and continuous integration, as well as other tools for testing,
    documentation, packaging and distribution. The tutorial is inspired by resources
    such as [Hypermodern Python](https://medium.com/@cjolowicz/hypermodern-python-d44485d9d769)
    and [Best Practices for a new Python project](https://mitelman.engineering/blog/python-best-practice/automating-python-best-practices-for-a-new-project/).
    However, this is not the only way to do things and you might have different preferences
    or opinions. The tutorial is intended to be beginner-friendly but also cover some
    advanced topics. In each section, you will automate some tasks and add badges
    to your project to show your progress and achievements.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是经验丰富的开发者还是刚刚开始接触🐍 **Python**，了解如何构建稳健且可维护的项目都是很重要的。本文教程将引导你完成使用一些行业内最受欢迎和有效的工具来设置
    Python 项目的过程。你将学习如何使用 [GitHub](https://github.com/) 和 [GitHub Actions](https://github.com/features/actions)
    进行版本控制和持续集成，以及其他用于测试、文档编写、打包和分发的工具。该教程灵感来源于 [Hypermodern Python](https://medium.com/@cjolowicz/hypermodern-python-d44485d9d769)
    和 [新 Python 项目的最佳实践](https://mitelman.engineering/blog/python-best-practice/automating-python-best-practices-for-a-new-project/)。然而，这并不是唯一的方法，你可能有不同的偏好或意见。教程旨在对初学者友好，同时也涵盖一些高级主题。在每个部分，你将自动化一些任务，并为你的项目添加徽章以展示你的进展和成就。
- en: The repository for this series can be found at [github.com/johschmidt42/python-project-johannes](https://github.com/johschmidt42/python-project-johannes)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本系列的代码库可以在 [github.com/johschmidt42/python-project-johannes](https://github.com/johschmidt42/python-project-johannes)
    找到
- en: Requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求
- en: '**OS**: Linux, Unix, macOS, Windows (WSL2 with e.g. Ubuntu 20.04 LTS)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作系统**: Linux, Unix, macOS, Windows (WSL2，例如 Ubuntu 20.04 LTS)'
- en: '**Tools**: python3.10, bash, git, tree'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工具**: python3.10, bash, git, tree'
- en: '**Version Control System (VCS) Host**: [GitHub](https://github.com/)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本控制系统 (VCS) 主机**: [GitHub](https://github.com/)'
- en: '**Continuous Integration (CI) Tool**: [GitHub Actions](https://github.com/features/actions)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续集成 (CI) 工具**: [GitHub Actions](https://github.com/features/actions)'
- en: 'It is expected that you are familiar with the versioning control system (VCS)
    [git](https://git-scm.com/). If not, here’s a refresher for you: [Introduction
    to Git](https://realpython.com/python-git-github-intro/)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 预计你对版本控制系统 (VCS) [git](https://git-scm.com/) 已经熟悉。如果不熟悉，这里有一个复习资料：[Git 入门介绍](https://realpython.com/python-git-github-intro/)
- en: Commits will be based on [best practices for git commits](https://deepsource.io/blog/git-best-practices/)
    & [Conventional commits](https://www.conventionalcommits.org/en/v1.0.0/). There
    is the [conventional commit plugin](https://plugins.jetbrains.com/plugin/13389-conventional-commit)
    for PyCharm or a [VSCode Extension](https://github.com/vivaxy/vscode-conventional-commits)
    that help you to write commits in this format.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 提交将基于 [最佳 git 提交实践](https://deepsource.io/blog/git-best-practices/) 和 [约定式提交](https://www.conventionalcommits.org/en/v1.0.0/)。对于
    PyCharm，有 [约定式提交插件](https://plugins.jetbrains.com/plugin/13389-conventional-commit)
    或者 [VSCode 扩展](https://github.com/vivaxy/vscode-conventional-commits) 可以帮助你按照这种格式撰写提交。
- en: Overview
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: '[Part I (GitHub, IDE)](https://johschmidt42.medium.com/setting-up-python-projects-part-i-408603868c08)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第一部分 (GitHub, IDE)](https://johschmidt42.medium.com/setting-up-python-projects-part-i-408603868c08)'
- en: Part II (Formatting, Linting, CI)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二部分 (格式化、Linting、CI)
- en: Part III (Testing, CI)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三部分 (测试、CI)
- en: '[Part IV (Documentation, CI/CD)](https://johschmidt42.medium.com/setting-up-python-projects-part-iv-82059eba4ca4)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第四部分 (文档、CI/CD)](https://johschmidt42.medium.com/setting-up-python-projects-part-iv-82059eba4ca4)'
- en: '[Part V (Versioning & Releases, CI/CD)](https://medium.com/@johschmidt42/setting-up-python-projects-part-v-206df3c1e3d3)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第五部分 (版本控制与发布，CI/CD)](https://medium.com/@johschmidt42/setting-up-python-projects-part-v-206df3c1e3d3)'
- en: '**Part VI (Containerisation, Docker, CI/CD)**'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第六部分 (容器化、Docker、CI/CD)**'
- en: Structure
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构
- en: Containerisation
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器化
- en: Docker
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: Dockerfile
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dockerfile
- en: Docker image
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 镜像
- en: Docker container
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 容器
- en: Docker stages (*base, builder, production*)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 阶段 (*基础、构建、生产*)
- en: Container registries (*ghcr.io*)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器注册中心 (*ghcr.io*)
- en: Docker push
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 推送
- en: CI (*build.yml & build_and_push.yml*)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CI (*build.yml & build_and_push.yml*)
- en: Badge (*Build*)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 徽章 (*构建*)
- en: Bonus (*trivy*)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 奖励 (*trivy*)
- en: In this article, we will explore the concept of **containerisation**, its benefits,
    and how it can be used with **Docker** to create and manage containerised applications.
    We will use **GitHub Actions** to continuously build Docker images & upload them
    to our repository when a new version is released.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇文章中，我们将深入探讨**容器化**的概念及其好处，以及如何与**Docker**结合使用，以创建和管理容器化应用。我们将使用**GitHub Actions**来持续构建
    Docker 镜像并在发布新版本时将其上传到我们的仓库。
- en: Containerisation
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器化
- en: Containerisation is a modern technology that has revolutionised the way software
    applications are developed, deployed, and managed. It has gained widespread adoption
    in recent years due to its ability to solve some of the biggest challenges in
    software development and deployment.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化是一项现代技术，它彻底改变了软件应用的开发、部署和管理方式。近年来，由于它能够解决软件开发和部署中的一些重大挑战，已获得广泛采用。
- en: In simple terms, containerisation is a process of packaging an application and
    all its dependencies into a single **container**. This container is a lightweight,
    portable, and self-sufficient unit that can be run consistently across different
    computing environments. It provides an isolated environment for the application,
    ensuring that it runs consistently, regardless of the underlying infrastructure.
    It allows developers to create applications that are scalable, portable, and easy
    to manage. Additionally, containers provide an extra layer of security by isolating
    applications from the host system. If you hear someone say the phrase “*it works
    on my computer*”, it is no longer valid because you can and should test your application
    in a Docker container. This ensures that it works consistently across different
    environments.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，容器化是将应用程序及其所有依赖项打包成一个单一的**容器**的过程。这个容器是一个轻量、可移植、自给自足的单元，可以在不同的计算环境中一致地运行。它为应用程序提供了一个隔离的环境，确保它在任何底层基础设施下都能一致运行。它使开发者能够创建可扩展、可移植且易于管理的应用程序。此外，容器通过将应用程序与宿主系统隔离，提供了额外的安全层。如果你听到有人说“*它在我的电脑上能工作*”，这已经不再有效，因为你可以并且应该在
    Docker 容器中测试你的应用。这确保了它在不同环境中的一致性。
- en: In conclusion, containerisation is a powerful technology that allows developers
    to create containerised applications that are reliable, efficient, and easy to
    manage, allowing them to focus on developing great software.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，容器化是一项强大的技术，它允许开发者创建可靠、高效且易于管理的容器化应用，使他们能够专注于开发优秀的软件。
- en: Docker
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker
- en: Docker is a popular containerisation platform that allows developers to create,
    deploy, and run containerised applications. It provides a range of tools and services
    that make it easy to package and deploy applications in a containerised format.
    With Docker, developers can create, test, and deploy applications in a matter
    of minutes, instead of days or weeks.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是一个流行的容器化平台，允许开发人员创建、部署和运行容器化应用程序。它提供了一系列工具和服务，使得将应用程序打包和部署为容器化格式变得简单。使用Docker，开发人员可以在几分钟内创建、测试和部署应用程序，而不是几天或几周。
- en: To create such an containerised application with docker we need to
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用docker创建这样的容器化应用程序，我们需要
- en: Build a **Docker image** from a **Dockerfile**
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Dockerfile**构建一个**Docker镜像**
- en: Create a **container** from the Docker image
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Docker镜像创建一个**容器**
- en: For this we will use the docker CLI.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将使用docker CLI。
- en: Dockerfile
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dockerfile
- en: A Dockerfile is a text file that contains all commands needed to build a given
    image. It adheres to a specific format and set of instructions which you can find
    about [here](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile是一个包含所有构建给定镜像所需命令的文本文件。它遵循特定的格式和指令集，你可以在[这里](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/)找到相关信息。
- en: 'The goal for this section here is to create a Dockerfile that **builds a wheel
    of our Python package**:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目标是创建一个**构建我们Python包的wheel文件**的Dockerfile：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This Dockerfile is essentially a set of instructions that tells Docker how to
    build a container for a Python application. It starts with a base image `python:3.10-slim`
    which is a slim version of the Python 3.10 image that has already been pre-built
    with some basic libraries and dependencies.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Dockerfile本质上是一组指令，告诉Docker如何为Python应用程序构建一个容器。它以`python:3.10-slim`作为基础镜像开始，这是一种已经预装了一些基本库和依赖项的Python
    3.10精简版镜像。
- en: The first instruction `WORKDIR /app` sets the working directory to `/app` inside
    the container where the application will be placed.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个指令`WORKDIR /app`将工作目录设置为容器内的`/app`，应用程序将被放置在此目录中。
- en: The next instruction `ENV POETRY_VERSION=1.2.0` sets an environment variable
    called `POETRY_VERSION` to `1.2.0` which will be used in the next command to install
    the Poetry package manager.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个指令`ENV POETRY_VERSION=1.2.0`设置一个名为`POETRY_VERSION`的环境变量为`1.2.0`，此变量将在下一条命令中用于安装Poetry包管理器。
- en: The `RUN pip install "poetry==$POETRY_VERSION"` command installs the Poetry
    package manager inside the container, which is used to manage dependencies for
    Python applications.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN pip install "poetry==$POETRY_VERSION"`命令在容器内安装Poetry包管理器，用于管理Python应用程序的依赖项。'
- en: The next instruction `COPY ["pyproject.toml", "poetry.lock", "README.md", "./"]`
    copies the project files (including the `pyproject.toml`, `poetry.lock` and `README.md`)
    to the container.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个指令`COPY ["pyproject.toml", "poetry.lock", "README.md", "./"]`将项目文件（包括`pyproject.toml`、`poetry.lock`和`README.md`）复制到容器中。
- en: The `README.md` file is required as there is a reference in the pyproject.toml.
    Without it we wouldn’t be able to build a wheel.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`README.md`文件是必需的，因为在pyproject.toml中有引用。没有它，我们将无法构建wheel。'
- en: The instruction `COPY ["src/", "src/"]` copies the source code of the application
    to the container.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 指令`COPY ["src/", "src/"]`将应用程序的源代码复制到容器中。
- en: The `RUN poetry build --format wheel` command builds a [Python wheel](https://realpython.com/python-wheels/)
    package for the Python application using the `poetry.lock` file and the source
    code of the application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN poetry build --format wheel`命令使用`poetry.lock`文件和应用程序的源代码为Python应用程序构建一个[Python
    wheel](https://realpython.com/python-wheels/)包。'
- en: Finally, the last instruction `RUN pip install dist/*.whl` installs the package
    by using `pip` and installs the generated `.whl` package file which is located
    inside the `dist` directory.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最后一条指令`RUN pip install dist/*.whl`使用`pip`安装包，并安装位于`dist`目录中的生成的`.whl`包文件。
- en: '**In summary**, this Dockerfile sets up a container with Python 3.10 and Poetry
    installed, copies the application source code and dependencies, builds a package
    wheel and installs it.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**总之**，这个Dockerfile设置了一个包含Python 3.10和已安装Poetry的容器，复制了应用程序源代码和依赖项，构建了一个包wheel并安装它。'
- en: '**This will not yet run the application**. But don’t worry, we will update
    it in the next sections. We must first understand the flow of using Docker.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**这还不会运行应用程序**。但不用担心，我们将在接下来的章节中更新它。我们必须首先了解使用Docker的流程。'
- en: Docker image
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker镜像
- en: We have created a **Dockerfile** that contains the instructions to build a Docker
    image. Why do we need a **Docker image** again**?** Because itallows us to build
    D**ocker containers**!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个 **Dockerfile**，其中包含构建 Docker 镜像的指令。为什么我们需要 **Docker 镜像**？因为它允许我们构建
    **Docker 容器**！
- en: 'Let’s run the **docker build** command to create our image:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行 **docker build** 命令来创建我们的镜像：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This command is used to build a Docker image from a Dockerfile and tag it with
    a specified name and version. Let’s break down the command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令用于从 Dockerfile 构建 Docker 镜像，并使用指定的名称和版本标记它。让我们来解析一下命令：
- en: '`docker build`: This is the command used to build Docker images.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker build`：这是用于构建 Docker 镜像的命令。'
- en: '`--file Dockerfile`: This option specifies the path and name of the Dockerfile
    used for building the image. In this case, it is simply named `Dockerfile`, so
    it''s using the default name.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--file Dockerfile`：此选项指定用于构建镜像的 Dockerfile 的路径和名称。在这种情况下，它被简单地命名为 `Dockerfile`，所以它使用了默认名称。'
- en: '`--tag project:latest`: This option specifies the name and version of the image
    to be created. In this case, the image name is `project` and its version is `latest`.
    `project` is the name given to the image, and `latest` is the version number.
    You can replace `project` and `latest` with the name and version of your choice.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--tag project:latest`：此选项指定要创建的镜像的名称和版本。在这种情况下，镜像名称为 `project`，版本为 `latest`。`project`
    是给镜像的名称，而 `latest` 是版本号。你可以用你选择的名称和版本替换 `project` 和 `latest`。'
- en: '`.`: This specifies the build context, which is the location of the files used
    for building the image. In this case, `.` refers to the current directory where
    the command is executed.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.`：此选项指定了构建上下文，即用于构建镜像的文件位置。在这种情况下，`.` 指当前执行命令的目录。'
- en: 'So, when this command is executed, Docker reads the Dockerfile in the current
    directory and uses it to build a new image named `project:latest`. We can find
    additional information about the resulting image (& other images) by running:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当执行此命令时，Docker 会读取当前目录中的 Dockerfile，并使用它来构建一个名为 `project:latest` 的新镜像。我们可以通过运行以下命令找到有关结果镜像（及其他镜像）的更多信息：
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Our image is **271 mb** in size. The size will be reduced later on.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的镜像大小为 **271 mb**。大小将在后续减少。
- en: Docker container
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 容器
- en: 'We can create/run a Docker container from a Docker image using the `docker
    run` command. The command requires one parameter which is the name of the image.
    For example, if your image is named `myimage`, you can run it with the following
    [command](https://docs.docker.com/language/python/run-containers/): `docker run
    myimage`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `docker run` 命令从 Docker 镜像创建/运行一个 Docker 容器。该命令需要一个参数，即镜像的名称。例如，如果你的镜像名为
    `myimage`，你可以使用以下 [命令](https://docs.docker.com/language/python/run-containers/)
    运行它：`docker run myimage`
- en: 'If we run our application like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们像这样运行我们的应用：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'it will open an Python terminal (you can close the session with **CTRL + D**
    or **CMD + D**; The `-it` option is used to run a container in interactive mode
    with a pseudo-TTY (terminal emulation). This allows you to interact with the container’s
    shell and see its output in real-time. The `-rm` option is used to remove the
    container automatically when it exits.):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 它将打开一个 Python 终端（你可以使用 **CTRL + D** 或 **CMD + D** 关闭会话；`-it` 选项用于以交互模式运行容器，并提供伪终端（终端仿真）。这允许你与容器的
    shell 进行交互，并实时查看其输出。`-rm` 选项用于在容器退出时自动删除容器。）
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Why does it open a Python session? That is, because the entrypoint of the docker
    image defaults to the Python interpreter in the standard **python:3.10-slim**
    image. If we want to have a look inside the container, we must overwrite the entrypoint.
    Because **bash** is installed by default on this build, we can run the docker
    container and get inside it with:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么它会打开一个 Python 会话？这是因为 Docker 镜像的 entrypoint 默认指向标准 **python:3.10-slim** 镜像中的
    Python 解释器。如果我们想查看容器内部，我们必须覆盖 entrypoint。因为 **bash** 默认安装在此构建中，我们可以通过以下命令运行 Docker
    容器并进入其中：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So we overwrite the entrypoint with **/bin/bash**.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们用 **/bin/bash** 覆盖了 entrypoint。
- en: 'And now we can check the content that is inside our container:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以检查容器内部的内容：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can check the installed packages with
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令检查已安装的包：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Great, we can jump inside a container, which is really good for troubleshooting.
    But how do we make it **run our application?** And where is our app installed?
    By default, packages can be found in the **site-packages** directory of the Python
    installation. To find that information we can use the **pip show** command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，我们可以进入容器，这对于故障排除非常有用。但我们如何让它**运行我们的应用程序**？我们的应用程序安装在哪里？默认情况下，包可以在 Python
    安装的**site-packages** 目录中找到。要获取这些信息，我们可以使用**pip show** 命令：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Since **uvicorn**, our ASGI server implementation, is installed by default,
    we can **cd** into */usr/local/lib/python3.10/site-packages/example_app*
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于**uvicorn**（我们的 ASGI 服务器实现）默认安装，我们可以**cd** 进入 */usr/local/lib/python3.10/site-packages/example_app*
- en: 'and run the application with the **uvicorn command**:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 并使用**uvicorn 命令**运行应用程序：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: where `app:app` follows the pattern `<file_name>:<variable_name>` .
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `app:app` 遵循 `<file_name>:<variable_name>` 模式。
- en: 'The application runs on **port 80** within the docker container with **1 worker**.
    To be accessible on the host (your machine), we need to expose the container port
    and publish it to the host. This can be done by adding adding the `--expose` and
    `--publish` flag to the docker run command. Alternatevily, we can have the container
    expose a certain port by defining this in the **Dockerfile**. We will do this
    in a second. Before that, here’s what we’re gonna do:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序在 docker 容器中运行在**端口 80**，并使用**1 个工作进程**。为了在主机（你的机器）上访问，我们需要暴露容器端口并将其发布到主机。这可以通过在
    docker run 命令中添加 `--expose` 和 `--publish` 标志来完成。或者，我们可以通过在**Dockerfile**中定义某个端口来让容器暴露该端口。我们稍后会做这个。之前，我们要做的是：
- en: 'Our application can be found in the site-packages directory. This requires
    us to change the directory before we can run the `uvicorn app:app` command. If
    we want to avoid changing the directory, we can instead create a file that imports
    the app for us. Here’s an example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序可以在 site-packages 目录中找到。这要求我们在运行 `uvicorn app:app` 命令之前更改目录。如果我们想避免更改目录，我们可以创建一个文件来为我们导入应用程序。以下是一个示例：
- en: 'Add a `main.py` :'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个 `main.py`：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'where we import the application in a `main.py` so that uvicorn can use it.
    If we now copy this file to our `/app` directory:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main.py` 中导入应用程序，以便 uvicorn 可以使用它。如果我们现在将这个文件复制到我们的 `/app` 目录：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: we can run the app with
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行应用程序
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Great. Now let’s set this command as an **entrypoint** when starting a container.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了。现在让我们将这个命令设置为启动容器时的**入口点**。
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We now copy the `main.py` file to the `/app` directory. The `EXPOSE` instruction
    informs Docker that the container listens on the specified network ports at runtime.
    In this case, it is exposing **port 80**.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将 `main.py` 文件复制到 `/app` 目录。`EXPOSE` 指令通知 Docker 容器在运行时监听指定的网络端口。在这种情况下，它暴露了**端口
    80**。
- en: The `CMD` instruction specifies what command to run within the container. Here,
    it is running the command `uvicorn main:app --host 0.0.0.0 --port 80 --workers
    1`. This command starts a uvicorn server with the `main:app` application, listening
    on host `0.0.0.0` and port `80`, with `1` worker.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMD` 指令指定了在容器内运行的命令。在这里，它运行命令 `uvicorn main:app --host 0.0.0.0 --port 80 --workers
    1`。这个命令启动了一个 uvicorn 服务器，运行 `main:app` 应用程序，监听主机 `0.0.0.0` 和端口 `80`，使用 `1` 个工作进程。'
- en: 'We can then run a container with the **docker run** command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用**docker run** 命令运行容器：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `-p` flag in the `docker run` command is used to publish a container’s port
    to the host. In this case, it is mapping port `9000` on the host to port `80`
    on the container. This means that any traffic sent to port `9000` on the host
    will be forwarded to port `80` on the container.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker run` 命令中的 `-p` 标志用于将容器的端口发布到主机。在这种情况下，它将主机上的端口 `9000` 映射到容器上的端口 `80`。这意味着任何发送到主机端口
    `9000` 的流量都会被转发到容器端口 `80`。'
- en: 'We see that our application that is running in the container can be reached:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到在容器中运行的应用程序可以被访问：
- en: '![](../Images/e59351dbabffba38db50b6de0d405edf.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e59351dbabffba38db50b6de0d405edf.png)'
- en: fastAPI application running in a Docker container — Image by author
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 运行在 Docker 容器中的 fastAPI 应用程序 — 作者图片
- en: '**Important remark**: Instead of uvicorn, I recommend using [**gunicorn**](https://gunicorn.org/)
    for production builds! For completeness, this is how the Dockerfile would look
    like instead:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要备注**：我建议在生产构建中使用 [**gunicorn**](https://gunicorn.org/) 代替 uvicorn！为了完整性，这里是
    Dockerfile 的替代版本：'
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: What’s the difference between these two?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个有什么区别？
- en: Uvicorn is an ASGI server that supports the ASGI protocol. It is built on [uvloop](https://uvloop.readthedocs.io/)
    and [httptools](https://pypi.org/project/httptools/) and is known for its performance
    benefits. [However, its capabilities as a process manager leave much to be desired](https://stackoverflow.com/questions/66362199/what-is-the-difference-between-uvicorn-and-gunicornuvicorn).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Uvicorn 是一个支持 ASGI 协议的 ASGI 服务器。它建立在 [uvloop](https://uvloop.readthedocs.io/)
    和 [httptools](https://pypi.org/project/httptools/) 之上，并以其性能优势而闻名。[然而，它作为进程管理器的能力还有待提高](https://stackoverflow.com/questions/66362199/what-is-the-difference-between-uvicorn-and-gunicornuvicorn)。
- en: Gunicorn, on the other hand, is a mature and fully-featured server and process
    manager. [It is a pre-fork worker model ported from Ruby’s Unicorn project and
    is broadly compatible with various web frameworks](https://stackshare.io/stackups/gunicorn-vs-uvicorn).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Gunicorn 另一方面是一个成熟且功能全面的服务器和进程管理器。[它是从 Ruby 的 Unicorn 项目移植而来的预叉工人模型，并与各种 web
    框架广泛兼容](https://stackshare.io/stackups/gunicorn-vs-uvicorn)。
- en: Docker stages
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 阶段
- en: Docker stages are a feature that allows you to create multiple stages in your
    Dockerfile. Each stage can have its own **base image** and set of instructions.
    You can selectively copy artifacts from one stage to another, leaving behind everything
    you don’t want in a target stage. [This feature is useful because it allows you
    to optimize your Docker images by reducing their size and complexity](https://docs.docker.com/build/building/multi-stage/).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 阶段是一项功能，允许你在 Dockerfile 中创建多个阶段。每个阶段可以有自己的 **基础镜像** 和指令集。你可以选择性地将工件从一个阶段复制到另一个阶段，留下你不想要的内容。[此功能很有用，因为它可以通过减少
    Docker 镜像的大小和复杂性来优化 Docker 镜像](https://docs.docker.com/build/building/multi-stage/)。
- en: 'With Docker stages we can (and should!) optimize our Docker image. So what
    we want to achieve is this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker 阶段，我们可以（并且应该！）优化我们的 Docker 镜像。所以我们想要实现的是：
- en: poetry should not be in the production build
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: poetry 不应该出现在生产构建中
- en: the production build should only contain as little as necessary to run the app
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产构建应该仅包含运行应用程序所需的最少内容
- en: 'And this is how we’re going to do it: We create a clean **base** stage. From
    the base stage we have a **builder** stage that installs poetry and builds the
    wheel. Another stage, **production,** can copy this artifact (.whl file) from
    the build stage and use it. This way we avoid having poetry installed in the production
    build and also limit it to have only the essentials, therby reducing the size
    of the final image.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们要做到的方法：我们创建一个干净的 **基础** 阶段。从基础阶段，我们有一个 **构建** 阶段，安装 poetry 并构建 wheel。另一个阶段，**生产，**
    可以从构建阶段复制这个工件（.whl 文件）并使用它。这样我们可以避免在生产构建中安装 poetry，同时也将其限制为仅包含必要内容，从而减少最终镜像的大小。
- en: About poetry in Docker
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于 Docker 中的 poetry
- en: There are different strategies that I’ve seen with poetry in combination with
    Docker.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我见过不同的策略将 poetry 与 Docker 结合使用。
- en: Creating a **virtual environment** and then copying the whole **venv** from
    one stage to another.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 **虚拟环境**，然后将整个 **venv** 从一个阶段复制到另一个阶段。
- en: Creating **requirements.txt** files from the **poetry.lock** file and using
    these to pip install the requirements.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 **poetry.lock** 文件创建 **requirements.txt** 文件，并使用这些文件通过 pip 安装要求。
- en: In the first case, Poetry is installed when building the image. In the second
    case, poetry is not installed within the docker build but Poetry needs to be used
    to create the requirements.txt files.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，Poetry 在构建镜像时安装。在第二种情况下，Poetry 不在 Docker 构建中安装，但需要使用 Poetry 来创建 requirements.txt
    文件。
- en: In both cases, we need Poetry to be installed in some way — either in the Docker
    image or on the host that runs the docker build command.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们需要以某种方式安装 Poetry——无论是在 Docker 镜像中还是在运行 Docker 构建命令的主机上。
- en: Having Poetry inside Docker will slightly increase the build time while having
    it outside of Docker will require you install Poetry on the host and add additional
    steps for the build process (creating the requirements.txt files from poetry.lock).
    In the context of a Docker build **CI pipeline**, the Poetry installation on the
    host machine could be cached and the build process will be generally faster. Both
    approaches have their advantages and disadvantages, and the best approach will
    depend on your specific needs and preferences.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Poetry 放入 Docker 中会稍微增加构建时间，而将其放在 Docker 之外则需要你在主机上安装 Poetry，并为构建过程添加额外步骤（从
    poetry.lock 创建 requirements.txt 文件）。在 Docker 构建 **CI 流水线** 的上下文中，主机上的 Poetry 安装可以被缓存，构建过程通常会更快。这两种方法都有其优缺点，最佳方法将取决于你的具体需求和偏好。
- en: 'For the sake of this tutorial, I will keep it simple and use the **venv strategy**
    described above**.** So here’s the new Dockfile with stages (To identiy the different
    stages seperated by the **FROM** statement, I highlited the lines in **bold**):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本教程的目的，我将保持简单，使用上面描述的 **venv 策略**。所以这是新的 Dockfile，其中包含阶段（为了识别不同的阶段，通过 **FROM**
    语句分隔，我将这些行用 **粗体** 高亮）：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This Dockerfile defines a multi-stage build with three stages: `base`, `builder`,
    and `production`.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Dockerfile 定义了一个包含三个阶段的多阶段构建：`base`、`builder` 和 `production`。
- en: The `base` stage starts from a Python 3.10-slim image and sets the working directory
    to `/app`. It also sets an environment variable to ignore a warning about running
    pip as the root user and updates pip to the latest version.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`base` 阶段从 Python 3.10-slim 镜像开始，将工作目录设置为 `/app`。它还设置了一个环境变量以忽略关于以 root 用户身份运行
    pip 的警告，并将 pip 更新到最新版本。'
- en: The `builder` stage starts from the `base` stage and installs Poetry using pip.
    It then copies the application files and uses Poetry to build a wheel for the
    application.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`builder` 阶段从 `base` 阶段开始，并使用 pip 安装 Poetry。然后，它复制应用程序文件，并使用 Poetry 为应用程序构建一个
    wheel 文件。'
- en: The `production` stage starts from the `base` stage again and exposes port 80\.
    It copies the wheel built in the `builder` stage and installs it using pip. It
    also copies the entrypoint of the app and sets the command to run the app using
    uvicorn.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`production` 阶段再次从 `base` 阶段开始，并暴露端口 80。它复制在 `builder` 阶段构建的 wheel 文件，并使用 pip
    安装。它还复制应用程序的入口点，并将命令设置为使用 uvicorn 运行应用程序。'
- en: 'We can now re-build our Docker image with:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用以下命令重新构建我们的 Docker 镜像：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can specify the stage we would like to build with the `--target` flag.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `--target` 标志指定我们希望构建的阶段。
- en: 'The file size is now **~70 Mb** less, with a total of **197MB**:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 文件大小现在减少了 **~70 Mb**，总共为 **197MB**：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: And we can run it with
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令运行它：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The API will be available under [http://localhost:9000](http://localhost:9000)
    in the browser.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: API 将在浏览器中通过 [http://localhost:9000](http://localhost:9000) 提供。
- en: '![](../Images/e59351dbabffba38db50b6de0d405edf.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e59351dbabffba38db50b6de0d405edf.png)'
- en: fastAPI application running in a Docker container — Image by author
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: fastAPI 应用程序在 Docker 容器中运行 — 作者图片
- en: Container registries
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器注册表
- en: A container registry is a repository or collection of repositories used to store
    and access container images. Container registries can support container-based
    application development, often as part of [DevOps](https://realpython.com/learning-paths/python-devops/)
    processes. They can connect directly to container orchestration platforms like
    [Docker and Kubernetes](https://www.redhat.com/en/topics/cloud-native-apps/what-is-a-container-registry).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 容器注册表是用于存储和访问容器镜像的仓库或仓库集合。容器注册表可以支持基于容器的应用程序开发，通常作为 [DevOps](https://realpython.com/learning-paths/python-devops/)
    过程的一部分。它们可以直接连接到像 [Docker 和 Kubernetes](https://www.redhat.com/en/topics/cloud-native-apps/what-is-a-container-registry)
    这样的容器编排平台。
- en: The most popular container registry is [Docker Hub](https://hub.docker.com/).
    Every Cloud Provider has its own. ACR for Azure, ECR for AWS and many many more.
    GitHub has its own package registry solution called [GitHub Packages](https://github.com/features/packages).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的容器注册表是 [Docker Hub](https://hub.docker.com/)。每个云服务提供商都有自己的注册表。Azure 的 ACR、AWS
    的 ECR 以及更多。GitHub 有一个名为 [GitHub Packages](https://github.com/features/packages)
    的包注册解决方案。
- en: As we’ve done basically everything on GitHub so far, we will use **GitHub Packages**
    in this tutorial.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们到目前为止基本上都在 GitHub 上完成了所有操作，所以在本教程中我们将使用 **GitHub Packages**。
- en: '![](../Images/b0a73063d4391300e8a9464b7428d8fa.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b0a73063d4391300e8a9464b7428d8fa.png)'
- en: GitHub Packages — Image by author
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Packages — 作者图片
- en: It has a free tier for a normal user on GitHub. This allows us to use up to
    **500 MB** of storage for our containers. That’s enough for our application.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 为普通用户提供了免费的层级。这允许我们为我们的容器使用最多 **500 MB** 的存储空间。这对我们的应用程序来说足够了。
- en: '![](../Images/e7f3be91fed4338dffe25a8f439b1f19.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e7f3be91fed4338dffe25a8f439b1f19.png)'
- en: GitHub Packages Pricing with free tier — Image by author
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Packages 定价和免费层 — 作者图片
- en: Docker push
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker push
- en: The `docker push` command is used to **upload** a Docker image to a container
    registry. This allows you to share your images with others or deploy them to different
    environments. The command takes the name of the image you want to push and the
    name of the registry you want to push it to as arguments. You need to be logged
    in to the registry before you can push an image to it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker push` 命令用于 **上传** Docker 镜像到容器注册表。这允许你与其他人分享你的镜像或将其部署到不同的环境中。该命令需要你指定要推送的镜像名称和要推送到的注册表名称作为参数。在推送镜像之前，你需要登录到注册表。'
- en: 'Here are the steps to push a Docker image to a container registry:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将 Docker 镜像推送到容器注册表的步骤：
- en: '**Tag** (rename) your image with the registry name: `docker tag project:latest
    <registry-name>/<project>:latest`'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**标记**（重命名）你的镜像，使用注册表名称：`docker tag project:latest <registry-name>/<project>:latest`'
- en: '**Log in** to the container registry: `docker login <registry-url>`'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**登录**到容器注册表：`docker login <registry-url>`'
- en: '**Push** your image to the registry: `docker push <registry-name>/<project>:latest`'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**推送**你的镜像到注册表：`docker push <registry-name>/<project>:latest`'
- en: 'We will push the image to [GitHub Packages](https://github.com/features/packages):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把镜像推送到[GitHub Packages](https://github.com/features/packages)：
- en: GitHub Packages
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitHub Packages
- en: GitHub Packages only supports authentication using a personal access token (February,
    2023). But we created a personal access token (PAT) in [Part V](https://medium.com/@johschmidt42/setting-up-python-projects-part-v-206df3c1e3d3),
    so we can use it here as well.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Packages 仅支持使用个人访问令牌进行身份验证（2023年2月）。但我们在[第五部分](https://medium.com/@johschmidt42/setting-up-python-projects-part-v-206df3c1e3d3)创建了一个个人访问令牌（PAT），所以我们也可以在这里使用它。
- en: We need to [login to the container registry](https://docs.github.com/en/packages/learn-github-packages/connecting-a-repository-to-a-package)
    with
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要[登录到容器注册表](https://docs.github.com/en/packages/learn-github-packages/connecting-a-repository-to-a-package)：
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It’s a shell command that uses a pipe to connect two commands. A pipe is a symbol
    (`|`) that redirects the output of one command to the input of another command.
    In this case, the first command is `echo $(CR_PAT)`, which prints the value of
    the CR_PAT variable to the standard output. The second command is `docker login
    ghcr.io -u johschmidt42 --password-stdin`, which logs in to ghcr.io using johschmidt42
    as the username and reading the password from the standard input. By using a pipe,
    the output of the echo command becomes the input of the docker login command,
    which means that the value of the CR_PAT variable is used as the password for
    logging in.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 shell 命令，使用管道将两个命令连接起来。管道是一个符号（`|`），它将一个命令的输出重定向到另一个命令的输入。在这种情况下，第一个命令是
    `echo $(CR_PAT)`，它将 CR_PAT 变量的值打印到标准输出。第二个命令是 `docker login ghcr.io -u johschmidt42
    --password-stdin`，它使用 johschmidt42 作为用户名，并从标准输入读取密码来登录 ghcr.io。通过使用管道，echo 命令的输出成为
    docker login 命令的输入，这意味着 CR_PAT 变量的值被用作登录密码。
- en: Let’s add this to our Makefile
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把它添加到我们的 Makefile 中
- en: '[PRE21]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We need to write a little if-else statement in **bash** so that this target
    login requires us to set the **CR_PAT** first.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在**bash**中写一个小的 if-else 语句，以便这个目标登录需要我们首先设置**CR_PAT**。
- en: 'This allows us to login like so now:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们现在可以像这样登录：
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For anyone confused by the bash command. Here’s an explanation:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何对 bash 命令感到困惑的人，这里有一个解释：
- en: The shell command uses an if-else statement to check a condition and execute
    different actions accordingly. The condition is `[ -z "$(CR_PAT)" ]`, which means
    “is the CR_PAT variable empty?”. The `-z` flag tests for zero length. The `$(CR_PAT)`
    part expands the value of the CR_PAT variable inside the brackets. If the condition
    is true, then the action after `then` is executed, which is `echo "CR_PAT is not
    set"`. This prints a message to the standard output. If the condition is false,
    then the action after `else` is executed, which is `echo $(CR_PAT) | docker login
    ghcr.io -u johschmidt42 --password-stdin`. The `\` at the end of each line means
    that the command continues on the next line. The `fi` at the end marks the end
    of the if-else statement.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 shell 命令使用 if-else 语句来检查一个条件，并根据不同的条件执行不同的操作。条件是 `[ -z "$(CR_PAT)" ]`，这意味着“CR_PAT
    变量为空吗？” `-z` 标志测试零长度。`$(CR_PAT)` 部分在括号内展开 CR_PAT 变量的值。如果条件为真，那么 `then` 后的操作会被执行，即
    `echo "CR_PAT is not set"`。这将一条消息打印到标准输出。如果条件为假，则执行 `else` 后的操作，即 `echo $(CR_PAT)
    | docker login ghcr.io -u johschmidt42 --password-stdin`。每行末尾的 `\` 意味着命令继续在下一行。末尾的
    `fi` 标志着 if-else 语句的结束。
- en: 'Now that we’re logged in, we need to rename the docker file so that we can
    push it to the remote registry using the docker tag command:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已登录，我们需要重命名 docker 文件，以便使用 docker tag 命令将其推送到远程注册表：
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can see information about our docker images with:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下命令查看有关我们的 docker 镜像的信息：
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If we now try to push the image to the registry, it will **fail**:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试将镜像推送到注册表，它会**失败**：
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: That’s because our token does **not have the expected scopes**. The message
    does not tell us which scopes (permissions) it requires but we can find this information
    in the [documentation](https://docs.github.com/en/packages/learn-github-packages/about-permissions-for-github-packages).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们的令牌**没有预期的范围**。消息没有告诉我们需要哪些范围（权限），但我们可以在[文档](https://docs.github.com/en/packages/learn-github-packages/about-permissions-for-github-packages)中找到这些信息。
- en: 'So we need to add these scopes:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们需要添加这些范围：
- en: '**read:packages**'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**read:packages**'
- en: '**delete:packages**'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**delete:packages**'
- en: '![](../Images/9682e27fb5857d928ec8fe542b048447.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9682e27fb5857d928ec8fe542b048447.png)'
- en: GH_TOKEN — Image by author
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: GH_TOKEN — 作者提供的图片
- en: 'And now we’re seeing it being pushed to the container registry:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到它被推送到容器注册表：
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In GitHub, under `profile` there is now a docker image in the `packages` tab:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub中，`profile`下的`packages`标签中现在有一个docker镜像：
- en: '![](../Images/25a9b41841631d08d4b4b72b2d989d7f.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/25a9b41841631d08d4b4b72b2d989d7f.png)'
- en: Your profile — Image by author
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你的个人资料 — 作者提供的图片
- en: '![](../Images/13cdc769731c3e98adcb44db40eeebb4.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/13cdc769731c3e98adcb44db40eeebb4.png)'
- en: GitHub packages — Image by author
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub packages — 作者提供的图片
- en: 'Clicking on it, allows us to [connect the package to our repository](https://docs.github.com/en/packages/learn-github-packages/connecting-a-repository-to-a-package):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 点击它，可以[将包连接到我们的仓库](https://docs.github.com/en/packages/learn-github-packages/connecting-a-repository-to-a-package)：
- en: '![](../Images/58796861176d35ba8a3fdc5b6a770cc7.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/58796861176d35ba8a3fdc5b6a770cc7.png)'
- en: 'GitHub packages: Connect Repository — Image by author'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 'GitHub packages: 连接仓库 — 作者提供的图片'
- en: 'And now this docker image can be found in the landing page of the repo [github.com/johschmidt42/python-project-johannes](https://github.com/johschmidt42/python-project-johannes):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个docker镜像可以在仓库的首页找到 [github.com/johschmidt42/python-project-johannes](https://github.com/johschmidt42/python-project-johannes)：
- en: '![](../Images/b2edcc5b423274b3b003ef82b3cf2c1d.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b2edcc5b423274b3b003ef82b3cf2c1d.png)'
- en: GitHub Packages Front page — image by author
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Packages 首页 — 作者提供的图片
- en: 'Excellent. We have created a Docker Image, pushed it to the remote repository,
    linked it to our current version and now everyone who wants to test our application
    can do so by running the docker pull command:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。我们已经创建了一个Docker镜像，将其推送到远程仓库，链接到我们当前的版本，现在每个人都可以通过运行docker pull命令来测试我们的应用：
- en: '[PRE29]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'CI/CD:'
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CI/CD：
- en: 'CI/CD stands for Continuous Integration and Continuous Deployment. With Docker
    images, CI/CD can automate the process of building, testing, and deploying images.
    In this tutorial, we’ll focus on continuously building our Docker image and pushing
    it to a remote container registry (CI) whenever there’s a new version. However,
    we won’t be deploying the image (CD) in this tutorial (stay tuned for a future
    blog post). Our Docker container will be built when:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD代表持续集成和持续部署。通过Docker镜像，CI/CD可以自动化构建、测试和部署镜像的过程。在本教程中，我们将重点关注持续构建我们的Docker镜像并在有新版本时将其推送到远程容器注册表（CI）。然而，在本教程中，我们不会部署镜像（CD）（请关注未来的博客文章）。我们的Docker容器将在以下情况构建：
- en: A commit is made to a branch with an open PR
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交到一个有打开的PR的分支
- en: A commit is made to the default branch (main)
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交到默认分支（main）
- en: A new release is created (this will push the image to the container registry)
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新版本（这会将镜像推送到容器注册表）
- en: 'The first action helps us catch bugs early on. The second action enables us
    to create and use a badge in our README.md file. The last action creates a new
    version of the Docker image and pushes it to the container registry. The overall
    flow of actions is summarised here:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个动作帮助我们及早发现错误。第二个动作使我们能够在README.md文件中创建并使用徽章。最后一个动作创建Docker镜像的新版本并将其推送到容器注册表。整体动作流程总结如下：
- en: '![](../Images/209a22eeb95a99285f547c1d8c4d1c1d.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/209a22eeb95a99285f547c1d8c4d1c1d.png)'
- en: GitHub Actions Flow — Image by author
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions 流程 — 作者提供的图片
- en: 'Let’s create the `build` pipeline:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建`build`管道：
- en: This GitHub Actions workflow builds a Docker image. It is triggered when there
    is a **push** or **pull request** to the **main** branch or when the workflow
    is called. The job is named “Build” and has two steps. The first step checks out
    the repository using the `actions/checkout` action. The second step builds the
    Docker image by running the `make build` command. That’s it.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个GitHub Actions工作流构建了一个Docker镜像。当有**push**或**pull request**到**main**分支时，或者当工作流被调用时，它会被触发。这个工作是命名为“Build”，包含两个步骤。第一步使用`actions/checkout`动作检出仓库。第二步通过运行`make
    build`命令来构建Docker镜像。就是这样。
- en: '![](../Images/fd3b515554b5a6ab99aa8bef6cf90ad3.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/fd3b515554b5a6ab99aa8bef6cf90ad3.png)'
- en: Workflow run — Image by author
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流运行 — 作者提供的图片
- en: 'We also need to update the `orchestrator.yml` accordingly:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要相应地更新 `orchestrator.yml`：
- en: The orchestrator is triggered when we push to the branch `main` .
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们推送到 `main` 分支时，会触发 orchestrator。
- en: '![](../Images/d38ab40f35c7b716ece3e7f38daff267.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d38ab40f35c7b716ece3e7f38daff267.png)'
- en: orchestrator.yml — image by author
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: orchestrator.yml — 图片由作者提供
- en: 'To build a new docker image with every **new version** released in our GitHub
    repository, we need to create a new GitHub actions workflow:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的 GitHub 存储库中发布每个 **新版本** 时构建新的 Docker 镜像，我们需要创建一个新的 GitHub Actions 工作流：
- en: This is a GitHub Actions workflow that builds and pushes a Docker image to the
    GitHub Container Registry (ghcr.io) when a release is published. The job named
    “build_and_push” has three steps. The first step checks out the repository using
    the `actions/checkout` action. The second step logs in to the GitHub Container
    Registry using the `docker/login-action`. The third step builds and pushes the
    Docker image using the `docker/build-push-action`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 GitHub Actions 工作流，当发布版本时，它会构建并推送 Docker 镜像到 GitHub Container Registry
    (ghcr.io)。名为“build_and_push”的作业有三个步骤。第一步使用 `actions/checkout` 操作检出存储库。第二步使用 `docker/login-action`
    登录到 GitHub Container Registry。第三步使用 `docker/build-push-action` 构建并推送 Docker 镜像。
- en: '![](../Images/ad45621c6d66fd7de9d92e98106efd2b.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ad45621c6d66fd7de9d92e98106efd2b.png)'
- en: build_and_push — image by author
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: build_and_push — 图片由作者提供
- en: Please note that, in order to login to GitHub Container Registry using [docker/login-action@v2](https://github.com/docker/login-action),
    we need to provide the secret **GH_TOKEN**, which is the PAT, we defined in [Part
    V](https://medium.com/@johschmidt42/setting-up-python-projects-part-v-206df3c1e3d3).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了使用 [docker/login-action@v2](https://github.com/docker/login-action) 登录到
    GitHub Container Registry，我们需要提供 **GH_TOKEN** 这个 PAT，正如我们在 [Part V](https://medium.com/@johschmidt42/setting-up-python-projects-part-v-206df3c1e3d3)
    中定义的那样。
- en: 'Here is a brief explanation of the parameters used in the last step [docker/build-push-action@4](https://github.com/docker/build-push-action):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最后一步中使用的参数的简要说明 [docker/build-push-action@4](https://github.com/docker/build-push-action)：
- en: '`context: .` specifies the build context as the current directory.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context: .` 指定构建上下文为当前目录。'
- en: '`push: true` specifies that the image should be pushed to the registry after
    it is built.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`push: true` 指定在构建后将图像推送到注册表。'
- en: '`tags: ghcr.io/${{ github.repository }}:${{ github.ref_name }}` specifies the
    tag for the image. In this case, it is tagged with the name of the repository
    and the branch or tag name that triggered the workflow.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tags: ghcr.io/${{ github.repository }}:${{ github.ref_name }}` 指定图像的标签。在这种情况下，它使用存储库的名称和触发工作流的分支或标签名称进行标记。'
- en: '`labels:` specifies labels for the image. In this case, it sets labels for
    the source, title, and version of the image.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`labels:` 指定图像的标签。在这种情况下，它设置了图像的源、标题和版本标签。'
- en: '`target: production` specifies the target stage to build in a multi-stage Dockerfile.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target: production` 指定在多阶段 Dockerfile 中构建的目标阶段。'
- en: '`github-token: ${{ secrets.GH_TOKEN }}` specifies the GitHub token to use for
    authentication.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`github-token: ${{ secrets.GH_TOKEN }}` 指定用于认证的 GitHub 令牌。'
- en: 'We can see our new docker image on GitHub:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 GitHub 上看到我们的新 Docker 镜像：
- en: '![](../Images/1e486e3903a579d596a11e18564e76b0.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1e486e3903a579d596a11e18564e76b0.png)'
- en: Images on GitHub — image by author
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 上的图像 — 图片由作者提供
- en: 'Badge:'
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 徽章：
- en: 'For this part, we will add a badge to our repo as we’ve done it before in the
    other parts. This time for the **build** pipeline. We can retrieve the badge when
    we click on a *build.yml* workflow run:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这部分，我们将像以前一样向我们的 repo 添加一个徽章。这一次是针对 **构建** 管道的。当我们点击 *build.yml* 工作流运行时，可以检索徽章：
- en: '![](../Images/2254ff4eefb21d7614ed6bb5b9e8d2b0.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2254ff4eefb21d7614ed6bb5b9e8d2b0.png)'
- en: Create a status badge — image by author
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 创建状态徽章 — 图片由作者提供
- en: Create a status badge from the workflow file on GitHub
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 从 GitHub 上的工作流文件创建状态徽章
- en: '![](../Images/6ccdfb3057da98e8f6219e21e1ca646c.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6ccdfb3057da98e8f6219e21e1ca646c.png)'
- en: Copy status badge Markdown — Image by author
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 复制状态徽章 Markdown — 图片由作者提供
- en: and select the main branch. The badge markdown can be copied and added to the
    *README.md:*
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 并选择主分支。徽章的 Markdown 可以复制并添加到 *README.md* 中：
- en: 'Our landing page of the GitHub now looks like this ❤:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 GitHub 登陆页面现在看起来是这样的 ❤：
- en: '![](../Images/ad2f4bc39f781c797b22d04a748a73a7.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ad2f4bc39f781c797b22d04a748a73a7.png)'
- en: 'Fifth badge in README.md: Build — Image by author'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: README.md 中的第五个徽章：构建 — 图片由作者提供
- en: If you want to know how this magically shows the current status of the last
    pipeline run in *main*, have a look the commit [statuses API](https://docs.github.com/en/rest/commits/statuses)
    on GitHub.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解如何神奇地显示 *main* 中最后一次管道运行的当前状态，请查看 GitHub 上的提交 [statuses API](https://docs.github.com/en/rest/commits/statuses)。
- en: That concludes the core portion of this tutorial! We successfully created a
    **Dockerfile** and used it to build an **Docker image** that enables us to run
    our application in a **Docker container**. Additionally, we implemented a **CI/CD**
    pipeline that automatically builds our Docker images and pushes them to the **container
    registry**. To top it off, we added a badge to our *README.md* file to proudly
    display our functional build pipeline to the world!
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了教程的核心部分！我们成功创建了一个**Dockerfile**，并使用它构建了一个**Docker 镜像**，使我们能够在**Docker 容器**中运行我们的应用程序。此外，我们实施了一个**CI/CD**
    管道，自动构建我们的 Docker 镜像并将其推送到**容器注册表**。最后，我们在 *README.md* 文件中添加了一个徽章，向世界展示我们功能齐全的构建管道！
- en: That was the last part! Did this tutorial help you to build a Python project
    on GitHub? Any suggestions for improvement? Let me know your thoughts!
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是最后一部分！这个教程是否帮助你在 GitHub 上构建了一个 Python 项目？有任何改进建议吗？让我知道你的想法！
- en: '[](https://johschmidt42.medium.com/membership?source=post_page-----cbdbf28eff53--------------------------------)
    [## Join Medium with my referral link - Johannes Schmidt'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://johschmidt42.medium.com/membership?source=post_page-----cbdbf28eff53--------------------------------)
    [## 通过我的推荐链接加入 Medium - Johannes Schmidt'
- en: Read every story from Johannes Schmidt (and thousands of other writers on Medium).
    Your membership fee directly…
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阅读 Johannes Schmidt 的每个故事（以及 Medium 上的其他成千上万名作者的故事）。你的会员费直接…
- en: johschmidt42.medium.com](https://johschmidt42.medium.com/membership?source=post_page-----cbdbf28eff53--------------------------------)
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: johschmidt42.medium.com](https://johschmidt42.medium.com/membership?source=post_page-----cbdbf28eff53--------------------------------)
- en: Bonus
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 奖励
- en: 'Clean up:'
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理：
- en: 'Here are some useful commands, that you can use when using the Docker CLI:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用 Docker CLI 时的一些有用命令：
- en: 'To stop all containers & remove them:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止所有容器并删除它们：
- en: '[PRE30]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To remove all unused docker images:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除所有未使用的 Docker 镜像：
- en: '[PRE31]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Vulnerability scanning in Docker images
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 镜像中的漏洞扫描
- en: Vulnerability scanning is a crucial step in ensuring the **security** of your
    docker images. It helps you identify and fix any potential weaknesses or risks
    that could compromise your application or data. One of the tools that can help
    you is [**trivy**](https://github.com/aquasecurity/trivy).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 漏洞扫描是确保 Docker 镜像**安全性**的关键步骤。它帮助你识别并修复可能会危害应用程序或数据的潜在弱点或风险。其中一个可以帮助你的工具是 [**trivy**](https://github.com/aquasecurity/trivy)。
- en: This open-source tool is a simple and fast **vulnerability scanner for docker
    images** that supports multiple formats and sources. I will demonstrate how to
    use it locally. Ideally, you should consider creating a GitHub actions workflow
    that runs whenever you build a docker image!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这个开源工具是一个简单快速的**Docker 镜像漏洞扫描器**，支持多种格式和来源。我将演示如何在本地使用它。理想情况下，你应该考虑创建一个 GitHub
    Actions 工作流，每当你构建 Docker 镜像时都运行！
- en: We first should install **trivy** according to the [documentation](https://aquasecurity.github.io/trivy/v0.43/getting-started/installation/).
    After building the production docker image with
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先应根据 [文档](https://aquasecurity.github.io/trivy/v0.43/getting-started/installation/)
    安装 **trivy**。在构建生产 Docker 镜像后
- en: '[PRE32]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: we can scan the built image with
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下命令扫描构建的镜像
- en: '[PRE33]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This will download the latest known vulnerabilites from a database and scan
    the image. The output will be shown in a table `--format table` with only the
    findings that have either CRITICAL or HIGH severity `--severity CRITICAL,HIGH`
    :'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从数据库下载已知的最新漏洞并扫描镜像。输出将以表格形式`--format table`显示，仅包含严重性为 CRITICAL 或 HIGH 的发现`--severity
    CRITICAL,HIGH`：
- en: '[PRE34]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'There or **2 OS libraries** with the severity **HIGH**. Both don’t provide
    a version we can upgrade to (see *Fixed Version* column) in order to fix the vulnerability
    in our docker image. So here’s how we’re going to deal with them:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 存在**2 个操作系统库**，其严重性为 **HIGH**。这两个库都没有提供可以升级到的版本（参见 *Fixed Version* 列），以修复我们
    Docker 镜像中的漏洞。因此，我们将按以下方式处理它们：
- en: '**linux-libc-dev**:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**linux-libc-dev**：'
- en: This is a package that is not required for our application to run. So it’s probably
    best to **uninstall** it!
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个运行应用程序时不需要的包。因此，最好还是**卸载**它！
- en: '**perl-base**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**perl-base**'
- en: This OS package provides the Perl interpreter and is required for other libraries
    that our application uses. That means that we cannot uninstall it and we cannot
    fix it. Hence, we must **accept the risk**. Accepting known vulnerabilites should
    be acknowledged and approved by management. We can then add the vunerability,
    e.g. CVE-2023–31484, to a .*trivyignore* file run the scanner again.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作系统包提供了 Perl 解释器，并且是我们应用程序使用的其他库所必需的。这意味着我们不能卸载它，也不能修复它。因此，我们必须**接受风险**。接受已知漏洞应由管理层确认和批准。然后，我们可以将漏洞，例如
    CVE-2023–31484，添加到 .*trivyignore* 文件中，再次运行扫描程序。
- en: 'Here are the changes:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是变更内容：
- en: '[PRE35]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When we run the command again (this time including the .*trivyignore* file):'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们再次运行命令（这次包含 .*trivyignore* 文件）时：
- en: '[PRE37]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'No vulnerabilites of severity HIGH or CRITICAL are reported anymore:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 不再报告严重性为 HIGH 或 CRITICAL 的漏洞：
- en: '[PRE38]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Cheers!
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 干杯！
