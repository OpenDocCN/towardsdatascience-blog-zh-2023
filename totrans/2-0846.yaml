- en: Exploratory Analysis of MEMS Sensor Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/exploratory-analysis-of-mems-sensor-data-bbfc0aa0a887](https://towardsdatascience.com/exploratory-analysis-of-mems-sensor-data-bbfc0aa0a887)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Reading, collecting, and analyzing data from the MPU6050 sensor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://dmitryelj.medium.com/?source=post_page-----bbfc0aa0a887--------------------------------)[![Dmitrii
    Eliuseev](../Images/7c48f0c016930ead59ddb785eaf3e0e6.png)](https://dmitryelj.medium.com/?source=post_page-----bbfc0aa0a887--------------------------------)[](https://towardsdatascience.com/?source=post_page-----bbfc0aa0a887--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----bbfc0aa0a887--------------------------------)
    [Dmitrii Eliuseev](https://dmitryelj.medium.com/?source=post_page-----bbfc0aa0a887--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----bbfc0aa0a887--------------------------------)
    ·13 min read·Aug 19, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: MEMS (Micro-electromechanical Systems) sensors are widely used in different
    applications, from game controllers and smartphones to unmanned aerial vehicles.
    In this article, I will show how to connect a gyroscope and accelerometer sensor,
    what kind of data it is possible to get from it, and how this data can be processed
    and visualized.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The MPU-6050 is a 6-axis sensor that combines a 3-axis gyroscope, a 3-axis accelerometer,
    and the I2C interface. As written in the datasheet, it is widely used for tablets
    and smartphones. When our smartphone or smartwatch calculates the steps and calories
    during the workout, the data from MEMS sensors is actually used. But sensors like
    this can be used for more than just sports. I decided to place the sensor in my
    apartment for several days and figure out if I would be able to detect and analyze
    different vibrations in the building where I live.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to collect data within several days, the Raspberry Pi is a good
    solution for that. The Raspberry Pi is a cheap (30–50$) single-board computer;
    it has low power consumption and plenty of pins to connect different types of
    hardware. An MPU-6050 prototyping board can be ordered on Amazon for 3–5$. The
    sensor itself uses the I2C bus for data transfer, and it can be connected to a
    Rasberry Pi using only 4 wires:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5bdd66a7770cc8248454aa787dd38659.png)'
  prefs: []
  type: TYPE_IMG
- en: Connection diagram, Image by author
  prefs: []
  type: TYPE_NORMAL
- en: 'Before using the sensor, the I2C bus should be enabled on the Raspbian OS (there
    are enough tutorials about how to connect the MPU6050 to the Raspberry Pi, so
    I will skip the “hardware” details here). After connecting the sensor, I created
    a simple Python application that reads the sensor data and writes it “as is” into
    log files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the “production” scenario, we can send data to a Kafka topic or to any other
    cloud provider, but for the “home” test, it was enough just to run the application
    in the background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: After that, we can leave the Raspberry Pi running for several days.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see from the code, all log files have a “YYYY-MM-DD” pattern. We
    can download these files from a Raspberry Pi using scp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s see what kind of data we can get.
  prefs: []
  type: TYPE_NORMAL
- en: General Insights
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s see what the gyroscope and accelerometer data look like. We need
    to include the needed libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s load the CSV into the Pandas dataframe and draw it using [Bokeh](https://github.com/bokeh/bokeh):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This sample contains the records, collected within 6 seconds, and the values
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0aacc7fa04821120e12ffb6549f5cd6e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, we can get about 60 measurements per second from the sensor.
    Let’s draw the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: By the way, the Bokeh library is good for plotting data like this. It turned
    out that, at least on my computer, Matplotlib practically “died” when the number
    of points became larger than several thousand. At the same time, Bokeh can handle
    even 1 million records in one graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b13b0125a260bc57e76e1909522ed8ec.png)'
  prefs: []
  type: TYPE_IMG
- en: Accelerometer and gyroscope data, Image by author
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to understand the **difference between a gyroscope and
    an accelerometer**. An accelerometer (top graph) is measuring *static acceleration*,
    including force from the Earth’s gravity. In this example, I was slowly rotating
    the board in my hand, and all three X, Y, and Z axes were proportionally changing.
    A gyroscope measures the *instantaneous momentum* around each axis. This data
    looks like a derivative of the accelerometer data; when the movement starts, there
    is a peak, then the values are going back to zeros.
  prefs: []
  type: TYPE_NORMAL
- en: 'I was not going to analyze step data in this article, but some readers may
    still be curious about what the **raw sensor data of human steps** looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9051362deed907ca4983ac1b3a6330fa.png)'
  prefs: []
  type: TYPE_IMG
- en: Accelerometer and gyroscope data from human steps, Image by author
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, especially on the gyroscope data graph, the pattern is quite
    straightforward to detect. And for the purpose of this article, it is more challenging
    to see if we can detect much slighter variations in the data, like the vibrations
    of the building.
  prefs: []
  type: TYPE_NORMAL
- en: Data Analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous steps, we saw how to make a simple application to collect sensor
    data and got a general insight into what this data looks like. Now, let’s see
    in more detail what interesting patterns can be found. For all further examples,
    I will be using data collected within 24 hours.
  prefs: []
  type: TYPE_NORMAL
- en: '**1\. Timestamp Accuracy**'
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, sensor data was collected using a Python application running
    on a Raspberry Pi. The Raspberry Pi itself is running Linux, which is not a real-time
    OS. First, let’s see the timestamp accuracy we have.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'I have collected 5,513,693 records within 24 hours; the total file size is
    about 500 MBytes. As we can see, the average difference between timestamps is
    0.015 s, and the average fps is about 64\. But how consistent is it? Let’s create
    a **histogram of the time difference**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that indeed, Raspbian is not an RTOS, but the accuracy is good enough
    for our task:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4558ed1d4e204f756be53443a231307b.png)'
  prefs: []
  type: TYPE_IMG
- en: Timestamps difference in milliseconds, Image by author
  prefs: []
  type: TYPE_NORMAL
- en: 5,349,277 records (more than 70%) have about 0,015 s (15 ms) of delay, and only
    less than 50 records (0.001%) have intervals longer than 0,01 s (100 ms).
  prefs: []
  type: TYPE_NORMAL
- en: '**2\. Sonogram**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‘s go to the more fun stuff. We obviously cannot analyze 5 million records
    with the naked eye. Let’s build a sonogram, which will allow us to see if there
    are some anomalies in the frequency domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The sonogram is based on the Fast Fourier Transform (FFT), which converts the
    values from a “time-based” domain to a “frequency” domain. The maximum frequency
    on the sonogram is about 30 Hz, which is equal to half of the sampling rate according
    to Nyquist’s theorem. Doing the calculations manually may require a lot of work,
    but Matplotlib’s “*specgram”* method does it all for us. The result looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7bbf2f08a6327c4b141dc631c2caedbf.png)'
  prefs: []
  type: TYPE_IMG
- en: Sonogram of the sensor data, Image by author
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, there are some spots on the graph, but the building where I live
    has no clearly visible resonant frequencies. But for other types of construction
    (motors, machines, bridges, etc.), this type of analysis can be useful.
  prefs: []
  type: TYPE_NORMAL
- en: '**3\. Heatmap**'
  prefs: []
  type: TYPE_NORMAL
- en: If we want to find some patterns in the vibration data, it makes sense to see
    the signal amplitude on the timeline. But there are too many records, and plotting
    them on one line will not be effective. In this case, the heatmap will be much
    better.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the heatmap, I preprocessed the data using three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Normalization. I extracted the mean and took the absolute value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Taking the maximum for the rolling period. This part is a bit more tricky.
    In the vibration data, short 1–2 s peaks can occur. Such small peaks will not
    be visible on the 24-hour timeline, so I decided to take a “rolling maximum” using
    this code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Practically, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c3d2a4edbe88227dfd9362031a467d75.png)'
  prefs: []
  type: TYPE_IMG
- en: Data processing example, Image by author
  prefs: []
  type: TYPE_NORMAL
- en: In this example, I set the number of samples for rolling to 400\. Instead of
    a short (violet) peak, we will have a much bigger spot on the heatmap.
  prefs: []
  type: TYPE_NORMAL
- en: 'The heatmap itself can be displayed using the “heatmap” method in Seaborn.
    The full code with preprocessing and drawing is presented below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The final image looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2b9cd32d7347cc0a6701a6aa6b73304e.png)'
  prefs: []
  type: TYPE_IMG
- en: MPU6050 vibration data heatmap, Image by author
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, getting all 24-hour data in one image is much more “explanatory”.
    For example, we can easily see the vibrations from the transport, which occurred
    in the morning at 9 a.m. and in the evening between 4 and 6 p.m.
  prefs: []
  type: TYPE_NORMAL
- en: I did not implement brightness adjustment; it can be changed manually in the
    code by tuning the parameters *vmin* and *vmax* of the *sns.heatmap* call. The
    data itself has no gaps, and processing of the missing values is not implemented
    here.
  prefs: []
  type: TYPE_NORMAL
- en: '**4\. Anomalies Detection**'
  prefs: []
  type: TYPE_NORMAL
- en: On the heatmap, we can see some interesting patterns, like the vibration caused
    by transport in the evening time. And we can also see some bright white spots
    — it is interesting to know what is it.
  prefs: []
  type: TYPE_NORMAL
- en: To detect such “anomalies”, we will try two approaches. First, we can just find
    the data that is bigger than a threshold. As a second approach, we can use ready-to-use
    libraries like Python Outlier Detection (PyOD). Let’s test both!
  prefs: []
  type: TYPE_NORMAL
- en: '**Filtering with a threshold** is straightforward. As a threshold, I selected
    a large value (7 standard deviations), so the probability of getting such levels
    of vibration by chance is minuscule. As for filtering itself, Pandas already have
    all the needed methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As an output, we get array indexes. But some of the items are too close; for
    example, indexes 3065854 and 3065855 definitely represent the same event. To filter
    the array, I created a helper method to remove redundant items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here the parameter “num_samples” is used as a criterion; all array items closer
    than this value will be removed from the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can show results with Bokeh:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4a8e37e52b1c34d86629149f025f7fe3.png)'
  prefs: []
  type: TYPE_IMG
- en: Anomalies, detected by a threshold, Image by author
  prefs: []
  type: TYPE_NORMAL
- en: As the last step of this article, let’s find anomalies using the [**Python Outlier
    Detection (PyOD)**](https://github.com/yzhao062/pyod) library. This library has
    more than 40 algorithms implemented; I will show one of them just to give readers
    an idea of how it works. I will be using a proximity-based KNN (k Nearest Neighbors)
    algorithm, which uses the distance to the kth nearest neighbor as the outlier
    score.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to fit the algorithm using some data. To do this, I’ve used
    one of the indexes that were found before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, there are two major differences between using PyOD and my “naive”
    approach. First, PyOD can analyze *multivariate data*, so we can use all three
    axes from the sensor. Second, based on our domain knowledge, we need to specify
    a *contamination* rate. I was looking for very rare and short events, which can
    occur once every several hours, so I put this value at 0.0001.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the detector is trained, we can simply use a “predict” method to process
    another set of data and get the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the results in a visual form, let’s draw inputs and predictions on the
    same graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the red, green, and blue lines are representing the sensor data, and the
    gray line is a prediction result, the small peaks are showing indexes where the
    outliers were detected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/28d6d5fea3251434d25c664b76741c87.png)'
  prefs: []
  type: TYPE_IMG
- en: Anomaly detection with PyOD, Image by author
  prefs: []
  type: TYPE_NORMAL
- en: It works. And as was written before, there are [more than 40 algorithms](https://github.com/yzhao062/pyod#implemented-algorithms)
    available in PyOD. Readers who wish are welcome to test others on their own. If
    someone would like to test them on the same dataset, write in the comments below,
    and I will share a temporary link.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this article, I explained how to connect the MPU6050 MEMS sensor to a Raspberry
    Pi single-board computer and collect vibration data from a building within several
    days. Then we analyzed this data in different ways, like drawing raw data on a
    timeline and on a heatmap, building a sonogram in the frequency domain, and applying
    an anomaly detection algorithm. This can be interesting for the research of the
    modern urban environment; for example, the vibrations caused by traffic were clearly
    visible on the graph (I was actually surprised that the MPU6050, which was designed
    mostly for smartphones and game controllers, can reliably detect such slight vibrations).
    It can even be possible to detect rare events like earthquakes, though for such
    events, having data from at least two places would be more reliable. Analysis
    of vibrations can also be useful to predict failures in machines like motors or
    turbines. The number of possible applications is actually large.
  prefs: []
  type: TYPE_NORMAL
- en: In general, it was interesting to make this experiment and to work with the
    “real” hardware and its data. Alas, I must admit that the number of articles and
    posts about data science and data analysis in hardware and IoT is minuscule, not
    only on TDS but also on other websites. I hope this story can change this disproportion
    a bit and show readers that working with hardware can be fun.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks for reading. If you enjoyed this story, feel free [to subscribe](https://medium.com/@dmitryelj/membership)
    to Medium, and you will get notifications when my new articles will be published,
    as well as full access to thousands of stories from other authors.
  prefs: []
  type: TYPE_NORMAL
