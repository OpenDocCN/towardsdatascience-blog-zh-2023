- en: Forecasting Intermittent Time Series in Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用Python预测间歇时间序列
- en: 原文：[https://towardsdatascience.com/forecasting-intermittent-time-series-in-python-9fd028a0c9ee](https://towardsdatascience.com/forecasting-intermittent-time-series-in-python-9fd028a0c9ee)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/forecasting-intermittent-time-series-in-python-9fd028a0c9ee](https://towardsdatascience.com/forecasting-intermittent-time-series-in-python-9fd028a0c9ee)
- en: A complete guide on intermittent time series forecasting in Python with a capstone
    project
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python中间歇时间序列预测的完整指南及其重点项目
- en: '[](https://medium.com/@marcopeixeiro?source=post_page-----9fd028a0c9ee--------------------------------)[![Marco
    Peixeiro](../Images/7cf0a81d87281d35ff47f51e3026a3e9.png)](https://medium.com/@marcopeixeiro?source=post_page-----9fd028a0c9ee--------------------------------)[](https://towardsdatascience.com/?source=post_page-----9fd028a0c9ee--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----9fd028a0c9ee--------------------------------)
    [Marco Peixeiro](https://medium.com/@marcopeixeiro?source=post_page-----9fd028a0c9ee--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@marcopeixeiro?source=post_page-----9fd028a0c9ee--------------------------------)[![Marco
    Peixeiro](../Images/7cf0a81d87281d35ff47f51e3026a3e9.png)](https://medium.com/@marcopeixeiro?source=post_page-----9fd028a0c9ee--------------------------------)[](https://towardsdatascience.com/?source=post_page-----9fd028a0c9ee--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----9fd028a0c9ee--------------------------------)
    [Marco Peixeiro](https://medium.com/@marcopeixeiro?source=post_page-----9fd028a0c9ee--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----9fd028a0c9ee--------------------------------)
    ·15 min read·Aug 7, 2023
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·发表于[Towards Data Science](https://towardsdatascience.com/?source=post_page-----9fd028a0c9ee--------------------------------)
    ·15分钟阅读·2023年8月7日
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/b059b7a1862602f8507d5feeee2ed7b8.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b059b7a1862602f8507d5feeee2ed7b8.png)'
- en: Photo by [Wexor Tmg](https://unsplash.com/@wexor?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 照片由[Wexor Tmg](https://unsplash.com/@wexor?utm_source=medium&utm_medium=referral)拍摄，来源于[Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: Intermittent time series, or sparse time series, is a special case where non-zero
    values appear sporadically in time, while the rest of the values are 0.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 间歇时间序列或稀疏时间序列是一种特殊情况，其中非零值在时间上偶尔出现，而其余的值都是0。
- en: A common example of spare time series is rainfall over time. There can be a
    lot of consecutive days without rain, and when it rains, the volume varies.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的稀疏时间序列示例是降雨量随时间的变化。可能会有连续很多天没有降雨，而降雨时，降雨量会有所不同。
- en: Another real-life example of intermittent series is in the demand of slow-moving
    or high-value items, such as spare parts in aerospace or heavy machinery.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个实际的间歇序列示例是对缓慢移动或高价值物品的需求，例如航空航天或重型机械中的备件。
- en: The intermittent nature of some time series pose a real challenge in forecasting,
    as traditional model do not handle intermittency well. Therefore, we must turn
    to alternate forecasting methods tailored for sparse time series.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一些时间序列的间歇性特征在预测中带来了真正的挑战，因为传统模型对间歇性处理不佳。因此，我们必须转向为稀疏时间序列量身定制的替代预测方法。
- en: In this article, we explore different ways of forecasting intermittent time
    series. As always, we explore each model theoretically first, and implement them
    in Python.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇文章中，我们将探讨预测间歇时间序列的不同方法。和往常一样，我们首先从理论上探讨每个模型，然后在Python中实现它们。
- en: As always, the full source code is available on [GitHub](https://github.com/marcopeix/intermittent_time_series).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，完整的源代码可在[GitHub](https://github.com/marcopeix/intermittent_time_series)上获得。
- en: '**Learn the latest time series analysis techniques with my** [**free time series
    cheat sheet**](https://www.datasciencewithmarco.com/pl/2147608294) **in Python!
    Get the implementation of statistical and deep learning techniques, all in Python
    and TensorFlow!**'
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**通过我的** [**免费时间序列备忘单**](https://www.datasciencewithmarco.com/pl/2147608294)
    **在Python中学习最新的时间序列分析技术！获取统计和深度学习技术的实现，全部使用Python和TensorFlow！**'
- en: Let’s get started!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Croston’s method
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Croston方法
- en: Croston’s method is one of the most common approaches to forecasting spare time
    series. It often acts as a baseline model to evaluate more complex methods.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Croston方法是预测稀疏时间序列最常见的方法之一。它通常作为基准模型来评估更复杂的方法。
- en: 'With Croston’s method, two series are constructed from the original series:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Croston方法，从原始序列中构建两个序列：
- en: A series containing the time periods with only zero values
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含只有零值的时间序列
- en: A series containing time periods with non-zero values
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含非零值时间段的时间序列
- en: 'Let’s consider a toy example to illustrate that. Given the spare time series
    below:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个示例来说明这一点。考虑下面的稀疏时间序列：
- en: '![](../Images/df44d08073163f068cc6e4c9d9cb5e02.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/df44d08073163f068cc6e4c9d9cb5e02.png)'
- en: A simulated sparse time series. Image by the author.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模拟的稀疏时间序列。图片由作者提供。
- en: 'Then, according to Croston’s method, we create two new series: one with non-zero
    values, and the other with the period of time separating non-zero values.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，根据 Croston 方法，我们创建两个新的序列：一个包含非零值，另一个包含分隔非零值的时间周期。
- en: '![](../Images/b6871b33517a24311247bf9ad9ac0b30.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b6871b33517a24311247bf9ad9ac0b30.png)'
- en: Constructing two new series. The first has only the non-zero values. The second
    has the period between non-zero values. Note that we assign a period of 1 between
    two consecutive values. Image by the author.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 构建两个新的序列。第一个序列只有非零值。第二个序列是非零值之间的周期。请注意，我们在两个连续值之间分配了周期为 1。图片由作者提供。
- en: From the table above, we can see that the we denote non-zero values as ***qᵢ***
    and the period between two consecutive non-zero values as ***aᵢ***.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从上表中，我们可以看到我们将非零值表示为 ***qᵢ***，两个连续非零值之间的周期表示为 ***aᵢ***。
- en: Note also that the first value of ***aᵢ*** is 1, because we have a non-zero
    value at *t=1*. Also, the period between two consecutive values is also considered
    to be 1.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意 ***aᵢ*** 的第一个值是 1，因为我们在 *t=1* 处有一个非零值。此外，两个连续值之间的周期也被认为是 1。
- en: 'From there, we predict each series using simple exponential smoothing according
    to the equations below:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，我们使用简单指数平滑根据下面的方程预测每个序列：
- en: '![](../Images/a83635165e840d0becbc233ca1c45950.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a83635165e840d0becbc233ca1c45950.png)'
- en: Forecasting non-zero values. Image by the author.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 预测非零值。图片由作者提供。
- en: '![](../Images/1d64db53e151787e3783147263c724ea.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1d64db53e151787e3783147263c724ea.png)'
- en: Forecasting intervals of time between consecutive non-zero values. Image by
    the author.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 预测连续非零值之间的时间间隔。图片由作者提供。
- en: Of course, the smoothing parameter *alpha* is between 0 and 1, as we are using
    simple exponential smoothing. Note also that the same smoothing parameter is used
    for both equations.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，平滑参数 *alpha* 在 0 和 1 之间，因为我们使用的是简单指数平滑。请注意，两条方程中使用的是相同的平滑参数。
- en: 'Then, the final forecast is the ratio of ***q*** and ***a***, as shown in the
    equation below:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，最终预测是 ***q*** 和 ***a*** 的比率，如下方的方程所示：
- en: '![](../Images/f4bb57020e0e29f43c82bd703940cafa.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f4bb57020e0e29f43c82bd703940cafa.png)'
- en: One-step ahead forecast using Croston’s method. Image by the author.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Croston 方法的一步预测。图片由作者提供。
- en: Now, since simple exponential smoothing is used to forecast each series, the
    prediction will be a flat horizontal line. That is why we often use it as a baseline
    model.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于使用简单指数平滑来预测每个序列，预测将是一个平坦的水平线。这就是为什么我们通常将其作为基线模型的原因。
- en: Also, most implementations of the basic Croston’s method use a value of 0.1
    for the smoothing parameter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，大多数基本 Croston 方法的实现使用平滑参数值为 0.1。
- en: Again, this is the most basic method for forecasting intermittent time series,
    but there are ways to easily improve it, as we discuss next.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这是预测间歇性时间序列的最基本方法，但有办法轻松改进它，我们将在接下来讨论。
- en: Improving the Croston’s method
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进 Croston 方法
- en: As we have seen earlier, the classical Croston’s method uses the same smoothing
    parameter of 0.1 to forecast both constructed series, which does not seem to be
    ideal.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，经典的 Croston 方法使用相同的平滑参数 0.1 来预测两个构建的序列，这似乎并不理想。
- en: An optimized version of Croston’s method was suggested, where the smoothing
    parameter is varied between 0.1 and 0.3\. Also, each series is optimized separately.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 提出了 Croston 方法的优化版本，其中平滑参数在 0.1 和 0.3 之间变化。此外，每个序列都是单独优化的。
- en: Everything remains unchanged, but now, we have unique optimized smoothing parameters
    for each series that make up the final forecast.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一切保持不变，但现在我们为每个序列都有唯一的优化平滑参数，这些参数构成了最终预测。
- en: Croston’s method in action
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Croston 方法的应用
- en: Let’s implement Croston’s method on a simulated dataset to see the kind of predictions
    we can make with this model.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个模拟数据集上实现 Croston 方法，看看我们可以用这个模型做出什么样的预测。
- en: First, I will import the required libraries and read the data.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将导入所需的库并读取数据。
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Then, we use the implementation available in *statsforecast*. For now, let’s
    work with the classical version of Croston’s method which uses a smoothing factor
    of 0.1.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 *statsforecast* 中的实现。现在，让我们使用经典版本的 Croston 方法，该方法使用平滑因子 0.1。
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Then, to compare the model’s predictions to the actual data in our simulated
    dataset, we run the cross-validation function. Here, we set the horizon to 1,
    so that our prediction curve is updated at every time step, over the last 50 time
    steps of our dataset.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了将模型的预测与我们模拟数据集中的实际数据进行比较，我们运行交叉验证函数。在这里，我们将预测范围设置为 1，因此我们的预测曲线会在数据集的最后
    50 个时间步上每个时间步进行更新。
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Then, we can plot the actual values and the predictions coming from the model.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以绘制实际值和模型预测值。
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![](../Images/4581f35d3c5bfb5b33c8b4ab98073dfe.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4581f35d3c5bfb5b33c8b4ab98073dfe.png)'
- en: Forecasting the next time step with Croston’s method. Image by the author.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Croston 方法预测下一个时间步。图片由作者提供。
- en: From the figure above, we can see how, intuitively, Croston’s method is really
    a weighted average for intermittent time series.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从上图中，我们可以直观地看到，Croston 方法实际上是间歇时间序列的加权平均。
- en: Looking closely, if a past value was large, then the next prediction would increase,
    and if a past value was small, then the next prediction would decrease.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察，如果过去的值较大，那么下一个预测值会增加；如果过去的值较小，那么下一个预测值会减少。
- en: Notice also the period of time where we have consecutive zero values, meaning
    that the prediction curve does not get updated, and remains flat.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意一段时间内我们有连续的零值，这意味着预测曲线没有更新，保持平坦。
- en: Finally, keep in mind that our prediction curve moves a lot because we forecast
    only the next time step. If we set a longer horizon, the curve resemble more of
    a staircase, since Croston’s method outputs a constant value.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请记住我们的预测曲线变化很大，因为我们只预测下一个时间步。如果我们设定一个更长的预测范围，曲线将更像一个楼梯，因为 Croston 方法输出的是一个恒定值。
- en: Optimized Croston’s method in action
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化的 Croston 方法在实际操作中
- en: Now, let’s repeat the same exercise as above, but using the optimized version
    of Croston’s method, where the smoothing parameter is optimized separately for
    the non-zero values series, and the zero values series.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重复上面的练习，但使用优化版本的 Croston 方法，其中平滑参数分别针对非零值序列和零值序列进行优化。
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Plotting the results gives the following figure.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制结果生成了下图。
- en: '![](../Images/4fa9a8d895ede6d4a9c99d47be0f00c0.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4fa9a8d895ede6d4a9c99d47be0f00c0.png)'
- en: Forecasting with the optimized Croston’s method. It is essentially the same
    thing as the previous method in this case. Image by the author.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用优化后的 Croston 方法进行预测。在这种情况下，它与之前的方法基本相同。图片由作者提供。
- en: Looking at the figure, we can see how optimizing smoothing parameter resulted
    in essentially the same predictions as the classical method for our simulated
    data.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从图中可以看到，优化平滑参数导致的预测与经典方法对我们模拟数据的预测几乎相同。
- en: Now that we understand Croston’s method, let’s move on to another forecasting
    technique.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了 Croston 方法，让我们继续学习另一种预测技术。
- en: Aggregate-Disaggreagate Intermittent Demand Approach (ADIDA)
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 汇总-拆分间歇性需求方法（ADIDA）
- en: The Aggregate-Disaggregate Intermittent Demand Approach, or ADIDA, aims to remove
    intermittence by aggregating the series at a lower frequency.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 汇总-拆分间歇性需求方法（ADIDA）旨在通过在较低频率下汇总序列来去除间歇性。
- en: For example, if hourly data has zero values, then summing over 24 hours to get
    daily data might get rid of the zero values. The same logic applies to intermittent
    daily data that we could aggregate to weekly data to remove periods with zero
    values.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果每小时数据有零值，那么对 24 小时数据求和以获得每日数据可能会去掉零值。同样的逻辑也适用于间歇性的日数据，我们可以将其汇总为周数据，以去除零值期间。
- en: '![](../Images/1d8cc0fddd41c0584c0a19ac929a4093.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1d8cc0fddd41c0584c0a19ac929a4093.png)'
- en: Aggregating our simulated data with a rolling sum of five time steps. Notice
    how the bottom plot (aggregated values) effectively removes the intermittence
    in the series. Image by the author.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 用五个时间步的滚动总和来汇总我们的模拟数据。注意底部图（汇总值）如何有效去除了系列中的间歇性。图片由作者提供。
- en: In the figure above, we can see the effect of aggregation on our simulated data.
    Here, we aggregate over five time steps. The resulting aggregated series, shown
    in the bottom plot, is not intermittent anymore, since we got rid of all zero
    values.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，我们可以看到汇总对模拟数据的影响。这里，我们对五个时间步进行了汇总。结果汇总序列如底部图所示，不再是间歇性的，因为我们去除了所有零值。
- en: Once the data is aggregated, simple exponential smoothing is again used to forecast
    the aggregated series.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据被汇总，简单的指数平滑再次用于预测汇总后的序列。
- en: Then, we disaggregate the predictions to bring them back to the original frequency.
    For example, if hourly data was aggregated to daily data, then each prediction
    would be divided by 24 (since there are 24 hours in a day) to get the disaggregated
    predictions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将预测值拆解回原始频率。例如，如果每小时数据被聚合到每日数据，那么每个预测值将除以24（因为一天有24小时）来得到拆解后的预测值。
- en: How to choose the aggregation level
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何选择聚合水平
- en: Of course, the aggregation level greatly impacts the predictions and performance
    of the model.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，聚合水平对预测和模型性能有很大影响。
- en: If the aggregation is too big, for example going from hourly to weekly data,
    then you might lose a lot of information.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果聚合过大，例如从每小时数据聚合到每周数据，那么可能会丢失很多信息。
- en: If the aggregation is too small, then the resulting series might also be intermittent,
    in which case traditional forecasting methods will not work appropriately.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果聚合过小，则结果系列也可能是间歇性的，此时传统的预测方法将无法适用。
- en: While there is no clear answer on how to choose the aggregation level, one way
    that is implemented in *statsforecast* is to calculate the the length of all intervals
    between non-zero values, and take the average of the intervals as the aggregate
    level.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管没有明确的答案来选择聚合水平，但在*statsforecast*中实现的一种方法是计算非零值之间所有间隔的长度，并取间隔的平均值作为聚合水平。
- en: For example, if your intermittent series has intervals between non-zero values
    of [3, 5, 4], then the aggregate level would be 4.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您的间歇性系列中非零值之间的间隔为[3, 5, 4]，则聚合水平将为4。
- en: In the best case scenario, this method completely removes the intermittency.
    Otherwise, only a few zero values will remain, which should not greatly impact
    exponential smoothing.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在最佳情况下，这种方法可以完全消除间歇性。否则，只有少数零值会残留，这不会对指数平滑产生很大影响。
- en: ADIDA in action
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ADIDA的实际应用
- en: Now, let’s implement ADIDA on our simulated data and see the predictions we
    obtain.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在模拟数据上实现ADIDA，并查看我们获得的预测结果。
- en: Using *statsforecast*, the implementation remains straightforward, as we simply
    need to change the model, but the pipeline stays the same.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*statsforecast*，实现仍然简单明了，我们只需更改模型，但管道保持不变。
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We then plot the predictions and see how it behaves when compared to Croston’s
    method.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们绘制预测图，查看其与Croston方法的比较表现如何。
- en: '![](../Images/6bb3441cf12ba7ef97485d273bae1ddb.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6bb3441cf12ba7ef97485d273bae1ddb.png)'
- en: Forecasting with ADIDA (dotted) and Croston’s method (dashed). We can see that
    ADIDA reacts more to periods with 0 values by lowering the predictions. Image
    by the author.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ADIDA（虚线）和Croston方法（虚线）进行预测。我们可以看到，ADIDA对零值期间的反应更为明显，通过降低预测值来应对。图片由作者提供。
- en: In the figure above, we can see that ADIDA reacts much more to periods with
    zero values. While the predictions from Croston will remain constant if zero values
    are observed, ADIDA will gradually decrease the prediction curve, and so it approaches
    more the actual data.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，我们可以看到ADIDA对零值期间的反应明显更强。尽管Croston的预测在观察到零值时保持不变，但ADIDA将逐渐降低预测曲线，因此更接近实际数据。
- en: While ADIDA considers a single aggregation level, an iteration to the model
    was proposed to consider multiple aggregation levels. This is what we study in
    the next section.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然ADIDA考虑了单一的聚合水平，但模型中提出了一次迭代来考虑多个聚合水平。这是我们在下一节中研究的内容。
- en: Intermittent Multiple Aggregation Prediction Algorithm (IMAPA)
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 间歇性多重聚合预测算法（IMAPA）
- en: As mentioned earlier, ADIDA only considers one aggregation level.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，ADIDA只考虑一个聚合水平。
- en: However, it is possible that information can be retrieved from a series at different
    aggregation levels.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，信息可能会从不同聚合水平的系列中恢复。
- en: For example, given hourly data, different patterns will arise if we aggregate
    the data daily, weekly, or monthly.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，给定每小时数据，如果我们将数据聚合到每日、每周或每月，不同的模式会出现。
- en: This is the general idea behind the Intermittent Multiple Aggregation Prediction
    Algorithm or IMAPA.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是间歇性多重聚合预测算法或IMAPA的基本思想。
- en: Again, the data is aggregated, but at multiple levels. Then, just like with
    ADIDA, simple exponential smoothing is used to generate predictions at each aggregation
    level. After, each prediction is dissagregated, just like in ADIDA.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 数据再次被聚合，但在多个水平上。然后，就像ADIDA一样，使用简单指数平滑来生成每个聚合水平上的预测值。之后，每个预测值被拆解，就像在ADIDA中一样。
- en: The final prediction is then obtained by taking the average of each predictions
    at each aggregation level.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最终预测是通过在每个聚合级别上取每个预测值的平均值得到的。
- en: Thus, we can think of IMAPA as running ADIDA multiple times at different aggregation
    levels, and then simply averaging the predictions to get a final prediction.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将 IMAPA 看作是在不同聚合级别上多次运行 ADIDA，然后简单地平均预测值以获得最终预测。
- en: With all that in mind, let’s see how IMAPA behaves on our simulated data.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这些，让我们看看 IMAPA 在我们模拟数据上的表现。
- en: IMAPA in action
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IMAPA 的实际应用
- en: Still using *statsforecast*, we simply add the IMAPA algorithm to our pipeline.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然使用*statsforecast*，我们只需将 IMAPA 算法添加到我们的管道中。
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Then, we can plot the predictions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以绘制预测图。
- en: '![](../Images/eec9ebe62e799ea01d7e0a8adee5522c.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/eec9ebe62e799ea01d7e0a8adee5522c.png)'
- en: Forecasting with IMAPA. In this case, it gives the same results as ADIDA. Image
    by the author.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 IMAPA 进行预测。在这种情况下，它给出了与 ADIDA 相同的结果。图片来源于作者。
- en: Looking at the figure above, we notice that both curves are overlapping, meaning
    that IMAPA and ADIDA give the same forecasts, in this case.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 看上面的图，我们注意到两条曲线重叠，这意味着 IMAPA 和 ADIDA 在这种情况下给出了相同的预测结果。
- en: While this is underwhelming, keep in mind that we are using simulated data and
    we will work on a real-life dataset soon.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这有些令人失望，但请记住，我们正在使用模拟数据，很快我们将处理实际数据集。
- en: Before that, we have one last method to explore.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前，我们还有一种方法需要探索。
- en: Teunter-Syntetos-Babai model (TSB)
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Teunter-Syntetos-Babai 模型（TSB）
- en: The Teunter-Syntetos-Babais model, or TSB, proposes an improvement over Croston’s
    method.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Teunter-Syntetos-Babais 模型，或 TSB，提出了对 Croston 方法的改进。
- en: As we have seen earlier, predictions from Croston’s method stay constant during
    period with zero values. This means that the predictions can become outdated with
    many periods of zero values.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所见，Croston 方法的预测在零值期间保持不变。这意味着在多个零值期间，预测可能会过时。
- en: In other words, Croston’s method ignores the risk of obsolescence, which occurs
    when non-zero values are separated by longer and longer zero demand periods.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，Croston 方法忽略了过时的风险，这种风险发生在非零值被越来越长的零需求期隔开时。
- en: This is especially important in inventory management of low-demand products,
    as companies can hold stocks of unused inventory for many years, which comes at
    a cost. They must therefore assess the risk of obsolescence to determine if they
    can get rid of dead stock or not.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这在低需求产品的库存管理中尤其重要，因为公司可能会持有多年未使用的库存，这会带来成本。因此，他们必须评估过时的风险，以确定是否可以处理过时库存。
- en: 'This is where the TSB model comes in. Instead of considering the demand interval,
    which are the periods of zero values, it will consider the demand probability,
    defined as:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 TSB 模型的作用。它不会考虑需求间隔（即零值期间），而是考虑需求概率，定义为：
- en: '![](../Images/2423831eec24f52c868813379589f1c4.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2423831eec24f52c868813379589f1c4.png)'
- en: 'Definition of demand probability. Image by R. Teunter, A. Syntetos, M. Babai,
    from [Intermittent demand: Linking forecasting to inventory obsolescence](https://www.sciencedirect.com/science/article/abs/pii/S0377221711004437)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 需求概率的定义。图片来源于 R. Teunter、A. Syntetos、M. Babai，来自[间歇性需求：将预测与库存过时性联系起来](https://www.sciencedirect.com/science/article/abs/pii/S0377221711004437)
- en: While this seems to be a small difference, it can actually have a big impact.
    With Croston’s method, the demand interval can only be updated once we observe
    a non-zero value.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这似乎是一个小差异，但实际上可能会产生很大的影响。使用 Croston 方法时，需求间隔只能在观察到非零值后进行更新。
- en: On the other hand, the demand probability is updated at every time step, making
    the model more flexible.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，需求概率在每个时间步长上都会更新，使模型更具灵活性。
- en: 'To make a prediction, the model also creates two series from the original series:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行预测，模型还会从原始序列中创建两个序列：
- en: One containing only non-zero values (also called **demand**)
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含仅非零值的序列（也称为**需求**）
- en: The other is for the demand probability
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个是需求概率
- en: Predictions for each series is done using simple exponential smoothing. Then,
    the final prediction is obtained by multiplying the demand by the demand probability.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 每个序列的预测是通过简单的指数平滑完成的。然后，通过将需求量与需求概率相乘，得到最终预测。
- en: With all that in mind, let’s apply the TSB model to our simulated data.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这些，让我们将 TSB 模型应用于我们的模拟数据。
- en: TSB in action
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TSB 的实际应用
- en: Unlike the optimized version of Croston’s method, the implementation of TSB
    in *statsforecast* needs us to specify the smoothing parameter for each series.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Croston 方法的优化版本不同，*statsforecast* 中的 TSB 实现需要我们为每个序列指定平滑参数。
- en: This means that we have to manually optimize those parameters. For now, let’s
    just use 0.1 for both parameters, just to see how the model behaves on our simulated
    data.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要手动优化这些参数。现在，我们只使用0.1作为两个参数，只是为了看看模型在我们模拟数据上的表现。
- en: '[PRE7]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Then, we can plot the predictions.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以绘制预测图。
- en: '![](../Images/1c1130c2954ecaab6e9f788974adeb58.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1c1130c2954ecaab6e9f788974adeb58.png)'
- en: Forecasting with TSB. We can see how using the demand probability updates the
    prediction curve during zero-demand periods, unlike Croston’s method. Image by
    the author.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TSB进行预测。我们可以看到，在零需求期间，使用需求概率更新预测曲线，与Croston方法不同。图片由作者提供。
- en: Looking at the figure above, we can see how using the demand probability makes
    a big difference, as the predictions are decreasing during no-demand periods,
    instead of being constant.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 看上面的图，我们可以看到使用需求概率的效果很大，因为预测在无需求期间下降，而不是保持不变。
- en: Now that we have covered many forecasting models for intermittent time series,
    let’s apply our knowledge in a little capstone project.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了许多间歇性时间序列的预测模型，让我们在一个小的capstone项目中应用我们的知识。
- en: Capstone project — Predict the power output of wind turbines
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Capstone 项目 — 预测风力发电机的功率输出
- en: Wind turbines are a source of renewable energy, but are unfortunately unreliable,
    due to the unpredictable nature of wind.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 风力发电机是可再生能源的来源，但由于风的不可预测性，它们不幸地不可靠。
- en: Sometimes, the power output can be very large, and other times, it can be very
    small.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，功率输出可能非常大，而其他时候，它可能非常小。
- en: There can also be days where the wind is too strong, so the wind turbine shuts
    down and no power is generated. Also, there may be not enough wind, which also
    results in no power being produced.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能有风速过强的天，因此风力发电机停机，不产生电力。此外，风速不足也会导致没有电力产生。
- en: Hence, we can see how the power output of a wind turbine is an intermittent
    time series.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到风力发电机的功率输出是一个间歇性时间序列。
- en: As a reminder, you can look at the full source code of this project on [GitHub](https://github.com/marcopeix/intermittent_time_series).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一下，你可以在[GitHub](https://github.com/marcopeix/intermittent_time_series)上查看这个项目的完整源代码。
- en: Data preparation
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据准备
- en: We start by reading our data and formatting it such that we can use *statsforecast*.
    We drop unecessary columns and format the time as a timestamp. Finally, we create
    a *unique_id* column and rename the columns appropriately.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先读取数据并将其格式化，以便我们可以使用*statsforecast*。我们删除不必要的列，并将时间格式化为时间戳。最后，我们创建一个*unique_id*列，并适当地重命名列。
- en: '[PRE8]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![](../Images/054601a00df30eba81ed7c8b36a8f7a6.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/054601a00df30eba81ed7c8b36a8f7a6.png)'
- en: First five rows of the formatted dataset. Image by the author.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化数据集的前五行。图片由作者提供。
- en: Like that, we have our data formatted the way *statsforecast* expects it. Remember
    that the *unique_id* column is to identify different time series within the same
    dataset. In our case, we only have one series, so the *unique_id* is constant
    for all rows.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的数据就按照*statsforecast*的期望格式化了。请记住，*unique_id*列用于识别同一数据集中不同的时间序列。在我们的案例中，我们只有一个序列，所以*unique_id*对所有行都是恒定的。
- en: Then, we can visualize our data. Here, we focus only on the first 200 time steps,
    as we have a fairly large dataset.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以可视化我们的数据。在这里，我们仅关注前200个时间步骤，因为我们有一个相当大的数据集。
- en: '[PRE9]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![](../Images/5e1495a3f7abf727fa13cc5d683b825b.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5e1495a3f7abf727fa13cc5d683b825b.png)'
- en: Power output of a wind turbine in Texas. Image by the author.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 德克萨斯州风力发电机的功率输出。图片由作者提供。
- en: From the figure above, we can see the intermittent nature of our data. We definitely
    notice periods of zero values, and notice also very large swings between high
    power output and low power output.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 从上图中，我们可以看到数据的间歇性。我们确实注意到零值期间，并且还注意到高功率输出和低功率输出之间的非常大波动。
- en: 'Now, let’s try to forecast the power output of the wind turbine. We will consider
    three different forecast horizons:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试预测风力发电机的功率输出。我们将考虑三个不同的预测周期：
- en: one hour
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一小时
- en: one day
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一天
- en: one week
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一周
- en: For each horizon, we will use the mean absolute error (MAE) to evaluate the
    performance of each model and select the best one. Our baseline model will be
    simple exponential smoothing.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个预测周期，我们将使用平均绝对误差（MAE）来评估每个模型的性能，并选择最佳模型。我们的基准模型将是简单指数平滑。
- en: Forecast the next hour
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预测下一小时
- en: To test different models, we simply list them out in a Python list.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试不同的模型，我们只需将它们列出在Python列表中。
- en: Here, we immediately used the optimized implementation of Croston’s method to
    have the optimal values for the smoothing parameters.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once this is done, we can initialize the *Statsforecast* object to pass in our
    dataset, and specify the frequency of our data.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Then, we run cross-validation to compare the predicted values against known
    values. Since we are forecasting the next hour, we set our horizon to 1\. Also,
    we evaluate our models over 50 predictions.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This results in a DataFrame with predictions from each model and the actual
    values. This allows us to plot the predicted values against the real values.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![](../Images/cd1c233e34e83338cd7e8ebd858f9e14.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: Forecasting the power output of a wind turbine for the next hour. Image by the
    author.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: From the figure above, we notice two things.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: First, I did not plot the curve from IMAPA, as it gave the exact same forecast
    as ADIDA.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Second, simple exponential smoothing seems to be doing a really good job at
    forecasting the next time step, since its curve is much closer to the actual values
    than the other models.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: To verify that, let’s calculate the MAE for each model and create a bar plot
    to identify the best model.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![](../Images/7e44897792667c223d32f27675d08cf3.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
- en: MAE of each model when forecasting the next hour. Here, SES is the top model.
    Image by the author.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: With no surprise, simple exponential smoothing is the best model as it achieves
    the lowest MAE. In this situation, it seems that our baseline performs best for
    forecasting the next time step.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how the models behave for forecasting the next day.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Forecast the next day
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To forecast the next day, the *Statforecast* object stays the same.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Now, we simply set the horizon to 24 hours and shift the cross-validation window
    by 24 time steps. Here, we do five rounds of cross-validation.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Then, we can plot the predictions and the actual values.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b235208c80f5c64fb6432933f5449374.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
- en: Forecasting the next 24 hours of power output. Image by the author.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: In the figure above, we notice how our predictions are flat over the horizon,
    which is normal since each model outputs a constant value.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: We can also see that the performance of simple exponential smoothing quickly
    degraded when forecasting on a longer horizon. Clearly, periods with zero values
    are not handled well by simple exponential smoothing.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating each model using the MAE gives the following result.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ed8c06d96122a2fa73cdec1b2208eef2.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
- en: MAE for each model when forecasting the next day. Here, Croston is the best
    model. Image by the author.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: From the figure above, we see that the optimized Croston’s method is the best
    performing model, achieving the lowest MAE. We also that simple exponential smoothing,
    when forecasting on a longer horizon, performs worse than Croston and TSB.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Also, keep in mind that since we increased our forecast horizon, the errors
    also increase, which is to be expected. The further we forecast into the future,
    the more likely we will be far from the actual values.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请记住，由于我们增加了预测范围，误差也增加，这是可以预期的。我们预测的时间越长，离实际值就越远。
- en: Finally, let’s set the horizon for a week.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将预测范围设置为一周。
- en: Forecast the next week
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预测下周
- en: To forecast the next week, we set our horizon to 168 time steps, since there
    are 168 hours in a week, and we have hourly data
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了预测下周，我们将预测范围设置为168个时间步长，因为一周有168小时，我们的数据是按小时记录的。
- en: '[PRE16]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Again, we can plot the predictions of each model.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以绘制每个模型的预测图。
- en: '![](../Images/c07c92a5d70a59825551a8a7cf29455d.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c07c92a5d70a59825551a8a7cf29455d.png)'
- en: Forecasting the power output for next week. Image by the author.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 预测下周的电力输出。图像由作者提供。
- en: The figure above is a bit underwhelming, as we can clearly see that are models
    are very far from the actual values. This is to be expected since our horizon
    is fairly long.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 上图稍显平淡，因为我们可以清楚地看到我们的模型与实际值相距甚远。这是可以预期的，因为我们的预测范围相当长。
- en: Evaluating our models gives the following result.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 评估我们的模型得到了以下结果。
- en: '![](../Images/3f60227eec9810af06cb5ec38d09580c.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3f60227eec9810af06cb5ec38d09580c.png)'
- en: MAE for each model when forecasting the next week. Again, Croston is the best
    model. Image by the author.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 预测下周每个模型的MAE。再次强调，Croston是最好的模型。图像由作者提供。
- en: From the figure above, we again see that Croston’s method is the best model
    as it achieves the lowest MAE.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 从上图来看，我们再次看到Croston的方法是最好的模型，因为它达到了最低的MAE。
- en: Interestingly, we also notice that the MAE did not increase significantly compared
    to forecasting the next day, even though the horizon is the seven times longer.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们还注意到，与预测次日相比，尽管预测期是原来的七倍，MAE并没有显著增加。
- en: Still, in practice, I doubt that forecasting a constant value over a week is
    really going to help make a decision or plan for the future.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，在实践中，我怀疑预测一个常数值一周真的能帮助做决策或计划未来。
- en: Conclusion
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: We have seen how intermittent time series pose an interesting forecasting challenge,
    as traditional models do not handle periods of zero values very well.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，间歇性时间序列提出了有趣的预测挑战，因为传统模型处理零值期间的能力较差。
- en: We explored different forecasting models, like Croston’s method, ADIDA, IMAPA
    and TSB, each bringing a new approach to predicting sparse time series.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探索了不同的预测模型，如Croston方法、ADIDA、IMAPA和TSB，每种方法都提供了预测稀疏时间序列的新方法。
- en: Congratulations on making it to the end and thank you so much for reading! I
    hope that you enjoyed and that your learned something new!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你看到最后，非常感谢你的阅读！希望你喜欢，并且学到了新的东西！
- en: If you are looking to master time series forecasting? The check out [Applied
    Time Series Forecasting in Python](https://www.datasciencewithmarco.com/offers/zTAs2hi6/checkout?coupon_code=ATSFP10).
    This is the only course that uses Python to implement statistical, deep learning
    and state-of-the-art models in 15 guided hands-on projects.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 想掌握时间序列预测吗？那就查看[Python中的应用时间序列预测](https://www.datasciencewithmarco.com/offers/zTAs2hi6/checkout?coupon_code=ATSFP10)。这是唯一一个使用Python在15个引导的实际项目中实现统计、深度学习和最先进模型的课程。
- en: Cheers 🍻
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 干杯 🍻
- en: Support me
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持我
- en: Enjoying my work? Show your support with [Buy me a coffee](http://buymeacoffee.com/dswm),
    a simple way for you to encourage me, and I get to enjoy a cup of coffee! If you
    feel like it, just click the button below 👇
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 喜欢我的工作吗？通过[买杯咖啡](http://buymeacoffee.com/dswm)来支持我，这是一种简单的方式来鼓励我，同时我也能享用一杯咖啡！如果你愿意，只需点击下面的按钮
    👇
- en: '[![](../Images/7ad9438bd50b1698fdd722fa6661b16c.png)](http://buymeacoffee.com/dswm)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](../Images/7ad9438bd50b1698fdd722fa6661b16c.png)](http://buymeacoffee.com/dswm)'
