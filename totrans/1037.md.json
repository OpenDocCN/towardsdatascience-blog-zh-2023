["```py\ndef qaoa(\n  problem, optimize, assess, compute,\n  to_circuit, problem_circuit, ansatz_circuit):\n\n    return optimize(\n        lambda params: assess(\n            problem,\n            compute(to_circuit(\n              problem, params,\n              problem_circuit, ansatz_circuit\n            ))\n        )\n    )\n```", "```py\nfrom qiskit import QuantumCircuit\n\ndef to_circuit(problem, params, problem_circuit, ansatz_circuit):\n    cnt_qubits = problem.size\n    qc_qaoa = QuantumCircuit(cnt_qubits)\n\n    # initial_state\n    qc_qaoa.h(range(cnt_qubits))\n\n    # append problem circuit\n    qc_qaoa.append(problem_circuit(problem, params[0]), range(cnt_qubits))\n\n    # append ansatz circuit\n    qc_qaoa.append(ansatz_circuit(problem, params[1]), range(cnt_qubits))\n\n    qc_qaoa.measure_all()\n    return qc_qaoa\n```", "```py\ndef problem_circuit(problem, gamma):\n    qc_p = QuantumCircuit(problem.size)\n    for i, j in problem.relations:\n        qc_p.rzz(gamma, i, j)\n        qc_p.barrier()\n\n    return qc_p\n```", "```py\ndef ansatz_circuit(problem, beta):\n    qc_a = QuantumCircuit(problem.size)\n    for i in range(problem.size):\n        qc_a.rx(beta, i)\n\n    return qc_a\n```", "```py\nfrom qiskit import Aer, execute\n\ndef compute(circuit):\n  return execute(\n    circuit,\n    Aer.get_backend('qasm_simulator'),\n    shots=1000\n  ).result().get_counts()\n```", "```py\ndef assess(problem, result):\n    avg = 0\n    sum_count = 0\n    for solution, count in result.items():\n        performance = 0\n        for i, j in problem.relations:\n            if solution[i] != solution[j]:\n                performance -= 1\n\n        avg += performance * count\n        sum_count += count\n    return avg/sum_count\n```", "```py\nfrom scipy.optimize import minimize\n\ndef optimize(f_params_to_problem):\n    return minimize(\n        # callable function\n        f_params_to_problem,\n\n        # initial guess on beta and gamma\n        [1.0, 1.0],\n\n        # optimization method\n        method='COBYLA')\n```", "```py\nclass Problem():\n    def __init__(self, nodes, relations):\n        self._nodes = nodes\n        self._relations = relations\n\n    @property\n    def size(self) -> int:\n        return len(self._nodes)\n\n    @property\n    def relations(self) -> int:\n        return self._relations\n```", "```py\nproblem = Problem([0, 1, 2], [(0, 1), (1, 2)])\nresult = qaoa(\n  problem, optimize, assess, compute,\n  to_circuit, problem_circuit, ansatz_circuit\n)\n```", "```py\n fun: -1.632\n   maxcv: 0.0\n message: 'Optimization terminated successfully.'\n    nfev: 32\n  status: 1\n success: True\n       x: array([1.05618646, 2.28854173])\n```", "```py\nfrom qiskit.visualization import plot_histogram\n\nplot_histogram(compute(to_circuit(\n  problem, result.x, problem_circuit, ansatz_circuit\n)))\n```"]