["```py\nxi_hat = xi + np.random.uniform(-1, 1, D) * (xi - xk)\n```", "```py\nclass Bee:\n    def __init__(self, n_dim, param_limits=(-5, 5)):\n        self.low = param_limits[0]\n        self.high = param_limits[1]\n        self.pos = np.random.uniform(\n            low=self.low, high=self.high, size=(n_dim,)\n        )\n        self.fitness = -1e8\n        self.counter = 0\n\n    def explore(self, neighbour, task):\n        phi = np.random.uniform(-1, 1, len(self.pos))\n        new_pos = self.pos + phi * (self.pos - neighbour.pos)\n        new_pos = np.clip(new_pos, self.low, self.high)\n\n        new_fitness = task.score(new_pos)\n        if new_fitness > self.fitness:\n            self.pos = new_pos\n            self.fitness = new_fitness\n            self.counter = 0\n        else:\n            self.counter += 1\n```", "```py\n class Colony:\n    def __init__(self, n_dim, n_population, param_limits):\n        self.n_dim = n_dim\n        self.bees = [Bee(n_dim, param_limits) for _ in range(n_population)]\n        self.best_solution = np.zeros(n_dim)\n        self.best_fitness = -1e8\n        self.limit = 10\n\n    def solve(self, task, num_iterations):\n        for _ in tqdm(range(num_iterations)):\n            # 'Employed bee' Phase\n            for bee in self.bees:\n                partner_idx = np.random.randint(len(self.bees))\n                bee.explore(self.bees[partner_idx], task)\n\n            # 'Onlooker bee' Phase\n            fitnesses = np.array([bee.fitness for bee in self.bees])\n            probs = fitnesses / fitnesses.sum()\n            for _ in range(len(self.bees)):\n                bee_idx = np.random.choice(range(len(self.bees)), p=probs)\n                self.bees[bee_idx].explore(np.random.choice(self.bees), task)\n\n            # 'Scout bee' Phase & Update best solution\n            for bee in self.bees:\n                if bee.counter > self.limit:\n                    bee = Bee(self.n_dim, (bee.low, bee.high))\n                if bee.fitness > self.best_fitness:\n                    self.best_fitness = bee.fitness\n                    self.best_solution = deepcopy(bee.pos)        \n        return self.best_solution\n```", "```py\nx = np.linspace(-5, 5, 100)\ny = np.linspace(-5, 5, 100)\nx, y = np.meshgrid(x, y)\n\ndef multipeak(x, y):\n    peak1 = 0.5 * np.exp(-((x-1)**2 + (y-1)**2))\n    peak2 = 0.6 * np.exp(-((x+1)**2 + (y-1)**2))\n    peak3 = 0.7 * np.exp(-((x-1)**2 + (y+1)**2))\n    peak4 = 0.8 * np.exp(-((x+3)**2 + (y+3)**2))\n    return np.maximum.reduce([peak1, peak2, peak3, peak4])\n\nz = multipeak(x, y)\nprint(\"z.shape: \", z.shape)\n\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\nsurface = ax.plot_surface(x, y, z, cmap='inferno')\n\nax.set_xlabel('X')\nax.set_ylabel('Y')\nplt.title('Surface Plot')\nfig.colorbar(surface, shrink=0.6, aspect=8)\nplt.show()\n```", "```py\ndef full_blackbox(x1, y1, x2, y2, x3, y3, x4, y4):\n    peak1 = 0.5 * np.exp(\n        -((x1-1)**2 + (y1-1)**2 + (x2-1)**2 + (y2-1)**2 + (x3-1)**2 + (y3-1)**2 + (x4-1)**2 + (y4-1)**2)\n    )\n    peak2 = 0.6 * np.exp(\n        -((x1+1)**2 + (y1-1)**2 + (x2+1)**2 + (y2-1)**2 + (x3+1)**2 + (y3-1)**2 + (x4+1)**2 + (y4-1)**2)\n    )\n    peak3 = 0.7 * np.exp(\n        -((x1-1)**2 + (y1+1)**2 + (x2-1)**2 + (y2+1)**2 + (x3-1)**2 + (y3+1)**2 + (x4-1)**2 + (y4+1)**2)\n    )\n    peak4 = 0.8 * np.exp(\n        -((x1+2)**2 + (y1+2)**2 + (x2+2)**2 + (y2+2)**2 + (x3+2)**2 + (y3+2)**2 + (x4+2)**2 + (y4+2)**2)\n    )\n    return np.maximum.reduce([peak1, peak2, peak3, peak4])\n```", "```py\nclass Task:\n    def __init__(self):\n        pass\n\n    def score(self, x_arr, with_noise=False):\n        if with_noise:\n            return full_blackbox(*x_arr) + 0.1*np.random.randn()\n        else:\n            return full_blackbox(*x_arr)\n```", "```py\ntask = Task()\nswarm = Swarm(n_dim=8, n_population=2000, param_limits=(-5, 5))\nsolution = swarm.solve(task, 500)\n\nprint(solution)\nprint(task.score(solution))\n```", "```py\ntask = Task()\ncolony = Colony(n_dim=8, n_population=2000, param_limits=(-5, 5))\nbest_solution = colony.solve(task, 500)\n\nprint(best_solution)\nprint(task.score(best_solution))\n```"]