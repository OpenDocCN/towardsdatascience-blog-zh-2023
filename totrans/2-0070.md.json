["```py\nChapter 1\\. 3D Python Setup\n1.1\\. Environment Setup\n1.2\\. Base Libraries\n1.3\\. 3D Data Libraries\n1.4\\. Geospatial Libraries\n1.5\\. IDE Setup\n\nChapter 2\\. Multi-Modal Data Curation\n2.1\\. 3D Data Sourcing\n2.2\\. Spatial Raster (GIS)\n2.3\\. Vector Data (GIS)\n2.4\\. Other Sources\n\nChapter 3\\. Data Analysis and Profiling\n3.1\\. 3D Point Clouds and voxels\n3.2\\. 3D mesh and city models\n3.3\\. Spatial / Raster Imagery\n3.4\\. DSM, DTM, CHM\n\nChapter 4\\. Registration / Reprojection\n4.1\\. Selecting a Reference System\n4.2\\. Data Georeferencing\n4.3\\. Data Reprojection\n4.4\\. Rigid Registration\n\nChapter 5\\. Data Pre-Processing\n5.1\\. Data Cleaning\n5.2\\. Data Transformation\n5.3\\. Data Reduction\n5.4\\. Data Enrichment (Fusion)\n\nChapter 6\\. Data Visualization and Validation\n6.1\\. 3D Data Inspection\n6.2\\. Point Cloud Canonical Link\n6.3\\. Hybrid Multi-Modal Visualization\n6.4\\. Projection-based Inspection\n\nChapter 7\\. Data Sharing\n7.1\\. Selection Method Definition\n7.2\\. Data Organization\n7.3\\. File Format Definition\n7.4 Export and External Use \n```", "```py\n#base libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n#3D libraries\nimport open3d as o3d\nimport laspy as lp\n\n#geospatial libraries\nimport rasterio as ra\nimport geopandas as gpd\n```", "```py\n#Load a las file\nlas = lp.read(\"../DATA/34FN2_13.laz\")\n```", "```py\nprint([dimension.name for dimension in las.point_format.dimensions])\nprint(np.max(las.red))\nprint(las.header.vlrs[2].string)\n```", "```py\n['X', 'Y', 'Z', 'intensity', ‘return_number’, ‘number_of_returns’, ‘synthetic’, ‘key_point’, ‘withheld’, ‘overlap’, ‘scanner_channel’, ‘scan_direction_flag’, ‘edge_of_flight_line’, ‘classification’, ‘user_data’, ‘scan_angle’, ‘point_source_id’, ‘gps_time’, ‘red’, ‘green’, ‘blue’, ‘nir’, ‘Amplitude’, ‘Reflectance’, ‘Deviation’]\n255\nCOMPD_CS[\"Amersfoort / RD New + NAP height\",PROJCS[“Amersfoort / RD New”,GEOGCS[“Amersfoort”,DATUM[“Amersfoort”,SPHEROID[“Bessel 1841”,6377397.155,299.1528128,AUTHORITY[“EPSG”,”7004\"]],AUTHORITY[“EPSG”,”6289\"]],PRIMEM[“Greenwich”,0,AUTHORITY[“EPSG”,”8901\"]],UNIT[“degree”,0.0174532925199433,AUTHORITY[“EPSG”,”9122\"]],AUTHORITY[“EPSG”,”4289\"]],PROJECTION[“Oblique_Stereographic”],PARAMETER[“latitude_of_origin”,52.1561605555556],PARAMETER[“central_meridian”,5.38763888888889],PARAMETER[“scale_factor”,0.9999079],PARAMETER[“false_easting”,155000],PARAMETER[“false_northing”,463000],UNIT[“metre”,1,AUTHORITY[“EPSG”,”9001\"]],AXIS[“Easting”,EAST],AXIS[“Northing”,NORTH],AUTHORITY[“EPSG”,”28992\"]],VERT_CS[“NAP height”,VERT_DATUM[“Normaal Amsterdams Peil”,2005,AUTHORITY[“EPSG”,”5109\"]],UNIT[“metre”,1,AUTHORITY[“EPSG”,”9001\"]],AXIS[“Gravity-related height”,UP],AUTHORITY[“EPSG”,”5709\"]],AUTHORITY[“EPSG”,”7415\"]]\n```", "```py\ncoords = np.vstack((las.x, las.y, las.z))\ncolors = np.vstack((las.red, las.green, las.blue))\n```", "```py\npcd = o3d.geometry.PointCloud()\npcd.points = o3d.utility.Vector3dVector(coords.transpose())\npcd.colors = o3d.utility.Vector3dVector(colors.transpose()/255)\no3d.visualization.draw_geometries([pcd])\n```", "```py\n#Load a point cloud and visualize\npcd_itc = o3d.io.read_point_cloud(\"../DATA/ITC_outdoor.ply\")\no3d.visualization.draw_geometries([pcd_itc])\n```", "```py\nvox_read = o3d.io.read_voxel_grid(\"../DATA/34FN2_13_vox.ply\", format='auto')\no3d.visualization.draw_geometries([vox_read])\n```", "```py\nmesh = o3d.io.read_triangle_mesh(\"../DATA/10–976–660-LoD22–3D.obj\")\nmesh.get_axis_aligned_bounding_box()\n```", "```py\nmesh.compute_vertex_normals()\no3d.visualization.draw_geometries([mesh])\n```", "```py\nsat_image = ra.open(\"../DATA/RGB_34FN2.tiff\")\nsat_image_array = sat_image.read(1)\nprint(sat_image.meta)\n```", "```py\n{‘driver’: ‘GTiff’, ‘dtype’: ‘uint8’, ‘nodata’: None, ‘width’: 20002, ‘height’: 25002, ‘count’: 3, ‘crs’: CRS.from_epsg(28992), ‘transform’: Affine(0.25, 0.0, 254999.75,\n 0.0, -0.25, 475000.25)}\n```", "```py\nplt.imshow(sat_image_array)\nplt.axis(\"off\")\nplt.show()\n```", "```py\nfrom rasterio.plot import show\ncir_image = ra.open(\"../DATA/CIR_34FN2.tiff\")\nshow(cir_image)\nshow(sat_image)\n```", "```py\ndtm = ra.open(\"../DATA/DTM5_34FN2.TIF\")\n```", "```py\nprint(dtm.meta)\nprint(dtm.shape, dtm.crs, dtm.bounds, dtm.overviews(1))\n```", "```py\n{‘driver’: ‘GTiff’, ‘dtype’: ‘float32’, ‘nodata’: 3.4028234663852886e+38, ‘width’: 1000, ‘height’: 1250, ‘count’: 1, ‘crs’: CRS.from_epsg(28992), ‘transform’: Affine(5.0, 0.0, 255000.0,\n 0.0, -5.0, 475000.0)}\n(1250, 1000) EPSG:28992 BoundingBox(left=255000.0, bottom=468750.0, right=260000.0, top=475000.0)\n```", "```py\ndtm_array = dtm.read(1).astype(‘float64’)\nselection = dtm_array[300:800,300:800]\n```", "```py\n#For the dtm plot with rasterio\nshow(dtm)\n\n#For the dtm zoomed-in plot with matplotlib\nfig, ax = plt.subplots(1, figsize=(15, 15))\nra.plot.show(selection, cmap=’Greys_r’, ax=ax)\nplt.axis(‘off’)\nplt.show()\n```", "```py\nvector_data = gpd.read_file(\"../DATA/gis_osm_roads_free_1.shp\")\n```", "```py\nprint(vector_data.crs)\n```", "```py\n<Geographic 2D CRS: EPSG:4326>\nName: WGS 84\nAxis Info [ellipsoidal]:\n- Lat[north]: Geodetic latitude (degree)\n- Lon[east]: Geodetic longitude (degree)\nArea of Use:\n- name: World.\n- bounds: (-180.0, -90.0, 180.0, 90.0)\nDatum: World Geodetic System 1984 ensemble\n- Ellipsoid: WGS 84\n- Prime Meridian: Greenwich\n```", "```py\nvector_data.plot()\n```", "```py\ntrashcan_data = gpd.read_file(\"../DATA/mapillary-trashcan_points.json\")\n```", "```py\ntrashcan_data.crs\n```", "```py\ntrashcan_data.plot()\n```", "```py\nimage = ra.open(\"../DATA/An8XJdYJkSXycbyDWiVyw8dfVi2IzZ-jr9z7IxneeEXnOJPt0K1C89cMdXNkl5FZT0x6aVuPFRpda6eWV9fcnpgJkPfWjrd7k9harUP48csXGFf2azE1qF7FhkYK4h__j9t6Vd3aUfKcEdlqF_rsVO4.jpg\")\nprint(image.meta)\n```", "```py\nDataset has no geotransform, gcps, or rpcs. The identity matrix will be returned.\n  dataset = DatasetReader(path, driver=driver, sharing=sharing, **kwargs)\n{'driver': 'JPEG', 'dtype': 'uint8', 'nodata': None, 'width': 2048, 'height': 1024, 'count': 3, 'crs': None, 'transform': Affine(1.0, 0.0, 0.0,\n       0.0, 1.0, 0.0)}\n```", "```py\nra.plot.show(image)\n```", "```py\n| Data | Lidar Point Cloud                | TLS Point Cloud | 3D City Mesh                     | Satellite Imagery   | Digital Terrain Model | Streets (Vector)         | Trashcans                      |\n|------|----------------------------------|-----------------|----------------------------------|---------------------|-----------------------|--------------------------|--------------------------------|\n| Name | 34FN2_13.laz                     | ITC_outdoor.ply | 10-976-660-LoD22-3D.obj          | RGB_34FN2.tiff      | DTM5_34FN2.TIF        | gis_osm_roads_free_1.shp | mapillary-trashcan_points.json |\n| CRS  | Amersfoort / RD New + NAP height | None            | Amersfoort / RD New + NAP height | Amersfoort / RD New | Amersfoort / RD New   | WGS 84                   | WGS 84                         |\n| CRSC | 7415                             |                 | 7415                             | 28992               | 28992                 | 4326                     | 4326                           |\n```", "```py\no3d.visualization.draw_geometries([pcd,vox_read,mesh])\n```", "```py\ntrashcan_data_georeferenced = trashcan_data.to_crs(‘epsg:28992’)\ntrashcan_data_georeferenced.plot(color=’red’)\nvector_data_georeferenced = vector_data.to_crs(‘epsg:28992’)\nvector_data_georeferenced.plot(edgecolor=’green’)\n```", "```py\n#We import a specific function\nfrom rasterio.fill import fillnodata\n\n#We transform to a numpy array\ndtm_array = dtm.read(1)\n\n#We interpolate\ninterpolated_dtm = fillnodata(dtm_array, mask=dtm.read_masks(1), max_search_distance=100, smoothing_iterations=0)\n\n#We plot the results\nfig, ax = plt.subplots(1, figsize=(15, 15))\nra.plot.show(interpolated_dtm, cmap='Greys_r', ax=ax)\nplt.axis('off')\nplt.show()\n```", "```py\n#We compute a MinMaxScaler bounds\ncoords_itc = np.array(pcd_itc.points)\nmin_itc = np.min(coords_itc, axis=0)\nmax_itc = np.max(coords_itc, axis=0)\n\n#MinMaxScaling\ncoords_itc_mmscaling = (coords_itc - min_itc) / (max_itc - min_itc)\n```", "```py\nn_bins = 20\nfig, ax = plt.subplots(1, 3, sharey=True, tight_layout=True)\nax[0].hist(coords_itc_mmscaling[:,0], bins=n_bins, color = \"skyblue\")\nax[1].hist(coords_itc_mmscaling[:,1], bins=n_bins, color = \"salmon\")\nax[2].hist(coords_itc_mmscaling[:,2], bins=n_bins,color = \"purple\")\n```", "```py\nfrom shapely.geometry import Polygon\n\nBBlidar=[np.min(coords, axis=1),np.max(coords, axis=1)]\n\nminx=BBlidar[0][0]\nminy=BBlidar[0][1]\nmaxx=BBlidar[1][0]\nmaxy=BBlidar[1][1]\nareabbox = gpd.GeoDataFrame({'geometry':Polygon([(minx,maxy),(maxx,maxy),(maxx,miny),(minx,miny),(minx,maxy)])},index=[0],crs=\"EPSG:28992\")\n```", "```py\nfrom rasterio.mask import mask\n\nin_raster = ra.open(\"../DATA/CIR_34FN2.tiff\")\n\n# Do the clip operation\nout_raster, out_transform = mask(in_raster, areabbox.geometry, filled=False, crop=True)\n\n# Copy the metadata from the source and update the new clipped layer \nout_meta=in_raster.meta.copy() \nout_meta.update({\n    \"driver\":\"GTiff\",\n    \"height\":out_raster.shape[1], # height starts with shape[1]\n    \"width\":out_raster.shape[2], # width starts with shape[2]\n    \"transform\":out_transform})\n\n# Plot the CIR raster\nra.plot.show(out_raster)\n```", "```py\nvoxel_size = 1\n\npcd_downsampled = pcd.voxel_down_sample(voxel_size = voxel_size)\no3d.visualization.draw_geometries([pcd_downsampled])\n```", "```py\nnn_distance = np.mean(pcd.compute_nearest_neighbor_distance())\nprint(nn_distance)\n\n#setting the radius search to compute normals\nradius_normals=nn_distance*4\npcd_downsampled.estimate_normals(search_param=o3d.geometry.KDTreeSearchParamHybrid(radius=radius_normals, max_nn=16), fast_normal_computation=True)\n\n# Visualizing the point cloud\npcd_downsampled.paint_uniform_color([0.6, 0.6, 0.6])\no3d.visualization.draw_geometries([pcd_downsampled])\n```", "```py\no3d.visualization.draw_geometries([pcd,vox_read,mesh])\n```", "```py\n# Plot the Georeferenced Shapefile and Point Cloud together using matplotlib\nvector_data_clipped_pc = vector_data_georeferenced.cx[257000:258000, 471200:472400]\nfig, ax = plt.subplots(figsize=(15, 15))\nvector_data_clipped_pc.plot(ax=ax, color='yellow', edgecolor='yellow')\n# Plot the point cloud\nax.scatter(coords[0][::100], coords[1][::100], c=coords[2][::100])\n# Customize the plot (add labels, titles, legends, etc. if needed)\nax.set_xlabel('X (meters)')\nax.set_ylabel('Y (meters)')\nax.set_title('Shapefile and Point Cloud Visualization')\n# Show the plot\nplt.show()\n```", "```py\n#Clipping vector data\nvector_data_clipped = vector_data_georeferenced.cx[255000:260000, 469000:475000]\n\n#Plot the Raster Imagery with Vector Dataset\nfig, ax = plt.subplots(figsize=(15, 15))\nra.plot.show(sat_image, ax=ax)\nvector_data_clipped.plot(ax=ax, facecolor='none', edgecolor='green')\n\n#Zooming-in\nfig, ax = plt.subplots(figsize=(15, 15))\nplt.axis([258000, 258500, 471000, 471500])\n#The line above actually define the extent of the plot using the coordinates in the CRS.\nra.plot.show(sat_image, ax=ax)\nvector_data_clipped.plot(ax=ax, facecolor='none', edgecolor='cyan')\n```", "```py\n#Overlaying Raster with Vector data\nfig, ax = plt.subplots(figsize=(15, 15))\nplt.axis([257600, 260000, 471000, 471500])\nra.plot.show(sat_image, ax=ax)\ntrashcan_data_georeferenced.plot(ax=ax, facecolor='none', edgecolor='green')\n```", "```py\n# Plot the Shapefile and Point Cloud together using matplotlib\nvector_data_clipped_pc = vector_data_georeferenced.cx[257000:258000, 471200:472400]\nfig, ax = plt.subplots(figsize=(15, 15))\n\n# plot the sattelite imagery\nra.plot.show(sat_image, ax=ax)\n\n# Plot the shapefile\nvector_data_clipped_pc.plot(ax=ax, color='blue', edgecolor='blue')\n\n# Plot the point cloud\nax.scatter(coords[0][::100], coords[1][::100], c=coords[2][::100])\n\n# Customize the plot (add labels, titles, legends, etc. if needed)\nax.set_xlabel('X (meters)')\nax.set_ylabel('Y (meters)')\nax.set_title('Shapefile and Point Cloud Visualization')\n\n# Show the plot\nplt.show()\n```", "```py\nwith ra.open(\"../RESULTS/CIR_34FN2_cropped.tiff\",'w',**out_meta) as wf:\n    wf.write(out_raster)\n```", "```py\nvector_data_clipped_pc.to_file(\"../RESULTS/roads.shp\")\n```"]