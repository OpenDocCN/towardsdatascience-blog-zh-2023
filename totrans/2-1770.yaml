- en: 'Recommender System: Collaborative Filtering with Matrix Factorization'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/recommendation-system-with-matrix-factorization-ebc4736869e4](https://towardsdatascience.com/recommendation-system-with-matrix-factorization-ebc4736869e4)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation of Recommendations through Matrix Factorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@christienatashia?source=post_page-----ebc4736869e4--------------------------------)[![Christie
    Natashia](../Images/168aa61f8495c7f3a3eccb880c8a023c.png)](https://medium.com/@christienatashia?source=post_page-----ebc4736869e4--------------------------------)[](https://towardsdatascience.com/?source=post_page-----ebc4736869e4--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----ebc4736869e4--------------------------------)
    [Christie Natashia](https://medium.com/@christienatashia?source=post_page-----ebc4736869e4--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----ebc4736869e4--------------------------------)
    ·8 min read·Apr 26, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/59da938334bfc2021061170bbcb4c9df.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [freestocks](https://unsplash.com/es/@freestocks?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Netflix is ​​a popular online streaming platform that offers its subscribers
    a wide range of movies, documentaries, and TV shows. To improve users’ experience,
    Netflix has developed a sophisticated recommendation system that suggests movies
    based on your past viewing history, ratings, and preferences.
  prefs: []
  type: TYPE_NORMAL
- en: The recommender system uses complex algorithms that analyze vast amounts of
    data to predict what users will most likely enjoy. With over 200 million subscribers
    worldwide, Netflix’s recommendation system is a key factor in its success and
    sets the standard for the streaming industry. Following is the source on how Netflix
    achieved 80% stream time through personalization [link](https://www.youtube.com/watch?v=f8OK1HBEgn0).
  prefs: []
  type: TYPE_NORMAL
- en: So, What is Recommendation System?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **recommender** system is one of unsupervised learning that uses information
    filtering to suggest products, or content to users based on their preferences,
    interests, and behavior. These systems are widely used in e-commerce and online
    streaming settings, and other applications to help discover new products and content
    that may be of interest to users.
  prefs: []
  type: TYPE_NORMAL
- en: Recommender systems are trained to understand **user** **and** **product** preferences,
    **past** **decisions**, and characteristics using data **collected** about **user-product**
    interactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of recommendation systems as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Content-based Filtering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The recommendation is based on the user or item attribute as the input to the
    algorithm. The contents of the shared attribute space are then used to create
    user and item profiles.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, **Spider-Man: No Way Home** and **Ant-Man and the Wasp: Quantumania**
    have similar attributes as both movies are under the Action/Adventure genre. Not
    only that, both are part of Marvel. Therefore, if Alice watched Spider-Man movie,
    a content-based recommendation system may recommend movies with similar attributes
    like action/Marvel movies.'
  prefs: []
  type: TYPE_NORMAL
- en: Collaborative Filtering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Based on several users who have similar past interactions. The key idea of this
    approach is leveraging the concept of collaboration to produce a new recommendation.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, Alice and Bob have similar interests in particular movies genre.
    A collaborative filtering recommendation system may recommend items to Alice that
    Bob has watched previously which is new to Alice since both of them have pretty
    similar preferences. And the reverse is true for Bob as well.
  prefs: []
  type: TYPE_NORMAL
- en: More on Collaborative Filtering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a wide scope of Recommender System model types as shown in the figure
    below, but today this article will focus on collaborative filtering (CF) with
    Matrix Factorization
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/859ea7896af801238264c22da09b5291.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Type of Recommender System** -Image Illustrated by Author'
  prefs: []
  type: TYPE_NORMAL
- en: Collaborative Filtering with Matrix Factorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Put simply, Matrix Factorization is a mathematical process that transforms a
    complicated matrix into a lower-dimensional space. One of the most popular matrix
    factorization techniques used in recommender systems is Singular Value Decomposition
    (SVD), Non-negative Matrix Factorization (NMF), and Probabilistic Matrix Factorization
  prefs: []
  type: TYPE_NORMAL
- en: Following is the illustration of how the matrix factorization concept is capable
    of predicting the user-movie rating
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ba1390f52378752d88d39d3e214f6e18.png)'
  prefs: []
  type: TYPE_IMG
- en: Image Illustrated by Author
  prefs: []
  type: TYPE_NORMAL
- en: '**Stage 1:** Matrix Factorization will randomly initialize the number, and
    the number of factors (K) is set. In this sample, we will set K = 5'
  prefs: []
  type: TYPE_NORMAL
- en: User Matrix (green box) represents the association between each user and the
    features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Item Matrix (orange box) represents the association between each item and the
    features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, for instance, we are creating 5 features (k=5) to represent the character
    of **m_1** movie: *comedy* as 2.10, *horror* as 0.88, *action* as 0.04, parent-guide
    as 0.02, and family-friendly as 0.04\. And the reverse is true for user_matrix.
    User_matrix represents the character of user such as prefered actors or directors,
    favorite movie production and many more'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Stage 2:** Rating Prediction is calculated from the dot product of *User
    Matrix* and *Item Matrix*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2b4864b7bb0ebea8fca2d49b30d0b1f7.png)'
  prefs: []
  type: TYPE_IMG
- en: where R as true rating, P as User Matrix, Q as Item Matrix, resulted R’ as predicted
    rating.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/614f9e0d91f3157fef6b371ff3fd72d8.png)'
  prefs: []
  type: TYPE_IMG
- en: Image Illustrated by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'In better mathematical notation, the **predicted rating R’** can be represented
    in the equation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c10f09641f5faa238b13959c5faa39c1.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Stage 3:** The squared error is used to calculate the difference between
    true rating and prediction rating'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a36b90b6354f337c30957f0ac8889f8c.png)'
  prefs: []
  type: TYPE_IMG
- en: Once we have these steps in place, we can optimize our parameters, using stochastic
    gradient descent. It will then compute the derivative of this value
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b08894df6b9063b3da129f4d25963a8d.png)![](../Images/303f94e143ceed35f2835ebcde52ef6f.png)'
  prefs: []
  type: TYPE_IMG
- en: At each iteration, the optimizer will compute the match between each movie and
    each user by multiplying them using the dot product, then compare it to the actual
    rating that the user gave the movie. It will then compute the derivative of this
    value and update the weights by multiplying it by the learning rate ⍺. As we repeat
    this process many times, the loss will improve, leading to better recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/eaa6b0e0151596fc165e672bdd7a2148.png)![](../Images/cceac4a18fd80e0817f927ca7c74478e.png)'
  prefs: []
  type: TYPE_IMG
- en: One of matrix factorization models that have been widely used in recommendation
    systems is known as [Singular Value Decomposition](https://en.wikipedia.org/wiki/Singular_value_decomposition)
    (SVD). SVD itself has broad applications, including image compression, and noise
    reduction in signal processing. Additionally, SVD is commonly employed in recommender
    systems, where it is adept at addressing the sparsity issue inherent in large
    user-item matrices.
  prefs: []
  type: TYPE_NORMAL
- en: This article will also provide **an overview** of SVD implementation using the
    Surprise Package.
  prefs: []
  type: TYPE_NORMAL
- en: So let’s get our hands dirty with **the implementation**!!
  prefs: []
  type: TYPE_NORMAL
- en: Implementation Contents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data Import
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data Pre-Processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Implementation #1: Matrix Factorization in Python from Scratch'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Implementation #2: Matrix Factorization with Surprise Package'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The complete notebook on Matrix Factorization implementation is available [here](https://github.com/christienatashiaarchie/Recommendation-System-with-Matrix-Factorization/blob/main/Recomender_Systems_Final.ipynb).
  prefs: []
  type: TYPE_NORMAL
- en: Data Import
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we are developing a recommendation system like Netflix, but we may not
    have access to their big data, we are going to use a great dataset from [MovieLens](https://grouplens.org/datasets/movielens/)
    for this practice [1] *with permission*. Besides, you can read and review their
    [README](https://files.grouplens.org/datasets/movielens/ml-latest-small-README.html)
    files for the usage licenses and other details. This dataset comprises millions
    of movies, users, and users’ past-interacting ranking.
  prefs: []
  type: TYPE_NORMAL
- en: 'After extracting the zip file, there will be 4 csv given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5f46ab66484f7721e6bb05de5adb11b4.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Snapshot of data** -Image by Author'
  prefs: []
  type: TYPE_NORMAL
- en: Data Pre-Processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Btw, Collaborative Filtering has a problem with *user cold-start.* The cold-start
    problem refers to a situation in which a system or algorithm could not make accurate
    predictions or recommendations for new users, items, or entities that has no prior
    information. This can happen when there is little or no historical data available
    for the new users or items, making it difficult for the system to understand their
    preferences or characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: The cold-start problem is a common challenge in recommendation systems, where
    the system needs to provide personalized recommendations for users with limited
    or no interaction history.
  prefs: []
  type: TYPE_NORMAL
- en: In this stage, we are going to select users who have at least interacted with
    2000 movies and movies who have been rated by 1000 users (this can be a good way
    to reduce the size of data and ofc with less null data. Besides, my RAM could
    never handle massive table)
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c0124bbab3a4dc9407abd39ec077b27a.png)'
  prefs: []
  type: TYPE_IMG
- en: '**My RAM condition** -Source: KC Green’s 2013 webcomic'
  prefs: []
  type: TYPE_NORMAL
- en: Actually, you can also use the small subset of 100k ratings which is provided
    by [MovieLens](https://grouplens.org/datasets/movielens/). I just want to optimize
    my computer resources as much as I can with less null data.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/468fd0c2202ad3502bd9855c36312c46.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Data output after data pre-processing** -Image by Author'
  prefs: []
  type: TYPE_NORMAL
- en: 'As is customary, we will divide the data into two groups: a training set and
    a testing set — by utilizing the train_test_split method.'
  prefs: []
  type: TYPE_NORMAL
- en: While the information we require is present, it is not presented in a way that
    is beneficial for humans to comprehend. However, I have created a table that presents
    the same data in a format that is easier for humans to understand.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6a82c2a86c08125a249e407bc5a60768.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Raw data** -Image by Author'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation #1: Matrix Factorization in Python from Scratch**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is the Python snippet for implementing Matrix Factorization with the gradient
    descent. The `matrix_factorization` function returns 2 matrices: **nP (user matrix)**
    and **nQ (item matrix)**.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, fit the training dataset to the model and here I set n_factor K = 5\.
    Following that, predictions can be computed by **multiplying nP and the transpose
    of nQ** using the dot product method, as illustrated in the code snippet below.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, here is the final prediction that the matrix_factorization produce
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/19ecdbd9071c12adcefe9f0e90dd2455.png)'
  prefs: []
  type: TYPE_IMG
- en: '**New predicted rating in train set**-Image form Author'
  prefs: []
  type: TYPE_NORMAL
- en: '**Prediction on the Test Set**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following snippet leverages the given **nP (user matrix)** and **nQ (movie
    matrix)** to make a prediction on the test set
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/33a111296f31e0934c781ff59eefd67d.png)'
  prefs: []
  type: TYPE_IMG
- en: '**The rating and pred_rating output of test set-**Image from Author'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating The Prediction Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although there are various evaluation metrics for Recommender Systems, such
    as Precision@K, Recall@K, MAP@K, and the list goes on. For this exercise, I will
    employ a basic accuracy metric namely RMSE. I probably will write other evaluation
    metrics in greater detail in the subsequent article.
  prefs: []
  type: TYPE_NORMAL
- en: As the result, the RMSE on the test set is **0.829**, which is pretty decent
    even before the hyper-tuning is implemented. Definitely, we can tune several parameters
    like learning rate, n_factor, epochs steps for better outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementation #2: Matrix Factorization with Surprise Package'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this segment, we opted for the Python library namely the **surprise package.**
    A [surprise package](https://surprise.readthedocs.io/en/latest/getting_started.html)
    is a Python library for building and evaluating recommendation systems. It provides
    a simple and easy-to-use interface for loading and processing datasets, as well
    as implementing and evaluating different recommendation algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Data Import and Model Training**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/15e0724819ac38d4e467ed8e992b8a9c.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Top-N recommendation generator**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'for UserId: `231832` following is the top 10 movie recommendation list:'
  prefs: []
  type: TYPE_NORMAL
- en: '*m_912, m_260, m_1198, m_110, m_60069, m_1172, m_919, m_2324, m_1204, m_3095*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5eff3d00f5ad43907716d617fb1353d0.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Top 10 recommendation output** -Image by Author'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The utilization of Matrix Factorization in modern entertainment like Netflix
    helps to understand user preferences. This information is then used to recommend
    the most relevant item/product/movie to the end user.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a summary of the Matrix Factorization illustration that I created, in
    case I need to explain it to my grandkids one day….
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9ab406b9fbe6b4150e3475003c8ab9f8.png)'
  prefs: []
  type: TYPE_IMG
- en: Image Illustrated by Author
  prefs: []
  type: TYPE_NORMAL
- en: Reference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[1] *Maxwell Harper and Joseph A. Konstan. 2015\. The MovieLens Datasets: History
    and Context. ACM Transactions on Interactive Intelligent Systems (TiiS) 5, 4:
    19:1–19:19\.* [*https://doi.org/10.1145/2827872*](https://doi.org/10.1145/2827872)'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://www.kaggle.com/code/jhoward/collaborative-filtering-deep-dive/notebook?source=post_page-----ebc4736869e4--------------------------------)
    [## Collaborative Filtering Deep Dive'
  prefs: []
  type: TYPE_NORMAL
- en: Explore and run machine learning code with Kaggle Notebooks | Using data from
    No attached data sources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: www.kaggle.com](https://www.kaggle.com/code/jhoward/collaborative-filtering-deep-dive/notebook?source=post_page-----ebc4736869e4--------------------------------)
    [](https://www.kaggle.com/code/gspmoreira/recommender-systems-in-python-101?source=post_page-----ebc4736869e4--------------------------------)
    [## Recommender Systems in Python 101
  prefs: []
  type: TYPE_NORMAL
- en: Explore and run machine learning code with Kaggle Notebooks | Using data from
    Articles sharing and reading from CI&T…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'www.kaggle.com](https://www.kaggle.com/code/gspmoreira/recommender-systems-in-python-101?source=post_page-----ebc4736869e4--------------------------------)  [##
    Matrix Factorization: A Simple Tutorial and Implementation in Python'
  prefs: []
  type: TYPE_NORMAL
- en: There is probably no need to say that there is too much information on the Web
    nowadays. Search engines help us a…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: www.quuxlabs.com](http://www.quuxlabs.com/blog/2010/09/matrix-factorization-a-simple-tutorial-and-implementation-in-python/?source=post_page-----ebc4736869e4--------------------------------)
  prefs: []
  type: TYPE_NORMAL
