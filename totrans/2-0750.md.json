["```py\ndef discretize(counts, blocks):\n    weigthed = 0\n    sum_count = 0\n    print (counts)\n    for key, value in counts.items():\n        weigthed += int(key)*int(value*0.999*blocks)\n        sum_count += value\n    return int(weigthed/sum_count)\n```", "```py\nfrom math import asin, sqrt\nfrom qiskit import QuantumCircuit, execute, Aer\nfrom qiskit.visualization import plot_histogram\n\ndef prob_to_angle(prob):\n    return 2*asin(sqrt(prob))\n\ndef simulate_step(blocks, steps, current):\n    qc = QuantumCircuit(1)\n\n    qc.ry(prob_to_angle((current+0.5)/steps), 0)\n\n    # Tell Qiskit how to simulate our circuit\n    backend = Aer.get_backend('statevector_simulator') \n\n    # Do the simulation, returning the result\n    result = execute(qc,backend, shots=1000).result()\n\n    # get the probability distribution\n    counts = result.get_counts()\n\n    return discretize(counts, blocks)\n```", "```py\nimport collections\n\nblocks = 4\nsteps = 20\nvalues = [simulate_step(blocks, steps, x) for x in range(steps)]\nprint (values)\n\nsorted(collections.Counter(values).items(), key=lambda x: x[0])\n```", "```py\n{'0': 0.975, '1': 0.025}\n{'0': 0.925, '1': 0.075}\n{'0': 0.875, '1': 0.125}\n{'0': 0.825, '1': 0.175}\n{'0': 0.775, '1': 0.225}\n{'0': 0.725, '1': 0.275}\n{'0': 0.675, '1': 0.325}\n{'0': 0.625, '1': 0.375}\n{'0': 0.575, '1': 0.425}\n{'0': 0.525, '1': 0.475}\n{'0': 0.475, '1': 0.525}\n{'0': 0.425, '1': 0.575}\n{'0': 0.375, '1': 0.625}\n{'0': 0.325, '1': 0.675}\n{'0': 0.275, '1': 0.725}\n{'0': 0.225, '1': 0.775}\n{'0': 0.175, '1': 0.825}\n{'0': 0.125, '1': 0.875}\n{'0': 0.075, '1': 0.925}\n{'0': 0.025, '1': 0.975}\n[0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3]\n[(0, 5), (1, 5), (2, 5), (3, 5)]\n```", "```py\ndef simulate_step_qasm(blocks, steps, current):\n    qc = QuantumCircuit(1)\n\n    qc.ry(prob_to_angle((current+0.5)/steps), 0)\n    qc.measure_all()\n\n    # Tell Qiskit how to simulate our circuit\n    backend = Aer.get_backend('qasm_simulator') \n\n    # Do the simulation, returning the result\n    result = execute(qc,backend, shots=1000).result()\n\n    # get the probability distribution\n    counts = result.get_counts()\n\n    return discretize(counts, blocks)\n```", "```py\nvalues = [simulate_step_qasm(blocks, steps, x) for x in range(steps)]\nprint (values)\nsorted(collections.Counter(values).items(), key=lambda x: x[0])\n```", "```py\n{'1': 29, '0': 971}\n{'1': 74, '0': 926}\n{'1': 130, '0': 870}\n{'1': 161, '0': 839}\n{'1': 218, '0': 782}\n{'0': 742, '1': 258}\n{'1': 325, '0': 675}\n{'0': 621, '1': 379}\n{'0': 599, '1': 401}\n{'0': 506, '1': 494}\n{'1': 516, '0': 484}\n{'0': 447, '1': 553}\n{'0': 390, '1': 610}\n{'0': 318, '1': 682}\n{'0': 284, '1': 716}\n{'0': 225, '1': 775}\n{'0': 169, '1': 831}\n{'1': 871, '0': 129}\n{'0': 67, '1': 933}\n{'0': 20, '1': 980}\n[0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3]\n[(0, 5), (1, 5), (2, 5), (3, 5)]\n```", "```py\nfrom qiskit import transpile\nfrom qiskit.providers.fake_provider import FakeQuito\nfrom qiskit.providers.aer import AerSimulator\n\n# create a fake backend\ndevice_backend = FakeQuito()\n\n# create a simulator from the backend\nsim_quito = AerSimulator.from_backend(device_backend)\n\ndef simulate_step_noise(blocks, steps, current):\n    qc = QuantumCircuit(1)\n\n    qc.ry(prob_to_angle((current+0.5)/steps), 0)\n    qc.measure_all()\n\n    # Tell Qiskit how to simulate our circuit\n    # transpile the circuit\n    mapped_circuit = transpile(qc, backend=sim_quito)\n\n    # run the transpiled circuit, no need to assemble it\n    result = sim_quito.run(mapped_circuit, shots=1000).result()\n\n    # get the probability distribution\n    counts = result.get_counts()\n\n    return discretize(counts, blocks)\n```", "```py\nvalues = [simulate_step_noise(blocks, steps, x) for x in range(steps)]\nprint (values)\nsorted(collections.Counter(values).items(), key=lambda x: x[0])\n```", "```py\n{'1': 55, '0': 945}\n{'1': 83, '0': 917}\n{'0': 855, '1': 145}\n{'1': 177, '0': 823}\n{'1': 230, '0': 770}\n{'0': 700, '1': 300}\n{'1': 319, '0': 681}\n{'0': 619, '1': 381}\n{'0': 617, '1': 383}\n{'0': 539, '1': 461}\n{'0': 496, '1': 504}\n{'1': 541, '0': 459}\n{'0': 407, '1': 593}\n{'1': 623, '0': 377}\n{'1': 663, '0': 337}\n{'0': 284, '1': 716}\n{'0': 219, '1': 781}\n{'0': 178, '1': 822}\n{'1': 862, '0': 138}\n{'0': 80, '1': 920}\n[0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3]\n[(0, 5), (1, 5), (2, 6), (3, 4)]\n```", "```py\nsteps = 24\nblocks = 8\nvalues = [simulate_step_noise(blocks, steps, x) for x in range(steps)]\nprint (values)\nsorted(collections.Counter(values).items(), key=lambda x: x[0])\n```", "```py\n{'1': 45, '0': 955}\n{'1': 71, '0': 929}\n{'1': 132, '0': 868}\n{'1': 134, '0': 866}\n{'0': 811, '1': 189}\n{'1': 202, '0': 798}\n{'1': 266, '0': 734}\n{'0': 700, '1': 300}\n{'1': 325, '0': 675}\n{'1': 368, '0': 632}\n{'1': 413, '0': 587}\n{'1': 440, '0': 560}\n{'1': 486, '0': 514}\n{'1': 530, '0': 470}\n{'1': 580, '0': 420}\n{'1': 623, '0': 377}\n{'0': 354, '1': 646}\n{'0': 301, '1': 699}\n{'0': 275, '1': 725}\n{'0': 226, '1': 774}\n{'0': 213, '1': 787}\n{'1': 825, '0': 175}\n{'0': 121, '1': 879}\n{'0': 97, '1': 903}\n[0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7]\n[(0, 2), (1, 4), (2, 4), (3, 3), (4, 3), (5, 3), (6, 3), (7, 2)]\n```"]