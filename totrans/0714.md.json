["```py\nstreamlit-population-canada\n├── data\n│   └── quarterly_canada_population.csv\n├── pages\n│   └── forecast.py\n├── main.py\n├── README.md\n└── requirements.txt\n```", "```py\nimport streamlit as st\nimport pandas as pd\nimport numpy as np\n\n@st.cache_data\ndef read_data():\n    URL = \"https://raw.githubusercontent.com/marcopeix/streamlit-population-canada/master/data/quarterly_canada_population.csv\"\n    df = pd.read_csv(URL, index_col=0, dtype={'Quarter': str, \n                                          'Canada': np.int32,\n                                          'Newfoundland and Labrador': np.int32,\n                                          'Prince Edward Island': np.int32,\n                                          'Nova Scotia': np.int32,\n                                          'New Brunswick': np.int32,\n                                          'Quebec': np.int32,\n                                          'Ontario': np.int32,\n                                          'Manitoba': np.int32,\n                                          'Saskatchewan': np.int32,\n                                          'Alberta': np.int32,\n                                          'British Columbia': np.int32,\n                                          'Yukon': np.int32,\n                                          'Northwest Territories': np.int32,\n                                          'Nunavut': np.int32})\n\n    return df \n```", "```py\ndf = read_data()\n\nif df not in st.session_state:\n    st.session_state['df'] = df\n```", "```py\ndf = st.session_state['df'] \n```", "```py\nimport streamlit as st\n\nst.title('Forecast the Quarterly Population in Canada')\n\ncol1, col2 = st.columns(2)\n```", "```py\ntarget = col1.selectbox('Select your target', df.columns)\n```", "```py\nhorizon = col2.slider('Choose the horizon', min_value=1, max_value=16, value=1, step=1)\n```", "```py\nforecast_btn = st.button('Forecast')\n```", "```py\n@st.cache_data\ndef rolling_predictions(df, train_len, horizon, window, method):\n\n    TOTAL_LEN = len(df)\n\n    if method == 'ar':\n        best_lags = ar_select_order(df[:train_len], maxlag=8, glob=True).ar_lags\n        pred_AR = []\n\n        for i in range(train_len, TOTAL_LEN, window):\n            ar_model = AutoReg(df[:i], lags=best_lags)\n            res = ar_model.fit()\n            predictions = res.predict(i, i + window -1)\n            oos_pred = predictions[-window:]\n            pred_AR.extend(oos_pred)\n\n        return pred_AR[:horizon]\n\n    elif method == 'holt':\n        pred_holt = []\n\n        for i in range(train_len, TOTAL_LEN, window):\n            des = Holt(df[:i], initialization_method='estimated').fit()\n            predictions = des.forecast(window)\n            pred_holt.extend(predictions)\n\n        return pred_holt[:horizon]\n\n    elif method == 'theta':\n        pred_theta = []\n\n        for i in range(train_len, TOTAL_LEN, window):\n            tm = ThetaModel(endog=df[:i], deseasonalize=False)\n            res = tm.fit()\n            preds = res.forecast(window)\n            pred_theta.extend(preds)\n\n        return pred_theta[:horizon]\n```", "```py\ndef smape(actual, predicted):\n\n    if not all([isinstance(actual, np.ndarray), isinstance(predicted, np.ndarray)]):\n        actual, predicted = np.array(actual), np.array(predicted)\n\n    return round(np.mean(np.abs(predicted - actual) / ((np.abs(predicted) + np.abs(actual))/2))*100, 2)\n```", "```py\n@st.cache_data\ndef test_and_predict(df, col_name, horizon):\n    df = df.reset_index()\n    model_list = ['ar', 'holt', 'theta']\n    train = df[col_name][:-32]\n    test = df[['Quarter', col_name]][-32:]\n    total_len = len(df)\n\n    train_len = len(train)\n    test_len = len(test)\n```", "```py\npred_AR = rolling_predictions(df[col_name], train_len, test_len, horizon, 'ar')\npred_holt = rolling_predictions(df[col_name], train_len, test_len, horizon, 'holt')\npred_theta = rolling_predictions(df[col_name], train_len, test_len, horizon, 'theta')\n\ntest['pred_AR'] = pred_AR\ntest['pred_holt'] = pred_holt\ntest['pred_theta'] = pred_theta\n```", "```py\nsmapes = []\n\nsmapes.append(smape(test[col_name], test['pred_AR']))\nsmapes.append(smape(test[col_name], test['pred_holt']))    \nsmapes.append(smape(test[col_name], test['pred_theta'])) \n```", "```py\nbest_model = model_list[np.argmin(smapes)]\n```", "```py\nif best_model == 'ar':\n    best_lags = ar_select_order(train, maxlag=8, glob=True).ar_lags\n    ar_model = AutoReg(df[col_name], lags=best_lags)\n    res = ar_model.fit()\n    predictions = res.predict(total_len, total_len + horizon - 1)\n\n    return predictions, smapes\n\nelif best_model == 'holt':\n    des = Holt(df[col_name], initialization_method='estimated').fit()\n    predictions = des.forecast(horizon)\n\n    return predictions, smapes\n\nelif best_model == 'theta':\n    tm = ThetaModel(endog=df[col_name], deseasonalize=False)\n    res = tm.fit()\n    predictions = res.forecast(horizon)\n```", "```py\n@st.cache_data\ndef test_and_predict(df, col_name, horizon):\n    df = df.reset_index()\n    model_list = ['ar', 'holt', 'theta']\n    train = df[col_name][:-32]\n    test = df[['Quarter', col_name]][-32:]\n    total_len = len(df)\n\n    train_len = len(train)\n    test_len = len(test)\n\n    pred_AR = rolling_predictions(df[col_name], train_len, test_len, horizon, 'ar')\n    pred_holt = rolling_predictions(df[col_name], train_len, test_len, horizon, 'holt')\n    pred_theta = rolling_predictions(df[col_name], train_len, test_len, horizon, 'theta')\n\n    test['pred_AR'] = pred_AR\n    test['pred_holt'] = pred_holt\n    test['pred_theta'] = pred_theta\n\n    smapes = []\n\n    smapes.append(smape(test[col_name], test['pred_AR']))\n    smapes.append(smape(test[col_name], test['pred_holt']))    \n    smapes.append(smape(test[col_name], test['pred_theta']))    \n\n    best_model = model_list[np.argmin(smapes)]\n\n    if best_model == 'ar':\n        best_lags = ar_select_order(train, maxlag=8, glob=True).ar_lags\n        ar_model = AutoReg(df[col_name], lags=best_lags)\n        res = ar_model.fit()\n        predictions = res.predict(total_len, total_len + horizon - 1)\n\n        return predictions, smapes\n\n    elif best_model == 'holt':\n        des = Holt(df[col_name], initialization_method='estimated').fit()\n        predictions = des.forecast(horizon)\n\n        return predictions, smapes\n\n    elif best_model == 'theta':\n        tm = ThetaModel(endog=df[col_name], deseasonalize=False)\n        res = tm.fit()\n        predictions = res.forecast(horizon)\n\n        return predictions, smapes \n```", "```py\nif forecast_btn:\n    preds, smapes = test_and_predict(df, target, horizon)\n```", "```py\ntab1, tab2 = st.tabs(['Predictions', 'Model evaluation'])\npred_fig, pred_ax = plt.subplots()\npred_ax.plot(df[target])\npred_ax.plot(preds, label='Forecast')\npred_ax.set_xlabel('Time')\npred_ax.set_ylabel('Population')\npred_ax.legend(loc=2)\npred_ax.set_xticks(np.arange(2, len(df) + len(preds), 8))\npred_ax.set_xticklabels(np.arange(1992, 2024 + floor(len(preds)/4), 2))\npred_fig.autofmt_xdate()\ntab1.pyplot(pred_fig)\n```", "```py\neval_fig, eval_ax = plt.subplots()\n\nx = ['AR', 'DES', 'Theta']\ny = smapes\n\neval_ax.bar(x, y, width=0.4)\neval_ax.set_xlabel('Models')\neval_ax.set_ylabel('sMAPE')\neval_ax.set_ylim(0, max(smapes)+0.1)\n\nfor index, value in enumerate(y):\n    plt.text(x=index, y=value + 0.015, s=str(round(value,2)), ha='center')\n\ntab2.pyplot(eval_fig)\n```"]