- en: Python OPP, and Why repr() and str() Matter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/python-opp-and-why-repr-and-str-matter-1cff584328f4](https://towardsdatascience.com/python-opp-and-why-repr-and-str-matter-1cff584328f4)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: PYTHON PROGRAMMING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The article discovers various faces behind using repr() and str() for Python
    classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@nyggus?source=post_page-----1cff584328f4--------------------------------)[![Marcin
    Kozak](../Images/d7faf62e48ed81dab5d8ad92819fff54.png)](https://medium.com/@nyggus?source=post_page-----1cff584328f4--------------------------------)[](https://towardsdatascience.com/?source=post_page-----1cff584328f4--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----1cff584328f4--------------------------------)
    [Marcin Kozak](https://medium.com/@nyggus?source=post_page-----1cff584328f4--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----1cff584328f4--------------------------------)
    ·14 min read·Nov 3, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f8fb381ea5c85aff97d6f167a83d2e54.png)'
  prefs: []
  type: TYPE_IMG
- en: Python classes need string representation to provide the user and the developer
    with more information than just a mess of letters. Photo by [Surendran MP](https://unsplash.com/@sure_mp?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: 'Python classes have many faces. For instance, you can create an empty class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'and it still can be of use, for instance, as [a sentinel value](https://en.wikipedia.org/wiki/Sentinel_value).
    You can add an `__init__()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It still will be a very simple class, but this time, it’ll keep a particular
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'A superb power of Python classes is that they can be used as types, as shown
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that not implementing the `__init__()` method does not mean it doesn’t
    exist. In fact, we overloaded the `__init__()` method above, not just implemented
    it. This is another significant aspect of Python classes that you should know:
    you can overload many other methods, such as `__new__()`, `__eq__()`, and `__setattr__()`.
    If you do not overload these methods, some will have their default implementation
    (like `__init__()`, `__new__()`, `__setattr__()`, and `__eq__()`), while others
    will not (like `__lt__()` and all the other comparison methods other than `__eq__()`,
    `__getitem__()`, `__setitem__()` and `__len__()`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'A class can inherit from another class, like here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: and, also as above, it can use static methods, but also class methods. You can
    create mixin classes and abstract base classes, singletons, and make tons of other
    things, sometimes very useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python classes have so many faces that it would take years to discuss each
    of them in detail, and we’ll be doing so in the future articles. In this one,
    we will focus on one particular aspect: the difference between and the power of
    the `__repr__()` and `__str__()` methods.'
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, you may think this is a minor topic, but it’s actually quite
    important. It’s easy to implement a Python class, but it takes more effort to
    implement a *good* Python class. And it is these minor details that differentiate
    a skillful Python developer from a regular one.
  prefs: []
  type: TYPE_NORMAL
- en: '*Note*: To run doctests, I used Python 3.11\. Don’t be amazed to see that older
    versions of Python could provide slightly different results. If you’d like to
    read more about Python `doctest`ing, grab the following article:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/python-documentation-testing-with-doctest-the-easy-way-c024556313ca?source=post_page-----1cff584328f4--------------------------------)
    [## Python Documentation Testing with doctest: The Easy Way'
  prefs: []
  type: TYPE_NORMAL
- en: doctest allows for documentation, unit and integration testing, and test-driven
    development.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/python-documentation-testing-with-doctest-the-easy-way-c024556313ca?source=post_page-----1cff584328f4--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: '`repr` vs `str`'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In theory, `repr()` should return an unambiguous string representation of an
    object, from which you should be able to recreate the object. `str()`, on the
    other hand, should return a human-readable string representation of an object.
  prefs: []
  type: TYPE_NORMAL
- en: So, still in theory, `repr()` should provide detailed information about the
    objects it’s used for, while `str()` should provide a readable string explaining
    what the object is and what it may contain. For example, we use `str()` to see
    an object in an interactive session or for logging purposes. But when we're debugging
    and need more details, `repr()` is the way to go. As we’ll see in the next section,
    we usually call these functions indirectly, without even knowing this — or at
    least without thinking about it.
  prefs: []
  type: TYPE_NORMAL
- en: We compared the `repr()` and `str()` functions above. To implement or overload
    them in a class, we need to use the corresponding methods, `__repr__()` and `__str__()`,
    respectively. If a class defines a `__repr__()` method, it’s used to generate
    the string representation of objects of that class when you call `repr()`. The
    same goes for `str()` and `__str__()`.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll see this in action soon — first let’s see what I meant when I mentioned
    indirect calling `repr()` and `str()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Calling repr()` and `str() indirectly`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There’s a secret related to these two functions, and it’s good to know it.
    Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Focus on the last two calls. As you can see, it can make a difference whether
    or not you use `print()` to print an object in a Python session or just an object’s
    name.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/cf7bd2d3796e42a6a20a265f7242982f.png)'
  prefs: []
  type: TYPE_IMG
- en: Difference between calling print(obj) and obj in a Python session. Image by
    author
  prefs: []
  type: TYPE_NORMAL
- en: 'The image below summarizes this: `print(obj)` calls `str(obj)` while `obj`
    calls `repr(obj)`.'
  prefs: []
  type: TYPE_NORMAL
- en: __repr__ vs __str__
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Above, I explained the concept behind `repr()` and `__repr__()` and `str()`
    and `__str__()`. The former pair should provide more information than the latter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Oftentimes, however, practice shows a different face:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the default implementations of both of these methods are the
    same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: So, even the default implementations of `__str__()` and `__repr__()`, used when
    you don’t overload these two methods in a Python class, go against the rule mentioned
    above. In addition, developers can overload either or both of these methods, and
    in real life, this can also mean going against this very rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens when only one of the two methods is implemented? To show this,
    I’ll implement the following four classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we defined four classes: one with neither `__str__()` nor `__repr__()`,
    two with one of them, and one with both. Let’s see what happens if we call `str()`
    and `repr()` on their instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the conclusions from the above `doctest`s:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement neither `__str__()` nor `__repr__()`: For both, the default implementations
    will be used; they are the same, both providing the class’s name and the instance’s
    address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Implement both `__str__()` and `__repr__()`: Usually, this is the recommended
    approach. It makes your code more readable and maintainable — although, at the
    same time, longer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Implement only `__str__()`: Python will use it for `str()` but for `repr()`
    the default implementation will be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Implement only `__repr__()`: Python will use it for both `str()` and `repr()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, what should I implement?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It depends. The most obvious conclusion is that if you implement a complex class,
    you should define *both* these methods. This will give you more opportunities
    to debug the code and use better logging.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, when you don’t have much time for coding as deadlines are approaching,
    you should implement at the very least one of the methods. Implementing none means
    the string representation of the class will contain little useful information,
    as it will contain the class’s name and the instance’s address. Therefore, do
    so only when you’re certain the class’s name is all you need. In prototyping,
    for example, this is often all you need.
  prefs: []
  type: TYPE_NORMAL
- en: For small classes, implementing only one of the two methods can be enough, but
    always make sure it’s indeed enough. Besides, how often do you have so little
    time to be unable to implement such a simple method as `__str__()` or `__repr__()`?
    I know this can happen — but I don’t think something like this happens more often
    that once in a while. To be honest, in my over five years of Python development,
    this has not happened even once.
  prefs: []
  type: TYPE_NORMAL
- en: So, I think time is seldom a concern. Space, on the other hand, can be. When
    your module contains a number of small classes that take several lines, implementing
    both `__repr__()` and `__str__()` for all of them can double the length of the
    module. This can make a big difference, so it’s worth considering whether both
    methods are needed, and if not, which one should be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Many built-in classes use the same implementation for `__repr__()` and `__str__()`,
    including `dict` and `list`. The same goes for many classes from well-known add-on
    packages, a perfect example from data science realm being `pandas.DataFrame`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s summarize our discussion in a set of rules. To be honest, even though
    I’ve been using them for years, this is the first time I’ve thought to write them
    down. I hope you’ll find them useful in your coding practice to decide whether
    to implement both `__repr__()` and `__str__()`, only one of them, or none:'
  prefs: []
  type: TYPE_NORMAL
- en: When you’re writing a prototype class and don’t plan to use its string representation
    at all, you can ignore both `__repr__()` and `__str__()`. For production code,
    however, think twice before doing so. During development, I often skip these methods
    unless I need to debug the code using the class’s instances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When your class produces complex instances with many attributes, I typically
    consider implementing both `__repr__()` and `__str__()`. Then: (i) The `__str__()`
    method should provide a simple human-readable string representation, which can
    be obtained by printing the instance using both the `print()` and `str()` functions.
    (ii) The `__repr__()` method should provide as much information as possible, including
    all the information required to recreate the class’s instances; this can be obtained
    using the `repr()` function or by typing the instance’s name in the interactive
    session.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your class needs to be used in debugging, make its `__repr__()` method as
    detailed as possible, regardless of whether or not you implement `__str__()`.
    This does not mean that the output of `__repr__()` must be insanely long; instead,
    in such situations, include whatever information is necessary for debugging purposes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a class needs a human-readable string representation and at the same time
    you need to implement a detailed `__repr__()` method, implement `__str__()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a class needs a human-readable string representation but you don’t need the
    detailed `__repr__()`, implement only `__repr__()`. This will give users a nice
    human-readable string representation from both methods, and they will avoid seeing
    the default `__repr__()` representation, which is usually of little value. When
    implementing only `__repr__()`, it is important to be consistent with the format
    of the string that is returned. This will make it easier for users to read and
    understand the output of both `str()` and `repr()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing `__repr__()` and `__str__()`
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know when to implement the two methods, it’s worth to consider how
    to do it. There are only two rules that you *must* follow, and fortunately, both
    are simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one deals with the methods’ arguments, and the other one with the
    types of their return values. We can thus present them using the two methods’
    expected signatures, that is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Is this all?
  prefs: []
  type: TYPE_NORMAL
- en: Basically, yes — but... I wrote these are the *expected* signatures, but the
    truth is, you should treat them as *required* signatures. You’ll see why below.
  prefs: []
  type: TYPE_NORMAL
- en: To learn why, you should know an interesting thing, one that I guess quite a
    few Python users don’t know. I, for one, wasn’t aware of it for quite some times.
  prefs: []
  type: TYPE_NORMAL
- en: 'This rule applies when you want the class’s `__str__()` to work with `str()`
    and `print()`, and `__repr__()` to work with `repr()` and by using the instance’s
    name in the session. To show this, let’s implement a class with `__str__()` having
    a non-optional argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Will the method work?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Hey, it does! So how come I just wrote `__str__()` should *not* take arguments?
  prefs: []
  type: TYPE_NORMAL
- en: 'It should not — although theoretically, it can. It can under an unrealistic
    condition that the only way the method is called is `inst.__str__(10)` (the value
    itself doesn’t matter). Above, we saw such a call, and it worked indeed. But what
    we’ll see now is three bitter failures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'So, using an argument for `__str__()` is not a syntax error, but it’s definitely
    a static error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/bdf41adc130aabeda0cd40eb93dc2310.png)'
  prefs: []
  type: TYPE_IMG
- en: A screenshot from Visual Studio Code. [Sonarlint](https://www.sonarsource.com/knowledge/languages/python/)
    shows that __str__() should not take arguments. Image by author
  prefs: []
  type: TYPE_NORMAL
- en: It definitely is a static error, but as shown above, a bigger problem is that
    using arguments for `__str__()` will most likely lead to a `TypeError` exception
    raised at runtime, as shown above.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typing `inst` directly in a session calls `repr()`, and since we did not implement
    it, the default implementation is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: But as shown before, calling `print(inst)` failed, for the simple reason that
    there was no direct way to providing a value for the non-optional argument `value`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s move on to the other issue, that is, returning an object of a non-string
    type. It seems like something to be considered a static error. Let’s consider
    two versions: untyped and typed class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/956f79dea798cb630678de79bfee5f79.png)'
  prefs: []
  type: TYPE_IMG
- en: A screenshot from Visual Studio Code. Based on an untyped class definition,
    [Sonarlint](https://www.sonarsource.com/knowledge/languages/python/) shows that
    __str__() should return a string. Image by author
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2a26e22b01ee2a0ac13b099aa14ef51e.png)'
  prefs: []
  type: TYPE_IMG
- en: A screenshot from Visual Studio Code. Based on a typed class definition, [Mypy](https://mypy.readthedocs.io/en/stable/)
    shows that __str__() should return a string. Image by author
  prefs: []
  type: TYPE_NORMAL
- en: So, returning a non-string object from a `__str__()` method is definitely a
    static error — but would it also cause raising a runtime `TypeError` exception?
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes, it would:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The rules for `__repr__()` are the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: So, remember *not* to use parameters for `__repr__()` and `__str__()`, and remember
    that both should return strings. But it’s also worth to remember what will happen
    when you break any of these two rules.
  prefs: []
  type: TYPE_NORMAL
- en: Example of a custom class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned above, when you’re implementing a complex custom class, you should
    usually implement both `__str__()` and `__repr__()`, and they should be different.
  prefs: []
  type: TYPE_NORMAL
- en: What does “complex” mean in this context? It can mean different things, but
    in the example below, it means that the class contains some attributes that don’t
    need to be included in the regular string representation, but which we may want
    to include for debugging or logging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will implement a popular `Point` class, but we will make it a little more
    complex:'
  prefs: []
  type: TYPE_NORMAL
- en: Its main attributes are `x` and `y`, defining the point’s coordinates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It also have an optional `group` attribute which defines an instance’s group
    membership; it can be a group like the species in the famous Iris dataset.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also add a comment to the class’s instances. It can be any comment,
    such as “Correct the group”, “Double-check the coordinates” or “Possible mistake”.
    Comments are not used in comparisons — just as a source of information about a
    particular point; we will see this in the code below.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is the implementation of the `Point` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s analyze differences between the `__repr__()` and `__str__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The level of detail*'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned above, such comments are not usually necessary in the regular string
    representation of a class instance. Therefore, we don’t need to include them in
    `__str__()`. However, when we’re debugging, comments can be extremely helpful,
    especially when they provide critical information about a particular class instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is why we should include comments in `__repr__()` but not in `__str__()`.
    Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*A more detailed picture*'
  prefs: []
  type: TYPE_NORMAL
- en: In our implementation, the two methods provide different pictures of a class
    instance. Compare
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In addition to providing a comment, `__repr__()` offers a more detailed picture
    by providing attribute names than does `__str__()`. This may not that big a difference
    in this particular class, but when a class has more attributes you want to include
    in string representation and their names are longer than here, the difference
    could be much more visible. Even here, however, `__str__()` does offer much more
    concise information about an instance than `__repr__()` does.
  prefs: []
  type: TYPE_NORMAL
- en: '*Recreating an instance from* `__repr__()`'
  prefs: []
  type: TYPE_NORMAL
- en: 'We mentioned this one, too. If possible, it’s a good practice to provide in
    `__repr__()` all the information required to recreate the instance. Here, `__str__()`
    is not enough for us to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'It doesn’t matter here that comments are not used to compare instances and
    that, for that reason, `p1 == p1_recreated_from_str` returns `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This only says that from the user’s point of view these two instances are equal.
    From a developers point of view, however, they are not: `p1` is *not* the same
    as `p1_recreated_from_str`. If we want to *fully* recreate `p1`, we need to use
    its ``__repr__()` representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope that reading this article has helped you see the subtle differences between
    `repr()` and `str()`, and between `__repr__()` and `__str__()`. Such subtleties
    may not be required for intermediate Python users, but if you want to be an advanced
    Python user or developer, it is precisely such subtleties that you need to know
    and use in your daily coding.
  prefs: []
  type: TYPE_NORMAL
- en: This is just the tip of the iceberg, but I won’t leave you with just this. We
    have discussed such subtleties of Python before, and we will discuss them even
    more in future articles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks for reading. If you enjoyed this article, you may also enjoy other articles
    I wrote; you will see them [here](https://medium.com/@nyggus). And if you want
    to join Medium, please use my referral link below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/@nyggus/membership?source=post_page-----1cff584328f4--------------------------------)
    [## Join Medium with my referral link - Marcin Kozak'
  prefs: []
  type: TYPE_NORMAL
- en: As a Medium member, a portion of your membership fee goes to writers you read,
    and you get full access to every story…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/@nyggus/membership?source=post_page-----1cff584328f4--------------------------------)
  prefs: []
  type: TYPE_NORMAL
