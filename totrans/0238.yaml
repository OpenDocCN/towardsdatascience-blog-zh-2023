- en: Add interactivity to your web apps with React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/a-step-by-step-guide-to-develop-a-map-based-application-part-iii-ad501c4aa35b](https://towardsdatascience.com/a-step-by-step-guide-to-develop-a-map-based-application-part-iii-ad501c4aa35b)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A Step-by-Step Guide to Develop a Map-Based Application (Part III)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@jacky.kaub?source=post_page-----ad501c4aa35b--------------------------------)[![Jacky
    Kaub](../Images/e66c699ee5a9d5bbd58a1a72d688234a.png)](https://medium.com/@jacky.kaub?source=post_page-----ad501c4aa35b--------------------------------)[](https://towardsdatascience.com/?source=post_page-----ad501c4aa35b--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----ad501c4aa35b--------------------------------)
    [Jacky Kaub](https://medium.com/@jacky.kaub?source=post_page-----ad501c4aa35b--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----ad501c4aa35b--------------------------------)
    ·24 min read·Feb 20, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/87da49187774c09f8bfac884d0cfcb7a.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Edgar](https://unsplash.com/@ymoran?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Maps are a powerful tool for visualizing and understanding geographic data but
    they need specific skills to be designed efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: In this step-by-step guide, we are going to take a deep dive into building a
    map-based application to show the customers' prices of gas stations around them.
    We will cover the different key steps of a product, from original proof of concept
    (POC) to the minimum viable product (MVP)
  prefs: []
  type: TYPE_NORMAL
- en: 'Articles in the series:'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Part I: The proof-of-concept — Build a minimalist demo](/a-step-by-step-guide-to-develop-a-map-based-application-part-i-757766b04f77)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Part II: How to use React to build web apps (Static Layout)](/a-step-by-step-guide-to-develop-a-map-based-application-part-ii-6d3fa7dbd8b9)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Part III: Add interactivity to your web apps with React'
  prefs: []
  type: TYPE_NORMAL
- en: '[Part IV: Build a back-end with PostgreSQL, FastAPI, and Docker](/build-a-back-end-with-postgresql-fastapi-and-docker-7ebfe59e4f06)'
  prefs: []
  type: TYPE_NORMAL
- en: A bit of context around this article
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This article is the direct continuation of Part II in which we started to build
    the UI of the web app using React.
  prefs: []
  type: TYPE_NORMAL
- en: '[In the previous article](/a-step-by-step-guide-to-develop-a-map-based-application-part-ii-6d3fa7dbd8b9),
    we started to explore the potential of React to build web applications and in
    particular for our Gas Station Finder. We ended up with a nice application layout
    that can be run locally on a test-server locally, but nothing yet interactive
    to really navigate through our data. I will not go over what we covered in part
    II and I strongly recommend going through it first as they are part of a whole.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this post, we are going to finalize the React component and conclude on
    the client-side part of our product. In particular, we are going to cover the
    following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing and passing states from component to component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Import and consume data from an API endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update dynamically a page with new data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a few interactive components (slider, special text box…)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle API errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the article, our application will be fully reactive, and the next
    step will be to look at the server side of the application.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7d6d059096e24371bd028a7d6ee3f231.png)'
  prefs: []
  type: TYPE_IMG
- en: The final render of the web app, Author Illustration
  prefs: []
  type: TYPE_NORMAL
- en: As usual, you can find the full code covered in this article on [the related
    GitHub page](https://github.com/jkaub/fuel-station-viewer-react-interactive).
  prefs: []
  type: TYPE_NORMAL
- en: '*Side note: Things are changing fast. I wrote this article in March 2023 and
    I am using* ***React 18.2.0\.*** *If you read this article years after its publication,
    it might be a bit outdated. So be careful with what you will read below.*'
  prefs: []
  type: TYPE_NORMAL
- en: A bit of theory behind React state management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In modern React, we define components just as “fancy” asynchronous functions.
    Those run perpetually and “listen” to some events (for example, a user clicking
    on it, the mousse passing on it, etc…) to execute stuff when an event happens
    (like modifying a variable that will update what is displayed in the screen —
    we call those callback functions).
  prefs: []
  type: TYPE_NORMAL
- en: To make the magic happens, the variables that are meant to be modified by callbacks
    to change the rendering of the component have to be defined in a special way,
    and we call the “state” variables (they manage the state of the application).
    When those variables are modified, all the code inside the component is rerun,
    which can result in changes in the user screen.
  prefs: []
  type: TYPE_NORMAL
- en: Define “state” variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s have a look at how to define those state variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with a very simple example which creates a button that changes color
    when a user clicks on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a3b073790489e59936c3f07df9405700.png)'
  prefs: []
  type: TYPE_IMG
- en: A simple component that changes color, Author Illustration
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let’s check the code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, we import the “useState” hook, which will be used to create the state
    variable that can be modified by callbacks. I will not go into the details, but
    a “hook” is simply a special feature that helps build React interactive components
    out of functions. We will cover two “hooks” in this article, but many more exists
    for a lot of different use cases…
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create our state variable using the useState hook. When you create
    a variable this way you are actually creating two things:'
  prefs: []
  type: TYPE_NORMAL
- en: 'the variable itself (in our case: colorIdx)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A “setter”: a function that will allow you to modify properly your variable
    (setColorIdx)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: useState(0) means that we initiate our variable colorIdx to 0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can then create what we call in React an “**arrow function**” to define the
    callback that will modify the variable colorIdx. An arrow function is nothing
    more than a function with a simpler syntax, which is particularly convenient for
    defining callbacks. The equivalent in python would be the lambda functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The value put inside setColorIdx will become the new value of colorIdx. In the
    case above, every time we call onClickCallBack, we change the value of colorIdx
    from 1 to 0 or from 0 to 1.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we bind our callback to the “onClick” event of the button, so that every
    time the user clicks on it, it will result in changing the index colorIdx.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This colorIdx is then used to modify directly the color style of the button,
    in such a way that it changes from “red” to “green” with every click.
  prefs: []
  type: TYPE_NORMAL
- en: The useEffect hook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The logic above will work well most of the time. The state of a variable is
    modified after a particular event, it re-triggers all the code inside the component,
    and the display on the screen is refreshed.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, in some cases, you don’t want all your code to be re-run when
    a state variable has been modified. This is the case for example when you make
    an API call and download data at the first render of your widget. This data might
    be useful to be downloaded only one time, but once the widget is rendered the
    first time, you don’t want the call to be made multiple times every time a state
    variable is modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take again the example of our button, I simply add a log to illustrate
    the code being rerun at every click:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/679bb3b8783f896f7cb94e201b5ebd50.png)'
  prefs: []
  type: TYPE_IMG
- en: All the code is rerun when the variable state is modified, Author illustration
  prefs: []
  type: TYPE_NORMAL
- en: The avoid this issue, React proposes the useEffect hook. The idea of that hook
    is that every line of code defined inside will be executed only at the initialization
    of the component or when the state variables from a watch list are updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'useEffect takes two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'one function: The code that will be executed during initialization and when
    certain state variables are modified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: one array (the “watch list”) is used to control the re-run of the code inside
    the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the example below, the console.log(“click”) will be executed only at the
    initialization of the widget as the watch list is empty.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/aa3117c19c072e0f31adba264b8cda76.png)'
  prefs: []
  type: TYPE_IMG
- en: The log “click” is triggered only at the initialization, Author Illustration
  prefs: []
  type: TYPE_NORMAL
- en: Retrieve data for our Gas Station Finder app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now all the theoretical material to add reactivity to our components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we want to do is to retrieve the filtered data around a given
    postal code and for a particular gas type. To do this we will need several things:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a state variable that will contain all the information of the stations,
    that can be used by the table and the graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make a callback that will trigger an API call and update the relevant state
    variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dropdown
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start with the Dropdown. In the previous article, the component used to
    be static and nothing would happen if a user was selecting another gas type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/787cf98c9cd653ea05f8b3cfea3031a7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As of now, the value in the <select> tag is hard-coded to “SP95”. We are going
    to replace it with a state variable using useState:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to modify the value when the “onChange” event is fired in the dropdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The onChange callback has an input “event” which contains the information related
    to the change. In our case, we are interested in the new dropdown value accessible
    in “event.target.value”.
  prefs: []
  type: TYPE_NORMAL
- en: 'As one of the first interactive components, let’s detail exactly what is happening
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: The component is initiated with the variable gasType, defined by a useState
    initialized to “SP95”, so this is what will appear in the dropdown box at first.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a user changes the value, it fires the “onChange” callback, which will
    call our handleChange function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In handleChange, we fire the setter of our gasType with the new value of the
    variable accessible via event.target.value, which as result modifies gasType and
    the rendering of the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/d0f7f09021f56836385fc6d144cd4211.png)'
  prefs: []
  type: TYPE_IMG
- en: The dropdown is now showing the latest clicked value, Author Illustration
  prefs: []
  type: TYPE_NORMAL
- en: The Postal Code TextArea
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The logic will be very similar for the text area for postal code with one difference:
    we will enforce our “onChange” function so that only numbers, up to 5 digits,
    can be accepted. To do this, we just test the next value via a regular expression
    (only digits, up to 5) and update the postalCode value only if it matches our
    regex.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/b8b3501858577982ff2827b9977ef28a.png)'
  prefs: []
  type: TYPE_IMG
- en: Illustration of the text area with the controller in place, Author Illustration
  prefs: []
  type: TYPE_NORMAL
- en: The button “Find Stations”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the button is hit, we want to pass the information from the Dropdown and
    the TextArea to an API that will send back stations, prices, and metadata in a
    30km radius around the city of interest.
  prefs: []
  type: TYPE_NORMAL
- en: Clicking on a button can be accessed via another callback named onClick, which
    is fired when a left click happens on it.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s prepare our function for now and simply log postalCode and gasType.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/c1e5847ee18a91d523301acf4dd115e9.png)'
  prefs: []
  type: TYPE_IMG
- en: When we click on Find Stations, we retrieve the latest information from the
    two fields, Author Illustration
  prefs: []
  type: TYPE_NORMAL
- en: A word about the API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the following article, we will discuss more in detail how to set up the server-side
    API using Python + FastAPI. I assume for now that the service is already available
    and that it provides a GET endpoint that provides all the data needed from a postal
    code and a gas type.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, use the below URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://API_URL/stations?oil_type=SP95&postal_code=60560](http://api_url/stations?oil_type=SP95&postal_code=60560)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: will result in sending the metadata of all stations in a 30km radius as well
    as lat/lon from the center of research and the circle coordinates that will be
    consumed to generate the graph and the table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Passing information from one component to another
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another thing to discuss now before going further is the way to pass the information
    from our StationsFilter component to our App component.
  prefs: []
  type: TYPE_NORMAL
- en: In React, information can be propagated from parent to children using “props”.
    This “props” is an object (key/values) that will contain the different elements
    passed as attributes in the tag.
  prefs: []
  type: TYPE_NORMAL
- en: In the example below we access a variable in the Child component via props.childVariable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This way, we can propagate values from Parent to Child. But what about the other
    way around? If you modify a value in Child that you would like to pass to Parent,
    you can do exactly as above, but instead of passing the variable, you can pass
    the setter. And thus, when a callback is fired in Child, it can fire the setter
    from Parent, which will modify the variable define in Parent.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the snippet above, every time a click is done, we fire a function that takes
    the current variable (in props.childVariable), adds +1, and fires the setter that
    will set “variable” in Parent to variable+1.
  prefs: []
  type: TYPE_NORMAL
- en: Finalizing our API call
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With this bit of theory in mind, let’s finalize our component. We start by creating
    multiple state variables in App.js that will be used to store the information
    from the API.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We then pass the setter to our StationsFilter component, where we will load
    the data from the API.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We need now to prepare the API call. In React, this is done using the “fetch”
    method, which takes an URL (for the requests) as well as extra parameters such
    as headers or extra request parameters. Let’s implement it directly in our “HandleClick”
    function used earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Going line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: We first use “fetch” which, by default, makes a GET call to the URL passed in
    the parameter. In our case, we form the URL to include the state variable gasType
    and postalCode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: fetch is an asynchronous function, we need to wait for it to complete before
    processing the data sent by the API. To do so, we use the callback .then() that
    we chain to our API call. When the fetch call is completed, it will automatically
    run the code in .then(). In that case, we receive a Response (from the API) that
    we convert into JSON using res.json(). This is also an asynchronous function,
    so processing its results has to be done by chaining another .then() callback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the last .then(), we retrieve the data parsed as JSON and we simply unpack
    it to lat, lon, and stations_infos. We then fire the different setter defined
    in App.js to update the different state variables. Note that in the case of stationsData,
    we use the spread operation [**…**someArray] which will create a copy of someArray.
    This is to make sure we create a new array to pass to stationsData and not just
    a reference to someArray which could cause some unexpecting behaviors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clicking on the button will now fire the API call that will ultimately update
    the state variables in App.js.
  prefs: []
  type: TYPE_NORMAL
- en: Connect the StationsTable component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If your recall from previous the article, we built the preview of StationsTable
    by using a pre-loaded JSON, which is following exactly the same format as what
    is stored now in the stationsData variable.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading the data from the API and storing them in stationsData was the difficult
    part. Now we just need to modify slightly our StationsTable component to use stationsData
    instead of the pre-loaded JSON.
  prefs: []
  type: TYPE_NORMAL
- en: First, we add an attribute to StationsTable the state variable stationsData
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We then add props to the declaration of the function in StationsTable.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we replace the pre-loaded JSON with the stationsData contained in
    the object props:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: And that’s it, the data in the table will be replaced by the prices of stations
    around the city of interest every time we click on the button.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b1e8638e91fc74c7cabec35f8555e385.png)'
  prefs: []
  type: TYPE_IMG
- en: The update of the Table in action, Author Illustration
  prefs: []
  type: TYPE_NORMAL
- en: Generate the Map with the state variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You should start to be used to it by now, we are going to proceed as before:
    pass the data from App to StationsMap via the attributes of the tag, add props
    to StationsMap, and modify the relevant part of each of the trace we have pre-generated
    in the last article.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now in StationsMap.js, we will create the different traces one by one, following
    the template provided by the python figure (from Part I of this series), and replace
    the relevant data when needed.
  prefs: []
  type: TYPE_NORMAL
- en: I show you here two examples below, then it becomes a bit redundant.
  prefs: []
  type: TYPE_NORMAL
- en: 'The trace for the circle around the perimeter of the research:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The black border of the oil stations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: Mapbox traces require unique identifiers for each trace. To do so, we
    can use a very convenient toolbox called **uuid** which can generate random ids
    for us.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When all our traces are defined, we can put them in a list that will be used
    as an attribute for our plotly component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can take care of the chart layout, using the same method: we take the
    dictionary exposed by the python figure and replace the “hardcoded” attributes
    with our state variables to make the layout interactive. In particular, we need
    to modify the “lat” and “lon” of the center of the layout to make sure that each
    time a user makes a request, the map will automatically recenter on the city of
    that request.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, note something very important here: we are passing our **Mapbox access
    token** in the layout. This is something you don’t want to expose publicly, so
    you should NEVER hard-code it somewhere, or it could be usable by other people
    for other purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add any secret variable in your project, you should add them within a .env
    file in the root of your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The .env should be added to your .gitignore in such a way that you cannot push
    it accidentally to a public place.
  prefs: []
  type: TYPE_NORMAL
- en: In React, you need to respect the prefix REACT_APP_ which will be the only variables
    read by the framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, our .env looks simple like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: With our “data” and “layout” directly plugged into our states variable, we can
    simply generate our plotly graph the same way as we did in the previous article.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Let’s have a look at the web app in action!
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/82e0a523f4ff03027b99c0c9811a9bca.png)'
  prefs: []
  type: TYPE_IMG
- en: The API call interactively modifies the map and the table now, Author Illustration
  prefs: []
  type: TYPE_NORMAL
- en: Improving the details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our app answers now the main “user story”: from a type of oil and a postal
    code, we are able to retrieve and display information about the prices from the
    surrounding stations. And it is already a great step achieved. We would like now
    to improve a bit the user experience with a few improvements that will be detailed
    in this section.'
  prefs: []
  type: TYPE_NORMAL
- en: Initiate the Application with an API call
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our current version of the app initiate in the middle of nowhere, in the middle
    of the sea. This can be a bit disturbing for a user that would arrive there for
    the first time. In order to remove this, we are going to initiate the application
    with an API call around Paris for SP98.
  prefs: []
  type: TYPE_NORMAL
- en: To do so, we are going to use the useEffect “hook” that we described in the
    first part of this article.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we start by passing the API call logic in App.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We then wrap this function in a useEffect hook with gasType=”SP98" and postalCode
    = “75001” which corresponds to the city center of Paris.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As I pass an empty list in the second parameter of the useEffect, this bit of
    code will only be executed at the component initialization, which is exactly what
    we want.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, now that we embedded all our update call logic in a function, we can
    do a bit of refactoring to our StationsFilter component by passing this function
    instead of all the setters for our state variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'And in StationsFilter.js, we just trigger this new function in the “HandleButtonClick”
    callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Adding a distance slider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the current version of the app, we are displaying on the screen all the stations
    in a 30km perimeter, which can make sense in low-density areas but that can also
    be really heavy for high-density areas.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/924b15938260b7e18dcca085c1264531.png)'
  prefs: []
  type: TYPE_IMG
- en: The 30km perimeter research… In which there is way too much information displayed,
    Author's Illustration
  prefs: []
  type: TYPE_NORMAL
- en: To solve this issue, we are going to use a slider to control the perimeter of
    the research, from 1 km to 30 km. With React we have access to a large ecosystem
    of libraries and tools, and after some research, I found a slider component that
    would fit well in the Gas Finder App [here](https://www.npmjs.com/package/react-slider).
    I’ll not detail the styling here, only the interactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by installing the react library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We can import the component simply in our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The slider will control another state variable (the filtering distance). Let’s
    add it to our App.py. I initiate it to 5km as a starting point.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We will integrate the slider between the StationsFilter and the StationsTable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: I will not go too much into the details here and pass on the .css, the component
    takes many parameters such as classes with the thumb and track, and minimum and
    maximum values. I modified the values based on the examples from [the documentation](https://zillow.github.io/react-slider/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Two interesting things to note:'
  prefs: []
  type: TYPE_NORMAL
- en: As for our Dropdown, we can control the value of the slider via our state variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will modify distanceFilter by using another callback: onAfterChange which
    will fire only after the user stops moving the thumb.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At that point, our slider control distanceFilter, and we now need to use it
    to filter the data points. To achieve this, we need to create another array, which
    will be a filtered version of stationsData (the data taken from the API).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We can now simply pass this filteredData instead of stationsData to our components
    and it will automatically update the stations visible based on the distance.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one last thing to do: control the trace that shows the circle showing
    the perimeter of the research. Currently, the circle is based on the output sent
    by the API based on a 30km distance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to make the modification: we could create a new API endpoint
    that would send us the array of points based on a lat/lon/radius and keep the
    logic of creating the circle in the backend, especially if you are more comfortable
    with python. This solution has the massive disadvantage that it will multiply
    the number of API calls every time a user plays a bit with the slider, which is
    something we would like to avoid for performance purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: The other solution is to transpose our python function to calculate the circle
    in Javascript, which will be calculated directly on the client side of the application.
    We will go with that second option for performance reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating a new utils folder located in StationsMap and containing
    a file drawCircle.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'I will transpose exactly the function that we used in python in Part I, but
    this time, in Javascript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: I will not go into the detail of that formula, it is a basic mathematical operation
    and is not relevant to this article. The main function, calcPointsOnCircle, is
    taking a lat/lon representing the center of the circle, a radius, and the number
    of points we desire. It returns an array made of tuples of (lat, lon).
  prefs: []
  type: TYPE_NORMAL
- en: An important point nevertheless if you are new to Javascript is that to make
    your function usable by other files, you need to export it at the end of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The function can be now used directly in StationsMap to calculate interactively
    the circle based on the current state variables (lat/lon and selected distance).
    Let’s have a look at the code modifications.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This concludes this section. By now, we have an interactive slider that controls
    the data displayed on the screen based on a filter on the distance.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/41b705b976195dfdfd9224f07f9d5c10.png)'
  prefs: []
  type: TYPE_IMG
- en: The slider in action, Author Illustration
  prefs: []
  type: TYPE_NORMAL
- en: Keep current zoom level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, every time a user play with the slider, it will reset the plotly
    view and regenerate the layout. The problem with this is that it also reset the
    zoom, which is a behavior we want to avoid, see the illustration below.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e4ce31ef495059ee907e529c0132ac49.png)'
  prefs: []
  type: TYPE_IMG
- en: Issues with zoom, Author Illustration
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to tackle the problem is to control the zoom with the slider value
    so that it automatically adapts to the circle size. In our case, this is a very
    easy modification to perform as we are incrementing distanceFilter 1 by 1\. Thus,
    the simplest way is to create a mapping {current distance value -> zoom wanted}
    and use it to automatically control the zoom level. In StationsMap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '*Note: to do the mapping, I simply iteratively looked for the best zoom level
    given the circle at different values (30,25,20…) and I performed a linear interpolation
    for the values in between.*'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a title above the table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a little change to the app but it brings more clarity to the end user.
    When a request is made, we want a title to show explicitly the location of the
    research and the type of fuel.
  prefs: []
  type: TYPE_NORMAL
- en: The API call provides already the city information and the gas type can be updated
    when a click is made on the button to make a new request.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to pass very quickly on the modifications to make as it is mostly
    reusing what we did until now with updating/passing state variables from one component
    to another.
  prefs: []
  type: TYPE_NORMAL
- en: In App.js, we create our two new state variables
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We can then update the ApiCallAndUpdateState function which is used when a user
    clicks a button.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now simply add a header between the StationsFilter and StationsTable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This now results in a header appearing above the table showing the current location
    of the research, as wanted.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/20dec1084d96f7c700d17259eb4b5a73.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding a header above the table brings more clarity, User Illustration
  prefs: []
  type: TYPE_NORMAL
- en: Consistent colors in the maps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In plotly, not precise lower and upper bounds when defining a heatmap will result
    by default stretching the scale to the minimum and maximum values of the population.
  prefs: []
  type: TYPE_NORMAL
- en: 'This has a major disadvantage: In the case of a station that prices really
    lower or really higher than average, the color scale will not have a relevant
    meaning anymore.'
  prefs: []
  type: TYPE_NORMAL
- en: Another problem we might meet is that the stations' colors will change depending
    on the distance used to filter because the number of stations will change, so
    will the max/min prices, and so, ultimately, the scale.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid the issue, we need to decide on a minimum and maximum value. Given
    the divergence color map used, we would like also the bounds to be symmetric.
    There are many possible solutions to that problem, I personally decided to go
    on “Price average in the 30km radius +/- 10%”, assuming that prices above or below
    that 10% around the average are anyway too high or too low.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compute the average, we need to take the non-filtered data and calculate
    the sum over length. This is done in Javascript using the reduce method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that sumPrice and avgPrice don’t need to be state variables: they will
    be always calculated when the new stationsData is updated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can pass now avgPrice to StationsMap via the props as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: And update the chart by thresholding the prices above or below the defined bound.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The next figure illustrates the difference between standard bounds and our
    custom bounds, which brings more contrast:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/cd7b80951eb60603bb68864dc80d2a9f.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting a lower/upper bound increase the color contrast, Author Illustration
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning hover information in the chart
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Part of the small details to fix, the default hover from plotly needs a bit
    of customization. There are currently two main problems:'
  prefs: []
  type: TYPE_NORMAL
- en: The hover event triggered when a user checks a station shows also the lat/lon
    by default, which is not something we want to see (we would like to see only the
    price)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the mousse passes on the black trace or the red dot, coordinates are also
    displayed and we would like to remove this interaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the first point, we can simply pass a **hovertemplate** parameter that controls
    the content displayed when there is a mousse hover. The below formula includes
    only the parameter in the “text” attribute and <extra></extra> remove the default
    box.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: For the second point, it is even easier, we just need to pass a parameter
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: which will completely remove the hover interaction for the trace.
  prefs: []
  type: TYPE_NORMAL
- en: Handle API errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a last thing we will explore in this article: handling an API error.
    If a user tries a postal code that is not in the database, the API is returning
    a custom error 400\. When this happens, we want to modify our text field to make
    the user understand there was a problem with his input and highlight the input
    field in red.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by adding a new state variable in App.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We can now modify our fetch method to include an action when something abnormal
    happens.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to throw an error if we don’t receive a proper response from
    the API.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we need to catch this error at the end of our processing pipeline,
    and setApiError to “true”. We need also to make sure that apiError is set back
    to “false” after a good request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We can finally pass apiError to our StationsForm component and modify the styling
    of the postalCode text field. One way of doing it is to add an extra class to
    the text field when apiError is “true”…
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: … and add extra CSS for that input-error class
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/6b819b63d2df6aa49a7a8b064cc004b0.png)'
  prefs: []
  type: TYPE_IMG
- en: When a wrong postal code is used, the text field change with a red border, Author
    Illustration
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This last implementation concludes completely the chapter dedicated to the development
    of the UI of a web app using React.
  prefs: []
  type: TYPE_NORMAL
- en: React is gaining more and more traction in the data scientist/data analyst community,
    and even if there is certainly a lot of time to invest in learning the framework,
    we saw through this example that once mastered, this allows us to build robust,
    powerful, and responsive applications.
  prefs: []
  type: TYPE_NORMAL
- en: With the UI completed, are now halfway to the completion of the prototype phase.
    In the next article, we are going to talk about the server side and prepare our
    API and our database.
  prefs: []
  type: TYPE_NORMAL
