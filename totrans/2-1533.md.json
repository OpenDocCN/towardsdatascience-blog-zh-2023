["```py\n## for data\nimport pandas as pd  #1.1.5\nimport numpy as np  #1.21.0\n\n## for plotting\nimport matplotlib.pyplot as plt  #3.3.2\nimport seaborn as sns  #0.11.1\nimport folium  #0.14.0\nfrom folium import plugins\nimport plotly.express as px  #5.1.0\n\n## for simple routing\nimport osmnx as ox  #1.2.2\nimport networkx as nx  #3.0\n\n## for advanced routing \nfrom ortools.constraint_solver import pywrapcp  #9.6\nfrom ortools.constraint_solver import routing_enums_pb2\n```", "```py\ncity = \"Hong Kong\"\n\ndtf = pd.read_csv('data_stores.csv')\ndtf = dtf[dtf[\"City\"]==city][\n        [\"City\",\"Street Address\",\"Latitude\",\"Longitude\"]\n      ].reset_index(drop=True)\ndtf = dtf.reset_index().rename(\n      columns={\"index\":\"id\", \"Latitude\":\"y\", \"Longitude\":\"x\"})\n\nprint(\"tot:\", len(dtf))\ndtf.head(3)\n```", "```py\n# pinpoint your starting location\ni = 0\ndtf[\"base\"] = dtf[\"id\"].apply(lambda x: 1 if x==i else 0)\nstart = dtf[dtf[\"base\"]==1][[\"y\",\"x\"]].values[0]\n\nprint(\"start =\", start)\ndtf.head(3)\n```", "```py\nplt.scatter(y=dtf[\"y\"], x=dtf[\"x\"], color=\"black\")\nplt.scatter(y=start[0], x=start[1], color=\"red\")\nplt.show()\n```", "```py\n# setup\ndata = dtf.copy()\ncolor = \"base\"  #color based on this column\nlst_colors = [\"black\",\"red\"]\npopup = \"id\" #popup based on this column\n\n# base map\nmap_ = folium.Map(location=start, tiles=\"cartodbpositron\", zoom_start=11)\n\n# add colors\nlst_elements = sorted(list(data[color].unique()))\ndata[\"color\"] = data[color].apply(lambda x: \n                  lst_colors[lst_elements.index(x)])\n\n# add popup\ndata.apply(lambda row: \n    folium.CircleMarker(\n            location=[row[\"y\"],row[\"x\"]], popup=row[popup],\n            color=row[\"color\"], fill=True, radius=5).add_to(map_), \n    axis=1)\n\n# add full-screen button\nplugins.Fullscreen(position=\"topright\", title=\"Expand\", \n      title_cancel=\"Exit\", force_separate_button=True).add_to(map_)\n\n# show\nmap_\n```", "```py\n# add lines\nfor i in range(len(dtf)):\n    points = [start, dtf[[\"y\",\"x\"]].iloc[i].tolist()]\n    folium.PolyLine(points, tooltip=\"Coast\", color=\"red\", \n                    weight=0.5, opacity=0.5).add_to(map_)\n\nmap_\n```", "```py\nlayers = [\"cartodbpositron\", \"openstreetmap\", \"Stamen Terrain\", \n          \"Stamen Water Color\", \"Stamen Toner\", \"cartodbdark_matter\"]\nfor tile in layers:\n    folium.TileLayer(tile).add_to(map_)\nfolium.LayerControl(position='bottomright').add_to(map_)\nmap_\n```", "```py\n# create network graph\nG = ox.graph_from_point(start, dist=10000, \n        network_type=\"drive\")  #'drive', 'bike', 'walk'\nG = ox.add_edge_speeds(G)\nG = ox.add_edge_travel_times(G)\n\n# plot\nfig, ax = ox.plot_graph(G, bgcolor=\"black\", node_size=5, \n        node_color=\"white\", figsize=(16,8))\n```", "```py\n# geo-dataframe (nodes)\nprint(\"nodes:\", len(G.nodes()))\nox.graph_to_gdfs(G, nodes=True, edges=False).reset_index().head(3)\n```", "```py\n# geo-dataframe (links)\nprint(\"links:\", len(G.edges()))\nox.graph_to_gdfs(G, nodes=False, edges=True).reset_index().head(3)\n```", "```py\nend = dtf[dtf[\"id\"]==68][[\"y\",\"x\"]].values[0]\nprint(\"locations: from\", start, \"--> to\", end)\n```", "```py\nstart_node = ox.distance.nearest_nodes(G, start[1], start[0])\nend_node = ox.distance.nearest_nodes(G, end[1], end[0])\nprint(\"nodes: from\", start_node, \"--> to\", end_node)\n```", "```py\n# calculate shortest path\npath_lenght = nx.shortest_path(G, source=start_node, target=end_node, \n                                method='dijkstra', weight='lenght')     \nprint(path_lenght)\n\n# plot on the graph\nfig, ax = ox.plot_graph_route(G, path_lenght, route_color=\"red\", \n                              route_linewidth=5, node_size=1, \n                              bgcolor='black', node_color=\"white\", \n                              figsize=(16,8))\n```", "```py\n# calculate shortest path\npath_time = nx.shortest_path(G, source=start_node, target=end_node, \n                              method='dijkstra', weight='travel_time')   \nprint(path_time)\n\n# plot on the graph\nfig, ax = ox.plot_graph_route(G, path_time, route_color=\"blue\", \n                              route_linewidth=5, node_size=1, \n                              bgcolor='black', node_color=\"white\", \n                              figsize=(16,8))\n```", "```py\n# plot on the graph\nfig, ax = ox.plot_graph_routes(G, routes=[path_lenght, path_time], \n                              route_colors=[\"red\",\"blue\"], \n                              route_linewidth=5, node_size=1, \n                              bgcolor='black', node_color=\"white\", \n                              figsize=(16,8))\n```", "```py\n# plot on the map\nox.plot_route_folium(G, route=path_lenght, route_map=map_, \n                     color=\"red\", weight=1)\nox.plot_route_folium(G, route=path_time, route_map=map_, \n                     color=\"blue\", weight=1)\nmap_\n```", "```py\nlst_start, lst_end = [],[]\nstart_x, start_y = [],[]\nend_x, end_y = [],[]\nlst_length, lst_time = [],[]\n\nfor a,b in zip(route_time[:-1], route_time[1:]):\n    lst_start.append(a)\n    lst_end.append(b)\n    lst_length.append(round(G.edges[(a,b,0)]['length']))\n    lst_time.append(round(G.edges[(a,b,0)]['travel_time']))\n    start_x.append(G.nodes[a]['x'])\n    start_y.append(G.nodes[a]['y'])\n    end_x.append(G.nodes[b]['x'])\n    end_y.append(G.nodes[b]['y'])\n\ndf = pd.DataFrame(list(zip(lst_start, lst_end, \n                           start_x, start_y, end_x, end_y, \n                           lst_length, lst_time)), \n                   columns=[\"start\",\"end\",\"start_x\",\"start_y\",\n                            \"end_x\",\"end_y\",\"length\",\"travel_time\"]\n                  ).reset_index().rename(columns={\"index\":\"id\"})\n\ndf.head()\n```", "```py\n## create start/end df \ndf_start = df[df[\"start\"] == start_node]\ndf_end = df[df[\"end\"] == end_node]\n\n## create basic map\nfig = px.scatter_mapbox(data_frame=df, lon=\"start_x\", lat=\"start_y\", \n                        zoom=15, width=1000, height=800, \n                        animation_frame=\"id\", \n                        mapbox_style=\"carto-positron\")\n## add driver\nfig.data[0].marker = {\"size\":12}\n## add start point\nfig.add_trace(px.scatter_mapbox(data_frame=df_start, \n                                lon=\"start_x\", lat=\"start_y\").data[0])\nfig.data[1].marker = {\"size\":15, \"color\":\"red\"}\n## add end point\nfig.add_trace(px.scatter_mapbox(data_frame=df_end, \n                                lon=\"start_x\", lat=\"start_y\").data[0])\nfig.data[2].marker = {\"size\":15, \"color\":\"green\"}\n## add route\nfig.add_trace(px.line_mapbox(data_frame=df, \n                             lon=\"start_x\", lat=\"start_y\").data[0])\nfig\n```", "```py\n## get the node for each location\ndtf[\"node\"] = dtf[[\"y\",\"x\"]].apply(lambda x: \n                           ox.distance.nearest_nodes(G, x[1], x[0]), \n                        axis=1)\ndtf = dtf.drop_duplicates(\"node\", keep='first')\ndtf.head()\n```", "```py\n## distance length function\ndef f(a,b):\n    try:\n        d = nx.shortest_path_length(G, source=a, target=b, \n                                    method='dijkstra', \n                                    weight='travel_time')\n    except:\n        d = np.nan\n    return d\n\n## apply the function\ndistance_matrix = np.asarray([[f(a,b) for b in dtf[\"node\"].tolist()] \n                               for a in dtf[\"node\"].tolist()])\ndistance_matrix = pd.DataFrame(distance_matrix, \n                               columns=dtf[\"node\"].values, \n                               index=dtf[\"node\"].values)\ndistance_matrix.head()\n```", "```py\nheatmap = distance_matrix.copy()\nfor col in heatmap.columns:\n    heatmap[col] = heatmap[col].apply(lambda x: \n                       0.3 if pd.isnull(x) else  #nan -> purple\n                      (0.7 if np.isinf(x) else   #inf -> orange\n                      (0 if x!=0 else 1) ))      # 0  -> white  \n\nfig, ax = plt.subplots(figsize=(10,5))\nsns.heatmap(heatmap, vmin=0, vmax=1, cbar=False, ax=ax)\nplt.show()\n```", "```py\n# fillna with row average\ndistance_matrix = distance_matrix.T.fillna(distance_matrix.mean(axis=1)).T\n\n# fillna with overall average\ndistance_matrix = distance_matrix.fillna(distance_matrix.mean().mean())\n```", "```py\n## Business parameters\ndrivers = 1\n\nlst_nodes = dtf[\"node\"].tolist()\nprint(\"start:\", start_node, \"| tot locations to visit:\", \n     len(lst_nodes)-1, \"| drivers:\", drivers)\n```", "```py\nmanager = pywrapcp.RoutingIndexManager(len(lst_nodes), \n                                       drivers, \n                                       lst_nodes.index(start_node))\nmodel = pywrapcp.RoutingModel(manager)\n```", "```py\ndef get_distance(from_index, to_index):\n    return distance_matrix.iloc[from_index,to_index]\n\ndistance = model.RegisterTransitCallback(get_distance)\nmodel.SetArcCostEvaluatorOfAllVehicles(distance)\n```", "```py\nparameters = pywrapcp.DefaultRoutingSearchParameters()\nparameters.first_solution_strategy = (\n          routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n)\n```", "```py\nsolution = model.SolveWithParameters(parameters)\n\nindex = model.Start(0)\nprint('Route for driver:')\nroute_idx, route_distance = [], 0\nwhile not model.IsEnd(index):\n    route_idx.append( manager.IndexToNode(index) ) \n    previous_index = index\n    index = solution.Value( model.NextVar(index) )\n    ### update distance\n    try:\n        route_distance += get_distance(previous_index, index)\n    except:\n        route_distance += model.GetArcCostForVehicle(\n                              from_index=previous_index, \n                              to_index=index, \n                              vehicle=0)\n\nprint(route_idx)\nprint(f'Total distance: {round(route_distance/1000,2)} km')\nprint(f'Nodes visited: {len(route_idx)}')\n```", "```py\nprint(\"Route for driver (nodes):\")\nlst_route = [lst_nodes[i] for i in route_idx]\nprint(lst_route)\n```", "```py\n# Get path between nodes\ndef get_path_between_nodes(lst_route):\n    lst_paths = []\n    for i in range(len(lst_route)):\n        try:\n            a, b = lst_nodes[i], lst_nodes[i+1]\n        except:\n            break\n        try:\n            path = nx.shortest_path(G, source=a, target=b, \n                                    method='dijkstra', \n                                    weight='travel_time')\n            if len(path) > 1:\n                lst_paths.append(path)\n        except:\n            continue\n    return lst_paths\n\nlst_paths = get_path_between_nodes(lst_route)\n\n# Add paths on the map\nfor path in lst_paths:\n    ox.plot_route_folium(G, route=path, route_map=map_, \n                         color=\"blue\", weight=1)\nmap_\n```", "```py\n## Business parameters\ndrivers = 3\ndriver_capacities = [20,20,20]\ndemands = [0] + [1]*(len(lst_nodes)-1)\nmax_distance = 1000\n```", "```py\n## model\nmanager = pywrapcp.RoutingIndexManager(len(lst_nodes), \n                                       drivers, \n                                       lst_nodes.index(start_node))\nmodel = pywrapcp.RoutingModel(manager)\n\n## add distance (cost)\ndef get_distance(from_index, to_index):\n    return distance_matrix.iloc[from_index,to_index]\n\ndistance = model.RegisterTransitCallback(get_distance)\nmodel.SetArcCostEvaluatorOfAllVehicles(distance)\n```", "```py\n## add capacity (costraint)\ndef get_demand(from_index):\n    return demands[from_index]\n\ndemand = model.RegisterUnaryTransitCallback(get_demand)\nmodel.AddDimensionWithVehicleCapacity(demand, slack_max=0, \n                                     vehicle_capacities=driver_capacities, \n                                     fix_start_cumul_to_zero=True,\n                                     name='Capacity')\n\n## add limited distance (costraint)\nname = 'Distance'\nmodel.AddDimension(distance, slack_max=0, capacity=max_distance, \n                   fix_start_cumul_to_zero=True, name=name)\ndistance_dimension = model.GetDimensionOrDie(name)\ndistance_dimension.SetGlobalSpanCostCoefficient(100)\n\n## set strategy to minimize cost\nparameters = pywrapcp.DefaultRoutingSearchParameters()\nparameters.first_solution_strategy = (\n          routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n)\nsolution = model.SolveWithParameters(parameters)\n```", "```py\nsolution = model.SolveWithParameters(parameters)\n\ndic_routes_idx, total_distance, total_load = {}, 0, 0\nfor driver in range(drivers):\n    print(f'Route for driver {driver}:')\n    index = model.Start(driver)\n    route_idx, route_distance, route_load = [], 0, 0\n    while not model.IsEnd(index):\n        node_index = manager.IndexToNode(index)\n        route_idx.append( manager.IndexToNode(index) )\n        previous_index = index\n        index = solution.Value( model.NextVar(index) )\n        ### update distance\n        try:\n            route_distance += get_distance(previous_index, index)\n        except:\n            route_distance += model.GetArcCostForVehicle(\n                                from_index=previous_index, \n                                to_index=index, \n                                vehicle=driver)\n        ### update load\n        route_load += demands[node_index]\n\n    route_idx.append( manager.IndexToNode(index) )\n    print(route_idx)\n    dic_routes_idx[driver] = route_idx\n    print(f'distance: {round(route_distance/1000,2)} km')\n    print(f'load: {round(route_load,2)}', \"\\n\")\n    total_distance += route_distance\n    total_load += route_load\n\nprint(f'Total distance: {round(total_distance/1000,2)} km')\nprint(f'Total load: {total_load}')\n```", "```py\n# Convert from idx to nodes\ndic_route = {}\nfor k,v in dic_routes_idx.items():\n    print(f\"Route for driver {k} (nodes):\")\n    dic_route[k] = [lst_nodes[i] for i in v]\n    print(dic_route[k], \"\\n\")\n```", "```py\n# Get path between nodes\ndic_paths = {k:get_path_between_nodes(v) for k,v in dic_route.items()}\n\n# Add paths on the map\nlst_colors = [\"red\",\"green\",\"blue\"]\nfor k,v in dic_paths.items():\n    for path in v:\n        ox.plot_route_folium(G, route=path, route_map=map_, \n                             color=lst_colors[k], weight=1)\nmap_\n```", "```py\ndef df_animation_multiple_path(G, lst_paths, parallel=True):\n    df = pd.DataFrame()\n    for path in lst_paths:\n        lst_start, lst_end = [],[]\n        start_x, start_y = [],[]\n        end_x, end_y = [],[]\n        lst_length, lst_time = [],[]\n\n        for a,b in zip(path[:-1], path[1:]):\n            lst_start.append(a)\n            lst_end.append(b)\n            lst_length.append(round(G.edges[(a,b,0)]['length']))\n            lst_time.append(round(G.edges[(a,b,0)]['travel_time']))\n            start_x.append(G.nodes[a]['x'])\n            start_y.append(G.nodes[a]['y'])\n            end_x.append(G.nodes[b]['x'])\n            end_y.append(G.nodes[b]['y'])\n\n        tmp = pd.DataFrame(list(zip(lst_start, lst_end, \n                                    start_x, start_y, \n                                    end_x, end_y, \n                                    lst_length, lst_time)), \n                           columns=[\"start\",\"end\",\"start_x\",\"start_y\",\n                                    \"end_x\",\"end_y\",\"length\",\"travel_time\"]\n                          )\n        df = pd.concat([df,tmp], ignore_index=(not parallel))\n\n    df = df.reset_index().rename(columns={\"index\":\"id\"})\n    return df\n```", "```py\ndf = pd.DataFrame()\nfor driver,lst_paths in dic_paths.items():\n    tmp = df_animation_multiple_path(G, lst_paths, parallel=False)\n    df = pd.concat([df,tmp], axis=0)\n\nfirst_node, last_node = lst_paths[0][0], lst_paths[-1][-1]\nplot_animation(df, first_node, last_node)\n```"]