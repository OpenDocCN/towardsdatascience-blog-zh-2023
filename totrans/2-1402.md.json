["```py\ndocker run -d --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3.11-management\n```", "```py\ndocker exec rabbitmq rabbitmqctl add_user percy secret\n```", "```py\ndocker exec rabbitmq rabbitmqctl set_user_tags percy administrator\n```", "```py\ndocker exec rabbitmq rabbitmqctl delete_user guest\n```", "```py\ndocker exec rabbitmq rabbitmqctl add_vhost customers\n```", "```py\ndocker exec rabbitmq rabbitmqctl set_permissions -p customers percy \".*\" \".*\" \".*\"\n```", "```py\nmkdir eventdriven\ncd eventdriven\nmkdir -p cmd/producer\nmkdir internal\ntouch cmd/producer/main.go\ntouch internal/rabbitmq.go\ngo mod init programmingpercy.tech/eventdrivenrabbit\ngo get github.com/rabbitmq/amqp091-go\n```", "```py\npackage internal\n\nimport (\n \"context\"\n \"fmt\"\n\n amqp \"github.com/rabbitmq/amqp091-go\"\n)\n\n// RabbitClient is used to keep track of the RabbitMQ connection\ntype RabbitClient struct {\n // The connection that is used\n conn *amqp.Connection\n // The channel that processes/sends Messages\n ch *amqp.Channel\n}\n\n// ConnectRabbitMQ will spawn a Connection\nfunc ConnectRabbitMQ(username, password, host, vhost string) (*amqp.Connection, error) {\n // Setup the Connection to RabbitMQ host using AMQP\n conn, err := amqp.Dial(fmt.Sprintf(\"amqp://%s:%s@%s/%s\", username, password, host, vhost))\n if err != nil {\n  return nil, err\n }\n return conn, nil\n}\n\n// NewRabbitMQClient will connect and return a Rabbitclient with an open connection\n// Accepts a amqp Connection to be reused, to avoid spawning one TCP connection per concurrent client\nfunc NewRabbitMQClient(conn *amqp.Connection) (RabbitClient, error) {\n // Unique, Conncurrent Server Channel to process/send messages\n // A good rule of thumb is to always REUSE Conn across applications\n // But spawn a new Channel per routine\n ch, err := conn.Channel()\n if err != nil {\n  return RabbitClient{}, err\n }\n\n return RabbitClient{\n  conn: conn,\n  ch:   ch,\n }, nil\n}\n\n// Close will close the channel\nfunc (rc RabbitClient) Close() error {\n return rc.ch.Close()\n}\n```", "```py\npackage main\n\nimport (\n \"log\"\n \"programmingpercy/eventdrivenrabbit/internal\"\n \"time\"\n)\n\nfunc main() {\n conn, err := internal.ConnectRabbitMQ(\"percy\", \"secret\", \"localhost:5672\", \"customers\")\n\n if err != nil {\n  panic(err)\n }\n defer conn.Close()\n client, err := internal.NewRabbitMQClient(conn)\n if err != nil {\n  panic(err)\n }\n defer client.Close()\n\n time.Sleep(30 * time.Second)\n\n log.Println(client)\n}\n```", "```py\ngo run cmd/producer/main.go\n```", "```py\nfunc (*amqp.Channel).QueueDeclare(name string, durable bool, autoDelete bool, exclusive bool, noWait bool, args amqp.Table) (amqp.Queue, error)\n```", "```py\n// CreateQueue will create a new queue based on given cfgs\nfunc (rc RabbitClient) CreateQueue(queueName string, durable, autodelete bool) error {\n _, err := rc.ch.QueueDeclare(queueName, durable, autodelete, false, false, nil)\n return err\n}\n```", "```py\nfunc main() {\n conn, err := internal.ConnectRabbitMQ(\"percy\", \"secret\", \"localhost:5672\", \"customers\")\n\n if err != nil {\n  panic(err)\n }\n defer conn.Close()\n\n client, err := internal.NewRabbitMQClient(conn)\n if err != nil {\n  panic(err)\n }\n defer client.Close()\n\n if err := client.CreateQueue(\"customers_created\", true, false); err != nil {\n  panic(err)\n }\n if err := client.CreateQueue(\"customers_test\", false, true); err != nil {\n  panic(err)\n }\n\n time.Sleep(10 *time.Second)\n\n log.Println(client)\n\n}\n```", "```py\ngo run cmd/producer/main.go\n```", "```py\ndocker restart rabbitmq\n```", "```py\ndocker exec rabbitmq rabbitmqadmin declare exchange --vhost=customers name=customer_events type=topic -u percy -p secret durable=true\n```", "```py\ndocker exec rabbitmq rabbitmqctl set_topic_permissions -p customers percy customer_events \"^customers.*\" \"^customers.*\" \n```", "```py\n// CreateBinding is used to connect a queue to an Exchange using the binding rule\nfunc (rc RabbitClient) CreateBinding(name, binding, exchange string) error {\n // leaveing nowait false, having nowait set to false wctxill cause the channel to return an error and close if it cannot bind\n // the final argument is the extra headers, but we wont be doing that now\n return rc.ch.QueueBind(name, binding, exchange, false, nil)\n}\n```", "```py\n ...\n // Create binding between the customer_events exchange and the customers-created queue\n if err := client.CreateBinding(\"customers-created\", \"customers.created.*\", \"customer_events\"); err != nil {\n  panic(err)\n }\n // Create binding between the customer_events exchange and the customers-test queue\n if err := client.CreateBinding(\"customers-test\", \"customers.*\", \"customer_events\"); err != nil {\n  panic(err)\n }\n```", "```py\ngo run cmd/producer/main.go\n```", "```py\n// Send is used to publish a payload onto an exchange with a given routingkey\nfunc (rc RabbitClient) Send(ctx context.Context, exchange, routingKey string, options amqp.Publishing) error {\n return rc.ch.PublishWithContext(ctx,\n  exchange,   // exchange\n  routingKey, // routing key\n  // Mandatory is used when we HAVE to have the message return an error, if there is no route or queue then\n  // setting this to true will make the message bounce back\n  // If this is False, and the message fails to deliver, it will be dropped\n  true, // mandatory\n  // immediate Removed in MQ 3 or up https://blog.rabbitmq.com/posts/2012/11/breaking-things-with-rabbitmq-3-0ยง\n  false,   // immediate\n  options, // amqp publishing struct\n )\n}\n```", "```py\n... \n// Create context to manage timeout\n ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n defer cancel()\n // Create customer from sweden\n if err := client.Send(ctx, \"customer_events\", \"customers.created.se\", amqp091.Publishing{\n  ContentType:  \"text/plain\",       // The payload we send is plaintext, could be JSON or others..\n  DeliveryMode: amqp091.Persistent, // This tells rabbitMQ that this message should be Saved if no resources accepts it before a restart (durable)\n  Body:         []byte(\"An cool message between services\"),\n }); err != nil {\n  panic(err)\n }\n if err := client.Send(ctx, \"customer_events\", \"customers.test\", amqp091.Publishing{\n  ContentType:  \"text/plain\",\n  DeliveryMode: amqp091.Transient, // This tells rabbitMQ that this message can be deleted if no resources accepts it before a restart (non durable)\n  Body:         []byte(\"A second cool message\"),\n }); err != nil {\n  panic(err)\n }\n\n log.Println(client)\n}\n```", "```py\ngo run cmd/producer/main.go\n```", "```py\ndocker restart rabbitmq\n```", "```py\nmkdir cmd/consumer\ntouch cmd/consumer/main.go\n```", "```py\n// Consume is a wrapper around consume, it will return a Channel that can be used to digest messages\n// Queue is the name of the queue to Consume\n// Consumer is a unique identifier for the service instance that is consuming, can be used to cancel etc\n// autoAck is important to understand, if set to true, it will automatically Acknowledge that processing is done\n// This is good, but remember that if the Process fails before completion, then an ACK is already sent, making a message lost\n// if not handled properly\nfunc (rc RabbitClient) Consume(queue, consumer string, autoAck bool) (<-chan amqp.Delivery, error) {\n return rc.ch.Consume(queue, consumer, autoAck, false, false, false, nil)\n}\n```", "```py\npackage main\n\nimport (\n \"log\"\n \"programmingpercy/eventdrivenrabbit/internal\"\n)\n\nfunc main() {\n\n conn, err := internal.ConnectRabbitMQ(\"percy\", \"secret\", \"localhost:5672\", \"customers\")\n if err != nil {\n  panic(err)\n }\n\n mqClient, err := internal.NewRabbitMQClient(conn)\n if err != nil {\n  panic(err)\n }\n\n messageBus, err := mqClient.Consume(\"customers_created\", \"email-service\", false)\n if err != nil {\n  panic(err)\n }\n\n // blocking is used to block forever\n var blocking chan struct{}\n\n go func() {\n  for message := range messageBus {\n   // breakpoint here\n   log.Printf(\"New Message: %v\", message)\n  }\n }()\n\n log.Println(\"Consuming, to close the program press CTRL+C\")\n // This will block forever\n <-blocking\n\n}\n```", "```py\ngo run cmd/consumer/main.go\n```", "```py\n2023/02/12 22:17:24 New Message: {0xc0000b0000 map[] text/plain  2 0     0001-01-01 00:00:00 +0000 UTC    ema\nil-service 0 1 false customer_events customers.created.se [65 110 32 99 111 111 108 32 109 101 115 115 97 103\n 101 32 98 101 116 119 101 101 110 32 115 101 114 118 105 99 101 115]}\n```", "```py\n// Delivery captures the fields for a previously delivered message resident in\n// a queue to be delivered by the server to a consumer from Channel.Consume or\n// Channel.Get.\ntype Delivery struct {\n Acknowledger Acknowledger // the channel from which this delivery arrived\n\n Headers Table // Application or header exchange table\n\n // Properties\n ContentType     string    // MIME content type\n ContentEncoding string    // MIME content encoding\n DeliveryMode    uint8     // queue implementation use - non-persistent (1) or persistent (2)\n Priority        uint8     // queue implementation use - 0 to 9\n CorrelationId   string    // application use - correlation identifier\n ReplyTo         string    // application use - address to reply to (ex: RPC)\n Expiration      string    // implementation use - message expiration spec\n MessageId       string    // application use - message identifier\n Timestamp       time.Time // application use - message timestamp\n Type            string    // application use - message type name\n UserId          string    // application use - creating user - should be authenticated user\n AppId           string    // application use - creating application id\n\n // Valid only with Channel.Consume\n ConsumerTag string\n\n // Valid only with Channel.Get\n MessageCount uint32\n\n DeliveryTag uint64\n Redelivered bool\n Exchange    string // basic.publish exchange\n RoutingKey  string // basic.publish routing key\n\n Body []byte\n}\n```", "```py\n go func() {\n  for message := range messageBus {\n   // breakpoint here\n   log.Printf(\"New Message: %v\", message)\n   // Multiple means that we acknowledge a batch of messages, leave false for now\n   if err := message.Ack(false); err != nil {\n    log.Printf(\"Acknowledged message failed: Retry ? Handle manually %s\\n\", message.MessageId)\n    continue\n   }\n   log.Printf(\"Acknowledged message %s\\n\", message.MessageId)\n  }\n }()\n```", "```py\n // Auto Ack is now True\n messageBus, err := mqClient.Consume(\"customers-created\", \"email-service\", true)\n if err != nil {\n  panic(err)\n }\n\n // blocking is used to block forever\n var blocking chan struct{}\n\n go func() {\n  for message := range messageBus {\n   log.Printf(\"New Message: %v\", message)\n   panic(\"Whops I failed here for some reason\")\n\n  }\n }()\n```", "```py\n messageBus, err := mqClient.Consume(\"customers-created\", \"email-service\", false)\n if err != nil {\n  panic(err)\n }\n\n // blocking is used to block forever\n var blocking chan struct{}\n\n go func() {\n  for message := range messageBus {\n   log.Printf(\"New Message: %v\", message)\n\n   if !message.Redelivered {\n    // Nack multiple, Set Requeue to true\n    message.Nack(false, true)\n    continue\n   }\n\n   // Multiple means that we acknowledge a batch of messages, leave false for now\n   if err := message.Ack(false); err != nil {\n    log.Printf(\"Acknowledged message failed: Retry ? Handle manually %s\\n\", message.MessageId)\n    continue\n   }\n   log.Printf(\"Acknowledged message %s\\n\", message.MessageId)\n  }\n }()\n```", "```py\n..... \n// Set a timeout for 15 secs\n ctx := context.Background()\n ctx, cancel := context.WithTimeout(ctx, 15*time.Second)\n defer cancel()\n // Create an Errgroup to manage concurrecy\n g, ctx := errgroup.WithContext(ctx)\n // Set amount of concurrent tasks\n g.SetLimit(10)\n go func() {\n  for message := range messageBus {\n   // Spawn a worker\n   msg := message\n   g.Go(func() error {\n    log.Printf(\"New Message: %v\", msg)\n\n    time.Sleep(10 * time.Second)\n    // Multiple means that we acknowledge a batch of messages, leave false for now\n    if err := msg.Ack(false); err != nil {\n     log.Printf(\"Acknowledged message failed: Retry ? Handle manually %s\\n\", msg.MessageId)\n     return err\n    }\n    log.Printf(\"Acknowledged message %s\\n\", msg.MessageId)\n    return nil\n   })\n  }\n }() \n```", "```py\n // Create context to manage timeout\n ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n defer cancel()\n // Create customer from sweden\n for i := 0; i < 10; i++ {\n  if err := client.Send(ctx, \"customer_events\", \"customers.created.se\", amqp091.Publishing{\n   ContentType:  \"text/plain\",       // The payload we send is plaintext, could be JSON or others..\n   DeliveryMode: amqp091.Persistent, // This tells rabbitMQ that this message should be Saved if no resources accepts it before a restart (durable)\n   Body:         []byte(\"An cool message between services\"),\n  }); err != nil {\n   panic(err)\n  }\n }\n\n if err := client.Send(ctx, \"customer_events\", \"customers.test\", amqp091.Publishing{\n  ContentType:  \"text/plain\",\n  DeliveryMode: amqp091.Transient, // This tells rabbitMQ that this message can be deleted if no resources accepts it before a restart (non durable)\n  Body:         []byte(\"A second cool message\"),\n }); err != nil {\n  panic(err)\n }\n\n log.Println(client)\n}\n```", "```py\n// Send is used to publish a payload onto an exchange with a given routingkey\nfunc (rc RabbitClient) Send(ctx context.Context, exchange, routingKey string, options amqp.Publishing) error {\n // PublishWithDeferredConfirmWithContext will wait for server to ACK the message\n confirmation, err := rc.ch.PublishWithDeferredConfirmWithContext(ctx,\n  exchange,   // exchange\n  routingKey, // routing key\n  // Mandatory is used when we HAVE to have the message return an error, if there is no route or queue then\n  // setting this to true will make the message bounce back\n  // If this is False, and the message fails to deliver, it will be dropped\n  true, // mandatory\n  // immediate Removed in MQ 3 or up https://blog.rabbitmq.com/posts/2012/11/breaking-things-with-rabbitmq-3-0ยง\n  false,   // immediate\n  options, // amqp publishing struct\n )\n if err != nil {\n  return err\n }\n // Blocks until ACK from Server is receieved\n log.Println(confirmation.Wait())\n return nil\n}\n```", "```py\n// NewRabbitMQClient will connect and return a Rabbitclient with an open connection\n// Accepts a amqp Connection to be reused, to avoid spawning one TCP connection per concurrent client\nfunc NewRabbitMQClient(conn *amqp.Connection) (RabbitClient, error) {\n // Unique, Conncurrent Server Channel to process/send messages\n // A good rule of thumb is to always REUSE Conn across applications\n // But spawn a new Channel per routine\n ch, err := conn.Channel()\n if err != nil {\n  return RabbitClient{}, err\n }\n // Puts the Channel in confirm mode, which will allow waiting for ACK or NACK from the receiver\n if err := ch.Confirm(false); err != nil {\n  return RabbitClient{}, err\n }\n\n return RabbitClient{\n  conn: conn,\n  ch:   ch,\n }, nil\n}\n```", "```py\ndocker exec rabbitmq rabbitmqadmin delete exchange name=customer_events --vhost=customers -u percy -p secret\ndocker exec rabbitmq rabbitmqadmin declare exchange --vhost=customers name=customer_events type=fanout -u percy -p secret durable=true\ndocker exec rabbitmq rabbitmqctl set_topic_permissions -p customers percy customer_events \".*\" \".*\"\n```", "```py\n// CreateQueue will create a new queue based on given cfgs\nfunc (rc RabbitClient) CreateQueue(queueName string, durable, autodelete bool) (amqp.Queue, error) {\n q, err := rc.ch.QueueDeclare(queueName, durable, autodelete, false, false, nil)\n if err != nil {\n  return amqp.Queue{}, nil\n }\n\n return q, nil\n}\n```", "```py\npackage main\n\nimport (\n \"context\"\n \"log\"\n \"programmingpercy/eventdrivenrabbit/internal\"\n \"time\"\n\n \"github.com/rabbitmq/amqp091-go\"\n)\n\nfunc main() {\n conn, err := internal.ConnectRabbitMQ(\"percy\", \"secret\", \"localhost:5672\", \"customers\")\n\n if err != nil {\n  panic(err)\n }\n defer conn.Close()\n client, err := internal.NewRabbitMQClient(conn)\n if err != nil {\n  panic(err)\n }\n defer client.Close()\n\n // Create context to manage timeout\n ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n defer cancel()\n // Create customer from sweden\n for i := 0; i < 10; i++ {\n  if err := client.Send(ctx, \"customer_events\", \"customers.created.se\", amqp091.Publishing{\n   ContentType:  \"text/plain\",       // The payload we send is plaintext, could be JSON or others..\n   DeliveryMode: amqp091.Persistent, // This tells rabbitMQ that this message should be Saved if no resources accepts it before a restart (durable)\n   Body:         []byte(\"An cool message between services\"),\n  }); err != nil {\n   panic(err)\n  }\n }\n\n log.Println(client)\n}\n```", "```py\npackage main\n\nimport (\n \"context\"\n \"log\"\n \"programmingpercy/eventdrivenrabbit/internal\"\n \"time\"\n\n \"golang.org/x/sync/errgroup\"\n)\n\nfunc main() {\n\n conn, err := internal.ConnectRabbitMQ(\"percy\", \"secret\", \"localhost:5672\", \"customers\")\n if err != nil {\n  panic(err)\n }\n\n mqClient, err := internal.NewRabbitMQClient(conn)\n if err != nil {\n  panic(err)\n }\n\n // Create Unnamed Queue which will generate a random name, set AutoDelete to True\n queue, err := mqClient.CreateQueue(\"\", true, true)\n if err != nil {\n  panic(err)\n }\n // Create binding between the customer_events exchange and the new Random Queue\n // Can skip Binding key since fanout will skip that rule\n if err := mqClient.CreateBinding(queue.Name, \"\", \"customer_events\"); err != nil {\n  panic(err)\n }\n\n messageBus, err := mqClient.Consume(queue.Name, \"email-service\", false)\n if err != nil {\n  panic(err)\n }\n // blocking is used to block forever\n var blocking chan struct{}\n // Set a timeout for 15 secs\n ctx := context.Background()\n ctx, cancel := context.WithTimeout(ctx, 15*time.Second)\n defer cancel()\n // Create an Errgroup to manage concurrecy\n g, ctx := errgroup.WithContext(ctx)\n // Set amount of concurrent tasks\n g.SetLimit(10)\n go func() {\n  for message := range messageBus {\n   // Spawn a worker\n   msg := message\n   g.Go(func() error {\n    log.Printf(\"New Message: %v\", msg)\n\n    time.Sleep(10 * time.Second)\n    // Multiple means that we acknowledge a batch of messages, leave false for now\n    if err := msg.Ack(false); err != nil {\n     log.Printf(\"Acknowledged message failed: Retry ? Handle manually %s\\n\", msg.MessageId)\n     return err\n    }\n    log.Printf(\"Acknowledged message %s\\n\", msg.MessageId)\n    return nil\n   })\n  }\n }()\n\n log.Println(\"Consuming, to close the program press CTRL+C\")\n // This will block forever\n <-blocking\n\n}\n```", "```py\ndocker exec rabbitmq rabbitmqadmin declare exchange --vhost=customers name=customer_callbacks type=direct -u percy -p secret durable=true\ndocker exec rabbitmq rabbitmqctl set_topic_permissions -p customers percy customer_callbacks \".*\" \".*\"\n```", "```py\npackage main\n\nimport (\n \"context\"\n \"fmt\"\n \"log\"\n \"programmingpercy/eventdrivenrabbit/internal\"\n \"time\"\n\n \"github.com/rabbitmq/amqp091-go\"\n)\n\nfunc main() {\n conn, err := internal.ConnectRabbitMQ(\"percy\", \"secret\", \"localhost:5672\", \"customers\")\n if err != nil {\n  panic(err)\n }\n defer conn.Close()\n // Never use the same Connection for Consume and Publish\n consumeConn, err := internal.ConnectRabbitMQ(\"percy\", \"secret\", \"localhost:5672\", \"customers\")\n if err != nil {\n  panic(err)\n }\n defer consumeConn.Close()\n\n client, err := internal.NewRabbitMQClient(conn)\n if err != nil {\n  panic(err)\n }\n defer client.Close()\n\n consumeClient, err := internal.NewRabbitMQClient(consumeConn)\n if err != nil {\n  panic(err)\n }\n defer consumeClient.Close()\n\n // Create Unnamed Queue which will generate a random name, set AutoDelete to True\n queue, err := consumeClient.CreateQueue(\"\", true, true)\n if err != nil {\n  panic(err)\n }\n\n if err := consumeClient.CreateBinding(queue.Name, queue.Name, \"customer_callbacks\"); err != nil {\n  panic(err)\n }\n\n messageBus, err := consumeClient.Consume(queue.Name, \"customer-api\", true)\n if err != nil {\n  panic(err)\n }\n go func() {\n  for message := range messageBus {\n   log.Printf(\"Message Callback %s\\n\", message.CorrelationId)\n  }\n }()\n // Create context to manage timeout\n ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n defer cancel()\n // Create customer from sweden\n for i := 0; i < 10; i++ {\n  if err := client.Send(ctx, \"customer_events\", \"customers.created.se\", amqp091.Publishing{\n   ContentType:  \"text/plain\",       // The payload we send is plaintext, could be JSON or others..\n   DeliveryMode: amqp091.Persistent, // This tells rabbitMQ that this message should be Saved if no resources accepts it before a restart (durable)\n   Body:         []byte(\"An cool message between services\"),\n   // We add a REPLYTO which defines the\n   ReplyTo: queue.Name,\n   // CorrelationId can be used to know which Event this relates to\n   CorrelationId: fmt.Sprintf(\"customer_created_%d\", i),\n  }); err != nil {\n   panic(err)\n  }\n }\n var blocking chan struct{}\n\n log.Println(\"Waiting on Callbacks, to close the program press CTRL+C\")\n // This will block forever\n <-blocking\n}\n```", "```py\npackage main\n\nimport (\n \"context\"\n \"log\"\n \"programmingpercy/eventdrivenrabbit/internal\"\n \"time\"\n\n \"github.com/rabbitmq/amqp091-go\"\n \"golang.org/x/sync/errgroup\"\n)\n\nfunc main() {\n\n conn, err := internal.ConnectRabbitMQ(\"percy\", \"secret\", \"localhost:5672\", \"customers\")\n if err != nil {\n  panic(err)\n }\n defer conn.Close()\n\n publishConn, err := internal.ConnectRabbitMQ(\"percy\", \"secret\", \"localhost:5672\", \"customers\")\n if err != nil {\n  panic(err)\n }\n defer publishConn.Close()\n\n mqClient, err := internal.NewRabbitMQClient(conn)\n if err != nil {\n  panic(err)\n }\n\n publishClient, err := internal.NewRabbitMQClient(publishConn)\n if err != nil {\n  panic(err)\n }\n // Create Unnamed Queue which will generate a random name, set AutoDelete to True\n queue, err := mqClient.CreateQueue(\"\", true, true)\n if err != nil {\n  panic(err)\n }\n // Create binding between the customer_events exchange and the new Random Queue\n // Can skip Binding key since fanout will skip that rule\n if err := mqClient.CreateBinding(queue.Name, \"\", \"customer_events\"); err != nil {\n  panic(err)\n }\n\n messageBus, err := mqClient.Consume(queue.Name, \"email-service\", false)\n if err != nil {\n  panic(err)\n }\n // blocking is used to block forever\n var blocking chan struct{}\n // Set a timeout for 15 secs\n ctx := context.Background()\n ctx, cancel := context.WithTimeout(ctx, 15*time.Second)\n defer cancel()\n // Create an Errgroup to manage concurrecy\n g, ctx := errgroup.WithContext(ctx)\n // Set amount of concurrent tasks\n g.SetLimit(10)\n go func() {\n  for message := range messageBus {\n   // Spawn a worker\n   msg := message\n   g.Go(func() error {\n    // Multiple means that we acknowledge a batch of messages, leave false for now\n    if err := msg.Ack(false); err != nil {\n     log.Printf(\"Acknowledged message failed: Retry ? Handle manually %s\\n\", msg.MessageId)\n     return err\n    }\n\n    log.Printf(\"Acknowledged message, replying to %s\\n\", msg.ReplyTo)\n\n    // Use the msg.ReplyTo to send the message to the proper Queue\n    if err := publishClient.Send(ctx, \"customer_callbacks\", msg.ReplyTo, amqp091.Publishing{\n     ContentType:   \"text/plain\",      // The payload we send is plaintext, could be JSON or others..\n     DeliveryMode:  amqp091.Transient, // This tells rabbitMQ to drop messages if restarted\n     Body:          []byte(\"RPC Complete\"),\n     CorrelationId: msg.CorrelationId,\n    }); err != nil {\n     panic(err)\n    }\n    return nil\n   })\n  }\n }()\n\n log.Println(\"Consuming, to close the program press CTRL+C\")\n // This will block forever\n <-blocking\n\n}\n```", "```py\n// ApplyQos is used to apply qouality of service to the channel\n// Prefetch count - How many messages the server will try to keep on the Channel\n// prefetch Size - How many Bytes the server will try to keep on the channel\n// global -- Any other Consumers on the connection in the future will apply the same rules if TRUE\nfunc (rc RabbitClient) ApplyQos(count, size int, global bool) error {\n // Apply Quality of Serivce\n return rc.ch.Qos(\n  count,\n  size,\n  global,\n )\n}\n```", "```py\n // Create an Errgroup to manage concurrecy\n g, ctx := errgroup.WithContext(ctx)\n // Set amount of concurrent tasks\n g.SetLimit(10)\n\n // Apply Qos to limit amount of messages to consume\n if err := mqClient.ApplyQos(10, 0, true); err != nil {\n  panic(err)\n }\n go func() {\n  for message := range messageBus {\n```", "```py\ngit clone https://github.com/rabbitmq/tls-gen tls-gen\ncd tls-gen/basic\nmake PASSWORD=\nmake verify\n```", "```py\n sudo chmod 644 tls-gen/basic/result/*\n```", "```py\nsudo docker container rm -f rabbitmq \n```", "```py\ncd ../../ # Go to root of Project\ntouch rabbitmq.conf\n```", "```py\ndocker run -d --name rabbitmq -v \"$(pwd)\"/rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf:ro -v \"$(pwd)\"/tls-gen/basic/result:/certs -p 5671:5671 -p 15671:15671 rabbitmq:3.11-management\n```", "```py\n# Disable NON TCP\nlisteners.tcp = none\n# TCP port\nlisteners.ssl.default = 5671\n# SSL Certs\nssl_options.cacertfile = /certs/ca_certificate.pem\nssl_options.certfile   = /certs/server_blackbox_certificate.pem\nssl_options.keyfile    = /certs/server_blackbox_key.pem\n# Peer verification\nssl_options.verify     = verify_peer\nssl_options.fail_if_no_peer_cert = true\n```", "```py\ndocker restart rabbitmq\n```", "```py\n2023-02-19 07:35:15.566316+00:00 [info] <0.738.0> Ready to start client connection listeners\n2023-02-19 07:35:15.567418+00:00 [info] <0.885.0> started TLS (SSL) listener on [::]:5671\n```", "```py\n// ConnectRabbitMQ will spawn a Connection\nfunc ConnectRabbitMQ(username, password, host, vhost, caCert, clientCert, clientKey string) (*amqp.Connection, error) {\n ca, err := os.ReadFile(caCert)\n if err != nil {\n  return nil, err\n }\n // Load the key pair\n cert, err := tls.LoadX509KeyPair(clientCert, clientKey)\n if err != nil {\n  return nil, err\n }\n // Add the CA to the cert pool\n rootCAs := x509.NewCertPool()\n rootCAs.AppendCertsFromPEM(ca)\n\n tlsConf := &tls.Config{\n  RootCAs:      rootCAs,\n  Certificates: []tls.Certificate{cert},\n }\n // Setup the Connection to RabbitMQ host using AMQPs and Apply TLS config\n conn, err := amqp.DialTLS(fmt.Sprintf(\"amqps://%s:%s@%s/%s\", username, password, host, vhost), tlsConf)\n if err != nil {\n  return nil, err\n }\n return conn, nil\n}\n```", "```py\n conn, err := internal.ConnectRabbitMQ(\"percy\", \"secret\", \"localhost:5671\", \"customers\",\n  \"/home/pp/development/blog/event-driven-rabbitmq/tls-gen/basic/result/ca_certificate.pem\",\n  \"/home/pp/development/blog/event-driven-rabbitmq/tls-gen/basic/result/client_blackbox_certificate.pem\",\n  \"/home/pp/development/blog/event-driven-rabbitmq/tls-gen/basic/result/client_blackbox_key.pem\",\n )\n if err != nil {\n  panic(err)\n }\n defer conn.Close()\n // Never use the same Connection for Consume and Publish\n consumeConn, err := internal.ConnectRabbitMQ(\"percy\", \"secret\", \"localhost:5671\", \"customers\",\n  \"/home/pp/development/blog/event-driven-rabbitmq/tls-gen/basic/result/ca_certificate.pem\",\n  \"/home/pp/development/blog/event-driven-rabbitmq/tls-gen/basic/result/client_blackbox_certificate.pem\",\n  \"/home/pp/development/blog/event-driven-rabbitmq/tls-gen/basic/result/client_blackbox_key.pem\",\n )\n defer consumeConn.Close()\n```", "```py\n2023-02-19 07:49:53.015732+00:00 [error] <0.948.0> Error on AMQP connection <0.948.0> (172.17.0.1:49066 -> 172.17.0.2:5671, state: starting):\n2023-02-19 07:49:53.015732+00:00 [error] <0.948.0> PLAIN login refused: user 'percy' - invalid credentials\n```", "```py\n#!/bin/bash\n\nfunction encode_password()\n{\n    SALT=$(od -A n -t x -N 4 /dev/urandom)\n    PASS=$SALT$(echo -n $1 | xxd -ps | tr -d '\\n' | tr -d ' ')\n    PASS=$(echo -n $PASS | xxd -r -p | sha256sum | head -c 128)\n    PASS=$(echo -n $SALT$PASS | xxd -r -p | base64 | tr -d '\\n')\n    echo $PASS\n}\n\nencode_password \"secret\"\n```", "```py\nlog.console = true\n# Disable NON TCP\nlisteners.tcp = none\n# TCP port\nlisteners.ssl.default = 5671\n# SSL Certs\nssl_options.cacertfile = /certs/ca_certificate.pem\nssl_options.certfile   = /certs/server_blackbox_certificate.pem\nssl_options.keyfile    = /certs/server_blackbox_key.pem\n# Peer verification\nssl_options.verify     = verify_peer\nssl_options.fail_if_no_peer_cert = true\n# Load definitions file\nload_definitions = /etc/rabbitmq/rabbitmq_definitions.json\n```", "```py\n{\n    \"users\": [\n        {\n            \"name\": \"percy\",\n            \"password_hash\": \"dPOoDgfw31kjUy41HSmqQR+X2Q9PCA5fD++fbxQCgPvKZmnX\",\n            \"tags\": \"administrator\"\n        }\n    ],\n    \"vhosts\": [\n        {\n            \"name\": \"/\"\n        },{\n            \"name\": \"customers\"\n        }\n    ],\n    \"permissions\": [\n        {\n            \"user\": \"percy\",\n            \"vhost\": \"customers\",\n            \"configure\": \".*\",\n            \"write\": \".*\",\n            \"read\": \".*\"\n        }\n    ],\n    \"exchanges\": [\n        {\n            \"name\": \"customer_events\",\n            \"vhost\": \"customers\",\n            \"type\": \"fanout\",\n            \"durable\": true,\n            \"auto_delete\": false,\n            \"internal\": false,\n            \"arguments\": {}\n        },\n        {\n            \"name\": \"customer_callbacks\",\n            \"vhost\": \"customers\",\n            \"type\": \"direct\",\n            \"durable\": true,\n            \"auto_delete\": false,\n            \"internal\": false,\n            \"arguments\": {}\n        }\n    ],\n    \"queues\": [\n        {\n            \"name\": \"customers_created\",\n            \"vhost\": \"customers\",\n            \"durable\": true,\n            \"auto_delete\": false,\n            \"arguments\": {}\n        }\n    ],\n    \"bindings\": [\n        {\n            \"source\": \"customers_events\",\n            \"vhost\": \"customers\",\n            \"destination\": \"customers_created\",\n            \"destination_type\": \"queue\",\n            \"routing_key\": \"customers.created.*\",\n            \"arguments\": {}\n        }\n    ]\n}\n```", "```py\ndocker run -d --name rabbitmq -v \"$(pwd)\"/rabbitmq_definitions.json:/etc/rabbitmq/rabbitmq_definitions.json:ro -v \"$(pwd)\"/rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf:ro -v \"$(pwd)\"/tls-gen/basic/result:/certs -p 5671:5671 -p 15672:15672 rabbitmq:3.11-management\n```", "```py\n2023-02-19 08:17:53.467218+00:00 [info] <0.867.0> Started message store of type persistent for vhost 'customers'\n2023-02-19 08:17:53.467310+00:00 [info] <0.867.0> Recovering 0 queues of type rabbit_classic_queue took 3ms\n2023-02-19 08:17:53.467348+00:00 [info] <0.867.0> Recovering 0 queues of type rabbit_quorum_queue took 0ms\n2023-02-19 08:17:53.467371+00:00 [info] <0.867.0> Recovering 0 queues of type rabbit_stream_queue took 0ms\n2023-02-19 08:17:53.468487+00:00 [info] <0.698.0> Importing concurrently 1 permissions...\n2023-02-19 08:17:53.469946+00:00 [info] <0.680.0> Successfully set permissions for 'percy' in virtual host 'customers' to '.*', '.*', '.*'\n```"]