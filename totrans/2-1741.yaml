- en: 'Python Tuple, the Whole Truth, and Only the Truth: Hello, Tuple!'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 元组，真相大白，只有真相：你好，元组！
- en: 原文：[https://towardsdatascience.com/python-tuple-the-whole-truth-and-only-the-truth-hello-tuple-12a7ab9dbd0d](https://towardsdatascience.com/python-tuple-the-whole-truth-and-only-the-truth-hello-tuple-12a7ab9dbd0d)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/python-tuple-the-whole-truth-and-only-the-truth-hello-tuple-12a7ab9dbd0d](https://towardsdatascience.com/python-tuple-the-whole-truth-and-only-the-truth-hello-tuple-12a7ab9dbd0d)
- en: PYTHON PROGRAMMING
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PYTHON 编程
- en: Learn the basics of tuples and of using them
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习元组的基础知识及其使用方法
- en: '[](https://medium.com/@nyggus?source=post_page-----12a7ab9dbd0d--------------------------------)[![Marcin
    Kozak](../Images/d7faf62e48ed81dab5d8ad92819fff54.png)](https://medium.com/@nyggus?source=post_page-----12a7ab9dbd0d--------------------------------)[](https://towardsdatascience.com/?source=post_page-----12a7ab9dbd0d--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----12a7ab9dbd0d--------------------------------)
    [Marcin Kozak](https://medium.com/@nyggus?source=post_page-----12a7ab9dbd0d--------------------------------)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@nyggus?source=post_page-----12a7ab9dbd0d--------------------------------)[![Marcin
    Kozak](../Images/d7faf62e48ed81dab5d8ad92819fff54.png)](https://medium.com/@nyggus?source=post_page-----12a7ab9dbd0d--------------------------------)[](https://towardsdatascience.com/?source=post_page-----12a7ab9dbd0d--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----12a7ab9dbd0d--------------------------------)
    [Marcin Kozak](https://medium.com/@nyggus?source=post_page-----12a7ab9dbd0d--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----12a7ab9dbd0d--------------------------------)
    ·16 min read·Jan 21, 2023
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: ·发布在[Towards Data Science](https://towardsdatascience.com/?source=post_page-----12a7ab9dbd0d--------------------------------)
    ·阅读时长16分钟·2023年1月21日
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/74860d4642efa6cd08de3d7411205690.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/74860d4642efa6cd08de3d7411205690.png)'
- en: Tuples are often considered records. Photo by [Samuel Regan-Asante](https://unsplash.com/@fkaregan?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 元组通常被视为记录。照片由[Samuel Regan-Asante](https://unsplash.com/@fkaregan?utm_source=medium&utm_medium=referral)提供，来自[Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: The tuple is an immutable collection type in Python. It’s one of the three most
    popular collection types in Python, along with the list and the dictionary. While
    I think that many beginning and intermediate developers know much about these
    two types, they may have problems with truly understanding what tuples are and
    how they work. Even advanced Python developers do not have to know everything
    about tuples — and given the type’s specificity, this does not come as a surprise
    to me.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是Python中的一种不可变集合类型。它是Python中三种最流行的集合类型之一，另外两种是列表和字典。虽然我认为许多初学者和中级开发者对这两种类型了解颇多，但他们可能在真正理解元组是什么以及如何工作上存在问题。即使是高级Python开发者也不必了解所有关于元组的知识——鉴于这种类型的特殊性，我对此并不感到惊讶。
- en: 'As a beginning and even intermediate Python developer, I did not know much
    about the tuple. Let me show you an example; imagine I wrote a fragment of code
    similar to the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个初学者甚至中级Python开发者，我对元组了解不多。让我给你一个例子；想象一下我写了一段类似于以下的代码：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you see, I used a list literal to define the `basic_names` list — but why
    not *a tuple literal*? It would look like below:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我使用了列表字面量来定义`basic_names`列表——但为什么不使用*元组字面量*呢？它看起来会是下面这样：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The main thing we know about the tuple is that it’s immutable — and the code
    itself suggests that the `basic_names` container will *not* change. Thus, a tuple
    seems more natural here than a list, doesn’t it? So, is there any *practical*
    difference between the two approaches? Like in performance, safety, or anything
    else?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 关于元组，我们知道的主要事情是它是不可变的——代码本身表明`basic_names`容器将*不会*改变。因此，元组在这里似乎比列表更自然，对吧？那么，两种方法之间是否存在*实际*差异？比如性能、安全性或其他方面？
- en: 'Such gaps in knowledge make us worse programmers. This article aims to help
    you become a better programmer, by helping you learn about one of the most important
    data type in Python, but one that many don’t know much about: the tuple. My aim
    is to make this article as thorough as possible from a practical point of view.
    So, for example, we will not talk about the details of C implementation of the
    tuple, but we will talk about the details of using tuples in Python.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 知识上的这些空白使我们成为更差的程序员。本文旨在通过帮助你了解Python中一个非常重要但许多人不了解的数据类型：元组，从而帮助你成为更好的程序员。我的目标是使这篇文章从实际角度尽可能详尽。因此，例如，我们不会讨论元组的C语言实现细节，但会讨论在Python中使用元组的细节。
- en: 'Tuples are a rich topic. Thus, I will split the knowledge about it into two
    parts — and two articles. Here are the topics I will cover in the first part —
    that is, here:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是一个丰富的话题。因此，我将把关于它的知识分为两部分——和两篇文章。以下是我将在第一部分中覆盖的主题——也就是这里：
- en: The basic of tuples.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组的基础。
- en: 'Using tuples: tuple unpacking and tuple methods.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用元组：元组解包和元组方法。
- en: 'So, we will focus on the basics here. In the second part, I cover more advanced
    topics of tuples, such as inheriting from tuple, tuple performance and tuple comprehensions.
    You will find it here:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将在这里专注于基础知识。在第二部分，我将覆盖元组的更多高级主题，例如继承自元组、元组性能和元组推导。你可以在这里找到它：
- en: '[](/python-tuple-the-whole-truth-and-only-truth-lets-dig-deep-24d2bf02971b?source=post_page-----12a7ab9dbd0d--------------------------------)
    [## Python Tuple, The Whole Truth and Only Truth: Let’s Dig Deep'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[](/python-tuple-the-whole-truth-and-only-truth-lets-dig-deep-24d2bf02971b?source=post_page-----12a7ab9dbd0d--------------------------------)
    [## Python 元组，完全的真相和唯一的真相：让我们深入探讨]'
- en: Learn the intricacies of tuples
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了解元组的复杂性
- en: towardsdatascience.com](/python-tuple-the-whole-truth-and-only-truth-lets-dig-deep-24d2bf02971b?source=post_page-----12a7ab9dbd0d--------------------------------)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[towardsdatascience.com](/python-tuple-the-whole-truth-and-only-truth-lets-dig-deep-24d2bf02971b?source=post_page-----12a7ab9dbd0d--------------------------------)'
- en: The basics of tuples
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组的基础知识
- en: A tuple is a container of values, similar to a list. In his great book entitled
    *Fluent Python*, L. Ramalho explains that tuples were created to be *immutable
    lists*, and that this term describes the nature of tuples well. But he also says
    that tuples are not just immutable lists; they are much more than that.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是一个值的容器，类似于列表。在他伟大的著作《*流畅的 Python*》中，L. Ramalho 解释说，元组是为了成为*不可变的列表*而创建的，这个术语很好地描述了元组的本质。但他也提到，元组不仅仅是不可变的列表；它们远不止于此。
- en: In particular, tuples can be used as records without field names. This means
    that we can have a record with several unnamed fields. Certainly, such a tuple-based
    record makes sense only when it is clear what each field represents.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，元组可以用作没有字段名称的记录。这意味着我们可以有一个包含几个未命名字段的记录。当然，这种基于元组的记录只有在每个字段的含义明确时才有意义。
- en: 'When you want to create a tuple in Python using a tuple literal, you need to
    use parentheses `()` instead of square brackets `[]`, as you would when creating
    a list¹:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想在 Python 中使用元组字面量创建元组时，你需要使用圆括号 `()` 而不是方括号 `[]`，就像创建列表时一样¹：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, `x_tuple_1 = (1, 2, 3)` creates a three-element tuple containing numbers
    `1`, `2`, and `3`; `x_tuple_2 = ([1, 2], 3)` creates a two-element tuple with
    two values: a list `[1, 2]` and number `3`. As you see, you can use objects of
    any types in a tuple. You can even create a tuple of empty tuples:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`x_tuple_1 = (1, 2, 3)` 创建了一个包含数字 `1`、`2` 和 `3` 的三元素元组；`x_tuple_2 = ([1,
    2], 3)` 创建了一个包含两个值的两元素元组：一个列表 `[1, 2]` 和数字 `3`。如你所见，你可以在元组中使用任何类型的对象。你甚至可以创建一个空元组的元组：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Although, to be honest, I do not know why you would want to do this.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管，说实话，我不知道你为什么会想这样做。
- en: 'Okay, so above we used a tuple literal. A second method of creating a tuple
    is using the built-in `tuple()` class. Enough to provide an iterable as an argument,
    and this will convert the iterable to a tuple:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们上面使用了元组字面量。创建元组的第二种方法是使用内置的 `tuple()` 类。只需提供一个可迭代对象作为参数，这将把可迭代对象转换为元组：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To access values in a tuple, you can use typical indexing: `x_tuple_1[0]` will
    return `1` while `x_tuple_2[0]` will return a list, `[1, 2]`. Note that since
    `x_tuple_2[0]` is a list, you can access its elements using its indices — so,
    you will use multiple (here, double) indexing; for example, `x_tuple_2[0][0]`
    will return `1` while `x_tuple_2[0][1]` will return `2`.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问元组中的值，你可以使用典型的索引：`x_tuple_1[0]` 将返回 `1`，而 `x_tuple_2[0]` 将返回一个列表 `[1, 2]`。注意，因为
    `x_tuple_2[0]` 是一个列表，所以你可以使用它的索引来访问它的元素——因此，你将使用多个（在这里是双重）索引；例如，`x_tuple_2[0][0]`
    将返回 `1`，而 `x_tuple_2[0][1]` 将返回 `2`。
- en: 'The biggest difference between lists and tuples is that lists are mutable,
    so you can change them, while tuples are immutable, so you cannot change them:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 列表和元组之间最大的区别在于列表是可变的，所以你可以改变它们，而元组是不可变的，所以你不能改变它们：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you see, you cannot use item assignment with tuples. This feature makes tuples
    less error prone than lists, as you can be sure (actually, almost sure, as we
    will discuss below) that tuples will not change. You can be sure, however, that
    their length will not change.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你不能对元组进行项赋值。这一特性使得元组比列表更不容易出错，因为你可以确定（实际上，几乎可以确定，我们将下文讨论）元组不会改变。然而，你可以确定的是，它们的长度不会改变。
- en: 'There is a common interview question about tuples: *Since tuples are immutable,
    you cannot change their values, right?* And the answer to this very question is:
    *Well*…'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个关于元组的常见面试问题：*由于元组是不可变的，你不能改变它们的值，对吗？* 对这个问题的回答是：*嗯*…
- en: 'This is because you can change values of mutable elements of a tuple:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为你可以改变元组中可变元素的值：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: So, although tuples are immutable, if their elements are not, you can change
    these elements, and so, at least indirectly, you can change the tuple. This makes
    it possible to change an unchangeable…
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，尽管元组是不可变的，但如果它们的元素不是，你可以改变这些元素，因此，至少间接地，你可以改变元组。这使得改变一个不可变的东西成为可能…
- en: If you’re feeling confused, at least clothe yourself with the fact that you’re
    not alone. You’re just one of many. However, this kind of immutability makes sense,
    at least theoretically, so let me explain what’s going on here.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感到困惑，至少要意识到你并不孤单。你只是其中之一。然而，这种不可变性至少在理论上是有意义的，所以让我解释一下这里发生了什么。
- en: The whole truth lies in the following. Like other collections, tuples do not
    contain objects but references to them; being immutable means being immutable
    in terms of these references. Therefore, once created, a tuple will always contain
    the same set of references.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 整个真相在于以下几点。像其他集合一样，元组不包含对象，而是包含对它们的引用；不可变意味着在这些引用方面是不可变的。因此，一旦创建，元组将始终包含相同的引用集合。
- en: '*In theory*, when an object being referenced to by one of a tuple’s references
    changes, the tuple remains the same: it’s still the very same tuple, with the
    very same references.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*理论上*，当一个元组引用的对象发生变化时，元组保持不变：它仍然是完全相同的元组，具有完全相同的引用。'
- en: '*In practice* (that is, from our typical/natural point of view), when an object
    being referenced to by one of a tuple’s references changes, the tuple *seems to*
    have changed: despite the very same references, one of the objects changed, so,
    in practice, the tuple *looks* different than it did before this change. But theoretically,
    the tuple (a collection of references) has not changed whatsoever.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实际上*（也就是说，从我们典型/自然的角度来看），当一个元组引用的对象发生变化时，元组*似乎*已经改变：尽管引用完全相同，一个对象发生了变化，因此，从实际情况来看，元组*看起来*与变化前不同。但在理论上，元组（一个引用的集合）没有发生任何变化。'
- en: Like other collections, tuples do not contain objects but references to them;
    being immutable means being immutable in terms of these references.
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 像其他集合一样，元组不包含对象，而是包含对它们的引用；不可变意味着在这些引用方面是不可变的。
- en: Okay, now that we know how tuple immutability works, we should remember to think
    that way about tuples, too. But knowing something does not have to mean that getting
    used to it will be easy. It’s not that easy to think of immutability that way.
    Remember, from now on you should remember that a tuple is an immutable collection
    of references to objects, not an immutable collection of objects. The values of
    objects a tuple contains can actually change — but the objects must stay the same…
    Already feeling a headache? It’s just the beginning…
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在我们知道了元组的不可变性是如何工作的，我们应该记住也要以这种方式来看待元组。但知道某件事并不意味着习惯它会很容易。以这种方式思考不可变性并不容易。记住，从现在开始，你应该记住元组是对对象的不可变引用集合，而不是对象的不可变集合。元组包含的对象的值实际上可以改变——但对象必须保持不变……已经觉得头疼了吗？这只是开始…
- en: Let’s think of a typical length of tuples. To add some context, however, we
    should consider what it looks like in lists. I think it’s safe to say that both
    short and long lists are frequently used. You can create a list using various
    methods, like a literal, a `for` loop, the `list()` method, and a list comprehension.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下典型的元组长度。然而，为了增加一些背景，我们应该考虑它在列表中的表现。我认为可以安全地说，短列表和长列表都经常使用。你可以通过多种方法创建列表，比如字面量、`for`循环、`list()`方法和列表推导。
- en: 'Immutable, tuples do not work like that. You cannot update them in a `for`
    loop (unless you’re updating their mutable elements) or a [comprehension](/a-guide-to-python-comprehensions-4d16af68c97e).
    You can create a tuple in two ways, using a tuple literal, like here:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是不可变的，它们并不像那样工作。你不能在`for`循环中更新它们（除非你在更新它们的可变元素）或在[推导式](/a-guide-to-python-comprehensions-4d16af68c97e)中更新它们。你可以用两种方式创建一个元组，使用元组字面量，比如这里：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'or calling the `tuple()` class (`tuple()` is a callable class) to an iterable:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 或调用`tuple()`类（`tuple()`是一个可调用类）对一个可迭代对象：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: My guess is that the former use case is far more frequent. Perhaps the most
    frequent use of the tuple is to return values from a function, especially when
    it’s two or three values (you would seldom (if ever) do this for ten values).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我猜前一种用法要频繁得多。也许元组最常见的用法是从函数中返回值，特别是当返回两个或三个值时（你很少（如果有的话）会为十个值这么做）。
- en: 'When a tuple literal is short, quite often the parentheses are omitted:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当元组字面量很短时，通常会省略括号：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This approach is often used with `return` statements, but not only. Is any of
    the two — with or without parentheses — better? Generally, no; but it depends
    on the situation. Sometimes the parentheses will make the code clearer, and some
    other times their absence will.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法通常与 `return` 语句一起使用，但不仅限于此。带括号和不带括号的两种方式中哪一种更好？一般来说，没有哪一种更好；但这要视情况而定。有时，括号会使代码更清晰，有时则不需要括号。
- en: 'Do remember about non-parentheses tuples, as they can be a source of bugs that
    are difficult to find; see here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住非括号元组，因为它们可能成为难以发现的错误来源；见这里：
- en: '[](https://betterprogramming.pub/find-a-bug-in-python-code-a-little-thing-does-so-much-89d0abd0300c?source=post_page-----12a7ab9dbd0d--------------------------------)
    [## Find a Bug in Python Code: A Little Thing Does So Much'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[找到 Python 代码中的 bug：小细节作用大](https://betterprogramming.pub/find-a-bug-in-python-code-a-little-thing-does-so-much-89d0abd0300c?source=post_page-----12a7ab9dbd0d--------------------------------)'
- en: Even the smallest characters can introduce big problems
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 即使是最小的字符也可能引发大问题
- en: betterprogramming.pub](https://betterprogramming.pub/find-a-bug-in-python-code-a-little-thing-does-so-much-89d0abd0300c?source=post_page-----12a7ab9dbd0d--------------------------------)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[更好编程](https://betterprogramming.pub/find-a-bug-in-python-code-a-little-thing-does-so-much-89d0abd0300c?source=post_page-----12a7ab9dbd0d--------------------------------)'
- en: 'To put it simply, when you forget about a comma at the end of a line, you may
    be using a tuple with an object instead of the object itself:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，当你忘记在行末添加逗号时，你可能会将一个对象作为元组而不是单独的对象来使用：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You may think that `x` is a set with three elements, but in fact it’s a tuple
    with one element:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为 `x` 是一个包含三个元素的集合，但实际上它是一个包含一个元素的元组：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you see, this one single comma put after instead of before the right curly
    bracket made `x` a one-element tuple.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这一个单独的逗号放在右大括号后面，而不是前面，使得 `x` 成为了一个一元素的元组。
- en: Tuples in action
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组的实际应用
- en: 'Tuples offer fewer methods than lists, but still quite a few. Some of them
    are better known than others; some are even very little known and used rather
    infrequently. In this section, we we discuss two important aspects of using tuples:
    tuple methods and unpacking tuples.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 元组提供的方法比列表少，但仍然有不少。有些方法比其他方法更为人所知；有些方法甚至非常少为人知晓且使用得不频繁。在本节中，我们将探讨使用元组的两个重要方面：元组方法和元组解包。
- en: Unpacking
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解包
- en: 'A fantastic feature of tuples is *tuple unpacking*. You can use it to assign
    a tuple’s values to multiple names at once. For example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 元组的一个极好的特性是 *元组解包*。你可以用它将一个元组的值一次性赋给多个变量。例如：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, `a` would become `1`, `b` would become `2`, and `c` would become 3.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`a` 将变为 `1`，`b` 将变为 `2`，而 `c` 将变为 `3`。
- en: 'Consider the below example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can also use special unpacking syntax using the asterisk, `*`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用带有星号 `*` 的特殊解包语法：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you see, when you attach the asterisk `*` to a name, it’s like saying, “Unpack
    this very item and all next ones to this name.” So:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，当你将星号 `*` 附加到一个变量名时，就像是在说：“将这个项及所有接下来的项解包到这个名字中。”所以：
- en: '`a, b*` means unpack the first element to `a` and all the remaining ones to
    `b`.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a, b*` 意味着将第一个元素解包到 `a`，所有剩余的元素解包到 `b`。'
- en: '`*a, b` means unpack the last element to `b` and all those before to `a`.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*a, b` 意味着将最后一个元素解包到 `b`，所有之前的元素解包到 `a`。'
- en: '`a, *b, c` means unpack the first element to `a`, the last element to `c`,
    and all the in-between elements to `b`.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a, *b, c` 意味着将第一个元素解包到 `a`，最后一个元素解包到 `c`，所有中间的元素解包到 `b`。'
- en: 'With more elements in a tuple, you can consider more scenarios. Imagine you
    have a tuple of seven elements, and you’re interested in the first two and the
    last one. You can use unpacking to get and assign them to names in the following
    way:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当元组中的元素更多时，你可以考虑更多场景。想象一下你有一个包含七个元素的元组，而你对前两个和最后一个感兴趣。你可以用解包的方式将它们获取并赋值给变量，如下所示：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Note here one more thing. I used `*_`, as I needed to extract only these three
    values, and the other ones can be ignored. Here, the underscore character, `_`,
    means exactly that: I don’t care what these other values from the tuple are, and
    so let’s ignore them. If you use a name instead, the reader of the code would
    think that the name is used somewhere in the code — but also your IDE would scream
    at you for assigning values to a name that isn’t used anywhere in the scope².'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还要注意一点。我使用了 `*_`，因为我只需要提取这三个值，其他值可以忽略。这里，下划线字符 `_` 正是表示这一点：我不关心这些元组中的其他值，因此让我们忽略它们。如果你使用名称，代码的读者会认为该名称在代码中被使用——但你的
    IDE 也会对分配给一个在作用域中未被使用的名称而发出警告²。
- en: Tuple unpacking can be used in various scenarios, but it’s particularly useful
    when you’re assigning values returned from a function or method that returns a
    tuple. The below example shows the usefulness of unpacking values returned from
    a function/method.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 元组解包可以用于各种场景，但当你赋值时，特别是从返回元组的函数或方法中获得值时，它特别有用。下面的例子展示了从函数/方法返回值中解包的有用性。
- en: 'First, let’s create a `Rectangle` class:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个 `Rectangle` 类：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you see, the `Rectangle.summarize()` method returns two values organized
    in a tuple: the rectangle’s area and perimeter. If we want to assign these values
    to names, we could do as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`Rectangle.summarize()` 方法返回两个组织在元组中的值：矩形的面积和周长。如果我们想将这些值分配给名称，我们可以这样做：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'However, the above approach is not a good one, among others for clarity reasons,
    and we can do it much more effectively using tuple unpacking:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，上述方法并不是一个好的选择，尤其是出于清晰性考虑，我们可以使用元组解包更有效地完成这个任务：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you can see, it’s clearer and shorter: just one line instead of three. In
    addition, it does not use indexing to get the values from the tuple. Indexing
    decreases readability, and it’d be better to use names instead of positions. We
    will discuss this below, in the section on inheriting from the `tuple` class and
    on named tuples. But remember that when a function/method returns a tuple — quite
    a frequent situation — you should unpack these values instead of assign them directly
    using tuple indexing.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它更加清晰简洁：只需一行而不是三行。此外，它不使用索引来从元组中获取值。索引降低了可读性，使用名称而非位置会更好。我们将在下面的部分讨论，从
    `tuple` 类继承和命名元组。但请记住，当一个函数/方法返回一个元组——这是一种相当常见的情况——你应该解包这些值，而不是直接使用元组索引分配它们。
- en: 'One more example, also using a `dataclass`³:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子，也使用 `dataclass`³：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The above examples show the most frequent use cases of tuple unpacking. Nonetheless,
    we can sometimes need to unpack values from a nested data structure based on tuples.
    Consider the following example. Imagine that we have a list of cities like above,
    a city being represented by a list inside a dictionary, not a `dataclass`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例展示了元组解包的最常见用例。然而，有时我们可能需要从基于元组的嵌套数据结构中解包值。考虑以下例子。假设我们有一个如上所示的城市列表，每个城市由一个字典中的列表表示，而不是
    `dataclass`：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As you see, we have the coordinates of the cities organized as tuples inside
    the list. We can use nested unpacking to get the coordinates:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们将城市的坐标组织成了列表中的元组。我们可以使用嵌套解包来获取这些坐标：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Or we may need also the area:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可能还需要面积：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Again, I have again used the underscore character, `_`, to assign a value we
    don’t need.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我使用了下划线字符 `_` 来分配我们不需要的值。
- en: 'Note that what we do with `*args` is exactly unpacking. By putting `*args`
    inside a function’s arguments, you let the users know they can use any arguments
    there:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们对 `*args` 所做的正是解包。通过将 `*args` 放在函数的参数中，你让用户知道他们可以使用任何参数：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, `*args` collects all the positional (not keyword!) arguments into the
    `args` tuple. This `return` statement enables us to see these arguments in the
    `args` tuple.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`*args` 将所有位置参数（而非关键字参数）收集到 `args` 元组中。这个 `return` 语句使我们能够查看 `args` 元组中的这些参数。
- en: 'One more thing: unpacking is not reserved for tuples, and you can use it to
    other iterables, too:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一点：解包不仅限于元组，你也可以将它用于其他可迭代对象：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Tuple methods
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组方法
- en: Python beginners learn about tuples rather quickly. With time, they learn a
    little more about them, mainly their immutability and its consequences. But many
    developers do not know all the methods the `tuple` class offers. To be honest,
    before writing this article, I did not know them when I was considering myself
    quite an advanced developer. But it’s good to know these methods — and this subsection
    aims to help you learn them.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Python 初学者很快就会了解元组。随着时间的推移，他们会多了解一些，主要是它们的不变性及其后果。但许多开发者不知道`tuple`类提供的所有方法。说实话，在写这篇文章之前，当我认为自己是一个相当高级的开发者时，我也不知道这些方法。不过了解这些方法是好的——这一小节旨在帮助你学习这些方法。
- en: 'It does not mean you need to use all of them. But it’s good, for example, to
    remember that you can use in-place operations on tuples, and what they lead to.
    This knowledge is enough to recall that there are only two in-place operations
    for tuples: in-place concatenation and in-place repeated concatenation.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着你需要使用所有这些操作。但例如，记住可以在元组上使用就地操作及其结果是好的。这些知识足以让你回忆起，元组只有两种就地操作：就地拼接和就地重复拼接。
- en: To learn the methods, let’s peek into *Fluent Python* again. We will find there
    a nice table with the comparison of the list’s and the tuple’s methods, from which
    we can extract the latter. Hence, below, you will find a complete list of methods
    of the `tuple` class, each accompanied by one or more simple examples.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了学习这些方法，我们再看看*《流畅的 Python》*。我们将找到一个比较列表和元组方法的漂亮表格，从中我们可以提取出元组的方法。因此，下面你将找到`tuple`类的完整方法列表，每个方法附有一个或多个简单示例。
- en: '*Get length*: `len(x)`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*获取长度*：`len(x)`'
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Concatenation*: `x + y`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*拼接*：`x + y`'
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Repeated concatenation*: `x * n`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*重复拼接*：`x * n`'
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Reversed repeated concatenation*: `n * x`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*反向重复拼接*：`n * x`'
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*In-place concatenation*: `x += y`'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*就地拼接*：`x += y`'
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The syntax of in-place concatenation may suggest that we’re dealing with the
    same object: we started with tuple `x` that was equal to `(1, 2, 3)`; after concatenating
    `y`, `x` was still a tuple, but it contained six values: `(1, 2, 3, "a", "b",
    "c")`. Since we discussed tuple immutability, we know that the `x` before and
    the `x` after were two different objects.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 就地拼接的语法可能会暗示我们在处理相同的对象：我们从等于`(1, 2, 3)`的元组`x`开始；在拼接`y`之后，`x`仍然是一个元组，但包含了六个值：`(1,
    2, 3, "a", "b", "c")`。由于我们讨论了元组的不变性，我们知道`x`之前和`x`之后是两个不同的对象。
- en: 'We can easily check this using the following simple test. It uses the two objects’
    `id`s: if they have the same `id`, they are one and the same object, but if the
    `id`s differ, `x` before the in-place concatenation and `x` after it are two different
    objects. Let’s do it:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下简单测试轻松检查这一点。它使用两个对象的`id`：如果它们有相同的`id`，那么它们是同一个对象；但如果`id`不同，那么在就地拼接之前和之后的`x`是两个不同的对象。我们来做一下测试：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The two `id`s differ, meaning that `x` after the in-place operation is a different
    object than `x` before it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`id`不同，这意味着在就地操作之后的`x`与之前的`x`是不同的对象。
- en: '*In-place repeated concatenation*: `x *= n`'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*就地重复拼接*：`x *= n`'
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'What I wrote above applies here, too: although we see just one name here, `x`,
    we have two objects: the before `x` and the after `x`.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我上面写的同样适用在这里：尽管我们在这里看到的只有一个名字，`x`，但实际上有两个对象：`x`之前的和`x`之后的。
- en: '*Contains*:`in`'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*包含*：`in`'
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Count occurrences of an element*: `x.count(element)`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*计算元素出现的次数*：`x.count(element)`'
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Get item at position*:`x[i]` (`x.__getitem__(i)`)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*获取指定位置的项*：`x[i]`（`x.__getitem__(i)`）'
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Find position of first occurrence of* `element`: `x.index(element)`'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*查找第一次出现的* `element` *的位置*：`x.index(element)`'
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Get iterator*: `iter(x)` (`x.__iter__()`)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*获取迭代器*：`iter(x)`（`x.__iter__()`）'
- en: '[PRE36]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Support for optimized serialization with* `pickle`: `x.__getnewargs__()`'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*支持使用* `pickle` *优化序列化*：`x.__getnewargs__()`'
- en: 'This method is not to be used like the above ones, in a direct way. Instead,
    it’s used during pickling to optimize tuples’ pickling, like in the below toy
    example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法不像上面那些方法那样直接使用。相反，它在pickle序列化过程中用于优化元组的序列化，如下面的玩具示例所示：
- en: '[PRE37]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In his fantastic book *Fluent Python* (2nd edition), Luciano Ramalho lists 15
    methods that that the list has but the tuple does not— but this one, the optimized
    pickling optimization, is the *only* method that the tuple has and the list does
    not.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在他那本精彩的书*《流畅的 Python》（第2版）*中，Luciano Ramalho列出了15个列表有而元组没有的方法——但这个优化序列化的方法是元组独有的，是列表没有的*唯一*方法。
- en: '![](../Images/3d0766b50bbdc25cfa5ecbb9dde984d7.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3d0766b50bbdc25cfa5ecbb9dde984d7.png)'
- en: Word “tuple” in various languages. Image by author.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: “元组”一词在不同语言中的表达。图片由作者提供。
- en: Conclusion
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: In this article, we’ve discussed the basics of one of the most common Python
    collection types, the tuple. I hope you’ve enjoyed this — and if you did, be aware
    that what we’ve discussed was not only basic but also, how to say it, uncontroversial.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇文章中，我们讨论了Python中最常见的集合类型之一——元组的基础知识。希望你喜欢这篇文章——如果喜欢，请注意，我们讨论的不仅仅是基础知识，还可以说是非争议性的。
- en: There’s much more into tuples, however, and some of it is not as clear as what
    we’ve learned from this article. We will discuss this in the continuation of this
    article. You will see there that tuples are not an easy topic, as you might think
    after reading this article. No, in my opinion tuples are more controversial than
    any other built-in type. Perhaps even tuples are overused — but I will let you
    decide yourself after reading the next article. But to be honest, there are things
    about tuples I don’t like. In fact, I will be a little harsh for tuples… Rather
    much… Maybe even too much?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，元组还有更多内容，其中一些内容并不像我们从这篇文章中学到的那样清晰。我们将在这篇文章的后续部分讨论这些内容。你会看到，元组并不像你读完这篇文章后可能想象的那样简单。在我看来，元组比任何其他内置类型都更具争议性。也许元组甚至被过度使用了——但在读完下一篇文章后，我让你自己决定。老实说，我对元组有些不满。实际上，我会对元组有点苛刻……甚至可能有些过头？
- en: 'I hope I have intrigued you enough for you to read the continuation of this
    article. You will find it here:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望我已经足够引起你的兴趣，让你阅读这篇文章的续集。你可以在这里找到它：
- en: '[](/python-tuple-the-whole-truth-and-only-truth-lets-dig-deep-24d2bf02971b?source=post_page-----12a7ab9dbd0d--------------------------------)
    [## Python Tuple, The Whole Truth and Only Truth: Let’s Dig Deep'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[## Python元组，全面的真相与唯一真相：让我们深入探讨](/python-tuple-the-whole-truth-and-only-truth-lets-dig-deep-24d2bf02971b?source=post_page-----12a7ab9dbd0d--------------------------------)'
- en: Learn the intricacies of tuples
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了解元组的复杂性
- en: towardsdatascience.com](/python-tuple-the-whole-truth-and-only-truth-lets-dig-deep-24d2bf02971b?source=post_page-----12a7ab9dbd0d--------------------------------)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[towardsdatascience.com](/python-tuple-the-whole-truth-and-only-truth-lets-dig-deep-24d2bf02971b?source=post_page-----12a7ab9dbd0d--------------------------------)'
- en: 'Thank you for reading. If you enjoyed this article, you may also enjoy other
    articles I wrote; you will see them [here](https://medium.com/@nyggus). If you
    want to join Medium, please use my referral link below:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢阅读。如果你喜欢这篇文章，你可能也会喜欢我写的其他文章；你可以在[这里](https://medium.com/@nyggus)查看。如果你想加入Medium，请使用下面的推荐链接：
- en: '[](https://medium.com/@nyggus/membership?source=post_page-----12a7ab9dbd0d--------------------------------)
    [## Join Medium with my referral link — Marcin Kozak'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[## 通过我的推荐链接加入Medium — Marcin Kozak](https://medium.com/@nyggus/membership?source=post_page-----12a7ab9dbd0d--------------------------------)'
- en: Read every story from Marcin Kozak (and thousands of other writers on Medium).
    Your membership fee directly supports…
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阅读Marcin Kozak的每一个故事（以及Medium上的其他数千位作者的故事）。你的会员费直接支持……
- en: medium.com](https://medium.com/@nyggus/membership?source=post_page-----12a7ab9dbd0d--------------------------------)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[medium.com](https://medium.com/@nyggus/membership?source=post_page-----12a7ab9dbd0d--------------------------------)'
- en: Footnotes
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚注
- en: ¹ Note that in many code blocks, like the one above, I use `doctest` testing,
    in order to assure that the examples work correctly. You can read more about `doctest`
    in the module’s [documentation](https://docs.python.org/3/library/doctest.html)
    and [this introductory article published in *Towards Data Science*](https://medium.com/towards-data-science/python-documentation-testing-with-doctest-the-easy-way-c024556313ca).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ 请注意，在许多代码块中，如上面所示，我使用了`doctest`测试，以确保示例正确运行。你可以在模块的[文档](https://docs.python.org/3/library/doctest.html)和[这篇在*Towards
    Data Science*上发布的介绍文章](https://medium.com/towards-data-science/python-documentation-testing-with-doctest-the-easy-way-c024556313ca)中了解更多关于`doctest`的信息。
- en: ² Note that I wrote “in scope” and not “in code”. This is because while we do
    not need these values here, we can need them elsewhere in the code, in some other
    scope (e.g., in another function). Using particular unpacking in a particular
    scope only affects this scope; hence, we can unpack the same iterable once more,
    in another scope, and this unpacking can be different.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ² 请注意，我写的是“在范围内”，而不是“在代码中”。这是因为虽然我们在这里不需要这些值，但我们可能在代码的其他地方，在某个其他范围内需要它们（例如，在另一个函数中）。在特定范围内使用特定解包只会影响这个范围；因此，我们可以在另一个范围内再次解包相同的可迭代对象，这种解包可能会有所不同。
- en: ³ In the code block, you will find the `KmSquare` type alias. I used it to increase
    the readability of the floats used to define a city. You can read more about such
    type hinting and type aliasing [here](https://medium.com/better-programming/pythons-type-hinting-friend-foe-or-just-a-headache-73c7849039c7).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码块中，你会发现 `KmSquare` 类型别名。我使用它来提高定义城市时浮点数的可读性。你可以在[这里](https://medium.com/better-programming/pythons-type-hinting-friend-foe-or-just-a-headache-73c7849039c7)阅读更多关于类型提示和类型别名的内容。
- en: Resources
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源
- en: '[](/python-documentation-testing-with-doctest-the-easy-way-c024556313ca?source=post_page-----12a7ab9dbd0d--------------------------------)
    [## Python Documentation Testing with doctest: The Easy Way'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[## Python 文档测试，使用 doctest：简单的方法](https://towardsdatascience.com/python-documentation-testing-with-doctest-the-easy-way-c024556313ca?source=post_page-----12a7ab9dbd0d--------------------------------)'
- en: doctest allows for documentation, unit and integration testing, and test-driven
    development.
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: doctest 允许进行文档、单元和集成测试，以及测试驱动开发。
- en: towardsdatascience.com](/python-documentation-testing-with-doctest-the-easy-way-c024556313ca?source=post_page-----12a7ab9dbd0d--------------------------------)
    [](/a-guide-to-python-comprehensions-4d16af68c97e?source=post_page-----12a7ab9dbd0d--------------------------------)
    [## A Guide to Python Comprehensions
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[## Python 列表推导指南](https://towardsdatascience.com/a-guide-to-python-comprehensions-4d16af68c97e?source=post_page-----12a7ab9dbd0d--------------------------------)'
- en: Learn the intricacies of list comprehensions (listcomps), set comprehensions
    (setcomps), dictionary comprehensions…
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了解列表推导（listcomps）、集合推导（setcomps）、字典推导等的复杂性…
- en: 'towardsdatascience.com](/a-guide-to-python-comprehensions-4d16af68c97e?source=post_page-----12a7ab9dbd0d--------------------------------)
    [](https://betterprogramming.pub/find-a-bug-in-python-code-a-little-thing-does-so-much-89d0abd0300c?source=post_page-----12a7ab9dbd0d--------------------------------)
    [## Find a Bug in Python Code: A Little Thing Does So Much'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[## 找到 Python 代码中的 bug：小细节产生大问题](https://betterprogramming.pub/find-a-bug-in-python-code-a-little-thing-does-so-much-89d0abd0300c?source=post_page-----12a7ab9dbd0d--------------------------------)'
- en: Even the smallest characters can introduce big problems
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 即使是最小的字符也可能引入大问题
- en: betterprogramming.pub](https://betterprogramming.pub/find-a-bug-in-python-code-a-little-thing-does-so-much-89d0abd0300c?source=post_page-----12a7ab9dbd0d--------------------------------)
    [](https://www.oreilly.com/library/view/fluent-python-2nd/9781492056348/?source=post_page-----12a7ab9dbd0d--------------------------------)
    [## Fluent Python, 2nd Edition
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[## Fluent Python，第 2 版](https://betterprogramming.pub/find-a-bug-in-python-code-a-little-thing-does-so-much-89d0abd0300c?source=post_page-----12a7ab9dbd0d--------------------------------)'
- en: Python's simplicity lets you become productive quickly, but often this means
    you aren't using everything it has to…
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python 的简洁性使你可以迅速变得高效，但这通常意味着你并没有充分利用它的所有功能…
- en: www.oreilly.com](https://www.oreilly.com/library/view/fluent-python-2nd/9781492056348/?source=post_page-----12a7ab9dbd0d--------------------------------)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[## Python 文档测试，使用 doctest：简单的方法](https://www.oreilly.com/library/view/fluent-python-2nd/9781492056348/?source=post_page-----12a7ab9dbd0d--------------------------------)'
