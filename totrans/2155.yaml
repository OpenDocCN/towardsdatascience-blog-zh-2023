- en: 'Taming Text with string2string: A Powerful Python Library for String-to-String
    Algorithms'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/tutorial-string2string-python-pkg-f9126b8474c5](https://towardsdatascience.com/tutorial-string2string-python-pkg-f9126b8474c5)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: TUTORIAL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Leverage string2string for Natural Language Processing Tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.ealizadeh.com/?source=post_page-----f9126b8474c5--------------------------------)[![Essi
    Alizadeh](../Images/be2244231732f93bcadf09682ef8ca37.png)](https://medium.ealizadeh.com/?source=post_page-----f9126b8474c5--------------------------------)[](https://towardsdatascience.com/?source=post_page-----f9126b8474c5--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----f9126b8474c5--------------------------------)
    [Essi Alizadeh](https://medium.ealizadeh.com/?source=post_page-----f9126b8474c5--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----f9126b8474c5--------------------------------)
    ·8 min read·May 11, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1cd63dbedcd4c1523f491ef2b3927751.png)'
  prefs: []
  type: TYPE_IMG
- en: Wordcloud of concepts available in string2string library in addition to an example
    (Image by Author).
  prefs: []
  type: TYPE_NORMAL
- en: The `string2string` library is an open-source tool that has a full set of efficient
    methods for string-to-string problems. String pairwise alignment, distance measurement,
    lexical and semantic search, and similarity analysis are all covered in this library.
    Additionally, a variety of useful visualization tools and metrics that make it
    simpler to comprehend and evaluate the findings of these approaches are also included.
  prefs: []
  type: TYPE_NORMAL
- en: The library has well-known algorithms like the Smith-Waterman, Hirschberg, Wagner-Fisher,
    BARTScore, BERTScore, Knuth-Morris-Pratt, and Faiss search. It can be used for
    many jobs and problems in natural-language processing, bioinformatics, and computer
    social studies [1].
  prefs: []
  type: TYPE_NORMAL
- en: The [Stanford NLP group](https://nlp.stanford.edu/), which is part of the Stanford
    AI Lab, has developed the library and introduced it in [1]. The library’s GitHub
    repository has several [tutorials](https://github.com/stanfordnlp/string2string/tree/main#tutorials)
    that you may find useful.
  prefs: []
  type: TYPE_NORMAL
- en: A *string* is a sequence of characters (letters, numbers, and symbols) that
    stands for a piece of data or text. From everyday phrases to DNA sequences, and
    even computer programs, strings may be used to represent just about everything
    [[](https://ealizadeh.com/blog/tutorial-string2string/#ref-suzgun2023string2string)1].
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Table of Contents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Installation](#3d0b)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Pairwise Alignment](#8c12)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: – [Needleman-Wunsch Algorithm for Global Alignment](#f0e7)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – [Dynamic Time Warping](#0a4b)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Search Problems](#793b)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: – [Lexical Search (exact-match search)](#5915)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – [Semantic Search](#795d)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: –– [Semantic Search via Faiss](#a554)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Distance](#5e77)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: – [Levenshtein edit distance](#2726)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – [Jaccard Index](#5130)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Similarity Analysis](#eb49)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Conclusion](#e244)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[References](#1b7b)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can install the library via pip by running `pip install string2string`.
    For more information, visit the library’s [GitHub Page](https://github.com/stanfordnlp/string2string).
  prefs: []
  type: TYPE_NORMAL
- en: Pairwise Alignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: String pairwise alignment is a method used in NLP and other disciplines to compare
    two strings, or sequences of characters, by highlighting their shared and unique
    characteristics. The two strings are aligned, and a similarity score is calculated
    based on the number of shared characters, as well as the number of shared gaps
    and mismatches. This procedure is useful for locating sequences of characters
    that share similarities and calculating the “distance” between two sets of strings.
    Spell checking, text analysis, and bioinformatics sequence comparison (e.g., DNA
    sequence alignment) are just some of the many uses for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, the `string2string` package provides the following alignment techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: Needleman-Wunsch for global alignment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smith-Waterman for local alignment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hirchberg’s algorithm for linear space global alignment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Longest common subsequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Longest common substring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic time warping (DTW) for time series alignment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this post, we’ll look at two examples: one for global alignment and one
    for time series alignment.'
  prefs: []
  type: TYPE_NORMAL
- en: Needleman-Wunsch Algorithm for Global Alignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Needleman-Wunsch algorithm is a type of dynamic programming algorithm that
    is often used in bioinformatics to match two DNA or protein sequences, globally.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For a more informative comparison, we can use `plot_pairwise_alignment()` function
    in the library.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6b2de8646275c91a71c808577929131f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: Global alignment between “ACGTGGA” and “AGCTCGC” (Image by Author).'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Time Warping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DTW is a useful tool to compare two time series that might differ in speed,
    duration, or both. It discovers the path across these distances that minimizes
    the total difference between the sequences by calculating the “distance” between
    each pair of points in the two sequences.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go over an example using the `alignment` module in the `string2string`
    library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Above is an example borrowed from my previous post, [*An Illustrative Introduction
    to Dynamic Time Warping*](https://ealizadeh.com/blog/introduction-to-dynamic-time-warping/#example-1).
    For those looking to delve deeper into the topic, in [2], I explained the core
    concepts of DTW in a visual and accessible way.
  prefs: []
  type: TYPE_NORMAL
- en: Search Problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'String search is the task of finding a pattern substring within another string.
    The library offers two types of search algorithms: lexical search and semantic
    search.'
  prefs: []
  type: TYPE_NORMAL
- en: Lexical Search (exact-match search)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lexical search, in layman’s terms, is the act of searching for certain words
    or phrases inside a text, analogous to searching for a word or phrase in a dictionary
    or a book.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of trying to figure out what a string of letters or words means, it
    just tries to match them exactly. When it comes to search engines and information
    retrieval, lexical search is a basic strategy to finding relevant resources based
    on the keywords or phrases users enter, without any attempt at comprehending the
    linguistic context of the words or phrases in question.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, the `string2string` library provides the following lexical search
    algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: Naive (brute-force) search algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rabin-Karp search algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knuth-Morris-Pratt (KMP) search algorithm (see the example below)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boyer-Moore search algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Semantic Search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Semantic search is a more sophisticated method of information retrieval that
    goes beyond simple word or phrase searches. It employs NLP (natural language processing)
    to decipher a user’s intent and return accurate results.
  prefs: []
  type: TYPE_NORMAL
- en: To put it another way, let’s say you’re interested in “how to grow apples.”
    While a lexical search may produce results including the terms “grow” and “apples,”
    a semantic search will recognize that you are interested in the cultivation of
    apple trees and deliver results accordingly. The search engine would then prioritize
    results that not only included the phrases it was looking for but also gave relevant
    information about planting, trimming, and harvesting apple trees.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic Search via Faiss
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Faiss (Facebook AI Similarity Search) is an efficient similarity search tool
    that is useful for dealing with high-dimensional data with numerical representations
    [3]. The `string2string` library has a wrapper for the FAISS library developed
    by Facebook (see [GitHub repository](https://github.com/facebookresearch/faiss)).
  prefs: []
  type: TYPE_NORMAL
- en: In short, Faiss search ranks its results based on a "score,” representing the
    degree to which two objects are similar to one another. The score makes it possible
    to interpret and prioritize search results based on how close/relevant they are
    to the desired target.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how the Faiss search is used in the `string2string` library. Here,
    we have a corpus (a corpus is a large and structured collections of texts used
    for linguistic research, NLP and ML applications) of 11 sentences, and we will
    do a semantic search by querying a target sentence to see how close/relevant it
    is to these sentences.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Let’s initialize the `FaissSearch` object. Facebook's BART Large model is the
    default model and tokenizer for the `FaissSearch` object.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s find the top 3 most similar sentences in the corpus to the query and print
    them, as well as their similarity scores.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Distance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'String distance is the task of quantifying the degree to which two supplied
    strings differ using a distance function. Currently, the `string2string` library
    offers the following distance functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Levenshtein edit distance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Damerau-Levenshtein edit distance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hamming distance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jaccard distance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Levenshtein edit distance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Levenshtein edit distance, or simply the edit distance, is the minimal number
    of insertions, deletions, or substitutions needed to convert one string into another.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Jaccard Index
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Jaccard index can be used to quantify the similarity between sets of words
    or tokens and is commonly used in tasks such as document similarity or topic modeling.
    For example, the Jaccard index can be used to measure the overlap between the
    sets of words in two different documents or to identify the most similar topics
    across a collection of documents.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Similarity Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To put it simply, string similarity determines the degree to which two strings
    of text (or sequences of characters) are linked or similar to one another. Take,
    as an example, the following pair of sentences:'
  prefs: []
  type: TYPE_NORMAL
- en: “The cat sat on the mat.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “The cat was sitting on the rug.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although not identical, these statements share vocabulary and convey a connected
    sense. Methods based on string similarity analysis reveal and quantify the degree
    of similarity between such text pairings.
  prefs: []
  type: TYPE_NORMAL
- en: There is a *duality* between string *similarity* and *distance* measures, meaning
    that they can be used interchangeably [[1]](https://ealizadeh.com/blog/tutorial-string2string/#ref-suzgun2023string2string).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `similarly` module of the `string2string` library currently offers the
    following algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: Cosine similarity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BERTScore
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BARTScore
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jaro similarity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LCSubsequence similarity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s go over an example of the BERTScore similarity algorithm with the following
    four sentences:'
  prefs: []
  type: TYPE_NORMAL
- en: The bakery sells a variety of delicious pastries and bread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The park features a playground, walking trails, and picnic areas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The festival showcases independent movies from around the world.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A range of tasty bread and pastries are available at the bakery.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sentences 1 and 2 are similar semantically, as both are about bakery and pastry.
    Hence, we should expect a high similarity score between the two.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement the above example in the library.
  prefs: []
  type: TYPE_NORMAL
- en: We can visualize the similarity between every pair of sentences using the `plot_heatmap()`
    function provided in the library.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ef168487ec83656d65f641afb0973fdc.png)'
  prefs: []
  type: TYPE_IMG
- en: Semantic similarity (BERTScore) between sentences (Image by Author).
  prefs: []
  type: TYPE_NORMAL
- en: As can be seen above, sentences 1 and 4 are much more similar (using the BERTScore
    algorithm) as we expected.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `string2string` Python library is an open-source tool that provides a full
    set of efficient methods for string-to-string problems. In particular, the library
    has four main modules that address the following tasks: 1\. *pairwise alignment,*
    including both global and local alignments; 2\. *distance measurement*; 3\. *lexical
    and semantic search*; and 4\. *similarity analysis*. The library offers various
    algorithms in each category and provides helpful visualization tools.'
  prefs: []
  type: TYPE_NORMAL
- en: 📓 *You can find the notebook for this post on* [*GitHub*](https://github.com/e-alizadeh/data-science-blog/blob/master/notebooks/string2string-tutorial.ipynb)*.*
  prefs: []
  type: TYPE_NORMAL
- en: Thanks for reading! 📚
  prefs: []
  type: TYPE_NORMAL
- en: I’m a senior data scientist 📊 and engineer, writing about statistics, machine
    learning, Python, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 🌱 I also curate a weekly newsletter called [**AI Sprout**](https://aisprout.beehiiv.com/subscribe)
    where I provide hands-on reviews and analysis of the latest AI tools and innovations.
    [Subscribe](https://aisprout.beehiiv.com/subscribe) to explore emerging AI with
    me!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[*Follow me on Medium*](https://medium.com/@ealizadeh) *👋 to get my latest
    post*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Subscribe to* [*my mailing list*](https://ealizadeh.com/) *✉️ for updates
    right to your inbox*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Let’s connect on* [*LinkedIn*](https://www.linkedin.com/in/alizadehesmaeil/)
    *and* [*Twitter*](https://twitter.com/es_alizadeh) *🤝*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[](https://medium.ealizadeh.com/membership?source=post_page-----f9126b8474c5--------------------------------)
    [## Join Medium with my referral link - Esmaeil Alizadeh'
  prefs: []
  type: TYPE_NORMAL
- en: 📖 Read every story from Esmaeil Alizadeh (and thousands of other writers on
    Medium). Subscribe to Medium to get full…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.ealizadeh.com](https://medium.ealizadeh.com/membership?source=post_page-----f9126b8474c5--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[1] M. Suzgun, S. M. Shieber, and D. Jurafsky, “string2string: A modern python
    library for string-to-string algorithms,” 2023, Available: [http://arxiv.org/abs/2304.14395](http://arxiv.org/abs/2304.14395)'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] E. Alizadeh, “An Illustrative Introduction to Dynamic Time Warping,” 2020\.
    [https://ealizadeh.com/blog/introduction-to-dynamic-time-warping/](https://ealizadeh.com/blog/introduction-to-dynamic-time-warping/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[3] J. Johnson, M. Douze, and H. Jégou, “Billion-scale similarity search with
    GPUs,” *IEEE Transactions on Big Data*, vol. 7, no. 3, pp. 535–547, 2019.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Originally published at* [*https://ealizadeh.com*](https://ealizadeh.com/blog/tutorial-string2string/)*.*'
  prefs: []
  type: TYPE_NORMAL
