- en: Delta Lake — Automatic Schema Evolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/delta-lake-automatic-schema-evolution-11d32bd1aa99](https://towardsdatascience.com/delta-lake-automatic-schema-evolution-11d32bd1aa99)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens and what you can/can’t do when merging evolutive DataFrames
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@vitorf24?source=post_page-----11d32bd1aa99--------------------------------)[![Vitor
    Teixeira](../Images/db450ae1e572a49357c02e9ba3eb4f9d.png)](https://medium.com/@vitorf24?source=post_page-----11d32bd1aa99--------------------------------)[](https://towardsdatascience.com/?source=post_page-----11d32bd1aa99--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----11d32bd1aa99--------------------------------)
    [Vitor Teixeira](https://medium.com/@vitorf24?source=post_page-----11d32bd1aa99--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----11d32bd1aa99--------------------------------)
    ·5 min read·Mar 10, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1b8dfc96acde282413eda93c212cb337.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [McDobbie Hu](https://unsplash.com/@hjx518756?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: In the last post, we covered the transaction log and [how to keep Delta Tables
    fast and clean](https://medium.com/p/3c9d4f9e2f5e). This time we will be covering
    automatic schema evolution in Delta tables.
  prefs: []
  type: TYPE_NORMAL
- en: Schema evolution is a critical aspect of managing data over time. It is very
    common for data sources to evolve and adapt to new business requirements, which
    might mean adding or removing fields from an existing data schema. As a data consumer,
    it is imperative a quick and agile adaption to the new characteristics of the
    data sources and automatic schema evolution allows us to seamlessly adapt to these
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: In this post, we will cover automatic schema evolution in [Delta](https://delta.io/)
    while using the [people10m public dataset](https://learn.microsoft.com/en-us/azure/databricks/dbfs/databricks-datasets#create-a-table-based-on-a-databricks-dataset)
    that is available on Databricks Community Edition. We’ll test adding and removing
    fields in several scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Automatic schema evolution can be enabled in two ways, depending on our workload.
    If we are doing blind appends, all we need to do is to enable ***mergeSchema***
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: If we use a merge strategy for inserting data we need to enable ***spark.databricks.delta.schema.autoMerge.enabled***by
    setting it to ***true.***
  prefs: []
  type: TYPE_NORMAL
- en: In this post, we’ll be using merge so we’ll go with the latter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are all set so we can load our Delta Table which should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8839e62234f398505c236f99438d592c.png)'
  prefs: []
  type: TYPE_IMG
- en: Initial dataset
  prefs: []
  type: TYPE_NORMAL
- en: Evolving Schemas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To simulate evolving schemas we will be creating custom DataFrames using a hand-made
    schema and merging them using Scala’s [Delta API](https://docs.delta.io/latest/delta-update.html#upsert-into-a-table-using-merge).
  prefs: []
  type: TYPE_NORMAL
- en: 'Disclaimer: All the updates that we will be doing to the schema are just examples
    and are not meant to make much sense.'
  prefs: []
  type: TYPE_NORMAL
- en: Initial DataFrame schema
  prefs: []
  type: TYPE_NORMAL
- en: Simulating and merging new records
  prefs: []
  type: TYPE_NORMAL
- en: Adding a field
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say our company wants to be nickname friendly and people can be called
    by their favorite nicknames (how awesome!).
  prefs: []
  type: TYPE_NORMAL
- en: We’ll add a new field to our current schema called *nickName* and update Pennie’s
    nickName (id number 1).
  prefs: []
  type: TYPE_NORMAL
- en: Schema with nickName
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/76766b715befdb9bb7772984303adfaa.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding a new field
  prefs: []
  type: TYPE_NORMAL
- en: As we can see a new field as added and Pennie can now be called by her new favorite
    nickname! Notice how all the other records' value was automatically filled with
    null.
  prefs: []
  type: TYPE_NORMAL
- en: Removing a field
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the addition of nicknames, everyone started thinking about how no one uses
    their middle name so they decided to remove it.
  prefs: []
  type: TYPE_NORMAL
- en: Schema without middleName
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to update Quyen’s nickname as well but as a result of the source
    deleting the field, her middle name won’t be present. What should happen to the
    table?
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/36d9e751d84a3a69ffbd630467ba2335.png)'
  prefs: []
  type: TYPE_IMG
- en: Table after deleting middleName
  prefs: []
  type: TYPE_NORMAL
- en: If you guessed nothing, you were right. Every current target table record remains
    the same, only new records will have *middleName* as *null*.
  prefs: []
  type: TYPE_NORMAL
- en: To showcase this we’re going to insert a new id (0).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c5dd1de121806ddf7bc081c97bc07586.png)'
  prefs: []
  type: TYPE_IMG
- en: Table after inserting a new record
  prefs: []
  type: TYPE_NORMAL
- en: Renaming a column
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Renaming a column is the same as removing a column and adding another with a
    new name. If you wish to rename a column in place please refer to [Delta Column
    Name Mapping](https://docs.databricks.com/delta/delta-column-mapping.html#rename-a-column).
  prefs: []
  type: TYPE_NORMAL
- en: I won’t dig further into this topic as even though it is a schema evolution,
    it is not automatic. Have in mind that this feature is irreversible, once you
    turn it on you aren’t able to turn it off.
  prefs: []
  type: TYPE_NORMAL
- en: Changing a column type/order
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Changing a column type or column order is also not part of automatic schema
    evolution.
  prefs: []
  type: TYPE_NORMAL
- en: Adding/Removing a field in a struct
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s imagine that we have added an employee history struct that includes the
    *startDate* and *endDate* to track when the employee started and left the job.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b758f6669537daf41bfc7ae793dd3cb8.png)'
  prefs: []
  type: TYPE_IMG
- en: For a more complete history, we now wish to include the *title* in order to
    track the employee’s career in the company.
  prefs: []
  type: TYPE_NORMAL
- en: Updated struct with ‘title’
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/61777ff2afd04f1c474f7d9eb4b6502c.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, adding a field to a struct is also not an issue. If we try to
    remove the newly added field it will also work. Adding and removing fields inside
    a struct works the same way as if it is performed on the root.
  prefs: []
  type: TYPE_NORMAL
- en: Adding/Removing a field in an array of structs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we are getting more complex. In this case, we’ll be adding a new field
    to a struct that is inside an array. Imagine we now have an array of equipment
    that currently belongs to an employee:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1fd9959a1f975febf5e503df3c8b980b.png)'
  prefs: []
  type: TYPE_IMG
- en: To showcase the addition of a new field inside the array we’ll be adding a *serial_num*
    to the struct so that we can better track the equipment.
  prefs: []
  type: TYPE_NORMAL
- en: Updated struct inside array with ‘serial_num’
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/71e939fa1fa139c21dbe30d28157f5da.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, this also works as expected. The table schema is updated, new
    records have the respective *serial_num* and older records *serial_num* arefilled
    with *null* values.
  prefs: []
  type: TYPE_NORMAL
- en: If we remove the newly added field again it works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Adding/Removing a field in a map of structs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now it's time to test the same but inside a map. We have added a new column
    called *connections* that will be responsible for holding the hierarchy for each
    employee.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0080df5b27d737475f8c9ee7a4454e92.png)'
  prefs: []
  type: TYPE_IMG
- en: To simulate an update we’ll be adding a new column called *title* to the struct
    inside the *connections* column.
  prefs: []
  type: TYPE_NORMAL
- en: Updated struct inside map with ‘title’
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5ec4b487a79f3f62ed9847b708c14d18.png)'
  prefs: []
  type: TYPE_IMG
- en: This time, removing the field that returns an *AnalysisException* which means
    that MapType conversions are not well supported.
  prefs: []
  type: TYPE_NORMAL
- en: After a brief investigation, I found that it is due to [castIfNeeded](https://github.com/delta-io/delta/blob/master/core/src/main/scala/org/apache/spark/sql/delta/UpdateExpressionsSupport.scala#L53)
    function not supporting MapTypes yet. I have [opened a bug](https://github.com/delta-io/delta/issues/1641)
    and will try to work on a fix for this issue.
  prefs: []
  type: TYPE_NORMAL
- en: '**Edit:** [https://github.com/delta-io/delta/pull/1645](https://github.com/delta-io/delta/pull/1645)'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this article, we went through the addition and removal of fields in several
    different scenarios. We concluded that automatic schema evolution in Delta is
    very complete and supports most of the complex scenarios. By allowing these scenarios
    we can avoid having to manually intervene to update our schemas when data sources
    evolve. This is especially useful when consuming hundreds of data sources.
  prefs: []
  type: TYPE_NORMAL
- en: As a bonus, we also found a missing case that is not supported in MapTypes which
    is a great opportunity to give back to the community for such an awesome open-source
    project.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you liked the read! Make sure to tune in for more!
  prefs: []
  type: TYPE_NORMAL
