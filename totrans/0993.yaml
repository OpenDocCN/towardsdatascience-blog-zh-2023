- en: 'Google Foobar Challenge: Level 3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://towardsdatascience.com/google-foobar-challenge-level-3-f487fa3f204b](https://towardsdatascience.com/google-foobar-challenge-level-3-f487fa3f204b)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exploring binary numbers, dynamic programming, and Markov chains
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@katyhagerty19?source=post_page-----f487fa3f204b--------------------------------)[![Katy
    Hagerty](../Images/7a4471c602063df015a289c1c343ca4e.png)](https://medium.com/@katyhagerty19?source=post_page-----f487fa3f204b--------------------------------)[](https://towardsdatascience.com/?source=post_page-----f487fa3f204b--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----f487fa3f204b--------------------------------)
    [Katy Hagerty](https://medium.com/@katyhagerty19?source=post_page-----f487fa3f204b--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ¬∑Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----f487fa3f204b--------------------------------)
    ¬∑9 min read¬∑Nov 30, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a0ec52c11538eee31caf7d77a54e6431.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Rajeshwar Bachu](https://unsplash.com/@rajeshwerbatchu7?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: What is the Foobar Challenge? üßê
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Foobar Challenge is a coding challenge hosted by Google that can be completed
    in either Python or Java. I completed the challenge using Python. The challenge
    has its own server with specific, terminal-style commands. The problems are of
    various difficulty organized into 5 levels. Each question must be solved within
    a certain time limit. More time is given for the higher levels.
  prefs: []
  type: TYPE_NORMAL
- en: To read more about the Foobar Challenge, I recommend reading my previous article,
    which provides an overview and a break-down of the Level 1 problem.
  prefs: []
  type: TYPE_NORMAL
- en: '[](/google-foobar-challenge-level-1-3487bb252780?source=post_page-----f487fa3f204b--------------------------------)
    [## Google Foobar Challenge: Level 1'
  prefs: []
  type: TYPE_NORMAL
- en: An intro to the secretive coding challenge and a breakdown of the problems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/google-foobar-challenge-level-1-3487bb252780?source=post_page-----f487fa3f204b--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Level 3 is where it started to get serious. Levels 1 and 2 tested the basics
    and took about 15 minutes to solve. Level 3 tested problem-solving skills and
    required hours of research. Unlike the prior levels, I didn‚Äôt immediately know
    how to solve these problems. I had to read the questions a few times and work
    out test cases on paper. Also, I had to research and practice some new concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Research doesn‚Äôt mean Googling the problem name and looking at other people‚Äôs
    solutions. Instead, I tried to rephrase the question or search for phrases that
    seemed oddly specific to find relevant equations and models.
  prefs: []
  type: TYPE_NORMAL
- en: At first, I was little hesitant. Was Google tracking my search history? Would
    they consider this as cheating? However, as I progressed in the level, I realized
    *these problems were mostly likely intended to force to you to look at outside
    material*. I highly doubt Google expects developers to memorize Markov Chain formulas.
  prefs: []
  type: TYPE_NORMAL
- en: As you work through the problems, I encourage you research unfamiliar concepts
    especially if your solution becomes long and unstructured. These problems were
    designed to have elegant solutions. ***If you can‚Äôt think of an elegant way to
    solve the problem, that‚Äôs a clue that there is probably a formula or method that
    will simplify it****.* Remember, part of coding is researching the best methods.
  prefs: []
  type: TYPE_NORMAL
- en: Questions & Concepts üìö
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Warning ‚Äî Spoilers Ahead ‚õîÔ∏è
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Below, I break down the questions and explain my thought process. I also provide
    solutions. However, ***I highly recommend you attempt the problem first***. The
    best part of the challenge is the surprise and satisfaction of solving an elusive
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: I debated not posting solutions and just explaining the underlying concepts.
    However, part of coding is learning how to troubleshoot and pinpointing where
    the code fails. Thus, I decided to post solutions so that if you‚Äôre stuck, you
    can see exactly where your logic diverges.
  prefs: []
  type: TYPE_NORMAL
- en: 'Level 3: Problem 1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Out of all the problems in Level 3, this was the hardest for me. I worked through
    a lot of examples on paper. The requirement to handle a 309 digit-long number
    seemed like a hint to try to solve this using binary numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The objective of the problem is to reach one pellet with the fewest actions.
    The most efficient action is halving the pellets because then, `n` will decay
    exponentially.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0105e2e38189cfdc0617a7e1d51cf47f.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: However, perfect exponential decay only works if `n` is a power of 2\. If not,
    eventually `n` will reduce to an odd number and cannot be halved. In those cases,
    is it better to add 1 or subtract 1? The best action is whichever one results
    in a number that can be halved the most. Luckily, the binary form provides that
    information. The number of trailing zeros in a binary number is how many times
    a number can be divided by 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider `n = 15` as shown below. The two series illustrate the
    two options for the first action: adding 1 (`n = 16`) and subtracting 1 (`n =
    14`). Even though 14 is closer to the desired final state of 1, 16 is the better
    option because it can be halved more. As you can see on the right graph, the number
    of trailing zeros in the binary form corresponds to how many times a number can
    be halved.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2af017fb2627430f0c3bd19d75f99eb2.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: To solve the problem, I first converted the input string (`n`) to binary (`b`)
    using the built-in `bin` function. I used a while loop to reduce to `b` until
    it reached 1\. If `b` is even, I halve it by removing a trailing zero. Halving
    `b` as much as possible will minimize the total number of actions. If `b` is odd,
    I choose the nearest neighboring integer with the most trailing zeros.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, the quantity of trailing zeros indicates the how many times a
    given number is divisible by two. Numbers with more trailing zeros are prioritized
    because they allow more halving. In other words, the number with the most trailing
    zeros provides the most the efficient way to 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Level 3: Problem 2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin, I worked through lots of practices problems on paper. In doing so,
    I realized the solutions to bigger staircases consisted of solutions to smaller
    staircases. Solving for `n` involves first solving for the smaller staircase sub-problems
    making this a dynamic programming problem.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0f0cca9d56a7e675558c601a695cc62d.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: I really struggled with cumulative nature of this problem. While I understood
    how smaller staircases contributed to larger ones, I couldn‚Äôt figure out how to
    account for the two step staircases. For example, when `n = 7`, I saw how `n =
    3` was part of the solution, but I didn‚Äôt know how to account for other two-step
    staircases.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/45e7af3ae94805b0eaeb3180cd373dfa.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise, I simplified the problem and just tried to find how many staircases
    existed for a given height and `n`. In other words, I took the graphic above and
    put in table form.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/515b54d8c1fc066cdcfd53378cc8e4c1.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: As I filled out the table, I figured out the algorithm. For each cell, I subtracted
    the staircase height from `n`. Then, I took the remainder and visited that column
    (`n = remainder`). The sum of that column equals the number of solutions. In some
    cases, the remainder was enough to build 1 step. To account for those cases, I
    added 1 along the diagonal. See the green numbers in the left figure below.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/42ce530ed34c458fd1a99d200d2c90a0.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, when `n = 8` and `staircase height = 5`, the remainder is `n =
    3`. The 3 column contains two solutions: `staircase height = 3` and `staircase
    height = 2`. Thus, for `n = 8` with `staircase height = 5`, there are two solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: This method works, but it could be more efficient. Instead of visiting each
    cell in a column, the table could be structured so that rows represented the max
    staircase height. For instance, `max staircase height = 3` would be the sum of
    the solutions for heights 1, 2, and 3 for a given `n`. The purple numbers below
    represent this cumulative approach. Now, finding the solution involves visiting
    just one cell.
  prefs: []
  type: TYPE_NORMAL
- en: Note how the figure below includes a `n=0` column. This way, the column index
    number equals the `n` value. This small change drastically simplifies the code.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/fd221f092f44bca4d1be18bc0ded154e.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: 'Level 3: Problem 3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading the problem, a couple of phrases jumped out at me. I searched
    for terms like ‚Äúfixed probability state‚Äù and ‚Äúprobability state transitions‚Äù and
    eventually came across Markov chains. Since there is guaranteed a path from each
    state to a terminal state, this is an absorbing Markov chain. A terminal state,
    also referred to as an absorbing state, means it is impossible to leave that state
    (i.e. zero probability of going to another state).
  prefs: []
  type: TYPE_NORMAL
- en: I never heard of Markov chains so before I started coding, I did my research.
    [Here](https://brilliant.org/wiki/absorbing-markov-chains/) is a great overview
    of Markov chains.
  prefs: []
  type: TYPE_NORMAL
- en: 'The transition matrix, *P*, for an absorbing Markov chain with *t* transition
    states and *s* absorbing states is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a38ebf16ef400dd9ed2787c850fdc916.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: 'The transition matrix can then be used to find the fundamental matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b229b7b942d99f1c3f5bfa83eda8558f.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fundamental matrix provides lots of information. But in order to solve
    the problem, one more matrix must be calculated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d8b1b0812169ed07620b7662db4f274d.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: In *M*, the rows represent starting states and the columns represent absorbing
    states. The value at *M[i][j]* is the probability of being absorbed by terminal
    state *j* if starting at transition state *i*. Thus, the number of rows in *M*
    will be determined by the number of transition states and the number of columns
    equals the number of terminal states.
  prefs: []
  type: TYPE_NORMAL
- en: First, I had to find the number and locations of the transition and absorbing
    states. Then, for the transition states, I had to convert the integers to fractions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the following input:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3c703b0b5bff4f9aa3c96c8dc7c76cc3.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code above transforms it to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4a765d1b4858a8fb6fc92165a05f90cb.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: Next, I need to calculate the *I* and *Q* matricesto solve for *N*. Since I
    couldn‚Äôt use libraries, I brushed up on matrix operations like [dot product](/dot-product-in-linear-algebra-for-data-science-using-python-f113fb60c8f)
    and [matrix inversion](https://integratedmlai.com/matrixinverse/).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/fa070364d577140a895d5f3a8d44619d.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: Now, I need to solve for *R.*
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/34c10516690a9288a4a65c325cfa378d.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: Now that both *R* and *N* are solved, I can calculate the probability matrix,
    *M.*
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/fcf1e5ae6ac0db4558656fc9c38631ae.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: Now, *M* must be formatted to match output specifications. Only the first row
    is needed since the question only asks for the probabilities when starting from
    state 0\. As you can see above, *M* is in fractions. To format the answer as an
    array of integers representing the numerators of the probabilities, I needed to
    find the least common multiple. The LCM will be the common denominator among the
    probabilities.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e4adc6f0c1648ecb3f9eb6464c896f8c.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: The trickiest part of this problem ended up being the fractions and relearning
    matrix operations. Like I mentioned in my Level 1 article, this challenge is very
    specific about what type of outputs it will accept.
  prefs: []
  type: TYPE_NORMAL
- en: Here‚Äôs the solution in full.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the end of the level, I was given the option to submit my contact info for
    a Google recruiter. However, that was over a year ago, and Google has yet to reach
    out.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, I felt these problems were designed to test more than just basic coding
    skills. Solving these types of problems proves you can develop solutions despite
    tricky edges cases and memory constraints. Ironically, I found the problems to
    get easier as the level progressed. However, with each new problem, I also started
    to *work* *smarter, not harder.* I reread the problem. I paused and drew out some
    examples on paper rather than immediately start coding the first thing that came
    to mind. And, most importantly, I used existing resources to learn new concepts
    and brush up on old ones.
  prefs: []
  type: TYPE_NORMAL
- en: '[![](../Images/03ef44469698c6bbba9be1e11d44ee17.png)](http://buymeacoffee.com/katyhagerty)'
  prefs: []
  type: TYPE_NORMAL
- en: '*Thank you for reading my article. If you like my content, follow me on* [*Medium*](https://medium.com/@katyhagerty19)*.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Connect with me on* [*LinkedIn*](https://www.linkedin.com/in/katherine-katy-hagerty/)*,*
    [*Twitter*](https://twitter.com/HagertyKaty)*, or* [*Instagram*](https://www.instagram.com/katyhagerty/)*.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*All feedback is welcome. I am always eager to learn new or better ways of
    doing things.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Feel free to leave a comment or reach out to me at katyhagerty19@gmail.com.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
