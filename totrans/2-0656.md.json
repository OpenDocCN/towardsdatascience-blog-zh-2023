["```py\nimport missingno as msno\nimport sweetviz as sv\nfrom pandas_dq import dq_report\n\n# completeness check\nmsno.matrix(df)\n\n# data profiling\nReport = sv.analyze(df)\n\nReport.show_notebook()\n```", "```py\n# check for missing values\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\ndef plot_missing_values(df: pd.DataFrame, \n                        title=\"Missing Values Plot\"):\n    plt.figure(figsize=(10, 6))\n\n    sns.displot(\n        data=df.isna().melt(value_name=\"missing\"),\n        y=\"variable\",\n        hue=\"missing\",\n        multiple=\"fill\",\n        aspect=1.25\n    )\n    plt.title(title)\n    plt.show()\n\nplot_missing_values(df)\n```", "```py\n# verify integrity check\ndf_loans = pd.concat([df, df_pdf], verify_integrity=True)\n\n# check duplicated ids\ndf_loans[df_loans.duplicated(keep=False)].sort_index()\n```", "```py\ndef check_duplicates(df, col):\n    '''\n    Check how many duplicates are in col.\n    '''\n    # first step set index\n    df_check = df.set_index(col)\n    count = df_check.index.duplicated().sum()\n    del df_check\n    print(\"There are {} duplicates in {}\".format(count, col))\n```", "```py\n# data validation on the data dictionary\nfrom pydantic import BaseModel, Field, conint, condecimal, constr\n\nclass LoanApplication(BaseModel):\n    Loan_ID: int\n    Gender: conint(ge=1, le=2)\n    Married: conint(ge=0, le=1)\n    Dependents: conint(ge=0, le=3)\n    Graduate: conint(ge=0, le=1)\n    Self_Employed: conint(ge=0, le=1)\n    ApplicantIncome: condecimal(ge=0)\n    CoapplicantIncome: condecimal(ge=0)\n    LoanAmount: condecimal(ge=0)\n    Loan_Amount_Term: condecimal(ge=0)\n    Credit_History: conint(ge=0, le=1)\n    Property_Area: conint(ge=1, le=3)\n    Loan_Status: constr(regex=\"^[YN]$\")\n\n# Sample loan application data\nloan_application_data = {\n    \"Loan_ID\": 123456,\n    \"Gender\": 1,\n    \"Married\": 1,\n    \"Dependents\": 2,\n    \"Graduate\": 1,\n    \"Self_Employed\": 0,\n    \"ApplicantIncome\": 5000,\n    \"CoapplicantIncome\": 2000,\n    \"LoanAmount\": 100000,\n    \"Loan_Amount_Term\": 360,\n    \"Credit_History\": 1,\n    \"Property_Area\": 2,\n    \"Loan_Status\": \"Y\"\n}\n\n# Validate the data using the LoanApplication Pydantic model\nloan_application = LoanApplication(**loan_application_data)\n```", "```py\n# data validation on the data dictionary\nfrom pydantic import ValidationError\nfrom typing import List\n\n# Function to validate DataFrame and return a list of failed LoanApplication objects\ndef validate_loan_applications(df: pd.DataFrame) -> List[LoanApplication]:\n    failed_applications = []\n\n    for index, row in df.iterrows():\n        row_dict = row.to_dict()\n\n        try:\n            loan_application = LoanApplication(**row_dict)\n        except ValidationError as e:\n            print(f\"Validation failed for row {index}: {e}\")\n            failed_applications.append(row_dict)\n\n    return failed_applications\n\n# Validate the entire DataFrame\nfailed_applications = validate_loan_applications(df_loans.reset_index())\n\n# Print the failed loan applications or \"No data quality issues\" \nif not failed_applications:\n    print(\"No data validation issues\")\nelse:\n    for application in failed_applications:\n        print(f\"Failed application: {application}\")\n```", "```py\nfrom pandas_dq import DataSchemaChecker\n\nschema = {\n    'Loan_ID': 'int64',\n    'Gender': 'int64',\n    'Married': 'int64',\n    'Dependents': 'int64',\n    'Graduate': 'int64',\n    'Self_Employed': 'int64',\n    'ApplicantIncome': 'float64',\n    'CoapplicantIncome': 'float64',\n    'LoanAmount': 'float64',\n    'Loan_Amount_Term': 'float64',\n    'Credit_History': 'int64',\n    'Property_Area': 'int64',\n    'Loan_Status': 'object'\n}\n\nchecker = DataSchemaChecker(schema)\n\nchecker.fit(df_loans.reset_index())\n```", "```py\n# fix issues\ndf_fixed = checker.transform(df_loans.reset_index())\n```", "```py\nfrom pandas_dq import dq_report\n\ndq_report(df_loans.reset_index(), target=None, verbose=1)\n```"]