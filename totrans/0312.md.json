["```py\nimport geopandas as gpd\nimport pandas as pd\n\n# Import data from csv\ndata = pd.read_csv(\"https://data.urbansharing.com/oslobysykkel.no/trips/v1/2023/10.csv\")\ndata = data[['started_at','ended_at','duration', 'start_station_latitude', 'start_station_longitude','end_station_latitude', 'end_station_longitude']]\n# Subset the data to only one day\ndata['start_day'] = data['started_at'].apply(lambda x: int(x[8:11]))\ndata = data[data[\"start_day\"]==day]\ndata\n```", "```py\nimport osmnx as ox\n# Create a GeoDataFrame from the stations\ninitial_data = gpd.GeoDataFrame(data, geometry=gpd.points_from_xy(data['start_station_longitude'],data['start_station_latitude']),crs=\"EPSG:4326\")\n# Get the total bounds\ntotal_bounds = initial_data.total_bounds\n# Create a list for the polygon\nbounding_box = [[total_bounds[0],total_bounds[3]], [total_bounds[0],total_bounds[1]], [total_bounds[2],total_bounds[1]], [total_bounds[2],total_bounds[3]]]\n# Create the polygon\nbounding_box_polygon = Polygon(bounding_box)\n# Buffer the polygon to include roads just outside of the stations\ngraph_extent = bounding_box_polygon.buffer(0.02)\n# Create the graph\narea_graph = ox.graph_from_polygon(graph_extent, network_type='bike')\nnodes, edges = ox.graph_to_gdfs(area_graph)\n```", "```py\nimport networkx as nx\nfrom shapely import ops\n\ndef calculate_shortest_path(start_point,end_point, graph):\n    # Find the nearest node to the start and end points\n    start_node = ox.distance.nearest_nodes(graph, X=start_point.x, Y=start_point.y)\n    end_node = ox.distance.nearest_nodes(graph, X=end_point.x, Y=end_point.y)\n\n    # Calculate the shortest path\n    path = nx.dijkstra_path(graph, source=start_node, target=end_node, weight='length')\n\n    # Convert the network path to a LineString\n    geoms = [edges.loc[(u, v, 0), 'geometry'] for u, v in zip(path[:-1], path[1:])]\n    route_lineString = MultiLineString(geoms)\n    route_lineString = ops.linemerge(route_lineString)\n    return route_lineString\n```", "```py\ndata['start_point'] = data.apply(lambda row: Point(row['start_station_longitude'],row['start_station_latitude']), axis=1)\ndata['end_point'] = data.apply(lambda row: Point(row['end_station_longitude'],row['end_station_latitude']), axis=1)\ndata['shortest_path'] = data.apply(lambda row: calculate_shortest_path(row['start_point'],row['end_point'],area_graph), axis=1)\nprint(data.head())\n```", "```py\nfrom datetime import datetime\ndata['started_at'] = data['started_at'].apply(lambda x: datetime.strptime(x[0:19], \"%Y-%m-%d %H:%M:%S\"))\ndata['ended_at'] = data['ended_at'].apply(lambda x: datetime.strptime(x[0:19], \"%Y-%m-%d %H:%M:%S\"))\n```", "```py\ndef line_to_points(df):\n# Create a dataframe for our points\n point_df = pd.DataFrame(columns=['x','y','time','dateminute','size'])\n# Iterate over the line data\n for idx, line in df.iterrows():\n  start_x = line['shortest_path'].coords.xy[0][0]\n  start_y = line['shortest_path'].coords.xy[1][0]\n  # Create number of sections based on duration of trip\n  delta = line['ended_at']-line['started_at']\n  sections = line['duration']/15\n  time_gap = delta/sections\n  # Create initial point\n  point_time = line['started_at']\n  size = 10\n  # Create timestamp\n  dateminute = int(str(line['started_at'].year)+str(line['started_at'].month).zfill(2)+str(line['started_at'].day).zfill(2)+str(line['started_at'].hour).zfill(2)+str(line['started_at'].minute).zfill(2))\n  append_list = [start_x,start_y,point_time.strftime(\"%Y-%m-%d %H:%M:%S\"),dateminute,size]\n  point_series = pd.Series(append_list,index=point_df.columns)\n  point_df = point_df.append(point_series, ignore_index=True)\n  # Iterate over rest of the sections, size relative to time\n  i = 1\n  while i <=sections:\n   size = 50\n   point_time += time_gap\n   this_section = i/sections\n   new_point = line['shortest_path'].interpolate(this_section, normalized=True)\n   dateminute = int(str(point_time.year)+str(point_time.month).zfill(2)+str(point_time.day).zfill(2)+str(point_time.hour).zfill(2)+str(point_time.minute).zfill(2))\n   if i == (sections-1):\n    size = 30\n   if i == 1:\n    size = 30\n   if i == (sections):\n    size = 10\n   point_series = pd.Series([new_point.x,new_point.y,point_time.strftime(\"%Y-%m-%d %H:%M:%S\"),dateminute,size],index=point_df.columns)\n   point_df = point_df.append(point_series, ignore_index=True)\n   i+=1\n return point_df\n```", "```py\n# Create a GeoDataFrame from the paths\npaths_gdf = gpd.GeoDataFrame(data, geometry='shortest_path', crs=\"EPSG:4326\")\npaths_gdf = paths_gdf[~paths_gdf.is_empty] \nresult = line_to_points(paths_gdf)\n```", "```py\n# Create geodataframe\ngdf = gpd.GeoDataFrame(result, geometry=gpd.points_from_xy(result['x'], result['y']))\ngdf['size'] = gdf['size'].astype(float)\ngdf.crs = \"EPSG:4326\"\ngdf = gdf.to_crs(epsg=4326)\n# Get list of timestamps\ntimes = list(gdf['dateminute'].unique())\ntimes.sort()\n```", "```py\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport contextily as ctx\n\ndef plot_minute(minute):\n  # Set up the plot parameter\n  matplotlib.rcParams.update({'font.size': 16})\n  fig, ax = plt.subplots(ncols = 1, figsize=(32,20))\n  # Plot all rows before the current minute\n  old_minutes = gdf[gdf['dateminute'] < minute]\n  old_minutes.to_crs(epsg=4326).plot(ax=ax, color='#1DA1F2',markersize=5, edgecolor=None, linewidth=0, alpha=0.4) # 2 - Projected plot\n  # Select and plot the current minute\n  minute_gdf = gdf[gdf['dateminute'] == minute]\n  minute_gdf.to_crs(epsg=4326).plot(ax=ax, color='#1DA1F2',markersize=minute_gdf['size'], edgecolor=None, linewidth=0.3, alpha=0.8) # 2 - Projected plot\n  # Set common boundaries for the plot\n  xlim = ([stations_gdf.total_bounds[0],  stations_gdf.total_bounds[2]])\n  ylim = ([stations_gdf.total_bounds[1],  stations_gdf.total_bounds[3]])\n  ax.set_xlim(xlim)\n  ax.set_ylim(ylim)\n  # Set time variables\n  mi = str(minute)[-2:]\n  h = str(minute)[-4:-2]\n  #d = str(minute)[-4:-2]\n  m = str(minute)[4:6]\n  y = str(minute)[:4]\n  # Add a basemap\n  ctx.add_basemap(ax,crs=minute_gdf.crs.to_string(), source=ctx.providers.CartoDB.DarkMatter)\n  ax.set_axis_off()\n  # Create text\n  ax.text(.5,.9,f'{h}:{mi} - {day}/{m}/{y}',\n        horizontalalignment='center',color='white',\n        transform=ax.transAxes,size=18)\n  plt.tight_layout()\n  # Save plot to file\n  plt.savefig(f'animation/{minute}.png',transparent=True, dpi=100)\n  plt.close()\n```", "```py\nfor timestamp in times:\n  plot_minute(timestamp)\n```", "```py\nconvert -resize 20% -delay 5 -loop 0 animation/*.png animation.gif\n```"]