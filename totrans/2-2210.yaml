- en: Unleashing the Power of the Julia SuperType
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/unleashing-the-power-of-the-julia-supertype-bb369209efca](https://towardsdatascience.com/unleashing-the-power-of-the-julia-supertype-bb369209efca)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Using and working with abstraction to do interesting things with the Julia language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://emmaccode.medium.com/?source=post_page-----bb369209efca--------------------------------)[![Emma
    Boudreau](../Images/f7201d012b733643d6e97957f73fd1fa.png)](https://emmaccode.medium.com/?source=post_page-----bb369209efca--------------------------------)[](https://towardsdatascience.com/?source=post_page-----bb369209efca--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----bb369209efca--------------------------------)
    [Emma Boudreau](https://emmaccode.medium.com/?source=post_page-----bb369209efca--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----bb369209efca--------------------------------)
    ·7 min read·Oct 11, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/709919bb56394b82ea33ff5474146f8f.png)'
  prefs: []
  type: TYPE_IMG
- en: image by author
  prefs: []
  type: TYPE_NORMAL
- en: introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the things I find fascinating about the exploration of different programming
    languages is the way that different paradigms solve different types of problems.
    In programming, there are a number of features that might be expected from a modern
    programming language. Some examples of these features include things like scope,
    polymorphism, and abstraction. Some paradigms are going to have more prominent
    applications in certain fields, and Data Science is no exception. These features
    are all implemented across the spectrum of programming paradigms using a multitude
    of different approaches. This subject becomes even more interesting to me whenever
    a language with a paradigm that is atypical implements these types of generic
    programming concepts. This brings us to the Julia programming language.
  prefs: []
  type: TYPE_NORMAL
- en: The Julia programming language is one of the more interesting developments that
    has come to the world of programming in recent years. The world of programming
    is quite used to a few choice paradigms that have been honed over the decades
    to create some very formidable ideological approaches to solving programming problems.
    While Julia pulls a lot of more generic programming concepts to get the job done,
    the language’s paradigm itself is incredibly unique and often brings about a different
    way of doing things. This has been coined the Multiple Dispatch programming paradigm.
    This paradigm is a very effective programming paradigm when it comes to doing
    exactly what Data Scientists do.
  prefs: []
  type: TYPE_NORMAL
- en: With this type of programming paradigm relationship, Julia changes its gears
    a bit to accomplish a lot of the more generic programming concepts that most programmers
    are going to want to use. There are a multitude of capacities where this plays
    out all across Julia. All of these concepts feed back into the robust capabilities
    of the multiple dispatch paradigm. For experienced programmers, I find this can
    be an incredibly powerful paradigm! That being said, with any paradigm it is important
    to know what tools are available to take advantage of. One example of a technique
    that fits very well into the Julian paradigm is the Julian implementation of abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction is going to be an essential technique when it comes to Data Science.
    In Data Science, observations can be of many different types and something like
    polymorphism might be very effective considering that this draws some commonality
    between the way different structures might be worked with.
  prefs: []
  type: TYPE_NORMAL
- en: As one might expect, Julian abstraction is implemented using multiple dispatch.
    However, there are some nuances to using multiple dispatch in this way and these
    are important to take note of, so without further ado let’s review the ins and
    outs of abstraction in Julia!
  prefs: []
  type: TYPE_NORMAL
- en: Super-type basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to get started creating our own super-types, we are going to want to
    get familiar with the `abstract type` syntax. An `abstract type` is a loosely
    defined type which exists only in name — containing no fields. Using different
    organizations of these names, we can apply methods to restricted levels of our
    type hierarchy. A great example of this would be numbers.
  prefs: []
  type: TYPE_NORMAL
- en: In Julia, numbers are organized based on a few different pragmatic categories.
    The resulting structure, which organizes different types of numbers hierarchically,
    is called a type heirarchy. In Julia, this type hierarchy will always begin with
    `Any` . `Any` is an abstract type that **every** type in Julia is a sub-type of.
    The number portion of this heirarchy begins below this with `Number` , before
    moving onto `Real` numbers — furthered with `Integers` and the works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f6c2fce8bf47d30c6a98865d59724af8.png)'
  prefs: []
  type: TYPE_IMG
- en: (image by author)
  prefs: []
  type: TYPE_NORMAL
- en: '[](/julia-and-imaginary-numbers-the-numerical-hierarchy-694aef87a7ce?source=post_page-----bb369209efca--------------------------------)
    [## Julia And Imaginary Numbers: The Numerical Hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: A deep dive into how Julia handles numbers.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/julia-and-imaginary-numbers-the-numerical-hierarchy-694aef87a7ce?source=post_page-----bb369209efca--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Our main tool to interact with the abstraction inside of Julia is the sub-type
    operator, `<:` . This is a bitwise boolean operator, meaning that it returns either
    true or false depending on two operands; bitwise meaning two operands, as opposed
    to unary, and boolean denoting the true/false nature of the return. This condition
    will be true if the first operand is a sub-type of the second operand. The first
    operand in this instance will be a `Type` or an abstract type. The second operand
    will always be an abstract type — given that things can only be a sub-type of
    an abstract type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This operator is also used in two other instances. One of these is multiple
    dispatch and the other is assigning a type as a sub-type. The latter may be done
    for a super-type or a regular type. This is done by providing the sub-type operator
    after its definition followed by the type we want it below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Super-type dispatch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating these type of hierarchies is great, but even better is utilizing them
    with multiple dispatch. Using multiple dispatch, we can dispatch to the exact
    level we want, allowing for the creation of functions that encompass only specific
    categories. In the following case, any `Float` or `Integer` will be handled differently
    within this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Likewise, if the functionality of these functions were the same we could go
    up a level and dispatch `Real` , then creating one function. This is a really
    simple implementation that gets the job done perfectly.
  prefs: []
  type: TYPE_NORMAL
- en: 'One nuance to using dispatch in this context is dispatch sub-types as parameters.
    For example, in some cases we might have an argument that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we wanted for any `Vector` that has numbers in it to be dispatched
    to this function. However, this is not the function we have wrote — instead we
    have dispatched a `Vector{Number}` …
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The solution here is a little obscure — we dispatch the parameter in this weird
    way with the sub-type operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Oddly, this is a unary usage of this operator — it certainly is strange, but
    it gets the job done and does make sense logically in other ways. This is certainly
    a nuance to take note of, however.
  prefs: []
  type: TYPE_NORMAL
- en: Fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Something that should also be part of the conversation when it comes to abstraction
    in Julia is fields. In short, Julia would prefer that abstract types are never
    used for fields. The reason for this is that Julia takes a severe performance
    hit when a field of a type can be of several different types. This can also be
    a really bad practice for multiple dispatch. It is probably better to utilize
    generic function constructors rather than use a generic structure. For example,
    the following structure is probably a bad idea.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this case, both `Real` and `AbstractString` are ambiguous field types. We
    can easily fix this by either deciding a better field or field type or using a
    parameter to denote the type. Whenever we use a parameter, we create a new type
    for every different setting that parameter could be. In other words, `Calculator{Float64}`
    is a distinct type from `Calculator{Int64}` , and the `x` field on both of these
    will always be the type of that parameter. To reorganize this, we add a parameter
    to the constructor and change the field to the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can also sub-type this parameter, making it more explicit what we are expecting
    this field to be.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As for the case of `y` , this might be an example of where it is better to simply
    use a different type. In most cases, an `AbstractString` would be better as a
    simple `String` .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In order for someone to construct this `Calculator` , they will now need to
    provide this parameter. We can change this by creating a new dispatch using an
    inner constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Super-type introspection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final thing I would like to point out in this overview of super-types is
    the ability to introspect super-types. Though certainly not as useful as many
    other forms of introspection in Julia, this certainly can come in handy — especially
    when it comes to figuring some things out. The most obvious form of this introspection
    was touched on earlier, and this is the ability to discern whether or not a type
    is a sub-type of an abstract type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, Julia also does not offer a lot of options beyond this. One other
    thing you might do that could be valuable is to get a nice printout of this heirarchy
    for a specific type. Here is a pretty nice function that has circulated the Julia
    community to do so
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: I believe the original source for this particular rendition goes to [tk3369](https://github.com/tk3369)
    on github.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Abstraction is an incredibly important tool for modern high-level programming
    languages. Creating the same function in multiple places is tedious, and programmers
    have caught onto this. A lot of languages have drastically different paradigms,
    and as a result the techniques used to achieve these programming concepts can
    be very interesting. One example where this is fervently the case is in that of
    the Julia language and its type hierarchies.
  prefs: []
  type: TYPE_NORMAL
- en: While Julia’s approach to this problem is a little unusual, it makes up for
    this abnormality by being incredibly powerful. Using this form of abstraction,
    we can get as specific as the exact type of each parameters or as ambiguous as
    allowing `Any` to pass through our methods. Overall, it is certainly very powerful
    and worth knowing. Thank you for reading!
  prefs: []
  type: TYPE_NORMAL
