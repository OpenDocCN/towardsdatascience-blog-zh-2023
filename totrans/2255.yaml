- en: Use the Partitions, Luke! A Simple and Proven Way to Optimise Your SQL Queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/use-the-partitions-luke-a-simple-and-proven-way-to-optimise-your-sql-queries-43e24ea4c5d0](https://towardsdatascience.com/use-the-partitions-luke-a-simple-and-proven-way-to-optimise-your-sql-queries-43e24ea4c5d0)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you’ve ever written an SQL query that takes ages to run, this is the article
    for you
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@mattchapmanmsc?source=post_page-----43e24ea4c5d0--------------------------------)[![Matt
    Chapman](../Images/7511deb8d9ed408ece21031f6614c532.png)](https://medium.com/@mattchapmanmsc?source=post_page-----43e24ea4c5d0--------------------------------)[](https://towardsdatascience.com/?source=post_page-----43e24ea4c5d0--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----43e24ea4c5d0--------------------------------)
    [Matt Chapman](https://medium.com/@mattchapmanmsc?source=post_page-----43e24ea4c5d0--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----43e24ea4c5d0--------------------------------)
    ·8 min read·Dec 7, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/caa41d8a1a68733fba112f4270c57c15.png)'
  prefs: []
  type: TYPE_IMG
- en: Baby Yoda loves partitions. Do you? Image by [Victor Serban](https://unsplash.com/@victorserban)
    on [Unsplash](https://unsplash.com/photos/green-frog-plush-toy-on-brown-textile-ZFN6UNWhstI)
  prefs: []
  type: TYPE_NORMAL
- en: Data Scientists love SQL, but boy do we suck at writing performant queries (maybe
    because we spent too much time debating whether it’s pronounced “S-Q-L” or “sequel”?).
  prefs: []
  type: TYPE_NORMAL
- en: In this article, I’m going to show you how to use ***SQL partitions*** to optimise
    your queries and write code that’s quicker and cheaper to run. If you’ve mastered
    the basics of SQL and want to start unlocking higher-level Data Science skills,
    this will be a great addition to your toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: What’s a partitioned table?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A partitioned table is a table that’s divided into segments/partitions (who
    saw that coming?).
  prefs: []
  type: TYPE_NORMAL
- en: In a partitioned table, each segment is stored in a different location on the
    server. This is different from a normal (unpartitioned) SQL table, where the entire
    table sits in a single location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a comparison using dummy data about the daily sales of three of my favourite
    books:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c80814445de2097c783f0c0e84481128.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Both the unpartitioned and the partitioned table hold the same data; the only
    difference is that the partitioned table splits the data into different segments.
    It’s still a single table (i.e. it’s not three separate tables); it’s just storing
    the data in a different way.
  prefs: []
  type: TYPE_NORMAL
- en: Why should we care? Well, as we’ll see shortly, we can take advantage of this
    structure to write more efficient SQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: Creating partitioned tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a partitioned table is easy as pie.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we’d use the following code to create a normal (unpartitioned)
    table…
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '… we can create a partitioned version by adding a single line at the end of
    the `CREATE TABLE` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The column on which were are partitioning is known as the **partitioning key**;
    in this case, we’re partitioning on the `date` column, but any column is fine
    as long as it’s either (1) a date/timestamp field or (2) an integer field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we’ve created these two tables, we’ll see that they look identical at
    first glance (e.g., if you run `SELECT *` against each table, the results will
    look the same). If however we look at the tables’ details/metadata, we’ll see
    that the partitioned table includes some extra metadata. Here’s what this looks
    like in BigQuery (the place I’m running my SQL):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ded7525c32680d28219a206fc6adbfd0.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Why does this matter? Because using partitions reduces the amount of data required
    to process your query
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: And this is great news, because it means that partitions can help you write
    more efficient queries!
  prefs: []
  type: TYPE_NORMAL
- en: When you query a normal (unpartitioned) table, the SQL engine typically has
    to scan the entire table in order to find the rows you want. On large tables,
    this can be unnecessarily slow and expensive, as your machine needs to process
    data which are not useful for creating the final output.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s query the unpartitioned table we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/0904eee688705792f43d47a6ea8448d8.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: In the image above, you can see that **all 9 rows of the table** were read in
    order to return the 6 rows with dates greater than ‘2023–12–01’.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s run the same query against our partitioned table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/0c8375b3ff38b786b5a1db0fb15a0c72.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: This time, we see that **only 6 rows of the unpartitioned table were read**
    in order to generate the same results. Before executing the main part of the query,
    BigQuery was able to identify the partitions which contained the relevant rows
    and pull selectively from them. It simply didn’t need to read the 3 rows in the
    other partition.
  prefs: []
  type: TYPE_NORMAL
- en: This preliminary step of selecting partitions is known as ***pruning****.* It’s
    much more efficient than normal queries because it means that the SQL engine won’t
    have to read every single row in the table; it will first fetch the partitions
    required, and only then will it execute your query. In fancy SQL lingo, the filter
    we add on the partitioning column is treated as an ***access predicate*** by the
    SQL engine and gets run before executing the main query.
  prefs: []
  type: TYPE_NORMAL
- en: — Quick interlude —
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’re enjoying this article, you might like my site [the-sql-gym.com](https://the-sql-gym.com),
    which contains over 100 practice SQL questions. If you want to boost your SQL
    skills, check it out! And let me know if you have any feedback :-)
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2eecfbe5e0a0711641021e07d3c44cf6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Image by author. Source: [the-sql-gym.com](https://the-sql-gym.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: Back to partitioning — Let’s look at a bigger example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we’re working with small tables like the ones above, partitioning might
    seem a bit overkill. But when we upscale to larger tables, it can lead to significant
    performance gains.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s create two large tables, each with 1 million rows. The first will
    be an unpartitioned table, and the second will be partitioned by the `id` column,
    with each partition being 10,000 rows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the following query against the unpartitioned table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/d1ce2eb7af55144289d1ee37e1f8f5f7.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: … we see that all 1,000,000 rows of the table are read before the 1,001 records
    are outputted. The whole operation took 650ms (Elapsed time) / 503ms (Slot time
    consumed).
  prefs: []
  type: TYPE_NORMAL
- en: However, when we run the same query against the **partitioned** table, only
    10,000 rows are read (i.e., one single partition).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/ee7a768edaf85d73975b4acc5dafee94.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: When querying the unpartitioned table, the operation’s elapsed time was less
    than half of that in the first query (on the unpartitioned large table), and the
    slot time consumed was nearly 95% lower.
  prefs: []
  type: TYPE_NORMAL
- en: Pretty cool, right?
  prefs: []
  type: TYPE_NORMAL
- en: Common mistakes when using partitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you’d like to start using partitions to improve your tables/queries, there
    are a couple of pitfalls to watch out for:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Don’t filter a large partitioned table on a non-partitioning column** — If
    you filter on a column which is NOT the partitioning key, you won’t be able to
    take advantage of the partitioned structure of the table. If you DO need to filter
    on a non-partitioning-key column, I’d recommend that (if possible) you first add
    in a filter on the parititioning key (to prune the unneeded partitions), and then
    apply your second filter. This is because BigQuery (like many SQL engines) executes
    filters in the `WHERE` statement from top to bottom.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Don’t apply a function on top of the partition keys** — For example, if your
    partitioning key is a column `date`, don’t add a filter like `WHERE CAST(date
    AS STRING) = ''2023-12-02''`. Instead, if you need to include a function in your
    `WHERE` clause, add the function on top of a constant. In that example, you could
    rewrite the filter to `WHERE date = CAST(''2023-01-01'' AS DATE)` to ensure that
    you still take advantage of pruning/partitioning.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2 quick notes about partitioning in BigQuery specifically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'BigQuery has **a limit of 4,000 partitions per table**. If you’re trying to
    use a partitioning key that will create more than 4,000 partitions, try using
    a different resolution. For example, instead of partitioning by date/day:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '… you could partition by week:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It’s also worth knowing that BigQuery makes it possible to partition based on
    an ingestion time field and a pseudocolumn named `_PARTITIONTIME`. It’s too niche
    for this article, but you can read more about it [here](https://cloud.google.com/bigquery/docs/partitioned-tables#ingestion_time).
  prefs: []
  type: TYPE_NORMAL
- en: When NOT to use partitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On smaller tables, partitioning might not lead to a performance boost. Why?
    Because the process of pruning partitions might take longer than simply looking
    through all the rows in the table ([source](https://stackoverflow.com/questions/58743050/whats-a-good-balance-to-decide-when-to-partition-a-table-in-bigquery)).
  prefs: []
  type: TYPE_NORMAL
- en: In these cases, ***clustering*** can be a more performant alternative. Stay
    tuned for more on that in my next article!
  prefs: []
  type: TYPE_NORMAL
- en: One more thing —
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I’ve started a free newsletter called [AI in Five](https://aiinfive.substack.com/)
    where I share 5 bullet points each week on the latest AI news, coding tips and
    career stories for Data Scientists/Analysts. There’s no hype, no “**data is the
    new oil**” rubbish and no tweets (or should I say ‘x-es’ now?) from Elon — just
    practical tips and insights to help you develop in your career.
  prefs: []
  type: TYPE_NORMAL
- en: '[Subscribe here](https://aiinfive.substack.com/) if that sounds up your street!
    Thanks for reading.'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://aiinfive.substack.com/?source=post_page-----43e24ea4c5d0--------------------------------)
    [## AI in Five | Matt Chapman | Substack'
  prefs: []
  type: TYPE_NORMAL
- en: The latest news, career stories and coding tips from the world of Data Science
    and AI, summarised in 5 bullet points…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: aiinfive.substack.com](https://aiinfive.substack.com/?source=post_page-----43e24ea4c5d0--------------------------------)
  prefs: []
  type: TYPE_NORMAL
