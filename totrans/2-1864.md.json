["```py\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n#set default plotting settings to personal preference\nfont_settings = {'family':'Times New Roman', 'size':12}\nline_settings = {'lw':2}\nplt.rc('font', **font_settings)\nplt.rc('lines', **line_settings)\n```", "```py\nclass BouncingBall():\n\n    def __init__(self, m, k, b, ball_radius_cm):\n        #TODO: initialize the physical properties of the ball\n        pass\n\n    def in_air(self,t,x):\n        #TODO: compute the in-air physics of the ball (return the \n        # rate of change of the ball's current state)\n        pass\n\n    def in_contact(self,t,x):\n        #TODO: compute the in-contact physics of the ball (return the\n        # rate of change of the ball's current state)\n        pass\n\n    def simulate(self, t_span, x0, max_step=0.01):\n        #TODO: use the two physics models (`in_air` and `in_contact`) to \n        # actually simulate the trajectory of the ball given a desired time\n        # span and initial conditions. Must switch between the two physics \n        # models at the appropriate times\n        pass\n```", "```py\n def __init__(self, m, k, b, ball_radius_cm, gravity=None):\n        \"\"\"\n        Parameters\n        ----------\n        m : float\n            ball mass in kg\n        k : float\n            ball stiffness in N/m\n        c : float\n            ball viscous damping coef. in N/(m/s)\n        ball_radius_cm : float\n            ball radius in centimeters\n        gravity : float, optional\n            acceleration of gravity in m/s^2\\. Defaults to 9.81 m/s^2 \n            if None given.\n        \"\"\"\n\n        self.r = ball_radius_cm/100 #radius in meters\n        self.m = m\n        self.k = k\n        self.b = b\n\n        if gravity is None:\n            self.g = 9.81 #m/s^2\n        else:\n            self.g = gravity #m/s^2\n```", "```py\n def in_air(self,t,x):\n        \"\"\"computes the ball's state derivatives while in air\n\n        Parameters\n        ----------\n        t : float\n            simulation time\n        x : array-like\n            vector containing the ball's state variables (height and velocity)\n\n        Returns\n        -------\n        list\n            vector containing the ball's state derivatives\n        \"\"\"\n\n        x1, x2 = x #unpack the current state of the ball\n        return [x2, -self.g]\n\n    def in_contact(self,t,x):\n        \"\"\"computes the ball's state derivatives while in contact with the ground\n\n        Parameters\n        ----------\n        t : float\n            simulation time\n        x : array-like\n            vector containing the ball's state variables (height and velocity)\n\n        Returns\n        -------\n        list\n            vector containing the ball's state derivatives\n        \"\"\"\n\n        x1, x2 = x #unpack the current state of the ball\n        x1_dot = x2\n        x2_dot = -(self.b/self.m)*x2 + (self.k/self.m)*(self.r - x1) - self.g\n        return [x1_dot, x2_dot]\n```", "```py\ndef ball_physics(self, t, x):\n\n    #unpack ball's height and velocity\n    x1, x2 = x\n\n    #check if ball's center height is less than ball's radius\n    if x1 <= self.R:\n        #compute in-contact physics (state derivative)\n        return self.in_contact(t,x)\n    else:\n        #compute in-air physics (state derivative)\n        return self.in_air(t,x)\n```", "```py\nclass ContactEvent():\n    \"\"\"Callable class that returns zero when the ball engages/disengages\n    contact with the ground.\n    \"\"\"\n\n    def __init__(self, r, direction=0):\n        \"\"\"\n        Parameters\n        ----------\n        r : float\n            Radius of the ball in meters\n        direction : int, optional\n            Direction of a zero crossing to trigger the contact event.\n            Negative for the ball coming into contact with the ground.\n            Positive for the ball leaving contact with the ground, by default 0\n        \"\"\"\n\n        self.r = r\n        self.direction = direction\n        self.terminal = True #terminal is True so that simulation will end on contact event\n\n    def __call__(self,t,x):\n        \"\"\"Computes the height of the ball above being in contact\n\n        Notes\n        -----\n        The ball will engage/disengage contact when the height of the center\n        of the ball equals the radius of the ball.\n\n        Parameters\n        ----------\n        t : float\n            time in the simulation\n        x : array-like\n            vector of ball's state variables (height and velocity)\n\n        Returns\n        -------\n        float\n            height above being in contact\n        \"\"\"\n        #unpack height and velocity of ball\n        x1, x2 = x\n        return x1 - self.r\n```", "```py\ndef __init__(self, m, k, b, ball_radius_cm, gravity=None):\n        \"\"\"\n        Parameters\n        ----------\n        m : float\n            ball mass in kg\n        k : float\n            ball stiffness in N/m\n        c : float\n            ball viscous damping coef. in N/(m/s)\n        ball_radius_cm : float\n            ball radius in centimeters\n        gravity : float, optional\n            acceleration of gravity in m/s^2\\. Defaults to 9.81 m/s^2 \n            if None given.\n        \"\"\"\n\n        self.r = ball_radius_cm/100 #radius in meters\n        self.m = m\n        self.k = k\n        self.b = b\n\n        if gravity is None:\n            self.g = 9.81 #m/s^2\n        else:\n            self.g = gravity #m/s^2\n\n        # create event functions for the ball engaging and disengaging contact\n        # note that when coming into contact with the ground, the direction of the\n        # zero crossing will be negative (height abve the ground is transitioning \n        # to negative) whereas when the ball leaves the ground the zero crossing \n        # will be positive (height above the ground is transitioning from negative\n        # to positive)\n        self.hitting_ground = ContactEvent(self.r, direction=-1)\n        self.leaving_ground = ContactEvent(self.r, direction=1)\n```", "```py\ndef simulate(self, t_span, x0, max_step=0.01):\n        \"\"\"Simulates the time evolution of the ball bouncing\n\n        Parameters\n        ----------\n        t_span : two element tuple/list\n            starting and stopping time of the simulation, e.g. (0,10)\n        x0 : array-like\n            initial conditions of ball (height and velocity in m and m/s)\n        max_step : float, optional\n            max step size in simulation, by default 0.01\n\n        Returns\n        -------\n        tuple\n            tuple containing the time vector and height of the ball \n        \"\"\"\n\n        #check the initial height of the ball to determine if it's starting in the air\n        in_air = x0[0] > self.r \n        #extract out initial starting and stopping times\n        t_start, t_stop = t_span\n\n        #create lists with initial conditions that we can append the piecewise solutions to\n        t_lst = [t_start]\n        x_lst = [x0[0]]\n\n        #loop until we reach the desired stopping time\n        while t_start < t_stop:\n\n            \"\"\"\n            Here we simulate the ball forward in time using either the air \n            or contact model. Each of these subroutines will terminate when \n            either 1) the final desired simulation stop time is reached,\n            or 2) when a contact event is triggered. At a high level, we are\n            simulating our system forward in time using the relevant physics \n            model (that depends on the state of the system). The simulation \n            will alternate between the \"in_air\" model and \"in_contact\" model \n            switching between the two each time a contact event is triggered\n            \"\"\"\n\n            if in_air:\n                sol = solve_ivp(self.in_air, [t_start, t_stop], x0, \n                                events=[self.hitting_ground], max_step=max_step)\n\n            else:\n                sol = solve_ivp(self.in_contact, [t_start, t_stop], x0, \n                                events=[self.leaving_ground], max_step=max_step) \n\n            # append solution and time array to list of solutions. \n            # Note that the starting time of each solution\n            # is the stopping time of the previous solution. \n            # To avoid having duplicate time points, we will not include the first\n            #data point of each simulation. This is also why we created our \n            # solution lists above with the initial conditions already in them\n            t_lst.append(sol.t[1::])\n            x_lst.append(sol.y[0,1::])\n\n            #set the starting time and initial conditions to the stopping \n            #time and end condtions of the previous loop\n            t_start = sol.t[-1]\n            x0 = sol.y[:,-1].flatten()\n\n            #if we haven't reached the stopping time yet in the current \n            #loop, we must be switching between being in the air and\n            #being in contact\n            if t_start < t_stop:\n                in_air = not in_air\n\n        #concatenate all of the solutions into a single numpy array\n        t = np.hstack(t_lst)\n        x = np.hstack(x_lst)\n\n        return t,x\n```", "```py\nclass BouncingBall():\n    \"\"\"Class to simulate a bouncing ball\n\n    Methods\n    -------\n    in_air(t, x) : Computes the ball's state derivatives while in air\n\n    in_contact(t, x) : Computes the ball's state derivatives while in contact\n\n    simulate(t_span, x0, max_step) : Simulates the ball bouncing\n    \"\"\"\n\n    def __init__(self, m, k, b, ball_radius_cm, gravity=None):\n        \"\"\"\n        Parameters\n        ----------\n        m : float\n            ball mass in kg\n        k : float\n            ball stiffness in N/m\n        c : float\n            ball viscous damping coef. in N/(m/s)\n        ball_radius_cm : float\n            ball radius in centimeters\n        gravity : float, optional\n            acceleration of gravity in m/s^2\\. Defaults to 9.81 m/s^2 \n            if None given.\n        \"\"\"\n\n        self.r = ball_radius_cm/100 #radius in meters\n        self.m = m\n        self.k = k\n        self.b = b\n\n        if gravity is None:\n            self.g = 9.81 #m/s^2\n        else:\n            self.g = gravity #m/s^2\n\n        # create event functions for the ball engaging and disengaging contact\n        # note that when coming into contact with the ground, the direction of the\n        # zero crossing will be negative (height abve the ground is transitioning \n        # to negative) whereas when the ball leaves the ground the zero crossing \n        # will be positive (height above the ground is transitioning from negative\n        # to positive)\n        self.hitting_ground = ContactEvent(self.r, direction=-1)\n        self.leaving_ground = ContactEvent(self.r, direction=1)\n\n    def in_air(self,t,x):\n        \"\"\"computes the ball's state derivatives while in air\n\n        Parameters\n        ----------\n        t : float\n            simulation time\n        x : array-like\n            vector containing the ball's state variables (height and velocity)\n\n        Returns\n        -------\n        list\n            vector containing the ball's state derivatives\n        \"\"\"\n\n        x1, x2 = x #unpack the current state of the ball\n        return [x2, -self.g]\n\n    def in_contact(self,t,x):\n        \"\"\"computes the ball's state derivatives while in contact with the ground\n\n        Parameters\n        ----------\n        t : float\n            simulation time\n        x : array-like\n            vector containing the ball's state variables (height and velocity)\n\n        Returns\n        -------\n        list\n            vector containing the ball's state derivatives\n        \"\"\"\n\n        x1, x2 = x #unpack the current state of the ball\n        x1_dot = x2\n        x2_dot = -(self.b/self.m)*x2 + (self.k/self.m)*(self.r - x1) - self.g\n        return [x1_dot, x2_dot]\n\n    def simulate(self, t_span, x0, max_step=0.01):\n        \"\"\"Simulates the time evolution of the ball bouncing\n\n        Parameters\n        ----------\n        t_span : two element tuple/list\n            starting and stopping time of the simulation, e.g. (0,10)\n        x0 : array-like\n            initial conditions of ball (height and velocity in m and m/s)\n        max_step : float, optional\n            max step size in simulation, by default 0.01\n\n        Returns\n        -------\n        tuple\n            tuple containing the time vector and height of the ball \n        \"\"\"\n\n        #check the initial height of the ball to determine if it's starting in the air\n        in_air = x0[0] > self.r \n        #extract out initial starting and stopping times\n        t_start, t_stop = t_span\n\n        #create lists with initial conditions that we can append the piecewise solutions to\n        t_lst = [t_start]\n        x_lst = [x0[0]]\n\n        #loop until we reach the desired stopping time\n        while t_start < t_stop:\n\n            \"\"\"\n            Here we simulate the ball forward in time using either the air \n            or contact model. Each of these subroutines will terminate when \n            either 1) the final desired simulation stop time is reached,\n            or 2) when a contact event is triggered. At a high level, we are\n            simulating our system forward in time using the relevant physics \n            model (that depends on the state of the system). The simulation \n            will alternate between the \"in_air\" model and \"in_contact\" model \n            switching between the two each time a contact event is triggered\n            \"\"\"\n\n            if in_air:\n                sol = solve_ivp(self.in_air, [t_start, t_stop], x0, \n                                events=[self.hitting_ground], max_step=max_step)\n\n            else:\n                sol = solve_ivp(self.in_contact, [t_start, t_stop], x0, \n                                events=[self.leaving_ground], max_step=max_step) \n\n            # append solution and time array to list of solutions. \n            # Note that the starting time of each solution\n            # is the stopping time of the previous solution. \n            # To avoid having duplicate time points, we will not include the first\n            #data point of each simulation. This is also why we created our \n            # solution lists above with the initial conditions already in them\n            t_lst.append(sol.t[1::])\n            x_lst.append(sol.y[0,1::])\n\n            #set the starting time and initial conditions to the stopping \n            #time and end condtions of the previous loop\n            t_start = sol.t[-1]\n            x0 = sol.y[:,-1].flatten()\n\n            #if we haven't reached the stopping time yet in the current \n            #loop, we must be switching between being in the air and\n            #being in contact\n            if t_start < t_stop:\n                in_air = not in_air\n\n        #concatenate all of the solutions into a single numpy array\n        t = np.hstack(t_lst)\n        x = np.hstack(x_lst)\n\n        return t,x\n```", "```py\nb = BouncingBall(m=1, k=10e3, c=10, ball_radius_cm=6)\n\nt,x = b.simulate([0,8], [2, 0])\ndf = pd.DataFrame({'time':t, 'x':x}).set_index('time')\ndf.to_csv('sim_data.csv')\n\nfig, ax = plt.subplots()\nax.plot(t,x)\nax.set_xlabel('Time [s]')\nax.set_ylabel('Height [m]')\n\nfig.savefig('bouncing_ball.png')\n```"]