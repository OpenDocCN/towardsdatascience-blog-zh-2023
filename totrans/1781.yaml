- en: Removing Clouds from Landsat Satellite Images with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/removing-clouds-from-landsat-satellite-images-with-python-246e73494bc](https://towardsdatascience.com/removing-clouds-from-landsat-satellite-images-with-python-246e73494bc)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Calculating cloud cover in your area of interest, removing clouds and inpainting
    them using another satellite image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://conorosullyds.medium.com/?source=post_page-----246e73494bc--------------------------------)[![Conor
    O''Sullivan](../Images/2dc50a24edb12e843651d01ed48a3c3f.png)](https://conorosullyds.medium.com/?source=post_page-----246e73494bc--------------------------------)[](https://towardsdatascience.com/?source=post_page-----246e73494bc--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----246e73494bc--------------------------------)
    [Conor O''Sullivan](https://conorosullyds.medium.com/?source=post_page-----246e73494bc--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----246e73494bc--------------------------------)
    ·14 min read·May 29, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/139abceec02d150bde92512b5d84aa21.png)'
  prefs: []
  type: TYPE_IMG
- en: '(source: author)'
  prefs: []
  type: TYPE_NORMAL
- en: Our technology has progressed to conquer the vastness of space. We’ve launched
    satellites, armed with state-of-the-art sensors, to monitor our changing planets.
    Yet, one adversary has humbled these advanced systems — clouds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whether you want to compare the value of spectral indices or train machine
    learning models on satellite images, clouds are a problem. So, we’ll explore how
    to use a cloud mask to:'
  prefs: []
  type: TYPE_NORMAL
- en: Calculate the **percentage of cloud cover** in your area of interest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remove** clouds from the image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inpaint** cloud pixels using an image taken on a different day'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When it comes to the actual mask we’ll explore two options:'
  prefs: []
  type: TYPE_NORMAL
- en: The one provided in the **Landsat QA file** (QA_PIXEL.tif)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An alternative **machine learning approach**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll explain the Python code used to do this and you can find the full project
    on [GitHub](https://github.com/conorosully/medium-articles/blob/master/src/remote%20sensing/landsat_clouds.ipynb).
    Let's clear those skies!
  prefs: []
  type: TYPE_NORMAL
- en: Downloading a satellite image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The methods we discuss will work with any raster data. In this article, we
    will specifically be working with Landsat satellite imagery. You can download
    a Landsat scene using the [EarthExplorer](https://earthexplorer.usgs.gov/) portal.
    Alternatively, if you want to use Python, the article below takes you through
    the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/downloading-landsat-satellite-images-with-python-a2d2b5183fb7?source=post_page-----246e73494bc--------------------------------)
    [## Downloading Landsat Satellite Images with Python'
  prefs: []
  type: TYPE_NORMAL
- en: Streamline Landsat scene downloads with the landsatxplore Python package
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/downloading-landsat-satellite-images-with-python-a2d2b5183fb7?source=post_page-----246e73494bc--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: In the end, you should have a folder like **Figure 1**. These are all the files
    available for a [Landsat level 2 science product](https://www.usgs.gov/landsat-missions/landsat-collection-2-level-2-science-products).
    We’ll be working with the highlighted files. These are the 3 visible light bands
    and the QA_PIXEL file.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b845ab3da664b3198809738ea990de2d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: Landsat level-2 science product files (source: author)'
  prefs: []
  type: TYPE_NORMAL
- en: This particular scene was taken above Cape Town, South Africa. To see this we
    visualise the visible light bands using the **get_RGB** function. This takes the
    file name/ ID as a parameter. It will then load the bands (lines 7–9), stack them
    (line 12), [scale them](https://www.usgs.gov/faqs/how-do-i-use-scale-factor-landsat-level-2-science-products)
    (line 13) and [clip them](/visualising-the-rgb-channels-of-satellite-images-with-python-6d541af1f98d)
    (line 16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We use this function to get an RGB visualisation for the scene we downloaded
    in **Figure 1** (lines 3–4). You can see the resulting image in **Figure 2**.
    Notice all the clouds! Let’s see if we can deal with them using the Landsat cloud
    mask.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/89908ec1b1269cf93dc7accc1c6ca975.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2: RGB visualisation of Landsat scene (source: author)'
  prefs: []
  type: TYPE_NORMAL
- en: Landsat cloud masks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a cloud mask?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A cloud mask is a segmentation map that separates clouds from other features
    on the earth’s surface. The map classifies each pixel in an image as either cloud
    or non-cloud. It can also include other similar features like cloud shadows. They
    are important in remote sensing as isolating cloud pixels leads to more accurate
    measurements and interpretations of land cover analysis.
  prefs: []
  type: TYPE_NORMAL
- en: There are various methods used to classify cloud pixels. Landsat uses an algorithm
    called [CFMask](https://www.usgs.gov/landsat-missions/cfmask-algorithm). This
    uses a combination of various statistics based on spectral indices. It has a classification
    accuracy of 89% for cloud pixels and 96% for cloud shadows [1]. Later, we will
    discuss an alternative machine-learning approach to creating cloud masks.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the quality assurance (QA) band
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The CFMask algorithm is run for every Landsat scene and the results can be found
    in the QA band. This file is an array with the same height and width as the solar
    reflection bands (e.g. visible light bands). Every pixel in the band is a 16-bit
    integer that contains the classification for that pixel. You can find more information
    on this encoding in the [Data Format Control Book](https://www.usgs.gov/media/files/landsat-8-9-olitirs-collection-2-level-2-data-format-control-book).
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose one of the pixels in the QA file has the value **22280**.
    To understand what this integer means we first convert it to a 16-bit binary number
    — **0101011100001000**. Every bit in this number then maps to a flag seen in **Figure
    3**. Bit 3 has a value of 1 indicating that this pixel is classified as cloud.
    Going forward, we will consider cover types for bits 1 to 4 for our cloud mask.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/bc422ce67a78418a67fa3204c49036b9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3: Landsat QA band bit description and example (source: author)'
  prefs: []
  type: TYPE_NORMAL
- en: We use this information to create the **get_mask** function. It will return
    the classification of an individual pixel for the 4 cover types — cloud, shadow,
    dilated cloud and cirrus. A pixel will have a value of 0 if it is classified as
    the given cover type and 1 otherwise. Later, we will see that this allows us to
    remove unwanted pixels by multiplying the satellite image by the mask.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To apply this function, we start by loading our QA band (line 2). We apply **get_mask**
    to every pixel in the band for each of the 4 cover types (lines 6–9). Instead
    of looping over every pixel, we speed things up using **np.vectorize()**. Each
    mask will be an array with the same dimensions as the scene where every element
    has a value of 0 or 1.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see these masks in action in **Figure 4**. Here we have overlayed the
    image we saw **Figure 2** with different colours depending on the classifications
    in the 4 masks. Zooming in on one area, we can get a better understanding of each
    cover type:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Shadows** are the darker areas below clouds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dilated clouds** are the edges around pixels classified as clouds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cirrus** are “wispy” clouds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a pixel is classified as cirrus it will also be classified as cloud.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/339af0757a3c4b210063d4c002ba2122.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4: Landsat segmentation mask with 4 cover types — cloud, shadow, dilated
    cloud and cirrus (source: author)'
  prefs: []
  type: TYPE_NORMAL
- en: The code below is used to create **Figure 4**. We add a layer for each of the
    masks to the original RGB image (lines 15–22). This is done using the **cv2.addWeighted()**
    function (line 22). Every mask layer is given a different color (lines 8–11) with
    50% transparency. The area of interest (AOI) is cropped by taking pixels within
    a given range (line 43). Next, we will take a closer look at this area.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Assessing area of interest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The percentage cloud cover of the entire scene is given as part of the scene’s
    metadata. In our case, we have a value of **59%**. With the cloud mask, we can
    calculate this figure for a particular AOI. This is useful as it allows us to
    programmatically search for scenes where our AOI is cloud-free. That is even if
    the rest of the scene is cloudy.
  prefs: []
  type: TYPE_NORMAL
- en: To see this, we select the same area of interest as **Figure 4** (line 2). Keep
    in mind, the cloud mask has a value of 0 for no clouds and 1 otherwise. We invert
    this and take the average (line 5). This gives us a value of **69%**. Unfortunately,
    our AOI is more cloudy than the scene in general!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Removing clouds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have a mask, removing unwanted pixels is straightforward. We simply
    have to multiply the RGB image by the mask. The code below will remove pixels
    classified as cloud (line 2). Keep in mind that the RGB image is a 3D array. In
    comparison, the **cloud_mask** is a 2D array. This is why we use **np.newaxis**
    to add an additional dimension.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can see the result in **Figure 5**. Cloud pixels are now all replaced with
    values of [0,0,0]. This is the same value used for the bounding box. This means
    the pixels have “no data” and can be ignored in further analysis. Ultimately,
    the results of this analysis rely on the accuracy of the cloud mask. This is why
    researchers continuously seek to improve these masks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9173baae6d2167f736c2041563575f9b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5: clouds removed from satellite image using Landsat cloud mask (source:
    author)'
  prefs: []
  type: TYPE_NORMAL
- en: Machine learning approach to cloud masks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We mentioned that Landsat uses an algorithm called [CFMask](https://www.usgs.gov/landsat-missions/cfmask-algorithm).
    It is based on remote sensing and meteorological knowledge of how cloud pixels
    are represented in satellite images. Alternatively, we can use machine learning.
    This requires training images where all cloud pixels have been manually labelled.
    An ML algorithm then learns the relationship between spectral bands and the labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[One approach](https://medium.com/sentinel-hub/clouds-segmentation-in-landsat-8-images-da370815235)
    uses a genetic algorithm trained on the Coastal Aerosol (B1), Red (B4) and Shortwave
    Infrared 2 (B7) bands. The resulting algorithm is given in **cloud_pred** function.
    The **pred** formula (lines 4-10) gives a weighting of the 3 bands. If the weighted
    value is greater than the B7 band the pixel is labelled as cloud (line 12).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To use this function, we start by loading the 3 necessary bands (lines 4–6).
    We get the cloud mask by passing these bands into the **cloud_pred** function
    (line 9). We can then use this mask to remove clouds in the same way as before
    (line 12). You can see the resulting image in **Figure 6**.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/6d63b900d94333d487b6dbdf8a96167e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6: clouds removed from satellite image using a machine learning approach
    (source: author)'
  prefs: []
  type: TYPE_NORMAL
- en: The researchers state the accuracy of the above approach was **89%** — similar
    to CFMask. As mentioned, improving the accuracy of algorithms is an active area
    of research. State-of-the-art approaches use deep learning algorithms for image
    segmentation such as [U-Net](/u-net-explained-understanding-its-image-segmentation-architecture-56e4842e313a).
    The downside to these approaches, over CFMask, is the need for accurately labelled
    training data.
  prefs: []
  type: TYPE_NORMAL
- en: Inpainting clouds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For some applications, it may be enough to simply remove clouds from your image.
    For others, we want to replace or “inpaint” the clouds. For example, to create
    a visualisation of a landscape without clouds.
  prefs: []
  type: TYPE_NORMAL
- en: In **Figure 7**, we can see the same cloudy image that we’ve been working with.
    This was taken on 10/04/2023\. Thankfully, 8 days later a clear image was taken
    over the same area. We’ll explore how to replace the pixels in the cloudy image
    (line 6) with the ones in the clear image (line 7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/ab15da8c8131f201d2cd2ecbbed7d753.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7: a cloudy and clear image taken 8 days apart (source: author).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will do this for both the **AOI** and the **entire scene**. In both cases,
    it is important to consider the *geolocations* of the pixels. Even though the
    cloudy and clear images are taken above the same area, the pixels will not align
    perfectly. In other words, the UTM coordinates of the pixel in array position
    [x,y] will be different in each image. Hence, if we relied on array positions
    alone we would end up replacing pixels with the wrong area of land. To deal with
    this, we build on methods used in this article:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/how-to-plot-coordinates-on-landsat-satellite-images-with-python-5671613887aa?source=post_page-----246e73494bc--------------------------------)
    [## How to Plot Coordinates on Landsat Satellite Images with Python'
  prefs: []
  type: TYPE_NORMAL
- en: Mapping pixel positions to geographic coordinates using Landsat metadata and
    Rasterio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/how-to-plot-coordinates-on-landsat-satellite-images-with-python-5671613887aa?source=post_page-----246e73494bc--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Area of interest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we will see how to inpaint an AOI. We start by creating a mask using
    all 4 cover types (line 2) and remove the unwanted pixels from the cloudy image
    (line 5). We then crop the resulting image around our AOI (lines 8–9). We take
    (x,y) as the centre of the AOI in the cloudy image.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned, we need to consider the geolocations of the pixels. We use the
    rasterio package to help with this. We load the red band for both the cloudy (line
    4) and clear (line 5) images.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We find the UTM coordinates, in the **cloudy image**, of the centre of our AOI
    (line 2). We then find the array positions for these UTM coordinates in the **clear
    image** (line 5). Printing these gives a value of **(4430, 4510)**. You can see
    how this is different to the original centre of **(4500,4500).**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We crop the AOI from the **clear image** (line 2) using the new centre. We then
    crop the cloud mask (from the cloudy image) using the original centre (line 5).
    The UTM coordinates of **crop_clear** and **crop_mask** will align perfectly.
    So, we create our **fill** by multiplying the clear image by the inverse of the
    mask (line 6). The final step is to add the **fill** to the cloudy image with
    no clouds (line 9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You can see the result in **Figure 8**. It looks good! For the most part, the
    landscape looks continuous. Although, there are a few issues which we discuss
    at the end.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/53f10e3ef571aedc757d7e62ab9a29e6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8: area of interest inpainted using clear image (source: author)'
  prefs: []
  type: TYPE_NORMAL
- en: The entire image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inpainting the entire scene is more complicated. To do this we need to align
    the bounding box of the cloudy and clear scenes. The bound box is the outer black
    border of the scene. We align the UTM coordinates of the boxes by adding and removing
    some pixels from the clear image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/efe597bd3cedb66ab980f4d360a7f699.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9: adding and removing pixels to align the bounding boxes'
  prefs: []
  type: TYPE_NORMAL
- en: We start by calculating the number of pixels to add/remove from the top, bottom,
    left and right of the clear image. We get array positions for the upper left (UL)
    (line 3) and lower right (LR) corners (line 4) of the **clear image**. These are
    based on the dimensions of the clear image (line 2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Next, we get the bounds from the **cloudy image** (line 2). These give the UTM
    coordinates of the cloudy image’s bounding box. We then get array positions for
    these coordinates from the **clear image** (lines 3–4). Note these positions can
    fall outside the dimensions of the clear image.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference between the original and new corner positions will tell us how
    we need to adjust the clear image to align the UTM coordinates. Printing the adjustments
    (line 8) gives us -10 0 70 -70\. This means we have to adjust the clear image
    by:'
  prefs: []
  type: TYPE_NORMAL
- en: Removing 10 pixels from the top
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No adjustment to the bottom
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding 70 pixels to the left
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing 70 pixels from the right
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: After calculating the adjustments, we can use the **adjust_rgb** function. This
    will add black pixels in the case of positive adjustments (lines 6–17). It will
    then crop pixels for negative adjustments (lines 20–27).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We use this function to adjust our clear image (line 6). We remove the unwanted
    pixels from the cloudy image (line 12) and then get the replacement pixels from
    the adjusted clear image (line 13). As they have been aligned, we add can simply
    add them together (line 14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You can see the results in **Figure 10**. Overall the landscape looks good.
    If we zoom in our area of interest you can see that it is exactly the same as
    in **Figure 8**. However, as mentioned, there are some issues.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ae783822cc05e00bd08c1cd1b6d35dbc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10: entire scene inpainted using clear image (source: author)'
  prefs: []
  type: TYPE_NORMAL
- en: We can see this if we zoom in on another AOI. The transparent white pixels are
    those that were replaced by pixels in the clear image. Notice that some of the
    shadow pixels have not been replaced. This may cause discontinuities in the landscape
    where the brightness changes drastically.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/27bcbd3ed109499fbdb85ac11834e684.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11: cloud shadows that have not been successfully inpainted (source:
    author)'
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that cloud masks are not perfect. We cannot completely replace
    all clouds if we cannot identify them with 100% accuracy. Discontinuities can
    also be caused by changes in the landscape over time. Rivers move and tides will
    rise. To create the best possible visualisations, select replacement images that
    were taken close to the time of your cloudy image.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you enjoyed this article! You can find me on [Mastodon](https://sigmoid.social/@conorosully)
    | [Twitter](https://twitter.com/conorosullyDS) | [YouTube](https://www.youtube.com/channel/UChsoWqJbEjBwrn00Zvghi4w)
    | [Newsletter](https://mailchi.mp/aa82a5ce1dc0/signup) — sign up for FREE access
    to a [Python SHAP course](https://adataodyssey.com/courses/shap-with-python/)
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://conorosullyds.medium.com/membership?source=post_page-----246e73494bc--------------------------------)
    [## Join Medium with my referral link — Conor O’Sullivan'
  prefs: []
  type: TYPE_NORMAL
- en: As a Medium member, a portion of your membership fee goes to writers you read,
    and you get full access to every story…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: conorosullyds.medium.com](https://conorosullyds.medium.com/membership?source=post_page-----246e73494bc--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[1] Steve Foga, et. al., **Cloud detection algorithm comparison and validation
    for operational Landsat data products**, [https://www.sciencedirect.com/science/article/pii/S0034425717301293?via%3Dihub](https://www.sciencedirect.com/science/article/pii/S0034425717301293?via%3Dihub=)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Landsat 8–9 OLI/TIRS Collection 2 Level 2 Data Format Control Book** [https://www.usgs.gov/media/files/landsat-8-9-olitirs-collection-2-level-2-data-format-control-book](https://www.usgs.gov/media/files/landsat-8-9-olitirs-collection-2-level-2-data-format-control-book)'
  prefs: []
  type: TYPE_NORMAL
- en: Leah Wasser **Lesson 3\. Clean Remote Sensing Data in Python — Clouds, Shadows
    & Cloud Masks** [https://www.earthdatascience.org/courses/use-data-open-source-python/multispectral-remote-sensing/landsat-in-Python/remove-clouds-from-landsat-data/](https://www.earthdatascience.org/courses/use-data-open-source-python/multispectral-remote-sensing/landsat-in-Python/remove-clouds-from-landsat-data/)
  prefs: []
  type: TYPE_NORMAL
- en: Leah Wasser **Lesson 4\. How to Replace Raster Cell Values with Values from
    A Different Raster Data Set in Python** [https://www.earthdatascience.org/courses/use-data-open-source-python/multispectral-remote-sensing/landsat-in-Python/replace-raster-cell-values-in-remote-sensing-images-in-python/](https://www.earthdatascience.org/courses/use-data-open-source-python/multispectral-remote-sensing/landsat-in-Python/replace-raster-cell-values-in-remote-sensing-images-in-python/)
  prefs: []
  type: TYPE_NORMAL
- en: Landsat Missions **CFMask Algorithm** [https://www.usgs.gov/landsat-missions/cfmask-algorithm](https://www.usgs.gov/landsat-missions/cfmask-algorithm)
  prefs: []
  type: TYPE_NORMAL
- en: '[Ing Grenet](https://medium.com/u/1f2c139115b6?source=post_page-----246e73494bc--------------------------------)
    **Cloud Segmentation in Landsat-8 Images** [https://medium.com/sentinel-hub/clouds-segmentation-in-landsat-8-images-da370815235](https://medium.com/sentinel-hub/clouds-segmentation-in-landsat-8-images-da370815235)'
  prefs: []
  type: TYPE_NORMAL
- en: SentinelHub **Landsat 8 Clouds Segmentation Script** [https://custom-scripts.sentinel-hub.com/custom-scripts/landsat-8/clouds_segmentation/](https://custom-scripts.sentinel-hub.com/custom-scripts/landsat-8/clouds_segmentation/)
  prefs: []
  type: TYPE_NORMAL
