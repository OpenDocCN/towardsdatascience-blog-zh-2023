# 进化算法 — 选择解释

> 原文：[https://towardsdatascience.com/evolutionary-algorithm-selections-explained-2515fb8d4287](https://towardsdatascience.com/evolutionary-algorithm-selections-explained-2515fb8d4287)

## 理解发生的过程，通过可视化和代码

[](https://medium.com/@byjameskoh?source=post_page-----2515fb8d4287--------------------------------)[![James Koh, PhD](../Images/8e7af8b567cdcf24805754801683b426.png)](https://medium.com/@byjameskoh?source=post_page-----2515fb8d4287--------------------------------)[](https://towardsdatascience.com/?source=post_page-----2515fb8d4287--------------------------------)[![Towards Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----2515fb8d4287--------------------------------) [James Koh, PhD](https://medium.com/@byjameskoh?source=post_page-----2515fb8d4287--------------------------------)

·发表于[Towards Data Science](https://towardsdatascience.com/?source=post_page-----2515fb8d4287--------------------------------) ·阅读时间8分钟·2023年11月4日

--

![](../Images/a196f197fbda7a28f3ddab8d2b5563e8.png)

图片由DALL·E 3根据提示“绘制一幅科幻主题的图像，描绘进化算法中的父代选择”创建。

旅行商问题（TSP）是一个著名的NP难题，具有明显的现实应用。例如，如果有人计划一次环游欧洲的旅行，并估计各站点之间的旅行时间，这就非常有用。

仅仅30个城市就会有超过10³⁰种可能的排列。通过暴力破解方法解决30个城市的TSP是不可行的（地球上的沙粒数量“仅为”10¹⁹）。

通过本文，使用进化算法（EA）解决这些问题将变得轻而易举。你将能够自己获得以下结果。

通过进化算法获得的解决方案改进过程。Gif由作者提供。

更重要的是，你将了解幕后究竟发生了什么，以及每个组件（特别是各种类型的突变）如何对解决方案作出贡献。

# 1\. 价值主张

许多指南错误地将遗传算法（GA）和进化算法（EA）互换使用。

GA在其标准形式中涉及以下元素[1]：

1\. 表示 — 位串

2a. 父代选择 — 与适应度成比例

2b. 交叉 — 单点交叉

3\. 突变 — 位翻转

4\. 生存选择 — 下一代

GA是EA的一个子集。

在本指南中，我们涵盖了GA中未讨论的EA方面。特别是，我们将重点关注**排列**表示方面，通过直观的可视化和代码进行解释。

# 2\. 定义

在进一步讨论之前，我们需要明确术语的使用[2]。

## 表型

原始问题背景中的解决方案。这些解决方案需要“按原样”解释，无需任何解码；并且与解决方案的推导方式无关。

## 基因型

表示表型的编码。这可能是比特串、整数，甚至是浮点数。确定性映射将每个基因型转换为对应的表型。

## 适应度

从某个函数中得出的度量，作为选择的基础。它使我们能够比较两个基因型（因此也比较两个解决方案），并定义哪个更“好”。

## 种群

由个体基因型组成的集合，通常具有恒定的大小。通过迭代，种群成员通过重组、突变和生存者选择的过程发生变化。

## 重组

一种二进制变异，其中两个后代从两个父代基因型中创建，在这个过程中混合它们的属性。

## 突变

对单一基因型执行的一元变异。变化是随机的，旨在保持种群的多样性。

## 生存者选择

确定哪些个体（由其基因型表示）将在下一代中保留下来的过程。目标是保留最有前途的选择，同时保持多样性，以促进未来的潜在改进。

# 3\. 大纲

进化算法遵循以下框架。

![](../Images/5a9ca78c7ba1dfcc9e5991734dd184c5.png)

图片由作者提供。灵感来自于[2]中的图3.2。

# 3.1 — 初始化；表示

在讨论任何数学或代码之前，我们需要框定问题并制定基因型，以便它能适当地映射到解决方案空间。

进化算法超越了二进制和排列表示，但我们在这里不进一步探讨。

然后将种群初始化为适当基因型的随机副本。

## 3.1.1（为什么不）二进制表示

使用比特来表示基因型是一个自然的选择，因为这反映了现实。人类以及其他生物都拥有DNA作为遗传物质。我们可以将DNA序列视为1和0的字符串，而不是‘A-T’和‘C-G’。

当固有问题涉及二进制决策时，二进制表示效果非常好——一个完美的例子是背包问题，其中每个比特表示该对应物品是否被选中。

尽管一切都可以用比特表示，但对于非二进制问题的解决方案，使用比特表示是不适当的。

突变应该以相等的概率改变解决方案，并确保随之产生的解决方案是有效的。将数字7（0111）变为8（1000）需要四次比特翻转，而将其变为3（0011）、5（0101）或6（0110）只需一次比特翻转——概率是不同的。使用灰码[3]不足以解决这种汉明距离的差异，坚持这种表示方式会导致进化过程的偏差。

此外，如果使用二进制表示法来表示排列，在重组和/或变异后可能需要进行调整。这是因为每个索引必须恰好出现一次，结果基因型可能对应于一个无效的表现型。

## 3.1.2 排列表示法

这引出了将排列作为基因型的使用。除了旅行商问题（TSP），这也适用于需要我们选择一个序列的问题。这可以是访问地点的序列、完成任务的序列、分配匹配或仓库中库存的放置。

将基因型作为索引序列在这里是理想的，因为我们可以确保在变异后得到有效的表现型。例如，如果有12个城市可以选择，基因型可以是`[9,2,6,1,7,8,11,0,4,3,10,5]`。我们将看到有多种方法可以进行变异，同时确保每个整数出现恰好一次。

我们可以从以下提纲开始生成一个种群。（为了简洁起见，我省略了库的导入，因为这些是微不足道的。）

[PRE0]

# 3.2 — 父代选择

在进化算法（EA）中，父代选择、变异和生存选择的过程是迭代进行的，以确保整个种群在代际之间不断改进。

如果任何一个步骤实施不正确，整个算法可能会崩溃。

父代选择，作为三大支柱之一，很重要，因为后代是其父代的变体。请记住，每个个体实际上是一个基因型，它代表了一个候选解决方案。

当我们结合两个父代，并应用重组（第3.3.1节）以获得新的基因型时，实际上发生的情况是将两个解决方案的各个方面混合在一起，结果产生新的候选解决方案。虽然不能保证高适应度的父代会导致更好的后代，但机会会倾向于对我们有利。

然而，我们需要在探索和利用之间找到平衡，就像在强化学习中一样。每次都选择最适应的两个父代不是一个好主意，因为缺乏多样性会阻碍我们找到最终解决方案[4]。

## 3.2.1 轮盘赌选择父代

假设的轮盘赌的区域与每个个体的适应度成正比。每个区域表示选择各自个体作为父代的概率。

![](../Images/6dcf4b0cb0885b0a84a29e9e289b1a29.png)

通过轮盘赌方法展示的父代选择概率相对于适应度的示意图。饼图来自Excel。图片由作者提供。

一个警告是适应度值应为正值。自己尝试一下，这比千言万语更有说服力。

[PRE1]

你将发现所有负权重被选中的机会为零，而高度负的权重与稍微负的权重没有区别。这不是我们在进化算法（EA）中想要的，因为一个略微差的解决方案应当明显优于一个极其糟糕的解决方案。

在TPS中，一种常见的适应度表示方法是通过否定城市之间的距离（你将在第4.1节看到代码）。在这种情况下，我们需要对适应度进行标准化，使其为正数。这可以通过从最小（即最负）适应度中减去，然后添加一些小的epsilon来完成，这样即使是最差的解也有非零的被选中机会。

这种基准选择实际上比看起来更重要，需要数据科学家的一些判断。考虑以下情况：

![](../Images/1447711bba42653252006c55bb8b33dc.png)

适应度的定义是相关的。在上面的例子中，适应度为100是否已经‘保证’并内置，或者*个体A*获得了它并且确实是其他个体的有力竞争者，这是有区别的。

## 3.2.2 父代选择的锦标赛

另一种常见的方法是锦标赛选择。这种方法用于确保最适应的父代不会大多数时间占据主导地位。

在这里发生的情况是，随机选择一个小子集，并在这个群体中选择适应度最高的个体作为父代。在下面的例子中（其中圆圈大小表示每个个体的适应度），紫色个体将被选择作为此特定运行的父代。

![](../Images/d207643a7d36cf790d89a97d5b55f5cb.png)

按照适应度比例显示个体在种群中的可视化。紫色圆圈在这个锦标赛选择的例子中被选中。图片由作者提供。

这有助于维持多样性，这一点在第3.2节开始时已经提到。若使用轮盘赌选择法，该紫色个体被选择的机会会非常低。

在代码中，锦标赛选择或轮盘赌选择父代可以实现如下：

[PRE2]

我将子群体的大小设置为5或总人口的2%，以较小者为准。你当然可以自由更改这个数字。这些超参数越小，探索（而非利用）就会越多。

# 待续

在这篇文章中，你了解了构成进化算法（EA）的不同组件，并探讨了不同父代选择方法的理由。

一篇文章中要吸收这么多新知识确实不少。这已经有8分钟的阅读时间了，EA中还有很多重要概念需要讨论。为了让学习更易接受，这篇文章就到这里。

在下一篇文章中，[**进化算法——突变解析**](/evolutionary-algorithm-mutations-explained-4a3b5c2d49de?sk=e3e2305821577766713f14b8240e8459)，你将学习关于重组、突变和生存选择的内容。基于排列的基因型中的重组不像交叉那样简单，但解释将通过直观、可视化和代码来支持，以便即使没有先前的经验也能清晰理解。然后我们将把所有代码整合在一起，并解决旅行商问题。

# 参考文献

[1] D. E. Goldberg, [搜索、优化与机器学习中的遗传算法](https://dl.acm.org/doi/10.5555/534133) (1989)，Addison-Wesley

[2] A. E. Eiben 和 J. E. Smith, [进化计算简介](https://link.springer.com/book/10.1007/978-3-662-44874-8) (2015)，Springer-Verlag Berlin Heidelberg

[3] C. Faloutsos, [使用灰码的多属性哈希](https://dl.acm.org/doi/abs/10.1145/16894.16877) (1986)，发表于1986年ACM SIGMOD国际数据管理会议论文集

[4] F. Vafaee, G. Turán, P. C. Nelson 和 T. Y. Berger-Wolf, [在自适应多样性引导遗传算法中平衡探索与开发](https://ieeexplore.ieee.org/abstract/document/6900257) (2014)，发表于2014 IEEE进化计算大会
