["```py\nclass Evolutionary:\n    def __init__(self, task):\n        self.task = task\n\n    def partial_map_crossover(self, parent1, parent2):\n        n = len(parent1)\n        point = random.randint(0, n-1)\n        child1 = list(parent1[0:point])\n        for j in parent2:\n            if (j in child1) == False:\n                child1.append(j)\n        child2 = list(parent2[0:point])\n        for j in parent1:\n            if (j in child2) == False:\n                child2.append(j)\n        return child1, child2\n\n    def run_evolution(self, population_size, generation_limit=5000, fitness_limit=1e99, crossover='single', verbose=True):\n        ## ... define population ...\n\n        best_fitness_seen = -1e9\n        for i in tqdm(range(generation_limit)):\n            population = sorted(\n                population, key=lambda genome: self.task.fitness(genome), reverse=True\n            )\n            fitness = self.task.fitness(population[0])\n\n            if verbose and (fitness > best_fitness_seen):\n                best_fitness_seen = fitness\n                self.task.visualize(population[0], save_id=i)\n            if fitness >= fitness_limit:\n                break\n\n            ## ... elitism; keep best individuals and variants of them ...\n\n            for j in range((population_size - n_keep)//2):\n                parents = self.selection(\n                    population, self.task.fitness, \n                    method='tournament'\n                )\n                if random.random() < 0.9:\n                    offspring_a, offspring_b = self.partial_map_crossover(parents[0], parents[1])\n                else:\n                    offspring_a, offspring_b = parents[0], parents[1]\n                if random.random() < 0.9:\n                    offspring_a = self.swop(offspring_a)\n                    offspring_b = self.swop(offspring_b)\n                next_generation += [offspring_a, offspring_b]\n            population = next_generation\n\n        best_genome = population[0]\n        return best_genome\n\n    def selection(self, ...):\n        ## tournament or roulette wheel, or combination\n\n    def shift_to_end(self, genome, num=1):\n        new_genome = deepcopy(genome)\n        for _ in range(num):\n            a = random.sample(range(len(genome)), k=1)[0]\n            ref = deepcopy(new_genome[a])\n            if random.random() < 0.5:\n                new_genome[1:a+1] = new_genome[:a]\n                new_genome[0] = ref   # bring to first\n            else:\n                new_genome[a:-1] = new_genome[a+1:]\n                new_genome[-1] = ref   # bring to last\n        return new_genome\n\n    def swop(self, genome, num=1):\n        new_genome = deepcopy(genome)\n        for _ in range(num):\n            a, b = random.sample(range(len(genome)), k=2)\n            new_genome[a], new_genome[b] = genome[b], genome[a]\n        return new_genome\n```", "```py\nnext_generation = population[:n_top]   # keep the n_top fittest individuals\n\nfor _ in range(n_perturb):\n    # select a candidate from population[:n_top]\n    if np.random.random() < p_shift:\n        candidate = self.shift_to_end(candidate)\n    if np.random.random() < p_swop:\n        candidate = self.swop(candidate)\n    next_generation += [candidate]\n\nn_keep = n_top + n_perturb\n```", "```py\nclass Salesman:\n    def __init__(self, num_cities, x_lim, y_lim, read_from_txt=None):\n        if read_from_txt:\n            self.city_locations = []\n            f = open(read_from_txt)\n            for i, line in enumerate(f.readlines()):\n                if i==num_cities:\n                    break\n                node_val = line.split()\n                self.city_locations.append(\n                    (float(node_val[-2]), float(node_val[-1]))\n                )\n            self.num_cities = len(self.city_locations)\n            self.x_lim = np.max(np.array(self.city_locations)[:,0])\n            self.y_lim = np.max(np.array(self.city_locations)[:,1])\n\n        else:   # generate randomly\n            self.num_cities = num_cities\n            self.x_lim = x_lim\n            self.y_lim = y_lim\n            x_loc = np.random.uniform(0, x_lim, size=num_cities)\n            y_loc = np.random.uniform(0, y_lim, size=num_cities)\n            self.city_locations = [\n                (x,y) for x,y in zip(x_loc,y_loc)\n            ]\n        self.distances = self.calculate_distances()\n\n    def calculate_distances(self):\n        distances = np.zeros((self.num_cities, self.num_cities))\n        for i in range(self.num_cities):\n            for j in range(i + 1, self.num_cities):\n                dist = np.sqrt((self.city_locations[i][0] - self.city_locations[j][0]) ** 2 + (self.city_locations[i][1] - self.city_locations[j][1]) ** 2)\n                distances[i][j] = distances[j][i] = dist\n        return distances\n\n    def fitness(self, solution):\n        total_distance = 0\n        for i in range(self.num_cities - 1):\n            total_distance += self.distances[solution[i]][solution[i+1]]\n        fitness = -total_distance\n        return fitness\n\n    def visualize(self, solution, save_id=None):\n        n = len(solution)\n        assert n == len(self.city_locations), 'The solution must correspond to all cities'\n        for i, (x,y) in enumerate(self.city_locations):\n            plt.plot(x, y, \"ro\")\n            plt.annotate(i, (x, y))\n\n        ordered_cities = [self.city_locations[idx] for idx in solution]\n        x_coord = [x for (x,y) in  ordered_cities]\n        y_coord = [y for (x,y) in  ordered_cities]\n        distance = -self.fitness(solution)\n\n        plt.plot(x_coord, y_coord, \"gray\")\n        plt.title(\"Connected cities (%.1f) according to solution\" % distance)\n        if save_id is not None:\n            filename = \"results/plot_%03d.png\" % save_id\n            plt.savefig(filename, bbox_inches='tight')\n            plt.close()\n        else:\n            plt.show()\n```", "```py\nsalesman = Salesman(\n    num_cities=30, x_lim=100, y_lim=100, read_from_txt='city_locations.txt'\n)\nevo = Evolutionary(salesman)\nbest_genome = evo.run_evolution(\n    population_size=200, generation_limit=1000, crossover='pmx', verbose=True\n)\nsalesman.visualize(best_genome)\n```"]