- en: Data-Oriented Programming in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/data-oriented-programming-with-python-ef478c43a874](https://towardsdatascience.com/data-oriented-programming-with-python-ef478c43a874)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A recap on *Data-Oriented Programming* by Yehonathan Sharvit but illustrated
    with Python examples (instead of JavaScript and Java)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@tamdtranthe?source=post_page-----ef478c43a874--------------------------------)[![Tam
    D Tran-The](../Images/2d1fcc2d5bfda09f26719c3a86817836.png)](https://medium.com/@tamdtranthe?source=post_page-----ef478c43a874--------------------------------)[](https://towardsdatascience.com/?source=post_page-----ef478c43a874--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----ef478c43a874--------------------------------)
    [Tam D Tran-The](https://medium.com/@tamdtranthe?source=post_page-----ef478c43a874--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----ef478c43a874--------------------------------)
    ·12 min read·May 12, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0394f0fd53608e090d14270536bf6869.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [AltumCode](https://unsplash.com/@altumcode?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: '[*Data-Oriented Programming*](https://www.manning.com/books/data-oriented-programming?utm_source=medium&utm_medium=referral&utm_campaign=book_sharvit2_data_1_29_21)
    by Yehonathan Sharvit is a great book that gives a gentle introduction to the
    concept of data-oriented programming (DOP) as an alternative to good old object-oriented
    programming (OOP). Sharvit deconstructs the elements of complexity that sometimes
    seems inevitable with OOP and summarizes the main principles of DOP that helps
    us make the system more manageable.'
  prefs: []
  type: TYPE_NORMAL
- en: As its name suggests, DOP puts data first and foremost. This can be achieved
    by adhering to four main principles. These principles are language-agnostic. They
    can be represented in OOP languages (Java, C++, etc.), functional programming
    (FP) languages (Clojure, etc.) or general-purpose languages (Python, JavaScript).
    Whereas the author illustrates his examples using JavaScript and Java, this article
    attempts to demonstrate the ideas in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Following along the article, you’ll find simple code snippets in Python that
    illustrate how each principle can be adhered to or broken. Sharvit also clarifies
    what the benefits and costs for each principle — many of them are relevant in
    Python whereas some are not.
  prefs: []
  type: TYPE_NORMAL
- en: Please note all the principles, corresponding advantages and drawbacks mentioned
    are credited to Yehonathan Sharvit, whereas the viewpoints on the applicability
    of these statements to Python, in conjunction with the Python code illustrations,
    are my own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Principle #1: Separate code from data'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: “Separate code from data in a way that the code resides in functions whose behavior
    does not depend on data that is encapsulated in the function’s context.” — Yehonathan
    Sharvit
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A natural way of adhering to this principle in Python is to use top-level functions
    (for code) and data classes that only have fields (for data). Whereas Sharvit
    illustrates in his book how to follow this principle in OOP and FP (functional
    programming) separately, my example in Python is a hybrid of OOP and FP.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the code snippet below as an example where code (behavior) is separated
    from data (facts/information).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Benefit # 1: “**Code can be reused in different contexts” — Yehonathan Sharvit'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As seen from the example above, `calculate_name()` can be used not only for
    authors but also for users, librarians, or anyone that has a first name and a
    last name field. The code that deals with full name calculation is separate from
    the code that deals with the creation of author data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Benefit # 2: “**Code can be tested in isolation” — Yehonathan Sharvit'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Below is an example that doesn’t adhere to Principle #1.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In order to test the `full_name()` property that lives inside the `Author` class,
    we need to instantiate the `Author` object, which requires us to have values for
    all attributes, including those unrelated to the behavior we are testing (such
    as `n_books` and `address` custom class). This is an unnecessarily complex and
    tedious setup just to test a single method.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, in the DOP version, to test `calculate_name()` code, we can
    create data to be passed into the function in isolation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Cost # 1:** “No control on what code can access what data” — Yehonathan Sharvit'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “…in OOP, the data is encapsulated in an object, which guarantees that the data
    is accessible only by the object’s methods. In DOP, since data stands on its own,
    it can be accessed by any piece of code…which is inherently unsafe.” — Yehonathan
    Sharvit
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**This statement is not applicable in Python.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, data held by a class can still be accessed by any piece of code
    that has a reference to the object. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Also, unless we store data in a global variable, we can still use scopes (functions,
    loops, etc.) to control who can access/change data in Python.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cost #2:** “There is no packaging” — Yehonathan Sharvit'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “In DOP, the code that manipulates the data could be anywhere. This might make
    it difficult for developers to discover that `[a specific function]` is available,
    which could lead to wasted time and duplicated code.” — Yehonathan Sharvit
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is true with our Python example above. For instance, our `AuthorData` data
    class might be in one file and `calculate_name()` function might be in another
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Principle #2: Represent data with generic data structures'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: “In DOP, data is represented with generic data structures, such as maps (or
    dictionaries) and arrays (or lists).” — Yehonathan Sharvit
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In Python, our built-in options for generic data structures are `dict` , `list`
    , and `tuple`.
  prefs: []
  type: TYPE_NORMAL
- en: In this article, I use Python’s `dataclass` , which can be thought of as a “mutable
    named tuple with defaults.” Note that this was not what Sharvit meant by “generic
    data structure.” Python’s `dataclass` is a hybrid that is closer to OOP than DOP.
    However, compared with dictionaries and tuples, this alternative is less susceptible
    to typos, more descriptive with type hinting, helps represent nested complex structure
    in a clearer and more concise way, and more. Also, it can easily be turned into
    a dictionary or a tuple if we want to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Benefit #1:** “The ability to use generic functions that are not limited
    to our specific use case” — Yehonathan Sharvit'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given generic structures, we can manipulate data using a rich set of built-in
    Python functions available on `dict`, `list`, `tuple`, etc.
  prefs: []
  type: TYPE_NORMAL
- en: Below are a few examples of generic functions that can be used to manipulate
    data stored in a `dict` .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This means we don’t have to learn and remember the custom methods of everyone’s
    classes. Also, the generic functions can’t break if we change some library versions.
    They only break if the Python language changes them (which almost never happens).
  prefs: []
  type: TYPE_NORMAL
- en: '**Benefit #2: “**Flexible data model” — Yehonathan Sharvit'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “When using generic data structures, data can be created with no predefined
    shape, and its shape can be modified at will.” — Yehonathan Sharvit
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the example below, not all the dictionaries in the list have the same keys.
    The extra keys can exist in the second dictionary as long as the required fields
    are present.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**Cost #1**: “Performance hit” — Yehonathan Sharvit'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**This does not entirely translate to Python.**'
  prefs: []
  type: TYPE_NORMAL
- en: In Python, there is not much difference in performance between retrieving value
    of a class member and retrieving value associated to a key in a dictionary. Unlike
    Java, there is no compilation step in Python, which means there is no compiler
    optimization when it comes to accessing a class member.
  prefs: []
  type: TYPE_NORMAL
- en: However, not all generic data structures are equal. Lookup time for `set` and
    `dict` is more efficient than that for `list` and `tuple` , given that sets and
    dictionaries use hash function to determine any particular piece of data is right
    away, without a search.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cost #2:** “No data schema” — Yehonathan Sharvit'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “When data is instantiated from a class, the information about the data shape
    is in the class definition. The existence of data schema at a class level makes
    it easy to discover the expected data shape. When data is represented with generic
    data structures, data schema is not part of the data representation.” — Yehonathan
    Sharvit
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For example, we can easily tell the data shape of `FullName` which is instantiated
    as a class object below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Cost #3:** “No compile-time check that the data is valid” — Yehonathan Sharvit'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '***This does not entirely translate to Python.***'
  prefs: []
  type: TYPE_NORMAL
- en: Again, there is no compilation step in Python as in Java. The only compile-time
    checking for Python would be running a tool like [mypy](https://mypy-lang.org/).
  prefs: []
  type: TYPE_NORMAL
- en: However, Sharvit’s example about how data shape errors could slip through the
    crack with generic data structures can still somewhat be demonstrated in Python
    as below.
  prefs: []
  type: TYPE_NORMAL
- en: 'When data is passed to the `FullName` class that does not conform to the shape
    it expects, an error occurs at run time. For example, if we mistype the field
    that stores first name ( `fist_name` instead of `first_name` ), we would get `TypeError:
    __init__() got an unexpected keyword argument ''fist_name''`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: However, with generic data structures, mistyping the field might not result
    in an error or an exception. Rather, first name is mysteriously omitted from the
    result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**Cost #4:** “The need for explicit type casting” — Yehonathan Sharvit'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**This does not translate to Python.**'
  prefs: []
  type: TYPE_NORMAL
- en: Python is a dynamically typed language. It does not require explicit type casting.
  prefs: []
  type: TYPE_NORMAL
- en: '**Principle # 3:** Data is immutable'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: “According to DOP, data should never change! Instead of mutating data, a new
    version of it is created.” — Yehonathan Sharvit
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To adhere to this principle, we make our `dataclass`frozen (i.e. immutable).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The immutable data types in built-in Python are `int` , `float` , `decimal`
    , `bool` , `string` , `tuple` and `range` . Note that `dict` , `list` and `set`
    are mutable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Benefit #1:** “Data access to all with confidence” — Yehonathan Sharvit'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “When data is mutable, we must be careful when passing data as an argument to
    a function since it can be mutated or cloned.” — Yehonathan Sharvit
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the example below, we originally pass an empty list as a default argument
    to the function. Since list is a mutable object, every time we call the function,
    the list gets mutated and a different default value gets used in the successive
    call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To fix the use case above, we can do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This code works as expected because `None` is immutable.
  prefs: []
  type: TYPE_NORMAL
- en: “When data is immutable, it can be passed to any function with confidence because
    data never changes.” — Yehonathan Sharvit
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Benefit #2:** “Predictable code behavior” — Yehonathan Sharvit'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here is an example of an unpredictable piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The value of `age` in `dummy` dictionary is not predictable. It depends on whether
    you run the code on an even or odd day.
  prefs: []
  type: TYPE_NORMAL
- en: However, with immutable data, it is guaranteed that data never changes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The piece of code above would error out, saying `dataclasses.FrozenInstanceError:
    cannot assign to field "n_books"` . With frozen data class, no matter it’s an
    even or odd day, `author_data.n_books` is always 500.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Benefit #3:** “Fast equality checks” — Yehonathan Sharvit'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Python has two similar operators for checking whether two objects are equal:
    `is` and `==` . `is` checks for identity (of objects) by comparing the integer
    equality of the memory address. `==` checks for equality (of values) by examining
    the actual content stored.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As seen above, `is` and `==` behaves the same way for `x` which is a string
    (i.e. immutable data type) but behaves differently for `y` which is a list (i.e.
    mutable data type). With immutable data objects, `is` behaves more predictably.
    Also,`is` is generally faster than `==` because comparing object addresses is
    faster than comparing all the fields. Immutable data thus enables fast equality
    checks by comparing data by reference.
  prefs: []
  type: TYPE_NORMAL
- en: '**Benefit #4: “**Free concurrency safety” — Yehonathan Sharvit'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'When data is mutable in a multi-thread environment, race condition failure
    can occur. For example, assuming that two threads are attempting to access and
    modify the value of `x` by adding/subtracting 10 to/from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/42945abfdf05c73ba8a011aa74410985.png)'
  prefs: []
  type: TYPE_IMG
- en: Race condition failure example. Image by Author.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three possible answers: `x=90` , `x=100` , and `x=110` . Depending
    on the order of execution, the program’s behavior changes each time it is run,
    which is not safe and vulnerable to corruption. To ensure concurrency safety,
    data should be in an immutable state.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cost #1:** “Performance hit” — Yehonathan Sharvit'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given that `list` is mutable and `tuple` is immutable, as we expand both objects,
    `list` identity remains the same whereas a brand new `tuple` is created with a
    different identity.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The need to copy contents of immutable object into a new object every time we
    modify it requires additional memory and creates added cost on CPU power, especially
    for very large collections.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cost #2:** “Required library for immutable data structures” — Yehonathan
    Sharvit'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**This does not translate to Python.**'
  prefs: []
  type: TYPE_NORMAL
- en: '`frozenset` and `tuple` are some basic built-in immutable data structures in
    Python. We are not always required to include a third-party library to adhere
    to data immutability principle.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Principle #4: Separate data schema from data representation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: “In DOP, the expected shape of data is represented as (meta) data that is kept
    separately from the main data representation.” — Yehonathan Sharvit
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Given below is a basic JSON schema (essentially a dictionary) that describes
    the format of data which is also represented as a dictionary. The schema defines
    which fields are required and the data types of the fields, whereas the data is
    represented by a generic data structure per Principle #3.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Data validation functions (or libraries) can be used to check whether a piece
    of data conforms to a data schema.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `validate` function passes through when data is valid or returns errors
    with details in a human readable format when data is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '**Benefit #1:** “Optional fields” — Yehonathan Sharvit'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “In OOP, allowing a class member to be optional is not easy. In DOP, it is natural
    to declare a field as optional in a map.” —Yehonathan Sharvit
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**This does not translate to Python.**'
  prefs: []
  type: TYPE_NORMAL
- en: In Python, even with OOP, allowing a class member to be optional is not hard.
    This benefit is therefore not strong in the context of Python. For example, below
    we can set the default argument of `n_books` to `None` to indicate the field is
    optional.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**Benefit #2:** “Advanced data validation conditions” — Yehonathan Sharvit'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “In DOP, data validation occurs at run time. It allows the definition of data
    validation conditions that go beyond the type of a field.” — Yehonathan Sharvit
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Compared with the minimal schema defined above, the following schema can be
    expanded to include more properties for each field.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: While not all the advantages and disadvantages of DOP principles mentioned by
    Sharvit directly apply to Python, the fundamental principles remain robust. This
    approach promotes code that is easier to reason about, test and maintain. By embracing
    the principles and techniques of DOP, Python programmers can create more maintainable
    and scalable code, and unlock the full potential of their data.
  prefs: []
  type: TYPE_NORMAL
- en: '*Special thanks to* [*Eddie Pantridge*](https://medium.com/u/85a05f1243a6?source=post_page-----ef478c43a874--------------------------------)
    *for his thoughtful comments and efforts towards improving this article.*'
  prefs: []
  type: TYPE_NORMAL
