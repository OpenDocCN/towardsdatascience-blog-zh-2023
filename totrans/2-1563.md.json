["```py\n>>> [1, \"two\", list, list(), list.sort]\n[1, 'two', <class 'list'>, [], <method 'sort' of 'list' objects>]\n```", "```py\n>>> x = [1, 2, \"three\"]\n>>> sum(x)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\n>>> sum(xi for xi in x if isinstance(xi, (float, int)))\n3\n```", "```py\n>>> float(\"nan\") is float(\"nan\")\nFalse\n>>> float(\"nan\") == float(\"nan\")\nFalse\n>>> math.nan is math.nan\nFalse\n>>> math.nan == math.nan\nFalse\n```", "```py\n>>> [1, 2, 3] == [1, 2, 3]\nTrue\n>>> [1, 2, float(\"nan\")] == [1, 2, float(\"nan\")]\nFalse\n```", "```py\n>>> NaN = float(\"nan\")\n>>> NaN is NaN\nTrue\n>>> NaN == NaN\nFalse\n>>> NaN = math.nan\n>>> NaNmath = math.nan\n>>> NaNmath is NaNmath\nTrue\n>>> NaNmath == NaNmath\nFalse\n```", "```py\n>>> x = [1, 2, \"three\"]\n>>> sum(xi for xi in x if isinstance(xi, (float, int)))\n3\n```", "```py\nfrom collections.abc import Sequence\nfrom typing import Any\n\ndef use_nan(__x: Sequence[float | Any]) -> Sequence[float]:\n    \"\"\"Replace non-numerical values with float(\"nan\").\n\n    >>> NaN = float(\"nan\")\n    >>> use_nan([1, 2, 3])\n    [1, 2, 3]\n    >>> use_nan([1., 2., 3.])\n    [1.0, 2.0, 3.0]\n    >>> use_nan([1, 2., 3.])\n    [1, 2.0, 3.0]\n    >>> use_nan([1, 2, \"str\"])\n    [1, 2, nan]\n    >>> use_nan((1, 2, str))\n    (1, 2, nan)\n    >>> use_nan(1., 2, Any, str, (1, 2,)))\n    (1.0, 2, nan, nan, nan)\n    \"\"\"\n    return type(__x)([xi\n                      if isinstance(xi, (float, int))\n                      else float(\"nan\")\n                      for xi in __x])\n```", "```py\n>>> x = use_nan([1, 2, float(\"nan\")])\n>>> sum(x)\nnan\n>>> import math\n>>> sum([1, 2, math.nan])\nnan\n```", "```py\n>>> x = use_nan([1, 2, \"three\"])\n>>> sum(xi for xi in x if xi is not float(\"nan\"))\nnan\n>>> sum(xi for xi in x if xi != float(\"nan\"))\nnan\n```", "```py\n>>> sum(xi for xi in x if not math.isnan(xi))\n3\n```"]