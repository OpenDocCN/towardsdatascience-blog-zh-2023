- en: 'Python Tuple, the Whole Truth, and Only the Truth: Hello, Tuple!'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/python-tuple-the-whole-truth-and-only-the-truth-hello-tuple-12a7ab9dbd0d](https://towardsdatascience.com/python-tuple-the-whole-truth-and-only-the-truth-hello-tuple-12a7ab9dbd0d)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: PYTHON PROGRAMMING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Learn the basics of tuples and of using them
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@nyggus?source=post_page-----12a7ab9dbd0d--------------------------------)[![Marcin
    Kozak](../Images/d7faf62e48ed81dab5d8ad92819fff54.png)](https://medium.com/@nyggus?source=post_page-----12a7ab9dbd0d--------------------------------)[](https://towardsdatascience.com/?source=post_page-----12a7ab9dbd0d--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----12a7ab9dbd0d--------------------------------)
    [Marcin Kozak](https://medium.com/@nyggus?source=post_page-----12a7ab9dbd0d--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----12a7ab9dbd0d--------------------------------)
    ·16 min read·Jan 21, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/74860d4642efa6cd08de3d7411205690.png)'
  prefs: []
  type: TYPE_IMG
- en: Tuples are often considered records. Photo by [Samuel Regan-Asante](https://unsplash.com/@fkaregan?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: The tuple is an immutable collection type in Python. It’s one of the three most
    popular collection types in Python, along with the list and the dictionary. While
    I think that many beginning and intermediate developers know much about these
    two types, they may have problems with truly understanding what tuples are and
    how they work. Even advanced Python developers do not have to know everything
    about tuples — and given the type’s specificity, this does not come as a surprise
    to me.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a beginning and even intermediate Python developer, I did not know much
    about the tuple. Let me show you an example; imagine I wrote a fragment of code
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you see, I used a list literal to define the `basic_names` list — but why
    not *a tuple literal*? It would look like below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The main thing we know about the tuple is that it’s immutable — and the code
    itself suggests that the `basic_names` container will *not* change. Thus, a tuple
    seems more natural here than a list, doesn’t it? So, is there any *practical*
    difference between the two approaches? Like in performance, safety, or anything
    else?
  prefs: []
  type: TYPE_NORMAL
- en: 'Such gaps in knowledge make us worse programmers. This article aims to help
    you become a better programmer, by helping you learn about one of the most important
    data type in Python, but one that many don’t know much about: the tuple. My aim
    is to make this article as thorough as possible from a practical point of view.
    So, for example, we will not talk about the details of C implementation of the
    tuple, but we will talk about the details of using tuples in Python.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tuples are a rich topic. Thus, I will split the knowledge about it into two
    parts — and two articles. Here are the topics I will cover in the first part —
    that is, here:'
  prefs: []
  type: TYPE_NORMAL
- en: The basic of tuples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using tuples: tuple unpacking and tuple methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, we will focus on the basics here. In the second part, I cover more advanced
    topics of tuples, such as inheriting from tuple, tuple performance and tuple comprehensions.
    You will find it here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/python-tuple-the-whole-truth-and-only-truth-lets-dig-deep-24d2bf02971b?source=post_page-----12a7ab9dbd0d--------------------------------)
    [## Python Tuple, The Whole Truth and Only Truth: Let’s Dig Deep'
  prefs: []
  type: TYPE_NORMAL
- en: Learn the intricacies of tuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/python-tuple-the-whole-truth-and-only-truth-lets-dig-deep-24d2bf02971b?source=post_page-----12a7ab9dbd0d--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: The basics of tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A tuple is a container of values, similar to a list. In his great book entitled
    *Fluent Python*, L. Ramalho explains that tuples were created to be *immutable
    lists*, and that this term describes the nature of tuples well. But he also says
    that tuples are not just immutable lists; they are much more than that.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, tuples can be used as records without field names. This means
    that we can have a record with several unnamed fields. Certainly, such a tuple-based
    record makes sense only when it is clear what each field represents.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you want to create a tuple in Python using a tuple literal, you need to
    use parentheses `()` instead of square brackets `[]`, as you would when creating
    a list¹:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `x_tuple_1 = (1, 2, 3)` creates a three-element tuple containing numbers
    `1`, `2`, and `3`; `x_tuple_2 = ([1, 2], 3)` creates a two-element tuple with
    two values: a list `[1, 2]` and number `3`. As you see, you can use objects of
    any types in a tuple. You can even create a tuple of empty tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Although, to be honest, I do not know why you would want to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, so above we used a tuple literal. A second method of creating a tuple
    is using the built-in `tuple()` class. Enough to provide an iterable as an argument,
    and this will convert the iterable to a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To access values in a tuple, you can use typical indexing: `x_tuple_1[0]` will
    return `1` while `x_tuple_2[0]` will return a list, `[1, 2]`. Note that since
    `x_tuple_2[0]` is a list, you can access its elements using its indices — so,
    you will use multiple (here, double) indexing; for example, `x_tuple_2[0][0]`
    will return `1` while `x_tuple_2[0][1]` will return `2`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The biggest difference between lists and tuples is that lists are mutable,
    so you can change them, while tuples are immutable, so you cannot change them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you see, you cannot use item assignment with tuples. This feature makes tuples
    less error prone than lists, as you can be sure (actually, almost sure, as we
    will discuss below) that tuples will not change. You can be sure, however, that
    their length will not change.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a common interview question about tuples: *Since tuples are immutable,
    you cannot change their values, right?* And the answer to this very question is:
    *Well*…'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is because you can change values of mutable elements of a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: So, although tuples are immutable, if their elements are not, you can change
    these elements, and so, at least indirectly, you can change the tuple. This makes
    it possible to change an unchangeable…
  prefs: []
  type: TYPE_NORMAL
- en: If you’re feeling confused, at least clothe yourself with the fact that you’re
    not alone. You’re just one of many. However, this kind of immutability makes sense,
    at least theoretically, so let me explain what’s going on here.
  prefs: []
  type: TYPE_NORMAL
- en: The whole truth lies in the following. Like other collections, tuples do not
    contain objects but references to them; being immutable means being immutable
    in terms of these references. Therefore, once created, a tuple will always contain
    the same set of references.
  prefs: []
  type: TYPE_NORMAL
- en: '*In theory*, when an object being referenced to by one of a tuple’s references
    changes, the tuple remains the same: it’s still the very same tuple, with the
    very same references.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*In practice* (that is, from our typical/natural point of view), when an object
    being referenced to by one of a tuple’s references changes, the tuple *seems to*
    have changed: despite the very same references, one of the objects changed, so,
    in practice, the tuple *looks* different than it did before this change. But theoretically,
    the tuple (a collection of references) has not changed whatsoever.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like other collections, tuples do not contain objects but references to them;
    being immutable means being immutable in terms of these references.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Okay, now that we know how tuple immutability works, we should remember to think
    that way about tuples, too. But knowing something does not have to mean that getting
    used to it will be easy. It’s not that easy to think of immutability that way.
    Remember, from now on you should remember that a tuple is an immutable collection
    of references to objects, not an immutable collection of objects. The values of
    objects a tuple contains can actually change — but the objects must stay the same…
    Already feeling a headache? It’s just the beginning…
  prefs: []
  type: TYPE_NORMAL
- en: Let’s think of a typical length of tuples. To add some context, however, we
    should consider what it looks like in lists. I think it’s safe to say that both
    short and long lists are frequently used. You can create a list using various
    methods, like a literal, a `for` loop, the `list()` method, and a list comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: 'Immutable, tuples do not work like that. You cannot update them in a `for`
    loop (unless you’re updating their mutable elements) or a [comprehension](/a-guide-to-python-comprehensions-4d16af68c97e).
    You can create a tuple in two ways, using a tuple literal, like here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'or calling the `tuple()` class (`tuple()` is a callable class) to an iterable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: My guess is that the former use case is far more frequent. Perhaps the most
    frequent use of the tuple is to return values from a function, especially when
    it’s two or three values (you would seldom (if ever) do this for ten values).
  prefs: []
  type: TYPE_NORMAL
- en: 'When a tuple literal is short, quite often the parentheses are omitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This approach is often used with `return` statements, but not only. Is any of
    the two — with or without parentheses — better? Generally, no; but it depends
    on the situation. Sometimes the parentheses will make the code clearer, and some
    other times their absence will.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do remember about non-parentheses tuples, as they can be a source of bugs that
    are difficult to find; see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://betterprogramming.pub/find-a-bug-in-python-code-a-little-thing-does-so-much-89d0abd0300c?source=post_page-----12a7ab9dbd0d--------------------------------)
    [## Find a Bug in Python Code: A Little Thing Does So Much'
  prefs: []
  type: TYPE_NORMAL
- en: Even the smallest characters can introduce big problems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: betterprogramming.pub](https://betterprogramming.pub/find-a-bug-in-python-code-a-little-thing-does-so-much-89d0abd0300c?source=post_page-----12a7ab9dbd0d--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 'To put it simply, when you forget about a comma at the end of a line, you may
    be using a tuple with an object instead of the object itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You may think that `x` is a set with three elements, but in fact it’s a tuple
    with one element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you see, this one single comma put after instead of before the right curly
    bracket made `x` a one-element tuple.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tuples offer fewer methods than lists, but still quite a few. Some of them
    are better known than others; some are even very little known and used rather
    infrequently. In this section, we we discuss two important aspects of using tuples:
    tuple methods and unpacking tuples.'
  prefs: []
  type: TYPE_NORMAL
- en: Unpacking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A fantastic feature of tuples is *tuple unpacking*. You can use it to assign
    a tuple’s values to multiple names at once. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, `a` would become `1`, `b` would become `2`, and `c` would become 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the below example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use special unpacking syntax using the asterisk, `*`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As you see, when you attach the asterisk `*` to a name, it’s like saying, “Unpack
    this very item and all next ones to this name.” So:'
  prefs: []
  type: TYPE_NORMAL
- en: '`a, b*` means unpack the first element to `a` and all the remaining ones to
    `b`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*a, b` means unpack the last element to `b` and all those before to `a`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a, *b, c` means unpack the first element to `a`, the last element to `c`,
    and all the in-between elements to `b`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With more elements in a tuple, you can consider more scenarios. Imagine you
    have a tuple of seven elements, and you’re interested in the first two and the
    last one. You can use unpacking to get and assign them to names in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Note here one more thing. I used `*_`, as I needed to extract only these three
    values, and the other ones can be ignored. Here, the underscore character, `_`,
    means exactly that: I don’t care what these other values from the tuple are, and
    so let’s ignore them. If you use a name instead, the reader of the code would
    think that the name is used somewhere in the code — but also your IDE would scream
    at you for assigning values to a name that isn’t used anywhere in the scope².'
  prefs: []
  type: TYPE_NORMAL
- en: Tuple unpacking can be used in various scenarios, but it’s particularly useful
    when you’re assigning values returned from a function or method that returns a
    tuple. The below example shows the usefulness of unpacking values returned from
    a function/method.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create a `Rectangle` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As you see, the `Rectangle.summarize()` method returns two values organized
    in a tuple: the rectangle’s area and perimeter. If we want to assign these values
    to names, we could do as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the above approach is not a good one, among others for clarity reasons,
    and we can do it much more effectively using tuple unpacking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it’s clearer and shorter: just one line instead of three. In
    addition, it does not use indexing to get the values from the tuple. Indexing
    decreases readability, and it’d be better to use names instead of positions. We
    will discuss this below, in the section on inheriting from the `tuple` class and
    on named tuples. But remember that when a function/method returns a tuple — quite
    a frequent situation — you should unpack these values instead of assign them directly
    using tuple indexing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One more example, also using a `dataclass`³:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The above examples show the most frequent use cases of tuple unpacking. Nonetheless,
    we can sometimes need to unpack values from a nested data structure based on tuples.
    Consider the following example. Imagine that we have a list of cities like above,
    a city being represented by a list inside a dictionary, not a `dataclass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As you see, we have the coordinates of the cities organized as tuples inside
    the list. We can use nested unpacking to get the coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we may need also the area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Again, I have again used the underscore character, `_`, to assign a value we
    don’t need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that what we do with `*args` is exactly unpacking. By putting `*args`
    inside a function’s arguments, you let the users know they can use any arguments
    there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, `*args` collects all the positional (not keyword!) arguments into the
    `args` tuple. This `return` statement enables us to see these arguments in the
    `args` tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'One more thing: unpacking is not reserved for tuples, and you can use it to
    other iterables, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Tuple methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python beginners learn about tuples rather quickly. With time, they learn a
    little more about them, mainly their immutability and its consequences. But many
    developers do not know all the methods the `tuple` class offers. To be honest,
    before writing this article, I did not know them when I was considering myself
    quite an advanced developer. But it’s good to know these methods — and this subsection
    aims to help you learn them.
  prefs: []
  type: TYPE_NORMAL
- en: 'It does not mean you need to use all of them. But it’s good, for example, to
    remember that you can use in-place operations on tuples, and what they lead to.
    This knowledge is enough to recall that there are only two in-place operations
    for tuples: in-place concatenation and in-place repeated concatenation.'
  prefs: []
  type: TYPE_NORMAL
- en: To learn the methods, let’s peek into *Fluent Python* again. We will find there
    a nice table with the comparison of the list’s and the tuple’s methods, from which
    we can extract the latter. Hence, below, you will find a complete list of methods
    of the `tuple` class, each accompanied by one or more simple examples.
  prefs: []
  type: TYPE_NORMAL
- en: '*Get length*: `len(x)`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Concatenation*: `x + y`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Repeated concatenation*: `x * n`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Reversed repeated concatenation*: `n * x`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*In-place concatenation*: `x += y`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax of in-place concatenation may suggest that we’re dealing with the
    same object: we started with tuple `x` that was equal to `(1, 2, 3)`; after concatenating
    `y`, `x` was still a tuple, but it contained six values: `(1, 2, 3, "a", "b",
    "c")`. Since we discussed tuple immutability, we know that the `x` before and
    the `x` after were two different objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily check this using the following simple test. It uses the two objects’
    `id`s: if they have the same `id`, they are one and the same object, but if the
    `id`s differ, `x` before the in-place concatenation and `x` after it are two different
    objects. Let’s do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The two `id`s differ, meaning that `x` after the in-place operation is a different
    object than `x` before it.
  prefs: []
  type: TYPE_NORMAL
- en: '*In-place repeated concatenation*: `x *= n`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'What I wrote above applies here, too: although we see just one name here, `x`,
    we have two objects: the before `x` and the after `x`.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Contains*:`in`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '*Count occurrences of an element*: `x.count(element)`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '*Get item at position*:`x[i]` (`x.__getitem__(i)`)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '*Find position of first occurrence of* `element`: `x.index(element)`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '*Get iterator*: `iter(x)` (`x.__iter__()`)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '*Support for optimized serialization with* `pickle`: `x.__getnewargs__()`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is not to be used like the above ones, in a direct way. Instead,
    it’s used during pickling to optimize tuples’ pickling, like in the below toy
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In his fantastic book *Fluent Python* (2nd edition), Luciano Ramalho lists 15
    methods that that the list has but the tuple does not— but this one, the optimized
    pickling optimization, is the *only* method that the tuple has and the list does
    not.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3d0766b50bbdc25cfa5ecbb9dde984d7.png)'
  prefs: []
  type: TYPE_IMG
- en: Word “tuple” in various languages. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this article, we’ve discussed the basics of one of the most common Python
    collection types, the tuple. I hope you’ve enjoyed this — and if you did, be aware
    that what we’ve discussed was not only basic but also, how to say it, uncontroversial.
  prefs: []
  type: TYPE_NORMAL
- en: There’s much more into tuples, however, and some of it is not as clear as what
    we’ve learned from this article. We will discuss this in the continuation of this
    article. You will see there that tuples are not an easy topic, as you might think
    after reading this article. No, in my opinion tuples are more controversial than
    any other built-in type. Perhaps even tuples are overused — but I will let you
    decide yourself after reading the next article. But to be honest, there are things
    about tuples I don’t like. In fact, I will be a little harsh for tuples… Rather
    much… Maybe even too much?
  prefs: []
  type: TYPE_NORMAL
- en: 'I hope I have intrigued you enough for you to read the continuation of this
    article. You will find it here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/python-tuple-the-whole-truth-and-only-truth-lets-dig-deep-24d2bf02971b?source=post_page-----12a7ab9dbd0d--------------------------------)
    [## Python Tuple, The Whole Truth and Only Truth: Let’s Dig Deep'
  prefs: []
  type: TYPE_NORMAL
- en: Learn the intricacies of tuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/python-tuple-the-whole-truth-and-only-truth-lets-dig-deep-24d2bf02971b?source=post_page-----12a7ab9dbd0d--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 'Thank you for reading. If you enjoyed this article, you may also enjoy other
    articles I wrote; you will see them [here](https://medium.com/@nyggus). If you
    want to join Medium, please use my referral link below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/@nyggus/membership?source=post_page-----12a7ab9dbd0d--------------------------------)
    [## Join Medium with my referral link — Marcin Kozak'
  prefs: []
  type: TYPE_NORMAL
- en: Read every story from Marcin Kozak (and thousands of other writers on Medium).
    Your membership fee directly supports…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/@nyggus/membership?source=post_page-----12a7ab9dbd0d--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Footnotes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ¹ Note that in many code blocks, like the one above, I use `doctest` testing,
    in order to assure that the examples work correctly. You can read more about `doctest`
    in the module’s [documentation](https://docs.python.org/3/library/doctest.html)
    and [this introductory article published in *Towards Data Science*](https://medium.com/towards-data-science/python-documentation-testing-with-doctest-the-easy-way-c024556313ca).
  prefs: []
  type: TYPE_NORMAL
- en: ² Note that I wrote “in scope” and not “in code”. This is because while we do
    not need these values here, we can need them elsewhere in the code, in some other
    scope (e.g., in another function). Using particular unpacking in a particular
    scope only affects this scope; hence, we can unpack the same iterable once more,
    in another scope, and this unpacking can be different.
  prefs: []
  type: TYPE_NORMAL
- en: ³ In the code block, you will find the `KmSquare` type alias. I used it to increase
    the readability of the floats used to define a city. You can read more about such
    type hinting and type aliasing [here](https://medium.com/better-programming/pythons-type-hinting-friend-foe-or-just-a-headache-73c7849039c7).
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[](/python-documentation-testing-with-doctest-the-easy-way-c024556313ca?source=post_page-----12a7ab9dbd0d--------------------------------)
    [## Python Documentation Testing with doctest: The Easy Way'
  prefs: []
  type: TYPE_NORMAL
- en: doctest allows for documentation, unit and integration testing, and test-driven
    development.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/python-documentation-testing-with-doctest-the-easy-way-c024556313ca?source=post_page-----12a7ab9dbd0d--------------------------------)
    [](/a-guide-to-python-comprehensions-4d16af68c97e?source=post_page-----12a7ab9dbd0d--------------------------------)
    [## A Guide to Python Comprehensions
  prefs: []
  type: TYPE_NORMAL
- en: Learn the intricacies of list comprehensions (listcomps), set comprehensions
    (setcomps), dictionary comprehensions…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'towardsdatascience.com](/a-guide-to-python-comprehensions-4d16af68c97e?source=post_page-----12a7ab9dbd0d--------------------------------)
    [](https://betterprogramming.pub/find-a-bug-in-python-code-a-little-thing-does-so-much-89d0abd0300c?source=post_page-----12a7ab9dbd0d--------------------------------)
    [## Find a Bug in Python Code: A Little Thing Does So Much'
  prefs: []
  type: TYPE_NORMAL
- en: Even the smallest characters can introduce big problems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: betterprogramming.pub](https://betterprogramming.pub/find-a-bug-in-python-code-a-little-thing-does-so-much-89d0abd0300c?source=post_page-----12a7ab9dbd0d--------------------------------)
    [](https://www.oreilly.com/library/view/fluent-python-2nd/9781492056348/?source=post_page-----12a7ab9dbd0d--------------------------------)
    [## Fluent Python, 2nd Edition
  prefs: []
  type: TYPE_NORMAL
- en: Python's simplicity lets you become productive quickly, but often this means
    you aren't using everything it has to…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: www.oreilly.com](https://www.oreilly.com/library/view/fluent-python-2nd/9781492056348/?source=post_page-----12a7ab9dbd0d--------------------------------)
  prefs: []
  type: TYPE_NORMAL
