["```py\nimport numpy as np\nimport pandas as pd\n\ndf = pd.read_csv('diabetes.csv')\ndf.info()\n```", "```py\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 768 entries, 0 to 767\nData columns (total 9 columns):\n #   Column                    Non-Null Count  Dtype  \n---  ------                    --------------  -----  \n 0   Pregnancies               768 non-null    int64  \n 1   Glucose                   768 non-null    int64  \n 2   BloodPressure             768 non-null    int64  \n 3   SkinThickness             768 non-null    int64  \n 4   Insulin                   768 non-null    int64  \n 5   BMI                       768 non-null    float64\n 6   DiabetesPedigreeFunction  768 non-null    float64\n 7   Age                       768 non-null    int64  \n 8   Outcome                   768 non-null    int64  \ndtypes: float64(2), int64(7)\nmemory usage: 54.1 KB\n```", "```py\ndf\n```", "```py\n#---check for 0s---\nprint(df.eq(0).sum())\n```", "```py\nPregnancies                 111\nGlucose                       5\nBloodPressure                35\nSkinThickness               227\nInsulin                     374\nBMI                          11\nDiabetesPedigreeFunction      0\nAge                           0\nOutcome                     500\ndtype: int64\n```", "```py\ndf[['Glucose','BloodPressure','SkinThickness',\n    'Insulin','BMI']] = \\\n    df[['Glucose','BloodPressure','SkinThickness',\n        'Insulin','BMI']].replace(0,np.NaN)\ndf\n```", "```py\ndf.fillna(df.mean(), inplace = True)   # replace the rest of the NaNs with the mean\n```", "```py\nprint(df.eq(0).sum())\n```", "```py\nPregnancies                 111\nGlucose                       0\nBloodPressure                 0\nSkinThickness                 0\nInsulin                       0\nBMI                           0\nDiabetesPedigreeFunction      0\nAge                           0\nOutcome                     500\ndtype: int64\n```", "```py\ncorr = df.corr()\nprint(corr)\n```", "```py\n Pregnancies  Glucose  BloodPressure  SkinThickness  \\\nPregnancies                      1.00     0.13           0.21           0.08   \nGlucose                          0.13     1.00           0.22           0.19   \nBloodPressure                    0.21     0.22           1.00           0.19   \nSkinThickness                    0.08     0.19           0.19           1.00   \nInsulin                          0.06     0.42           0.07           0.16   \nBMI                              0.02     0.23           0.28           0.54   \nDiabetesPedigreeFunction        -0.03     0.14          -0.00           0.10   \nAge                              0.54     0.27           0.32           0.13   \nOutcome                          0.22     0.49           0.17           0.22   \n\n                          Insulin  BMI  DiabetesPedigreeFunction  Age  Outcome  \nPregnancies                  0.06 0.02                     -0.03 0.54     0.22  \nGlucose                      0.42 0.23                      0.14 0.27     0.49  \nBloodPressure                0.07 0.28                     -0.00 0.32     0.17  \nSkinThickness                0.16 0.54                      0.10 0.13     0.22  \nInsulin                      1.00 0.17                      0.10 0.14     0.21  \nBMI                          0.17 1.00                      0.15 0.03     0.31  \nDiabetesPedigreeFunction     0.10 0.15                      1.00 0.03     0.17  \nAge                          0.14 0.03                      0.03 1.00     0.24  \nOutcome                      0.21 0.31                      0.17 0.24     1.00 \n```", "```py\n%matplotlib inline\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(10, 10))\ncax     = ax.matshow(corr,cmap='coolwarm', vmin=-1, vmax=1)\n\nfig.colorbar(cax)\nticks = np.arange(0,len(df.columns),1)\nax.set_xticks(ticks)\n\nax.set_xticklabels(df.columns)\nplt.xticks(rotation = 90)\n\nax.set_yticklabels(df.columns)\nax.set_yticks(ticks)\n\n#---print the correlation factor---\nfor i in range(df.shape[1]):\n    for j in range(9):\n        text = ax.text(j, i, round(corr.iloc[i][j],2),\n                       ha=\"center\", va=\"center\", color=\"w\")\nplt.show()\n```", "```py\n#---get the top four features that has the highest correlation---\nprint(df.corr().nlargest(4, 'Outcome').index)\n\n#---print the top 4 correlation values---\nprint(df.corr().nlargest(4, 'Outcome').values[:,8])\n```", "```py\nIndex(['Outcome', 'Glucose', 'BMI', 'Age'], dtype='object')\n[1\\.         0.49292767 0.31192439 0.23835598]\n```", "```py\nfrom sklearn import linear_model\nfrom sklearn.model_selection import cross_val_score\n\n#---features---\nX = df[['Glucose','BMI','Age']]\n\n#---label---\ny = df.iloc[:,8]\n\nlog_regress = linear_model.LogisticRegression()\nlog_regress_score = cross_val_score(log_regress, X, y, cv=10, scoring='accuracy').mean()\n\nprint(log_regress_score)\n```", "```py\nresult = []\nresult.append(log_regress_score)\n```", "```py\nfrom sklearn.neighbors import KNeighborsClassifier\n\n#---empty list that will hold cv (cross-validates) scores---\ncv_scores = []\n\n#---number of folds---\nfolds = 10\n\n#---creating odd list of K for KNN---\nks = list(range(1,int(len(X) * ((folds - 1)/folds)), 2))\n\n#---perform k-fold cross validation---\nfor k in ks:\n    knn = KNeighborsClassifier(n_neighbors=k)\n    score = cross_val_score(knn, X, y, cv=folds, scoring='accuracy').mean()\n    cv_scores.append(score)\n\n#---get the maximum score---\nknn_score = max(cv_scores)\n\n#---find the optimal k that gives the highest score---\noptimal_k = ks[cv_scores.index(knn_score)]\n\nprint(f\"The optimal number of neighbors is {optimal_k}\")\nprint(knn_score)\nresult.append(knn_score)\n```", "```py\nThe optimal number of neighbors is 19\n0.7721462747778537\n```", "```py\nfrom sklearn import svm\n\nlinear_svm = svm.SVC(kernel='linear')\nlinear_svm_score = cross_val_score(linear_svm, X, y,\n                                   cv=10, scoring='accuracy').mean()\nprint(linear_svm_score)\nresult.append(linear_svm_score)\n```", "```py\nrbf = svm.SVC(kernel='rbf')\nrbf_score = cross_val_score(rbf, X, y, cv=10, scoring='accuracy').mean()\nprint(rbf_score)\nresult.append(rbf_score)\n```", "```py\nalgorithms = [\"Logistic Regression\", \"K Nearest Neighbors\", \"SVM Linear Kernel\", \"SVM RBF Kernel\"]\ncv_mean = pd.DataFrame(result,index = algorithms)\ncv_mean.columns=[\"Accuracy\"]\ncv_mean.sort_values(by=\"Accuracy\",ascending=False)\n```", "```py\n#---features---\nX = df.iloc[:,:8]\n\n#---label---\ny = df.iloc[:,8]\n```", "```py\n!pip install lazypredict\n```", "```py\nimport lazypredict\n\n# for classification problem\nfrom lazypredict.Supervised import LazyClassifier\n\n# split dataset into training and testing sets\nfrom sklearn.model_selection import train_test_split\n```", "```py\nclf = LazyClassifier(verbose=0, ignore_warnings=True, \n                     custom_metric = None, predictions=True)\n```", "```py\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=.2, random_state = 42)\n```", "```py\nscores, predictions = clf.fit(X_train, X_test, y_train, y_test)\nscores\n```", "```py\npredictions\n```", "```py\nfrom lazypredict.Supervised import LazyRegressor\nfrom sklearn.model_selection import train_test_split\nfrom sklearn import datasets\n\n# load the Boston dataset\ndata = datasets.load_boston()\nX, y = data.data, data.target\n\n# split the data\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=.2, random_state=42)\n\nclf = LazyRegressor(predictions=True)\n\n# fit the data using different algorithms\nmodels, predictions = clf.fit(X_train, X_test, y_train, y_test)\nmodels\n```", "```py\npredictions\n```"]