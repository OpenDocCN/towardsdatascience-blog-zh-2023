- en: Slicing A Pandas Dataframe Using “&” and “|” Instead of “and” and “or”
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/slicing-a-pandas-dataframe-using-and-instead-of-and-and-or-eca8fed7751](https://towardsdatascience.com/slicing-a-pandas-dataframe-using-and-instead-of-and-and-or-eca8fed7751)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 3-MINUTES PANDAS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'when you see ValueError: The truth value of a Series is ambiguous. Use a.empty,
    a.bool(), a.item(), a.any() or a.all()'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://jianan-lin.medium.com/?source=post_page-----eca8fed7751--------------------------------)[![Yufeng](../Images/8b1a4c165aaac045ea819f850017b7cd.png)](https://jianan-lin.medium.com/?source=post_page-----eca8fed7751--------------------------------)[](https://towardsdatascience.com/?source=post_page-----eca8fed7751--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----eca8fed7751--------------------------------)
    [Yufeng](https://jianan-lin.medium.com/?source=post_page-----eca8fed7751--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----eca8fed7751--------------------------------)
    ·6 min read·Apr 14, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/500c0747fef4427deeade943cf346e84.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [TJ Arnold](https://unsplash.com/@missinformed?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Data filtering/slicing is an everyday task if you work with data.
  prefs: []
  type: TYPE_NORMAL
- en: The general idea of data slicing is to select the rows whose column values meet
    certain criteria. For example, choose the rows whose second column value is less
    than 3, the rows whose third column value is in a pre-defined list, the rows whose
    fifth column value starts with ‘ABC’, and so on ([see this post for how to do
    slicing in details](https://medium.com/towards-data-science/extract-rows-columns-from-a-dataframe-in-python-r-678e5b6743d6)).
  prefs: []
  type: TYPE_NORMAL
- en: If you do the data slicing in the Python library `pandas`and combine several
    criteria by `and`or `or`operators, you must have encountered this,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here’s an example. Let’s create a data frame in pandas,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The data frame looks like this,
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/73a4f2d2f68c867403473f925ed507ec.png)'
  prefs: []
  type: TYPE_IMG
- en: created toy data frame (image by author)
  prefs: []
  type: TYPE_NORMAL
- en: Then, by using ‘***and***’, we tried to select the persons who are at most 25
    years old but earn at least 50,000 per year.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here’s what I got,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: I used `and` to combine the two criteria together in order to get the rows that
    meet both criteria from the data frame.
  prefs: []
  type: TYPE_NORMAL
- en: I receive this “value error” because it’s ambiguous to treat a pandas series
    object as a boolean object even though that pandas series consist of boolean values.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, in the expression `(df[‘age’]<=30) and (df[‘income’]>=50000)`,
    Python tried to convert the boolean pandas Series `df[‘age’]<=30` and `df[‘income’]>=50000`
    to a single bool value first.
  prefs: []
  type: TYPE_NORMAL
- en: It’s ambiguous because Python doesn’t know whether it should assign it to `True`
    only if all the values are `True` or if any of the values are `True` . Therefore,
    it resulted in a value error.
  prefs: []
  type: TYPE_NORMAL
- en: It’s very simple to solve such a problem and the key is to avoid converting
    the pandas series to a single boolean value.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid pandas.Series() to bool conversion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the example above, we actually need an element-wise `and` between two pandas
    series. Here we go.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest solution is to change `and` to `&` .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: which yields,
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d338e8149e90459d310bbbef768a7f65.png)'
  prefs: []
  type: TYPE_IMG
- en: '& instead of `and` result (image by author)'
  prefs: []
  type: TYPE_NORMAL
- en: Same thing for the `or` operation.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we want to select the persons whose is still a student or is under
    25 years old.
  prefs: []
  type: TYPE_NORMAL
- en: Using `or` will result in the same value error as using `and` ,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Instead, we should do this,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: which yields,
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7b4b152441e492c9f3f16d9a002063fe.png)'
  prefs: []
  type: TYPE_IMG
- en: '| instead of ‘or’ result (image by author)'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we can also use the NumPy functions to achieve the same operation
    because the pandas series are built upon NumPy arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: which gives us the same result as using `&` ,
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e966a98f2aacab3cb7e56f7104c124b9.png)'
  prefs: []
  type: TYPE_IMG
- en: np.logical_and() result (image by author)
  prefs: []
  type: TYPE_NORMAL
- en: And similarly for the `or` operation,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: which yields,
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1e0eccb7f92e20eee96eee87159ec079.png)'
  prefs: []
  type: TYPE_IMG
- en: np.logical_or() result (image by author)
  prefs: []
  type: TYPE_NORMAL
- en: To make the codes look tidy, I recommend using `&` and `|` for data slicing.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid chained comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes you may get confused when you do use `&` and `|` but still get the
    same errors.
  prefs: []
  type: TYPE_NORMAL
- en: It’s a high chance that you did the chained comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: For example, by using the same data above, we want to get those persons between
    20 to 25 years old and with a GPA of at least 3.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: which yields,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Don’t confuse this error with the ones we see above. Even though the error messages
    are the same, the reason is no more about the `&` operation. It’s about the chained
    comparisons in `20<df['age']<25` .
  prefs: []
  type: TYPE_NORMAL
- en: It’s not allowed to do the chained comparisons in pandas data slicing, unfortunately.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the chained comparisons have to be split into two standalone comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now we get the correct result,
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/fa2d543f4b27336ceecb74047e64362f.png)'
  prefs: []
  type: TYPE_IMG
- en: avoid chained comparisons (image by author)
  prefs: []
  type: TYPE_NORMAL
- en: And don’t forget to use parenthesis for every criterion you want to use `&`
    or `|` to combine, otherwise the operators `&` and `|` will get higher precedence
    to execute than the comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: will give the same error message.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Takeaways
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `&` and `|` instead of `and` and `or` to combine comparisons in the pandas
    data slicing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Avoid using chained comparisons as one criterion for data slicing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thanks for reading! Hope you enjoy using the Pandas trick in your work!
  prefs: []
  type: TYPE_NORMAL
- en: Please [subscribe to my Medium](https://jianan-lin.medium.com/subscribe) if
    you want to read more stories from me. And you can also join the Medium membership
    by my [referral link](https://jianan-lin.medium.com/membership)!
  prefs: []
  type: TYPE_NORMAL
