- en: Anomaly Detection in TensorFlow and Keras Using the Autoencoder Method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/anomaly-detection-in-tensorflow-and-keras-using-the-autoencoder-method-5600aca29c50](https://towardsdatascience.com/anomaly-detection-in-tensorflow-and-keras-using-the-autoencoder-method-5600aca29c50)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/06b21f76fa65b8247eabeb45da835d72.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Leiada Krozjhen](https://unsplash.com/@leiadakrozjhen?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: A cutting-edge unsupervised method for noise removal, dimensionality reduction,
    anomaly detection, and more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://rashida00.medium.com/?source=post_page-----5600aca29c50--------------------------------)[![Rashida
    Nasrin Sucky](../Images/42bd057e8eca255907c43c29a498f2ca.png)](https://rashida00.medium.com/?source=post_page-----5600aca29c50--------------------------------)[](https://towardsdatascience.com/?source=post_page-----5600aca29c50--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----5600aca29c50--------------------------------)
    [Rashida Nasrin Sucky](https://rashida00.medium.com/?source=post_page-----5600aca29c50--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----5600aca29c50--------------------------------)
    ·7 min read·Sep 23, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: All the tutorials about TensorFlow and neural networks I have shared until now
    have been about supervised learning. This one will be about the Autoenocder which
    is an unsupervised learning technique. If I want to express it simply, autoencoders
    **reduce the noises** from the data by **compressing the input data**, and encoding
    and reconstructing the data. That way autoencoders can **reduce the dimensionality**
    or the noise of the data and focus on the real focal point of the input data.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the introduction to the autoencoders here there is more
    than one process required.
  prefs: []
  type: TYPE_NORMAL
- en: First, a model to compress the input data which is the encoder model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then another model to reconstruct the compressed data that should be as close
    as the input data which is a decoder model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this process, it can remove the noise, reduce the dimensionality, and clear
    up the input data.
  prefs: []
  type: TYPE_NORMAL
- en: In this tutorial, I will explain in detail how an autoencoder works with a working
    example.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, I chose to use a [public dataset](https://github.com/AlexOlsen/DeepWeeds/blob/master/LICENSE)
    (Apache License 2.0) named deep_weeds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Data Preparation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to prepare a dataset for this unsupervised anomaly detection example.
    Only one class will be taken as our main class that will be considered as the
    valid class. And I will put a few data from another class as an anomaly. Then
    we will develop the model to see if we can find that few anomaly data.
  prefs: []
  type: TYPE_NORMAL
- en: I chose class 5 as the valid class and class 1 as the anomaly. In the code block
    below, I am taking all the data of classes 5 and 1 first and creating lists of
    the images and their corresponding labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see the shape of the main image (images of class 5) data here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The image shapes are (256, 256, 3) and we have a total of 1009 data for class
    5.
  prefs: []
  type: TYPE_NORMAL
- en: However, we do not need all the data from class 1\. Because class 1 is the anomaly
    class. So, only 1% of the class 1 data will be taken for the training.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The shape of the total_images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We have a total of 1020 images for training. As we saw earlier, we have 1009
    class 5 images, and we took 1020–1009 = 11 of class 1 images which is our anomaly.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see if we can develop an autoencoder model in Keras and Tensorflow to
    detect these anomalies.
  prefs: []
  type: TYPE_NORMAL
- en: Model Development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the fun part! But first, we should do the necessary imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Some of the data should be kept separately for testing purposes. The train_test_split
    method from the sklearn library can be used for that. Remember, as this is an
    unsupervised learning method, the labels are not necessary. We will only split
    the images.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the autoencoder model. We will build a Convolution_Autoencoder class
    which is a Convolutional Neural Network. The class has the build method where
    we will define the Autoencoder model.
  prefs: []
  type: TYPE_NORMAL
- en: The ‘build’ takes width, depth, height, filters, and latentDim as parameters.
    Here, width, depth, and height are the dimensions of the images that is (256,
    256, 3) for us as we have seen with the total_images.shape method above.
  prefs: []
  type: TYPE_NORMAL
- en: The parameter ‘filters’ is the filter for the convolution layers.
  prefs: []
  type: TYPE_NORMAL
- en: The ‘latentDim’ is the size of our compressed layer after the encoder method.
  prefs: []
  type: TYPE_NORMAL
- en: In this build method, the first part is an encoder model which is a simple Convolutional
    Neural Network.
  prefs: []
  type: TYPE_NORMAL
- en: Once the encoder portion is done, a decoder model is developed using Conv2DTranspose
    layers to reconstruct the data again.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we construct the autoencoder model which is actually a combination of
    both encoder and decoder models.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we return the encoder, decoder, and autoencoder models.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Model development is done. It’s time to run the model and see if it works. It
    should run like any other TensorFlow model.
  prefs: []
  type: TYPE_NORMAL
- en: Here we will compile the model first with Adam optimizer. And also, I used a
    decay in the learning rate and the ‘mse’ as the loss.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, running the model. Remember, this is an unsupervised learning method.
    So there won''t be any label in the model training. Instead, we need to pass two
    training features which will be just train_x twice. If you notice the build method
    in the Convolution_Autoencoder class, autoencoder looks like this there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the Model above, we need to pass inputs which is train_x first, and then
    decoder(encoder(inputs)) where we need to pass the train_x again. Same for the
    test_x as well.
  prefs: []
  type: TYPE_NORMAL
- en: Before you begin the mode training, I should warn you that it is very slow in
    the default setting of Google Colab. You can make it way faster by running this
    in the GPU. Please change the settings of your Google Colab notebook before you
    run this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see there are not many changes to losses, simply because here we
    do not have labels. Instead, we pass the training features to it twice. Losses
    come from comparing the original images to the reconstructed images by autoencoders.
  prefs: []
  type: TYPE_NORMAL
- en: Model Evaluation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Model evaluation is different than a regular supervised learning model in autoencoders
    as this is not a supervised learning method. Let’s do that step by step.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will do the prediction as usual, which will be the decoded images
    by the autoencoder model.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you calculate the mean squared error using the original errors and the
    reconstructed error and save it to the ‘errors’ list. Here is the code for that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As we have the ‘mse’ for all the images in the test set, we choose a threshold.
    Here I am using 95% quantile using np. quantile method and getting indices from
    the ‘errors’ where ‘mse’ is greater than the threshold. When ‘mse’ is greater
    than the threshold error we decided we will consider them as an anomaly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s get back to the image dataset ‘total_images’ that we prepared for
    the training earlier. We need to check if the indices we have which are more than
    the threshold are actually the anomaly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Yes!! They are all anomaly data. If you count the number of ‘True’ above we
    have 11 ‘True’ here. We can check how many anomaly data we originally had in the
    ‘images_anomaly’:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: So, we found all the anomaly data using the autoencoder model.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I have another anomaly detection tutorial that uses probability to find the
    anomaly. Please check the ‘More Reading’ section below. Here we used TensorFlow
    and Keras which are much more advanced tools for images and more complex data.
    As I mentioned in the Introduction, autoencoders can be used in a variety of other
    tasks as well. I will be sharing more use cases in my future posts on autoencoders
    and also more cutting-edge techniques in TensorFlow and Keras.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to follow me on [Twitter](https://twitter.com/rashida048) and like
    my [Facebook](https://www.facebook.com/rashida.smith.161) page.
  prefs: []
  type: TYPE_NORMAL
- en: 'More Reading:'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[A Complete Anomaly Detection Algorithm From Scratch in Python: Step by Step
    Guide | by Rashida Nasrin Sucky | Towards Data Science (medium.com)](https://medium.com/p/4c115e65d54e)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Implementation of a Siamese Network in Keras and TensorFlow | by Rashida Nasrin
    Sucky | Aug, 2023 | Towards Data Science (medium.com)](https://medium.com/p/aa327418e177)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Complete Implementation of a Mini VGG Network for Image Recognition | by Rashida
    Nasrin Sucky | Towards Data Science (medium.com)](https://medium.com/p/849299480356)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Using a Keras Tuner for Hyperparameter Tuning of a TensorFlow Model | by Rashida
    Nasrin Sucky | Towards AI (medium.com)](https://medium.com/p/41978f53111)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Map, Filter, and CombinePerKey Transforms in Writing Apache Beam Pipelines
    with Examples | by Rashida Nasrin Sucky | Towards Data Science (medium.com)](https://medium.com/p/e06926124a02)'
  prefs: []
  type: TYPE_NORMAL
