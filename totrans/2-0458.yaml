- en: Business Analytics with LangChain and LLMs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/business-analytics-with-langchain-and-llms-c8e902446073](https://towardsdatascience.com/business-analytics-with-langchain-and-llms-c8e902446073)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: GENERATIVE AI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A step-by-step tutorial on querying SQL databases with human language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://tamimi-naser.medium.com/?source=post_page-----c8e902446073--------------------------------)[![Naser
    Tamimi](../Images/8d43c66ea3c0ef9b49c7d33dbc008c28.png)](https://tamimi-naser.medium.com/?source=post_page-----c8e902446073--------------------------------)[](https://towardsdatascience.com/?source=post_page-----c8e902446073--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----c8e902446073--------------------------------)
    [Naser Tamimi](https://tamimi-naser.medium.com/?source=post_page-----c8e902446073--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----c8e902446073--------------------------------)
    ·7 min read·Dec 19, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5540ac3aed1e97360f2bf8286e9d3663.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by the author (generated via Midjourney)
  prefs: []
  type: TYPE_NORMAL
- en: Many businesses have a lot of proprietary data stored in their databases. If
    there’s a virtual agent that understands human language and can query these databases,
    it opens up big opportunities for these businesses. Think of customer service
    chatbots, they’re a common example. These agents can take customer requests, ask
    the database for information, and give the customer what they need.
  prefs: []
  type: TYPE_NORMAL
- en: The benefit of such agents is not limited to external customer interactions.
    Many business owners or people in companies, even in tech companies, might not
    know SQL or similar languages, but they still need to ask the database for information.
    That’s where frameworks like LangChain come in. Such frameworks make it easy to
    create these helpful agents/applications. Agents that can talk to humans and at
    the same time, talk to databases, APIs, and more.
  prefs: []
  type: TYPE_NORMAL
- en: LLM-backed Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LangChain is an open-source framework for building interactive applications
    using Large Language Models (LLMs). It’s a tool that helps LLMs connect with other
    sources of information and lets them talk to the world around them. One important
    concept in such frameworks is the Chain. Let’s take a look at this concept.
  prefs: []
  type: TYPE_NORMAL
- en: What are Chains?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Chains are advanced tools in this framework that combine LLMs with other tools
    to perform more complicated tasks. Specifically, chains are interfaces that use
    a sequence of LLMs along with other tools, such as SQL databases, API calls, bash
    operators, or math calculators, to complete a complex job. An example could be
    our application receiving input from a user and passing it to our LLM model; then,
    the LLM calls an API. The API responds to the LLM, and the LLM takes the response
    to perform another task, and so on. As you can see, it is a chain of inputs and
    outputs where, in many parts of this sequence, we have LLM models handling the
    situation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Our Hands Dirty
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it’s time to get our hands dirty and start coding a simple LLM-backed application.
    For this application, we are going to make a simple Q&A agent that takes our question
    and queries a SQL database to find the answer for us.
  prefs: []
  type: TYPE_NORMAL
- en: Set Up A PostgreSQL Sample Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use [DVD Rental Sample Database](https://www.postgresqltutorial.com/postgresql-getting-started/postgresql-sample-database/)
    from postgresqltutorial.com ([License Information](https://dev.mysql.com/doc/sakila/en/sakila-license.html)).
    To install the database on your local system, you need to have PostgreSQL installed.
    Simply type `*psql*`in your terminal and see if it runs.
  prefs: []
  type: TYPE_NORMAL
- en: Then you should follow the instructions [here](https://www.postgresqltutorial.com/postgresql-getting-started/load-postgresql-sample-database/).
    Here I walk through the database installation with you quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your terminal launch PostgreSQL via:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You must substitute the `<USERNAME>` with your actual username. Then the system
    asks you about your password. Enter your password and you get into your Postgres
    database.
  prefs: []
  type: TYPE_NORMAL
- en: First, we should create a database to load all the tables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: After creating the database, you can check it by typing `*\list*` command, You
    should see your dvdrental database in the returned list. Then simply exit Postgres
    (via `\q`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to download the tables and data. You can download everything as
    a tar file here: [Download DVD Rental Sample Database](https://www.postgresqltutorial.com/wp-content/uploads/2019/05/dvdrental.zip)'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the folder that you downloaded the tar file and using pg_restore, we can
    load the tables into our Postgres Database.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Before going further, let’s check if the tables are loaded. Launch Postgres
    via `psql -U <USERNAME>` and enter your password.
  prefs: []
  type: TYPE_NORMAL
- en: Then type the following commands to list tables inside the dvdrental database.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You must see a list of tables like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Set Up .env File
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After building the sample database, we need to create a `.env` file. We use
    this file to store our secrets and keys as well as environmental variables. Of
    course, we can put all that information in our code, but we must follow best engineering
    practices even for small projects. An accidental git push can expose our API keys
    and secrets to the public. Here is our `.env` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you see, you need to get your own OpenAI API key for this test. You can follow
    the instructions [here](https://medium.com/@rithin_9167/how-to-obtain-openai-api-key-30df0b8bd114)
    to obtain an API key from Open AI.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a LangChain Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After saving your .env file in your project folder, we can start the actual
    code. First, we import the required libraries into our Python code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: For this tutorial, I recommend using a Jupyter Notebook to test it step by step.
  prefs: []
  type: TYPE_NORMAL
- en: We need to import the required libraries at the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using load_dotenv(), we load the environment variables that we defined in the
    `.env` file. Now, safely we can access them in the code.
  prefs: []
  type: TYPE_NORMAL
- en: For our chain, we need a language model with chat capabilities. For simplicity,
    we chose gpt-3.5-turbo from OpenAI which is accessible through the API. You can
    use any other public or private models.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In addition to a model, we need a SQL Database connection. That connection enables
    our chain to query against the database and get the results back. As mentioned
    before, we use a PostgreSQL Database, but according to LangChain, any SQL engine
    with a JDBC connection should be easy to use (e.g. MySQL, Presto, Databricks).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In case you are wondering about `sample_rows_in_table_info` parameter that we
    used in our SQL database connection, Rajkumar et. al showed in their paper ([https://arxiv.org/abs/2204.00498](https://arxiv.org/abs/2204.00498))
    that including a few sample rows from the table increases the performance of the
    model in creating mode affecting querying the data. In LangChain, simply you can
    set `sample_rows_in_table_info` and determine the number of sample rows from each
    table that will be appended to each table description.
  prefs: []
  type: TYPE_NORMAL
- en: To test the SQL database connection, I printed the list of available tables
    using `db.get_usable_table_names()`. It should return the following list of tables
    for you too.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The next step is the most important one. With our LLM model and a SQL database
    connection, now we should be able to instantiate our chain. Before showing the
    instantiation, let’s get a little bit more sense about a chain.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are using an SQL chain from LangChain to get a human question, convert
    it to an SQL query, run it on the database, and retrieve the results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we use the `run()` method to pass our input/question to the chain and
    get the final response back.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now it is time to test our code. We start with a simple query that requires
    querying a single table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The chain gets our human-style query and converts it into an SQL query first.
    Then using the SQL DB connection, it runs the SQL query on the database. The returned
    response provides context for the LLM and along with the human original query,
    triggers a response. In this case, you can see the final response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: First, since the `verbose=True` (where we defined the db_chain) we get more
    information about the constructed SQL query and the returned SQL results. If you
    turn off the verbose, you only see the final results (highlighted with the boldface).
    The final answer shows correctly that the average length of films released in
    2006 is 115.272 minutes (you can verify it with your own SQL query on Postgres).
  prefs: []
  type: TYPE_NORMAL
- en: The second question is a little bit more complicated and requires joining three
    tables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The question asks about the actor who played in movies that their total length
    is more than any other actors. This question requires joining three tables: actor,
    film_actor, and film. Here is the chain response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you see, our super-simple LangChain application did a good job of understanding
    the relationships between these tables and constructing the SQL query.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this article, we introduced a powerful open-source tool called LangChain
    that enables us to build LLM-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: Then we used SQLDatabaseChain to build an application that queries a SQL database
    based on user questions and returns the results.
  prefs: []
  type: TYPE_NORMAL
- en: This simple Q&A application can be expanded into a more complex business analytics
    assistant that anyone inside a business can use daily to get the latest insights
    from the proprietary data.
  prefs: []
  type: TYPE_NORMAL
