["```py\nimport requests\n\nurl_berlin = \"https://www....\"\nprint(requests.get(url_berlin))\n```", "```py\nfrom selenium import webdriver\nimport time\n\ndef page_has_loaded(driver: webdriver.Chrome):\n    \"\"\" Check if the page is ready \"\"\"\n    page_state = driver.execute_script('return document.readyState;')\n    return page_state == 'complete'\n\ndef page_get(url: str, driver: webdriver.Chrome, delay_sec: int):\n    \"\"\" Get the page content \"\"\"\n    driver.get(url)\n    time.sleep(delay_sec)\n    while not page_has_loaded(driver):\n        time.sleep(1)\n    return driver.page_source\n\noptions = webdriver.ChromeOptions()\ndriver = webdriver.Chrome(executable_path=\"./chromedriver\", chrome_options=options)\n\n# Get the first page\nurl_page1 = \"https://www....\"\nhtml1 = page_get(url_page1, driver, delay_sec=30)\n\n# Get next pages\nurl_page2 = \"https://www...\"\nhtml2 = page_get(url_page1, driver, delay_sec=1)\n...\n```", "```py\nfrom bs4 import BeautifulSoup\n\nsoup = bs.BeautifulSoup(html1, \"lxml\")\nli = soup.find(id=\"resultListItems\")\nlinks_all = []\nchildren = li.find_all(\"li\", {\"class\": \"result-list__listing\"})\nfor child in children:\n    for link in child.find_all(\"a\"):\n        if 'data-go-to-expose-id' in link.attrs:\n            links_all.append(base_url + link['href'])\n            break\nlinks_all.append(base_url + link['href'])\n```", "```py\nsoup = bs.BeautifulSoup(s_html, \"lxml\")\n\ntitle = soup.find_all(\"h1\", id=\"expose-title\")\nif len(title) > 0:\n    str_title = title[0].get_text().strip()\n```", "```py\nproperty_id;logging_date;property_area;num_rooms;floor;floors_in_building;price_cold_eur;price_warm_eur;deposit_eur;property_type;publisher;city;title;address;region;\n13507XXX1;2023-03-20;7.0;1;None;None;110;110;None;Sonstige;Private;Berlin;Lagerraum / Kellerraum / Abstellraum zu vermieten;None;Moabit, 10551 Berlin;\n13613XXX2;2023-03-20;29.0;1;None;None;189;320;None;None;XXXXXXXX Sverige AB;Berlin;Wohnungstausch: Luise-Zietz-Straße 119;Luise-Zietz-Straße 119;Marzahn, 12000 Berlin;\n...\n14010XXXn;2023-03-20;68.0;1;None;None;28000;28000;1000;None;HousingXXXXXXXXX B.V;Berlin;Wilhelminenhofstraße, Berlin;Wilhelminenhofstraße 0;Oberschöneweide, 12459 Berlin;\n```", "```py\nimport pandas as pd\n\ndf_berlin = pd.read_csv(\"Berlin.csv\", sep=';', \n                        na_values=[\"None\"], parse_dates=['logging_date'], \n                        dtype={\"price_cold_eur\": pd.Int32Dtype(), \n                               \"price_warm_eur\": pd.Int32Dtype(), \n                               \"floor\": pd.Int32Dtype(), \n                               \"floors_in_building\": pd.Int32Dtype()})\ndisplay(df_berlin)\n```", "```py\ndisplay(df_berlin.shape)\ndisplay(df_berlin.isna().sum())\n```", "```py\ndisplay(df_berlin.drop(columns=['property_id']).describe().style.format(precision=0, thousands=\",\"))\n```", "```py\npd.plotting.scatter_matrix(df_berlin[[\"property_area\", \"num_rooms\", \n                                      \"price_warm_eur\", \"price_cold_eur\"]][(df_berlin['price_cold_eur'] > 0) & (df_berlin['price_cold_eur'] < 5000)], \n                           hist_kwds={'bins': 50, 'color': '#0C0786'}, \n                           figsize=(16, 16))\n```", "```py\nfrom bokeh.io import show, output_notebook, export_png\nfrom bokeh.plotting import figure, output_file\nfrom bokeh.models import ColumnDataSource, LabelSet, Label, Whisker, FactorRange\nfrom bokeh.transform import factor_cmap, factor_mark, cumsum\nfrom bokeh.palettes import *\nfrom bokeh.layouts import row, column\noutput_notebook()\n```", "```py\ndf_berlin = pd.read_csv(\"Berlin.csv\", sep=';', na_values=[\"None\"], parse_dates=['logging_date'], dtype={\"price_cold_eur\": pd.Int32Dtype(), \"price_warm_eur\": pd.Int32Dtype(), \"floor\": pd.Int32Dtype(), \"floors_in_building\": pd.Int32Dtype()})\ndf_munchen = pd.read_csv(\"Munchen.csv\", sep=';', na_values=[\"None\"], parse_dates=['logging_date'], dtype={\"price_cold_eur\": pd.Int32Dtype(), \"price_warm_eur\": pd.Int32Dtype(), \"floor\": pd.Int32Dtype(), \"floors_in_building\": pd.Int32Dtype()})\ndf_hamburg = pd.read_csv(\"Hamburg.csv\", sep=';', na_values=[\"None\"], parse_dates=['logging_date'], dtype={\"price_cold_eur\": pd.Int32Dtype(), \"price_warm_eur\": pd.Int32Dtype(), \"floor\": pd.Int32Dtype(), \"floors_in_building\": pd.Int32Dtype()})\ndf_cologne = pd.read_csv(\"Cologne.csv\", sep=';', na_values=[\"None\"], parse_dates=['logging_date'], dtype={\"price_cold_eur\": pd.Int32Dtype(), \"price_warm_eur\": pd.Int32Dtype(), \"floor\": pd.Int32Dtype(), \"floors_in_building\": pd.Int32Dtype()})\ndf_frankfurt = pd.read_csv(\"Frankfurt.csv\", sep=';', na_values=[\"None\"], parse_dates=['logging_date'], dtype={\"price_cold_eur\": pd.Int32Dtype(), \"price_warm_eur\": pd.Int32Dtype(), \"floor\": pd.Int32Dtype(), \"floors_in_building\": pd.Int32Dtype()})\ndf_dresden = pd.read_csv(\"Dresden.csv\", sep=';', na_values=[\"None\"], parse_dates=['logging_date'], dtype={\"price_cold_eur\": pd.Int32Dtype(), \"price_warm_eur\": pd.Int32Dtype(), \"floor\": pd.Int32Dtype(), \"floors_in_building\": pd.Int32Dtype()}) \n\ndf = pd.concat([df_berlin, df_munchen, df_hamburg, \n                df_cologne, df_frankfurt, df_dresden])\n```", "```py\n data_pr = df[['property_type']].fillna('Unbekannt').groupby(['property_type'], as_index=False).size().sort_values(by=[\"size\"], ascending=True)\n\ntypes = data_pr['property_type']\namount = data_pr['size']\n\npalette = Viridis10 + Plasma10\np = figure(y_range=FactorRange(factors=types), width=1200, height=500, title=\"Apartment Types\")\np.hbar(y=types, right=amount, height=0.8, color=palette[:len(types)])\np.xaxis.axis_label = 'Amount'\np.x_range.start = 0\nshow(p)\n```", "```py\ndef q0(x):\n    return x.quantile(0.01)\n\ndef q1(x):\n    return x.quantile(0.25)\n\ndef q3(x):\n    return x.quantile(0.75)\n\ndef q4(x):\n    return x.quantile(0.99)\n\nagg_data = {'price_cold_eur': ['size', 'min', q0, q1, 'median', q3, q4, 'max']}\n\nprices = df[df['price_cold_eur'].notna()][['property_type', 'price_cold_eur']].fillna('Unbekannt').groupby('property_type', as_index=False).agg(agg_data)\nprices = prices.sort_values(by=('price_cold_eur', 'size'), ascending=True)\ndisplay(prices.style.hide(axis=\"index\"))\n```", "```py\nprices = prices.sort_values(by=('price_cold_eur', 'size'), ascending=True)\n\np_types = prices[\"property_type\"]\nq1 = prices[\"price_cold_eur\"][\"q1\"].astype('int32')\nq3 = prices[\"price_cold_eur\"][\"q3\"].astype('int32')\nv_min = prices[\"price_cold_eur\"][\"q0\"].astype('int32')\nv_max = prices[\"price_cold_eur\"][\"q4\"].astype('int32')\nmedian = prices[\"price_cold_eur\"][\"median\"].astype('int32')\n\npalette = Viridis10 + Plasma10\nsource = ColumnDataSource(data=dict(p_types=p_types, \n                                    lower=v_min, \n                                    bottom=q1, \n                                    median=median, \n                                    top=q3,                                     \n                                    upper=v_max,\n                                    color=palette[:p_types.shape[0]]))\n\np = figure(x_range=p_types, width=1400, height=500, title=\"Property types distribution\") \nwhisker = Whisker(base=\"p_types\", upper=\"upper\", lower=\"lower\", source=source)\np.add_layout(whisker)\np.vbar(x='p_types', top='top', bottom='median', width=0.9, color='color', \n       line_color=\"black\", source=source)\np.vbar(x='p_types', top='median', bottom='bottom', width=0.9, color='color', \n       line_color=\"black\", source=source)\n\np.left[0].formatter.use_scientific = False\np.y_range.start = 0\np.y_range.end = 4000\np.yaxis.axis_label = 'Rent Price, EUR'\nshow(p)\n```", "```py\npr_types = df[['property_type']].fillna('Unbekannt').groupby(['property_type'], as_index=False).size().sort_values(by=[\"size\"], ascending=True)['property_type']\n```", "```py\nprice_limit, area_limit = 3000, 200  \n\ndf_city = df_berlin  \ndata_pr = df_city[df_city['price_cold_eur'].notna()][['property_area', 'price_cold_eur', 'property_type']].fillna('Unbekannt')\ndata_pr = data_pr[(data_pr['property_area'] > 0) & (data_pr['property_area'] < area_limit) & (data_pr['price_cold_eur'] > 0) & (data_pr['price_cold_eur'] < price_limit)] \nvalues_x = data_pr[\"property_area\"].astype('float').values\nvalues_y = data_pr[\"price_cold_eur\"].astype('float').values\ntypes = data_pr[\"property_type\"]\n```", "```py\nfrom sklearn.linear_model import LinearRegression\n\nlinear_model = LinearRegression().fit(values_x.reshape(-1, 1), values_y)\n```", "```py\npalette = (Viridis10 + Plasma10)[:len(pr_types)]\n\nname = \"Berlin\"\ndf_city = df_berlin\n\nsource = ColumnDataSource(dict(property_area=values_x, \n                               price_cold_eur=values_y, \n                               property_type=types))\n\ntitle = f\"Property prices: {name} ({df_city.shape[0]} items, {data_pr.shape[0]} displayed)\"\np = figure(width=1200, height=550, title=title)\n\n# Draw scatter\np.scatter(\"property_area\", \"price_cold_eur\",\n              source=source, fill_alpha=0.8, size=4,\n              legend_group='property_type',\n              color=factor_cmap('property_type', palette, pr_types)\n             )\n# Draw approximation with a linear model\nlinear_model = LinearRegression().fit(values_x.reshape(-1, 1), values_y)\np.line([0, 9999], linear_model.predict([[0], [9999]]), line_width=4, line_dash=\"2 2\", alpha=0.5)\n\np.xaxis.axis_label = 'Area, m^2'\np.yaxis.axis_label = 'Rent Price, EUR'\np.x_range.start = 0\np.x_range.end = area_limit\np.y_range.start = 0\np.y_range.end = price_limit\np.toolbar_location = None\np.legend.visible = True\np.legend.background_fill_alpha = 0.9\n```", "```py\np1 = get_figure_price_per_area(\"Berlin\", df, df_berlin)\np2 = get_figure_price_per_area(\"München\", df, df_munchen)\np3 = get_figure_price_per_area(\"Hamburg\", df, df_hamburg)\np4 = get_figure_price_per_area(\"Köln\", df, df_koeln)\np5 = get_figure_price_per_area(\"Frankfurt\", df, df_frankfurt)\np6 = get_figure_price_per_area(\"Dresden\", df, df_dresden)\nshow(column(row(p1, p2), \n            row(p3, p4), \n            row(p5, p6)))\n```", "```py\ndef get_figure_histogram_price(name: str, df_city: pd.DataFrame):\n    price_limit = 10000\n    prices = df_city['price_cold_eur'].dropna().values\n    hist_e, edges_e = np.histogram(prices, density=False, bins=50, range=(0, price_limit))\n\n    # Create figure\n    palette = Viridis256[::3][0:len(hist_e)]  # Take every 3rd item from array\n    p = figure(width=1400, height=500, \n               title=f\"Property prices: {name} ({df_city.shape[0]} total)\")\n    p.quad(top=hist_e, bottom=0, left=edges_e[:-1], right=edges_e[1:], fill_color=palette)\n    p.x_range.start = 0\n    p.x_range.end = price_limit\n    p.y_range.start = 0\n    p.y_range.end = 360\n    p.xaxis[0].ticker.desired_num_ticks = 20\n    p.xaxis.axis_label = \"Rent Price, EUR\"\n    p.yaxis.axis_label = \"Amount\"\n    p.toolbar_location = None\n    return p\n```", "```py\np1 = get_figure_histogram_price(\"Berlin\", df_berlin)\np2 = get_figure_histogram_price(\"München\", df_munchen)\np3 = get_figure_histogram_price(\"Hamburg\", df_hamburg)\np4 = get_figure_histogram_price(\"Köln\", df_koeln)\np5 = get_figure_histogram_price(\"Frankfurt\", df_frankfurt)\np6 = get_figure_histogram_price(\"Dresden\", df_dresden)\nshow(column(row(p1, p2), \n            row(p3, p4), \n            row(p5, p6)))\n```", "```py\nname = \"Berlin\"\ndf_city = df_berlin\n\ndf_area = df_city[['property_area', 'price_warm_eur', 'price_cold_eur', 'property_type']].copy()\ndf_area['property_type'] = df_area['property_type'].fillna('Unbekannt')\n\npr_types = df_area[['property_type']].groupby(['property_type'], as_index=False).size().sort_values(by=[\"size\"], ascending=True)['property_type']\n\ndf_area['price_diff'] = df_area['price_warm_eur'] - df_area['price_cold_eur']\ndf_area = df_area[df_area['price_diff'] > 0] \nvalues_x = df_area['property_area'].astype('float').values\nvalues_y = df_area['price_diff'].astype('float').values\n\np = figure(width=1200, height=500, title=f\"Utilities cost: {name}\")\n\nsource = ColumnDataSource(dict(property_area=values_x, \n                               price_diff=values_y, \n                               property_type=df_area[\"property_type\"]))\n\npalette = (Viridis10 + Plasma10)[:len(pr_types)]\n\n# Draw scatter\np.scatter(\"property_area\", \"price_diff\", source=source,\n          fill_alpha=0.8, size=4,\n          legend_group='property_type',\n          color=factor_cmap('property_type', palette, pr_types))\n# Draw approximation with a linear model\nmodel = LinearRegression().fit(values_x.reshape(-1, 1), values_y)\np.line([0, 9999], model.predict([[0], [9999]]), line_width=2, line_dash=\"2 2\", alpha=0.5, color='red')\n\np.xaxis.axis_label = 'Area, m^2'\np.yaxis.axis_label = '\"Warm\" - \"Cold\" price, EUR'\np.x_range.start = 0\np.x_range.end = 200\np.y_range.start = 0\np.y_range.end = 800\np.toolbar_location = None\np.legend.visible = True\np.legend.background_fill_alpha = 0.9\nshow(p)\n```", "```py\ndisplay(df_berlin[[\"title\", \"price_cold_eur\", \"deposit_eur\"]])\n```", "```py\nprint(df['deposit_eur'].unique().tolist())\n```", "```py\ndef value_from_str(price_str: str) -> Optional[float]:\n    \"\"\" Convert string price like \"7.935,60 EUR\" to 7936 \"\"\"\n    try:\n        # '4.800,00 EUR' => '4.800,00'\n        if price_str.find(' ') > 0:\n            price_str = price_str.split(\" \")[0]\n        s_filtered = ''.join(c for c in price_str if c in \"0123456789,.\")\n        # \"1000.0\" => 1000.0\n        if s_filtered.find(\".\") != -1 and s_filtered.find(\",\") == -1:\n            return float(price_str)\n        # 7.935,60 => 7935.60\n        return float(s_filtered.replace(\".\", \"\").replace(\",\", \".\"))\n    except ValueError as _:\n        return None\n\ndef convert_price(s_deposit: str, cold_price: int) -> float:\n    \"\"\" Convert text string and a price to a new value \"\"\"\n    try:\n        if s_deposit is None:\n            return None\n        if isinstance(s_deposit, int) or isinstance(s_deposit, float):\n            return s_deposit\n        if '€' in s_deposit:\n            # 585 € => 585\n            return value_from_str(s_deposit)\n        if 'zwei' in s_deposit.lower():\n            return 2*cold_price\n        if 'drei' in s_deposit.lower():\n            return 3*cold_price\n        if 'kalt' in s_deposit.lower() or 'km' in s_deposit.lower() or 'monat' in s_deposit.lower():\n            # 2x Monatsnettokaltmieten => 2\n            return cold_price*value_from_str(s_deposit)\n        return value_from_str(s_deposit)\n    except:\n        return None\n```", "```py\nconvert_price(\"3 Nettokaltmieten\", 659)\nconvert_price(\"1.274,00 EUR\", 659)\n```", "```py\ndef get_deposit_ratio(s_deposit: str, cold_price: int) -> float:\n    \"\"\" Calculate the ratio between deposit and price \"\"\"\n    try:\n        deposit_price = convert_price(s_deposit, cold_price)\n        if deposit_price is not None and cold_price != 0:\n            return deposit_price/cold_price\n    except:\n        pass\n    return None\n\ndf_berlin[\"deposit_price_ratio\"] =  df_berlin.apply(lambda x: get_deposit_ratio(s_deposit=x['deposit_eur'], \n                                                                                cold_price=x['price_cold_eur']), \n                                                    axis=1)\n```", "```py\ndef get_deposit_histogram(name: str, df_city: pd.DataFrame):\n    \"\"\" Get Bokeh figure from a dataframe \"\"\"\n    prices = df_city['deposit_price_ratio'].dropna().values\n    hist_e, edges_e = np.histogram(prices, density=False, bins=60, range=(0, 5))\n\n    # Draw\n    palette = Viridis256[::2][0:len(hist_e)]  # Take every 2nd item from array\n    p = figure(width=1400, height=400, \n               title=f\"Property area: {name} ({df_city.shape[0]} total)\")\n    p.quad(top=hist_e, bottom=0, left=edges_e[:-1], right=edges_e[1:], fill_color=palette)\n    p.x_range.start = 0\n    p.x_range.end = 5\n    p.y_range.start = 0\n    p.y_range.end = 400\n    p.xaxis[0].ticker.desired_num_ticks = 20\n    p.xaxis.axis_label = 'Deposit amount, relative to the \"cold\" price'\n    p.yaxis.axis_label = 'Number of objects available'\n    p.toolbar_location = None\n    return p\n\np1 = get_deposit_histogram(\"Berlin\", df_berlin)\np2 = get_deposit_histogram(\"München\", df_munchen)\np3 = get_deposit_histogram(\"Hamburg\", df_hamburg)\np4 = get_deposit_histogram(\"Köln\", df_koeln)\np5 = get_deposit_histogram(\"Frankfurt\", df_frankfurt)\np6 = get_deposit_histogram(\"Dresden\", df_dresden)\nshow(column(row(p1, p2), row(p3, p4), row(p5, p6)))\n```", "```py\ndef get_figure_publisher(name: str, df_city: pd.DataFrame) -> figure:\n    publishers = df_city[['publisher']].groupby(['publisher'], as_index=False).size().sort_values(by=[\"size\"], ascending=False)\n    publishers = publishers[publishers['size'] > 5]\n\n    # Put private first\n    data_private = publishers[(publishers['publisher'] == \"Private\")]\n    data_non_private = publishers[(publishers['publisher'] != \"Private\")]\n    data = pd.concat([data_private, data_non_private])\n\n    palette = RdGy3[:1] + Viridis11 + BrBG11 + Plasma11 + Cividis11 + RdYlBu11 + RdGy11 + PiYG11\n\n    data['angle'] = data['size']/data['size'].sum()*2*np.pi\n    data['percentage'] = data['size'] / data['size'].sum() * 100\n    data['color'] = palette[:data.shape[0]]\n\n    p = figure(width=1100, height=750, title=f\"Property publishers: {name}\", toolbar_location=None, x_range=(-0.5, 1.0))\n    pie_chart = p.wedge(x=0, y=1, radius=0.4,\n            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),\n            line_color=\"white\", \n            fill_color='color', \n            legend_field='publisher', \n            source=data)\n\n    p.axis.axis_label = None\n    p.axis.visible = False\n    p.grid.grid_line_color = None\n    return p\n```", "```py\ndef to_digit(v):\n    \"\"\" Convertion for string or digit \"\"\"\n    if v.isdigit():\n        return f\"{int(v):02d}\" # \"1\" => \"001\"     \n    return ' ' + str(v)\n\ndef custom_key(v):\n    \"\"\" Custom key for the dataframe sort \"\"\"\n    # v: pd.Series, convert items for proper sort\n    # [\"1\", \"10\", \"2\", \"U\"] => [\" U\", \"001\", \"002\", \"010\"]\n    return v.apply(to_digit)\n\ndef get_figure_floors(city_name: str, df_city: pd.DataFrame) -> figure:\n    \"\"\" Get Bokeh figure \"\"\"\n    floors = df_city[['floor']].astype(str).mask(df_city.isnull(), None).fillna(\"?\").groupby(['floor'], as_index=False).size()\n    floors = floors.sort_values(by=[\"floor\"], key=lambda x: custom_key(x), ascending=True)\n\n    # Draw\n    palette = Viridis11 + Plasma11 + Cividis11\n    values = floors['floor']\n    amount = floors['size']\n    p = figure(x_range=FactorRange(factors=values), width=1200, height=400, title=f\"{city_name}: apartments floor\")\n    p.vbar(x=values, top=amount, width=0.8, color=palette[:len(values)])\n    p.xaxis.axis_label = 'Floor №'\n    p.yaxis.axis_label = \"Amount\"\n    p.toolbar_location = None\n    return p\n\np1 = get_figure_floors(\"Berlin\", df_berlin)\np2 = get_figure_floors(\"München\", df_munchen)\nshow(row(p1, p2))\n```", "```py\nfrom geopy.geocoders import Nominatim\nfrom functools import lru_cache\n\ngeolocator = Nominatim(user_agent=\"Python3.9\")\n\n@lru_cache(maxsize=None)\ndef get_coord_lat_lon(full_addr: str):\n    \"\"\" Get coordinates for address \"\"\"\n    # Remove brackets: \"Mitte (Ortsteil), 10117\" => \"Mitte, 10117\"\n    p1, p2 = full_addr.find('('), full_addr.find(')')\n    if p1 != -1 and p2 != -1 and p2 > p1:\n        full_addr = full_addr[:p1].strip() + full_addr[p2 + 1:]  \n    # Make request\n    pt = geolocator.geocode(full_addr)\n    return (pt.latitude, pt.longitude) if pt else (None, None)\n```", "```py\ndf_city = df_berli\ndf_addrs = df_city[[\"address\", \"region\", \"price_cold_eur\"]].dropna().copy()\n# Combine the address from 2 fields\ndf_addrs[\"address_full\"] = df_addrs[[\"address\", \"region\"]].apply(lambda x: x[0] + \", \" + x[1], axis=1)\n\npoints = []\nfor index, row in df_addrs.iterrows():\n    addr, price = row['address_full'], row['price_cold_eur']\n    lat, lon = get_coord_lat_lon(addr)\n    if (index % 50) == 0:\n        print(f\"{index} of {df_addrs.shape[0]}: {addr}, {price}, {lat}, {lon}\")\n    if lat and lon:\n        points.append((addr, price, lat, lon)) \n\nprint(f\"Points added: {len(points)}\")\nreturn points\n```", "```py\nimport folium\nfrom folium.plugins import HeatMap\nfrom branca.element import Figure\n\nfig = Figure(width=1200, height=1000)\nm = folium.Map(location=(50.59, 10.38), tiles=\"openstreetmap\", zoom_start=7)\n\nfolium.Marker(location=(52.59, 13.37), popup=\"Berlin\").add_to(m)\n\nfig.add_child(m)\ndisplay(fig)\n```", "```py\nimport folium\nfrom folium.plugins import HeatMap\nfrom branca.element import Figure\nimport matplotlib\nimport matplotlib.cm as colormap\n\ndef value_to_color(value: int) -> str:\n    \"\"\" Convert price value to the HTML color \"\"\"\n    if value >= 5000:\n        # Mark high values in special colors\n        return \"#FF00FF\"\n\n    norm = matplotlib.colors.Normalize(vmin=0, vmax=3000, clip=True)\n    mapper = colormap.ScalarMappable(norm=norm, cmap=colormap.inferno)\n    r, g, b, _ = mapper.to_rgba(value, alpha=None, bytes=True)\n    return \"#\" + f\"{(r << 16) + (g << 8) + b:#08x}\"[2:]\n\ndef add_to_map(fmap, lat, lon, price):\n    \"\"\" Add point to map \"\"\"\n    color_str = value_to_color(price)\n    folium.Circle(\n        location=[lat, lon],\n        radius=100,\n        popup=addr + \": \" + str(price),\n        color=color_str,\n        fill=True,\n        fill_color=color_str\n    ).add_to(fmap)\n\ndef get_html_text_label(text: str, value1: int, value2: int=999999):\n    \"\"\" Prepare HTML label with a gradient text \"\"\"\n    color1 = value_to_color(value1)\n    color2 = value_to_color(value2-1)\n    return f'<span style=\"background: linear-gradient(to right, {color1}, {color2}); padding-left: 2%; padding-top: 3%; padding-bottom: 1%;\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;{text}</span>'\n\ndef generate_map(points: list, location: Tuple, name: str):\n    \"\"\" Draw a city map \"\"\"\n    fig = Figure(width=1200, height=600)\n    m = folium.Map(location=location, zoom_start=12)\n\n    heat_map = folium.FeatureGroup(name='Heat Map')\n    price_less_500 = folium.FeatureGroup(name=get_html_text_label('< 500', 0, 500))\n    price_less_1000 = folium.FeatureGroup(name=get_html_text_label('500..1000', 500, 1000))\n    price_less_2000 = folium.FeatureGroup(name=get_html_text_label('1000..2000', 1000, 2000))\n    price_less_5000 = folium.FeatureGroup(name=get_html_text_label('2000..5000', 2000, 5000))\n    price_more_5000 = folium.FeatureGroup(name=get_html_text_label('> 5000', 5000))\n\n    heat_data = []\n    for addr, price, lat, lon in points:\n        if price < 500:\n            add_to_map(price_less_500, lat, lon, price)\n        elif price <= 1000:\n            add_to_map(price_less_1000, lat, lon, price)\n        elif price <= 2000:\n            add_to_map(price_less_2000, lat, lon, price)\n        elif price <= 5000:\n            add_to_map(price_less_5000, lat, lon, price)\n        else:\n            add_to_map(price_more_5000, lat, lon, price)\n        heat_data.append((lat, lon))\n\n    heat_map.add_child(HeatMap(heat_data, min_opacity=0.3, blur=50))\n    m.add_child(heat_map)\n    m.add_child(price_less_500)\n    m.add_child(price_less_1000)\n    m.add_child(price_less_2000)\n    m.add_child(price_less_5000)\n    m.add_child(price_more_5000)\n\n    folium.map.LayerControl('topright', collapsed=False, style=(\"background-color: grey; color: white;\")).add_to(m)\n\n    fig.add_child(m)\n    return fig\n```", "```py\ndef get_two_histograms(name: str, df_all: pd.DataFrame, df_closed: pd.DataFrame):\n    \"\"\" Draw two dataframe histograms on the same graph \"\"\"\n    price_limit = 10000\n    prices = df_all['price_cold_eur'].values\n    hist_e1, edges_e1 = np.histogram(prices, density=False, bins=40, range=(0, price_limit))\n    prices = df_closed[(df_closed['price_cold_eur'] < price_limit)]['price_cold_eur'].values\n    hist_e2, _ = np.histogram(prices, density=False, bins=edges_e1)\n\n    # Draw\n    palette1 = Viridis256[::3][0:len(hist_e1)]  # Take every 3rd item from array\n    p = figure(width=1400, height=500, \n               title=f\"Property prices: {name} ({df_city.shape[0]} total)\")\n    p.quad(top=hist_e1, bottom=0, left=edges_e1[:-1], right=edges_e1[1:], fill_color=palette1, fill_alpha=0.8, legend_label='All properties')\n    p.quad(top=hist_e2, bottom=0, left=edges_e1[:-1]+20, right=edges_e1[1:]-20, fill_color=palette1, legend_label='Properties removed from listing within 7 days')\n    # Add percentage labels\n    for i in range(hist_e1.shape[0]):\n        pos_x = (edges_e1[i] + edges_e1[i + 1])/2\n        pos_y = hist_e1[i]\n        value = 100*hist_e2[i]/hist_e1[i] if hist_e1[i] != 0 else 0        \n        value_str = f'{value:.1f}%' if value > 0.5 else \"0%\"\n        p.add_layout(Label(x=pos_x, y=pos_y + 2, text_align=\"center\",\n                 text=value_str, text_font_size='7pt',\n                 background_fill_color='white', background_fill_alpha=0.0))\n\n    p.x_range.start = 0\n    p.x_range.end = price_limit\n    p.y_range.start = 0\n    p.y_range.end = 480\n    p.xaxis[0].ticker.desired_num_ticks = 20\n    p.left[0].formatter.use_scientific = False\n    p.below[0].formatter.use_scientific = False\n    p.xaxis.axis_label = \"Rent Price, EUR\"\n    p.yaxis.axis_label = \"Amount\"\n    return p\n\ndf_berlin0 = pd.read_csv(\"Berlin_00.csv\", sep=';', na_values=[\"None\"]).drop_duplicates(subset='property_id', keep=\"first\")\nids0 = df_berlin0[\"property_id\"].unique().tolist()\ndf_berlin6 = pd.read_csv(\"Berlin_06.csv\", sep=';', na_values=[\"None\"]).drop_duplicates(subset='property_id', keep=\"first\")\nids6 = df_berlin6[\"property_id\"].unique().tolist()\n\ndf_f = df_berlin0.copy()\ndf_f[\"deal_closed\"] = df_f['property_id'].apply(lambda pr_id: pr_id in ids0 and pr_id not in ids6)\ndf_f_closed = df_f[df_f['deal_closed'] == True]\n\np1 = get_two_histograms(\"Berlin\", df_berlin0, df_f_closed)\nshow(p1)\n```", "```py\nfrom sklearn.ensemble import IsolationForest\n\ndf_city = df_berlin[[\"region\", \"address\", \"price_cold_eur\", \"num_rooms\", \"property_area\"]].dropna().copy().reset_index(drop=True)\nanomaly_inputs = [\"price_cold_eur\", \"num_rooms\", \"property_area\"]\nfor field in anomaly_inputs:\n    df_city[field] = df_city[field].astype(float)\n\ndisplay(df_city[anomaly_inputs])\n\nmodel_if = IsolationForest(contamination=0.01)\nmodel_if.fit(df_city[anomaly_inputs])\n\n# anomaly_scores: generated by calling model_IF.predict() and is used to identify if a point is an outlier (-1) or an inlier (1)\ndf_city['anomaly_scores'] = model_if.decision_function(df_city[anomaly_inputs])\n# anomaly : generated by calling model_IF.predict() and is used to identify if a point is an outlier (-1) or an inlier (1)\ndf_city['anomaly'] = model_if.predict(df_city[anomaly_inputs])\n```", "```py\ndisplay(df_city[df_city['anomaly'] == -1])\n```", "```py\nimport shap\nshap.initjs()\n\nexplainer = shap.Explainer(model_if.predict, df_city[anomaly_inputs])\nshap_values = explainer(df_city[anomaly_inputs])\n```", "```py\nshap.plots.waterfall(shap_values[3030])\n```", "```py\ndisplay(shap.plots.scatter(shap_values[:,'num_rooms'], color=shap_values[:,\"price_cold_eur\"]))\n```", "```py\nfrom wordcloud import WordCloud\nimport matplotlib.pyplot as plt\n\nfrom nltk.corpus import stopwords\nstop_words_de = stopwords.words('german')\n\n# Generate\ntext = \"\"\nfor s in df.title:\n    s_out = s.replace('/', ' ').replace(':', ' ').replace(',', ' ').replace('!', ' ').replace('-', ' ')\n    text += s_out + \" \"\n\nwordcloud = WordCloud(width=1600, height=1200, stopwords=set(stopwords_de), collocations=False, background_color=\"white\").generate(text)\n\n# Show\nplt.figure(figsize=(16, 12), dpi=100)\nplt.imshow(wordcloud, interpolation='bilinear')\nplt.axis(\"off\")\nplt.show()\n```"]