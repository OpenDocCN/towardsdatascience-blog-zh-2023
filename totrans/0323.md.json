["```py\n>>> from numpy import mean, std\n>>> x = [5, 10, 15]\n>>> normed = [(mean(x) - i) / std(x) for i in x]\n>>> print(normed)\n[1.224744871391589, 0.0, -1.224744871391589]\n```", "```py\njulia> using Statistics: std, mean\n\njulia> x = [5, 10, 15]\n3-element Vector{Int64}:\n  5\n 10\n 15\n\njulia> normed = [(mean(x) - i) / std(x) for i in x]\n3-element Vector{Float64}:\n  1.0\n  0.0\n -1.0\n```", "```py\n# python\nimport math as mt\ndef mean(x : int):\n    return(sum(x) / len(x))\n\ndef std(arr : list):\n    m = mean(arr)\n    arr2 = [(i-m) ** 2 for i in arr]\n    m = mean(arr2)\n    m = mt.sqrt(m)\n    return(m)\n```", "```py\n# julia\nmean(x::Vector{<:Number}) = sum(x) / length(x)\n\nfunction std(array3::Vector{<:Number})\n    m = mean(array3)\n    [i = (i-m) ^ 2 for i in array3]\n    m = mean(array3)\n    try\n        m = sqrt(m)\n    catch\n        m = sqrt(Complex(m))\n    end\n    return(m)\nend\n```", "```py\n# python\ndef norm(x : list):\n    mu = mean(x)\n    sigma = std(x)\n    return([(xbar - mu) / sigma for xbar in x])\n```", "```py\n# julia\nfunction norm(x::Vector{<:Number})\n    mu::Number = mean(x)\n    sigma::Number = std(x)\n    [(xbar - mu) / sigma for xbar in x]::Vector{<:Number}\nend\n```", "```py\nnorm([5, 10, 15])\n\n[-1.224744871391589, 0.0, 1.224744871391589]\n```", "```py\nmu = mean([5, 10, 15])\nsigma = std([5, 10, 15])\n\n(15 - mu) / sigma\n\n1.5811388300841895\n\n(20 - mu) / sigma\n\n3.162277660168379\n```", "```py\npop = [5, 10, 15, 20, 25, 30]\nmu = mean(pop)\nsigma = std(pop)\n```", "```py\nxbar = mean(pop[3:5])\n```", "```py\n(xbar - mu) / sigma\n0.5976143046671968\n```", "```py\nxbar = mean([50, 25, 38])\n(xbar - mu) / sigma\n\n4.820755390982054\n```", "```py\n# julia\nfunction drop_outls(vec::Vector{<:Number})\n    normed = norm(vec)\n    mask = [~(x <= -2 || x >= 2) for x in normed]\n    normed[mask]\nend\n```", "```py\n# python\ndef drop_outls(vec : list):\n    mu = mean(vec)\n    normed = norm(vec)\n    mask = [x <= -2 or x >= 2 for x in normed]\n    ret = []\n    for e in range(1, len(mask)):\n        if mask[e] == False:\n            ret.append(vec[e])\n        else:\n            ret.append(mu)\n    return(ret)\n```", "```py\nmyX = [1, 2, 3, 4, 5]\nnormedx = norm(x)\n```"]