- en: How to Predict Player Churn, with Some Help From ChatGPT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/player-churn-rate-prediction-data-analysis-and-visualisation-part-1-12a9fdff9c10](https://towardsdatascience.com/player-churn-rate-prediction-data-analysis-and-visualisation-part-1-12a9fdff9c10)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Data Science using a low-code ML Platform | Actable AI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Analyzing data and training models for player churn prediction, using a low-code
    platform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@chrisgalea?source=post_page-----12a9fdff9c10--------------------------------)[![Christian
    Galea](../Images/1e4e32ce529f7694422f130897eb071b.png)](https://medium.com/@chrisgalea?source=post_page-----12a9fdff9c10--------------------------------)[](https://towardsdatascience.com/?source=post_page-----12a9fdff9c10--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----12a9fdff9c10--------------------------------)
    [Christian Galea](https://medium.com/@chrisgalea?source=post_page-----12a9fdff9c10--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----12a9fdff9c10--------------------------------)
    ·22 min read·Jun 20, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b1907bde077d48abe4a7127f8a720a6c.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Tima Miroshnichenko on Pexels](https://www.pexels.com/photo/man-in-white-dress-shirt-with-eyeglasses-feeling-exhausted-7567442/)
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the world of gaming, companies strive not only to attract players but also
    to retain them for as long as possible, especially in free-to-play games that
    rely on in-game micro-transactions. These micro-transactions often involve the
    purchase of in-game currency, allowing players to acquire items for progression
    or customization, and funding the game’s development. Monitoring the *churn rate*,
    which represents the number of players who stop playing, is crucial. This is because
    a high churn rate means a significant loss in income, which in turn leads to higher
    stress levels for developers and managers.
  prefs: []
  type: TYPE_NORMAL
- en: This article explores the use of a real-world dataset based on data acquired
    from a mobile app, specifically focusing on the levels played by users. Leveraging
    *machine learning*, which has become an essential part of the technology landscape
    and forms the basis of Artificial Intelligence (AI), businesses can extract valuable
    insights from their data.
  prefs: []
  type: TYPE_NORMAL
- en: However, building machine learning models typically demands coding and data
    science expertise, making it inaccessible for many individuals and smaller companies
    lacking resources for hiring data scientists or powerful hardware to handle complex
    algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: To address these challenges, low-code and no-code machine learning platforms
    have emerged with the aim of simplifying machine learning and data science processes,
    thereby mitigating the need for extensive coding knowledge. Examples of such platforms
    include [Einblick](https://www.einblick.ai/), [KNIME](https://www.knime.com/),
    [Dataiku](https://www.dataiku.com/), [Alteryx](https://www.alteryx.com/), and
    [Akkio](https://www.akkio.com/).
  prefs: []
  type: TYPE_NORMAL
- en: This article uses one low-code machine learning platform to train a model capable
    of predicting if a user will stop playing a game. Additionally, it delves into
    results interpretation and techniques that can be used to improve the model’s
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of this article is organised as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[The Platform](#4f95)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[The Dataset](#39c5)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Exploratory Data Analysis](#a111)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Training a Classification Model](#f19a)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Improving the Model Performance](#2d59)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Creating New Features](#6ae7)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Training a New (hopefully improved) Classification Model](#773d)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Model Deployment in Production](#e258)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Conclusions](#70bd)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Full disclosure — I am a data scientist with [Actable AI](https://www.actable.ai/)
    at the time of writing this article, so it is the platform that will be used in
    this article. I am also involved in implementing new features in the ML library
    and maintaining them, so I was curious to see how the platform would fare on a
    real-world problem.
  prefs: []
  type: TYPE_NORMAL
- en: The platform provides a web application with a number of popular machine learning
    methods for the traditional applications of classification, regression, and segmentation.
    A number of less common tools are also available, such as time-series forecasting,
    sentiment analysis, and causal inference. Missing data can also be imputed, statistics
    of a dataset can be computed (such as correlation among features, Analysis of
    Variance (ANOVA), and so on), while data can be visualized using tools such as
    bar charts, histograms, and word clouds.
  prefs: []
  type: TYPE_NORMAL
- en: A [Google Sheets add-on](https://www.actable.ai/resources/gsheets-add-on) is
    also available, enabling analyses and model training to be done directly within
    a spreadsheet. However, do note that newer features may not be available in this
    add-on.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2a0725ee07bdf56af89ca82dfffe0293.png)'
  prefs: []
  type: TYPE_IMG
- en: '[Actable AI’s Google Sheets add-on](https://www.actable.ai/resources/gsheets-add-on).
    Image by author.'
  prefs: []
  type: TYPE_NORMAL
- en: The core library is open-source and available on [GitHub](https://github.com/Actable-AI/actableai-lib),
    and is composed of several well-known and trusted frameworks such as [AutoGluon](https://github.com/autogluon/autogluon)
    and [scikit-learn](https://scikit-learn.org/stable/) that are also open-source
    and freely available. This is not dissimilar to other related platforms, which
    also take advantage of existing open-source solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this begs the question: why would you use such platforms at all, if
    most of the tools are already available and free to use?'
  prefs: []
  type: TYPE_NORMAL
- en: The main reason is that these tools require knowledge of programming languages
    such as Python, so anyone who may not be familiar with coding in general may find
    it hard or impossible to use. Hence, these platforms aim to provide all the functionalities
    in the form of a Graphical User Interface (GUI), rather than as a set of programming
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: More experienced professionals could also potentially benefit by saving time
    through a graphical interface that is easy to use and that may also provide informative
    descriptions of the available tools and techniques. Some platforms could also
    present tools which you may not have been familiar with, or provide potentially
    helpful warnings (such as the presence of [data leakage](https://machinelearningmastery.com/data-leakage-machine-learning/),
    which is when the model has access to features that will not be available when
    deployed to production on unseen data) when working with your data.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason to use these kinds of platforms is that the hardware on which
    to run models is also provided. Hence, one does not need to buy and maintain their
    own computers and components such as Graphical Processing Units (GPUs).
  prefs: []
  type: TYPE_NORMAL
- en: The Dataset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The dataset, provided by a gaming company using the platform, can be viewed
    [here](https://app.actable.ai/r/ze61cu96uA3ZKApZgUCztA) and has a [CC BY-SA-4
    license](https://creativecommons.org/licenses/by-sa/4.0/) associated with it,
    allowing sharing and adaptation as long as the appropriate credit is provided.
    It has a total of 789,879 rows (samples), which is quite substantial and should
    help to reduce effects such as model [over-fitting](https://en.wikipedia.org/wiki/Overfitting).
  prefs: []
  type: TYPE_NORMAL
- en: The dataset contains information about each level that a person has played in
    a mobile app. For example, there’s information on the amount of time played, whether
    the player won or lost the level, the level number, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The user IDs have also been included, but they have been anonymised so as not
    to reveal the original players’ identities. Some fields have also been removed.
    However, it should provide a solid basis to see if the tools provided by the ML
    platform considered in this article can be useful in trying to predict whether
    a player will churn.
  prefs: []
  type: TYPE_NORMAL
- en: 'The meaning of each feature is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Churn`: ‘1’ if the player has not played the game in more than 2 weeks, ‘0’
    otherwise'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ServerTime`: the servers’ timestamp when the level was played'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EndType`: the reason why the level ended (mainly ‘Win’ if the player won the
    game, and ‘Lose’ if the player lost the game)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LevelType`: type of the level'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Level`: the level number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SubLevel`: sub-level number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Variant`: level variant'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Levelversion`: level version'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NextCar`: unused (included to see how the platform handles features having
    only one label, as discussed later)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddMoves`: additional moves available'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DoubleMana`: unused (included to see how the platform handles features having
    only one label, as discussed later)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StartMoves`: number of moves available at the beginning of the level'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExtraMoves`: extra moves purchased'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UsedMoves`: moves used by the player'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UsedChangeCar`: unused (included to see how the platform handles features
    having only one label, as discussed later)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WatchedVideo`: whether a video was watched, providing extra moves'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BuyMoreMoves`: Number of times a player purchased more moves'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PlayTime`: time spent playing the level'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Scores`: score achieved by the player'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UsedCoins`: total coins used in the level'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MaxLevel`: maximum level reached by the player'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Platform`: device type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UserID`: ID of the player'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RollingLosses`: number of successive losses by the player'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploratory Data Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step before training is to get an understanding of the data through
    Exploratory Data Analysis (EDA). EDA is a data analysis approach that involves
    summarizing, visualizing, and understanding the main characteristics of a dataset.
    The goal is to gain insights into the data and identify any patterns, trends,
    anomalies, or any issues (e.g. missing values) that may be present, and which
    can help inform the features and models to be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by checking out the main reasons for levels being ended:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/576f1a4434eb9416e890a1b7dc9843fa.png)'
  prefs: []
  type: TYPE_IMG
- en: Statistics of some columns in the dataset. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: In the image above, we can see that the predominant cause of the level ending
    (represented by `EndType`) is due to the player losing the game (63.6%) versus
    35.2% of players winning the game. We can also see that the `UsedChangeCar` column
    appears to be useless since it contains the same value for all rows.
  prefs: []
  type: TYPE_NORMAL
- en: A very important observation is that our target value is highly imbalanced,
    with only 63 samples out of the first 10,000 rows (i.e. 0.6% of the data) having
    a churn value of 1 (i.e. a player has churned). This will need to be kept in mind,
    because it is likely that our models can be very easily biased to only predict
    a value of 0 for `Churn`. The reason is that the model can attain very good values
    for some metrics such as accuracy; in this case, if a dummy model that simply
    selects the most prevalent class, it will be right 99.4% of the time! I invite
    you to read more about this in two great articles by [Baptiste Rocca](/handling-imbalanced-datasets-in-machine-learning-7a0e84220f28)
    and [Jason Brownlee](https://machinelearningmastery.com/failure-of-accuracy-for-imbalanced-class-distributions/).
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, Actable AI does not yet offer any way to handle imbalanced data,
    such as via the [Synthetic Minority Oversampling Technique (SMOTE)](https://machinelearningmastery.com/smote-oversampling-for-imbalanced-classification/),
    or by using class weights or different sampling strategies. This means that we
    would need to be careful when it comes to the metric chosen for optimisation.
    As mentioned above, accuracy would not be the best choice given that a high rate
    can be achieved even if the samples of one class are never labeled correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful type of analysis is the correlation between features, especially
    those of the predictor features with the target feature. This can be done using
    the ‘Correlation Analysis’ tool, the results of which can be viewed directly on
    the Actable AI platform [here](https://app.actable.ai/r/QZ-BLTgqb8ggJIiRVh3zpQ):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f2eab9f0bb3310d5a62c3bd42cf9738f.png)'
  prefs: []
  type: TYPE_IMG
- en: Positive/Negative Chart. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: In the chart above, the blue bars indicate positive correlation of a feature
    with the `Churn` when the value is equal to 1, while the orange bars indicate
    negative feature correlations. It should be noted that correlation lies between
    -1 and 1, where positive values represent that both features tend to change in
    the same direction (e.g. both increase or both decrease), whereas negative correlation
    simply indicates that when one of the features increases or decreases, the other
    does the opposite. As such, the magnitude of the correlation (ignoring the negative
    sign) is perhaps the most important thing of note.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of takeaways, such as players that lose a level being more
    susceptible to churning (top-most blue bar), and conversely that players who win
    a level tend to keep on playing (third orange bar). However, it should also be
    noted that the values are fairly low, indicating that these features are quite
    weakly correlated with the target. This means that it will probably be necessary
    to perform *feature engineering*, whereby the existing features are used to create
    new ones that capture more salient information that would enable a model to perform
    more accurate predictions. Feature engineering will be discussed in further detail
    later in this article.
  prefs: []
  type: TYPE_NORMAL
- en: However, before creating new features, it is worth seeing what sort of performance
    we can achieve using just the original features in our dataset. The next step
    will thus probably be more exciting — training a model to see what sort of performance
    can be attained.
  prefs: []
  type: TYPE_NORMAL
- en: Training a Classification Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we would like to predict if a user will stop playing or not, this is a
    *classification* problem where one of a number of labels needs to be selected.
    In our case, the problem involves assigning one of two labels (‘1’ corresponding
    to ‘Churn’, and ‘0’ corresponding to ‘No Churn’), which further makes it a *binary*
    classification problem.
  prefs: []
  type: TYPE_NORMAL
- en: This process is done primarily via the [AutoGluon](https://github.com/autogluon/autogluon)
    library, which automatically trains a number of models to then select the one
    attaining the best performance. This avoids having to manually train individual
    models and compare their performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'A number of parameters need to be set in the Actable AI platform, with my choices
    shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/18e2c7d418273b8712c517c9fce3bd00.png)'
  prefs: []
  type: TYPE_IMG
- en: Options selected in the Actable AI web app. Image provided by author.
  prefs: []
  type: TYPE_NORMAL
- en: The metric to use for optimisation of the models can also be chosen. I used
    the [Area under the Receiver Operating Characteristics (AUC ROC) Curve](https://developers.google.com/machine-learning/glossary#auc-area-under-the-roc-curve),
    since it is much less sensitive to the class imbalance issue discussed earlier.
    Values range from 0 to 1 (the latter being a perfect score).
  prefs: []
  type: TYPE_NORMAL
- en: After some time, the results are generated and displayed, which can also be
    viewed [here](https://app.actable.ai/r/C3FLuD7jpJY2NaV2VLdKDg). A number of different
    metrics are computed, which is not only good practice but pretty much necessary
    if we truly want to understand our model, given that each metric focuses on certain
    aspects of a model’s performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first metric that is displayed is the optimisation metric, with a value
    of 0.675:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e4ea302c903c1803fca04dcbc95536be.png)'
  prefs: []
  type: TYPE_IMG
- en: Evaluation Metrics. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: This is not great, but recall that the features were quite weakly correlated
    with the target during our EDA, so it is unsurprising that performance is unremarkable.
  prefs: []
  type: TYPE_NORMAL
- en: This result also highlights the importance of understanding the results; we
    would normally be very happy with an accuracy of 0.997 (i.e. 99.7%). However,
    this is largely due to the highly imbalanced nature of the dataset, as discussed
    earlier, so it shouldn’t be given much importance. Meanwhile, scores like the
    precision and recall are based on a threshold of 0.5 by default, which may not
    be the most suitable for our application.
  prefs: []
  type: TYPE_NORMAL
- en: '[ROC](https://developers.google.com/machine-learning/glossary#roc-receiver-operating-characteristic-curve)
    and [precision-recall curves](https://machinelearningmastery.com/roc-curves-and-precision-recall-curves-for-classification-in-python/)
    are also shown, which again clearly show that the performance is a bit poor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/bc830ba4048cf3377a7acf9e78b53c53.png)![](../Images/f460be3a37ecf272e79f0ccdd8038ba6.png)'
  prefs: []
  type: TYPE_IMG
- en: ROC curve (left) and precision-recall curve (right) of the trained model. Images
    by author.
  prefs: []
  type: TYPE_NORMAL
- en: These curves are also useful to determine what threshold we could use in our
    final application. For example, if it is desired to minimize the number of false
    positives, then we can select a threshold where the model obtains a higher precision,
    and check what the corresponding recall will be like.
  prefs: []
  type: TYPE_NORMAL
- en: 'The importance of each feature for the best model obtained can also be viewed,
    which is perhaps one of the more interesting results. This is computed using [permutation
    importance via AutoGluon](https://auto.gluon.ai/stable/api/autogluon.tabular.TabularPredictor.feature_importance.html).
    [P-values](https://en.wikipedia.org/wiki/P-value) are also shown to determine
    the reliability of the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c3d1e484aadbd41848dfe25df6bce665.png)'
  prefs: []
  type: TYPE_IMG
- en: Feature Importance Table. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps unsurprisingly, the most important feature is `EndType` (showing what
    caused the level to end, such as a win or a loss), followed by `MaxLevel`(the
    highest level played by a user, with higher numbers indicating that a player is
    quite engaged and active in the game).
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, `UsedMoves` (the number of moves performed by a player) is
    practically useless, and `StartMoves` (the number of moves available to a player)
    could actually harm performance. This also makes sense, since the number of moves
    used and the number of moves available to a player by themselves aren’t highly
    informative; a comparison between them would probably be much more useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could also have a look at the estimated probabilities of each class (either
    1 or 0 in this case), which are used to derive the predicted class (by default,
    the class having the highest probability is assigned as the predicted class):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/cddb98bd5cec2315e136b03ddb02abe1.png)'
  prefs: []
  type: TYPE_IMG
- en: Table with original values, Shapley values, and predicted values. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: '[Explainable AI](https://cloud.google.com/explainable-ai#:~:text=Explainable%20AI%20is%20a%20set,others%20understand%20your%20models''%20behavior.)
    is becoming ever more important to understand model behaviour, which is why tools
    like [Shapley values](https://docs.actable.ai/glossary.html#shapley-values) are
    increasing in popularity. These values represent the contribution of a feature
    on the probability of the predicted class. For instance, in the first row, we
    can see that a `RollingLosses` value of 36 decreases the probability of the predicted
    class (class 0, i.e. that the person will keep playing the game) for that player.'
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, this means that the probability of the other class (class 1, i.e.
    that a player churns) is increased. This makes sense, because higher values of
    `RollingLosses` indicate that the player has lost many levels in succession and
    is thus more likely to stop playing the game due to frustration. On the other
    hand, low values of `RollingLosses` generally improve the probability of the negative
    class (i.e. that a player will not stop playing).
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned, a number of models are trained and evaluated, following which
    the best one is then selected. It is interesting to see that the best model in
    this case is [LightGBM](https://en.wikipedia.org/wiki/LightGBM), which is also
    one of the fastest:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/31ff24f446b7cef2af787163f068bb36.png)'
  prefs: []
  type: TYPE_IMG
- en: Information on the models trained. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the Model Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, we can try improving the performance of the model. Perhaps one
    of the easiest ways is to select the ‘Optimize for quality’ option, and see how
    far we can go. This option configures several parameters that are known to generally
    improve performance, at the expense of a potentially slower training time. The
    following results were obtained (which you can also view [here](https://app.actable.ai/r/ze61cu96uA3ZKApZgUCztA)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e37ee8499c3922291c91c72cc3931a29.png)'
  prefs: []
  type: TYPE_IMG
- en: Evaluation Metrics when using the ‘Optimize for quality’ option. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: Again focusing on the ROC AUC metric, performance improved from 0.675 to 0.709\.
    This is quite a nice increase for such a simple change, although still far from
    ideal. Is there something else that we can do to improve performance further?
  prefs: []
  type: TYPE_NORMAL
- en: Creating New Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed earlier, we can do this using *feature engineering*. This involves
    creating new features from existing ones, which are able to capture stronger patterns
    and are more highly correlated with the variable to be predicted.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, the features in the dataset have a fairly narrow scope since the
    values pertain to only one single record (i.e. the information on a level played
    by the user). Hence, it might be very useful to get a more global outlook by summarizing
    records over time. In this way, the model would have knowledge on the historical
    trends of a user.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, we could determine how many extra moves were used by the player,
    thereby providing a measure of the difficulty experienced; if few extra moves
    were needed, then the level might have been too easy; on the other hand, a high
    number might mean that the level was too hard.
  prefs: []
  type: TYPE_NORMAL
- en: It would also be a good idea to check if the user is immersed and engaged in
    playing the game, by checking the amount of time spent playing it over the last
    few days. If the player has not played the game much, it might mean that they’re
    losing interest and may stop playing soon.
  prefs: []
  type: TYPE_NORMAL
- en: Useful features vary across different domains, so it is important to try and
    find any information pertaining to the task at hand. For example, you could find
    and read research papers, case studies, and articles, or seek the advice of companies
    or professionals who have worked in the field and are thus experienced and well-versed
    with the most common features, their relationships with each other, any potentially
    pitfalls, and which new features that are most likely to be useful. These approaches
    help in reducing trial-and-error, and speed up the feature engineering process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the recent advances in Large Language Models (LLMs) (for example, you
    may have heard of [ChatGPT](https://chat.openai.com/)…), and given that the process
    of feature engineering might be a bit daunting for inexperienced users, I was
    curious to see if LLMs could be at all useful in providing ideas on what features
    could be created. I did just that, with the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3293709148c6044e8bb2af656d7b9f17.png)'
  prefs: []
  type: TYPE_IMG
- en: ChatGPT’s answer when asking about what new features can be created to predict
    player churn more accurately. The reply is actually quite useful. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: ChatGPT’s reply is actually quite good, and also points to a number of time-based
    features as discussed above. Of course, keep in mind that we might not be able
    to implement all of the suggested features if the required information is not
    available. Moreover, it is well-known that it is [prone to hallucination](https://spectrum.ieee.org/ai-hallucination),
    and as such may not provide fully accurate answers.
  prefs: []
  type: TYPE_NORMAL
- en: We could get more relevant responses from ChatGPT, for example by specifying
    the features that we’re using or by employing [prompts](https://github.com/f/awesome-chatgpt-prompts),
    but this is beyond the scope of this article and is left as an exercise to the
    reader. Nevertheless, LLMs could be considered as an initial step to get things
    going, although it is still highly recommended to seek more reliable information
    from papers, professionals, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: On the Actable AI platform, new features can be created using the fairly well-known
    [SQL](https://en.wikipedia.org/wiki/SQL) programming language. For those less
    acquainted with SQL, approaches such as utilizing [ChatGPT](https://chat.openai.com/)
    to automatically generate queries may prove useful. However, in my limited experimentation,
    the reliability of this method can be somewhat inconsistent.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure accurate computation of the intended output, it is advisable to manually
    examine a subset of the results to verify that the desired output is being computed
    correctly. This can easily be done by checking the table that is displayed after
    the query is run in SQL Lab, Actable AI’s interface to write and run SQL code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the SQL code I used to generate the new columns, which should help give
    you a head start if you would like to create other features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, ‘windows’ are created to define the range of time to consider,
    such as the last day, last week, or last two weeks. The records falling within
    that range will then be used during the feature computations, which are mainly
    intended to provide some historical context as to the player’s journey in the
    game. The full list of features is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`time_spend_on_level`: time spent by a user in playing the level. Gives an
    indication of level difficulty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`levels_completed_in_last_7_days`: The number of levels completed by a user
    in the last 7 days (1 week). Gives an indication of level difficulty, perseverance,
    and immersion in game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`total_wins_in_last_14_days`: the total number of times a user has won a level'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`total_losses_in_last_14_days`: the total number of times a user has lost a
    level'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`win_to_lose_ratio_in_last_14_days`: Ratio of the number of wins to the number
    of losses (`total_wins_in_last_14_days/total_losses_in_last_14_days`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UsedCoins_in_last_1_days`: the number of used coins within the previous day.
    Gives an indication of the level difficulty, and willingness of a player to spend
    in-game currency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UsedCoins_in_last_7_days`: the number of used coins within the previous 7
    days (1 week)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UsedCoins_in_last_14_days`: the number of used coins within the previous 14
    days (2 weeks)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExtraMoves_in_last_1_days`: The number of extra moves used by a user within
    the previous day. Gives an indication of level difficulty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExtraMoves_in_last_7_days`: The number of extra moves used by a user within
    the previous 7 days (1 week)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExtraMoves_in_last_14_days`: The number of extra moves used by a user within
    the previous 14 days (2 weeks)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RollingLosses_mean_last_7_days`: The average number of cumulative losses by
    a user over the last 7 days (1 week). Gives an indication of level difficulty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MaxLevel_mean`: the mean of the maximum level reached across all users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Max_Level`: The maximum level reached by a player in the last 7 days (1 week).
    In conjunction with `MaxLevel_mean`, it gives an indication of a player’s progress
    with respect to the other players.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Min_Level`: The minimum level played by a user in the last 7 days (1 week)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PlayTime_cumul_7_days`: The total time played by a user in the last 7 days
    (1 week). Gives an indication to the player’s immersion in the game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PlayTime_cumul`: The total time played by a user (since the first available
    record)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RollingLosses_cumul_7_days`: The total number of rolling losses over the last
    7 days (1 week). Gives an indication of the level of difficulty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important that only the past records are used when computing the value
    of a new feature in a particular row. In other words, the use of future observations
    must be avoided, since the model will obviously not have access to any future
    values when deployed in production.
  prefs: []
  type: TYPE_NORMAL
- en: Once satisfied with the features created, we can then save the table as a new
    dataset, and run a new model that should (hopefully) attain better performance.
  prefs: []
  type: TYPE_NORMAL
- en: Training a New (hopefully improved) Classification Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Time to see if the new columns are any useful. We can repeat the same steps
    as before, with the only difference being that we now use the new dataset containing
    the additional features. The same settings are used to enable a fair comparison
    with the original model, with the following results (which can also be viewed
    [here](https://app.actable.ai/r/GDfT0fXaMmYO-5cmt-XxZA)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/cc9aff0dd7f3d14e64986ab9a92e2925.png)'
  prefs: []
  type: TYPE_IMG
- en: Evaluation Metrics using the new columns. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: The ROC AUC value of 0.918 is much improved compared with the original value
    of 0.675\. It’s even better than the model optimized for quality (0.709)! This
    demonstrates the importance of understanding your data and creating new features
    that are able to provide richer information.
  prefs: []
  type: TYPE_NORMAL
- en: 'It would now be interesting to see which of our new features were actually
    the most useful; again, we could check the feature importance table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/16410615270256f5f7c7ca1aa6a8826b.png)'
  prefs: []
  type: TYPE_IMG
- en: Feature importance table of the new model. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: It looks like the total number of losses in the last two weeks is quite important,
    which makes sense because the more often a player loses a game, it is potentially
    more likely for them to become frustrated and stop playing.
  prefs: []
  type: TYPE_NORMAL
- en: The average maximum level across all users also seems to be important, which
    again makes sense because it can be used to determine how far off a player is
    from the majority of other players — much higher than the average indicates that
    a player is well immersed in the game, while values that are much lower than the
    average could indicate that the player is still not well motivated.
  prefs: []
  type: TYPE_NORMAL
- en: These are only a few simple features that we could have created. There are other
    features that we can create, which could improve performance further. I will leave
    that as an exercise to the reader to see what other features could be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Training a model optimized for quality with the same time limit as before did
    not improve performance. However, this is perhaps understandable because a greater
    number of features is being used, so more time might be needed for optimisation.
    As can be observed [here](https://app.actable.ai/r/G8frdBHCjbl9twVSTKuP8w), increasing
    the time limit to 6 hours indeed improves performance to 0.923 (in terms of the
    AUC):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/beaf8b4e003c1323f94db9f1c4fad341.png)'
  prefs: []
  type: TYPE_IMG
- en: Evaluation metric results when using the new features and optimizing for quality.
    Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: It should also be noted that some metrics, such as the precision and recall,
    are still quite poor. However, this is because a classification threshold of 0.5
    is assumed, which may not be optimal. Whilst the threshold may be changed by clicking
    on the curves, the AUC is threshold independent and can give a more comprehensive
    picture of the performance. As mentioned earlier, the AUC is especially useful
    when used as the optimisation metric whilst training on imbalanced datasets, as
    is the case here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The performance in terms of the AUC of the trained models can be summarised
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Model Deployment in Production
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s no use having a good model if we can’t actually use it on new data. Machine
    learning platforms may offer this ability to generate predictions on future unseen
    data given a trained model. For example, the Actable AI platform allows the use
    of an [API](https://en.wikipedia.org/wiki/API) that allows the model to be used
    on data outside of the platform, as is exporting the model or inserting raw values
    to get an instant prediction.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is crucial to periodically test the model on future data, to determine
    if it is still performing as expected. Indeed, it may be necessary to re-train
    the models with the newer data. This is because the characteristics (e.g. feature
    distributions) may change over time, thereby affecting the accuracy of the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a new policy may be introduced by a company that then affects
    customer behaviours (be it positively or negatively), but the model may be unable
    to take the new policy into account if it does not have access to any features
    reflecting the new change. If there are such drastic changes but no features that
    could inform the model are available, then it could be worth considering the use
    of two models: one trained and used on the older data, and another trained and
    used with the newer data. This would ensure that the models are specialised to
    operate on data with different characteristics that may be hard to capture with
    a single model.'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this article, a real-world dataset containing information on each level played
    by a user in a mobile app was used to train a classification model that can predict
    whether a player will stop playing the game in two weeks’ time.
  prefs: []
  type: TYPE_NORMAL
- en: The whole processing pipeline was considered, from EDA to model training to
    feature engineering. Discussions on the interpretation of results and how we could
    improve upon them was provided, to go from a value of 0.675 to a value of 0.923
    (where 1.0 is the maximal value).
  prefs: []
  type: TYPE_NORMAL
- en: The new features that were created are relatively simple, and there certainly
    exist many more features that could be considered. Moreover, techniques such as
    feature normalisation and standardisation could also be considered. Some useful
    resources can be found [here](/normalization-vs-standardization-quantitative-analysis-a91e8a79cebf)
    and [here](https://machinelearningmastery.com/how-to-improve-neural-network-stability-and-modeling-performance-with-data-scaling/).
  prefs: []
  type: TYPE_NORMAL
- en: 'With regards to the Actable AI platform, I may of course be a bit biased, but
    I do think that it helps simplify some of the more tedious processes that need
    to be done by data scientists and machine learning experts, with the following
    desirable aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: Core ML library is open-source, so it can be verified to be safe to use by anyone
    who has good programming knowledge. It can also be used by anyone who knows Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For those who do not know Python or are not familiar with coding, the GUI offers
    a way to use a number of analytics and visualisations with little fuss
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s not too difficult to start using the platform (it does not overwhelm the
    user with too much technical information that may dissuade less knowledgeable
    people from using it)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Free tier allows running of analytics on datasets that are publicly available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A vast number of tools are available (apart from classification considered in
    this article)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That said, there are a few drawbacks while several aspects could be improved,
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Free tier does not allow running ML models on private data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User interface looks a bit dated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some visualisations can be unclear and sometimes hard to interpret
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: App can be slow to respond at times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No support for imbalanced data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some knowledge of data science and machine learning is still needed to extract
    the most out of the platform (although this is probably true of other platforms
    too)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In other future articles, I will consider using other platforms to determine
    their strengths and weaknesses, and thereby which use cases best fit each platform.
  prefs: []
  type: TYPE_NORMAL
- en: Until then, I hope this article was an interesting read! Please feel free to
    leave any feedback or questions that you may have!
  prefs: []
  type: TYPE_NORMAL
- en: '*Do you have any thoughts about this article? Please feel free to post a note,
    comment, or message me directly on* [*LinkedIn*](https://www.linkedin.com/in/cgalea)!'
  prefs: []
  type: TYPE_NORMAL
- en: '*Also, make sure to* [***Follow***](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fa9be78db0c9b&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fplayer-churn-rate-prediction-data-analysis-and-visualisation-part-1-12a9fdff9c10&user=Christian+Galea&userId=a9be78db0c9b)
    *me to ensure that you’re notified upon publication of future articles.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9b800d9a965cfbb1a33f23e4d154787b.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Pixabay](https://www.pexels.com/photo/application-blur-business-code-270408/)
  prefs: []
  type: TYPE_NORMAL
- en: '*The author was a data scientist with Actable AI at the time of writing this
    article.*'
  prefs: []
  type: TYPE_NORMAL
