- en: 'AI Search Algorithms: A Deep Dive into the Most Popular Ones'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/ai-search-algorithms-a-deep-dive-into-the-most-popular-ones-2760679368bb](https://towardsdatascience.com/ai-search-algorithms-a-deep-dive-into-the-most-popular-ones-2760679368bb)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Going through four of the most-used search algorithms in AI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://polmarin.medium.com/?source=post_page-----2760679368bb--------------------------------)[![Pol
    Marin](../Images/a4f69a96717d453db9791f27b8f85e86.png)](https://polmarin.medium.com/?source=post_page-----2760679368bb--------------------------------)[](https://towardsdatascience.com/?source=post_page-----2760679368bb--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----2760679368bb--------------------------------)
    [Pol Marin](https://polmarin.medium.com/?source=post_page-----2760679368bb--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----2760679368bb--------------------------------)
    ·11 min read·Aug 23, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b054060379f1a626a70cb89b3b1a1aa8.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Mitchell Luo](https://unsplash.com/@mitchel3uo?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: It’s as if we don’t have enough humans on Earth, that we’ve been trying for
    years to create machines that behave like us. We create mathematical models or
    agents that act rationally, so we don’t have to rely on other human beings’ decisions.
  prefs: []
  type: TYPE_NORMAL
- en: Search algorithms were the most used for a long time, but with the rise of machine
    and deep learning, they’ve kind of taken a seat back. However, I think all data
    scientists should know about them because they are an amazing toolset that will
    prove useful in many situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'They can be applied in many situations, but the most representative ones are
    games: tic tac toe, maze, even chess… And we’ll use these to explain the algorithms
    we’ll be visiting today.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be introducing four of the most famous ones and we’ll be expanding a little
    bit on them, using some practical and visual examples.
  prefs: []
  type: TYPE_NORMAL
- en: As always, refer to the **Resources** section at the bottom of this article
    for more info and code.
  prefs: []
  type: TYPE_NORMAL
- en: But before that, we need to introduce some definitions to understand some key
    terms.
  prefs: []
  type: TYPE_NORMAL
- en: Terminology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Agent**: it’s the human, model, or algorithm that interacts with its environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State**: a particular environment or set of elements that represent the problem
    at a given moment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State space**: the set of all possible reachable states.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Goal state**: the final state, where certain conditions are met.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Action**: a function or decision the agent must make in a given state to
    move to the next one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could define more terms but these are the basic-most ones, enough for today’s
    topic.
  prefs: []
  type: TYPE_NORMAL
- en: Representation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AI Search Algorithms are usually explained using graphs and we won’t change
    the status quo today.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a sample graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f6c04074d7aaf42713247bfdce3b4128.png)'
  prefs: []
  type: TYPE_IMG
- en: Sample graph we’ll use to explain the concepts — image by the author
  prefs: []
  type: TYPE_NORMAL
- en: In a graph, each node is a state. And we always have the **initial state** (A
    in this case, in green) and the **goal state** (which I’ve decided it’ll be E,
    in red). It's through the **actions** we defined in the previous section that
    our agent can move from one state to the next and repeat that successively until
    we reach the goal state.
  prefs: []
  type: TYPE_NORMAL
- en: All the nodes, from A to F, define the **state space**.
  prefs: []
  type: TYPE_NORMAL
- en: What differs then is the algorithm we use to get from A to E. And that’s what
    we’ll start exploring next.
  prefs: []
  type: TYPE_NORMAL
- en: Depth First Search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Depth First Search (DFS)[1] algorithm is one of the **uninformed search
    algorithms**, in which the only information we have is the one provided in the
    problem definition.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, in an uninformed search algorithm, we know where we want to
    go — we want to reach the goal state E — but we don’t know how close or far we
    are from it.
  prefs: []
  type: TYPE_NORMAL
- en: The Depth First Search in particular keeps on moving forward until it reaches
    a leaf node. At each bifurcation it might encounter, it randomly selects one direction
    and keeps on moving forward.
  prefs: []
  type: TYPE_NORMAL
- en: If the leaf node we reach is the goal state, then we’re done. But if it’s not,
    then it goes up again to the last bifurcation and keeps on moving forward. This
    process is repeated recursively until we get to the goal state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see it now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3c95b2c864a81e567d60f541f5d3eb82.png)'
  prefs: []
  type: TYPE_IMG
- en: The first action applied — image by the author
  prefs: []
  type: TYPE_NORMAL
- en: From the initial state A, we can only move towards B. So, after the action takes
    place, our agent will be in that second state. Then comes the bifurcation, and
    we need to choose. As DFS is an uninformed type of algorithm, it chooses randomly
    because we know nothing about which one is best. Let’s suppose it chose F instead
    of C.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b338de4f49ee8c9e3dbf9061730aa8b4.png)'
  prefs: []
  type: TYPE_IMG
- en: DFS second decision — image by the author
  prefs: []
  type: TYPE_NORMAL
- en: As the algorithm is trained to go in-depth until it explores other branches,
    it will have to again decide between going to D and E. If it chose E, we’d be
    done. But we’re unlucky this time and it randomly goes to D.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/56664120de80a6334313d9c3704fcce2.png)'
  prefs: []
  type: TYPE_IMG
- en: Possible DFS implementation — image by the author
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the algorithm has visited A, B, F, and D. Being at D, there’s
    only one direction possible and it takes us to E. There, we’re done.
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm is simple yet effective in multiple cases. It follows the last-in
    first-out strategy and that’s why it could be implemented using a stack.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, the optimal solution gets us from A to E in 3 steps, but it’s
    not guaranteed. In fact, the example we followed took us 4 actions.
  prefs: []
  type: TYPE_NORMAL
- en: Breadth-First Search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Breadth First Search or BFS[2] is another type of uninformed search algorithm
    and we could say it’s the opposite of DFS: instead of going deep branch by branch,
    it doesn’t reach the next depth level until all nodes from the previous level
    have been explored.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While we used a stack in DFS, here we use a queue: it follows the first-in-first-out
    strategy.'
  prefs: []
  type: TYPE_NORMAL
- en: Again, let’s traverse the graph to see it visually. It goes from A to B as we
    saw previously, we have no alternative here. Then we arrive at the bifurcation
    at B and, as it’s an uninformed algorithm, we simply choose randomly between C
    and F. We’ll basically be exploring both, it’s just a matter of which one we explore
    first.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/57cfeb2f89179eb61ec809430442204b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Second step of BFS: we’ve explored A, B, C and F— image by the author'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve explored level 1 (node A), level 2 (node B), and level 3 (nodes C and
    F). We now move on to level 4, where we explore the final leaves — E and D.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, whether we explore E before D or vice versa is a completely arbitrary
    decision:'
  prefs: []
  type: TYPE_NORMAL
- en: If C went first in the B bifurcation, then we would reach E right after that.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But if F went first, then a random decision would be made as to whether we explore
    D or E first.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BFS has some potential, as well as DFS, but both have their flaws. One will
    be best in some cases but will result inefficient in others. These are simple
    algorithms and, while still useful, we deserve more.
  prefs: []
  type: TYPE_NORMAL
- en: Greedy Best-First Search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the first **informed search algorithm** we’ll be visiting today. In
    this kind of algorithm, we do have information about the goal state, and our duty
    is to use that information to choose wisely before each step. We define the term
    *heuristic* as this piece of information that tells us how close or far we are
    from the goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Greedy Best-First Search** (GBFS)[3] algorithm is simple: we simply move
    toward the nodes that take us closer to the goal node, and the heuristic *h(x)*
    is the one measuring the closeness.'
  prefs: []
  type: TYPE_NORMAL
- en: In the typical maze game, the closeness could be expressed by the number of
    pixels/tiles away we are from it, both in the vertical and horizontal direction.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s suppose an example, in which we want to go from A to B, and we’ve already
    played up until we reach a tricky decision point. If we were using BFS or DFS,
    the selection would have been random. But we’re using informed algorithms now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the following maze, in which there’s a number in each tile defining how
    many tiles away we are from the goal. In other words, the heuristic defines the
    number of steps we need to go from the actual tile to the goal, supposing a maze
    without walls in which we can only move horizontally or vertically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/25739bcdc10df56469846942fe61f1ba.png)'
  prefs: []
  type: TYPE_IMG
- en: Sample maze with closeness heuristic values — image by the author
  prefs: []
  type: TYPE_NORMAL
- en: If we used GBFS, the closeness heuristic we’re using suggests that we go up
    because if we go up the number of steps needed to reach B is decreased from 2
    to 1, but if we go down it increases from 2 to 3\. In other words, if we go up
    we get closer to the goal and we move further if we decide to go down.
  prefs: []
  type: TYPE_NORMAL
- en: This isn’t perfect, because we’re only taking into account how close we are
    to B, but not the actual walls we have between us and the goal state. That’s something
    we just cannot control with GBFS.
  prefs: []
  type: TYPE_NORMAL
- en: For consistency purposes, let me go back to the graph representation we’ve been
    using on and on, only that this time it will be a whole new graph. We still want
    to get from A to E but, as we already know, we now have information in each node
    about how close we are to the end state.
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to use the letter h to provide an imaginary value to the heuristic.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/de36516b65b435651198708477a72df8.png)'
  prefs: []
  type: TYPE_IMG
- en: Sample graph with heuristics — image by the author
  prefs: []
  type: TYPE_NORMAL
- en: 'The proposed example works the same way the maze does: every action required
    to move from state to state gets us either one unit closer to the goal, one unit
    further, or makes us remain the same. The most optimal path is clear: From A to
    C to E. It’s a matter of moving toward the node with a smaller *h(x)* if there’s
    a bifurcation.'
  prefs: []
  type: TYPE_NORMAL
- en: But it could have been different. Imagine that the heuristic didn’t differ by
    one unit at max from node to node, but it depended on several environmental factors.
    If it was that way, the optimal path would not have changed in our example, because
    it’s a really simple one, but it would be a totally different story in a more
    complex graph.
  prefs: []
  type: TYPE_NORMAL
- en: Greedy Best-First Search is a powerful algorithm but it isn’t perfect. While
    it considers how close we are to the goal, it doesn’t take into account the actual
    costs of having gone that far.
  prefs: []
  type: TYPE_NORMAL
- en: Believe it or not, the cost of getting to a state or node is as important as
    the cost of the greedy search.
  prefs: []
  type: TYPE_NORMAL
- en: Get ready for the next algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: A* Search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **A* search algorithm**[4] is a variation of the GBFS algorithm but now,
    as stated, we take into account the costs of getting to each node. In other words,
    traversing via different edges might not have the same cost.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll define:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Forward cost** — *h(x)*. It’s the same heuristic used in GBFS: the distance
    between the current state and the goal state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Backward cost** — g(x). It’s the cost of going from the initial state to
    the current state. It’s a cumulative cost, in the sense that it sums all the previous
    costs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The goal of A* Search then is to find a path where the sum of both costs is
    the least. In mathematical terms, the overall cost of the node *x* is given by
    ***f(x) = g(x) + h(x).***
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, I’ll be using the initial graph we’ve already used. We
    still want to get from A to E and the costs are shown now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9d7645d5ad830ed6627870fc22449db8.png)'
  prefs: []
  type: TYPE_IMG
- en: New graph to perform the A* Search in — image by the author
  prefs: []
  type: TYPE_NORMAL
- en: Take a moment to think about which could be the optimal path here. The numbers
    around the nodes are the forward costs and the numbers close to the lines are
    the backward costs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to decipher it now, going step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: We have no other option than going from A to B. The cost of reaching B is *f(B)
    = 2 + 2 = 4*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From B, we can either go to C or F. Here we pause and check which one’s lower.
    We see that *f(C) = 7 + 1 = 8* and *f(F) = 3+1 = 4*. Then, we determine **F**
    to be the best solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From F, we again have two options: we can go to E and reach the goal state
    or go towards D. Most would choose E because we wouldn’t need to do extra steps,
    but we’re smart and we’ll let the math do the work: *f(D) = 6+1 = 7* and *f(E)
    = 13+0 = 13*. D is therefore a better option than E.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: However, remember that we still have an open path at B, where we could go towards
    C. But the cost of going from B to C is 8, still above 7, so we’ll still keep
    on moving in the F->D direction.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: From D we can only go to E (or move backward to F, which doesn’t make sense).
    The cost is *f(E) = 7+0 = 7*. As it is still lower than f(C), we’re done here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So the optimal path is finally A->B->F->D->E.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0de3368e80d2cce428ecb80baf0d4629.png)'
  prefs: []
  type: TYPE_IMG
- en: Optimal path using A* Search— image by the author
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Put this knowledge into practice.
  prefs: []
  type: TYPE_NORMAL
- en: We haven’t used any code here because I believe trying to build it on your own
    is the best way to understand how these algorithms work. However, in the resources
    section below you’ll have a link to a GitHub repo[5] I’ve created where I’ve coded
    three of these four algorithms we’ve seen today.
  prefs: []
  type: TYPE_NORMAL
- en: My implementations are simple and not the most efficient. My goal in providing
    the code was to let you play with it and improve it your way by making an iterative
    function recursive, by creating more complex classes…
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and try to implement your own maze implementation using DFS, BFS, GBFS,
    or A* Search. Don’t just copy my code, use it as a template (you might find some
    surprises there).
  prefs: []
  type: TYPE_NORMAL
- en: Be creative and resourceful, and don’t stop here. Try other algorithms we haven’t
    covered here like minimax or uniform cost search. Google is your friend.
  prefs: []
  type: TYPE_NORMAL
- en: Today I’ve covered the basics of these four algorithms showing how they work
    with visual examples and following a set of steps. I used simple examples but
    the process is the same on larger graphs.
  prefs: []
  type: TYPE_NORMAL
- en: The key here is, as data scientists, to understand them, know how to use them,
    and, most importantly, identify situations in which they could be useful for us.
  prefs: []
  type: TYPE_NORMAL
- en: Search algorithms are just a part of AI and they’re still key even though they’ve
    been around for a while.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and try them out!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’d like to support me further, consider subscribing to Medium’s Membership
    through the link you find below: it won’t cost you any extra penny but will help
    me through this process.'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/@polmarin/membership?source=post_page-----2760679368bb--------------------------------)
    [## Join Medium with my referral link - Pol Marin'
  prefs: []
  type: TYPE_NORMAL
- en: Read every story from Pol Marin (and thousands of other writers on Medium).
    Your membership fee directly supports Pol…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/@polmarin/membership?source=post_page-----2760679368bb--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[1] [Depth-First Search — Wikipedia](https://en.wikipedia.org/wiki/Depth-first_search)'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] [Breadth-First Search — Wikipedia](https://en.wikipedia.org/wiki/Breadth-first_search)'
  prefs: []
  type: TYPE_NORMAL
- en: '[3] [Best-First Search — Wikipedia](https://en.wikipedia.org/wiki/Best-first_search)'
  prefs: []
  type: TYPE_NORMAL
- en: '[4] [A* Search Algorithm — Wikipedia](https://en.wikipedia.org/wiki/A*_search_algorithm)'
  prefs: []
  type: TYPE_NORMAL
- en: '[5] [AI Search Algorithms Repo — GitHub](https://github.com/polmarin/ai_search_algorithms)'
  prefs: []
  type: TYPE_NORMAL
- en: Additional Resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Search Algorithms in AI — Geeks For Geeks](https://www.geeksforgeeks.org/search-algorithms-in-ai/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
