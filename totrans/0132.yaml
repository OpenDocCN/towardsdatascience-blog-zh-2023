- en: 6 Python Best Practices that Distinguish Senior Developers from Juniors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/6-python-best-practices-that-distinguish-seniors-from-juniors-84199d4cac3c](https://towardsdatascience.com/6-python-best-practices-that-distinguish-seniors-from-juniors-84199d4cac3c)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How to write Python code that is perceived as coming from an experienced developer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@tomergabay?source=post_page-----84199d4cac3c--------------------------------)[![Tomer
    Gabay](../Images/1fb1d408bc89415918c1aa6733df44e1.png)](https://medium.com/@tomergabay?source=post_page-----84199d4cac3c--------------------------------)[](https://towardsdatascience.com/?source=post_page-----84199d4cac3c--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----84199d4cac3c--------------------------------)
    [Tomer Gabay](https://medium.com/@tomergabay?source=post_page-----84199d4cac3c--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----84199d4cac3c--------------------------------)
    ·12 min read·Apr 18, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3dd47a21048817c7f706cbf2338c9456.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Desola Lanre-Ologun](https://unsplash.com/@disruptxn?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: In January 2023 I published [an article about 5 Python Tricks That Distinguish
    Senior Developers From Juniors](https://medium.com/towards-data-science/5-python-tricks-that-distinguish-senior-developers-from-juniors-826d57ab3940).
    In this article, rather than looking at ‘tricks’, we take a look at 6 best practices
    in Python that can distinguish experienced developers from beginners. Through
    various examples, we will explore the differences between code written by a senior
    developer and that by a junior developer.
  prefs: []
  type: TYPE_NORMAL
- en: By learning these best practices, you can write code that is not only perceived
    as being created by a senior developer, but it will also actually be of a higher
    quality as well. Both these qualities will be advantageous when e.g. presenting
    your code to colleagues or at job interviews.
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Use the right iterable type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An iterable is any Python object capable of returning its members one at a time,
    permitting it to be iterated over in a for-loop. ([source](https://www.pythonlikeyoumeanit.com/Module2_EssentialsOfPython/Iterables.html#:~:text=An%20iterable%20is%20any%20Python,over%20in%20a%20for%2Dloop.))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Junior developers tend to use lists every time they need an iterable. However,
    different types of iterables serve different purposes in Python. To summarize
    the most essential iterables:'
  prefs: []
  type: TYPE_NORMAL
- en: '**lists** are for iterables that should be **ordered** and **mutable.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sets** are for iterables that should **only contain unique values** and are
    **mutable** and **unordered**. They should be preferred when checking for the
    presence of an item, in which they are extremely fast. However, they are slower
    than a `list` when used to iterate over.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**tuples** are for iterables that should be **ordered** and **immutable**.
    Tuples are faster and more memory-efficient than lists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s first take a look at the difference when using a `set` versus a `list`.
    Imagine the simple task of warning the user when a requested username is already
    used. For example, you might often encounter code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`taken_usernames` is a `list` in the above code. However, all values in `taken_usernames`
    only have to occur once, there is no need for duplicate values, as duplicate usernames
    are not allowed. Also, the use case here for `taken_usernames` is to check for
    the presence of a new username in it. Therefore, there is no reason here to use
    a `list`. Instead, it is better to use a `set`, as we read here above that checking
    for presence is faster when using a `set` and because there is no need to store
    the same value more than once.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Despite that both code snippets end up with the same result, using a `set` for
    checking presence instead of a `list` shows others that you understand that there
    are different iterable types for different use cases, rather than using a `list`
    each time you need an iterable.
  prefs: []
  type: TYPE_NORMAL
- en: 'For iterables that won’t mutate during execution time and need order, a `tuple`
    is the best option; e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now you have a better understanding of when to use which iterable type! Your
    code will already seem more senior when instead of a `list` you use a `set` for
    iterables that contain only unique values which don’t need order, and a `tuple`
    for an ordered iterable whose values should not change.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll take a look at Python’s naming conventions, after
    which will be clear why for example `WEEKDAYS` was spelt with capital letters
    in the more senior example in the snippet here above.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to go deeper into when to use which iterable see for e.g. this
    article:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/15-examples-to-master-python-lists-vs-sets-vs-tuples-d4ffb291cf07?source=post_page-----84199d4cac3c--------------------------------)
    [## 15 Examples to Master Python Lists vs Sets vs Tuples'
  prefs: []
  type: TYPE_NORMAL
- en: Comprehend the differences between these data structures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/15-examples-to-master-python-lists-vs-sets-vs-tuples-d4ffb291cf07?source=post_page-----84199d4cac3c--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Use Python’s naming conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two kinds of ‘rules’ for variable names in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: Enforced rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Naming conventions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enforced rules prevent invalid variable names, such as variable names which
    start with a digit or that contain hyphens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Of course, because these are enforced by Python interpreters, you (hopefully)
    won’t see any of them applied in code. However, there are style guidelines (a.k.a.
    naming conventions) for variable names which are not enforced, and hence, you
    can use the wrong style for the wrong object.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are some of the most important naming conventions in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '**variables:** lower-case only, which underscores to split words, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`first_name` `items` `names_list`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**functions** and **methods:** same rule as *variables,* lower-case only, which
    underscores to split words, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get_avg` `load_data` `print_each_item`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**classes:** use [CamelCasing](https://www.techtarget.com/whatis/definition/CamelCase#:~:text=CamelCase%20is%20a%20way%20to,humps%20on%20a%20camel''s%20back.);
    start with a capital letter and each new word starts with another capital letter,
    with no underscores in between:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Person` `TrainStation` `MarineAnimal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**constants:** uppercase only, with underscores to split words, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WEEKDAYS` `FORBIDDEN_WORDS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**modules:** for Python file names, use the same convention as *variables,
    functions* and *methods (*lowercase with underscores to split words):'
  prefs: []
  type: TYPE_NORMAL
- en: '`calculations.py` `data_preprocessing.py`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the proper naming conventions does not only show maturity in Python, but
    not using the proper naming conventions can lead to significantly more confusing
    code, as we’ll see here below.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python code that follows PEP-8 naming conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Python code that doesn’t use naming conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Most developers will definitely highly doubt your Python skills if you provide
    them with the code in the second snippet, while when provided with the first snippet,
    they see quality Python code. Therefore it is very important to make sure you
    adhere to Python’s naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: For more details on naming conventions in Python see [PEP-8.](https://peps.python.org/pep-0008/#naming-conventions)
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Use the proper comparison statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Comparison operators (…) compare the values on either side of them and returns
    a boolean value. They tell whether a statement is True or False according to the
    condition. ([source](https://flexiple.com/python/comparison-operators-in-python/))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In Python, there are many ways to write (almost) identical comparison statements,
    but they’re not necessarily equally appropriate. Let’s take a look at a small
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The last example `if is_even(x):` works, because without anything to compare
    to, Python evaluates if `is_even(x)` evaluates to `True`. However, it is important
    to note that almost any Python variable will evaluate to `True` except for:'
  prefs: []
  type: TYPE_NORMAL
- en: Empty sequences, such as lists, tuples, strings etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number `0` (in both its integer and its float type)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`None`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`False` (obviously)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This means for example that every `if <number>:` statement will evaluate to
    `True`, except if that number is `0`. Therefore, an if-statement without any concrete
    example might seem too global to be used, because the chances seem high that it
    unwittingly might evaluate to `True`. Yet, we can make very good use of the fact
    that empty sequences always evaluate to `False`, while a sequence with at least
    one value always evaluates to `True`. Often in more junior Python code, you’ll
    encounter the following comparison statement: `if <variable> != []`, such as in
    the snippet below.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: However, what will happen when someone inserts a different type of iterable?
    For example, a `set`. If you want to raise a `ValueError` for an empty `list`
    , you probably would want to raise a `ValueError` for an empty `set` as well.
    In the code above, an empty `set` will still evaluate to `True`, because an empty
    `set` is not equal to an empty `list`. One way to prevent such unwanted behaviour
    is to use `if items` instead of `if items != []`, because `if items` will now
    raise a `ValueError` for each iterable that is empty, including the `list`, `set`
    and a `tuple` from section1.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you want to compare a value explicitly to `True` or `False` , you should
    use `is True` or `is False` instead of `== True` and `== False` . This also applies
    to `None` , because they are all [*singletons*](https://www.geeksforgeeks.org/singleton-pattern-in-python-a-complete-guide/).
    See [PEP285](https://peps.python.org/pep-0285/). Though the differences in performances
    are tiny, `is True` is a bit faster than `== True.` Above all, it shows that you
    are known with PEPs (Python Enhancement Proposals), which shows developer skill
    maturity.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**Bonus tip:** [PEP8](https://peps.python.org/pep-0008/#programming-recommendations)
    warns about the use of `if value` to make sure `value` is not `None` . To check
    whether a value is not `None` , use `if value is not None` explicitly.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Choosing the most proper comparison statement can occasionally save you or others
    from having to debug a tricky bug. But above all, senior developers will estimate
    you more equal to them if you use e.g. `if value is True` over `if value == True`.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, rather than just writing a comparison statement for a variable's
    value it is better to check for the data type first, but how do we raise good
    exceptions for that? Let’s take a look at raising informative exceptions in the
    section!
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Raise informative exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Something more junior developers rarely do is ‘manually’ raise exceptions with
    custom messages. Let’s consider the following situation: we want to create a function
    called `print_each_item()` which prints each item of an iterable type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most simple solution would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this code works. However, when this function is part of a big code
    base, the possible absence of print results when running the program might be
    confusing. Is the function called properly? One way to solve such an issue is
    to use **logging**, which we’ll discuss in the next section. First, let’s look
    at how to prevent insecurities such as the absence of print results by raising
    `Exceptions`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function `print_each_item()` works only on iterable Python objects, so
    our first check should be whether Python can iterate on the provided argument
    by using Python''s built-in function `iter()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: By trying the `iter()` function on `items` we check whether it is possible to
    iterate over `items`. Of course, it is also possible to check the type of `items`
    through `isinstance(items, Iterable)`, however, some custom Python types might
    not count as an `Iterable` while they might be iterable, so `iter(items)` is more
    waterproof here. We add the `.with_traceback` here to the `Exception`to give more
    context for debugging when the error is raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, when we’ve confirmed that `items` is iterable, we must make sure that
    `items` is not an empty iterable, to prevent the absence of print results. We
    can do this how we learned in the previous section, by using `if items:`. If `if
    items:` is `False` we want to raise a `ValueError`, because that means the iterable
    is empty. Here below is the full-proof `print_each_item()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the most simple `print_each_item()` is fine for most use cases, however,
    if you work as a developer at a company, or write open-source code, and the function
    is often reused, your fellow-Pythoneers might require or at least be much happier
    when they see the function as in the second example. Being able to understand
    which exceptions could happen for a function and how to properly handle them and
    raising informative exceptions is definitely a required skill to become (more)
    senior.
  prefs: []
  type: TYPE_NORMAL
- en: Yet, your function will still likely be refused when being reviewed by others.
    That is because it doesn’t contain a docstring or any type hinting, which are
    essential for high-quality Python code.
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Type hinting and docstrings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Type hinting was introduced in Python 3.5\. With type hinting, you can *hint*
    which type is expected. A very simplistic example could be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: By specifying `str` as the type hint of `sentence` we know `sentence` should
    be a string, and not e.g. a list with words. Through `-> str` we specify that
    the function returns an object of type string. Python won’t enforce the right
    types (if won’t raise an `Exception` if an object of a different type is inserted)
    but often IDEs like [Visual Studio Code](https://code.visualstudio.com/) and [PyCharm](https://www.jetbrains.com/pycharm/promo/?medium=cpc&campaign=14124132615&term=pycharm&content=536947779960&gclid=CjwKCAjwue6hBhBVEiwA9YTx8AeY9b1iUuYFfKf0ae1o-GKo3jbkTjE361ftJkshc6vKDk7dPqDPdxoC7boQAvD_BwE)
    help you code by making use of the type hints in the code (see screenshot further
    down this section).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can apply this too in our `print_each_item()` through:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '**Docstrings** help explain code snippets like functions or classes. We can
    add the following docstring to `print_each_item()` to make it absolutely clear
    for other users and our future self what the function does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we are writing code that uses `print_each_item` we see the following
    information appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/09803f88a783599a56e8edaa60adf6eb.png)'
  prefs: []
  type: TYPE_IMG
- en: (Screenshot by Author)
  prefs: []
  type: TYPE_NORMAL
- en: By adding type hinting and docstrings, we have made our function much more user-friendly!
  prefs: []
  type: TYPE_NORMAL
- en: For more on type hinting click [here](https://docs.python.org/3/library/typing.html).
    For more on docstrings see [PEP-257](https://peps.python.org/pep-0257/).
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** it might feel like writing a long docstring for such a simple function
    is a bit of an overkill, which you could argue it sometimes is. Luckily, when
    a function isn’t secretive, you can easily ask [ChatGPT](https://chat.openai.com/)
    to write a very accurate and elaborate docstring for you!'
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Use logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few things which make using your code much more pleasant for others,
    such as type hinting and docstrings. However, one of the most important, underused
    and underrated features is logging. Though a lot of (junior) developers perceive
    logging as difficult or unnecessary, running a properly logged program can make
    a huge difference to anyone using your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Only two lines are required to make logging in your code possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can easily add logging to help e.g. with debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also really help other developers with debugging by logging the error
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Because logging is such a rare feature to see in more junior developers’ code,
    adding it to your own makes you already (seem) much more experienced in Python!
  prefs: []
  type: TYPE_NORMAL
- en: To conclude
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this article, we’ve taken a look at 6 Python best practices that can make
    the difference between appearing to be a junior developer versus a more senior
    one. Of course, there are manymore factors that distinguish senior developers
    from juniors, however, by applying these 6 best practices you’ll definitely distinguish
    yourself (whether at your work, at a coding interview or when contributing to
    open-source packages) from other junior developers who don’t apply these best
    practices!
  prefs: []
  type: TYPE_NORMAL
- en: 'To read more about the differences between code of seniors and juniors see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/5-python-tricks-that-distinguish-senior-developers-from-juniors-826d57ab3940?source=post_page-----84199d4cac3c--------------------------------)
    [## 5 Python Tricks That Distinguish Senior Developers From Juniors'
  prefs: []
  type: TYPE_NORMAL
- en: Illustrated through differences in approaches to Advent of Code puzzles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/5-python-tricks-that-distinguish-senior-developers-from-juniors-826d57ab3940?source=post_page-----84199d4cac3c--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to know more about how to become more senior yourself see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/how-to-level-up-your-python-skills-by-learning-from-these-professionals-3e906b83f355?source=post_page-----84199d4cac3c--------------------------------)
    [## How to Level Up Your Python Skills by Learning From These Professionals'
  prefs: []
  type: TYPE_NORMAL
- en: Prevent staying stuck at the junior level of Python programming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/how-to-level-up-your-python-skills-by-learning-from-these-professionals-3e906b83f355?source=post_page-----84199d4cac3c--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Iterables** [https://www.pythonlikeyoumeanit.com/Module2_EssentialsOfPython/Iterables.html#](https://www.pythonlikeyoumeanit.com/Module2_EssentialsOfPython/Iterables.html#)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://stackoverflow.com/questions/2831212/python-sets-vs-lists](https://stackoverflow.com/questions/2831212/python-sets-vs-lists)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://towardsdatascience.com/15-examples-to-master-python-lists-vs-sets-vs-tuples-d4ffb291cf07](/15-examples-to-master-python-lists-vs-sets-vs-tuples-d4ffb291cf07)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Naming conventions**'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://peps.python.org/pep-0008](https://peps.python.org/pep-0008)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.techtarget.com/whatis/definition/CamelCase#:~:text=CamelCase%20is%20a%20way%20to,humps%20on%20a%20camel''s%20back](https://www.techtarget.com/whatis/definition/CamelCase#:~:text=CamelCase%20is%20a%20way%20to,humps%20on%20a%20camel''s%20back).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Proper comparison statements** [https://peps.python.org/pep-0008](https://peps.python.org/pep-0008)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://peps.python.org/pep-0285/](https://peps.python.org/pep-0285/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://flexiple.com/python/comparison-operators-in-python/](https://flexiple.com/python/comparison-operators-in-python/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Type hinting and docstrings** [https://docs.python.org/3/library/typing.html](https://docs.python.org/3/library/typing.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://peps.python.org/pep-0257/](https://peps.python.org/pep-0257/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Logging** [https://docs.python.org/3/library/logging.html](https://docs.python.org/3/library/logging.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Memes** [https://www.reddit.com/r/ProgrammerHumor/comments/l9lbm2/code_review_be_like/](https://www.reddit.com/r/ProgrammerHumor/comments/l9lbm2/code_review_be_like/)'
  prefs: []
  type: TYPE_NORMAL
