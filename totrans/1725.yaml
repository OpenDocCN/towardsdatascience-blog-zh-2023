- en: 'Python Inheritance: Should You Inherit From dict or UserDict?'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/python-inheritance-should-you-inherit-from-dict-or-userdict-9b4450830cbb](https://towardsdatascience.com/python-inheritance-should-you-inherit-from-dict-or-userdict-9b4450830cbb)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: PYTHON PROGRAMMING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: They say you shouldn’t inherit from dict but UserDict. Is this true indeed?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@nyggus?source=post_page-----9b4450830cbb--------------------------------)[![Marcin
    Kozak](../Images/d7faf62e48ed81dab5d8ad92819fff54.png)](https://medium.com/@nyggus?source=post_page-----9b4450830cbb--------------------------------)[](https://towardsdatascience.com/?source=post_page-----9b4450830cbb--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----9b4450830cbb--------------------------------)
    [Marcin Kozak](https://medium.com/@nyggus?source=post_page-----9b4450830cbb--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----9b4450830cbb--------------------------------)
    ·15 min read·May 10, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c72ec52580061eee2cab00288f3dddbf.png)'
  prefs: []
  type: TYPE_IMG
- en: Dictionaries are among the basic Python data types. Photo by [Waldemar](https://unsplash.com/@waldemarbrandt67w?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting from `dict` is usually not the best idea — not only because they
    say so, but because the overloaded methods will not work. Instead, you’re supposed
    to subclass `collections.UserDict`. But what if you do not want to overload `dict`
    methods, just to add new ones? In this article, we will discuss when and how to
    inherit from the `dict` and `collections.UserDict` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In his fantastic book *Fluent Python. 2nd ed.*, Luciano Ramalho explains why
    you should not create custom classes inheriting from `dict`. The reason behind
    this rule, strange at the first glance, is simple but critical: `dict` is a highly
    optimized type implemented in C, and it wouldn’t call the methods you overload
    in your subclass of `dict`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That would be a nasty surprise, wouldn’t it? Let’s see this in an example.
    Imagine you want to create a dictionary-like class in which the provided values
    will be converted to their string representation. Let’s try to do this by subclassing
    the `dict` built-in type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This seems like perfectly valid Python code. Let’s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Well, it does not work at all — or rather, this `__setitem__` method does not
    work at all. We wanted to get values converted to strings but they are not. Nonetheless,
    we don’t see any error; the class itself works somehow — in fact, it works just
    like a regular dictionary would. (Or rather, it provides the same results but
    slower; we will discuss this later on.)
  prefs: []
  type: TYPE_NORMAL
- en: 'To get what you want, you should subclass `UserDict`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you see the only thing we changed in the definition is subclassing `UserDict`
    instead of `dict`.
  prefs: []
  type: TYPE_NORMAL
- en: So now you know. It’s enough to use `UserDict`. Great.
  prefs: []
  type: TYPE_NORMAL
- en: Is it?
  prefs: []
  type: TYPE_NORMAL
- en: Consequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hold on. Let’s think. There are a couple of things we should consider before
    deciding that using `UserDict` instead of `dict` is so great.
  prefs: []
  type: TYPE_NORMAL
- en: First, we know that Python’s built-in types are highly optimized because they
    are implemented in C, and that this implementation itself is highly optimized.
  prefs: []
  type: TYPE_NORMAL
- en: Second, we know that we shouldn’t subclass `dict` because its methods implemented
    in C will not call the overwritten methods implemented in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'And third, an easy thing to check, `collections.UserDict` is implemented in
    Python. In Linux, you will find its definition here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b4e6c7a118564c65b2e2ed8e1df68ed4.png)'
  prefs: []
  type: TYPE_IMG
- en: Localization of UserDict definition in Linux. Screenshot from VS Code. Image
    by author
  prefs: []
  type: TYPE_NORMAL
- en: 'In this context, the following question asks itself: If so, will my custom
    class subclassing `UserDict` be performant?'
  prefs: []
  type: TYPE_NORMAL
- en: My immediate guess is that no, it won’t. The optimization of `dict` comes from
    C implementation, and `UserDict` is implemented in Python. Why should it be optimized
    whatsoever? We will check this in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarking UserDict against dict
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For benchmarks, we will use the standard-library `timeit` module. You can read
    about it here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/benchmarking-python-code-with-timeit-80827e131e48?source=post_page-----9b4450830cbb--------------------------------)
    [## Benchmarking Python code with timeit'
  prefs: []
  type: TYPE_NORMAL
- en: The most popular tool for time benchmarking of Python code, the built-in timeit
    module offers more than most…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/benchmarking-python-code-with-timeit-80827e131e48?source=post_page-----9b4450830cbb--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 'To make benchmarks a little simpler and structurized, let us define a simple
    function to run time benchmarks for two or more code snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'A couple of things:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The function uses the `[rounder](https://pypi.org/project/rounder/)` package,
    to round all numbers in the dictionary to four significant digits; you can read
    more about it here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[](/rounder-rounding-numbers-in-complex-python-objects-e4b6f3b563f8?source=post_page-----9b4450830cbb--------------------------------)
    [## rounder: Rounding Numbers in Complex Python Objects'
  prefs: []
  type: TYPE_NORMAL
- en: The rounder package enables you to round all numbers in any object, with just
    one command.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/rounder-rounding-numbers-in-complex-python-objects-e4b6f3b563f8?source=post_page-----9b4450830cbb--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: '`__snippet1` and `__snippet2` are positional-only arguments, so you cannot
    call them by name. This is thanks to the double-underscore prefix.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thanks to `*args` after the two snippet arguments, you can provide more snippets,
    also as positional keywords; you can use as many of them as you want.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the remaining arguments are keyword-only. Here, this is achieved by putting
    them after `*args`.¹
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function report the results as the mean of all calls from the quickest of
    seven runs. Hence, all the results are directly comparable, even if the `timeit.repeat()`
    function was used with different `number` values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function return implicit `None` and prints a short report of the benchmarks,
    using the `pprint()` function from the standard-library `pprint` module. More
    often than not, avoid replacing return statements with prints², unless your function/method
    is a one that *prints*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Okay, we’ll see the function in action in a second. Let’s start off with comparing
    how quickly `dict()` and `UserDict()` create instances. Nonetheless, we can instantiate
    a regular dictionary using two methods, `dict()` and (significantly faster) `{}`,
    so we’ll include them both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For all benchmarks in this article, I used Python 3.11 on a Windows 10 machine,
    in WSL 1, 32 GM of RAM and four physical (eight logical) cores. The benchmark
    shows that to create a new instance, `UserDict` is twice slower than `dict`.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned above, the values we see in the results dictionary represent the
    time of creating *one* instance of either `UserDict` or regular `dict` (created
    using two methods). Clearly, to create an instance of `UserDict`, you need more
    time, about `1.3e-07` of a second — while `{}` needs about `1.5e-08`. Not a big
    difference? Note when you need to create a single instance, but imagine creating
    millions of dictionaries. So, to create a regular dictionary, you need more or
    less *3–8 times less time* than to create a `UserDict`, depending on the instantiation
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works with bigger dictionaries. We’ll create a simple numerical
    dictionary via a dictionary comprehension. Since `UserDict` does not enable us
    to use the dictcomp syntax (another drawback), the only thing we can do is to
    create first a regular dictionary using the dictcomp syntax and then convert it
    to a `UserDict` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: A regular dictionary is about 2.5 times faster. That seems quite amazing given
    that creating an empty dictionary was even faster. We have to remember that the
    results of such benchmarks can vary from run to run. But we also have to remember
    that when we use many repetitions (here, a hundred thousand — we could use more),
    the variation should be relatively small.
  prefs: []
  type: TYPE_NORMAL
- en: Will the size matter when we compare lookup time? Basically key lookup is unrelated
    to dictionary size, so supposedly, we should be getting similar results irrespective
    of dict size.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, a small dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, so about 3.5 times slower. Now, for a bigger one, of `10_000` key-value
    pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'and for one of 10 million elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the size indeed does not matter, and every time, `dict` was more or less
    3–3.5 times faster. Let’s see, this time just for medium-sized dictionaries, how
    it works with an unexisting key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This time it’s a bigger difference, `dict` being over 10 times faster.
  prefs: []
  type: TYPE_NORMAL
- en: What about checking if a key is in the dictionary?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: So, again 3–3.5 times faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s benchmark a frequent operation, that is, iterating over a dictionary;
    again, let’s check various sizes of the dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Okay, so for small dictionaries, `dict` is about 7 times faster to loop over
    its key-value pairs available via the `.items()` method. For medium-sized dictionaries
    (of 10 thousand elements in our experiment), about 9 times faster. For bigger
    dictionaries (of `100_000` elements), the result was similar, so looping itself
    — once it started — does not seem to depend on the type of dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Since it was a rather minor benchmark, we can conclude that a regular dictionary
    should be around 5–10 times faster to loop over its items than `UserDict`.
  prefs: []
  type: TYPE_NORMAL
- en: To conclude the benchmarks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Maybe let’s stop here. We could conduct more benchmarks, but that’s not the
    point. I did not want to conduct a full comparison of `dict` and `UserDict` in
    terms of execution time; if you’re interested, you can play with the code to conduct
    a set of solid benchmarks. Instead, I wanted to shed some light on the issue and
    check if, as I expected based on the knowledge of `UserDict` and `dict`’s implementations,
    the former is significantly slower than the latter.
  prefs: []
  type: TYPE_NORMAL
- en: And it is — unless you consider 5–10 times slower as an insignificant number.
    So, if you only can, consider using regular dictionaries, not those subclassing
    `UserDict`, unless you must change the behavior of `dict`.
  prefs: []
  type: TYPE_NORMAL
- en: Ah… Why can’t we just subclass `dict`?! Why?
  prefs: []
  type: TYPE_NORMAL
- en: Or… Can we?
  prefs: []
  type: TYPE_NORMAL
- en: Don’t subclass dict? And why not?!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps you’ve noticed that the rule of not subclassing `dict` is related to
    the `dict` methods implemented in C, which would not call the built-in `dict`
    methods overloaded in Python. But what if you just want to add some functionalities
    to `dict`, leaving the methods already implemented in C untouched?
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s a very good question. And the answer is short and simple: Yes, you can
    do it! You *can* inherit from `dict`; simply don’t overload `dict`’s methods,
    that’s all.'
  prefs: []
  type: TYPE_NORMAL
- en: The question is, will such a `dict`-based class be as performant as `dict`?
    Or rather as `collections.UserDict`? To answer this question, we will have to
    run some more benchmarks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s imagine we keep some data in a dictionary, and we want to add method
    `.summarize()` that calculates some summary statistics for the data. It could
    be something like this (just an example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`RichDict` is a `dict` with one more method: `.summarize()`. The method does
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It iterates over key-value pairs of the data (reached via the `.items` method).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a value is a string, `statistics` includes only length and is returned
    as a dictionary with one key, `n`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a value is a `Sequence`, the main summary statistics are calculated. The
    measures are kept as callables in a class attribute `RichDict.measures`, which
    is a dictionary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The method protects calculations: if a measure cannot be calculated, an exception
    is caught and `float("nan")` (for *not-a-number*) is returned as the results of
    calculations. That way, Python will not throw an error when attempting to calculate
    the mean of an empty list, for instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you want to add a measure, you can easily do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If the function is more complicated, you can use a `lambda` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'or, preferably, first define a function and then assign it here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that since `.measures` is a class attribute, all instances of `RichDict`
    (those to be created, but also those already existing) will have the extended
    measures, with `min` and `max` statistics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just one example of `RichDict` in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/3318c11f8c1f78be6a64b5787c89fff5.png)'
  prefs: []
  type: TYPE_IMG
- en: Above, the `RichDict` class has one class attribute with measures to be used
    for sequence data; for strings, the `.summarize()` methods calculates only one
    measure. Update the class so that it has two class attributes, `measures_seq`
    and `measures_str`, designed as `measures` above. For strings, the `.summarize()`
    method should calculate the measures the way it does for sequences, that is, using
    `measures_str`.
  prefs: []
  type: TYPE_NORMAL
- en: You will find the solution in Appendix 1.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/89f1c24cf1dd3f341ddc19cd83009d2e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the code, I used the standard-library `doctests` module for documentation
    testing. If you’re interested in learning more about this interesting module,
    you can do so from this article:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/python-documentation-testing-with-doctest-the-easy-way-c024556313ca?source=post_page-----9b4450830cbb--------------------------------)
    [## Python Documentation Testing with doctest: The Easy Way'
  prefs: []
  type: TYPE_NORMAL
- en: doctest allows for documentation, unit and integration testing, and test-driven
    development.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/python-documentation-testing-with-doctest-the-easy-way-c024556313ca?source=post_page-----9b4450830cbb--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Okay, now that we know that `RichDict` works, we know we *can* subclass `dict`.
    What we want to learn now is whether `RichDict`’s added functionality, defined
    in Python (not in C, like the base code for `dict`), adds some overhead time for
    the regular behavior of `dict`. To this end, we will benchmark such behavior as
    creating a new `RichDict` versus creating a new `dict`, key lookup, and the like.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s conduct similar benchmarks to those above, conducted for `UserDict`. You
    can find the code for them in [this GitHib gist](https://gist.github.com/nyggus/430a6ee05ea69cbd9e46c2d31ebedb95).
    You will find there the `setup` value used below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As shown above, when it comes to creating an empty instance, `RichDict` is significantly
    faster than `UserDict` (about 2 times faster) and slower than `dict` (about 2
    times slower).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This time, `RichDict` is about 2.5 times faster than `UserDict` but a little
    slower (around 1.3 times) than `dict`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Below, you will find examples of more benchmarks, separated by blank lines
    for your convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The numbers themselves say what we need, and so I will leave you with them for
    the moment.
  prefs: []
  type: TYPE_NORMAL
- en: To conclude the benchmarks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`RichDict` is usually slower than `dict` (though sometimes only very little)
    but faster than `UserDict`.'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, if you just want to add some functionalities to `dict`, without overwriting
    its built-in methods, you *definitely* *can subclass* `dict`. I’d say this should
    be your preferred method, instead of subclassing `collections.UserDict`, as the
    latter is significantly slower. *Do remember* that we’re talking about the situation
    when you do not need to change the regular behavior of a dictionary, just to add
    some new behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember also that you will have to pay a tax for using a built-in type that
    way: Your class (in our example, `RichDict`) will be slower than `dict`. Still,
    however, it will be faster than `UserDict`, which was created for this very aim:
    to let you inherit from… well, not from `dict`, so rather to let you create a
    new type (class) that will have the same behavior as `dict`. Using `UserDict`,
    unfortunately, is rather costly, as its performance is significantly worse than
    that of `dict`.'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s summarize our discussion about subclassing `dict` and `UserDict`. We’ve
    learned we have three options to choose from:'
  prefs: []
  type: TYPE_NORMAL
- en: Inherit from `UserDict`, when you want to overwrite the built-in behavior of
    `dict`. This will be the slowest option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inherit from `dict`, when you don’t want to overwrite the built-in behavior
    of `dict`, but to add new functionalities (methods). This will be a faster option
    than option 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the built-in `dict` type, without creating a custom class. If you need custom
    functionalities, you can implement them in functions that take a `dict` instance
    as an argument. This is the fastest option (see below).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have not discussed the third option yet, as it does not include subclassing.
    Not much to discuss, though, as this is the simplest approach, one that uses a
    more procedural approach rather than OOP. On the one hand, using the `summarize()`
    function in this approach would be only a little (if any at all) faster than using
    the `RichDict.summarize()` method in option 2\. [This gist](https://gist.github.com/nyggus/cd41a181ad2e23425279db1961438ca4)
    contains the corresponding benchmark code; in my machine, it provided a small
    but stable (from run to run) improvement in performance. On the other hand, all
    the other behavior of regular `dict`, as we know, is significantly faster than
    that of `RichDict`. Hence, generally, option 3 offers the fastest way to handle
    a dictionary with additional functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, if performance matters, the most sensible seems to be the third option
    — that is, using a regular dictionary and implementing the additional required
    behavior in external functions. Depending on the situation, it can also be an
    option with the clearest code, as it does not require a custom data structure
    but uses a dictionary, one of the most common data structures in Python, combined
    with a function. More often than not, this means clearer code.
  prefs: []
  type: TYPE_NORMAL
- en: The second option means worse performance, as adding methods to `dict` leads
    to overhead time of its behavior. As we know, option 3 gets rid of this overhead
    by moving the method outside the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first option is definitely the worst one in terms of performance. I think
    the only situations in which this option makes sense are those in which *each*
    of the following three conditions is met:'
  prefs: []
  type: TYPE_NORMAL
- en: performance does not matter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: you need to overwrite one or more built-in `dict` methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the code will be clearer and easier to use thanks to creating a class that will
    join all the required functionalities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Footnotes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ¹ I am planning to write a dedicated article to positional-only and keyword-only
    arguments. Once it’s published, I will link it here.
  prefs: []
  type: TYPE_NORMAL
- en: ² By the way, in an interactive session, a return from the function would have
    the same effect (of course, when the results are not assigned). I ran the benchmarks
    in a script, not an interactive session, however.
  prefs: []
  type: TYPE_NORMAL
- en: Appendix 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solution to the exercise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can do it in various way. The below solution avoids repetition, but also
    makes it easy to add yet another type (to `Sequence` and `str`) to calculations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Thanks for reading. If you enjoyed this article, you may also enjoy other articles
    I wrote; you will see them [here](https://medium.com/@nyggus). And if you want
    to join Medium, please use my referral link below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/@nyggus/membership?source=post_page-----9b4450830cbb--------------------------------)
    [## Join Medium with my referral link - Marcin Kozak'
  prefs: []
  type: TYPE_NORMAL
- en: Read every story from Marcin Kozak (and thousands of other writers on Medium).
    Your membership fee directly supports…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/@nyggus/membership?source=post_page-----9b4450830cbb--------------------------------)
  prefs: []
  type: TYPE_NORMAL
