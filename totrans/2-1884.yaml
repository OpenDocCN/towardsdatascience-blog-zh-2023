- en: Software Engineering Best Practices for Writing Maintainable ML Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/software-engineering-best-practices-for-writing-maintainable-ml-code-717934bd5590](https://towardsdatascience.com/software-engineering-best-practices-for-writing-maintainable-ml-code-717934bd5590)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/1d59ed9c7fdba6ad95f054d4357d2f46.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: A data scientist who is lost in a forest full of code. Related to the second
    and last tip. Image created with [Midjourney](https://www.midjourney.com) by the
    author.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Advanced coding tips for data scientists
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://hennie-de-harder.medium.com/?source=post_page-----717934bd5590--------------------------------)[![Hennie
    de Harder](../Images/3e4f2cccd6cb976ca3f8bf15597daea8.png)](https://hennie-de-harder.medium.com/?source=post_page-----717934bd5590--------------------------------)[](https://towardsdatascience.com/?source=post_page-----717934bd5590--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----717934bd5590--------------------------------)
    [Hennie de Harder](https://hennie-de-harder.medium.com/?source=post_page-----717934bd5590--------------------------------)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----717934bd5590--------------------------------)
    ·11 min read·Aug 6, 2023
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: --
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '**Unlike traditional software engineering projects, ML codebases tend to lag
    behind in code quality due to their complex and evolving nature, leading to increased
    technical debt and difficulties in collaboration. Prioritizing maintainability
    is important to create robust ML solutions that can adapt, scale, and deliver
    value over time.**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: In recent years, machine learning has taken the world by storm, transforming
    industries from healthcare to finance and more. As more organizations jump on
    the ML bandwagon to discover new possibilities and insights, the significance
    of writing maintainable and robust ML code becomes crucial. By crafting ML code
    that’s easy to work with and stands the test of time, teams can collaborate better
    and guarantee success as models and projects grow and adapt. The following section
    will show common examples from ML codebases and explain how to handle those properly.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Don’t Create Monoliths
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This tip is probably irrelevant for you, but it’s written for the single person
    who is not aware of this (until now)!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Monolithic scripts, a.k.a. a single script for the whole project, may arise
    when you reuse your experimental code in production. Copy, paste, done! It’s always
    a bad idea to create one single script for a project. It’s difficult to read (even
    for the writer), hard to debug and inefficient. You can’t easily add new features
    or modify the code, because every time the whole thing has to run. Adding unittests
    is impossible as well, because the monolith is ‘the whole unit’.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Another problem with a single script is reusability. You can’t reuse the code
    in other projects, because it’s so hard to read.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: There is only one reason to write a monolith; that is if you don’t like the
    colleague who takes over your work. If you want to get this person frustrated,
    it’s an easy way to accomplish that.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: What to do instead? Write modules and classes. Create different code files that
    have one specific purpose. Every file should contain functions or classes and
    methods. By doing this, the code becomes way easier to read, debug, reuse and
    test. In the next tip you can find a commonly used directory structure.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Don’t Over-Engineer the Repository Structure
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This might seem counterintuitive, but it’s quite an important one. Over-engineering
    the repository structure refers to creating a complex and unnecessarily convoluted
    organization for your code and project files. It involves introducing layers of
    abstraction, excessive folder structures, and intricate naming conventions that
    may not provide any significant benefits in terms of maintainability, scalability,
    or collaboration. Instead, it adds unnecessary complexity, making it harder for
    team members to understand, navigate, and contribute to the project.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'To name a few issues that may arise: slower development because of the increased
    cognitive load for developers. The learning curve for new team members becomes
    more complex, and the complexity of the repo can lead to code duplication and
    fragmentation.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'How can you maintain a healthy repository structure? Here are some tips that
    might help:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Follow standard directory layouts and naming conventions that are widely accepted
    in the ML community (see below).
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Group related files and modules together in appropriate directories. For example,
    keep data preprocessing code separate from model training code.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide clear and concise documentation to guide team members on how to navigate
    and contribute to the project.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regularly review the repository structure with the team to identify areas that
    can be simplified or improved.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And last but not least: Keep it simple! Avoid adding unnecessary layers of
    abstraction or complicated folder hierarchies unless they genuinely improve organization
    and readability.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of a standard directory structure:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![](../Images/71f64ba97af91ce6f51f4061a0293b52.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
- en: Many nested folders can make a repo too complex. Photo by [Didssph](https://unsplash.com/@didsss?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Understand your Programming Language Behavior
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some situations, a programming language does not behave as you would expect.
    This can cause frustration and a lot of time wasted on debugging code. To prevent
    this, it helps a lot if you are aware of strange behavior of your programming
    language.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: If we take a look at Python, here are some examples that you should be aware
    of.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one you might encounter as programmer is the following. You want
    to round numbers and then you discover this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What’s going on? In Python 3, the decision is made to use bankers’ rounding,
    which means that 0.5 is rounded to an even number. Why does this make sense? I
    like [this explanation](https://stackoverflow.com/questions/45223778/is-bankers-rounding-really-more-numerically-stable)
    on Stack Overflow.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example of strange behavior in Python:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the example above the default argument of the list is an empty list. But
    if you run the function for a second time, the output of the second run is surprising.
    It returns the previous list with the new item added! The reason for this is that
    in Python there are *mutable default arguments*, meaning that changes made to
    the default object persist across function calls. To avoid this, set the default
    to `None` and create a new instance of the mutable object within the function
    call.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'And another one, *floating-point arithmetic precision*:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It’s better to accept small tolerances when comparing floating point values.
    If you are comparing floating point values during testing and you use [pytest](https://docs.pytest.org/en/7.4.x/contents.html),
    you can solve this problem with `approx`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the special case you are using Python 2.7, the following example can be
    confusing. Variables used in a list comprehension can “leak” into the outer scope:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Sorting with `None` will raise a `TypeError`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can also assign an attribute to an instance that is not present in its
    class:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Another confusing example is about *inconsistent closures*. A closure is a
    function that captures and remembers the environment in which it was created,
    including any variables from its outer scope. While closures are a powerful feature,
    their behavior in loops can lead to surprising results:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: All functions return the product of the last value of `i` in the loop (which
    is 4) with `x`. This happens because closures in Python close over variables,
    not their values, which means they retain a reference to the variable `i`. When
    the closure is called later (outside the loop), it looks up the current value
    of `i` in its enclosing scope, which is now 4 (the last value in the loop).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'An easy way to solve this would be to use default arguments:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There are many more examples besides these ones. Being aware of this will make
    your code more robust and reliable and it will avoid all those unwanted surprises!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Handling Multiple Return Values
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding more and more parameters to return statements in functions can make Python
    code messy and harder to maintain, especially when the number of parameters grows
    large. Every time you change something, you need to update all the calling code,
    leading to a maintenance nightmare. Developers might mistakenly pass the parameters
    in the wrong order, leading to logical errors.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'Python provides an elegant solution for this: `[namedtuple](https://docs.python.org/3/library/collections.html#collections.namedtuple)`
    from Python’s `collections` module.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how you can use namedtuples to improve the clarity and maintainability
    of your code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Easy, right? Using `namedtuple` has many benefits, like making your code more
    readable, being immutable and it’s more memory efficient (implemented in C). And
    maybe the biggest one for you as a programmer: you don’t have to update all the
    calling code after adding another parameter to the return statement.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: [namedtuples](https://docs.python.org/3/library/collections.html#collections.namedtuple)
    in Python are similar to [case classes](https://docs.scala-lang.org/tour/case-classes.html)
    in Scala.'
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A Note on Exception Handling
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The worst way of handling exceptions is blindly continuing when one occurs:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Never do this. If something happens and the result couldn’t be obtained, the
    script continues like everything is normal. The exceptions are silently ignored.
    This can lead to hidden bugs and unexpected behavior.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: In some repos, you will find many `try` `except` blocks. Avoid using try-except
    blocks for normal flow control. Exceptions should be used for handling exceptional
    situations, not regular flow.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'Another bad practice is catching generic exceptions:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This can hide specific errors and make debugging difficult. Also avoid bare
    `except` blocks. You won’t have a clue about what’s going on.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: How should you handle exceptions? Here are some useful tips.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Try to be specific, and only catch generic exceptions for debugging. In some
    cases it can be useful to add a `finally` block. Code in the `finally` block will
    always run.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can also create custom exception classes. With custom exceptions, you can
    provide more specific error messages and help distinguish different types of errors.
    It can be as easy as this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Dealing Properly with Large Conditional Logic Trees
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The complexity of (business) logic can quickly escalate. It begins with a simple
    if-else statement, but as it expands, it turns into a massive conditional structure
    that becomes difficult to manage, leading to frustration. Fortunately, various
    approaches exist to address this challenge and enhance maintainability.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'One solution is to separate the logic from the processing, for example in a
    dictionary. Let’s look at the following if-else tree:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can refactor this using a dictionary:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Best is to define the mapping outside of the function in a separate settings
    or configuration file. This approach is okay, but it can still become quite a
    large dictionary if you aren’t careful.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Another way to handle this is by using *polymorphism*. Create a base class with
    a common interface, and then implement subclasses for each specific case. Each
    subclass will handle its unique logic.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want to perform different mathematical operations based on the input
    `op` and apply them to `x` and `y`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And a final warning: beware of code repetition. If you have multiple models
    and you want to use their outputs to get to a final score, don’t create nested
    conditional logic trees. Instead, you can use multiple small functions to get
    to the final score.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a toy example from school. Your final grade for math will be calculated
    out of your attendance percentage and your exam percentage score.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'First look at this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Looks complex right? And what if there are more factors involved in calculating
    the grade? The tree will grow exponentially with every added parameter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, there exists a more concise and efficient solution for such scenarios:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This solution scales really well! You can add a parameter to the list with its
    corresponding score and it will be included in the result.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: You might want to round the final solution when adding more parameters.
    Make sure to do it properly (see the tip about programming language behavior).'
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the future you can use these examples as inspiration to create smarter code
    and avoid long conditional logic trees.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations on reaching the end of this post! The provided tips can be instrumental
    in keeping codebases structured and maintainable. Striking a balance between chaotic
    monolithic files and overly complex nested directories is key to get a good development
    experience.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: By understanding the programming language’s behavior, adopting named tuples
    for multiple return values, handling errors effectively and simplifying conditional
    logic, developers and teams can invest less time in maintenance and more in adding
    useful functionality or exploring new projects. Remember to fortify codebases
    with [tests](https://docs.pytest.org/en/7.4.x/), [linting](https://flake8.pycqa.org/en/latest/),
    [code formatting](https://github.com/psf/black) and [documentation](https://www.sphinx-doc.org/en/master/)
    to ensure long-term health and productivity.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Happy coding, and until next time!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Related
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](/simplify-your-machine-learning-projects-ab171d19c9ef?source=post_page-----717934bd5590--------------------------------)
    [## Simplify Your Machine Learning Projects'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Why spending a lot of time and effort on a complex model is a bad idea, and
    what to do instead
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/simplify-your-machine-learning-projects-ab171d19c9ef?source=post_page-----717934bd5590--------------------------------)
    [](/how-to-compare-ml-solutions-effectively-28384e2cbca1?source=post_page-----717934bd5590--------------------------------)
    [## How to Compare ML Solutions Effectively?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Increasing the chances of getting a model to production
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/how-to-compare-ml-solutions-effectively-28384e2cbca1?source=post_page-----717934bd5590--------------------------------)
    [](https://medium.com/bigdatarepublic/detecting-data-drift-with-machine-learning-adb177544312?source=post_page-----717934bd5590--------------------------------)
    [## Detecting Data Drift with Machine Learning
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Understand degraded performance of your ML models with an easy, automated process.
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过一个简单的自动化过程，了解你的机器学习模型性能下降的情况。
- en: medium.com](https://medium.com/bigdatarepublic/detecting-data-drift-with-machine-learning-adb177544312?source=post_page-----717934bd5590--------------------------------)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[medium.com](https://medium.com/bigdatarepublic/detecting-data-drift-with-machine-learning-adb177544312?source=post_page-----717934bd5590--------------------------------)'
