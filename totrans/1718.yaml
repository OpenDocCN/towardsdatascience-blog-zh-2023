- en: 'Python Decorators: A Comprehensive Guide'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/python-decorators-a-comprehensive-guide-5bde06d2fb27](https://towardsdatascience.com/python-decorators-a-comprehensive-guide-5bde06d2fb27)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: PYTHON PROGRAMMING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The article introduces the amazingly powerful syntactic sugar of Python: decorators.'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@nyggus?source=post_page-----5bde06d2fb27--------------------------------)[![Marcin
    Kozak](../Images/d7faf62e48ed81dab5d8ad92819fff54.png)](https://medium.com/@nyggus?source=post_page-----5bde06d2fb27--------------------------------)[](https://towardsdatascience.com/?source=post_page-----5bde06d2fb27--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----5bde06d2fb27--------------------------------)
    [Marcin Kozak](https://medium.com/@nyggus?source=post_page-----5bde06d2fb27--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----5bde06d2fb27--------------------------------)
    ·11 min read·Oct 19, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ca223f2a3dbe822cd12c47eb407ef22a.png)'
  prefs: []
  type: TYPE_IMG
- en: Be a good designer of your decorators — and of your Python code. Photo by [Spacejoy](https://unsplash.com/@spacejoy?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Python decorators are one of those concepts that seem simple if you understand
    them, but very difficult otherwise. Many Python beginners see them as a magical
    tool that they must learn and use in their own code in order to perform true magic.
    But using built-in decorators or those from site packages is not enough; it’s
    like doing magic with a magic box bought in a kid shop. True magic comes from
    writing your own decorators.
  prefs: []
  type: TYPE_NORMAL
- en: I remember when I desperately wanted to learn how to write and use my own decorators
    in a real project, not just for fun. When that time finally came, the pleasure
    I felt was immense. This experience made me eager to find more opportunities to
    implement my own decorators.
  prefs: []
  type: TYPE_NORMAL
- en: I hope that after reading this article, you will have no problems with Python
    decorators. Therefore, this article aims to introduce the concept of Python decorators
    to those who have not been able to understand it yet. I hope to reveal the magic
    behind them in a simple to understand way.
  prefs: []
  type: TYPE_NORMAL
- en: There is much more to decorators than that. We will discuss the basics, but
    the good news is that these basics should be enough for you to implement even
    complex and functional decorators. In future articles, we will go further into
    the details by discussing the intricacies of decorators and their various use
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: Python programmers at all levels can benefit from this article. *Beginners*
    will learn the basics of decorators, while *intermediates* will gain a deeper
    understanding; *advanced programmers* can use the article to refresh their memory.
    In addition, sometimes it’s good to look at a particular concept from different
    angles, not only the one we’ve been using for years — here, I am offering my viewpoint
    on decorators and their usefulness, which I hope will be helpful to readers of
    all levels.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python decorators are a powerful and versatile tool, but they should be used
    judiciously to avoid overuse and misuse. A decorator is a function that allows
    you to modify the behavior of another function. Decorators can also be written
    as classes, but this is less common and will not be covered in this article.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have a decorator, say `my_decorator()`, you use it to decorate another
    function, say `foo()`, in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After decorating the `foo()` function, we no longer know what it does without
    also knowing what the `my_decorator` decorator does. The decorator may add new
    behavior, such as logging, or it may completely change the function’s behavior
    and return value. For example, the decorated `foo()` function may return a dictionary
    instead of a tuple, or it may return `None`. To find out what the `foo()` function
    does after being decorated, we must check the definition of the `my_decorator`
    decorator.
  prefs: []
  type: TYPE_NORMAL
- en: I don’t know the etymology of the word “decorator” used in the Python context.
    In Python, the word comes from the decorator pattern, but this does not explain
    the original etymology. If you know it, please share it with us in the comments.
  prefs: []
  type: TYPE_NORMAL
- en: I personally find Python decorators to be a beautiful form of syntactic sugar.
    It is no wonder they are called decorators, as they decorate the function being
    decorated. I appreciate both the appearance and power of decorators.
  prefs: []
  type: TYPE_NORMAL
- en: However, I am aware of the difficulty that decorators can introduce. As explained
    above, we cannot know how a decorated function behaves without knowing the definition
    of its decorator. Additionally, the fact that multiple decorators can be used
    on a single function can make things even more complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me organize the idea behind decorators into three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Need*. You have a function, but you need to change its behavior. This can
    result from various reasons. For instance, you may need to add logging to all
    functions in an application or changing the behavior of a function from an external
    module.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Definition*. You write a decorator function that is responsible for this updated
    behavior. It can take one or more parameters in addition to the original function.
    The decorator function typically calls the original function, but it doesn’t have
    to.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Use*. You overwrite the original function with the new one. This can be done
    in two ways: via decoration or assignment, but decoration is much more common.
    Calling the decorated function using its original name means calling the new function,
    because the original function no longer exists unless it was copied.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each of these three steps is equally important, so let’s discuss these three
    steps one by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Need'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Okay, so you *need* to change the behavior of a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why use a decorator to change the behavior of a function instead of simply
    rewriting it? There are a few reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: You may not be able to rewrite the function. For example, it may be a function
    from an external module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may not want to rewrite the function. For example, it may be a large or
    complex function, or it may be a function that is used in many different places.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It may be cumbersome to rewrite the function. For example, it may be called
    by many different functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may only need to change the behavior of the function for development, but
    you want to use the original function in production.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may need to change the behavior of many functions. In this case, it is much
    more efficient to write a decorator than to rewrite each function individually.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most common scenario is when you need to change the behavior of many functions.
    In this case, you can write one decorator and apply it to all of the functions
    that you need to change. This can save you a lot of time and code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few examples of how decorators can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: To add logging to all existing functions in a project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To measure and log the execution time of each function in an app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To add authentication and authorization to functions called in an app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To cache output returned from functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To change a function from writing data to a local file to writing data to a
    remote database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To silence a particular function for testing. For example, you could use a decorator
    to prevent a function from writing to a remote database during testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decorators are also heavily used in mocking in Python. Mocking allows you to
    create fake objects that simulate the behavior of real objects. This can be useful
    for testing code that relies on external resources, such as databases and web
    services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: Definition'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Have you noticed that after decorating a function with the `@` syntax, the decorated
    function is called using the name of the original function? This is what makes
    a function a decorator. If the original function, say `foo()`, is still available
    as `foo()`, and there is a new function, say `foo_changed()`, whose behavior is
    the changed behavior of `foo()`, *there is no decoration involved here*. So, decorating
    a function involves overwriting the original function. You can keep a copy of
    the original function under a new name, but the original function itself has been
    replaced by the decorated function.
  prefs: []
  type: TYPE_NORMAL
- en: Decorating involves overwriting the original function.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It’s time to leave the world of abstraction and move to practicalities. Let’s
    create a simple decorator, called `scream()`, that makes functions scream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This decorator takes a callable (`func`) as input and returns a callable (`inner`).
    The inner function prints “SCREAM!!!” to the console before calling the original
    function (`func`). I gave up a docstring to make the code shorter, but in real
    work, you should definitely add docstrings to your decorators.
  prefs: []
  type: TYPE_NORMAL
- en: In real work, you should definitely add docstrings to your decorators.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here is a breakdown of the `scream()` decorator line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`def scream(func: Callable) -> Callable:` → This is the function signature.
    The `scream()` decorator can be used to decorate any callable (`func`), and it
    returns a callable, too.¹'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`def inner(*args, **kwargs):` → This is the inner function. It prints “SCREAM!!!”;
    you can use whatever name you want, but I usually make it `inner`, like here.
    When decorating a function, you can use any parameters that the decorated function
    takes. For example, the `scream()` decorator can be used for any function, with
    any number of parameters of any types (hence the use of `*args, **kwargs`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`print("SCREAM!!!")` → This is the new behavior, added to the original behavior
    of the decorated function. Whatever the function does, it will *first* scream
    (by printing `"SCREAM!!!"`), and then it will do what it was originally supposed
    to do. Note that in this decorator, the new behavior is added *before*, but it
    can be added *after*, both *before and after*,or even *instead* *of* the original
    behavior.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`return func(*args, **kwargs)` → This is the original behavior of the function.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`return inner` → A standard line of any decorator: returning the `inner` function.
    This means that when the `scream()` decorator is used, it will replace the original
    function with the inner function.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Appendix 1, you will find two other version of the `scream()` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Screaming two times: before and after the original behavior'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Screaming instead of what the original function was supposed to do.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Step 3: Use'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To decorate a function, you can use a decorator in two ways. This subsection
    describes both of them.
  prefs: []
  type: TYPE_NORMAL
- en: '*Method 1: Decorator used as* `*@decorator*`'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need a function to decorate. Let’s use two functions to illustrate
    that you can use the same decorator for as many functions as you want or need,
    and for very different functions at that.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first function we want to decorate is `foo()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When we call this function, we will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is almost the easiest Python function: it takes no parameters and returns
    a string. This is the second function we want to decorate, `bar()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is more complex than `foo()`. It has three parameters: an integer
    `x`, a string `string`, and a callable `func`. It also accepts any additional
    keyword arguments. The function applies `func()` to each character in `string`
    and `x`, passing in the additional keyword arguments, if any. Finally, it returns
    a list of the results.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple call can look like that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s change use a different callable for `func`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: For our purposes, it doesn’t matter what `foo()` and `bar()` do. What’s important
    is that `foo()` is a very simple function, while `bar()` is more complex, despite
    being concise.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can decorate both functions using the decorator syntax, which is shown in
    the two lines starting with the `@` character. For the sake of completeness and
    clarity, I will show the full code, so I will repeat the functions’ code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s run both functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Method 2: Using a decorator as a* `*function()*`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common way to use a decorator function is as a decorator. However,
    there is another way, which is less common:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this way, you simply call the decorator function with the function to be
    decorated as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Irrespective of which method you use to apply the `scream()` decorator, when
    you run `foo()`, the decorated function will scream and then do what it was originally
    used to do.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This article explains the basics of Python decorators. I have tried to be comprehensive,
    but there are still many intricacies of decorators that we have not discussed.
    We will explore these in future articles.
  prefs: []
  type: TYPE_NORMAL
- en: There are several reasons why it is important to learn about Python decorators,
    not only how to use them but also how to write new ones. First, decorators are
    a powerful tool that can help you write concise and readable code. If you know
    how to write custom decorators, you will often find that they can save you a lot
    of time and effort.
  prefs: []
  type: TYPE_NORMAL
- en: Second, decorators can be used to quickly update legacy code. For example, if
    you need to change the behavior of a function or several functions, but revising
    the functions themselves is not an option, you can use a decorator instead. While
    it is always possible to rewrite the functions, if the changed behavior is the
    same for all of them, a single decorator may be sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: Third, decorators are one of the most important syntactic sugar items in Python.
    If you do not understand them, you will likely be considered a Python beginner.
    I cannot imagine a Python developer who does not know how to use decorators, let
    alone understand them.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, decorators are very common in the Python code base. If you are not
    familiar with decorators, you will not be able to understand much of the existing
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, all intermediate and advanced Python developers should know the concept
    of decorators, understand how to use them, and be able to write them.
  prefs: []
  type: TYPE_NORMAL
- en: Although decorators may seem difficult at first glance, I believe that if you
    have read this article up to this point, you will agree that once you understand
    the basics, they are not such a big puzzle after all. In fact, they can be a rather
    simple and handy coding tool.
  prefs: []
  type: TYPE_NORMAL
- en: Footnotes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '¹ For simplicity, I will use the term “decorator function” instead of “decorator
    callable.” However, please keep in mind that this is just a shorthand for decorators
    defined in both ways: as a function and as a class. I simply don’t want to overuse
    the word “callable,” even though it is frequently used in Python texts.'
  prefs: []
  type: TYPE_NORMAL
- en: Appendices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Appendix 1: Two other versions of the `scream()` decorator'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Version 2: Scream before and after running the function*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You would see the following output from `foo()` after decorating it with the
    above decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Version 3: Scream instead of running the function*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This version of the `scream()` decorator completely overwrites the decorated
    function’s original behavior. The decorated function now only screams, and its
    original behavior is completely removed. This structure can be very useful in
    many different situations. For example, you could use it to totally silence a
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see an example of such a silencer in the code of the `[easycheck](https://pypi.org/project/easycheck/)`
    Python package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://github.com/nyggus/easycheck/blob/master/easycheck/easycheck.py?source=post_page-----5bde06d2fb27--------------------------------)
    [## easycheck/easycheck/easycheck.py at master · nyggus/easycheck'
  prefs: []
  type: TYPE_NORMAL
- en: A module offering Python functions for simple and readable assertion-like checks
    to be used inside code, but also in…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: github.com](https://github.com/nyggus/easycheck/blob/master/easycheck/easycheck.py?source=post_page-----5bde06d2fb27--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Look in this code for a `switch` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also see there that you can stack decorators; here’s an example from
    the above `easycheck` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We will discuss such intricacies of decorators in future articles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks for reading. If you enjoyed this article, you may also enjoy other articles
    I wrote; you will see them [here](https://medium.com/@nyggus). And if you want
    to join Medium, please use my referral link below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/@nyggus/membership?source=post_page-----5bde06d2fb27--------------------------------)
    [## Join Medium with my referral link - Marcin Kozak'
  prefs: []
  type: TYPE_NORMAL
- en: Read every story from Marcin Kozak (and thousands of other writers on Medium).
    Your membership fee directly supports…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/@nyggus/membership?source=post_page-----5bde06d2fb27--------------------------------)
  prefs: []
  type: TYPE_NORMAL
