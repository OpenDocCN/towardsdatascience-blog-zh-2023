["```py\nimport random\nimport numpy as np\n\nrandom.seed(10)\n\n# Number of jobs\nn = 15\n# Number of machines\nm = 5\n# Max time for random input generator\nmax_time = 100\n\n# Generate processing times randomly\ntimes = np.zeros((m, n))\ntot_time_job = []\nfor i in range(m):\n    for j in range(n):\n        times[i][j] = random.randint(1, max_time)\n# Total processing time per job - sum across machines\ntot_processing_job = np.sum(times, axis=0)\n\n# Upper bound of the solution - sum of transit matrix\nM = sum(times[j][i] for i in range(n) for j in range(m))\n```", "```py\nopt_model = grb.Model(name=\"Flow shop scheduling\")\n\n# Start time of job j at in machine i\nx = {(j, i): opt_model.addVar(vtype=grb.GRB.CONTINUOUS, lb=0, name=\"x_{0}_{1}\".format(j, i))\n     for j in range(n) for i in range(m)}\n\n# 1 if job j is executed before job k. 0 otherwise\ny = {(j, k): opt_model.addVar(vtype=grb.GRB.BINARY, name=\"y_{0}_{1}\".format(j, k))\n     for j in range(n) for k in range(n) if j != k}\n\n# Makespan - Completion time of last job in last machine\nc = opt_model.addVar(vtype=grb.GRB.CONTINUOUS, lb=0, name=\"c\")\n```", "```py\n# Job j in machine i can start only when it is finished in machine i-1\nc1 = {(j, i): opt_model.addConstr(x[j, i] - x[j, i - 1] >= times[i - 1][j],\n                                  name=\"c1_{0}_{1}\".format(j, i))\n      for j in range(n) for i in range(1, m)}\n\n# Disjunctive constraints - if job j is after k, it should start after its completion\nc2 = {(j, k, i): opt_model.addConstr(x[j, i] - x[k, i] + M * y[j, k] >= times[i][k],\n                                     name=\"c2_{0}_{1}_{2}\".format(j, k, i))\n      for j in range(n) for k in range(n) for i in range(m) if k != j}\n\nc3 = {(j, k, i): opt_model.addConstr(-x[j, i] + x[k, i] - M * y[j, k] >= times[i][j] - M,\n                                     name=\"c3_{0}_{1}_{2}\".format(j, k, i))\n      for j in range(n) for k in range(n) for i in range(m) if k != j}\n\n# Makespan is the completion time of last job in last machine\nc4 = {j: opt_model.addConstr(c >= x[j, m - 1] + times[m - 1][j],\n                             name=\"c4_{0}\".format(j))\n      for j in range(n)}\n```", "```py\nopt_model.ModelSense = grb.GRB.MINIMIZE\nopt_model.setObjective(c)\nopt_model.setParam('MIPGap', 0.018)\nopt_model.optimize()\n```", "```py\ndef get_makespan(solution):\n    ''' Calculate the makespan of a sequence of integer (jobs).\n        - A job can start only after the previous operation of the same job in machine j-1 ends and\n            machine is not processing any other job\n        - Finish time of a job in a given machine is its start time plus processing time in current machine\n    '''\n    end_time = np.zeros((m, len(solution) + 1))\n    for j in range(1, len(solution) + 1):\n        end_time[0][j] = end_time[0][j - 1] + times[0][solution[j - 1]]\n    for i in range(1, m):\n        for j in range(1, len(solution) + 1):\n            end_time[i][j] = max(end_time[i - 1][j], end_time[i][j - 1]) + times[i][solution[j - 1]]\n    return end_time\n```", "```py\ndef neh():\n    ''' Heuristic NEH (Nawaz, Enscore & Ham) for flow shop scheduling\n        1 - Start from an empty schedule\n        2 - Add first the job with highest sum of processing time\n        3 - Go through the list of the unassigned jobs, test all in all possible positions in the current solutions\n        4 - Assign the best job at the best position (with lowest makespan) at the final solution\n        5 - Repeat (3) and (4) until there are no job unassigned\n    '''\n    initial_solution = np.argsort(-tot_processing_job)\n    current_solution = [initial_solution[0]]\n    for i in range(1, n):\n        best_cmax = 99999999\n        for j in range(0, i + 1):\n            temp_solution = current_solution[:]\n            temp_solution.insert(j, initial_solution[i])\n            temp_cmax = get_makespan(temp_solution)[m - 1][len(temp_solution)]\n            if best_cmax > temp_cmax:\n                best_seq = temp_solution\n                best_cmax = temp_cmax\n        current_solution = best_seq\n    return current_solution, get_makespan(current_solution)[m - 1][n]\n```", "```py\nc.Start = cmax_heuristic\n```", "```py\nfor j in range(n):\n   for k in range(n):\n       if j != k:\n           y[j, k].Start = 0\nfor i in range(0, len(sequence_heuristic) - 1):\n   for j in range(i + 1, len(sequence_heuristic)):\n       j1 = sequence_heuristic[i]\n       j2 = sequence_heuristic[j]\n       y[j1, j2].Start = 1\n```"]