["```py\nproject_root/\n|-- data/\n|   |-- raw/                   # Raw data files (read-only)\n|   |-- processed/             # Processed data files (generated by scripts)\n|   |-- intermediate/          # Intermediate data files (generated by scripts)\n|-- notebooks/                # Jupyter notebooks (for exploration, analysis, and visualization)\n|-- src/\n|   |-- data/                  # Data processing scripts\n|   |-- models/                # Model implementation and training scripts\n|   |-- evaluation/            # Model evaluation and testing scripts\n|   |-- utils/                 # Utility functions and helper scripts\n|-- experiments/              # Experiment logs, metrics, and model checkpoints\n|-- configs/                  # Configuration files (hyperparameters, settings)\n|-- tests/                    # Unit tests and test data\n|-- docs/                     # Documentation files (if separate from notebooks)\n|-- README.md                 # Project overview and instructions\n|-- pyproject.toml            # Poetry project file for package management\n|-- poetry.lock               # Poetry lock file for pinned dependencies\n|-- Dockerfile                # Dockerfile for containerization\n|-- .gitignore                # List of files to ignore in version control (e.g., data files, virtual environments)\n```", "```py\nprint(round(2.5))  # output: 2 (expectation: 3) (!)\nprint(round(3.5))  # output: 4 (expectation: 4)\nprint(round(4.5))  # output: 4 (expectation: 5) (!)\npirnt(round(5.5))  # output: 6 (expectation: 6)\n```", "```py\ndef append_to_list(item, my_list=[]):\n    my_list.append(item)\n    return my_list\n\nprint(append_to_list(1))  # output: [1]\nprint(append_to_list(2))  # output: [1, 2] (!)\n```", "```py\nprint(0.1 + 0.2 == 0.3)  # output: False (!)\n```", "```py\nfrom pytest import approx\n\ndef test_example():\n    assert 0.1 + 0.2 == approx(0.3)  # output: True\n```", "```py\nx = 5\nmy_list = [x for x in range(3)]\nprint(x)  # output: 2 (!)\n```", "```py\nmy_list = [None, 3, 1, 2]\nsorted_list = sorted(my_list)  # raises TypeError (!)\n```", "```py\nclass MyClass:\n    pass\n\nobj = MyClass()\nobj.new_attribute = 42\nprint(obj.new_attribute)  # output: 42 (!)\n```", "```py\ndef create_multipliers():\n    multipliers = []\n    for i in range(5):\n        def multiplier(x):\n            return i * x\n        multipliers.append(multiplier)\n    return multipliers\n\nmultipliers_list = create_multipliers()\n\n# calling the closure functions from the list\nprint(multipliers_list[0](2))  # output: 8 (4 * 2)\nprint(multipliers_list[1](2))  # output: 8 (4 * 2)\nprint(multipliers_list[2](2))  # output: 8 (4 * 2)\nprint(multipliers_list[3](2))  # output: 8 (4 * 2)\nprint(multipliers_list[4](2))  # output: 8 (4 * 2)\n```", "```py\ndef create_multipliers_fixed():\n    multipliers = []\n    for i in range(5):\n        def multiplier(x, i=i):\n            return i * x\n        multipliers.append(multiplier)\n    return multipliers\n\nmultipliers_list_fixed = create_multipliers_fixed()\n\n# calling the fixed closure functions from the list\nprint(multipliers_list_fixed[0](2))  # output: 0 (0 * 2)\nprint(multipliers_list_fixed[1](2))  # output: 2 (1 * 2)\nprint(multipliers_list_fixed[2](2))  # output: 4 (2 * 2)\nprint(multipliers_list_fixed[3](2))  # output: 6 (3 * 2)\nprint(multipliers_list_fixed[4](2))  # output: 8 (4 * 2)\n```", "```py\nfrom collections import namedtuple\n\ndef calculate_statistics(numbers):\n    total = sum(numbers)\n    mean = total / len(numbers)\n    maximum = max(numbers)\n    Statistics = namedtuple('Statistics', ['sum', 'mean', 'maximum'])\n    return Statistics(sum=total, mean=mean, maximum=maximum)\n\n# example\ndata = [12, 5, 8, 14, 10]\nresult = calculate_statistics(data)\n\nprint(\"Sum:\", result.sum)         # output: Sum: 49\nprint(\"Mean:\", result.mean)       # output: Mean: 9.8\nprint(\"Maximum:\", result.maximum) # output: Maximum: 14\n```", "```py\ntry:\n    result = do_something()\nexcept:\n    pass\n```", "```py\ntry:\n    result = do_something()\nexcept Exception as e:\n    log_error(f'Exception occurred: {str(e)}')\n```", "```py\ntry:\n    result = do_something()\nexcept FileNotFoundError:\n    log_error(\"File not found.\")\nexcept ValueError:\n    log_error(\"Invalid input.\")\nexcept Exception as e:\n    # catch any other unexpected exceptions and log them for debugging\n    log_error(f\"An unexpected error occurred: {str(e)}\")\nfinally:\n    # this runs always, whether an exception occurred or not\n    close_resources()\n```", "```py\nclass CustomError(Exception):\n    def __init__(self, message, *args):\n        self.message = message\n        super(CustomError, self).__init__(message, *args)\n\ndef some_function():\n    if some_condition:\n        raise CustomError(\"This is a custom error message.\")\n\ntry:\n    some_function()\nexcept CustomError as ce:\n    log_error(str(ce))\n```", "```py\ndef process_input(x):\n    if x == 'A':\n        return 'Apple'\n    elif x == 'B':\n        return 'Banana'\n    elif x == 'C':\n        return 'Cherry'\n    elif x == 'D':\n        return 'Date'\n    # ... and so on for many more cases\n    else:\n        return 'Unknown'\n```", "```py\ndef process_input(x):\n    mapping = {\n        'A': 'Apple',\n        'B': 'Banana',\n        'C': 'Cherry',\n        'D': 'Date',\n        # ... and so on for many more cases\n    }\n    return mapping.get(x, 'Unknown')\n```", "```py\nclass Operation:\n    def perform(self, x, y):\n        raise NotImplementedError\n\nclass Addition(Operation):\n    def perform(self, x, y):\n        return x + y\n\nclass Subtraction(Operation):\n    def perform(self, x, y):\n        return x - y\n\nclass Multiplication(Operation):\n    def perform(self, x, y):\n        return x * y\n\nclass Division(Operation):\n    def perform(self, x, y):\n        if y != 0:\n            return x / y\n        else:\n            raise ValueError(\"Cannot divide by zero.\")\n\ndef calculate(op, x, y):\n    operations = {\n        '+': Addition(),\n        '-': Subtraction(),\n        '*': Multiplication(),\n        '/': Division(),\n    }\n\n    operation = operations.get(op)\n    if operation:\n        return operation.perform(x, y)\n    else:\n        raise ValueError(\"Invalid operation.\")\n```", "```py\ndef final_score(attendance: float, exam: float) -> int:\n    if attendance < 0.25:\n        if exam < 0.25:\n            return 4\n        elif exam < 0.5:\n            return 5\n        elif exam < 0.75:\n            return 6\n        else:\n            return 7\n    elif attendance < 0.5:\n        if exam < 0.25:\n            return 5\n        elif exam < 0.5:\n            return 6\n        elif exam < 0.75:\n            return 7\n        else:\n            return 8\n    elif attendance < 0.75:\n        if exam < 0.25:\n            return 6\n        elif exam < 0.5:\n            return 7\n        elif exam < 0.75:\n            return 8\n        else:\n            return 9\n    else:\n        if exam < 0.25:\n            return 7\n        elif exam < 0.5:\n            return 8\n        elif exam < 0.75:\n            return 9\n        else:\n            return 10 \n```", "```py\nfrom typing import List\n\ndef map_score(score, score_ranges: List[float]) -> int:\n    for i, threshold in enumerate(score_ranges):\n        if score < threshold:\n            return 2*i\n    return 2*(i+1)\n\ndef final_score(parameter_scores: List[float], base_score: int = 4) -> int:\n    parameter_range = [0.25, 0.5, 0.75]\n    scores = [map_score(parameter_score, parameter_range)/len(parameter_scores) for parameter_score in parameter_scores]\n    return sum(scores) + base_score\n\n# example\nattendance = 0.6\nexam = 0.85\nresult = final_score([attendance, exam])\nprint(\"Final Score:\", result)\n```"]