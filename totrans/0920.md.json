["```py\ndef apply_transformation(original_x: int, original_y: int) -> Tuple[int, int]:\n    # Define the rotation matrix   \n    rotate_transformation = np.array([[np.cos(np.pi/4), -np.sin(np.pi/4), 0],\n                                      [np.sin(np.pi/4),  np.cos(np.pi/4), 0],\n                                      [0, 0, 1]])\n    # Apply transformation after setting homogenous coordinate to 1 for the original vector.\n    new_coordinates = rotate_transformation @ np.array([original_x, original_y, 1]).T\n    # Round the new coordinates to the nearest pixel   \n    return int(np.rint(new_coordinates[0])), int(np.rint(new_coordinates[1]))\n```", "```py\ndef forward_mapping(original_image: np.ndarray) -> np.ndarray:\n    # Create the new image with same shape as the original one\n    new_image = np.zeros_like(original_image)\n    for original_y in range(original_image.shape[1]):\n        for original_x in range(original_image.shape[0]):\n            # Apply rotation on the original pixel's coordinates\n            new_x, new_y = apply_transformation(original_x, original_y)\n            # Check if new coordinates fall inside the image's domain\n            if 0 <= new_y < new_image.shape[1] and 0 <= new_x < new_image.shape[0]:\n                new_image[new_x, new_y, :] = original_image[original_x, original_y, :]\n\n    return new_image\n```", "```py\ndef apply_inverse_transformation(new_x: int, new_y: int) -> Tuple[int, int]:\n    # Define the inverse rotation matrix\n    rotate_transformation = np.array([[np.cos(np.pi/4), -np.sin(np.pi/4), 0],\n                                      [np.sin(np.pi/4),  np.cos(np.pi/4), 0],\n                                      [0, 0, 1]])\n    inverse_rotate_transformation = np.linalg.inv(rotate_transformation)\n\n    # Apply transformation after setting homogenous coordinate to 1 for the position vector.\n    original_coordinates = inverse_rotate_transformation @ np.array([new_x, new_y, 1]).T\n    # Round the original coordinates to the nearest pixel\n    return int(np.rint(original_coordinates[0])), int(np.rint(original_coordinates[1]))\n```", "```py\ndef backward_mapping(original_image: np.ndarray) -> np.ndarray:\n    # Create the new image with same shape as the original one\n    new_image = np.zeros_like(original_image)\n    for new_y in range(new_image.shape[1]):\n        for new_x in range(new_image.shape[0]):\n            # Apply inverse rotation on the new pixel's coordinates\n            original_x, original_y = apply_inverse_transformation(new_x, new_y)\n            # Check if original coordinates fall inside the image's domain\n            if 0 <= original_y < original_image.shape[1] and 0 <= original_x < original_image.shape[0]:\n                new_image[new_x, new_y, :] = original_image[original_x, original_y, :]\n\n    return new_image\n```"]