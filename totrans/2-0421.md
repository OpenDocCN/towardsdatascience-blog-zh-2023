# 用 Go 构建 REST API：时间序列的数据分析

> 原文：[https://towardsdatascience.com/build-a-rest-api-with-go-data-analytics-for-time-series-8d3f0747665c](https://towardsdatascience.com/build-a-rest-api-with-go-data-analytics-for-time-series-8d3f0747665c)

## 一个关于使用 Go、Gin 和 Gorm 进行 CRUD 操作和统计分析的逐步示例。

[](https://medium.com/@davide.burba?source=post_page-----8d3f0747665c--------------------------------)[![Davide Burba](../Images/a1ca3cf59c2b933021fa0d978e1af522.png)](https://medium.com/@davide.burba?source=post_page-----8d3f0747665c--------------------------------)[](https://towardsdatascience.com/?source=post_page-----8d3f0747665c--------------------------------)[![Towards Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----8d3f0747665c--------------------------------) [Davide Burba](https://medium.com/@davide.burba?source=post_page-----8d3f0747665c--------------------------------)

·发布于 [Towards Data Science](https://towardsdatascience.com/?source=post_page-----8d3f0747665c--------------------------------) ·阅读时间 10 分钟·2023 年 11 月 7 日

--

![](../Images/a6e61301baab7f2a0bed1c777ea8da26.png)

“学习 Go”，作者 [Giulia Roggia](https://www.instagram.com/giulia_roggia__/)。经许可使用。

+   [介绍](#23c9)

+   [模型与数据库](#4f5c)

+   [统计](#810b)

+   [处理程序](#1043)

+   [用法](#380a)

# 介绍

本文介绍了一个使用 Go 构建的 REST API 示例，用于执行 CRUD（创建、读取、更新、删除）操作并计算时间序列数据的统计信息。

*本文中使用的完整代码可以在* [*这里*](https://github.com/davide-burba/code-collection/)*找到*。

## *为什么选择 Go？*

[Go](https://go.dev/) 是构建 REST API 的常见选择，原因有很多。尽管它是高效的编译语言，但其语法简单且可读性强。它使得实现并发处理变得容易。它提供了功能丰富的标准库，并且拥有一个出色的库和工具生态系统。

在这个例子中，我们使用了两个流行的 Go 库：

+   [Gin](https://gin-gonic.com/): 一个提供创建 Web 应用工具的 Web 框架。

+   [Gorm](https://gorm.io/): 一个功能全面的 ORM（对象关系映射），用于与数据库交互。

## 文件夹结构

我们为每个“服务”创建一个文件夹。在 Go 中，每个文件夹对应一个包，每个文件都可以访问同一包中其他文件定义的元素。以下是项目中使用的文件夹结构：

[PRE0]

# 模型与数据库

首先在 *models.go* 中定义 ORM 模型，以表示时间序列数据。我们使用了两个模型，一个用于标识序列，另一个用于存储其值。每个值通过外键与时间序列相关联。

[PRE1]

我们还定义了两个用于时间序列值的 getter，这在计算统计数据时将非常有用。

[PRE2]

在*database.go*中，我们定义了一个获取数据库的函数（在示例中使用*SQLite*），并应用迁移以创建每个模型的SQL表（如果尚不存在）。

[PRE3]

# 统计量

注意：如果你只对CRUD部分感兴趣，可以跳过这一部分。

由于统计量的计算是一个常见任务，为了提高代码的可重用性，我们将其开发为一个“独立”包，这意味着它不依赖于项目中定义的其他包。为此，我们定义一个`TsValue`接口：统计函数的输入是一个值的切片，每个值必须定义接口方法`GetTime`和`GetValue`。

[PRE4]

现在我们为每个统计量定义一个函数：

+   `Count`：系列的长度。

[PRE5]

+   `Min`：最小值（以及`Max`，其功能类似）。

[PRE6]

+   `Mean`：系列的均值。

[PRE7]

+   `StandardDeviation`：系列的标准差。

[PRE8]

我们可以将统计量集中在一个函数中：

[PRE9]

请注意，函数`ComputeStatistics`是顺序计算统计量的。如果每个系列中的值很多，这可能会变得耗时。如果是这样，我们可以使用goroutines并发计算统计量。

让我们定义一个并发版本`ComputeStatisticsConcurrent`，其执行以下步骤：

1.  创建一个通道来收集结果，一个同步goroutines的等待机制，以及一个包含要计算的统计量的映射。

1.  设置一个计数器来计算要计算的统计量数量。

1.  为每个统计函数启动一个goroutine。

1.  设置一个特殊的goroutine，以便在所有统计量计算完成后（即计数器归零时）关闭通道。

1.  从通道中收集结果。收集在通道关闭时停止。

[PRE10]

**注意**：如果你想在不使用大数据的情况下测试性能提升，可以在每个统计函数内部运行`time.Sleep`进行模拟。

# 处理程序

现在让我们定义REST API的端点。因为：

+   端点逻辑依赖于数据库。

+   我们不想使用全局变量。

+   端点函数必须只接受Gin上下文指针作为输入，该指针包含请求信息。

我们创建一个数据库包装器，并将端点方法分配给它：

[PRE11]

我们定义一个函数来设置所有端点。每个端点指定一个路径，并指定一个接受Gin上下文指针的函数。

[PRE12]

## 处理程序：系列

让我们从定义时间序列端点开始。下面是列出所有可用时间序列的实现。当调用`DB.Find`时，时间序列存储在`tseriesList`切片中。

[PRE13]

在开发`TimeSeries`的基础CRUD端点之前，让我们定义一个辅助函数来从请求中获取系列ID并执行一些检查。

[PRE14]

我们现在可以定义`TimeSeries`的基本CRUD操作：

+   *创建*：POST一个新的系列。

[PRE15]

+   *读取*：GET一个现有系列。

[PRE16]

+   *更新*：PUT一个现有系列。

[PRE17]

+   *删除*：删除一个系列及其值。为了在运行时出现错误时进行回滚，我们在数据库事务中执行这两个操作。

[PRE18]

## 处理程序：值

我们现在可以定义 `TimeSeriesValues` 的端点。由于它们与我们刚刚定义的端点类似，我们仅展示 *Create* 方法的实现，它与系列方法不同，因为我们允许同时发布多个值。

[PRE19]

## 处理程序：统计信息

我们需要定义的最后一个处理程序是计算给定系列的统计信息。根据其 ID，我们查询值并使用之前实现的 `ComputeStatisticsConcurrent` 函数计算统计信息。

[PRE20]

在返回统计信息之前，我们将 `serializeMap` 函数应用于输出。这是为了将 *NaN* 值转换为 *nil*，以便使输出可以进行 JSON 序列化。注意，映射中的输出值类型是空接口 `interface{}`，它可以容纳任何类型的值。

[PRE21]

# 使用方法

使应用程序可用的最后一段代码是 `main` 函数，用于运行 Web 服务器。我们提供了三个可选的命令行参数：

+   `db`：指定数据库文件的名称（默认：`timeseries.db`）

+   `proxy`：设置服务器的受信任代理（默认：`127.0.0.1`）

+   `port`：定义服务器监听的端口号（默认：`8080`）

[PRE22]

## 构建

你现在可以通过以下方式运行 API：

1.  使用 `go mod init` 初始化一个新的 Go 模块。这将生成一个带有模块名称和 Go 版本的 *go.mod* 文件。

1.  使用 `go mod tidy` 跟踪依赖项。这将把项目依赖项添加到 *go.mod* 文件中，并创建一个包含所有依赖项校验和的 *go.sum* 文件（用于确保其完整性）。

1.  使用 `go build` 构建程序并运行生成的可执行文件。这也可以通过 `go run main.go` 一步完成。

*go.mod* 和 *go.sum* 文件已在 [项目仓库](https://github.com/davide-burba/code-collection/tree/main/examples/go-timeseries-api) 中提供。你可以在 [这里](https://pkg.go.dev/cmd/go) 阅读更多关于 `go` 命令的信息。

我们还可以使用 Docker 运行 API。在下面显示的 *Dockerfile* 中，首先，我们使用 Go 官方镜像构建可执行文件，然后将其复制到一个最小的镜像中，这样得到一个约 20Mb 的小文件。

[PRE23]

我们可以按照以下步骤使用 Docker 构建和执行 API：

[PRE24]

## 示例用法

应用程序启动并运行后，我们可以通过 API 调用来测试它。下面我们展示了一个使用 `curl` 的示例。我们创建一个时间序列，发布其值，计算统计信息，最后删除它。

[PRE25]

# 关于学习 Go 的说明

这是我在 Go 中的第一个项目。因此，如果你有任何反馈，我将非常感激！

我来自 Python 背景，我特别喜欢 Go 的速度和轻量性，并发现它比 C++ 学起来容易多了。以下是一些帮助我入门的资源：

+   [官方 Go 教程](https://go.dev/doc/tutorial/)

+   [Go 之旅](https://go.dev/tour/basics/1)：对 Go 的互动式介绍，也是官方的

+   [使用 Go、Gin 和 Gorm 开发简单的 CRUD API](https://cgrant.medium.com/developing-a-simple-crud-api-with-go-gin-and-gorm-df87d98e6ed1)

+   [寻找最佳 Go 项目结构](https://itnext.io/finding-the-best-go-project-structure-part-1-5290bc1d869d)

*本文中使用的完整代码可以在* [*这里*](https://github.com/davide-burba/code-collection/) *找到。*

*喜欢这篇文章吗？* [*查看我的其他文章*](https://medium.com/@davide.burba) *并关注我以获取更多内容！* [*点击这里*](https://medium.com/@davide.burba/membership) *以无限阅读文章并以零额外费用支持我* ❤️
