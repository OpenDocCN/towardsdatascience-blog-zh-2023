["```py\ndef generate_vibration_signal(duration, sampling_rate, frequency, amplitude, noise_level, max_wear, wear_threshold):\n    t = np.linspace(0, duration, int(sampling_rate * duration), endpoint=False)\n\n    # Generate a sinusoidal signal\n    signal = amplitude * np.sin(2 * np.pi * frequency * t)\n\n    # Add random noise to simulate real-world conditions\n    noise = np.random.normal(0, noise_level, signal.shape)\n    signal_with_noise = signal + noise\n\n    # Simulate equipment wear\n    wear = np.linspace(0, max_wear, len(t))\n    wear[wear > wear_threshold] = 0  # Reset wear if it exceeds the threshold\n    signal_with_wear = signal_with_noise + wear\n\n    return t, signal_with_wear\n```", "```py\n# Parameters\nduration = 20         # seconds\nsampling_rate = 20    # Hz\nfrequency = 5         # Hz (vibration frequency)\namplitude = 1.0       # Min Max range\nnoise_level = 0.3     # Noise factor to increase reality\nmax_wear = 1          # Maximum wear before reset\nwear_threshold = 0.5  # Wear threshold for reset\n\n# Generate synthetic vibration signal with wear and threshold\ntime, vibration_signal = generate_vibration_signal(duration, sampling_rate, frequency, amplitude, noise_level, max_wear, wear_threshold)\n\n# Plot the signal\nplt.plot(time, vibration_signal)\nplt.title('Synthetic Vibration Signal with Equipment Wear')\nplt.xlabel('Time (s)')\nplt.ylabel('Amplitude')\nplt.legend()\nplt.show()\n```", "```py\ndf_windowed = pd.DataFrame({'time': time, 'vibration_signal': vibration_signal})\n\n# Make some experiments\nwindow_size = int(2)  \n\n# Apply mean windowing using the 'rolling' function\ndf_windowed['mean_amplitude'] = df_windowed['vibration_signal'].rolling(window=window_size, min_periods=1).mean()\n\n# Plot the original signal and the mean windowed signal\nplt.plot(df_windowed['time'], df_windowed['vibration_signal'], label='Original Signal')\nplt.plot(df_windowed['time'], df_windowed['mean_amplitude'], label=f'Mean Window ({window_size} samples)')\nplt.title('Synthetic Vibration Signal with Mean Windowing')\nplt.xlabel('Time (s)')\nplt.ylabel('Amplitude')\nplt.legend()\nplt.show()\n```", "```py\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.stats import skew, kurtosis\n\n# Set a random seed for reproducibility\nnp.random.seed(1992)\n\n# Generate synthetic datasets with varying skewness and kurtosis\n# Normal distribution\nnormal_data = np.random.normal(loc=170, scale=5, size=1000)\n\n# Positively skewed distribution                \nskewed_data = np.random.gamma(shape=2, scale=5, size=1000)\n\n# Negatively skewed distribution                 \nnegative_skewed_data = -np.random.gamma(shape=2, scale=5, size=1000)      \n\n# Calculate mean and median for each dataset\nnormal_mean, normal_median = np.mean(normal_data), np.median(normal_data)\nskewed_mean, skewed_median = np.mean(skewed_data), np.median(skewed_data)\nnegative_skewed_mean, negative_skewed_median = np.mean(negative_skewed_data), np.median(negative_skewed_data)\n\n# Plot the distributions\nplt.figure(figsize=(12, 6))\n\nplt.subplot(1, 3, 1)\nplt.hist(normal_data, bins=30, color='blue', alpha=0.7)\nplt.axvline(x=normal_mean, color='red', linestyle='--', label=f'Mean: {normal_mean:.2f}')\nplt.axvline(x=normal_median, color='green', linestyle='--', label=f'Median: {normal_median:.2f}')\nplt.legend()\nplt.title('Normal Distribution')\n\nplt.subplot(1, 3, 2)\nplt.hist(skewed_data, bins=30, color='orange', alpha=0.7)\nplt.axvline(x=skewed_mean, color='red', linestyle='--', label=f'Mean: {skewed_mean:.2f}')\nplt.axvline(x=skewed_median, color='green', linestyle='--', label=f'Median: {skewed_median:.2f}')\nplt.legend()\nplt.title('Positively Skewed Distribution')\n\nplt.subplot(1, 3, 3)\nplt.hist(negative_skewed_data, bins=30, color='green', alpha=0.7)\nplt.axvline(x=negative_skewed_mean, color='red', linestyle='--', label=f'Mean: {negative_skewed_mean:.2f}')\nplt.axvline(x=negative_skewed_median, color='green', linestyle='--', label=f'Median: {negative_skewed_median:.2f}')\nplt.legend()\nplt.title('Negatively Skewed Distribution')\n\nplt.tight_layout()\nplt.show()\n```", "```py\n# Leptokurtic distribution (heavier tails)\nheavy_tails_data = np.random.exponential(scale=10, size=1000)\n\n# Platykurtic distribution (lighter tails)\nlight_tails_data = np.random.uniform(low=160, high=180, size=1000)        \n\n# Calculate mean and median for each dataset\nnormal_mean, normal_median = np.mean(normal_data), np.median(normal_data)\nheavy_tails_mean, heavy_tails_median = np.mean(heavy_tails_data), np.median(heavy_tails_data)\nlight_tails_mean, light_tails_median = np.mean(light_tails_data), np.median(light_tails_data)\n\n# Plot the distributions with mean and median\nplt.figure(figsize=(12, 6))\n\nplt.subplot(1, 3, 1)\nplt.hist(normal_data, bins=30, color='blue', alpha=0.7)\nplt.axvline(x=normal_mean, color='red', linestyle='--', label=f'Mean: {normal_mean:.2f}')\nplt.axvline(x=normal_median, color='green', linestyle='--', label=f'Median: {normal_median:.2f}')\nplt.legend()\nplt.title('Normal (esokurtic) Distribution')\n\nplt.subplot(1, 3, 2)\nplt.hist(heavy_tails_data, bins=30, color='red', alpha=0.7)\nplt.axvline(x=heavy_tails_mean, color='red', linestyle='--', label=f'Mean: {heavy_tails_mean:.2f}')\nplt.axvline(x=heavy_tails_median, color='green', linestyle='--', label=f'Median: {heavy_tails_median:.2f}')\nplt.legend()\nplt.title('Leptokurtic Distribution (Heavier Tails)')\n\nplt.subplot(1, 3, 3)\nplt.hist(light_tails_data, bins=30, color='green', alpha=0.7)\nplt.axvline(x=light_tails_mean, color='red', linestyle='--', label=f'Mean: {light_tails_mean:.2f}')\nplt.axvline(x=light_tails_median, color='green', linestyle='--', label=f'Median: {light_tails_median:.2f}')\nplt.legend()\nplt.title('Platykurtic Distribution (Lighter Tails)')\n\nplt.tight_layout()\nplt.show()\n```", "```py\n# Calculate skewness and kurtosis for each dataset\nnormal_skewness = skew(normal_data)\nnormal_kurtosis = kurtosis(normal_data)\n\nskewed_skewness = skew(skewed_data)\nskewed_kurtosis = kurtosis(skewed_data)\n\nnegative_skewness = skew(negative_skewed_data)\nnegative_kurtosis = kurtosis(negative_skewed_data)\n\nheavy_tails_skewness = skew(heavy_tails_data)\nheavy_tails_kurtosis = kurtosis(heavy_tails_data)\n\nlight_tails_skewness = skew(light_tails_data)\nlight_tails_kurtosis = kurtosis(light_tails_data)\n\n# Print the calculated values\nprint(\"Normal Distribution:\")\nprint(f\"Skewness: {normal_skewness}, Kurtosis: {normal_kurtosis}\\n\")\n\nprint(\"Positively Skewed Distribution:\")\nprint(f\"Skewness: {skewed_skewness}, Kurtosis: {skewed_kurtosis}\\n\")\n\nprint(\"Negatively Skewed Distribution:\")\nprint(f\"Skewness: {negative_skewness}, Kurtosis: {negative_kurtosis}\\n\")\n\nprint(\"Leptokurtic Distribution (Heavier Tails):\")\nprint(f\"Skewness: {heavy_tails_skewness}, Kurtosis: {heavy_tails_kurtosis}\\n\")\n\nprint(\"Platykurtic Distribution (Lighter Tails):\")\nprint(f\"Skewness: {light_tails_skewness}, Kurtosis: {light_tails_kurtosis}\\n\")\n```", "```py\ndef calculate_rolling_statistics(signal, window_size):\n\n    df = pd.DataFrame({'signal': signal})\n    rolling_stats = df['signal'].rolling(window=window_size, min_periods=1)\n\n    mean_values = rolling_stats.mean()\n    std_dev_values = rolling_stats.std()\n    skewness_values = rolling_stats.apply(skew, raw=True)\n    kurtosis_values = rolling_stats.apply(kurtosis, raw=True)\n\n    return mean_values, std_dev_values, skewness_values, kurtosis_values\n\nwindow_size = 20  \n\n# Calculate rolling statistics\nrolling_means, rolling_std_devs, rolling_skewness, rolling_kurtosis = calculate_rolling_statistics(vibration_signal, window_size)\n```", "```py\n# Plot the signal and rolling statistics\nplt.figure(figsize=(12, 6))\n\n# Plot Rolling Mean, Rolling Mean + Std Dev, Rolling Mean - Std Dev\nplt.subplot(2, 1, 1)\nplt.plot(time[:len(rolling_means)], vibration_signal[:len(rolling_means)], label='Vibration Signal')\nplt.plot(time[:len(rolling_means)], rolling_means, label='Rolling Mean')\nplt.plot(time[:len(rolling_means)], rolling_means + rolling_std_devs, label='Rolling Mean + Std Dev', linestyle='--')\nplt.plot(time[:len(rolling_means)], rolling_means - rolling_std_devs, label='Rolling Mean - Std Dev', linestyle='--')\nplt.title(f'Synthetic Vibration Signal with Rolling Mean and Standard Deviation (Window Size = {window_size})')\nplt.xlabel('Time (s)')\nplt.ylabel('Amplitude')\nplt.legend()\n\n# Plot Rolling Skewness and Rolling Kurtosis\nplt.subplot(2, 1, 2)\nplt.plot(time[:len(rolling_means)], vibration_signal[:len(rolling_means)], label='Vibration Signal')\nplt.plot(time[:len(rolling_means)], rolling_skewness, label='Rolling Skewness', linestyle='--')\nplt.plot(time[:len(rolling_means)], rolling_kurtosis, label='Rolling Kurtosis', linestyle='--')\nplt.title(f'Synthetic Vibration Signal with Rolling Skewness and Kurtosis (Window Size = {window_size})')\nplt.xlabel('Time (s)')\nplt.ylabel('Amplitude')\nplt.legend()\n\nplt.tight_layout()\nplt.show()\n```", "```py\ndef calculate_rolling_statistics_behind_scenes(signal, window_size):\n    mean_values = np.convolve(signal, np.ones(window_size)/window_size, mode='valid')\n    std_dev_values = np.array([np.std(signal[i-window_size+1:i+1]) for i in range(window_size-1, len(signal))])\n    skewness_values = np.array([skew(signal[i-window_size+1:i+1]) for i in range(window_size-1, len(signal))])\n    kurtosis_values = np.array([kurtosis(signal[i-window_size+1:i+1]) for i in range(window_size-1, len(signal))])\n\n    return mean_values, std_dev_values, skewness_values, kurtosis_values\n```", "```py\ndef calculate_rolling_rms(signal, window_size):\n    df = pd.DataFrame({'signal': signal})\n    rolling_stats = df['signal'].rolling(window=window_size, min_periods=1)\n\n    rms_values = np.sqrt(rolling_stats.apply(lambda x: np.mean(x**2), raw=True))\n\n    return rms_values\n\nwindow_size = 20\nrolling_rms = calculate_rolling_rms(vibration_signal, window_size)\n```", "```py\nplt.plot(time[:len(rolling_rms)], vibration_signal[:len(rolling_rms)], label='Vibration Signal')\nplt.plot(time[:len(rolling_rms)], rolling_rms, label='Rolling RMS', linestyle='--')\nplt.title(f'Synthetic Vibration Signal with Rolling RMS (Window Size = {window_size})')\nplt.xlabel('Time (s)')\nplt.ylabel('Amplitude')\nplt.legend()\n\nplt.tight_layout()\nplt.show()\n```", "```py\ndef calculate_crest_factor_and_peak(signal, window_size):\n    df = pd.DataFrame({'signal': signal})\n    rolling_stats = df['signal'].rolling(window=window_size, min_periods=1)\n\n    peak_values = rolling_stats.apply(lambda x: np.max(np.abs(x)), raw=True)\n    rms_values = np.sqrt(rolling_stats.apply(lambda x: np.mean(x**2), raw=True))\n\n    crest_factor_values = peak_values / rms_values\n\n    return crest_factor_values, peak_values\n\n# Calculate rolling Crest Factor and Peak values\nrolling_crest_factor, rolling_peak_values = calculate_crest_factor_and_peak(vibration_signal, window_size)\n```", "```py\n# Plot the vibration signal, rolling Crest Factor, and Peak values\n\nplt.plot(time[:len(rolling_crest_factor)], vibration_signal[:len(rolling_crest_factor)], label='Vibration Signal')\nplt.plot(time[:len(rolling_crest_factor)], rolling_crest_factor, label='Rolling Crest Factor', linestyle='--')\nplt.plot(time[:len(rolling_peak_values)], rolling_peak_values, label='Rolling Peak Values', linestyle='-.')\nplt.title(f'Synthetic Vibration Signal with Rolling Crest Factor and Peak Values (Window Size = {window_size})')\nplt.xlabel('Time (s)')\nplt.ylabel('Amplitude')\nplt.legend()\n\nplt.tight_layout()\nplt.show()\n```"]