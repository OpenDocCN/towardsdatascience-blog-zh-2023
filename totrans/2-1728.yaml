- en: 'Python Lists Vs. NumPy Arrays: A Deep Dive into Memory Layout and Performance
    Benefits'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/python-lists-vs-numpy-arrays-a-deep-dive-into-memory-layout-and-performance-benefits-a74ce774bc1e](https://towardsdatascience.com/python-lists-vs-numpy-arrays-a-deep-dive-into-memory-layout-and-performance-benefits-a74ce774bc1e)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[FAST COMPUTING](https://medium.com/@qtalen/list/fast-computing-2a37a7e82be5)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Exploring allocation differences and efficiency gains
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://qtalen.medium.com/?source=post_page-----a74ce774bc1e--------------------------------)[![Peng
    Qian](../Images/9ce9aeb381ec6b017c1ee5d4714937e2.png)](https://qtalen.medium.com/?source=post_page-----a74ce774bc1e--------------------------------)[](https://towardsdatascience.com/?source=post_page-----a74ce774bc1e--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----a74ce774bc1e--------------------------------)
    [Peng Qian](https://qtalen.medium.com/?source=post_page-----a74ce774bc1e--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----a74ce774bc1e--------------------------------)
    ·9 min read·Jul 14, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9c59152b04be4c0785841172da617a50.png)'
  prefs: []
  type: TYPE_IMG
- en: Data in NumPy arrays are arranged as compactly as books on a shelf. Photo by
    [Eliabe Costa](https://unsplash.com/@eliabevces?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: In this article, we will delve into the memory design differences between native
    Python lists and NumPy arrays, revealing why NumPy can provide better performance
    in many cases.
  prefs: []
  type: TYPE_NORMAL
- en: We will compare data structures, memory allocation, and access methods, showcasing
    the power of NumPy arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine you are preparing to go to the library to find a book. Now, you discover
    that the library has two shelves:'
  prefs: []
  type: TYPE_NORMAL
- en: The first shelf is filled with various exquisite boxes, some containing CDs,
    some containing pictures, and others containing books. Only the name of the item
    is attached to the box.
  prefs: []
  type: TYPE_NORMAL
- en: This represents native Python lists, where each element has its memory space
    and type information.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this approach has a problem: many empty spaces in the boxes, wasting
    shelf space. Moreover, when you want to find a specific book, you must look inside
    each box, which takes extra time.'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at the second shelf. This time there are no boxes; books, CDs,
    and pictures are all compactly placed together according to their categories.
  prefs: []
  type: TYPE_NORMAL
- en: This is NumPy arrays, which store data in memory in a continuous fashion, improving
    space utilization.
  prefs: []
  type: TYPE_NORMAL
- en: Since the items are all grouped by category, you can quickly find a book without
    having to search through many boxes. This is why NumPy arrays are faster than
    native Python lists in many operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python Lists: A Flexible but Less Efficient Solution'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everything in Python is an object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start with the Python interpreter: although CPython is written in C,
    Python variables are not basic data types in C, but rather C structures that contain
    values and additional information.'
  prefs: []
  type: TYPE_NORMAL
- en: Take a Python integer `x = 10_000` as an example, `x` is not a basic type on
    the stack. Instead, it is a pointer to a memory heap object.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you delve into the source code of `Python 3.10`, you’ll find that the C
    structure that `x` points to is as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e8ab1f9b423c39d2154cf23062e737c9.png)'
  prefs: []
  type: TYPE_IMG
- en: Python integer vs. C native integer. Image by Author.
  prefs: []
  type: TYPE_NORMAL
- en: The `PyObject_HEAD` contains information such as reference count, type information,
    and object size.
  prefs: []
  type: TYPE_NORMAL
- en: Python lists are objects containing a series of objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From this, we can deduce that a Python list is also an object, except that it
    contains pointers to other objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a list that contains only integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also create a list that includes multiple object types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Pros and cons of Python lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we can see, Python lists contain a series of pointer objects. These pointers,
    in turn, point to other objects in memory.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of this approach is flexibility. You can put any object in a Python
    list without worrying about type errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the downside is also evident:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8bd8a6e6c917ad70888efa730be2c265.png)'
  prefs: []
  type: TYPE_IMG
- en: Python lists contain a series of pointer objects. Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: The objects pointed to by each pointer are scattered in memory. When you traverse
    a Python list, you need to look up the memory location of each object based on
    the pointer, resulting in lower performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'NumPy Arrays: A Contiguous Memory Layout for Enhanced Performance'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, let’s explore the components and arrangement of NumPy arrays, and how
    it benefits [cache locality](https://en.wikipedia.org/wiki/Locality_of_reference)
    and [vectorization](https://en.wikipedia.org/wiki/Array_programming).
  prefs: []
  type: TYPE_NORMAL
- en: 'NumPy arrays: structure and memory layout'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'According to NumPy’s internal description, NumPy arrays consist of two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: One part stores the metadata of the NumPy array, which describes the data type,
    array shape, etc.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The other part is the data buffer, which stores the values of array elements
    in a tightly packed arrangement in memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../Images/293e30473af49ed86ee6557e21a73bcd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'NumPy arrays: structure and memory layout. Image by Author'
  prefs: []
  type: TYPE_NORMAL
- en: Memory layout of NumPy arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we observe the `.flags` attribute of a ndarray, we find that it includes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`C_CONTIGUOUS`, which indicates whether the data can be read using row-major
    order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`F_CONTIGUOUS`, which indicates whether the data can be read using column-major
    order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Row-major order is the data arrangement used by the C language, denoted by `order=’C’`.
    It means that data is stored row by row.
  prefs: []
  type: TYPE_NORMAL
- en: Column-major order, on the other hand, is used by FORTRAN, denoted by `order=’F’`,
    and stores data column by column.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/61c02ad2bfe42cab37edc845fcb12a13.png)'
  prefs: []
  type: TYPE_IMG
- en: Memory layout of NumPy arrays. Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of NumPy’s memory layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since `ndarray` is designed for matrix operations, all its data types are identical,
    with the same byte size and interpretation.
  prefs: []
  type: TYPE_NORMAL
- en: This allows data to be tightly packed together, bringing advantages in cache
    locality and vectorized computation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cache Locality: How NumPy’s Memory Layout Improves Cache Utilization'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is CPU cache
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NumPy’s contiguous memory layout helps improve cache hit rates because it matches
    how CPU caches work. To better explain this, let’s first understand the basic
    concept of [CPU cache](https://en.wikipedia.org/wiki/CPU_cache).
  prefs: []
  type: TYPE_NORMAL
- en: A CPU cache is a small, high-speed storage area between the CPU and main memory
    (RAM). The purpose of the CPU cache is to speed up data access in memory.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/65ec790c90e1f80582d8effeafe103ca.png)'
  prefs: []
  type: TYPE_IMG
- en: A CPU cache is a small, high-speed storage area between the CPU and main memory
    (RAM). Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: When the CPU needs to read or write data, it first checks if it is already in
    the cache.
  prefs: []
  type: TYPE_NORMAL
- en: The CPU can read directly from the cache if the required data is in the cache
    (cache hit). If the data is not present (cache miss), the CPU loads the data from
    RAM and stores it in the cache for future use.
  prefs: []
  type: TYPE_NORMAL
- en: CPU caches are usually organized in [cache lines](https://open-cas.github.io/cache_line.html),
    which are contiguous memory addresses. When the CPU accesses RAM, the cache loads
    the entire cache line into the high-speed cache.
  prefs: []
  type: TYPE_NORMAL
- en: This means that if the CPU accesses neighboring memory addresses, subsequent
    accesses are more likely to hit the cache after loading a cache line, thus improving
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8a46ad394890e167696d1acb56acde03.png)'
  prefs: []
  type: TYPE_IMG
- en: When the CPU accesses RAM, the cache loads the entire cache line into the high-speed
    cache. Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: How NumPy utilizes cache
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NumPy’s contiguous memory layout takes advantage of this fact.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy arrays store data in continuous memory addresses, which helps improve
    cache locality.
  prefs: []
  type: TYPE_NORMAL
- en: When accessing an element in the array, the entire cache line (containing neighboring
    array elements) is loaded into the cache.
  prefs: []
  type: TYPE_NORMAL
- en: As you traverse the array, you access each element in a sequence. Because array
    elements are stored contiguously in memory, cache hits are more likely during
    the traversal, improving performance.
  prefs: []
  type: TYPE_NORMAL
- en: This is similar to going to the library to read a book. Instead of just grabbing
    the book you need, you also take out related books and place them on the table.
  prefs: []
  type: TYPE_NORMAL
- en: This way, when you need to consult associated materials, they’re easily accessible
    and more efficient than searching the shelves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Vectorization: Unleashing the Power of NumPy’s Memory Layout'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is vectorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vectorization is a technique that leverages the [Single Instruction Multiple
    Data (SIMD)](https://en.wikipedia.org/wiki/Single_instruction,_multiple_data)
    features of CPUs or GPUs to perform multiple data operations simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Vectorized operations can significantly improve code execution efficiency by
    simultaneously processing multiple data items.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy’s contiguous memory layout facilitates vectorized operations.
  prefs: []
  type: TYPE_NORMAL
- en: Why is vectorization suitable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consider yourself a delivery person who must deliver packages to various households
    daily.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose the packages are arranged sequentially in the vehicle, and the houses
    are numbered along the street. In that case, the delivery person can efficiently
    deliver packages along the street in order.
  prefs: []
  type: TYPE_NORMAL
- en: 'This efficient method is analogous to NumPy’s memory layout, which brings the
    following benefits in vectorization:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data alignment**: NumPy arrays’ contiguous memory layout ensures that data
    is aligned in memory in a vectorization-friendly manner. This allows the CPU to
    efficiently load and process data in NumPy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sequential access pattern**: NumPy’s tightly packed data in memory helps
    improve vectorization performance. The sequential access pattern also takes full
    advantage of CPU cache and prefetching, reducing memory access latency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplified code**: NumPy offers a range of functions (e.g., `np.add`, `np.multiply`)
    and operations (e.g., array slicing) that automatically handle vectorized operations.
    You can write concise and efficient code without worrying about the underlying
    implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Copies and Views: NumPy’s Excellent Design for Performance Optimization'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the earlier discussion, we discussed how NumPy leverages its contiguous memory
    layout to achieve performance advantages.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s discuss how NumPy gains performance benefits through copies and views.
  prefs: []
  type: TYPE_NORMAL
- en: What are copies and views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Copies and views are two options that define the relationship between existing
    data and the original array. Based on the characteristics of these two options,
    they can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Copy**: Uses a different memory space than the original array, but the data
    content is the same.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View**: References the same memory address as the original array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/0631a2f1f1b65b13f83aa786a8ccc0e9.png)'
  prefs: []
  type: TYPE_IMG
- en: A copy may have multiple views. Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: If we compare this to a book, a view is like a bookmark placed in the book,
    without creating a copy of the book.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, a copy is a duplicate of the original book, containing a
    complete replica, including text and images. When you add notes to this copy,
    the original book remains unaffected.
  prefs: []
  type: TYPE_NORMAL
- en: Making good use of both features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Utilizing the characteristics of views and copies can help us write concise
    and efficient code.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take arithmetic operations as an example. A new copy will be created if
    you use `a = a + 1`. However, if you use `a += 1` or `np.add`, broadcasting is
    applied, and the addition is performed directly on the original array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code, which measures the execution time:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing the above code will yield a result similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/27788bf9a18866baa8dc92921a9bda1f.png)'
  prefs: []
  type: TYPE_IMG
- en: Using views for calculations takes less time. Screenshot by Author
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from the results, using views for calculations takes less time.
  prefs: []
  type: TYPE_NORMAL
- en: Distinguishing between copies and views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Confirming whether the result is a view or a copy every time a calculation is
    performed would require much effort.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there’s a more straightforward way to verify this:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `may_share_memory` to determine if the two arrays in the argument refer
    to the same memory space. This judgment may not be strict. True doesn’t necessarily
    mean the arrays are shared, but False confirms that the arrays are definitely
    not shared.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need a more accurate answer, you can use the `share_memory` function.
    However, this function takes longer to execute than `may_share_memory`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In summary, we have learned about the differences in memory arrangement between
    NumPy arrays and native Python lists.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the contiguous arrangement of the same data type in NumPy’s array, significant
    performance advantages are achieved in both Cache Locality and Vectorization.
  prefs: []
  type: TYPE_NORMAL
- en: Separating views and copies in NumPy’s design provides greater flexibility for
    code execution performance and memory management.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming series of articles, I will start from the basics and reiterate
    the best practices for data science at work. If you have any suggestions or questions,
    please feel free to comment, and I will address them individually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides improving code execution speed and performance, using various tools
    to improve work efficiency is also a performance enhancement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Peng Qian](../Images/fa6bd24b4781f623be8ea40c4e6bdb78.png)'
  prefs: []
  type: TYPE_IMG
- en: '[Peng Qian](https://qtalen.medium.com/?source=post_page-----a74ce774bc1e--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: Python Toolbox
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[View list](https://qtalen.medium.com/list/python-toolbox-4289824c6407?source=post_page-----a74ce774bc1e--------------------------------)6
    stories![Seaborn 0.12: An Insightful Guide to the Objects Interface and Declarative
    Graphics](../Images/6c1f4ca8d7b82c288cb229b73f560c04.png)![Supercharge Your Python
    Asyncio With Aiomultiprocess: A Comprehensive Guide](../Images/9c366de04067cd0ec1b30d9ce223011b.png)![Conquer
    Retries in Python Using Tenacity: An In-depth Tutorial](../Images/e636d5546f5826d60865c6a95f976fa8.png)[](https://medium.com/@qtalen/membership?source=post_page-----a74ce774bc1e--------------------------------)
    [## Join Medium with my referral link - Peng Qian'
  prefs: []
  type: TYPE_NORMAL
- en: As a Medium member, a portion of your membership fee goes to writers you read,
    and you get full access to every story…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/@qtalen/membership?source=post_page-----a74ce774bc1e--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 'This article was originally published at: [https://www.dataleadsfuture.com/python-lists-vs-numpy-arrays-a-deep-dive-into-memory-layout-and-performance-benefits/](https://www.dataleadsfuture.com/python-lists-vs-numpy-arrays-a-deep-dive-into-memory-layout-and-performance-benefits/)'
  prefs: []
  type: TYPE_NORMAL
