- en: Data Scientist Interview Guide
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/data-scientist-technical-interview-guide-part-1-84e286fd4bae](https://towardsdatascience.com/data-scientist-technical-interview-guide-part-1-84e286fd4bae)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Part 1: Statistics and probability'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@dannyf16?source=post_page-----84e286fd4bae--------------------------------)[![Daniel
    Foley](../Images/b2a9e060f181784ffc9b1c00a7b071f7.png)](https://medium.com/@dannyf16?source=post_page-----84e286fd4bae--------------------------------)[](https://towardsdatascience.com/?source=post_page-----84e286fd4bae--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----84e286fd4bae--------------------------------)
    [Daniel Foley](https://medium.com/@dannyf16?source=post_page-----84e286fd4bae--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----84e286fd4bae--------------------------------)
    ·18 min read·Feb 9, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8ae427526ba605580176c95c7f878677.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Maranda Vandergriff](https://unsplash.com/@mkvandergriff?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
    on [Unsplash](https://unsplash.com/s/photos/interview?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many data science interview blog posts out there, but since I recently
    started interviewing again I thought it would be good for me to share both my
    previous and current experience going through this process and hopefully be able
    to provide some guidance to any of you out there who are on this journey as well.
    There is no doubt that going through data science interviews is tough. Part of
    the challenge is the sheer breadth of topics that you can be quizzed on. You almost
    need to be a software engineer a data analyst and a product manager all rolled
    up into one.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that once you remind yourself of the basics, you tend to get
    asked the same type of questions over and over again. In part 1 of this technical
    interview guide, I wanted to provide problems and in-depth solutions to some probability
    and statistics questions you will likely be quizzed on in technical interviews.
    So without further ado, let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: Statistics and Probability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Statistics and probability are a must for any data scientist and reviewing the
    basic concepts will be key to doing well in technical interviews. There are a
    number of topics that come up quite regularly, particularly the ones listed below.
  prefs: []
  type: TYPE_NORMAL
- en: '**Probability**: Expected Value, Combinations and Permutations, Recurrence
    Relations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Statistics:** p-values, hypothesis testing, power, confidence intervals,
    probability vs likelihood, central limit theorem, the law of large numbers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distributions:** Uniform, Binomial and Normal distributions are the most
    important'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In my opinion, the tougher interviews will focus on solving problems involving
    one or more of these concepts which is the primary focus of this post. However,
    it is also extremely important to be able to explain these concepts in a non-technical
    way so I will cover a select few topics I think are useful to know. My hope is
    that walking through my thought process while solving these problems will provide
    a useful guide for those of you preparing for these technical interviews.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a [reference book](http://stat88.org/textbook/content/intro.html) I
    found useful for reminding myself of the basic concepts.
  prefs: []
  type: TYPE_NORMAL
- en: '***Central Limit Theorem***'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose I wanted to measure people’s incomes. If we took a sample of incomes
    and plotted those data points, we would likely see a skewed distribution where
    a few people have very large incomes while most others have incomes that are smaller
    and much closer together. Let’s say we compute an average based on this sample.
    If we continued to sample incomes and compute the average and plot the data, we
    would have the sampling distribution of the sample means (visualised below). This
    distribution would look like a Normal distribution due to the **Central Limit
    Theorem.** Crucially, the underlying population distribution does not have to
    be normal. The figures below illustrate this.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f2c6c5f8592e7252450fe4bfdab46068.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Source: Exponential Distribution by Author'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/657e85547ce263ea86a1cf107f6b38e1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Source: Normal Distribution by Author'
  prefs: []
  type: TYPE_NORMAL
- en: This is important because it allows us to make statistical inferences based
    on single samples. For example, in hypothesis testing and regression, we can use
    the CLT theorem to say something about the behaviour of our test statistic/coefficients.
    Because we know it is normally distributed we can calculate confidence intervals
    and p-values and make reliable inferences.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Law of Large Numbers***'
  prefs: []
  type: TYPE_NORMAL
- en: The LLN states that as the sample size increases, the sample mean converges
    to the population mean. It is helpful to picture the population and sample as
    two sets where the sample is a subset of the population set. As the sample size
    increases, the size of the sample set gets bigger and bigger and eventually will
    be the same size as the population. This is why the sample mean converges to the
    population mean.
  prefs: []
  type: TYPE_NORMAL
- en: The key difference between the LLN and the CLT is that the LLN says something
    about the sample mean while the CLT is related to the distribution of the sample
    mean.
  prefs: []
  type: TYPE_NORMAL
- en: '***Binomial Distribution***'
  prefs: []
  type: TYPE_NORMAL
- en: The binomial distribution is an extremely important distribution and comes up
    frequently in interviews. Deriving the distribution from first principles in an
    intuitive high-level way is a great approach to show your understanding of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we have 10 users on our website and we want to predict how many of
    them will buy something. We can view this as repeated independent trials where
    each user either buys or doesn’t buy. Call p the probability of buying something
    and 1-p not buying since probabilities need to sum to 1\. Consider the case where
    nobody buys: (1-p)*(1-p)*… = (1-p)¹⁰.'
  prefs: []
  type: TYPE_NORMAL
- en: What if one person buys? We have p¹(1-p)⁹. i.e. 1 success and 9 failures. We
    do not know which user makes the purchase though. It could be user 1, user 2,
    … or user 10\. To account for this we have 10 possibilities and we want to choose
    1\. Putting this all together gives us the general binomial formula below.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/fbe500e96e2da74a09de593a9693d61e.png)'
  prefs: []
  type: TYPE_IMG
- en: Binomial Formula
  prefs: []
  type: TYPE_NORMAL
- en: '***p-values***'
  prefs: []
  type: TYPE_NORMAL
- en: p-values are quite a contentious topic and in my opinion not very intuitive
    even to data scientists let alone non-technical folks. But let me try and explain
    it with an example of how they are used.
  prefs: []
  type: TYPE_NORMAL
- en: We use p-values to determine if a hypothesis test is significant or not. Normally
    we pick a p-value of 0.05 or 5%. If for example we carried out a hypothesis test
    and we obtained a p-value of 0.03 then this means that ***Assuming the null is
    true, the chance of us observing a test statistic as or more extreme than this
    is 3%***. In other words, it is very unlikely that we would observe this effect
    if the null was true therefore it is likely false. We can also think about a p-value
    like this. If we ran our experiment 100 times then we would expect to observe
    a test statistic at least as large as this 5 times. Finally, another way to view
    a p-value is that it is a conditional probability. In this scenario, it is the
    probability of observing as or more extreme test statistic **GIVEN** the null
    is true.
  prefs: []
  type: TYPE_NORMAL
- en: In the problems that follow, I will show how we can use some of these topics
    in practice to solve problem-set style questions in technical interviews.
  prefs: []
  type: TYPE_NORMAL
- en: Solving Problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following problems have been sourced either from previous interview questions
    that I have been asked in the past or from various books and internet sources
    (e.g. glassdoor) that I came across while preparing for interviews. They are chosen
    on the basis of reflecting the most important and common concepts required for
    technical interviews. I have also highlighted some of the key concepts I think
    are important to recognise for each question.
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem 1**'
  prefs: []
  type: TYPE_NORMAL
- en: '***You and a friend take turns rolling a fair six-sided die, and the first
    person to roll 6 wins. What is the probability that the person who makes the first
    roll wins the game?***'
  prefs: []
  type: TYPE_NORMAL
- en: '***Key Concepts: recurrence relation, probability tree, independence, uniform
    distribution***'
  prefs: []
  type: TYPE_NORMAL
- en: If we think about the problem statement a little bit before we start, intuitively
    it seems like going first would give us an advantage, so we expect this probability
    to be larger than 1/2 anyway. What else do we know about rolling a die? Well,
    we know that the outcomes of rolling a die have a uniform distribution. Each outcome
    is equally likely and the probability of getting a specific number is 1/6.
  prefs: []
  type: TYPE_NORMAL
- en: For these kinds of questions, I like to draw a probability tree. For me, at
    least, this simplifies the problem and gives me a general approach I can use to
    tackle problems that are not immediately obvious. So let’s do this from our point
    of view. There are two possible scenarios
  prefs: []
  type: TYPE_NORMAL
- en: 'We win: define the probability of winning as x'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We lose: with probability 1-x'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the first roll, we, therefore, have the following,
  prefs: []
  type: TYPE_NORMAL
- en: either we roll a 6 with probability 1/6 and then we win with probability 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OR** we roll some other number with probability 5/6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second scenario is interesting as it is now our friend’s roll. In order
    for us to win, we need them to **not** roll a 6 which again happens with probability
    5/6\. ***Notice, when this happens we effectively start the game again***. i.e.
    it is our roll again and our probability of winning is x.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s make this a bit more concrete with an equation. To get our probability
    we just need to solve the equation for x.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d44f319eb4a2fc78eb5a9d05238489c7.png)'
  prefs: []
  type: TYPE_IMG
- en: Therefore our probability of winning if we go first is 6/11 and the probability
    of losing our equivalently of our friend winning if they go second is 5/11 (1–6/11).
    See below for the tree diagram.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/484459b46190f553c75f62c284c923ed.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Problem 2**'
  prefs: []
  type: TYPE_NORMAL
- en: '***You start at the bottom of an 8*6 grid. You can only move up or right. What
    is the probability that you will pass through the centre?***'
  prefs: []
  type: TYPE_NORMAL
- en: '***Key Concepts: combinations (order does not matter), product rule of counting***'
  prefs: []
  type: TYPE_NORMAL
- en: For these kinds of problems, It often helps to define the probability as a frequency,
    i.e. (number of relevant events) / (number of total events). Doing so can help
    us to break down the problem and try and solve for the numerator and denominator.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first try to find the denominator which is the total number of possible
    events. In this case, the total number of ways we can move from the starting point
    (0, 0) to the endpoint (8,6). How many moves do we need to make to reach this
    point? We need to make 8 up and 6 right or 14 in total. If we define an up move
    as U and a right move as R, one way we could move is
  prefs: []
  type: TYPE_NORMAL
- en: UUUUUUUURRRRRR, i.e. 8 up moves followed by 6 right moves
  prefs: []
  type: TYPE_NORMAL
- en: This would get us to our destination. However, we could also have done this.
  prefs: []
  type: TYPE_NORMAL
- en: RRRRRRUUUUUUUU, i.e. 6 right moves followed by 8 up moves.
  prefs: []
  type: TYPE_NORMAL
- en: We can continue to enumerate all of the possibilities but there is probably
    an easier way. In total, we have 14! ways to move from (0, 0) to (8,6), (14 ways
    to make the first move, then 13 ways for the second, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: However, this results in overcounting because we can re-arrange the initial
    6 R’s in the sequence and it doesn’t change, i.e. the ***order does not matter***.
    Therefore we must divide the total by the number of ways to arrange these 6 R’s,
    i.e. 6!. Similarly, we also divide by the number of ways to arrange 8 U’s (8!).
    This gives us
  prefs: []
  type: TYPE_NORMAL
- en: 14! / (8!6!) = 3003.
  prefs: []
  type: TYPE_NORMAL
- en: Some of you may recognize this as the formula for a combination. And you are
    right. Because the order does not matter, this is the same thing as 14 choose
    8\. Ok, so we know the value of our denominator, but what about the numerator?
    Remember, we need to find the total ways of arriving at point (8, 6) by going
    through the centre of the grid, i.e. point (4,3). The easiest way to solve this
    is to break down the journey into two.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to find the number of ways to move from (0, 0) to (4, 3) and
    then find the number of ways from (4, 3) to (8, 6). We then just multiply these
    values together to get our total for the numerator.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the same thought process as for the denominator here. We must make
    a total of 4 moves right and 3 moves up or 4+3 = 7 moves total. A possible path
    is the following: RRRRUUU. Again, there are 7! ways to arrange the letters and
    we need to divide by the number of ways to arrange the 4 R’s (4!) and the number
    of ways to arrange the 3 U’s (3!).'
  prefs: []
  type: TYPE_NORMAL
- en: '(0, 0) -> (4, 3): 7!/(4!3!) = 35'
  prefs: []
  type: TYPE_NORMAL
- en: We again apply the same principle for the number of ways to get from (4, 3)
    to (8, 6). This is the exact same as the first part, i.e. 7 total moves 4 R and
    3 U.
  prefs: []
  type: TYPE_NORMAL
- en: '(4, 3) -> (8, 6): 7!/(4!3!) = 35'
  prefs: []
  type: TYPE_NORMAL
- en: Our answer is, therefore, ***(35*35) / 3003 = 1225 / 3003 = 175 / 429.***
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem 3**'
  prefs: []
  type: TYPE_NORMAL
- en: '***A discount coupon is given to 2 riders. The probability of using a coupon
    is P. Given that at least one of them uses a coupon, what is the probability that
    both riders use the coupons?***'
  prefs: []
  type: TYPE_NORMAL
- en: '***Key Concepts: Bayes Theorem, Binomial distribution, Independence***'
  prefs: []
  type: TYPE_NORMAL
- en: There is more than one way to solve this problem and I will discuss both here.
    The first approach is using Bayes Theorem and we can usually recognise these types
    of problems as there will be some conditional statement. In this case, **given**
    that at least one of the riders uses a coupon, what is the probability, both use
    the coupons? We can define these events as follows
  prefs: []
  type: TYPE_NORMAL
- en: '***at least one of the riders uses a coupon (A)***'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***both riders use a coupon (B).***'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to find the probability of B given A and we can use Bayes theorem below
    to calculate this.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8caf8c8f8b5000df99dfc234fd35c9cd.png)'
  prefs: []
  type: TYPE_IMG
- en: Bayes Theorem
  prefs: []
  type: TYPE_NORMAL
- en: All that remains is to calculate each component and plug them into the equation.
    Let’s start with P(A|B) or the probability that at least one rider uses a coupon
    given both use the coupon. This is clearly 1 since if both use the coupon at least
    one of them has to use it. What is P(B)? We know that the probability of using
    a coupon is P and assuming each rider is independent we can say the probability
    of both using a coupon is P*P=P² (Multiplication rule).
  prefs: []
  type: TYPE_NORMAL
- en: P(B) = probability rider 1 uses coupon **AND** probability rider 2 uses coupon
    = P*P= P²
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating the probability of A (P(A)) is a bit more tricky. The probability
    that at least 1 of the riders uses a coupon is the probability that 1 of the riders
    uses the coupon **OR** 2 of the riders use the coupon. Since each rider uses the
    coupon or doesn’t with the same probability we can describe this using a binomial
    distribution.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e95b8f34be57abe53f14bdb14058df21.png)'
  prefs: []
  type: TYPE_IMG
- en: Binomial Distribution
  prefs: []
  type: TYPE_NORMAL
- en: To get the total probability we just add these together (Addition Rule). Plugging
    these values into our formula gives us the answer below.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4f2a0248fb3f742a17bda3377e1f6e6e.png)'
  prefs: []
  type: TYPE_IMG
- en: P(A)
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/24a8cb0601d83f01114b5f1e08ccf3d4.png)'
  prefs: []
  type: TYPE_IMG
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: '**Alternate Solution**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned above, there is also a much simpler solution. We can list out
    all of the possibilities. If we let X be the rider uses the coupon and Y be the
    rider does not use the coupon we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '***XX: both riders use the coupon***'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***XY: rider 1 uses the coupon and rider 2 does not use the coupon***'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***YX: rider 1 does not use the coupon and rider 2 does use the coupon***'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***YY: both riders do not use the coupon***'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now if we condition on at least one rider using the coupon we are left with
    the first 3 possibilities. Now the probability is just the event we want, divided
    by the total number of possible events.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/36d40592c99304d7686f949767dc51cb.png)'
  prefs: []
  type: TYPE_IMG
- en: Substituting in P as the probability of a rider using the coupon we get the
    same results as the first solution
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/93f427c9b5e14ae65d47e4463b111466.png)'
  prefs: []
  type: TYPE_IMG
- en: Alternate Solution
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem 4**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Imagine you* *observed 3 sequences of 5 flips. At least one sequence was
    all heads. Is the coin biased?***'
  prefs: []
  type: TYPE_NORMAL
- en: '***Key Concepts: hypothesis testing, binomial distribution, independence***'
  prefs: []
  type: TYPE_NORMAL
- en: This second question is an interesting one I got in an interview and can be
    a little tricky. The easiest way to solve this, in my opinion, is to try and break
    down the problem into several steps. First, we define what it means for a coin
    to be biased. Well, a coin is biased if the probability of getting heads is not
    1/2\. Next, we need to consider how we can test this. In order for us to assess
    whether the coin is biased or not we basically need to do a hypothesis test.
  prefs: []
  type: TYPE_NORMAL
- en: To formulate our hypothesis test we first assume that the coin is fair, i.e.
    our null is that p = 0.5 (i.e. probability of flipping heads) and our alternate
    is that p ≠ 0.5\. We then calculate the probability of observing this sequence
    of events under this assumption. If the probability is very low (below a certain
    threshold, p < 0.05) we reject our hypothesis and conclude the coin is biased.
    How do we calculate the probability of observing this sequence of events?
  prefs: []
  type: TYPE_NORMAL
- en: '***Remember, the probability of getting at least one sequence of all heads
    is the same as 1 minus the probability of getting 0 sequences of all heads. Alternatively,
    we could calculate the probability of getting exactly 1 sequence of all heads
    + 2 sequences of all heads + 3 sequences of all heads.***'
  prefs: []
  type: TYPE_NORMAL
- en: To find this probability, we need to calculate the following
  prefs: []
  type: TYPE_NORMAL
- en: '***probability of getting 5 heads in 5 flips: i.e. HHHHH***'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***probability of getting exactly 0 out of 3 sequences of all heads.***'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***We need to take this away from 1 to get at least 1 sequence of all heads.***'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are two parts to this problem consisting of two binomial distributions.
    The first one is getting 5 heads in 5 flips. We can then use this probability
    as an input into our second binomial distribution, 3 sequences of 5 flips where
    p is the answer to the first part.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the first sequence with 5 flips. What are we trying to calculate? We
    want to know the probability of getting 5 heads in 5 flips. If we define the probability
    of success as getting a head, we have
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/94745b70c55f308a759b7df32b1c9c0d.png)'
  prefs: []
  type: TYPE_IMG
- en: Ok, so now we know the probability of 5 heads in 5 flips. For the second part,
    we can apply the binomial formula again here because each sequence has the same
    probability and all are independent. We have 3 trials and we want to get 0 of
    them having HHHHH.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have n = 3, k = 0, p = 0.03124 and 1-p = 0.96875
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8ae75561b66b1bd29278d1d8daf9bb66.png)'
  prefs: []
  type: TYPE_IMG
- en: Remember, this is the probability of seeing all sequences of 0 heads so to get
    at least one all heads **1–0.909 = 0.09**
  prefs: []
  type: TYPE_NORMAL
- en: This is essentially our p-value for the hypothesis test. The value is not below
    our threshold of 0.05 and therefore we do not have enough evidence to reject the
    hypothesis that the coin Is fair. This should also make intuitive sense as you
    would generally need a lot more flips of a coin to determine whether or not it
    is biased.
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem 5**'
  prefs: []
  type: TYPE_NORMAL
- en: '***You draw from a normally distributed random variable X — N(0,1) once a day.
    What is the approximate expected number of days until you get a value greater
    than 2?***'
  prefs: []
  type: TYPE_NORMAL
- en: '***Key Concepts: expected value, Normal Distribution, Empirical Rule, Geometric
    Distribution***'
  prefs: []
  type: TYPE_NORMAL
- en: To solve this problem, we need to recognise that we are trying to calculate
    the expected time until some event happens. We could also frame this as ***the
    number of trials until our first success which you may recognise as a geometric
    distribution***. In other words, we need to find the expected value of a geometric
    distribution. The mean of a geometric is 1/p. This problem is the exact same as
    a problem such as how many times we expect to roll a die before we see a 4\. The
    answer is 1/(1/6) = 6 rolls.
  prefs: []
  type: TYPE_NORMAL
- en: The trick to this problem is finding the correct value of p. We know that our
    distribution is Normal with mean = 0 and standard deviation of 1\. How likely
    are we to get a value of 2 if we sample from this distribution?
  prefs: []
  type: TYPE_NORMAL
- en: Well, 2 is 2 standard deviations from the mean. We know from the empirical rule
    that the area of the curve > 2 standard deviations is around 0.025\. Therefore
    the probability we observe a value > 2 is 0.025 on any given day. This is our
    value of p.
  prefs: []
  type: TYPE_NORMAL
- en: Now, all we need to do is calculate 1/0.025 = 40\. In other words, we expect
    to wait 40 days until we see a 2.
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem 6**'
  prefs: []
  type: TYPE_NORMAL
- en: '***You flip 100 fair coins. If 60 or more land on heads, you win $10, you win
    nothing on all other outcomes. Should you play this game for $1?***'
  prefs: []
  type: TYPE_NORMAL
- en: '***Key Concepts: expected value, binomial distribution, central limit theorem,
    empirical rule***'
  prefs: []
  type: TYPE_NORMAL
- en: You should recognise this question as an expected value question. We want to
    know if the expected benefit we get from playing the game is greater than the
    expected cost of playing the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define the expected value of the game as follows: i.e. it costs us $1
    to play and if we get 60 or more heads we win $10 and win $0 if we get less than
    60 heads.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/873b21ea7c5c8ea7c1d8db0ad6d0b64a.png)'
  prefs: []
  type: TYPE_IMG
- en: Ok, so this question, boils down to finding the P(X≥60). With a little bit of
    thinking we can recognise that getting 60 or more heads in 100 flips should be
    binomially distributed with N = 100 and p = 0.5 (assuming a fair coin). Now, all
    we need to do is find the probability of getting 60 or more coin flips using the
    binomial distribution. The long way to do this would be to individually calculate
    the probability of getting 60 + 61 + 62 + … + 100\. This seems a bit inefficient
    so is there anything else we can do which will make this calculation easier?
  prefs: []
  type: TYPE_NORMAL
- en: Notice that our sample size is 100 coin flips. Hopefully, you will recognise
    that the Central Limit Theorem (CLT) can help us out here since N > 30\. I will
    admit that this is not the most obvious insight in the world to have but the more
    you practice these kinds of questions, the easier it will be to spot situations
    like this. Why is the CLT helpful here? Well, we know that if we apply the CLT
    then the sampling distribution will approximately be normal. Because this is a
    well-behaved distribution we only need to know the mean and standard deviation
    to define the entire distribution. If we know the distribution then we can easily
    compute the probability we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is compute the mean and standard deviation of
    the coin flips. Since they follow a [binomial](https://online.stat.psu.edu/stat414/lesson/28/28.1),
    we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/43a3f66b7941c65ababedc80c2b99bb5.png)'
  prefs: []
  type: TYPE_IMG
- en: We, therefore, have a mean of 50 and a standard deviation of 5\. What else do
    we know about the Normal distribution? If you recall the empirical rule states
    that approximately 95% of the distribution is within 2 standard deviations of
    the mean we can use this to calculate the probability we need. 60 is 2 standard
    deviations away from the mean and we know that approximately 2.5% of the distribution
    lies above this point.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the P(X≥60) is ~ 0.025\. Now we can just directly plug this into
    the expected value equation above.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/cd65cc38c7423678f83085a6b5733185.png)'
  prefs: []
  type: TYPE_IMG
- en: The expected value of this game is negative and therefore we should not play
    it. I really like this question as it requires applying several aspects of probability
    and statistics to be able to solve it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem 7**'
  prefs: []
  type: TYPE_NORMAL
- en: '***In unprofitable times corporations sometimes suspend dividend payments.
    Suppose that after a dividend has been paid the next one will be paid with probability
    0.9 while after a dividend is suspended the next one will be suspended with probability
    0.6\. In the long run, what is the fraction of dividends that will be paid?***'
  prefs: []
  type: TYPE_NORMAL
- en: '***Key Concepts: Markov Chains, stationary distribution***'
  prefs: []
  type: TYPE_NORMAL
- en: This problem can be formulated as a Markov chain with 2 states
  prefs: []
  type: TYPE_NORMAL
- en: dividend paid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: dividend suspended
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why can it be represented as a Markov chain? Because the problem has the Markov
    property (memoryless). The probability of going into any state at time t+1 only
    depends on the state you are in at time t. i.e. are we in the dividend-paid state
    or the dividend-suspended state? States at time t-1, t-2 etc do not impact our
    probability of the next state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The question gives us the probability of moving between these 2 states. If
    we are in paid dividend state, we will stay in this state with probability 0.9
    and therefore move into the suspended state with probability 0.1\. If we are in
    the dividend-suspended state we will remain in this state with probability 0.6
    and move into the other state with probability 0.4\. We can represent this as
    the following transition matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e5f366d1680d2fa97a151f8fc7015a81.png)'
  prefs: []
  type: TYPE_IMG
- en: Transition Matrix
  prefs: []
  type: TYPE_NORMAL
- en: gWhat the question is asking us to solve is the stationary distribution of the
    Markov chain. i.e. the long-run equilibrium. At this point, the probability distribution
    does not change as time progresses. i.e. if I take my current state and multiply
    by the transition matrix, I get the same value back. This situation is described
    in the following equations
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2e51287c0fe3a45011e9c2cb72ffd260.png)'
  prefs: []
  type: TYPE_IMG
- en: Stationary Distribution
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/77bbc3147be4793c923655b5adda7a49.png)'
  prefs: []
  type: TYPE_IMG
- en: Stationary Distribution
  prefs: []
  type: TYPE_NORMAL
- en: All we want to do here is solve these sets of equations for pi1 and pi2\. Where
    pi1+pi2 = 1 since the probabilities must sum to 1.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c3739c5452651228cbe463a0668ecc39.png)'
  prefs: []
  type: TYPE_IMG
- en: equations
  prefs: []
  type: TYPE_NORMAL
- en: If we solve this system of equations we get the following
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/068b79ffd5cd92777a48a586dfb0da28.png)'
  prefs: []
  type: TYPE_IMG
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: Therefore the dividends will be paid ***around 85% of dividends will be paid
    in the long run.***
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Below are some additional references I think will be useful to both aid in your
    preparation and dive deeper into topics that I haven’t covered here.
  prefs: []
  type: TYPE_NORMAL
- en: '**References**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[1] [Introduction to Probability by Joseph K. Blitzstein and Jessica Hwang](https://drive.google.com/file/d/1VmkAAGOYCTORq1wxSQqy255qLJjTNvBI/view)'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] [Zenefits Glassdoor Interview Question](https://www.glassdoor.com/Interview/Alice-and-Bob-take-turns-in-rolling-a-fair-dice-Whoever-gets-6-first-wins-the-game-Alice-starts-the-game-What-are-the-QTN_1831416.htm)'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] [https://www.stat.berkeley.edu/~aldous/150/takis_exercises.pdf](https://www.stat.berkeley.edu/~aldous/150/takis_exercises.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[3] [Lyft Glassdoor Interview Question](https://www.glassdoor.com/Interview/1-Lyft-wants-to-launch-ride-share-program-What-are-the-most-important-KPIs-would-you-track-2-Lyft-is-trying-to-optimiz-QTN_4697390.htm)'
  prefs: []
  type: TYPE_NORMAL
- en: '[4] [Recursive Methods](https://www.probabilitycourse.com/chapter14/Chapter_14.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[5] [Central Limit Theorem](http://stat88.org/textbook/content/Chapter_08/00_Central_Limit_Theorem.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[6] [Binomial Distribution](http://stat88.org/textbook/content/Chapter_03/03_The_Binomial_Distribution.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Some of my other posts you may find interesting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[](/lets-build-a-streaming-data-pipeline-e873d671fc57?source=post_page-----84e286fd4bae--------------------------------)
    [## Let’s Build a Streaming Data Pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: Apache Beam and DataFlow for real-time data pipelines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/lets-build-a-streaming-data-pipeline-e873d671fc57?source=post_page-----84e286fd4bae--------------------------------)
    [](/building-machine-learning-pipelines-using-snowflake-and-dask-10ae5e7fff0f?source=post_page-----84e286fd4bae--------------------------------)
    [## Building Machine Learning Pipelines using Snowflake and Dask
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/building-machine-learning-pipelines-using-snowflake-and-dask-10ae5e7fff0f?source=post_page-----84e286fd4bae--------------------------------)
    [](/a-bayesian-approach-to-time-series-forecasting-d97dd4168cb7?source=post_page-----84e286fd4bae--------------------------------)
    [## A Bayesian Approach to Time Series Forecasting
  prefs: []
  type: TYPE_NORMAL
- en: Today we are going to implement a Bayesian linear regression in R from scratch
    and use it to forecast US GDP growth…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/a-bayesian-approach-to-time-series-forecasting-d97dd4168cb7?source=post_page-----84e286fd4bae--------------------------------)
  prefs: []
  type: TYPE_NORMAL
