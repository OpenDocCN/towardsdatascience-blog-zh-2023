["```py\npython ≥ 3.8\npytorch ≥ 1.7\ntorchvision ≥ 0.8\n```", "```py\npip install numpy matplotlib laspy opencv-python\n```", "```py\nconda install pytorch torchvision torchaudio pytorch-cuda=11.7 -c pytorch -c nvidia\n```", "```py\npip install git+https://github.com/facebookresearch/segment-anything.git\n```", "```py\n# The Base libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport cv2\nimport laspy\n\n# The Deep Learning libraries\nimport torch\nfrom segment_anything import sam_model_registry\nfrom segment_anything import SamAutomaticMaskGenerator\n```", "```py\nimport torch\nprint('CUDA available -> ', torch.cuda.is_available())\nprint('CUDA GPU number -> ', torch.cuda.device_count())\nprint('GPU -> ', torch.cuda.get_device_name())\n```", "```py\n|     Encoder          |   #parameters    |     Speed      |   Quality    |\n|----------------------|------------------|----------------|--------------|\n|   ViT-B   (basic)    |       91M        |     Fastest    |   Low        |\n|   ViT-L   (large)    |       308M       |     Fast       |   High       |\n|   ViT-H   (huge)     |       636M       |     Slow       |   Highest    |\n```", "```py\nMODEL = \"../../MODELS/sam_vit_h_4b8939.pth\"\n\n#You can run the line below to test if you have the ability to leverage CUDA\ntorch.cuda.is_available()\n\n#Choose between cpu or cuda training. For cpu, input 'cpu' instead 'cuda:0'\nUSED_D = torch.device('cuda:0')\n```", "```py\nsam = sam_model_registry[\"vit_h\"](checkpoint = MODEL)\n\n#Cast your model to a specific device (cuda or cpu)\nsam.to(device = USED_D)\n```", "```py\n#When loading an image with openCV, it is in bgr by default\nloaded_img = cv2.imread(\"../DATA/biscarosse.jpg\")\n\n#Now we get the R,G,B image\nimage_rgb = cv2.cvtColor(loaded_img, cv2.COLOR_BGR2RGB)\n```", "```py\nmask_generator = SamAutomaticMaskGenerator(sam)\nresult = mask_generator.generate(image_rgb)\n```", "```py\ndef sam_masks(anns):\n    if len(anns) == 0:\n        return\n    sorted_anns = sorted(anns, key=(lambda x: x['area']), reverse=True)\n    ax = plt.gca()\n    ax.set_autoscale_on(False)\n    c_mask=[]\n    for ann in sorted_anns:\n        m = ann['segmentation']\n        img = np.ones((m.shape[0], m.shape[1], 3))\n        color_mask = np.random.random((1, 3)).tolist()[0]\n        for i in range(3):\n            img[:,:,i] = color_mask[i]\n        ax.imshow(np.dstack((img, m*0.8)))\n        c_mask.append(img)\n    return c_mask\n```", "```py\nprint('Mem allocated by other programs: ', torch.cuda.memory_allocated(), 'reserved:', torch.cuda.memory_reserved())\nimport os\nos.environ[\"PYTORCH_CUDA_ALLOC_CONF\"] = \"max_split_size_mb:512\"\nimport gc\ngc.collect()\ntorch.cuda.empty_cache()\n\nIf the GPU memory is not freed enough, try rebooting your (Windows) computer.\nALSO, try using the following line if memory problems persist\nmask_generator = SamAutomaticMaskGenerator(sam, points_per_batch=16)\n```", "```py\nfig = plt.figure(figsize=(np.shape(image_rgb)[1]/72, np.shape(image_rgb)[0]/72))\nfig.add_axes([0,0,1,1])\nplt.imshow(image_rgb)\ncolor_mask = sam_masks(result)\nplt.axis('off')\nplt.savefig(\"../test_result.jpg\")\n```", "```py\ndef cloud_to_image(pcd_np, resolution):\n    minx = np.min(pcd_np[:, 0])\n    maxx = np.max(pcd_np[:, 0])\n    miny = np.min(pcd_np[:, 1])\n    maxy = np.max(pcd_np[:, 1])\n    width = int((maxx - minx) / resolution) + 1\n    height = int((maxy - miny) / resolution) + 1\n    image = np.zeros((height, width, 3), dtype=np.uint8)\n    for point in pcd_np:\n        x, y, *_ = point\n        r, g, b = point[-3:]\n        pixel_x = int((x - minx) / resolution)\n        pixel_y = int((maxy - y) / resolution)\n        image[pixel_y, pixel_x] = [r, g, b]\n    return image\n```", "```py\n#Reading the point cloud with laspy\npcd = laspy.read(\"../DATA/34FN2_18.las\")\n\n#Transforming the point cloud to Numpy\npcd_np = np.vstack((pcd.x, pcd.y, pcd.z, (pcd.red/65535*255).astype(int), (pcd.green/65535*255).astype(int), (pcd.blue/65535*255).astype(int))).transpose()\n\n#Ortho-Projection\northoimage = cloud_to_image(pcd_np, 1.5)\n\n#Plotting and exporting\nfig = plt.figure(figsize=(np.shape(orthoimage)[1]/72, np.shape(orthoimage)[0]/72))\nfig.add_axes([0,0,1,1])\nplt.imshow(orthoimage)\nplt.axis('off')\nplt.savefig(\"../DATA/34FN2_18_orthoimage.jpg\")\n```", "```py\ndef generate_spherical_image(center_coordinates, point_cloud, colors, resolution_y=500):\n    # Translate the point cloud by the negation of the center coordinates\n    translated_points = point_cloud - center_coordinates\n\n    # Convert 3D point cloud to spherical coordinates\n    theta = np.arctan2(translated_points[:, 1], translated_points[:, 0])\n    phi = np.arccos(translated_points[:, 2] / np.linalg.norm(translated_points, axis=1))\n\n    # Map spherical coordinates to pixel coordinates\n    x = (theta + np.pi) / (2 * np.pi) * (2 * resolution_y)\n    y = phi / np.pi * resolution_y\n\n     # Create the spherical image with RGB channels\n    resolution_x = 2 * resolution_y\n    image = np.zeros((resolution_y, resolution_x, 3), dtype=np.uint8)\n\n    # Create the mapping between point cloud and image coordinates\n    mapping = np.full((resolution_y, resolution_x), -1, dtype=int)\n\n    # Assign points to the image pixels\n    for i in range(len(translated_points)):\n        ix = np.clip(int(x[i]), 0, resolution_x - 1)\n        iy = np.clip(int(y[i]), 0, resolution_y - 1)\n        if mapping[iy, ix] == -1 or np.linalg.norm(translated_points[i]) < np.linalg.norm(translated_points[mapping[iy, ix]]):\n            mapping[iy, ix] = i\n            image[iy, ix] = colors[i]\n    return image\n```", "```py\n#Loading the las file from the disk\nlas = laspy.read(\"../DATA/ITC_BUILDING.las\")\n\n#Transforming to a numpy array\ncoords = np.vstack((las.x, las.y, las.z))\npoint_cloud = coords.transpose()\n\n#Gathering the colors\nr=(las.red/65535*255).astype(int)\ng=(las.green/65535*255).astype(int)\nb=(las.blue/65535*255).astype(int)\ncolors = np.vstack((r,g,b)).transpose()\n```", "```py\nresolution = 500\n\n#Defining the position in the point cloud to generate a panorama\ncenter_coordinates = [189, 60, 2]\n```", "```py\n#Function Execution\nspherical_image, mapping = generate_spherical_image(center_coordinates, point_cloud, colors, resolution)\n\n#Plotting with matplotlib\nfig = plt.figure(figsize=(np.shape(spherical_image)[1]/72, np.shape(spherical_image)[0]/72))\nfig.add_axes([0,0,1,1])\nplt.imshow(spherical_image)\nplt.axis('off')\n\n#Saving to the disk\nplt.savefig(\"../DATA/ITC_BUILDING_spherical_projection.jpg\")\n```", "```py\nsam = sam_model_registry[\"vit_h\"](checkpoint = MODEL)\nsam.to(device = USED_D)\n\nmask_generator = SamAutomaticMaskGenerator(sam)\n\ntemp_img = cv2.imread(\"../DATA/ITC_BUILDING_spherical_projection.jpg\")\nimage_rgb = cv2.cvtColor(temp_img, cv2.COLOR_BGR2RGB)\n\nt0 = time.time()\nresult = mask_generator.generate(image_rgb)\nt1 = time.time()\n```", "```py\nfig = plt.figure(figsize=(np.shape(image_rgb)[1]/72, np.shape(image_rgb)[0]/72))\nfig.add_axes([0,0,1,1])\n\nplt.imshow(image_rgb)\ncolor_mask = sam_masks(result)\nplt.axis('off')\nplt.savefig(\"../DATA/ITC_BUILDING_spherical_projection_segmented.jpg\")\n```", "```py\ndef color_point_cloud(image_path, point_cloud, mapping):\n    image = cv2.imread(image_path)\n    h, w = image.shape[:2]\n    modified_point_cloud = np.zeros((point_cloud.shape[0], point_cloud.shape[1]+3), dtype=np.float32)\n    modified_point_cloud[:, :3] = point_cloud\n    for iy in range(h):\n        for ix in range(w):\n            point_index = mapping[iy, ix]\n            if point_index != -1:\n                color = image[iy, ix]\n                modified_point_cloud[point_index, 3:] = color\n    return modified_point_cloud\n```", "```py\nmodified_point_cloud = color_point_cloud(image_path, point_cloud, mapping)\n```", "```py\ndef export_point_cloud(cloud_path, modified_point_cloud):\n    # 1\\. Create a new header\n    header = laspy.LasHeader(point_format=3, version=\"1.2\")\n    header.add_extra_dim(laspy.ExtraBytesParams(name=\"random\", type=np.int32))\n\n    # 2\\. Create a Las\n    las_o = laspy.LasData(header)\n    las_o.x = modified_point_cloud[:,0]\n    las_o.y = modified_point_cloud[:,1]\n    las_o.z = modified_point_cloud[:,2]\n    las_o.red = modified_point_cloud[:,3]\n    las_o.green = modified_point_cloud[:,4]\n    las_o.blue = modified_point_cloud[:,5]\n    las_o.write(cloud_path)\n\n    print(\"Export succesful at: \", cloud_path)\n    return\n```", "```py\nexport_point_cloud(\"../DATA/pcd_results.las\", modified_point_cloud)\n```"]