- en: Explore Pydantic V2’s Enhanced Data Validation Capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/explore-pydantic-v2s-enhanced-data-validation-capabilities-792a3353ec5](https://towardsdatascience.com/explore-pydantic-v2s-enhanced-data-validation-capabilities-792a3353ec5)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Learn the new features and syntaxes of Pydantic V2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://lynn-kwong.medium.com/?source=post_page-----792a3353ec5--------------------------------)[![Lynn
    G. Kwong](../Images/b9a05b6587db5ca41c1d8264adda5b06.png)](https://lynn-kwong.medium.com/?source=post_page-----792a3353ec5--------------------------------)[](https://towardsdatascience.com/?source=post_page-----792a3353ec5--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----792a3353ec5--------------------------------)
    [Lynn G. Kwong](https://lynn-kwong.medium.com/?source=post_page-----792a3353ec5--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----792a3353ec5--------------------------------)
    ·7 min read·Oct 25, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/84d995a0acb8b86cb58dee8da4027427.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by jackmac34 on Pixabay
  prefs: []
  type: TYPE_NORMAL
- en: Data validation stands as a cornerstone for robust applications in the ever-evolving
    field of data engineering and software development. Ensuring data cleanliness
    and accuracy is essential not only for application reliability but also for user
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: Pydantic is the most widely used data validation library for Python. The core
    of the newest version (V2) of Pydantic has been rewritten in Rust and has a much
    better performance than the previous version. Besides, there are some major improvements
    to the functionalities like supporting strict mode, validation without a model,
    model namespace cleanup, etc.
  prefs: []
  type: TYPE_NORMAL
- en: This post will dive deep into the latest features and enhanced performance of
    the powerful data validation capabilities of Pydantic, offering developers a comprehensive
    toolset for all sorts of data-handling tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Preparation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To follow the examples in this post, you should install a modern version of
    Python (≥ 3.10) and the latest version of Pydantic V2\. It’s recommended to manage
    the different versions of Python and the libraries with a [conda](https://superdataminer.com/2022/01/04/how-to-create-virtual-environments-with-venv-and-conda-in-python/)
    virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Basic Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Normally with Pydantic, we need to define the schema of our data using models
    first, which are simply classes inheriting from `BaseModel`. In these models,
    the data types of each field are defined by type hints.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To use this model for validation, we can create an instance by passing the
    values for each field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The string data for `storage` is coerced to an integer which is defined in the
    model.
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity of demonstration, we will only use two fields, namely `brand`
    and `storage` in this post, which can be easily expanded to other fields.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Validate data directly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the example above, an instance of a Pydantic model is created for data validation.
    In Pydantic V2, we can also validate dictionaries or JSON data directly using
    `model_validate()` and `model_validate_json()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In Pydantic V2, all methods on models start with `model_`, and thus the field
    names are not allowed to start with `model_` . However, field aliases can be used
    if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Validate data in strict mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, the strict mode is off, which means the data type will be coerced
    if possible. For example, in the above examples, the type of the `storage` field
    is coerced from `str` to `int`. We can disable the strict mode so data types of
    all fields must match exactly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also set strict mode on the field level of the model so we don’t need
    to specify it in the validation step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Configure models with model_config
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Pydantic V2, to specify configuration on a model, we can set a class attribute
    called `model_config` to be a dict with the key/value pairs that will be used
    as the config. Typically, we do this with a special dict called `ConfigDict` which
    is a `TypedDict` for configuring Pydantic behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can set the `strict` mode on the model level, rather than on
    the field level as shown above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We have also specified the minimum length for string fields to be 2 so a brand
    like `X` will be rejected.
  prefs: []
  type: TYPE_NORMAL
- en: Use typing.Annotated for Fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Rather than assigning a `Field` value to a field to specify the behavior of
    a field, it can also be done with type hint using `typing.Annotated`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: With `Annotated`, the first type parameter (here `int`) passed is the actual
    type and the rest is just metadata for other tools (here Pydantic). You can have
    anything as the metadata, and it’s up to the other tools how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Fields with dynamic default values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can set a dynamic default value for a field so it can be generated automatically
    and can be different for each model instance. For example, we can set the current
    timestamp as the created time for a model and also set a unique ID for it. This
    can be done using `default_factory`, which accepts a factory function as the input.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It shows that the `uid` and `created` field are created automatically and will
    be different for each model.
  prefs: []
  type: TYPE_NORMAL
- en: Field and model validators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to applying the strict mode on a field, we can apply a custom validator
    to a field using the `Annotated` syntax of type hints. Let’s add a custom validator
    which checks if the storage is a valid value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `AfterValidator` indicates that the validation will be applied after Pydantic’s
    inner validation logic. It’s equivalent to the `after` mode with `@field_validator()`
    decorator as shown below.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the validation code should not raise `ValidationError` itself, but
    rather raise a `ValueError` or `AssertionError` (or subclass thereof) which will
    be caught and used to populate `ValidationError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the `@field_validator()` decorator to apply a custom validator
    to a field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `@field_validator()` should work exactly the same as with the `Annotated`
    syntax shown above. There are some pros and cons for each syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `Annotated` we can re-use the custom validation function more easily.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `field_validator` we can apply the same validation function to multiple
    fields more easily.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, you need to decide which syntax to use based on your specific practical
    use case.
  prefs: []
  type: TYPE_NORMAL
- en: We can also apply custom validators to the whole model using `@model_validator()`.
    In this case, we can have access to data from all the fields. For example, let’s
    assume that if the brand is “Apple”, then the storage must be at least 256GB.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note that `@model_validator()` is an instance method decorator, rather than
    a [class method decorator](https://superdataminer.com/2021/11/16/how-to-decorate-classes-in-python/)
    like `@field_validator()`.
  prefs: []
  type: TYPE_NORMAL
- en: Dumping or Serialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use`[model_dump](https://docs.pydantic.dev/latest/concepts/serialization/#modelmodel_dump)()`
    to convert an instance of a Pydantic model to a dictionary with the values of
    the instance. We will use the more verbose model as introduced at the beginning
    of this post to demonstrate serialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Pydantic can serialize many commonly used types to JSON that would otherwise
    be incompatible with a simple `json.dumps()` (e.g. `datetime`, `date` or `UUID`)
    . If needed, we can also customize how a field should serialized with the `[@field_serializer](http://twitter.com/field_serializer)()`
    decorator. For example, let’s convert the brand to uppercase when it’s dumped.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that `_info` represents the metadata that’s provided by Pydantic automatically.
  prefs: []
  type: TYPE_NORMAL
- en: In this post, we introduced how to use the latest version of Pydantic (V2) for
    data validation. A lot of syntax changes and new features have been introduced
    in this version which can be pretty verbose and cumbersome to read in the official
    documentation. Luckily, we only use a small set of them in our daily work and
    most of them have been introduced in this post with simple examples which can
    provide developers with a comprehensive toolset for all sorts of data-handling
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Related posts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[How to Validate Your Data with Custom Validators of Pydantic Models in Python](https://superdataminer.com/2022/08/05/how-to-validate-your-data-with-custom-validators-of-pydantic-models-in-python/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Understand and Master the Decorator in Python](https://superdataminer.com/2021/05/14/understand-and-master-the-decorator-in-python/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
