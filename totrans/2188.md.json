["```py\nimport numpy as np\n\ndef compute_iou(box1, box2):\n    \"\"\"\n    This function computes the intersection-over-union of two boxes.\n    Both boxes are expected to be in (x1, y1, x2, y2) format.\n    where (x1, y1) is the top_left coordinates and \n    (x2, y2) is the bottom_right coordinates\n\n    Arguments:\n        box1 4 by 1 NumPy Array: The first box.\n        box2 4 by 1 NumPy Array: The second box.\n\n    Returns:\n        iou (float): The intersection-over-union value for the two boxes.\n    \"\"\"\n    # Calculate the area of each box\n    area1 = np.prod(box1[2:] - box1[:2])\n    area2 = np.prod(box2[2:] - box2[:2])\n    print(\"Area of box 1 and box2, respectively: \", area1, area2)\n\n    # Calculate the intersection coordinates (top left and bottom right)\n    top_left = np.maximum(box1[:2], box2[:2])\n    bottom_right = np.minimum(box1[2:], box2[2:])\n    print(\"Top left and bottom right of intersection rectangle: \", top_left, bottom_right)\n\n    # Calculate the intersection area\n    intersection = np.prod(np.clip(bottom_right - top_left, a_min=0, a_max=None))\n    print(\"Intersection area: \", intersection)\n    # Calculate the union area\n    union = area1 + area2 - intersection\n    print(\"Union area: \", union)\n\n    # Calculate the IoU\n    iou = intersection / union if union > 0 else 0.0\n\n    return iou\n\n# Calling compute_iou with overlapping boxes\ndetection = np.array([859, 31, 1002, 176])\nlabel = np.array([860, 68, 976, 184])\niou_value = compute_iou(detection, label)\nprint(\"IoU:\", iou_value)\n```", "```py\nArea of box 1 and box2, respectively:  20735 13456\nTop left and bottom right of intersection rectangle:  [860  68] [976 176]\nIntersection area:  12528\nUnion area:  21663\nIoU: 0.5783132530120482\n```", "```py\n# Calling compute_iou with non-intersecting boxes\ndetection = np.array([810, 744, 942, 865])\nlabel = np.array([109,563,217,671])\niou_value = compute_iou(detection, label)\nprint(\"IoU:\", iou_value)\n```", "```py\nArea of box 1 and box2, respectively:  15972 11664\nTop left and bottom right of intersection rectangle:  [810 744] [217 671]\nIntersection area:  0\nUnion area:  27636\nIoU: 0.0\n```", "```py\ndef compute_ious(boxes1, boxes2):\n    \"\"\"\n    This function computes intersection-over-union of boxes.\n    Both sets of boxes are expected to be in (x1, y1, x2, y2) format\n    where (x1,y1) is the top-left coordinates and \n    (x2,y2) is the bottom right coordinates\n    Arguments:\n        boxes1: M by 4 NumPy array\n        boxes2: N by 4 NumPy array\n    Returns:\n        iou MxN Numpy Matrix - containing the pairwise\n            IoU values for every element in boxes1 and boxes2\n    \"\"\"\n    # Compute area for all combination of boxes in boxes1 and boxes2\n    area1 = np.prod(boxes1[:, 2:] - boxes1[:, :2], axis=1)\n    area2 = np.prod(boxes2[:, 2:] - boxes2[:, :2], axis=1)\n\n    # Top left and bottom right of the intersection for all box pairs\n    top_left = np.maximum(boxes1[:, None, :2], boxes2[:, :2])  # NxMx2 Array\n    bottom_right = np.minimum(boxes1[:, None, 2:], boxes2[:, 2:])  # NxMx2 Array\n\n    # Compute intersection for all box pairs\n    intersection = np.prod(np.clip(bottom_right - top_left, a_min=0, a_max=None), 2)\n\n    return intersection / (area1[:, None] + area2 - intersection)\n\n# Define detections and ground_truths\ndetections = np.array([[374,627,538,792],\n[330,308,501,471],\n[474,14,638,181],\n[810,744,942,865],\n[58,844,204,993],\n[905,280,1022,425],\n[887,412,1018,543],\n[0,871,68,1008],\n[859,31,1002,176],\n[698,949,808,1023],\n[0,400,47,505],\n[234,0,314,58]])\n\nground_truths = np.array([[331,303,497,469],\n[385,624,543,782],\n[809,743,941,875],\n[883,410,1024,556],\n[918,287,1024,425],\n[860,68,976,184],\n[109,563,217,671],\n[0,401,60,515],\n[51,833,207,989],\n[0,867,80,1024],\n[273,877,403,1007],\n[701,939,821,1024],\n[905,608,1021,724],\n[471,17,629,175]])\n# Call compute_ious() function \nious = compute_ious(detections, ground_truths)\nprint(ious)\n```"]