# 探索 Pydantic V2 的增强数据验证功能

> 原文：[https://towardsdatascience.com/explore-pydantic-v2s-enhanced-data-validation-capabilities-792a3353ec5](https://towardsdatascience.com/explore-pydantic-v2s-enhanced-data-validation-capabilities-792a3353ec5)

## 了解 Pydantic V2 的新功能和语法

[](https://lynn-kwong.medium.com/?source=post_page-----792a3353ec5--------------------------------)[![Lynn G. Kwong](../Images/b9a05b6587db5ca41c1d8264adda5b06.png)](https://lynn-kwong.medium.com/?source=post_page-----792a3353ec5--------------------------------)[](https://towardsdatascience.com/?source=post_page-----792a3353ec5--------------------------------)[![Towards Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----792a3353ec5--------------------------------) [Lynn G. Kwong](https://lynn-kwong.medium.com/?source=post_page-----792a3353ec5--------------------------------)

·发布于 [Towards Data Science](https://towardsdatascience.com/?source=post_page-----792a3353ec5--------------------------------) ·7 min read·2023年10月25日

--

![](../Images/84d995a0acb8b86cb58dee8da4027427.png)

图片由 jackmac34 在 Pixabay 提供

数据验证是数据工程和软件开发领域中稳健应用的基石。确保数据的清洁性和准确性不仅对应用的可靠性至关重要，也对用户体验有很大影响。

Pydantic 是 Python 中使用最广泛的数据验证库。Pydantic 最新版本（V2）的核心已经用 Rust 重新编写，相比于之前的版本性能大大提升。此外，在功能方面也有一些重大改进，例如支持严格模式、无模型验证、模型命名空间清理等。

本文将深入探讨 Pydantic 强大数据验证功能的最新特性和增强性能，为开发者提供一个全面的数据处理工具集。

## 准备工作

要跟随本文中的示例，您应该安装现代版本的 Python（≥ 3.10）和最新版本的 Pydantic V2。建议使用 [conda](https://superdataminer.com/2022/01/04/how-to-create-virtual-environments-with-venv-and-conda-in-python/) 虚拟环境来管理不同版本的 Python 和库：

[PRE0]

## 基本用法

通常使用 Pydantic 时，我们需要先通过模型定义数据的模式，这些模型只是继承自 `BaseModel` 的类。在这些模型中，每个字段的数据类型由类型提示定义。

[PRE1]

要使用此模型进行验证，我们可以通过传递每个字段的值来创建一个实例：

[PRE2]

`storage` 字符串数据会被强制转换为模型中定义的整数。

为了演示的简便性，我们在本文中仅使用两个字段，即`brand`和`storage`，这可以轻松扩展到其他字段。

[PRE3]

## 直接验证数据

在上面的示例中，为数据验证创建了一个Pydantic模型的实例。在Pydantic V2中，我们还可以直接使用`model_validate()`和`model_validate_json()`来验证字典或JSON数据：

[PRE4]

在Pydantic V2中，所有模型的方法都以`model_`开头，因此字段名称不允许以`model_`开头。然而，如果需要，可以使用字段别名。

## 在严格模式下验证数据

默认情况下，严格模式是关闭的，这意味着数据类型会被强制转换（如果可能的话）。例如，在上述示例中，`storage`字段的类型从`str`被强制转换为`int`。我们可以禁用严格模式，这样所有字段的数据类型必须完全匹配：

[PRE5]

我们还可以在模型的字段级别设置严格模式，这样我们在验证步骤中就不需要指定它：

[PRE6]

## 使用`model_config`配置模型

在Pydantic V2中，为了指定模型的配置，我们可以将类属性`model_config`设置为一个字典，该字典包含将用于配置的键/值对。通常，我们通过一个称为`ConfigDict`的特殊字典来做到这一点，它是一个用于配置Pydantic行为的`TypedDict`。

例如，我们可以在模型级别设置`strict`模式，而不是在字段级别，如上所示：

[PRE7]

我们还指定了字符串字段的最小长度为2，因此像`X`这样的品牌将被拒绝。

## 使用`typing.Annotated`来处理字段

不必将`Field`值分配给字段以指定字段的行为，也可以使用类型提示`typing.Annotated`来完成：

[PRE8]

使用`Annotated`时，传递的第一个类型参数（这里是`int`）是实际类型，其余的是其他工具（这里是Pydantic）的元数据。元数据可以包含任何内容，如何使用由其他工具决定。

## 具有动态默认值的字段

我们可以为字段设置动态默认值，这样它可以自动生成，并且每个模型实例可能不同。例如，我们可以将当前时间戳设置为模型的创建时间，并为其设置唯一的ID。这可以通过使用`default_factory`来完成，它接受一个工厂函数作为输入。

[PRE9]

这表明`uid`和`created`字段是自动创建的，并且每个模型将会不同。

## 字段和模型验证器

类似于在字段上应用严格模式，我们可以使用`Annotated`语法为字段应用自定义验证器。让我们添加一个自定义验证器，检查`storage`是否是有效值：

[PRE10]

`AfterValidator`表示验证将在Pydantic的内部验证逻辑之后应用。它相当于使用`@field_validator()`装饰器的`after`模式，如下所示。

请注意，验证代码不应抛出`ValidationError`本身，而应抛出`ValueError`或`AssertionError`（或其子类），这些异常将被捕获并用于填充`ValidationError`。

我们还可以使用`@field_validator()`装饰器为字段应用自定义验证器：

[PRE11]

使用`@field_validator()`的效果应与上述`Annotated`语法完全相同。每种语法都有其优缺点：

+   使用`Annotated`可以更轻松地重用自定义验证函数。

+   使用`field_validator`我们可以更轻松地将相同的验证函数应用于多个字段。

因此，你需要根据具体的实际使用案例来决定使用哪种语法。

我们还可以使用`@model_validator()`将自定义验证器应用于整个模型。在这种情况下，我们可以访问所有字段的数据。例如，假设如果品牌是“Apple”，则存储必须至少为256GB。

[PRE12]

请注意，`@model_validator()`是一个实例方法装饰器，而不是像`@field_validator()`那样的[类方法装饰器](https://superdataminer.com/2021/11/16/how-to-decorate-classes-in-python/)。

## 转储或序列化

我们可以使用`[model_dump](https://docs.pydantic.dev/latest/concepts/serialization/#modelmodel_dump)()`将Pydantic模型的实例转换为包含实例值的字典。我们将使用文章开头介绍的更详细的模型来演示序列化：

[PRE13]

Pydantic可以将许多常用类型序列化为JSON，这些类型否则会与简单的`json.dumps()`不兼容（例如`datetime`、`date`或`UUID`）。如果需要，我们还可以使用`[@field_serializer](http://twitter.com/field_serializer)()`装饰器自定义字段的序列化方式。例如，我们可以在转储时将品牌转换为大写。

[PRE14]

请注意，`_info`表示Pydantic自动提供的元数据。

在这篇文章中，我们介绍了如何使用最新版本的Pydantic（V2）进行数据验证。在这个版本中引入了许多语法变化和新特性，这些在官方文档中可能会显得非常冗长和复杂。幸运的是，我们在日常工作中只使用了一小部分功能，并且大多数功能在这篇文章中通过简单的示例进行了介绍，这些示例可以为开发者提供全面的数据处理工具集。

## 相关帖子

+   [如何使用Pydantic模型的自定义验证器验证数据](https://superdataminer.com/2022/08/05/how-to-validate-your-data-with-custom-validators-of-pydantic-models-in-python/)

+   [理解和掌握Python中的装饰器](https://superdataminer.com/2021/05/14/understand-and-master-the-decorator-in-python/)
