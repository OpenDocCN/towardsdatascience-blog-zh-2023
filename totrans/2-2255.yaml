- en: Use the Partitions, Luke! A Simple and Proven Way to Optimise Your SQL Queries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/use-the-partitions-luke-a-simple-and-proven-way-to-optimise-your-sql-queries-43e24ea4c5d0](https://towardsdatascience.com/use-the-partitions-luke-a-simple-and-proven-way-to-optimise-your-sql-queries-43e24ea4c5d0)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you’ve ever written an SQL query that takes ages to run, this is the article
    for you
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@mattchapmanmsc?source=post_page-----43e24ea4c5d0--------------------------------)[![Matt
    Chapman](../Images/7511deb8d9ed408ece21031f6614c532.png)](https://medium.com/@mattchapmanmsc?source=post_page-----43e24ea4c5d0--------------------------------)[](https://towardsdatascience.com/?source=post_page-----43e24ea4c5d0--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----43e24ea4c5d0--------------------------------)
    [Matt Chapman](https://medium.com/@mattchapmanmsc?source=post_page-----43e24ea4c5d0--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----43e24ea4c5d0--------------------------------)
    ·8 min read·Dec 7, 2023
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/caa41d8a1a68733fba112f4270c57c15.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
- en: Baby Yoda loves partitions. Do you? Image by [Victor Serban](https://unsplash.com/@victorserban)
    on [Unsplash](https://unsplash.com/photos/green-frog-plush-toy-on-brown-textile-ZFN6UNWhstI)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Data Scientists love SQL, but boy do we suck at writing performant queries (maybe
    because we spent too much time debating whether it’s pronounced “S-Q-L” or “sequel”?).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: In this article, I’m going to show you how to use ***SQL partitions*** to optimise
    your queries and write code that’s quicker and cheaper to run. If you’ve mastered
    the basics of SQL and want to start unlocking higher-level Data Science skills,
    this will be a great addition to your toolkit.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: What’s a partitioned table?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A partitioned table is a table that’s divided into segments/partitions (who
    saw that coming?).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: In a partitioned table, each segment is stored in a different location on the
    server. This is different from a normal (unpartitioned) SQL table, where the entire
    table sits in a single location.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a comparison using dummy data about the daily sales of three of my favourite
    books:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c80814445de2097c783f0c0e84481128.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
- en: Image by author
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Both the unpartitioned and the partitioned table hold the same data; the only
    difference is that the partitioned table splits the data into different segments.
    It’s still a single table (i.e. it’s not three separate tables); it’s just storing
    the data in a different way.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Why should we care? Well, as we’ll see shortly, we can take advantage of this
    structure to write more efficient SQL queries.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Creating partitioned tables
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a partitioned table is easy as pie.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we’d use the following code to create a normal (unpartitioned)
    table…
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '… we can create a partitioned version by adding a single line at the end of
    the `CREATE TABLE` statement:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The column on which were are partitioning is known as the **partitioning key**;
    in this case, we’re partitioning on the `date` column, but any column is fine
    as long as it’s either (1) a date/timestamp field or (2) an integer field.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we’ve created these two tables, we’ll see that they look identical at
    first glance (e.g., if you run `SELECT *` against each table, the results will
    look the same). If however we look at the tables’ details/metadata, we’ll see
    that the partitioned table includes some extra metadata. Here’s what this looks
    like in BigQuery (the place I’m running my SQL):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ded7525c32680d28219a206fc6adbfd0.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: Image by author
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Why does this matter? Because using partitions reduces the amount of data required
    to process your query
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: And this is great news, because it means that partitions can help you write
    more efficient queries!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: When you query a normal (unpartitioned) table, the SQL engine typically has
    to scan the entire table in order to find the rows you want. On large tables,
    this can be unnecessarily slow and expensive, as your machine needs to process
    data which are not useful for creating the final output.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s query the unpartitioned table we created earlier:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![](../Images/0904eee688705792f43d47a6ea8448d8.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: Image by author
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: In the image above, you can see that **all 9 rows of the table** were read in
    order to return the 6 rows with dates greater than ‘2023–12–01’.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s run the same query against our partitioned table:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![](../Images/0c8375b3ff38b786b5a1db0fb15a0c72.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: Image by author
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: This time, we see that **only 6 rows of the unpartitioned table were read**
    in order to generate the same results. Before executing the main part of the query,
    BigQuery was able to identify the partitions which contained the relevant rows
    and pull selectively from them. It simply didn’t need to read the 3 rows in the
    other partition.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: This preliminary step of selecting partitions is known as ***pruning****.* It’s
    much more efficient than normal queries because it means that the SQL engine won’t
    have to read every single row in the table; it will first fetch the partitions
    required, and only then will it execute your query. In fancy SQL lingo, the filter
    we add on the partitioning column is treated as an ***access predicate*** by the
    SQL engine and gets run before executing the main query.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: — Quick interlude —
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’re enjoying this article, you might like my site [the-sql-gym.com](https://the-sql-gym.com),
    which contains over 100 practice SQL questions. If you want to boost your SQL
    skills, check it out! And let me know if you have any feedback :-)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2eecfbe5e0a0711641021e07d3c44cf6.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
- en: 'Image by author. Source: [the-sql-gym.com](https://the-sql-gym.com/)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Back to partitioning — Let’s look at a bigger example
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we’re working with small tables like the ones above, partitioning might
    seem a bit overkill. But when we upscale to larger tables, it can lead to significant
    performance gains.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s create two large tables, each with 1 million rows. The first will
    be an unpartitioned table, and the second will be partitioned by the `id` column,
    with each partition being 10,000 rows.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When we run the following query against the unpartitioned table:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](../Images/d1ce2eb7af55144289d1ee37e1f8f5f7.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
- en: Image by author
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: … we see that all 1,000,000 rows of the table are read before the 1,001 records
    are outputted. The whole operation took 650ms (Elapsed time) / 503ms (Slot time
    consumed).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: However, when we run the same query against the **partitioned** table, only
    10,000 rows are read (i.e., one single partition).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![](../Images/ee7a768edaf85d73975b4acc5dafee94.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: Image by author
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: When querying the unpartitioned table, the operation’s elapsed time was less
    than half of that in the first query (on the unpartitioned large table), and the
    slot time consumed was nearly 95% lower.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Pretty cool, right?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Common mistakes when using partitions
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you’d like to start using partitions to improve your tables/queries, there
    are a couple of pitfalls to watch out for:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '**Don’t filter a large partitioned table on a non-partitioning column** — If
    you filter on a column which is NOT the partitioning key, you won’t be able to
    take advantage of the partitioned structure of the table. If you DO need to filter
    on a non-partitioning-key column, I’d recommend that (if possible) you first add
    in a filter on the parititioning key (to prune the unneeded partitions), and then
    apply your second filter. This is because BigQuery (like many SQL engines) executes
    filters in the `WHERE` statement from top to bottom.'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Don’t apply a function on top of the partition keys** — For example, if your
    partitioning key is a column `date`, don’t add a filter like `WHERE CAST(date
    AS STRING) = ''2023-12-02''`. Instead, if you need to include a function in your
    `WHERE` clause, add the function on top of a constant. In that example, you could
    rewrite the filter to `WHERE date = CAST(''2023-01-01'' AS DATE)` to ensure that
    you still take advantage of pruning/partitioning.'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2 quick notes about partitioning in BigQuery specifically
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'BigQuery has **a limit of 4,000 partitions per table**. If you’re trying to
    use a partitioning key that will create more than 4,000 partitions, try using
    a different resolution. For example, instead of partitioning by date/day:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '… you could partition by week:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It’s also worth knowing that BigQuery makes it possible to partition based on
    an ingestion time field and a pseudocolumn named `_PARTITIONTIME`. It’s too niche
    for this article, but you can read more about it [here](https://cloud.google.com/bigquery/docs/partitioned-tables#ingestion_time).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: When NOT to use partitions
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On smaller tables, partitioning might not lead to a performance boost. Why?
    Because the process of pruning partitions might take longer than simply looking
    through all the rows in the table ([source](https://stackoverflow.com/questions/58743050/whats-a-good-balance-to-decide-when-to-partition-a-table-in-bigquery)).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在较小的表格中，分区可能不会带来性能提升。为什么？因为修剪分区的过程可能比简单地查看表中所有行花费更多时间（[来源](https://stackoverflow.com/questions/58743050/whats-a-good-balance-to-decide-when-to-partition-a-table-in-bigquery)）。
- en: In these cases, ***clustering*** can be a more performant alternative. Stay
    tuned for more on that in my next article!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，***聚类***可能是一个更高效的替代方案。请关注我下一篇文章了解更多内容！
- en: One more thing —
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有一件事——
- en: I’ve started a free newsletter called [AI in Five](https://aiinfive.substack.com/)
    where I share 5 bullet points each week on the latest AI news, coding tips and
    career stories for Data Scientists/Analysts. There’s no hype, no “**data is the
    new oil**” rubbish and no tweets (or should I say ‘x-es’ now?) from Elon — just
    practical tips and insights to help you develop in your career.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经开始了一份免费的通讯，叫做 [AI in Five](https://aiinfive.substack.com/)，每周分享5个要点，涵盖最新的AI新闻、编码技巧和数据科学家/分析师的职业故事。没有炒作，没有“**数据是新的石油**”的废话，也没有来自Elon的推文（或者我现在应该说‘x-es’？）——只有实用的技巧和见解，帮助你在职业生涯中发展。
- en: '[Subscribe here](https://aiinfive.substack.com/) if that sounds up your street!
    Thanks for reading.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[在这里订阅](https://aiinfive.substack.com/) 如果这正是你感兴趣的！感谢阅读。'
- en: '[](https://aiinfive.substack.com/?source=post_page-----43e24ea4c5d0--------------------------------)
    [## AI in Five | Matt Chapman | Substack'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[## AI in Five | Matt Chapman | Substack](https://aiinfive.substack.com/?source=post_page-----43e24ea4c5d0--------------------------------)'
- en: The latest news, career stories and coding tips from the world of Data Science
    and AI, summarised in 5 bullet points…
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最新消息、职业故事和数据科学与人工智能领域的编码技巧，浓缩成5个要点……
- en: aiinfive.substack.com](https://aiinfive.substack.com/?source=post_page-----43e24ea4c5d0--------------------------------)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[aiinfive.substack.com](https://aiinfive.substack.com/?source=post_page-----43e24ea4c5d0--------------------------------)'
