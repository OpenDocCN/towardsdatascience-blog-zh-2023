["```py\nimport matplotlib.pyplot as plt\nimport numpy as np\nnp.random.seed(0)\n\nTOTAL_BUDGET = 100_000\n\n# Alpha and beta constants\nalphas = np.array([-9453.72, -8312.84, -7371.33])\nbetas = np.array([8256.21, 7764.20, 7953.36])\n\n# Linearly spaced numbers\nx = np.linspace(1, TOTAL_BUDGET, TOTAL_BUDGET)\n\n# Plot the response curves\nfig = plt.figure(figsize=(10, 5), dpi=300)\nplt.plot(x, alphas[0] + betas[0] * np.log(x), color='red', label='Google Ads')\nplt.plot(x, alphas[1] + betas[1] * np.log(x), color='blue', label='Facebook Ads')\nplt.plot(x, alphas[2] + betas[2] * np.log(x), color='green', label='Twitter Ads')\nplt.xlabel('Budget ($)')\nplt.ylabel('Returns ($)') \nplt.legend()\nplt.show()\n```", "```py\ndef greedy_optimization(TOTAL_BUDGET, alphas, betas, num_iterations=1_000):\n    # Initialize the budget allocation and the best objective value\n    google_budget = facebook_budget = twitter_budget = TOTAL_BUDGET / 3\n    obj = alphas[0] + betas[0] * np.log(google_budget) + alphas[1] + betas[1] * np.log(facebook_budget) + alphas[2] + betas[2] * np.log(twitter_budget)\n\n    for _ in range(num_iterations):\n        # Generate a new random allocation\n        random_allocation = np.random.dirichlet(np.ones(3)) * TOTAL_BUDGET\n        google_budget_new, facebook_budget_new, twitter_budget_new = random_allocation\n\n        # Calculate the new objective value\n        new_obj = alphas[0] + betas[0] * np.log(google_budget_new) + alphas[1] + betas[1] * np.log(facebook_budget_new) + alphas[2] + betas[2] * np.log(twitter_budget_new)\n\n        # If the new allocation improves the objective value, keep it\n        if new_obj > obj:\n            google_budget, facebook_budget, twitter_budget = google_budget_new, facebook_budget_new, twitter_budget_new\n            obj = new_obj\n\n    # Return the best allocation and the corresponding objective value\n    return (google_budget, facebook_budget, twitter_budget), objp\n```", "```py\n# Run the greedy optimization\n(best_google, best_facebook, best_twitter), obj = greedy_optimization(TOTAL_BUDGET, alphas, betas)\n\n# Print the result\nprint('='*59 + '\\n' + ' '*24 + 'Solution' + ' '*24 + '\\n' + '='*59)\nprint(f'Returns = ${round(obj):,}\\n')\nprint('Marketing allocation:')\nprint(f' - Google Ads   = ${round(best_google):,}')\nprint(f' - Facebook Ads = ${round(best_facebook):,}')\nprint(f' - Twitter Ads  = ${round(best_twitter):,}')\n```", "```py\n===========================================================\n                        Solution                        \n===========================================================\nReturns = $224,534\n\nMarketing allocation:\n - Google Ads   = $35,476\n - Facebook Ads = $31,722\n - Twitter Ads  = $32,802\n```", "```py\nimport cvxpy as cp\n\n# Variables\ngoogle   = cp.Variable(pos=True)\nfacebook = cp.Variable(pos=True)\ntwitter  = cp.Variable(pos=True)\n\n# Constraint\nconstraint = [google + facebook + twitter <= TOTAL_BUDGET]\n\n# Objective\nobj = cp.Maximize(alphas[0] + betas[0] * cp.log(google)\n                + alphas[1] + betas[1] * cp.log(facebook)\n                + alphas[2] + betas[2] * cp.log(twitter))\n```", "```py\n# Solve\nprob = cp.Problem(obj, constraint)\nprob.solve(solver='ECOS', verbose=False)\n\n# Print solution\nprint('='*59 + '\\n' + ' '*24 + 'Solution' + ' '*24 + '\\n' + '='*59)\nprint(f'Status = {prob.status}')\nprint(f'Returns = ${round(prob.value):,}\\n')\nprint('Marketing allocation:')\nprint(f' - Google Ads   = ${round(google.value):,}')\nprint(f' - Facebook Ads = ${round(facebook.value):,}')\nprint(f' - Twitter Ads  = ${round(twitter.value):,}')\n```", "```py\n===========================================================\n                        Solution                        \n===========================================================\nStatus = optimal\nReturns = $224,540\n\nMarketing allocation:\n - Google Ads   = $34,439\n - Facebook Ads = $32,386\n - Twitter Ads  = $33,175\n```", "```py\n# Plot the functions and the results\nfig = plt.figure(figsize=(10, 5), dpi=300)\n\nplt.plot(x, alphas[0] + betas[0] * np.log(x), color='red', label='Google Ads')\nplt.plot(x, alphas[1] + betas[1] * np.log(x), color='blue', label='Facebook Ads')\nplt.plot(x, alphas[2] + betas[2] * np.log(x), color='green', label='Twitter Ads')\n\n# Plot optimal points\nplt.scatter([google.value, facebook.value, twitter.value],\n            [alphas[0] + betas[0] * np.log(google.value),\n             alphas[1] + betas[1] * np.log(facebook.value),\n             alphas[2] + betas[2] * np.log(twitter.value)],\n            marker=\"+\", color='black', zorder=10)\n\nplt.xlabel('Budget ($)')\nplt.ylabel('Returns ($)') \nplt.legend()\nplt.show()\n```", "```py\n# List to store the best objective value for each number of iterations\nbest_obj_list = []\n\n# Range of number of iterations to test\nnum_iterations_range = np.logspace(0, 6, 20).astype(int)\n\n# Run the greedy algorithm for each number of iterations and store the best objective value\nfor num_iterations in num_iterations_range:\n    _, best_obj = greedy_optimization(TOTAL_BUDGET, alphas, betas, num_iterations)\n    best_obj_list.append(best_obj)\n```", "```py\n# Plot the results\nplt.figure(figsize=(10, 5), dpi=300)\nplt.ticklabel_format(useOffset=False)\nplt.plot(num_iterations_range, best_obj_list, label='Greedy algorithm')\nplt.axhline(y=prob.value, color='r', linestyle='--', label='Optimal solution (CVXPY)')\nplt.xlabel('Number of iterations')\nplt.xticks(num_iterations_range)\nplt.xscale(\"log\")\nplt.ylabel('Best returns ($)')\nplt.title('Best returns found by the greedy algorithm for different numbers of iterations')\nplt.legend()\nplt.show()\n```"]