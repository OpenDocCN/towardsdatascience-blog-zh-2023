- en: Bubble Sort Explained ‚Äî A Data Scientists Algorithm Guide
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://towardsdatascience.com/bubble-sort-explained-a-data-scientists-algorithm-guide-853b2286e5ab](https://towardsdatascience.com/bubble-sort-explained-a-data-scientists-algorithm-guide-853b2286e5ab)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An intuitive explanation of bubble sort with implementation in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://richmondalake.medium.com/?source=post_page-----853b2286e5ab--------------------------------)[![Richmond
    Alake](../Images/7d563ac272e730f4f6a9ce8620cd11e3.png)](https://richmondalake.medium.com/?source=post_page-----853b2286e5ab--------------------------------)[](https://towardsdatascience.com/?source=post_page-----853b2286e5ab--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----853b2286e5ab--------------------------------)
    [Richmond Alake](https://richmondalake.medium.com/?source=post_page-----853b2286e5ab--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ¬∑Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----853b2286e5ab--------------------------------)
    ¬∑10 min read¬∑Jan 5, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: As software engineers and data scientists, we often take sorting functions for
    granted. These algorithms may not be the most glamorous or heavily discussed aspects
    of our work, but they play a vital role in the technologies we use every day.
    For example, imagine trying to organize the contact list on your phone without
    a way to sort alphabetically or sorting products on an eCommerce website by price
    and category. It‚Äôs easy to overlook the importance of sorting algorithms, but
    they are integral to our work as programmers.
  prefs: []
  type: TYPE_NORMAL
- en: Even though most programming languages, such as Java, Python, C# etc., come
    with built-in functions for common sorting algorithms, it‚Äôs still important for
    us to have a basic understanding of how these algorithms work. This knowledge
    allows us to make informed decisions about which algorithm to use based on its
    space and time complexities, especially when working with large datasets as data
    scientists. So don‚Äôt underestimate the humble sorting function ‚Äî they may not
    be the star of the show, but they are the unsung heroes of the tech industry.
  prefs: []
  type: TYPE_NORMAL
- en: In this article, we‚Äôll dive into the bubble sort algorithm, examining its implementation
    in Python and JavaScript. We‚Äôll also take a closer look at the intuition behind
    the algorithm and discuss considerations for time and space complexity. By the
    end of this article, you‚Äôll have a solid understanding of when it is appropriate
    to use the bubble sort algorithm in your programs, as well as an overview of its
    space and time complexities.
  prefs: []
  type: TYPE_NORMAL
- en: Get a detailed overview of how hardware innovations are changing how data teams
    build analytics and machine learning applications in the free ebook, [Hardware
    > Software > Process](https://www.nvidia.com/en-us/ai-data-science/resources/hardware-software-process-book/?nvid=nv-int-tblg-423746#cid=dl13_nv-int-tblg_en-us).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Bubble Sort Intuition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is always more helpful to first grasp the concept when attempting to understand
    and later recall an algorithm. By familiarizing yourself with the idea before
    jumping into implementation, you will better retain the information for future
    use. Bubble sort is no exception.
  prefs: []
  type: TYPE_NORMAL
- en: To sort an array [2, 3, 4, 5, 1] in ascending order using the bubble sort algorithm,
    we start from the first element [2] and compare it with the second element [3].
    If the first element is greater than the second, we swap them. We continue this
    process of comparing pairs of elements until we reach the end of the array. This
    way, the largest elements will be shifted to the end of the array, and the smallest
    elements will be shifted to the beginning of the array.
  prefs: []
  type: TYPE_NORMAL
- en: The name ‚Äúbubble sort‚Äù refers to the way in which larger elements ‚Äúbubble‚Äù to
    the top or the end of the array as they are repeatedly compared and swapped with
    smaller elements. By the end of the sorting process, the array will be fully sorted
    in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: Bubble Sort Algorithm Explanation (Step by Step)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is a list of unordered numbers that we will use bubble sort to
    organize:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f99f40bc2856d230ab08396ad2d66cd5.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to focus only on the first two numbers, which in this example
    are 5 and 9\. You can visualize considering just the two elemtns 5 and 9 as shown
    in the image below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1177ff3ca9581e555a7d91333459e232.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you must determine if the numbers inside the bubble are in order. If
    they aren‚Äôt in proper order, switch them around to make it right. Fortunately
    for us, they are already arranged in ascending order. 5 is less than 9, so it
    comes before 9\. This means we don‚Äôt have anything left to do ‚Äî we move our bubble
    one step further like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8ace99ef64f5f6230e14c7c11c329ad0.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'We conduct the same step in the next iteration of the array. However, this
    time 9 is greater than 1, but it‚Äôs also in front of it. So, to rectify that, the
    position of both elements is swapped. Here‚Äôs how the list looks now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/127b21ad18da3204ccd2183d72a8543f.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the elements are swapped, the bubble progresses to successive pairs.
    And the steps repeat until the last pairs in the array have undergone a check
    to swap. The first run through the array will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/82e9178717c0e913d3ea32c30303e6d5.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: The bubble sort algorithm is a simple yet effective way to sort an array of
    elements. It works by repeatedly iterating through the array and comparing pairs
    of elements, swapping their positions if they are out of order. This process is
    repeated until the entire array is sorted.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to remember is that the number of passes required to sort an array
    is equal to the number of elements in the array. For example, a 6-element array
    will need to go through 6 passes in order to be fully sorted in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: However, it‚Äôs possible to make the bubble sort algorithm more efficient by limiting
    the number of operations or passes conducted on the array. This is because the
    last element of the array is always the maximum value, so there is no need to
    continue comparing all elements beyond this point in future passes through the
    array. We‚Äôll see this optimization in action as we implement the bubble sort algorithm
    in Python and JavaScript in the sections below.
  prefs: []
  type: TYPE_NORMAL
- en: Bubble Sort Algorithm implemented in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section implements the bubble sort algorithm using the Python programming
    language. We will observe a naive implementation and a more efficient version
    of the bubble sort algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Initialize a Python array containing integer elements
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Define a function named ‚ÄòbubbleSort‚Äô that accepts an array in its parameter
    named ‚Äòdata‚Äô. First, let‚Äôs attempt to pass through the array that swaps any elements
    that satisfy the condition that if the left element at a particular index is greater
    than an element to the right, we execute a swap operation between those two elements.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to note is the assignment of the left element in any iteration to
    a temporary variable ‚ÄòtempValue‚Äô and then assigning the right element to the temporary
    variable
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The code snippet above, when called with an unsorted array passed as its arguments,
    will conduct the bubbleSort function pass once on the array. And in most cases,
    will not completely sort the array in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To fix this, we have to iterate through the array we want to sort as many times
    as there are combinations of pairs. Simply kept, the number of iterations to conduct
    is the length of the unsorted array squared (len(unsortedArrray)¬≤). This is the
    naive implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Running the bubble sort function again with the unsorted array passed as an
    argument will result in an array sorted in ascending order provided as an output
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Optimized Version of Bubble Sort**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the naive version of the bubble sort algorithm does work, it has some
    unnecessary and redundant operations. In particular, it compares elements at the
    end of the array that are already the maximum values present in the array. This
    is because on each pass through the array, the bubble sort algorithm moves the
    maximum element values to the end of the array.
  prefs: []
  type: TYPE_NORMAL
- en: To optimize the bubble sort algorithm, we can reduce the number of swap operations
    required by keeping track of the portion of the array that we want to consider
    for comparison. We can do this by starting with the maximum length of the array
    and decrementing it by 1 after each pass, reducing the area of the array that
    the swap operation acts upon. This way, we can avoid comparing with the last elements
    of the array on each pass, which are already in their correct position.
  prefs: []
  type: TYPE_NORMAL
- en: By using this optimization, we can make the bubble sort algorithm more efficient
    and reduce the number of unnecessary operations it performs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Further refactoring could be conducted to ensure the code above is readable
    and efficient. Also, as pointed out in the comments by [Dr. Robert K√ºbler](https://medium.com/u/6d6b5fb431bf?source=post_page-----853b2286e5ab--------------------------------),
    further optimization can be made to this algorithm by checking if a swap operation
    occurs. If a swap operation doesn‚Äôt occur, we can break the loop to avoid unnecessary
    passes through the array.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Below is an implementation of the same algorithm in JavaScript, a programming
    language popular with data practitioners and software engineers.
  prefs: []
  type: TYPE_NORMAL
- en: Bubble Sort Algorithm implemented in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Time and Space Complexity (Big O notation)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data scientists must understand the performance of a sorting algorithm and how
    much time/space it requires. This allows you to select the best sorting algorithm
    depending on your specific situation, as many options are available.
  prefs: []
  type: TYPE_NORMAL
- en: When bubble sort is used on an array already in ascending order, it requires
    only one pass through the entire array. This is considered the best-case scenario.
    In practice, though, this only occurs sometimes, and bubble sort usually necessitates
    n(n-1)/2 swaps or comparisons to achieve a sorted array.
  prefs: []
  type: TYPE_NORMAL
- en: The bubble sort algorithm‚Äôs average/worst time complexity is O(n¬≤), as we have
    to pass through the array as many times as there are pairs in a provided array.
    Therefore, when time is a factor, there may be better options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time complexity Worst Case: O(n¬≤)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Time complexity Average Case: O(n¬≤)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Time complexity Best Case: O(n), the array is already sorted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In terms of space complexity, since we only swapped the elements with one another
    and never stored anything, we don‚Äôt need any extra space to run the algorithm.
    This is amazing because it means the space complexity comes out as constant, or
    O(1). This makes it an [in-place](https://www.techiedelight.com/in-place-vs-out-of-place-algorithms/)
    algorithm that works by modifying the input directly.
  prefs: []
  type: TYPE_NORMAL
- en: Key Takeaways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The bubble sort algorithm may not be the most well-known or highly-regarded
    sorting algorithm, but as we‚Äôve seen, it‚Äôs not a terrible option either. With
    a time complexity of O(n¬≤) and a space complexity of O(1), it‚Äôs a simple algorithm
    that is easy for beginners to understand. However, its slow speed may make it
    less practical for certain applications.
  prefs: []
  type: TYPE_NORMAL
- en: Despite its limitations, the bubble sort algorithm can be a useful starting
    point for learning about sorting algorithms and data structures. It‚Äôs a good way
    to get a basic understanding of how these algorithms work, and can help you build
    a foundation for learning more complex algorithms later on.
  prefs: []
  type: TYPE_NORMAL
- en: That being said, the bubble sort algorithm may not be the best choice for time-sensitive
    material, as its slow speed can be prohibitive. However, if you‚Äôre willing to
    sacrifice some space for time, it may work well for you. Ultimately, the choice
    of sorting algorithm will depend on your specific needs and goals. By learning
    about the bubble sort algorithm, you can make more informed decisions about which
    algorithm is best for your needs.
  prefs: []
  type: TYPE_NORMAL
- en: FAQs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What is Bubble Sort?**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bubble sort is a sorting algorithm that uses comparison methods to sort an array.
    The algorithm compares pairs of elements in an array and swaps them if the left
    pair(position) is greater than the right pair(position+1). This process is repeated
    until the entire array is sorted.
  prefs: []
  type: TYPE_NORMAL
- en: '**How many passes does Bubble Sort require?**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bubble Sort requires n(n-1)/2 passes through all elements in order for the final
    array sorted in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the worst time complexity of Bubble Sort?**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The worst time complexity of Bubble Sort is O(n2).
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the worst time complexity of Bubble Sort?**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The best time complexity of Bubble Sort is O(n), and this occurs when the array
    is already sorted.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the space complexity of Bubble Sort?**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bubble sort has an O(1) space complexity, as it works in-place by modifying
    the input directly.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you found the article useful.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To connect with me or find more content similar to this article, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[**Support my writing**](https://richmondalake.medium.com/membership) by becoming
    a referred Medium member'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Subscribe to my [**YouTube channel**](https://www.youtube.com/channel/UCNNYpuGCrihz_YsEpZjo8TA)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Subscribe to my Podcast [**Apple Podcasts**](https://apple.co/3tbXlIa) **|**
    [**Spotify**](https://spoti.fi/38IIC06) **|** [**Audible**](https://amzn.to/3m62Vb3)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Subscribe to my [**Email List**](https://richmond-alake.ck.page/c8e63294ee)
    for my newsletters
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What to read next üëáüèæ
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](/merge-sort-explained-a-data-scientists-algorithm-guide-2f79d5034ba3?source=post_page-----853b2286e5ab--------------------------------)
    [## Merge Sort Explained‚ÄìA Data Scientist‚Äôs Algorithm Guide'
  prefs: []
  type: TYPE_NORMAL
- en: An explanation of the merge sort algorithm with an implementation in Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/merge-sort-explained-a-data-scientists-algorithm-guide-2f79d5034ba3?source=post_page-----853b2286e5ab--------------------------------)
  prefs: []
  type: TYPE_NORMAL
