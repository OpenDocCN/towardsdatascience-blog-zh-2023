- en: 'Understanding Predictive Maintenance — Wave Data: Feature Engineering (Part
    1)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/understanding-predictive-maintenance-wave-data-feature-engineering-part-1-fd22b6a19323](https://towardsdatascience.com/understanding-predictive-maintenance-wave-data-feature-engineering-part-1-fd22b6a19323)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: All the information you need to start learning about wave-data signal processing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://marcin-staskopl.medium.com/?source=post_page-----fd22b6a19323--------------------------------)[![Marcin
    Stasko](../Images/5142b9a260a1cce7c6a2ebcc16f46fbb.png)](https://marcin-staskopl.medium.com/?source=post_page-----fd22b6a19323--------------------------------)[](https://towardsdatascience.com/?source=post_page-----fd22b6a19323--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----fd22b6a19323--------------------------------)
    [Marcin Stasko](https://marcin-staskopl.medium.com/?source=post_page-----fd22b6a19323--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----fd22b6a19323--------------------------------)
    ·16 min read·Nov 21, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/443d342974ccbd2a69ea10cb885c6e55.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Lukas Tennie](https://unsplash.com/@luk10?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Article Purpose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’re about to dive into something cool — wave data signal processing. It’s
    a big deal in predictive maintenance, but also in other fields. I’m breaking it
    down step by step in this series, making it clear to understand. Got any thoughts
    to add? Feel free to share!
  prefs: []
  type: TYPE_NORMAL
- en: This article is part of the series Understanding Predictive Maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: '[Check the whole series in this link](https://marcin-staskopl.medium.com/list/understanding-predictive-maintenance-series-e1f44d8a0cc3).
    Ensure you don’t miss out on new articles by following me. All images without
    captions were created by me.'
  prefs: []
  type: TYPE_NORMAL
- en: Why does it matter if our analysis operates in the time domain?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Time domain analysis in signal processing is a method that focuses on signals
    based on their behavior and characteristics over time. Unlike frequency domain
    analysis which explores signal components in terms of their frequency content,
    time domain analysis provides insights into how signals change over different
    time intervals. This approach allows us to observe the variations, patterns, and
    trends exhibited by signals, providing valuable information about the dynamics
    and temporal aspects of a system or process.
  prefs: []
  type: TYPE_NORMAL
- en: Why it is important in predictive maintenance?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/dddbaf48b672be24871ebcba125e3993.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [James Lewis](https://unsplash.com/@jamesplewis?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: By applying this analytical technique to equipment data, maintenance professionals
    can identify and analyze temporal patterns in machinery performance. Monitoring
    changes over time helps in the early detection of anomalies or deviations from
    expected behavior, allowing for timely intervention to address potential issues
    before they escalate. This proactive approach to maintenance enhances equipment
    reliability, reduces downtime, and ultimately contributes to more cost-effective
    and efficient operational processes.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to comprehend the temporal aspects of signals through time domain
    analysis empowers industries to **move beyond reactive maintenance practices.**
    Predictive maintenance, informed by insights gained from time domain analysis,
    enables organizations to schedule maintenance activities based on the actual condition
    of equipment rather than arbitrary time intervals. This not only optimizes resource
    utilization but also extends the lifespan of machinery, translating into substantial
    cost savings and improved overall operational performance.
  prefs: []
  type: TYPE_NORMAL
- en: Vibration data — core of predictive maintenance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Understanding vibration data is crucial in predictive maintenance for several
    reasons. Firstly, abnormal vibrations are often early indicators of machinery
    malfunctions. By continuously monitoring and analyzing vibration data, maintenance
    teams can detect anomalies before they lead to critical failures. Secondly, vibration
    analysis provides insights into the specific nature of a potential issue, allowing
    for targeted and timely interventions. Lastly, by leveraging vibration data, predictive
    maintenance strategies can move away from routine, time-based maintenance to a
    more efficient, condition-based approach, optimizing equipment performance and
    minimizing downtime.
  prefs: []
  type: TYPE_NORMAL
- en: Feature Engineering Theory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the hands-on section, I will provide code examples for each feature, along
    with explanations to facilitate practical implementation. Let’s explore the theory
    behind feature engineering and its application in the context of vibration data
    analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '**Time-Domain Features**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this category, statistical measures such as mean, standard deviation, skewness,
    and kurtosis are calculated for each vibration signal. Additionally, we delve
    into metrics like the Root Mean Square (RMS) and Crest Factor to provide overall
    measures of signal energy and peak characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: '`Distibution Statistical Measures` Calculate statistical measures such as `mean`,
    `standard deviation`, `skewness`, and `kurtosis` for each vibration signal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RMS (Root Mean Square)` Provides a measure of the overall energy in the signal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Crest Factor` The ratio of the peak value to the `RMS` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frequency-Domain Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Transitioning to the frequency domain, we employ techniques like the `Fast Fourier
    Transform (FFT)` to convert time-domain signals. Extracted features include `dominant
    frequency`, `spectral entropy`, and `spectral kurtosis`. `Power Spectral Density
    (PSD)` offers insights into power distribution and harmonic relationships.
  prefs: []
  type: TYPE_NORMAL
- en: '`FFT (Fast Fourier Transform`) Convert the time-domain signal to the frequency
    domain. Extract features from the resulting spectrum, such as `dominant frequency`,
    `spectral entropy`, and `spectral kurtosis`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Power Spectral Density (PSD)` Describes how the power of a signal is distributed
    over frequency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time-Frequency Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Exploring the time-frequency domain involves techniques such as the `Wavelet
    Transform` and `Short-Time Fourier Transform (STFT)`, providing dynamic representations
    of signals and capturing changes in frequency content over time.
  prefs: []
  type: TYPE_NORMAL
- en: '`Wavelet Transform` Provides a time-frequency representation of the signal.
    Extract features from the wavelet coefficients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Short-Time Fourier Transform (STFT)` Represents how the frequency content
    of a signal changes over time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Envelope Analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Demodulation techniques, such as the `Hilbert transform` or `wavelet transform`,
    are employed to extract signal envelopes. Analyzing features within the envelope
    adds another layer of understanding.
  prefs: []
  type: TYPE_NORMAL
- en: '`Demodulation` Extract the envelope of the signal using techniques like `Hilbert
    transform` or `wavelet transform`. Analyze the features of the envelope.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statistical Measures Over Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rolling statistics, computed over fixed-size windows, allow the capture of trends
    and patterns. Additionally, higher-order statistical moments over windows, known
    as waveform moments, contribute valuable insights.
  prefs: []
  type: TYPE_NORMAL
- en: '`Rolling Statistics` Calculate statistical measures over fixed-size windows,
    capturing trends and patterns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Waveform Moments` Higher-order statistical moments over windows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recurrence Plots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Delving into recurrence plots and utilizing `Recurrence Quantification Analysis
    (RQA)` them allows discerning patterns in the data structure, providing a unique
    perspective on vibration signals.
  prefs: []
  type: TYPE_NORMAL
- en: '`Recurrence Quantification Analysis (RQA)` Analyze the structure of the recurrence
    plot to capture patterns in the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Domain-Specific Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Domain-specific features, such as `Peak Features` and `Shape Features`, are
    designed to identify and analyze peaks and the overall waveform shape in vibration
    signals.
  prefs: []
  type: TYPE_NORMAL
- en: '`Peak Features` Identify and analyze peaks in the vibration signal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Shape Features` Extract features related to the shape of the signal waveform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While these examples don’t encompass every possibility, some of them might prove
    useful for your needs. :)
  prefs: []
  type: TYPE_NORMAL
- en: Hand`s on experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../Images/2d66eb11a994c0f50a5a5efc709fb48b.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Amauri Mejía](https://unsplash.com/@amavcinema?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Now it is the time to make hands dirty by code. We will run some experiments
    to help you get familiarized with article concepts. I recommend you to reproduce
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Create the signal for experiments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to emulate the vibration signal and add more realism to reproduce the
    equipment wear
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this code, the wear is resetting after reaching specific value -simulation
    of equipment change
  prefs: []
  type: TYPE_NORMAL
- en: Let`s generate the signal and plot
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/37338e0659cdb53f7881626d24af2c50.png)'
  prefs: []
  type: TYPE_IMG
- en: Noisy signal with wear effect for next experiments
  prefs: []
  type: TYPE_NORMAL
- en: This article’s mission is to introduce you to these cool features. We’re not
    building the whole process here — no pipelines for us today. That’s a story for
    another article! Right now, let’s dive into the fun world of creating features
    from signals. Ready for the feature-fest? Let’s roll! 🚀
  prefs: []
  type: TYPE_NORMAL
- en: To window or not to window, that is the question.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/e1e0d4d57c1b486971d15460046207fa.png)'
  prefs: []
  type: TYPE_IMG
- en: Generated by me using DiscoDiffusion model
  prefs: []
  type: TYPE_NORMAL
- en: Time series windowing is like looking at snapshots of a continuous timeline,
    and it’s super helpful, especially in predictive maintenance. Imagine you’re watching
    a movie, but instead of watching the whole thing, you pause every few minutes
    and take a picture. These pictures are your “windows.” Now, these windows help
    us understand how things change over time. In the world of machines and equipment,
    where things can wear out or break, understanding how they behaved in the past
    helps us predict what might happen in the future.
  prefs: []
  type: TYPE_NORMAL
- en: One big plus of using these windows is that they make it easier to understand
    what’s going on. It’s like breaking down a big story into smaller chapters. Each
    window is a chapter, and by looking at them, we can spot any weird or interesting
    things that happened in that time frame. This detailed view helps us figure out
    why machines might be getting worn out or failing. Also, these windows help us
    deal with changes in how often we get information and handle any weird stuff in
    the data, making sure our predictions are solid.
  prefs: []
  type: TYPE_NORMAL
- en: But, of course, it’s not all sunshine and rainbows. Picking the right size for
    these windows is a bit tricky. If they’re too big or too small, we might miss
    important details or add in unnecessary noise. It’s like choosing the right lens
    for your camera — you want to capture just the right amount. Also, deciding whether
    these windows should overlap or not is a bit of a puzzle. Overlapping windows
    give more context, but too much overlap might make things repetitive. It’s like
    trying to balance how much backstory to include in each chapter of a book. Finding
    this sweet spot is key to making sure our predictions about machine maintenance
    are spot on.
  prefs: []
  type: TYPE_NORMAL
- en: Windowing example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: I’m going to throw a window party with different sizes to show you how it changes
    things up. It’s like Mean Windowing is our cool DJ, spinning averages within the
    window range. Let’s see how the dance floor of data grooves to the beat of different
    window sizes!
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0500ff9df2d8dcb7288e6d69bcb50f5f.png)'
  prefs: []
  type: TYPE_IMG
- en: Mean windowing with window size =2
  prefs: []
  type: TYPE_NORMAL
- en: With a window size of 2, it’s tough to see any clear patterns; it introduces
    too much noise. We need to increase the window size to get a better picture of
    what’s happening in the data.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8a2be5a64c5a4f77aa4fecc9c5fd4bcd.png)'
  prefs: []
  type: TYPE_IMG
- en: Mean windowing with window size = 200
  prefs: []
  type: TYPE_NORMAL
- en: Right now, the window is too big, and that’s not good because we’re losing a
    lot of details from the data. We want a window that’s just right to catch all
    the important stuff.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a7b9a89908eed7be62638caa420ee524.png)'
  prefs: []
  type: TYPE_IMG
- en: Mean windowing with window size = 20
  prefs: []
  type: TYPE_NORMAL
- en: With a window size of 20, the data pattern becomes distinctly visible, allowing
    us to discern the synthetic “wear effect” that was introduced during signal generation.
    When training your models, it’s essential to engage in trial and error to identify
    the optimal window size. For the purpose of this article, I will generate features
    by employing a window size of 20.
  prefs: []
  type: TYPE_NORMAL
- en: Time-Domain Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Distribution Statistical Measures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/fb35bae6da5b5d496237cbba0b31b69b.png)'
  prefs: []
  type: TYPE_IMG
- en: Distribution statistics (Latex compiled)
  prefs: []
  type: TYPE_NORMAL
- en: Let`s play with distribution measures. Of course I might skip the `mean` and
    `standard deviation` because its obvious but I have tried to make a little fun
    to keep the standard of this article explaining each stuff in depth.
  prefs: []
  type: TYPE_NORMAL
- en: '**Mean**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine you and your friends are at a pizza party. Everyone loves pizza with
    various toppings. This `mean` is like figuring out the average number of pepperoni
    slices each person has on their pizza. If one friend has a lot and another friend
    has just a few, the mean helps you know how much pepperoni to expect per person
    on average. It’s like finding the pizza harmony!
  prefs: []
  type: TYPE_NORMAL
- en: '**Standard Deviation**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let’s talk about `standard deviation`. Picture a group of cats. Some cats
    are super chill and lazy, while others are hyperactive and playful. This `standard
    deviation` is like measuring how much each cat’s energy level deviates or differs
    from the average energy level of all the cats. If the standard deviation is high,
    you’ve got a mix of lazy and hypercats. If it’s low, most of the cats have similar
    energy levels — maybe a laid-back cat party!
  prefs: []
  type: TYPE_NORMAL
- en: '**Skewness**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s use a fruit basket scenario to understand the difference between `positive`
    and `negative` `skewness` more clearly.
  prefs: []
  type: TYPE_NORMAL
- en: '`Positive Skewness (Fruitful to the Right)` Imagine your friends are filling
    a fruit basket. Most friends decide to add a variety of fruits, but a couple of
    them go all out, adding extra bananas, apples, and oranges. The fruit basket seesaw
    tilts to the right because of this extra fruity enthusiasm. This is `positive
    skewness`, indicating that there’s an extended excitement toward more in the right
    direction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Negative Skewness (Light to the Left)` Now, suppose a few friends decide to
    keep it light, adding only a few grapes and berries to the basket. The seesaw
    tilts to the left because of this lighter fruity approach. This is `negative skewness`,
    signaling a leaning towards less in the left direction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kurtosis**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, imagine you’re on a rollercoaster. Some rollercoasters are wild and full
    of twists, while others are gentler. `Kurtosis` is our rollercoaster critic, assessing
    how crazy the ride is. `Positive kurtosis` means the rollercoaster has sharp turns
    and unexpected loops while `negative kurtosis` suggesting a smoother, milder ride.
    `Kurtosis` is the thrill factor of our statistical theme park!
  prefs: []
  type: TYPE_NORMAL
- en: Skewness comparison
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/3a663f428a3c425f8d4ac46e4b0e7265.png)'
  prefs: []
  type: TYPE_IMG
- en: Skewness comparison plots with mean and median
  prefs: []
  type: TYPE_NORMAL
- en: '`Normal` distributions have data spread evenly on both sides, with the mean
    closely aligned with the median.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Positive / Right-skewed` distributions have a longer or fatter tail on the
    right side, indicating more data points on the left. The mean is typically greater
    than the median'
  prefs: []
  type: TYPE_NORMAL
- en: '`Negative / Left-skewed` distributions have a longer or fatter tail on the
    left side, suggesting more data points on the right. The mean is usually less
    than the median.'
  prefs: []
  type: TYPE_NORMAL
- en: Kurtosis comparison
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/cac8934a7af04e8cfbfd73975f1bfb6a.png)'
  prefs: []
  type: TYPE_IMG
- en: Kurtosis plots comparison
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s compute the statistics for comparison.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/7079ae0c7912df4e32a8a1c77f6c992d.png)'
  prefs: []
  type: TYPE_IMG
- en: Calculated statistics output
  prefs: []
  type: TYPE_NORMAL
- en: '**Normal Distribution**'
  prefs: []
  type: TYPE_NORMAL
- en: '`Skewness` -0.0237 (slightly negatively skewed)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Kurtosis` 0.1356 (platykurtic, flatter than normal)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Positively Skewed Distribution**'
  prefs: []
  type: TYPE_NORMAL
- en: '`Skewness` 1.3753 (strongly positively skewed)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Kurtosis` 2.7358 (leptokurtic, heavier tails than normal)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Negatively Skewed Distribution**'
  prefs: []
  type: TYPE_NORMAL
- en: '`Skewness` -1.3357 (strongly negatively skewed)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Kurtosis` 2.4060 (leptokurtic, heavier tails than normal)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Leptokurtic Distribution (Heavier Tails)**'
  prefs: []
  type: TYPE_NORMAL
- en: '`Skewness` 1.8463 (positively skewed)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Kurtosis` 4.4461 (high kurtosis, very heavy tails)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Platykurtic Distribution (Lighter Tails)
  prefs: []
  type: TYPE_NORMAL
- en: '`Skewness` -0.0243 (slightly negatively skewed)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Kurtosis` -1.1587 (platykurtic, much lighter tails than normal)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply the statistics using the rolling window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/b2c9ce7979e80149532c3522cb8403de.png)'
  prefs: []
  type: TYPE_IMG
- en: Rolling Window explanation (Latex compiled)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: And plot the results I will separate `skewnes` and `kurtosis` for better visibility
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/9ac1de43ee46823973412ba00d819ffc.png)'
  prefs: []
  type: TYPE_IMG
- en: The roling application vs original signal
  prefs: []
  type: TYPE_NORMAL
- en: Observing the results, it’s evident that the rolling window serves as an effective
    denoising technique. I suggest experimenting with various window sizes, as Data
    Science often involves empirical exploration through trial and error.
  prefs: []
  type: TYPE_NORMAL
- en: '**Behind the** `**.apply()**` **scenes**'
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a little extra something to show you how the function and windowing play
    together in backstage. I’ll do it just this once to give you a peek into how the
    apply function does its thing when it comes to windowing, using our straightforward
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`mean_values` This is calculated using the `np.convolve` function, which performs
    a convolution operation. In this case, it calculates the rolling mean by convolving
    the signal with a window of ones divided by the window size. The `mode=''valid''`
    argument ensures that the convolution is performed only where the full window
    can fit without zero-padding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std_dev_values` This is calculated by iterating over the signal using a list
    comprehension. For each position `i` in the signal, it computes the standard deviation
    of the subarray `signal[i-window_size+1:i+1]`. This represents the rolling standard
    deviation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skewness_values` Similar to standard deviation, it''s computed by iterating
    over the signal using a list comprehension. For each position `i`, it calculates
    the skewness of the subarray `signal[i-window_size+1:i+1]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kurtosis_values` Again, similar to standard deviation and skewness, it''s
    computed by iterating over the signal using a list comprehension. For each position
    `i`, it calculates the kurtosis of the subarray `signal[i-window_size+1:i+1]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RMS (Root Mean Square)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/fd8cd5ae76655c003d55b48d25446c4a.png)'
  prefs: []
  type: TYPE_IMG
- en: RMS equation (Latex compiled)
  prefs: []
  type: TYPE_NORMAL
- en: '`Root Mean Square (RMS)` is like a mathematical superhero. It takes a group
    of numbers, squares each one, finds the average, and then takes the square root.
    This process gives you a single number that represents the typical size or intensity
    of the original numbers. It’s a handy tool in various fields, from measuring vibrations
    in machinery to assessing the power of signals.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/557730c49a8c3c7543c6692536295851.png)'
  prefs: []
  type: TYPE_IMG
- en: RMS unveils a single, robust metric that captures the underlying signal power
    while effectively mitigating noise. This plot serves as a visual testament to
    the practical efficacy of RMS in enhancing signal clarity and precision across
    diverse applications.
  prefs: []
  type: TYPE_NORMAL
- en: Crest Factor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/76a055904ff4b3fbe4904da207b4d139.png)'
  prefs: []
  type: TYPE_IMG
- en: Crest Factor equation (Latex compiled)
  prefs: []
  type: TYPE_NORMAL
- en: '`Crest Factor (CF)` is like the sidekick `Root Mean Square (RMS)` in the world
    of signal analysis. While `RMS` it gives you the overall intensity, `Crest Factor`
    it steps in to highlight the peaks. It’s the ratio of the highest point to the
    RMS value, telling you how spiky or ‘cresty’ your signal is. Think of `CF` as
    the superhero partner that helps you understand the sharp peaks in your data,
    whether it’s in sound waves, electrical signals, or any other fluctuating measurements.
    Together with, they form a dynamic duo for unraveling the secrets hidden in your
    data'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Create the plot
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/505b32fada57e46cd242c26a09fa0677.png)'
  prefs: []
  type: TYPE_IMG
- en: Imagine `RMS` and `CF` as a dynamic duo in signal analysis. `RMS` is like the
    overall strength expert, giving you a big-picture view by crunching numbers. It
    squares, averages, and roots to show how intense the signal is. Now, meet, the
    peak detective. It focuses on the spiky parts of the signal, pointing out where
    things get really high. Together, they make a cool team, helping you understand
    both the general strength and the sharp peaks in your data.
  prefs: []
  type: TYPE_NORMAL
- en: That concludes part 1! We’ve delved into the theoretical groundwork and put
    it into practice with feature crafting examples. In the upcoming segment of this
    series, I’ll unravel the details of the next set of features. Stay tuned for more
    exciting insights!
  prefs: []
  type: TYPE_NORMAL
- en: This article is part of the series Understanding Predictive Maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: '[Check the whole series in this link](https://marcin-staskopl.medium.com/list/understanding-predictive-maintenance-series-e1f44d8a0cc3).
    Ensure you don’t miss out on new articles by following me.'
  prefs: []
  type: TYPE_NORMAL
