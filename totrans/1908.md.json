["```py\npip install --upgrade scalecast\nconda install tensorflow\nconda install shap\nconda install -c conda-forge cmdstanpy\npip install prophet\n```", "```py\nimport pandas as pd\nimport numpy as np\nfrom scalecast.Forecaster import Forecaster\nfrom scalecast.util import metrics\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\ndef read_data(idx = 'H1', cis = True, metrics = ['smape']):\n    info = pd.read_csv(\n        'M4-info.csv',\n        index_col=0,\n        parse_dates=['StartingDate'],\n        dayfirst=True,\n    )\n    train = pd.read_csv(\n        f'Hourly-train.csv',\n        index_col=0,\n    ).loc[idx]\n    test = pd.read_csv(\n        f'Hourly-test.csv',\n        index_col=0,\n    ).loc[idx]\n    y = train.values\n    sd = info.loc[idx,'StartingDate']\n    fcst_horizon = info.loc[idx,'Horizon']\n    cd = pd.date_range(\n        start = sd,\n        freq = 'H',\n        periods = len(y),\n    )\n    f = Forecaster(\n        y = y, # observed values\n        current_dates = cd, # current dates\n        future_dates = fcst_horizon, # forecast length\n        test_length = fcst_horizon, # test-set length\n        cis = cis, # whether to evaluate intervals for each model\n        metrics = metrics, # what metrics to evaluate\n    )\n\n    return f, test.values\n\nf, test_set = read_data()\nf # display the Forecaster object\n```", "```py\nf.set_estimator('naive')\nf.manual_forecast(seasonal=True)\n```", "```py\nf.set_estimator('arima')\nf.manual_forecast(\n    order = (5,1,4),\n    seasonal_order = (1,1,1,24),\n    call_me = 'manual_arima',\n)\n```", "```py\nf.set_estimator('rnn')\nf.manual_forecast(\n    lags = 48,\n    layers_struct=[\n        ('LSTM',{'units':100,'activation':'tanh'}),\n        ('LSTM',{'units':100,'activation':'tanh'}),\n        ('LSTM',{'units':100,'activation':'tanh'}),\n    ],\n    optimizer = 'Adam',\n    epochs = 15,\n    plot_loss = True,\n    validation_split=0.2,\n    call_me = 'rnn_tanh_activation',\n)\n\nf.manual_forecast(\n    lags = 48,\n    layers_struct=[\n        ('LSTM',{'units':100,'activation':'relu'}),\n        ('LSTM',{'units':100,'activation':'relu'}),\n        ('LSTM',{'units':100,'activation':'relu'}),\n    ],\n    optimizer = 'Adam',\n    epochs = 15,\n    plot_loss = True,\n    validation_split=0.2,\n    call_me = 'rnn_relu_activation',\n)\n```", "```py\nf.set_estimator('prophet')\nf.manual_forecast()\n```", "```py\nresults = f.export(determine_best_by='TestSetSMAPE')\nms = results['model_summaries']\nms[\n    [\n        'ModelNickname',\n        'TestSetLength',\n        'TestSetSMAPE',\n        'InSampleSMAPE',\n    ]\n]\n```", "```py\nf.plot(order_by=\"TestSetSMAPE\",ci=True)\nplt.show()\n```", "```py\n f.add_signals(\n    f.history.keys(), # add signals from all previously evaluated models\n)\nf.add_ar_terms(48)\nf.set_estimator('catboost')\n```", "```py\nf.manual_forecast(\n    Xvars='all',\n    call_me='catboost_all_reg',\n    verbose = False,\n)\nf.manual_forecast(\n    Xvars=[x for x in f.get_regressor_names() if x.startswith('AR')], \n    call_me = 'catboost_lags_only',\n    verbose = False,\n)\nf.manual_forecast(\n    Xvars=[x for x in f.get_regressor_names() if not x.startswith('AR')], \n    call_me = 'catboost_signals_only',\n    verbose = False,\n)\n```", "```py\ntest_results = pd.DataFrame(index = f.history.keys(),columns = ['smape','mase'])\nfor k, v in f.history.items():\n    test_results.loc[k,['smape','mase']] = [\n        metrics.smape(test_set,v['Forecast']),\n        metrics.mase(test_set,v['Forecast'],m=24,obs=f.y),\n    ]\n\ntest_results.sort_values('smape')\n```", "```py\nfig, ax = plt.subplots(figsize=(12,6))\nf.plot(\n    models = ['catboost_all_reg','catboost_signals_only'],\n    ci=True,\n    ax = ax\n)\nsns.lineplot(\n    x = f.future_dates, \n    y = test_set, \n    ax = ax,\n    label = 'held out actuals',\n    color = 'darkblue',\n    alpha = .75,\n)\nplt.show()\n```", "```py\nf.export_feature_importance('catboost_all_reg')\n```"]