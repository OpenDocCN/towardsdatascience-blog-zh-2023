- en: 'Data Filtering In Julia: Everything You Need To Know'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/data-filtering-in-julia-everything-you-need-to-know-d0bf08a00328](https://towardsdatascience.com/data-filtering-in-julia-everything-you-need-to-know-d0bf08a00328)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Everything you need to know when it comes to data filtering in Julia
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://emmaccode.medium.com/?source=post_page-----d0bf08a00328--------------------------------)[![Emma
    Boudreau](../Images/f7201d012b733643d6e97957f73fd1fa.png)](https://emmaccode.medium.com/?source=post_page-----d0bf08a00328--------------------------------)[](https://towardsdatascience.com/?source=post_page-----d0bf08a00328--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----d0bf08a00328--------------------------------)
    [Emma Boudreau](https://emmaccode.medium.com/?source=post_page-----d0bf08a00328--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----d0bf08a00328--------------------------------)
    ·7 min read·Jul 11, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0d8be971b1ee16caf88f89d7affa2ca9.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Najib Kalil](https://unsplash.com/@nkalil?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to Data Science, performing hypothesis tests, machine-learning,
    and even analytics, the most important component to getting results is having
    good data. There are a multitude of different requirements for data that often
    need to be imposed on that data. One technique that is incredibly common and is
    frequently used in the world of data is data filtering. Data filtering may either
    be the process of removing components of data that do not belong or the process
    of grabbing a sample that fits a certain parameter or number of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: We might say that an example of removing data when it does not belong with filtering
    is when we remove missing values from our data. This is an essential step in the
    Data Science process and is often done with filtering techniques. An example of
    grabbing a sample that fits some set parameters would be if we were trying to
    test statistical significance between being tall and bumping your head. We would
    filter out all of the data where people are short so that we had data of exclusively
    tall people to test with.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are numerous applications of this technique. Filtering may also be essential
    for performing some common Data Science tasks, so it is certainly something to
    be aware of. Luckily, filtering in Julia is relatively straightforward. If you
    would like to try the code in this article, here is a link to this overview in
    notebook format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Julia/data%20filtering%20in%20julia.ipynb?source=post_page-----d0bf08a00328--------------------------------)
    [## Emmetts-DS-NoteBooks/Julia/data filtering in julia.ipynb at master · emmettgb/Emmetts-DS-NoteBooks'
  prefs: []
  type: TYPE_NORMAL
- en: Random notebooks for various projects. Contribute to emmettgb/Emmetts-DS-NoteBooks
    development by creating an account…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: github.com](https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Julia/data%20filtering%20in%20julia.ipynb?source=post_page-----d0bf08a00328--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: In order to really understand filtering in Julia, there are a few different
    things that we need to know about. **Anonymous functions** will often be provided
    as arguments, though any form of function as an argument including the `do` syntax
    is possible. In some cases, we might also utilize a type of `Vector` called a
    `**BitArray**` .
  prefs: []
  type: TYPE_NORMAL
- en: BitArray
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `BitArray` is a `Vector` that contains only `Bool` type values. In Julia,
    `Array` is simply an alias for `Vector` . Generally in mathematics, we consider
    a `Vector` to specifically describe a 1-dimensional array… Usually a single column
    of features. In the case of the `BitArray` , we should note that this might also
    go by the name `BitVector` . This is what will be returned from most bitwise bool
    operators when broadcasted with `.`, such as `.==` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Although this type is quite similar to a `Vector{Bool}` , it is important to
    remember this type does exist as it will be a return from the operators, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Anonymous functions in Julia can certainly look a little difficult to grasp
    at first, but are relatively simple once the syntax is understood. If you would
    like to read a more in-depth overview of anonymous functions in Julia, here is
    an article I have written detailing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/what-on-earth-is-an-anonymous-function-f8043eb845f3?source=post_page-----d0bf08a00328--------------------------------)
    [## What On Earth Is An Anonymous Function?'
  prefs: []
  type: TYPE_NORMAL
- en: Uncovering the ins and outs of anonymous functions and types in Julia
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/what-on-earth-is-an-anonymous-function-f8043eb845f3?source=post_page-----d0bf08a00328--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous functions are just like normal functions, only the function is not
    defined under a type. Allow me to make that make more sense by explaining a bit
    more about Julia functions. Whenever we create a function normally in Julia, this
    function becomes defined under a name and has a type. This is a singleton, and
    this type has methods that are registered with the type of (`typeof`) this method
    inside of them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can access the methods of a new function using the `methods` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Whenever we create an anonymous function, the function name becomes undefined
    — we can only have one method for an anonymous function for this reason. This
    is useful if we just want a function to do something quick for us, for example,
    filtering. To write an anonymous function, we use the logical right operator.
    In a lot of ways, it is a lot like if we replaced the `=` in a normal function
    declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The arguments for the anonymous function go on the left side of the operator,
    the function itself goes on the right. We could use an annotation to make this
    a bit more clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: One of the great things about Julia is the language’s extensibility. With Julia,
    all of the modules can utilize the functions provided by the `Base` module to
    add new methods. In other words, modules can blend seemlessly with the `Base`
    and often be treated like `Base` types. This means that if we learn how these
    methods work with `Base` we will probably be able to carry a lot of that knowledge
    with us into other modules. Today we will demonstrate this by starting with `Base`
    and then expanding into filtering a different structure from a dependency, a `DataFrame`
    from `DataFrames` .
  prefs: []
  type: TYPE_NORMAL
- en: Filtering base types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a few different techniques that can be used to filter a simple `Vector`
    . One feature that I think is relatively new to Julia is the ability to provide
    conditional masks as indexes. I am not sure how long this has been included with
    `Base` , but this is certainly an awesome feature, as I love conditional masks.
    To create a conditional mask, we need to make one of the `BitArrays` we talked
    about earlier. In this instance, we will broadcast a comparison operator again.
    Here we will filter any value above 14 out of x:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, we could utilize the `filter` methods. These are `filter` and
    `filter!` . These two methods do the same exact thing, the only difference is
    that `filter!` is a mutating method. This is precisely what the `!` in function
    names is meant to represent. I find that to be a really cool standard as it does
    certainly make it easier to discern when things are being mutated and when they
    are not. I think that is a great thing to know, especially when it comes to Data
    Science. The `filter` method is provided with a `Function` as the first positional
    argument and then our `Vector` as the second positional argument. This might change
    slightly if the type is not a `Vector` , so keep that in mind.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Given that we used `filter` instead of `filter!` here, we would need to set
    `x` equal to the return to enforce these changes. Another thing we can filter
    using this technique is dictionaries. Rather than providing the type of each element
    in the `Vector` , we instead work with a `Pair` .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Because the function is the first positional argument, this also opens up the
    ability to utilize the do syntax, so definitely keep this in mind.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Filtering dataframes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another common type of structure that might need to be filtered is the `DataFrame`
    . This is a bit different because it is a dependency and a module, not just a
    portion of `Base` .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `filter` method when used on a `DataFrame` will provide a `DataFrameRow`
    to the function. This is a cool type, we can index it pretty easily and this makes
    filtering a breeze.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: That really is all there is to it, and with the preexisting knowledge from `Base`
    , it might be hard to find things that are not possible to filter with this technique!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data filtering is an essential step in the process of working with data. Filtering
    techniques allow us to remove observations that might be impeding any sort of
    real analysis of modeling. Luckily, Julia being a Scientific computing language
    has considered the importance of this and the `Base` tools provided by the language
    work pretty well for this! Furthered, Julia is built in a way where the functions
    that comprise the `Base` can have additional methods added in order to add functionality.
  prefs: []
  type: TYPE_NORMAL
- en: What this creates is one of my favorite things about Julia. It is common in
    the programming world to have familiarity with a certain ecosystem or set of packages.
    Just because I know how to use NumPy does not mean I know how to use Dask, for
    example. With Julia, things are bit different because it is entirely possible
    that a Dask or NumPy equivalent would both use the same method. We see this in
    the application of `filter` on `DataFrames` . This helps to save cost on singletons
    and also helps the users of the packages to reuse old knowledge. Needless to say,
    Julia is a great language to work with data in — and this is no different in the
    application of data filtering.
  prefs: []
  type: TYPE_NORMAL
