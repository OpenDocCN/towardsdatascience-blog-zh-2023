- en: 'Window Functions: A Must Know for Data Engineers and Data Scientists'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/window-functions-a-must-know-for-data-engineers-and-data-scientists-4dd3e4ad0d2](https://towardsdatascience.com/window-functions-a-must-know-for-data-engineers-and-data-scientists-4dd3e4ad0d2)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Back To Basics | Demystifying SQL Window Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://iffatm.medium.com/?source=post_page-----4dd3e4ad0d2--------------------------------)[![Iffat
    Malik](../Images/7be3b651053507de2077b3c3c9d3a408.png)](https://iffatm.medium.com/?source=post_page-----4dd3e4ad0d2--------------------------------)[](https://towardsdatascience.com/?source=post_page-----4dd3e4ad0d2--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----4dd3e4ad0d2--------------------------------)
    [Iffat Malik](https://iffatm.medium.com/?source=post_page-----4dd3e4ad0d2--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----4dd3e4ad0d2--------------------------------)
    ·13 min read·Jun 14, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/14add0fff137d8af56d3fda795403145.png)'
  prefs: []
  type: TYPE_IMG
- en: Data growth has been pretty extensive in the past few years and even though
    we have a diverse set of tools and technologies at our disposal, SQL still remains
    at the core of most of them. It’s one of the fundamental languages for data analysis
    and is widely employed by companies at all scales for solving data-related challenges.
  prefs: []
  type: TYPE_NORMAL
- en: I always believe you do not need to know certain concepts just for the sake
    of clearing the interview or solving a particular problem. If you care to learn
    the concept and underlying architecture it will help you conquer work anywhere
    you go. Window Functions are a bit tricky and one might feel a little intimidated
    at first but once you get a hold of it, they are most fun to work with.
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be easier to understand the concept of Window Functions if you are
    familiar with SQL Aggregate Functions. Aggregate Functions perform the calculation
    on a set of values and return one value; when paired with *GROUP BY*clause, it
    returns a single value for each group. You can read more about it here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/how-to-use-sql-aggregate-functions-92f7244a07cb?source=post_page-----4dd3e4ad0d2--------------------------------)
    [## SQL Aggregate Functions for your next Data Science interview'
  prefs: []
  type: TYPE_NORMAL
- en: Back To Basics | SQL fundamentals for beginners
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/how-to-use-sql-aggregate-functions-92f7244a07cb?source=post_page-----4dd3e4ad0d2--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Before going any further, let me introduce you to the sample database. We will
    be using data from a dummy vehicle retailer company, you can find source data
    in my [GitHub Repo](https://github.com/PhoenixIM/All_Things_SQL),
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/689057cd098a835bb0c46c8a2df2b2dd.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: What are Window Functions?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The traditional definition of a Window Function is,
  prefs: []
  type: TYPE_NORMAL
- en: A Window Function performs calculations across a set of table rows that are
    somehow related to the current row.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If I break it down, Window Functions enable us to perform calculations against
    partitions. Partition is simply a user-defined set, subgroup or bucket of rows
    on which the window function will perform calculations.
  prefs: []
  type: TYPE_NORMAL
- en: They are also widely known as *Analytic Functions.*
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need Window Functions?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we know, Aggregate Functions summarise the data from multiple rows into a
    single row (if used along with GROUP BY clause then a single row for each group);
    whereas, Window Functions also perform calculations on a set of rows but unlike
    Aggregate Functions they do not summarise the result set into a single row. Instead,
    all the rows maintain their original form/identity and the calculated row is added
    to the result set for every row.
  prefs: []
  type: TYPE_NORMAL
- en: Sounds funny, huh? Let’s break it down. Here is the sample data from the table
    PRODUCTS,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/651d9f7af58f9aca574103ea1bbf35a7.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Say, we need the information about the average buy pricefor each *PRODUCTCATEGORY*,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/1314327e8368f826b1ae1397fd1914e0.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Now, this information alone won’t be much of a use. Yes! Now you do know the
    average buy price for each *PRODUCTCATEGORY,* but what next? How does this information
    produce business insight? What if I want to compare the buy price of each product
    with the average buy price of the particular *PRODUCTLCATEGORY*? Let me rephrase
    my new requirement,
  prefs: []
  type: TYPE_NORMAL
- en: Display the buy price of each product within the *PRODUCTCATEGORY* along with
    the average buy price for that *PRODUCTCATEGORY*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Arrange the result set grouped by *PRODUCTCATEGORY*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Would you be able to achieve this with normal Aggregate Function alone? The
    above stated requirement wants to display some information as it is (e.g. *PRODUCTCATEGORY*,
    *PRODUCTNAME*, *BUYPRICE* in the original form) and additionally wants a new column
    displaying the average buy price for each *PRODUCTCATEGORY* as well. That’s where
    the heroic Window Function comes to the rescue,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/d58f53fcd3b6071e46bc0382822931f6.png)'
  prefs: []
  type: TYPE_IMG
- en: GIF by author
  prefs: []
  type: TYPE_NORMAL
- en: Before we jump start to commonly used Window Functions, let’s understand the
    basic syntax and clauses paired with it.
  prefs: []
  type: TYPE_NORMAL
- en: The general syntax of a Window Function is,
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7231354dacbfef3c29dd5f72b36ffd52.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Where,
  prefs: []
  type: TYPE_NORMAL
- en: '***OVER()*** clausedefines a user-specific set of rows. A Window Function would
    then performs a calculation on that specific set only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is used specifically with Window Functions; however, it can also be used
    with Aggregate Functions, just like we used it with the *AVG()* function above,
    and in doing so turning it into a Window Function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you do not supply anything inside of *OVER()*, the Window Function will be
    applied to the entire result set.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '***PARTITION BY*** is used with *OVER* clause. It divides the query result
    set into partitions and then the Window Function applies to each partition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s optional, so if you do not specify *PARTITION BY* clause*,* thenthe function
    treats all rows as a single partition.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '***ORDER BY***clause is used to sort the result set in either ascending or
    descending order within each partition of the result set. By default, it’s in
    ascending order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***ROWS/RANGE*** is a part of the *FRAME* clause which defines a subset within
    the partition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can read about a detailed comparison of Window vs Aggregate Function and
    Window Function clauses here, [*Anatomy of SQL Window Functions*](https://medium.com/towards-data-science/anatomy-of-sql-window-functions-7256d8cf509a).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are familiar with the basic anatomy of a Window Function, let’s
    explore the most commonly used one,
  prefs: []
  type: TYPE_NORMAL
- en: ROW_NUMBER()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*ROW_NUMBER()* assigns a sequential integer number to each row of a table or
    a partition in case we are using *PARTITION BY* clause. The common syntax is,'
  prefs: []
  type: TYPE_NORMAL
- en: '**ROW_NUMBER() OVER ([PARTITION BY clause] [ORDER BY clause])**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Here is the sample data from the table *PRODUCTS,* it holds the data of a range
    of products available with the vehicle retailer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/651d9f7af58f9aca574103ea1bbf35a7.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start basic,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/81e19d655d73883c4fe47b86506f573f.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Here, *ROW_NUMBER()* has assigned a sequential integer number starting from
    1 to each row of the table *PRODUCTS*. Let’s level it up a little by adding row
    numbers for each *PRODUCTCATEGORY,* for that we will have to use *PARTITION BY*
    clause.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/986bf791956b8f08782d34ff9e44635c.png)'
  prefs: []
  type: TYPE_IMG
- en: GIF by author
  prefs: []
  type: TYPE_NORMAL
- en: We have the 2 distinct *PRODUCTCATEGORY* available in the *PRODUCTS* table,
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1d485e42300dcec74d98116328e33225.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: '*ROW_NUMBER()* generated a sequential integer number for each row and *PARTITION
    BY* clause, broke down the resultset into bucketsbased on *PRODUCTCATEGORY*. So
    basically *ROW_NUMBER()* along with *OVER* and *PARTITION B*Y clause, generated
    a unique sequence of numbers for each *PRODUCTCATEGORY.*'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s utilize the *ORDER BY* clause as well. This was also one of the most
    asked interview questions at the entry/intermediate level. Say, we want to know
    the top 3 products from each *PRODUCTCATEGORY* with the highest quantity in stock
    available.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/f551b9eebdd985b47e38cde3518811eb.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first break down the entire query into two parts, as shown in the following
    image; first, we are creating a *PRODUCT_INVENTORY.* The table data will be divided
    into partitions/groups of each *PRODUCTCATEGORY*, ordered in descending order
    of the quantity available in stock for each product category. *ROW_NUMBER()* will
    then generate sequential integer numbers for each partition. The cool part here
    is, the row number for each row is sort of reset for each *PRODUCTCATEGORY*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/16e509f3e781da65e904a9c5fa36a8ee.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: The above query will return the following result,
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/daa97b7f18233566468a8e77be17ffb9.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Now the second part of our query is pretty straightforward. It will utilize
    this result-set as an input and will pick up the top 3 products from each *PRODUCTCATEGORY*
    based on the condition *ROW_NUM ≤ 3*. The final result is as follows,
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1c5adf8b10295d05bfdb26c5db4c8f42.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: That leads us to the final result as,
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d852588165ed8e1da3cb84eba7daf198.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: RANK()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the name suggests, *RANK()* assigns a rank to each row of the table or each
    row in a partition. The general syntax is,
  prefs: []
  type: TYPE_NORMAL
- en: '**RANK() OVER ([PARTITION BY clause] [ORDER BY clause])**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Continuing to our *PRODUCTS* table example, let us assign a rank to products
    based on the quantity available in stock in descending order, partitioned by *PRODUCTCATEGORY*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/d47aae5563f60fa0405ba9cca27e0269.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: I have limited the result-set for demo purpose. Now, Don’t get mixed up between
    *ROW_NUMBER()* and *RANK()*. The result-set for both of them may look alike; however,
    there is a difference. *ROW_NUMBER()* assigns a unique sequential integer number
    to each row of a table or in a partition; whilst, *RANK()* too generates a sequential
    integer number to each row of a table or in a partition but it assigns the same
    rank for rows with the same values.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s understand this with an example, here is the sample data from the table
    *CUSTOMERS*,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/9b2c26bb8b1673ed9f92ebc50cee7f86.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: In the following demo, I have generated *ROW_NUMBER()* and *RANK()* for the
    table *CUSTOMERS*, ordered in descending order of their *CREDITLIMIT*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/279568a1777a1ae809b303f52c82d114.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: I have limited the result-set for demo purpose. Highlighted in green is *ROW_NUMBER()*
    and highlighted in blue is *RANK().*
  prefs: []
  type: TYPE_NORMAL
- en: Now if you refer to 3 records highlighted in red, that’s where the result-set
    for both the function differs; *ROW_NUMBER()*generated a unique sequential integer
    number for all the rows. But on the other hand, *RANK()* assigned the same rank,
    ***20***, for *CUSTOMERID* ***239*** and ***321*** since they have the same credit
    limit, which is ***105000.00***. Not just that, for the next record, that is *CUSTOMERID*
    ***458***, it skipped rank ***21*** and assigned it rank ***22***.
  prefs: []
  type: TYPE_NORMAL
- en: DENSE_RANK()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now if you are wondering, why do we need *DENSE_RANK()* if we are already equipped
    with *RANK()*? As we already witnessed in the previous example, *RANK()* generates
    the same rank for rows with the same values and then it skips the next consecutive
    rank(refer to the above image).
  prefs: []
  type: TYPE_NORMAL
- en: '*DENSE_RANK()* is similar to the *RANK()* except for this one difference, it
    doesn’t skip any ranks when ranking the rows. The common syntax is,'
  prefs: []
  type: TYPE_NORMAL
- en: '**DENSE_RANK() OVER ([PARTITION BY clause] [ORDER BY clause])**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Going back to *CUSTOMERS* table, let’s compare result-set for both *RANK()*
    and *DENSE_RANK()*,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/fede63360bf9a057ab071a2c6d8bf7a9.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Similar to *RANK()* (highlighted in blue)*, DENSE_RANK() (*highlighted in green),
    generated the same rank for *CUSTOMERID* ***239*** and ***321****,* what *DENSE_RANK()*
    did differently is instead of skipping the next consecutive number like *RANK()*
    did, it maintained the sequence and assigned ***21*** rank to *CUSTOMERID* ***458***.
  prefs: []
  type: TYPE_NORMAL
- en: NTH_VALUE()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a bit different than what we have discussed so far. *NTH_VALUE()* will
    return the value of the *Nth* row from the expression in a specified window. The
    common syntax is,
  prefs: []
  type: TYPE_NORMAL
- en: '**NTH_VALUE(expression, N) OVER ([PARTITION BY clause] [ORDER BY clause] [ROW/RANGE
    clause])**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*’N’* must be the positive integer value. If data doesn’t exist on *Nth* position,
    the function will return *NULL*. Here if you have noticed, we have an additional
    clause in the syntax which is the *ROW/RANGE* clause*.*'
  prefs: []
  type: TYPE_NORMAL
- en: RAW/RANGE is part of the *Frame Clause* in Window Function which defines a subset
    within a window partition. *ROW/RANGE* defines the start and end points of this
    subset with respect to the current row, you take your current row’s location as
    a base point, and with that reference, you define your frame within the partition.
  prefs: []
  type: TYPE_NORMAL
- en: '*ROWS* - This defines the beginning and end of the frame by specifying the
    number of rows that precede or follow the current row.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*RANGE* - Contrary to the *ROWS*, *RANGE* specifies the range of values compared
    to the value of the current row to define a frame within the partition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic syntax is,
  prefs: []
  type: TYPE_NORMAL
- en: '**{ROWS | RANGE} BETWEEN <frame_starting> AND <frame_ending>**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/3849aa0e5961ada988e8b08e89b4b5b5.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you use *ORDER BY* clause, it sets the default frame as,
  prefs: []
  type: TYPE_NORMAL
- en: '*{ROWS/RANGE} BETWEEN* **UNBOUNDED PRECEDING** *AND* **CURRENT ROW**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Without ORDER BY clause, the default frame as,
  prefs: []
  type: TYPE_NORMAL
- en: '*{ROWS/RANGE}* BETWEEN **UNBOUNDED PRECEDING** AND **UNBOUNDED FOLLOWING**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It may all seem too much at the moment but no need to memorize the syntax and
    its meaning, just practice! You may read the detailed *Frame Clause* with a bunch
    of examples here,
  prefs: []
  type: TYPE_NORMAL
- en: '[](/anatomy-of-sql-window-functions-7256d8cf509a?source=post_page-----4dd3e4ad0d2--------------------------------)
    [## Anatomy of SQL Window Functions'
  prefs: []
  type: TYPE_NORMAL
- en: Back To Basics | SQL fundamentals for beginners
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/anatomy-of-sql-window-functions-7256d8cf509a?source=post_page-----4dd3e4ad0d2--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s say, we need to find out *PRODUCTNAME* from each *PRODUCTCATEGORY*
    with 2nd highest buy-price,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/b8c66263b42f77d92f1ef6739c6c59c8.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: We have 2 more value functions similar to *NTH_VALUE()*; *FIRST_VALUE()* and
    *LAST_VALUE()*. As the name suggests, they return the highest(first) and lowest(last)
    values from an ordered list based on the user expression, respectively. The common
    syntax is,
  prefs: []
  type: TYPE_NORMAL
- en: '**FIRST_VALUE(expression) OVER ([PARTITION BY clause] [ORDER BY clause] [ROW/RANGE
    clause])**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**LAST_VALUE(expression) OVER ([PARTITION BY clause] [ORDER BY clause] [ROW/RANGE
    clause])**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Similar to the above example, can you now find out the *PRODUCTNAME* with the
    highest and the lowest buy-price for each *PRODUCTCATEGORY* ?
  prefs: []
  type: TYPE_NORMAL
- en: NTILE()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes there are scenarios where you would want to arrange the rows within
    the partition to a certain number of groups or buckets. NTILE() is used for such
    purpose, it divides the ordered rows in the partition into a specific number of
    buckets. Each such bucket is assigned a group number starting from 1\. It will
    try to create groups of equal size as possible. For each row, *NTILE()* function
    returns a group number representing the group to which that row belongs.
  prefs: []
  type: TYPE_NORMAL
- en: General syntax is,
  prefs: []
  type: TYPE_NORMAL
- en: '**NTILE(N) OVER ([PARTITION BY clause] [ORDER BY clause])**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Where ’N’ a is a positive integer that defines the number of groups one wants
    to create.
  prefs: []
  type: TYPE_NORMAL
- en: Say, we want to segregate *PRODUCTCATEGORY -‘Cars’* such that we have a list
    of cars with high-range, mid-range, and low-range buy-price.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/26e7d808c9718c3c9bc8a0d5f8765ff1.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: LAG() & LEAD()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We often encounter scenarios where some sort of comparative analysis is required.e.g.
    comparing sales of the selected year with the previous year or the following year.
    Such comparisons are really useful when working with time series data and calculating
    differences across time.
  prefs: []
  type: TYPE_NORMAL
- en: '*LAG()* pulls the data from the row that precedes the current row. If there
    is no preceding row then it returns *NULL*. The common syntax is,'
  prefs: []
  type: TYPE_NORMAL
- en: '**LAG(expression, offset) OVER ([PARTITION BY clause] [ORDER BY clause])**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*LEAD()* gets the data from the row that follows the current row. If there
    is no following row then it returns *NULL.* The common syntax is,'
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAD(expression, offset) OVER ([PARTITION BY clause] [ORDER BY clause])**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Where ***offset***is optional and but when used its value must be either 0 or
    a positive integer,
  prefs: []
  type: TYPE_NORMAL
- en: When specified as 0, then *LAG()* and *LEAD()* evaluate the expression for the
    current row.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When omitted, 1 is considered a default value, which takes the immediately preceding
    or following row to the current row.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have first used *CTE (Common Table Expression)* to get the data of
    total sales for each *PRODUCTCATEGORY* year-wise. We then use this data with *LAG()*
    and *LEAD()* to fetch data of total sales partitioned by *PRODUCTCATEGORY* and
    ordered by *SALES_YEAR* for the previous and following calendar year respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/24ef51d7c4bc4b1269bd75db4181e98b.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Window Functions are really useful when you want to analyze your data in multiple
    ways. Different flavors of SQL may have slightly different implementations, so
    it’s always a good idea to refer to the official documentation of a particular
    SQL flavor. Here are some resources to get you started,
  prefs: []
  type: TYPE_NORMAL
- en: '[Anatomy of Window Functions](/anatomy-of-sql-window-functions-7256d8cf509a)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Window Function concepts and syntax](https://dev.mysql.com/doc/refman/8.0/en/window-functions-usage.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[MySQL Window Function Restrictions](https://dev.mysql.com/doc/refman/8.0/en/window-function-restrictions.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SQL Window Function Cheat Sheet](https://learnsql.com/blog/sql-window-functions-cheat-sheet/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you remember something really well, you must have practiced it well,
  prefs: []
  type: TYPE_NORMAL
- en: '[HackerRank](https://www.hackerrank.com) or [LeetCode](https://leetcode.com)
    to practice basic/intermediate/advance SQL problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Become a member and read every story on Medium*](https://medium.com/@iffatm/membership)*.*'
  prefs: []
  type: TYPE_NORMAL
- en: Happy Learning!
  prefs: []
  type: TYPE_NORMAL
