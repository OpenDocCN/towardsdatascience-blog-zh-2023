["```py\n!pip install dlisio\n```", "```py\nfrom dlisio import dlis\nimport pandas as pd\n```", "```py\nf, *tail = dlis.load('Data/NLOG Data/NPN_TVN-1_23_Dec_2009_E3_Main_SONIC_057PUC.DLIS')\n```", "```py\nf.describe()\n```", "```py\nf.frames\n```", "```py\n[Frame(60B), Frame(10B), Frame(15B)]\n```", "```py\ndef frame_summary(dlis_file: dlis) -> pd.DataFrame:\n    \"\"\"\n    Generates a summary DataFrame of the frames contained within a given DLIS file.\n\n    This function iterates through the frames and channels in the DLIS file, \n    converting depth values from inches to meters if necessary, and then compiles \n    the information into a DataFrame. The resulting DataFrame contains the frame \n    name, index type, index curve, minimum and maximum index, spacing, direction, \n    number of channels, and channel names for each frame.\n\n    Parameters:\n    dlis_file (DLIS): The DLIS file to summarise.\n\n    Returns:\n    DataFrame: A DataFrame summarising the frames and channels of the DLIS file.\n\n    \"\"\"\n\n    temp_dfs = []\n\n    for frame in dlis_file.frames:\n\n        for channel in frame.channels:\n            # Get the index units\n            if channel.name == frame.index:\n                depth_units = channel.units\n\n            # In cases where units are stored in inches, we need to convert to m\n            if depth_units == \"0.1 in\":\n                multiplier = 0.00254\n            else:\n                multiplier = 1\n\n        df = pd.DataFrame(data= [[frame.name,\n                                  frame.index_type,\n                                  frame.index,\n                                  (frame.index_min * multiplier),\n                                  (frame.index_max * multiplier),\n                                  (frame.spacing * multiplier), \n                                  frame.direction,\n                                  len(frame.channels), \n                                  [channel.name for channel in frame.channels]]],\n                          columns=['Frame Name', \n                                   'Frame Index Type', \n                                   'Index Curve',\n                                   'Index Min',\n                                   'Index Max',\n                                   'Spacing', \n                                   'Direction',\n                                   'Number of Channels', \n                                   'Channel Names'])\n        temp_dfs.append(df)\n\n    final_df = pd.concat(temp_dfs)\n    return final_df.reset_index(drop=True)\n```", "```py\ndf = pd.DataFrame(f.frames[1].curves())\n```", "```py\ndf = pd.DataFrame()\n\nfor frame in f.frames:\n    for channel in frame.channels:\n        # Check if the channel is 1-dimensional\n        if channel.dimension[0] == 1:\n            # Get the data for the channel\n            data = channel.curves() \n\n            # Get the data for the channel\n            data = channel.curves()\n\n            # Add the channel data to the DataFrame as a new column\n            df[channel.name] = pd.Series(data)\n```", "```py\ndf['TDEP'] = df['TDEP'] * 0.00254\n```", "```py\ndf = df.sort_values(by='TDEP', ascending=True)\n```"]