["```py\nlibrary(tidyverse)\nlibrary(tidybayes)\nlibrary(brms)\nlibrary(ggdag)\nlibrary(dagitty)\n\ntrain <- read_csv('lego.population.csv')\n\ntrain_parse <- \ntrain %>% \n  drop_na(Weight, Pieces) %>% \n  mutate(Weight = as.numeric(str_sub(Weight, 1, 3)),\n         Price = as.numeric(str_remove(Price, '[^[:alnum:]]')),\n         Amazon_Price = as.numeric(str_remove(Amazon_Price, '[^[:alnum:]]')),\n         Price = coalesce(Price, Amazon_Price)) %>% \n  drop_na(Price, Weight) %>% \n  mutate(Weight_c = Weight/max(Weight),\n         Price_c = Price/max(Price),\n         Pieces_c = Pieces/max(Pieces)) %>% \n  drop_na(Weight, Pieces, Price)\n```", "```py\nGGally::ggpairs(train_parse %>% \n                  select(Weight_c, Pieces_c, Price_c),\n                aes(alpha = 1/3)) +\n  theme_minimal() +\n  labs(title = 'Pairplot for Weight, Pieces and Price')\n```", "```py\ndag_coords <- \n  tibble(name = c(\"Pcs\", 'W', 'Pr'),\n         x = c(1, 2, 2),\n         y = c(2, 2, 1))\n\ndagify(Pr ~ Pcs,\n       Pr ~ W, \n       W ~ Pcs,\n       coords = dag_coords) %>% \n  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +\n    geom_dag_point(color = 'dark red', alpha = 1/4, size = 20) +\n    geom_dag_edges(edge_color = 'dark red') +\n    geom_dag_text(color = 'dark red') +\n    scale_x_continuous(NULL, breaks = NULL, expand = c(.1, .1)) +\n    scale_y_continuous(NULL, breaks = NULL, expand = c(.1, .1)) +\n    theme_bw() +\n    theme(panel.grid = element_blank())\n```", "```py\nmP_Pr <- brm(Price ~ 1 + Pieces,\n             family = gaussian,\n             prior = c(prior(exponential(1), class = sigma),\n                       prior(normal(20, 6), class = Intercept),\n                       prior(normal(0.11, 0.04), class = b)\n                       ),\n             data = train_parse,\n             warmup = 1000, iter = 2000, chains = 4, cores = 4, seed = 246) %>% \n  add_criterion(criterion = c('loo'))\nsummary(mP_Pr)\n```", "```py\nmW_Pr <- brm(Price ~ 1 + Weight,\n             family = gaussian,\n             prior = c(prior(exponential(5), class = sigma),\n                       prior(normal(20, 6), class = Intercept),\n                       prior(normal(50, 15), class = b)),                       )\n             data = train_parse,\n             warmup = 1000, iter = 2000, chains = 4, cores = 4, seed = 246)\n```", "```py\n# The Colllider\nmWP_Pr <- brm(\n  Price ~ 1 + Pieces + Weight, \n  family = gaussian,\n             prior = c(prior(exponential(5), class = sigma),\n                       prior(normal(20, 6), class = Intercept),\n                       prior(normal(50, 15), class = b, coef = Weight),\n                       prior(normal(0.11, 0.04), class = b, coef = Pieces)\n                       ),\n  data = train_parse,\n             warmup = 1000, iter = 4000, chains = 4, cores = 4, seed = 246)\n```", "```py\n# LHS: Plot of Posterior Draws Weight vs. Pieces\nas_draws_df(mWP_Pr) %>%\n  ggplot(aes(x = b_Pieces_c, y=b_Weight_c)) +\n    geom_point(alpha = 0.3) +\n    labs(y = 'Weight', x = 'Pieces', title = 'Weight and Pieces Display Multicollinearity and Not Indpendant', subtitle = 'How Can Price per Piece Increase as Price per Unit Weight Decreases?') +\n    theme_minimal()\n\n# RHS: Comparison of Posterior Draws for Weight Across W → Pr ← Pcs & W → Pr\ntidy_draws(mWP_Pr) %>% \n  select(b_Pieces_c, b_Weight_c) %>% \n  transmute(Pieces_Weight = b_Pieces_c + b_Weight_c,\n         Weight = tidy_draws(mW_Pr) %>% select(b_Weight_c) %>% as_vector()) %>% \n  pivot_longer(1:2, names_to = 'Variable', values_to = 'posterior_samples') %>% \n  ggplot(aes(posterior_samples, fill = Variable)) +\n           geom_density(alpha = 1/3) +\n  theme_minimal() +\n  labs(title = 'Addition of Pieces and Weight is Nearly Equivalent to Weight Alone',\n       subtitle = 'Variables Min-Max Scaled',\n       y = 'Density',\n       x = 'Posterior Distribution')\n\n#NB We've used models regenerated using min-max scaled variables. \n```", "```py\n# The Pipe\npr_model <- bf(Price ~ 1 + Weight)\nw_model <- bf(Weight ~ 1 + Pieces)\n\nmWP_Pr2 <- brm(pr_model + w_model + set_rescor(F),\n    prior = c(prior(exponential(5), class = sigma, resp = Price),\n              prior(exponential(5), class = sigma, resp = Weight),\n              prior(normal(50, 15), class = b, coef = Weight, resp = Price),\n              prior(normal(0.11, 0.04), class = b, coef = Pieces, resp = Weight)),\n             family = gaussian,\n             data = train_parse,\n             warmup = 1000, iter = 4000, chains = 4, cores = 4, seed = 246)\n```", "```py\n# Counterfactual Plot Pieces on Price, Holding Weight Consant\nnd <- tibble(Pieces = seq(from = 0, to = 5000, length.out = 50),\n             Weight = 1)\n\npredict(mWP_Pr2, \n        resp = c('Price'),\n        newdata = nd) %>% \n  as_tibble() %>% \n  bind_cols(nd) %>% \n  ggplot(aes(x = Pieces, y = Estimate, ymin = Q2.5, ymax = Q97.5)) +\n    geom_smooth(stat = 'identity', alpha = 1/5, size = 1/4) +\n    labs(y = 'Counterfactual Price', x = 'Manipulated Pieces')\n```"]