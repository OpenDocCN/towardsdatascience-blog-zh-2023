- en: Window Functions in PostgreSQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/window-functions-in-postgresql-788d2ad57c6b](https://towardsdatascience.com/window-functions-in-postgresql-788d2ad57c6b)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A must-know for any data practitioner
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://ms101196.medium.com/?source=post_page-----788d2ad57c6b--------------------------------)[![Merlin
    Schäfer](../Images/70108782dda329ca5bbc4cfb5d650e5e.png)](https://ms101196.medium.com/?source=post_page-----788d2ad57c6b--------------------------------)[](https://towardsdatascience.com/?source=post_page-----788d2ad57c6b--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----788d2ad57c6b--------------------------------)
    [Merlin Schäfer](https://ms101196.medium.com/?source=post_page-----788d2ad57c6b--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----788d2ad57c6b--------------------------------)
    ·8 min read·Jan 6, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6fb505f5f62aafc51e7e278fa8654702.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Stephen Dawson](https://unsplash.com/@dawson2406?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Have you ever found yourself writing long SQL queries with many steps or subqueries
    containing aggregate functions to calculate seemingly simple metrics? Have you
    ever wondered if you “couldn’t just calculate along the table differently to make
    things easier”? Then it might be time to have a look at window functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Window functions are a handy and powerful feature in SQL that allows you to
    perform calculations across a number of rows similar to aggregate functions. But
    other than aggregate functions, which you might use with a GROUP BY, they don’t
    return a single value for a group of rows, but a value for each row in the set.
    Let’s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/d9ea7c43f0f7d2cd4a66ac506fe0d215.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/c630683f642ebee9e71a1a2d75085451.png)'
  prefs: []
  type: TYPE_IMG
- en: Why and when should you use window functions?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One advantage of window functions is that they allow you to work with aggregate
    and non-aggregate values combined because the rows are not collapsed together.
    This opens up a way to calculate many things in one step that would otherwise
    require multiple.
  prefs: []
  type: TYPE_NORMAL
- en: Window functions are also relatively simple to use and read compared to multiple
    subqueries and self-joins. They reduce the complexity and number of steps in your
    queries, which makes it easier to maintain down the road.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, they can also help with performance issues. For example, you can
    use a window function instead of having to do a self-join or subqueries.
  prefs: []
  type: TYPE_NORMAL
- en: Important window functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use functions like SUM() and COUNT() as window functions but there are
    some special functions that are only available as window functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the most important window functions in PostgreSQL:'
  prefs: []
  type: TYPE_NORMAL
- en: 'RANK(): returns the rank of each row within a set of rows. The rank is determined
    by the order of the rows in the set. Rank 1 would be the first row. Tied rows
    receive the same rank, which can lead to gaps.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'DENSE_RANK(): similar to RANK(), but it does not skip any ranks if there are
    ties in the values of the rows. For example, if two rows have the same value and
    are ordered as the first and second rows, their ranks will be 1 and 1 and the
    next will receive 2, not 1 and 1 and 3 as it would be the case with RANK().'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'ROW_NUMBER(): returns a unique, number for each row in the set. The first row
    is assigned a row number of 1, the second row is assigned a row number of 2, and
    so on.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'NTILE(): divides the rows into a specified number of groups, or “tiles” and
    assigns a tile number to each row. For example, if you specify NTILE(3) and have
    9 rows in the set, the first 3 rows will be assigned a tile number of 1, the next
    3 rows will be assigned a tile number of 2, and the final 3 rows will be assigned
    a tile number of 3\. This function can be used to calculate quantiles.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '5\. LAG() and LEAD(): These functions are used to access values from previous
    or subsequent rows in the set. For example, if you have a set of values and you
    want to compare the value in each row to the value in the previous row, you could
    use the LAG() function to access the previous value.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Let’s look at some examples!**'
  prefs: []
  type: TYPE_NORMAL
- en: '**RANK(), DENSE_RANK, and ROW_NUMBER():** To use these functions, you would
    specify the name of the column that you want to rank, and the ORDER BY clause
    that determines the order of the rows in the set.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to rank the rows in a table by the number of values in the “sales”
    column, you could use the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/0462adf3da8d9dafe19bd8eeec7d0a8b.png)'
  prefs: []
  type: TYPE_IMG
- en: In this example, the respective ranking function assigns a rank of 1 to the
    row with the highest number of values in the “sales” column, a rank of 2 (or one
    if ties are allowed) to the row with the second-highest, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '**NTILE**(): To use the NTILE() function, you need to specify the number of
    tiles that you want to create, as well as the ORDER BY clause that determines
    the order of the rows in the set. For example, to divide the rows in a table into
    4 tiles (quartiles), you could use the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/aea65a7078033b6cba6343a44d84dc0b.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see we can now easily determine the top/bottom quartiles’ sales.
    I found this function to be very useful to find the values above or below a certain
    percentage/quantile.
  prefs: []
  type: TYPE_NORMAL
- en: '**LAG**() and **LEAD**(): To use the LAG() or LEAD() functions, you would specify
    the name of the column that you want to access, the number of rows to move, and
    the default value to use if the specified row does not exist. For example, to
    access the value in the previous row in the “sales” column, you could use the
    following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/94bb9940f20f825fc5f9e3dad3aea62b.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, the LAG() function will access the value in the previous row in the “sales”
    column, and return 0 if there is no previous row (for example, if the current
    row is the first row in the set).
  prefs: []
  type: TYPE_NORMAL
- en: OVER, PARTITION BY, and ORDER BY
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The OVER clause is an optional part of the syntax for many window functions
    in PostgreSQL. It specifies the criteria that determine the set of rows that the
    function will operate on. For example, if you want to use a window function to
    calculate the average “sales” value for each year, you could use the OVER clause
    to define the set of rows as all rows with the same “year” value. The OVER clause
    typically includes the PARTITION BY and ORDER BY clauses, which are used to divide
    the rows into groups (or partitions) and determine the order of the rows within
    each partition.
  prefs: []
  type: TYPE_NORMAL
- en: The OVER clause is a powerful feature of window functions in PostgreSQL, as
    it allows you to control the criteria that determine the set of rows that the
    function will operate on. This allows you to perform calculations on groups of
    rows, or even on individual rows, depending on your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need even more control over the included rows you can use **row selection
    in your OVER clause**. A row selection clause determines the rows that will be
    included in the set that the window function operates on. The row selection clause
    can be used to specify the **number of rows** to include, or the **range of rows**
    to include, based on the position of the current row in the set. This can be useful
    if you only want to include a certain number of rows from the beginning or end
    of the set, or if you want to exclude certain rows from the calculation. Here
    are some examples that you might encounter frequently:'
  prefs: []
  type: TYPE_NORMAL
- en: 'ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING: This clause specifies
    that all rows in the set should be included in the calculation. This is the default
    behavior if no row selection clause is specified, so you won’t see it a lot but
    it’s the most used row selection.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING: This clause specifies that
    all rows from the current row to the end of the set should be included in the
    calculation.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW: This clause specifies that
    all rows from the beginning of the set to the current row should be included in
    the calculation. I found this to be very useful in cumulative calculations.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING: This clause specifies that the current
    row and the two rows immediately preceding and following it should be included
    in the calculation. You can change the numerical values to adjust the size and
    shape of your calculation window.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here are a few more things, which are good to know
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Window functions can be used in the SELECT, WHERE, and HAVING clauses of a query.
    This allows you to use the results of the window function in various parts of
    the query, and even to use them to filter the rows that are returned by the query.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Window functions can be combined with aggregate functions. For example, you
    can use a window function to calculate the rank of each row, and then use an aggregate
    function like SUM() to calculate the total sum of the ranks. This can be very
    useful in the calculations of fractions and percentages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Window functions can be used with the GROUP BY clause. When used in combination
    with the GROUP BY clause, window functions will calculate the value for each group
    of rows, rather than for the entire set of rows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Window functions can be used with subqueries and CTEs. This allows you to perform
    calculations on the results of a subquery/CTE, rather than on the original data
    set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is a WINDOW keyword is used to define the window frames for window functions
    in PostgreSQL. A window frame is the set of rows that a window function operates
    on, and is determined by the OVER clause and any row selection clauses that are
    included in the function’s syntax. By using the WINDOW keyword, you can specify
    the window frames for multiple window functions in a single query, rather than
    repeating the OVER and row selection clauses for each function. This can make
    your queries more readable and easier to maintain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In conclusion, window functions are a powerful and versatile tool in PostgreSQL
    that allows you to perform complex calculations on sets of rows. Whether you need
    to calculate ranks, divide rows into groups, or access values from other rows,
    window functions have you covered.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you learned something and can improve your calculations and analysis
    with window functions!
  prefs: []
  type: TYPE_NORMAL
- en: -Merlin
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://ms101196.medium.com/membership?source=post_page-----788d2ad57c6b--------------------------------)
    [## Join Medium with my referral link - Merlin Schäfer'
  prefs: []
  type: TYPE_NORMAL
- en: Read every story from Merlin Schäfer (and thousands of other writers on Medium).
    Your membership fee directly supports…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ms101196.medium.com](https://ms101196.medium.com/membership?source=post_page-----788d2ad57c6b--------------------------------)
  prefs: []
  type: TYPE_NORMAL
