- en: The Top 3 SQL Skills Needed to Get to the Next Round
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/the-top-3-sql-skills-needed-to-get-to-the-next-round-51ad1699a213](https://towardsdatascience.com/the-top-3-sql-skills-needed-to-get-to-the-next-round-51ad1699a213)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Technical Interview Help for Data Professionals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@violante.andre?source=post_page-----51ad1699a213--------------------------------)[![Andre
    Violante](../Images/0382695157126b7ed742649d348cae61.png)](https://medium.com/@violante.andre?source=post_page-----51ad1699a213--------------------------------)[](https://towardsdatascience.com/?source=post_page-----51ad1699a213--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----51ad1699a213--------------------------------)
    [Andre Violante](https://medium.com/@violante.andre?source=post_page-----51ad1699a213--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----51ad1699a213--------------------------------)
    ·6 min read·Aug 28, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/584c4b12a0d4da972d8f858eddd3f5f9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Picture Credit: [Arnold Francisa at Unsplash](https://unsplash.com/@clark_fransa)'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re aspiring and currently interviewing for roles such as data scientists,
    data analysts, and data engineers then you are likely to encounter one or more
    technical interviews that require live coding, usually involving SQL. While later
    interviews might require different programming languages like Python, which is
    common in the data domain, let’s focus on the typical SQL questions that I’ve
    encountered during these interviews. For the purpose of this discussion, I’ll
    assume that you’re already familiar with fundamental SQL concepts such as `SELECT`,
    `FROM`, `WHERE`, as well as aggregate functions like `SUM` and `COUNT`. Let’s
    get into the specifics!
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Mastering Joins and Table Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Without a doubt, the most common SQL question is around table joins. It might
    seem too obvious, but every interview I’ve participated in has centered around
    this topic. You should feel at ease with inner joins and left joins. Additionally,
    proficiency in handling self-joins and unions is valuable. Equally important is
    the ability to execute these joins across different table types, particularly
    ***fact*** and ***dimension*** tables. Here are my loose definitions for these
    two terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '***Fact Table:*** A table containing numerous rows but relatively few attributes
    or columns. Imagine an example where an online retailer maintains an “*orders*”
    table with columns like: `date, customer_id, order_id, product_id, units, amount`.
    This table has few attributes but contains a huge volume of records.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Dimension Table:*** A dimensional table with fewer rows yet many attributes.
    For instance, the same online retailer’s “*customer*” table might hold one row
    per customer, featuring attributes such as `customer_id, first_name, last_name,
    ship_street_addr, ship_zip_code` and more.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Understanding these two primary table types is important. It’s crucial to grasp
    why and how to merge fact and dimension tables to ensure accurate results. Let’s
    consider a real-world example: the interview question presents two tables (*“orders”*
    and *“customer”*) and asks:'
  prefs: []
  type: TYPE_NORMAL
- en: How many customers have purchased at least 3 units in their lifetime and have
    a shipping zip code of 90210?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'By just running an inner join followed by counts, sums, and / or filters might
    yield huge discrepancies due to overcounting. Even within this seemingly straightforward
    question, various parts require careful thought. To effectively communicate your
    thought process to the interviewer, think these items aloud:'
  prefs: []
  type: TYPE_NORMAL
- en: Which table encompasses ALL customers? The *“orders”* fact table only includes
    customers with confirmed purchases, whereas the *“customer”* dimension table includes
    all customers, including those who’ve registered but haven’t purchased. A quick
    `count(distinct )` comparison would show the table with more unique customers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating the sum or count of units bought by each customer requires an aggregate
    function with a `GROUP BY` clause.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A join with the *“customer”* table is needed to narrow down customers in zip
    code 90210\. When using joins I would recommend creating aliases for tables which
    then may require you to add that alias in the select statement with the associated
    attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having outlined the thought process, let’s translate it into code!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This solution uses a Common Table Expression (CTE), but remember, there are
    a lot of different ways to achieve the same outcome in SQL. As long as you arrive
    at the correct result and can explain your approach, you’re on the right track.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Tackling Complexity with Subqueries, Temp Tables, and CTEs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like the previous example, almost every SQL coding interview will require multi-step
    procedures. This is where subqueries, temporary tables, and CTEs are beneficial.
    Proficiency in these techniques or at least familiarity with them is a must. Let’s
    explore each approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Subqueries:** These nested queries involve constructs like `select * from
    (select * from table)` or filtering `select * from table1 where table1_value <
    (select max(table2_value) from table2)`, encompassing inner and outer queries.
    Subqueries are useful, but their syntax can become difficult or messy for both
    code writers and readers. For complex scenarios, avoid excessive subqueries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Temporary Tables:** As the name suggests, temporary tables only persist for
    a session’s duration. You can create them incrementally, building one after another
    to aid in troubleshooting or logical sequencing. They are helpful for breaking
    down multifaceted problems into smaller, more manageable steps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Common Table Expressions (CTEs):** As demonstrated in the joins example,
    CTEs offer a flexible way to structure queries. They resemble temporary tables
    but don’t persist beyond the following `SELECT` statement. This requires CTEs
    to be “chained” (see below code example) if you have many steps. When chaining
    CTEs together, remember that only one `WITH` statement is used, followed by the
    CTEs, and finally, the main query. Also, the semicolon comes after the final `SELECT`
    statement within the CTE chain. CTEs can’t be referenced beyond this point due
    to their limited scope.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In practice, once you get hired, you can decide on the best approach or what
    others are using. Currently, CTEs appear to be the more popular choice. Given
    that interview scenarios usually don’t necessitate chained CTEs, incorporating
    a CTE should prove relatively straightforward and effective.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Navigating Window Functions for Advanced Analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A recurring topic that arises in nearly every interview pertains to window functions.
    The [PostgreSQL documentation](https://www.postgresql.org/docs/9.1/tutorial-window.html)
    effectively explains window functions and highlights the difference compared to
    group by operations.
  prefs: []
  type: TYPE_NORMAL
- en: A window function performs a calculation across a set of table rows that are
    somehow related to the current row. This is comparable to the type of calculation
    that can be done with an aggregate function. But unlike regular aggregate functions,
    use of a window function does not cause rows to become grouped into a single output
    row — the rows retain their separate identities. Behind the scenes, the window
    function is able to access more than just the current row of the query result.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The key is in the final two sentences. The non-grouping of rows and the window
    function accesses more than the current row behind the scenes. Interview questions
    often span a range from theoretical, such as “What types of window functions have
    you used?” to coding questions where the use of window functions is needed. Consider
    scenarios like “show me with the three highest earning employees within each department”
    or “show the three most recent items purchased by each customer.” In my experience,
    the most common window functions encompass `rank()`, `row_number()`, and `dense_rank()`
    all using the `OVER` function. It’s worth noting that most aggregate functions
    can be used alongside the `OVER` function. For a good illustration of the differences
    between rank functions you can see this [example on Stack Overflow](https://stackoverflow.com/questions/7747327/sql-rank-versus-row-number).
    Also, this [Window Functions Cheat Sheet](https://learnsql.com/blog/sql-window-functions-cheat-sheet/Window_Functions_Cheat_Sheet_Letter.pdf)
    by LearnSQL is a great visual to see the different types of functions as well
    as some output visuals.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These are the top three SQL skills that interviewers have repeatedly inquired
    about over the past month during coding interviews. Proficiency in these areas
    should easily help you navigate almost all SQL interview scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, here’s my last tip: If you find yourself in a coding interview and
    you’re unsure about syntax or terminology, jot down a step-by-step outline of
    your problem-solving process. Emphasize your thought process and creativity, as
    they often outweigh strict syntax. Best of luck in your upcoming data-related
    interviews!'
  prefs: []
  type: TYPE_NORMAL
