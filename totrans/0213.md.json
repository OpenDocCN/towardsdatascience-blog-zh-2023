["```py\n├── dashboard_backend\n│   ├── Dockerfile\n│   ├── app\n│   │   ├── core\n│   │   │   ├── config.py\n│   │   │   └── utils.py\n│   │   ├── db\n│   │   │   └── data_api.py\n│   │   ├── main.py\n│   │   └── models\n│   │       └── sensors.py\n│   ├── entrypoint.sh\n│   └── requirements.txt\n├── dashboard_frontend\n│   ├── Dockerfile\n│   ├── app\n│   │   ├── main.py\n│   │   ├── static\n│   │   │   └── js\n│   │   │       └── main.js\n│   │   └── templates\n│   │       └── index.html\n│   ├── entrypoint.sh\n│   └── requirements.txt\n├── producer\n│   ├── Dockerfile\n│   ├── app\n│   │   ├── __init__.py\n│   │   ├── core\n│   │   │   ├── config.py\n│   │   │   └── utils.py\n│   │   ├── main.py\n│   │   └── schemas\n│   │       └── sensors.py\n│   ├── entrypoint.sh\n│   └── requirements.txt\n├── docker-compose.yml\n```", "```py\nversion: '3.8'\n\nservices:\n\n  zookeeper:\n    image: bitnami/zookeeper:latest\n    ports:\n      - 2181:2181\n    environment:\n      - ALLOW_ANONYMOUS_LOGIN=yes\n\n  kafka:\n    image: bitnami/kafka:latest\n    ports:\n      - 9092:9092\n      - 9093:9093\n    environment:\n      - KAFKA_BROKER_ID=1\n      - KAFKA_CFG_LISTENERS=PLAINTEXT://:9092\n      - KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://127.0.0.1:9092\n      - KAFKA_CFG_ZOOKEEPER_CONNECT=zookeeper:2181\n      - ALLOW_PLAINTEXT_LISTENER=yes\n      - KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP=CLIENT:PLAINTEXT\n      - KAFKA_CFG_LISTENERS=CLIENT://:9092\n      - KAFKA_CFG_ADVERTISED_LISTENERS=CLIENT://kafka:9092\n      - KAFKA_CFG_INTER_BROKER_LISTENER_NAME=CLIENT\n    depends_on:\n      - zookeeper\n\n  ksqldb-server:\n    image: confluentinc/ksqldb-server:latest\n    hostname: ksqldb-server\n    container_name: ksqldb-server\n    depends_on:\n      - kafka\n    ports:\n      - \"8088:8088\"\n    environment:\n      KSQL_LISTENERS: http://0.0.0.0:8088\n      KSQL_BOOTSTRAP_SERVERS: kafka:9092\n      KSQL_KSQL_LOGGING_PROCESSING_STREAM_AUTO_CREATE: \"true\"\n      KSQL_KSQL_LOGGING_PROCESSING_TOPIC_AUTO_CREATE: \"true\"\n      KSQL_KSQL_STREAMS_COMMIT_INTERVAL_MS: 100\n      KSQL_KSQL_IDLE_CONNECTION_TIMEOUT_SECONDS: 600\n\n  ksqldb-cli:\n    image: confluentinc/ksqldb-cli:latest\n    container_name: ksqldb-cli\n    depends_on:\n      - kafka\n      - ksqldb-server\n    entrypoint: /bin/sh\n    tty: true\n\n  producer:\n    build:\n      context: ./producer\n      dockerfile: Dockerfile\n    command: uvicorn main:app --workers 1 --host 0.0.0.0 --port 8000\n    ports:\n      - 8000:8000\n    env_file:\n      - .env\n    depends_on:\n      - kafka\n      - zookeeper\n\n  dashboard_backend:\n    build:\n      context: ./dashboard_backend\n      dockerfile: Dockerfile\n    command: uvicorn main:app --workers 1 --host 0.0.0.0 --port 5000\n    ports:\n      - 5000:5000\n    env_file:\n      - .env\n    depends_on:\n      - ksqldb-server\n\n  dashboard_frontend:\n    build:\n      context: ./dashboard_frontend\n      dockerfile: Dockerfile\n    command: uvicorn main:app --workers 1 --host 0.0.0.0 --port 4200\n    ports:\n      - 4200:4200\n    env_file:\n      - .env\n    depends_on:\n      - dashboard_backend\n```", "```py\nproducer\n    ├── Dockerfile\n    ├── app\n    │   ├── __init__.py\n    │   ├── core\n    │   │   ├── config.py\n    │   │   └── utils.py\n    │   ├── main.py\n    │   └── schemas\n    │       └── sensors.py\n    ├── entrypoint.sh\n    └── requirements.txt\n```", "```py\n# producer/app/main.py\nimport json\nfrom fastapi import FastAPI\nimport asyncio\nfrom aiokafka import AIOKafkaProducer\nfrom schemas.sensors import SensorReading, SensorResponse\nfrom core.config import app_config\nfrom core.utils import flatten_dict\nfrom loguru import logger\n\n# Instantiate FastAPI app\napp = FastAPI(title=app_config.PROJECT_NAME)\n\n# Create the event loop to use async programming\nloop = asyncio.get_event_loop()\n\n# Instatiate the Kafka producer object\nproducer = AIOKafkaProducer(\n    loop=loop,\n    client_id=app_config.PROJECT_NAME,\n    bootstrap_servers=app_config.KAFKA_URL\n)\n\n@app.on_event(\"startup\")\nasync def startup_event():\n\n    await producer.start()\n    await producer.send(app_config.TOPIC_NAME, json.dumps({'status':'ready'}).encode(\"ascii\"))\n\n@app.on_event(\"shutdown\")\nasync def shutdown_event():\n    await producer.stop()\n\n@app.post(\"/phone-producer/\")\nasync def kafka_produce(data: SensorReading):\n\n    \"\"\"\n    Produce a message containing readings from a smartphone sensor to Kafka.\n\n    Parameters\n    ----------\n    data : SensorReading\n        The request body containing sensor readings and metadata.\n\n    Returns\n    -------\n    response : SensorResponse\n        The response body corresponding to the processed sensor readings\n        from the request.\n    \"\"\"\n\n    # Extract the messageId, deviceId, and sessionId\n    message_info = data.dict().copy()\n    message_info.pop('payload')\n\n    # Write each sensor reading in the payload to kafka\n    for sensor_reading in data.dict()['payload']:\n\n        kafka_message = {**flatten_dict(sensor_reading), **message_info}\n        await producer.send(app_config.TOPIC_NAME,\n                            json.dumps(kafka_message).encode(\"ascii\"))\n\n    response = SensorResponse(\n        messageId=data.messageId,\n        sessionId=data.sessionId,\n        deviceId=data.deviceId\n    )\n\n    logger.info(response)\n\n    return response\n```", "```py\n{\"messageId\": 20,\n \"sessionId\": \"4bf3b3b9-a241-4aaa-b1d3-c05100df9976\",\n \"deviceId\": \"86a5b0e3-6e06-40e2-b226-5a72bd39b65b\",\n \"payload\": [{\"name\": \"accelerometeruncalibrated\",\n              \"time\": \"1671406719721160400\",\n              \"values\": {\"z\": -0.9372100830078125,\n                         \"y\": -0.3241424560546875, \n                         \"x\": 0.0323486328125}},\n             {\"name\": \"magnetometeruncalibrated\",\n              \"time\": \"1671406719726579500\",\n              \"values\": {\"z\": -5061.64599609375,\n                         \"y\": 591.083251953125,\n                         \"x\": 3500.541015625}},\n             {\"name\": \"gyroscopeuncalibrated\",\n              \"time\": \"1671406719726173400\",\n              \"values\": {\"z\": -0.004710599314421415,\n                         \"y\": -0.013125921599566936,\n                         \"x\": 0.009486978873610497}}, \n...\n]}\n```", "```py\n# Extract the messageId, deviceId, and sessionId\nmessage_info = data.dict().copy()\nmessage_info.pop('payload')\n\n# Write each sensor reading in the payload to kafka\nfor sensor_reading in data.dict()['payload']:\n\n    kafka_message = {**flatten_dict(sensor_reading), **message_info}\n    await producer.send(app_config.TOPIC_NAME,\n                        json.dumps(kafka_message).encode(\"ascii\"))\n```", "```py\n{\n  \"name\": \"accelerometeruncalibrated\",\n  \"time\": \"1683555956851304200\",\n  \"values\": {\n    \"z\": -1.0012664794921875,\n    \"y\": -0.467315673828125,\n    \"x\": -0.00494384765625\n  }\n}\n```", "```py\n{\n  \"name\": \"accelerometeruncalibrated\",\n  \"time\": \"1683555956851304200\",\n  \"values_z\": -1.0012664794921875,\n  \"values_y\": -0.467315673828125,\n  \"values_x\": -0.00494384765625,\n  \"messageId\": 35,\n  \"sessionId\": \"c931f349-faf5-4e45-b09f-c623a76ef93a\",\n  \"deviceId\": \"86a5b0e3-6e06-40e2-b226-5a72bd39b65b\"\n}\n```", "```py\nCREATE STREAM smartphone_sensor_stream (\n    name VARCHAR,\n    time BIGINT,\n    values_x DOUBLE,\n    values_y DOUBLE,\n    values_z DOUBLE,\n    messageId BIGINT,\n    sessionId VARCHAR,\n    deviceId VARCHAR\n  ) WITH (\n    KAFKA_TOPIC = 'smartphone-sensor-data',\n    VALUE_FORMAT = 'JSON'\n  );\n```", "```py\nfrom ksql import KSQLAPI # pip install ksql\n\n# Where ksqldb is running\nKSQL_URL = \"http://localhost:8088\" \n\n# Instantiate the ksqldb API object\nclient = KSQLAPI(KSQL_URL)\n\n# Create the \"smartphone_sensor_stream\" stream over the specified topic\nclient.create_stream(table_name=\"smartphone_sensor_stream\",\n                     columns_type=[\"name varchar\",\n                                   \"time bigint\",\n                                   \"values_x double\",\n                                   \"values_y double\",\n                                   \"values_z double\",\n                                   \"messageId bigint\",\n                                   \"sessionId varchar\",\n                                   \"deviceId varchar\"\n                                   ],\n                     topic=\"smartphone-sensor-data\",\n                     value_format=\"JSON\") \n```", "```py\nselect deviceId,\n       time,\n       values_x,\n       values_y,\n       values_z\nfrom smartphone_sensor_stream\nwhere name = 'accelerometeruncalibrated'\nemit changes\n```", "```py\nfrom ksql import KSQLAPI\nfrom typing import Generator\n\n# Where ksqldb is running\nKSQL_URL = \"http://localhost:8088\" \n\n# Instantiate the ksqldb API object\nclient = KSQLAPI(KSQL_URL)\n\n# Write a push query \npush_query = '''select deviceId,\n                        time,\n                        values_x,\n                        values_y,\n                        values_z\n                    from smartphone_sensor_stream\n                    where name = 'accelerometeruncalibrated'\n                    emit changes\n                   '''\n# Get the KSQL stream generator\nsensor_push_stream: Generator = client.query(push_query, use_http2=True)\n\n# Loop through messages in the generator and print them as they're received\nfor raw_message in sensor_push_stream:\n\n    print(raw_message) \n```", "```py\n[\n '86a5b0e3-6e06-40e2-b226-5a72bd39b65b', # Device ID\n 1684615020438850600, # Timestamp of the sensor recording\n 0.993927001953125, # x value\n-0.5736083984375, # y value\n-0.1787261962890625 # z value\n]\n```", "```py\n dashboard_backend\n   ├── Dockerfile\n   ├── app\n   │   ├── core\n   │   │   ├── config.py\n   │   │   └── utils.py\n   │   ├── db\n   │   │   └── data_api.py\n   │   ├── main.py\n   │   └── models\n   │       └── sensors.py\n   ├── entrypoint.sh\n   └── requirements.txt\n```", "```py\n# data_api.py\n\nfrom retry import retry\nfrom ksql import KSQLAPI\nfrom models.sensors import SensorName\nfrom typing import Generator\n\n@retry()\ndef create_ksql_connection(url: str) -> KSQLAPI:\n    \"\"\"\n    Create a connection to a KSQL server using the provided URL.\n\n    Parameters\n    ----------\n    url : str\n        The URL of the KSQL server to connect to.\n\n    Returns\n    -------\n    KSQLAPI\n        An instance of the `KSQLAPI` class representing the connection\n        to the KSQL server.\n    \"\"\"\n\n    return KSQLAPI(url)\n\ndef create_ksql_device_stream(client: KSQLAPI,\n                              stream_name: str,\n                              topic_name: str) -> None:\n    \"\"\"\n    Creates a new device stream in KSQL server if it does not already exist.\n\n    Parameters:\n    -----------\n    client : KSQLAPI\n        A client instance of the KSQLAPI class to connect with KSQL server.\n    stream_name : str\n        The name of the device stream to create.\n    topic_name : str\n        The name of the Kafka topic to associate with the device stream.\n\n    Returns:\n    --------\n    None\n\n    Raises:\n    -------\n    KSQLServerError\n        If there is an error while creating the stream in KSQL server.\n    \"\"\"\n\n    # Get the current streams\n    curr_streams = client.ksql('show streams')\n    curr_stream_names = [stream['name'].lower()\n                         for stream in curr_streams[0]['streams']]\n\n    # If the device stream doesn't exist, create it\n    if stream_name.lower() not in curr_stream_names:\n\n        client.create_stream(table_name=stream_name,\n                             columns_type=['name varchar',\n                                           'time bigint',\n                                           'values_x double',\n                                           'values_y double',\n                                           'values_z double',\n                                           'messageId bigint',\n                                           'sessionId varchar',\n                                           'deviceId varchar'\n                                           ],\n                             topic=topic_name,\n                             value_format='JSON')\n\ndef ksql_sensor_push(client: KSQLAPI,\n                     stream_name: str,\n                     sensor_name: SensorName) -> Generator:\n    \"\"\"\n    Generator function that continuously pushes sensor data\n    for a given sensor name from a KSQL server using the KSQL API client.\n\n    Parameters:\n    -----------\n    client : KSQLAPI\n        The KSQL API client instance used to query the KSQL server.\n    stream_name : str\n        The name of the KSQL stream to query data from.\n    sensor_name : SensorName\n        An enum value representing the name of the sensor to stream data for.\n\n    Returns:\n    --------\n    Generator:\n        A generator object that yields the sensor data as it is streamed in real-time.\n    \"\"\"\n\n    push_query = f'''\n                  select deviceId,\n                         time,\n                         values_x,\n                         values_y,\n                         values_z\n                    from {stream_name}\n                    where name = '{sensor_name.value}'\n                    emit changes\n                   '''\n\n    sensor_push_stream: Generator = client.query(push_query, use_http2=True)\n\n    return sensor_push_stream\n```", "```py\n# main.py\n\nimport pandas as pd\nimport json\nfrom fastapi import FastAPI\nfrom sse_starlette.sse import EventSourceResponse\nfrom fastapi.requests import Request\nfrom starlette.middleware.cors import CORSMiddleware\nfrom core.config import app_config\nfrom core.utils import maybe_load_json\nfrom models.sensors import SensorName\nfrom db.data_api import (create_ksql_connection,\n                         create_ksql_device_stream,\n                         ksql_sensor_push)\n```", "```py\n# main.py\n\n...\n\n# Instantiate KSQLAPI object\nKSQL_CLIENT = create_ksql_connection(app_config.KSQL_URL)\n\n# Create the KSQL device stream if it doesn't exist\ncreate_ksql_device_stream(\n  KSQL_CLIENT, app_config.STREAM_NAME, app_config.TOPIC_NAME\n)\n\n# Instantiate FastAPI app\napp = FastAPI()\n\n# Configure middleware\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n```", "```py\n# main.py\n\n...\n\n# An SSE endpoint that pushes sensor data from KSQLDB to the client\n@app.get(\"/chart-data/{client_id}\")\nasync def message_stream(request: Request, client_id: str):\n    async def event_generator():\n        while True:\n            # If the client closes the connection, stop sending events\n            if await request.is_disconnected():\n                break\n\n            try:\n\n                # Get the KSQL stream generator\n                sensor_push_stream = ksql_sensor_push(\n                    KSQL_CLIENT, app_config.STREAM_NAME, SensorName.ACC)\n\n                for raw_message in sensor_push_stream:\n\n                    # If client closes connection, stop sending events\n                    if await request.is_disconnected():\n                        break\n\n                    # Check if the raw message is the correct format\n                    message = maybe_load_json(raw_message)\n\n                    # If the message is in the correct format (i.e. a list),\n                    # send to client\n                    if isinstance(message, list):\n\n                        # Format the sensor timestamp\n                        message[1] = str(pd.to_datetime(message[1]))\n\n                        # Yield the message as JSON\n                        yield {\n                            \"event\": \"new_message\",\n                            \"id\": \"message_id\",\n                            \"retry\": 1500000,\n                            \"data\": json.dumps(message)\n                        }\n            except Exception as e:\n\n                if await request.is_disconnected():\n\n                    break\n\n                continue\n\n    return EventSourceResponse(event_generator())\n```"]