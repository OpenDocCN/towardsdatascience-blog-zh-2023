["```py\nfrom sklearn.linear_model import LinearRegression\nimport pandas as pd\nimport numpy as np\n\n# simulate linear regression data\ndef regression_simulation(sim_var, sim_error, sim_coef, size):\n\n    '''\n        Simulates data for simple linear regression.\n\n        inputs:\n            sim_var (list)    : 2-element list, first element is the mean of a random variable\n                                that is being used to simulate a feature in the linear regression, \n                                second is the standard deviation\n            sim_error (list)   : 2-element list, first element is the mean of random error being added,\n                                 second is the standard deviation\n            sim_coef (float)   : impact of the random variable established by sim_var on the target \n                                 variable\n            size (int)         : number of units to simulate\n\n        output:\n            sim_df (DataFrame) : dataframe with simulated data\n\n    '''\n\n    # create an empty dataframe to populate\n    sim_df = pd.DataFrame()\n\n    # create the feature for the linear regression\n    sim_df['var'] = np.random.normal(sim_var[0], sim_var[1], size = size)\n\n    # multiply feature by the coef to get a simulated impact\n    sim_df['var_impact'] = sim_df['var']*sim_coef\n\n    # create error for the linear regression\n    sim_error = np.random.normal(sim_error[0], sim_error[1], size = size)\n\n    # create the target variable\n    sim_df['target'] = sim_df['var_impact'] + sim_error\n\n    return sim_df\n\nlinear_regression_sim_df = regression_simulation(sim_var = [2, 0.2], \n                                                 sim_error = [0, 2],\n                                                 sim_coef = 0.16,\n                                                 size = 30000)\n\nlin_reg = LinearRegression()\nX = np.array(linear_regression_sim_df['var']).reshape(-1, 1)\ny = linear_regression_sim_df['target']\nlin_reg.fit(X, y)\n```", "```py\nprint(lin_reg.coef_)\n```", "```py\n# run multiple simulations\niters = 1000\nceof_list = []\n\nfor i in range(iters):\n\n    reg_sim_df = regression_simulation([2, 0.2], [0, 0.1], 0.16, 5000)\n\n    lin_reg = LinearRegression()\n    X = np.array(reg_sim_df['var']).reshape(-1, 1)\n    y = reg_sim_df['target']\n    lin_reg.fit(X, y)\n\n    coef = lin_reg.coef_[0]\n\n    ceof_list.append(coef)\n\nplt.hist(ceof_list, bins = 20)\n```", "```py\nfrom sklearn.linear_model import LogisticRegression\nimport pandas as pd\nimport numpy as np\n\n# simulate binary data\ndef logistic_regression_simulation(sim_var, sim_error, sim_coef, size):\n\n    '''\n        Simulates data for simple logistic regression.\n\n        inputs:\n            sim_var (list)    : 2-element list, first element is the mean of a random variable\n                                that is being used to simulate a feature in the logistic regression, \n                                second is the standard deviation\n            sim_error (list)   : 2-element list, first element is the mean of random error being added,\n                                 second is the standard deviation\n            sim_coef (float)   : impact of the random variable established by sim_var on the target \n                                 variable\n            size (int)         : number of units to simulate\n\n        output:\n            sim_df (DataFrame) : dataframe with simulated data\n\n    '''\n\n    # create an empty dataframe to populate\n    sim_df = pd.DataFrame()\n\n    # create the feature for the linear regression\n    sim_df['var'] = np.random.normal(sim_var[0], sim_var[1], size = size)\n\n    # multiply feature by the coef to get a simulated impact\n    sim_df['var_impact'] = sim_df['var']*sim_coef\n\n    # create error term\n    sim_df['sim_error'] = np.random.normal(sim_error[0], sim_error[1], size = size)\n\n    # add error and impact together\n    sim_df['sum_vars_error'] = sim_df['var_impact'] + sim_df['sim_error']\n\n    # create a uniform random variable used to convert sum_vars_error from continuous to binary\n    sim_df['uniform_rv'] = np.random.uniform(size = len(sim_df))\n\n    # create the binary target variable using the uniform random variable\n    sim_df['binary_target'] = sim_df.apply(lambda x : 1 if x.sum_vars_error > x.uniform_rv else 0, axis = 1)\n\n    return sim_df\n\nlog_reg_sim_df = logistic_regression_simulation([2.00, 0.2], [0, 0.1], 0.16, 30000)\n```", "```py\nlog_reg = LogisticRegression()\nX = np.array(log_reg_sim_df['var']).reshape(-1, 1)\ny = log_reg_sim_df['binary_target']\nlog_reg.fit(X, y)\n```", "```py\nprint(log_reg.coef_[0])\n```", "```py\nfrom math import exp\nimport numpy as np\nimport pandas as pd\nfrom matplotlib import pyplot as plt\n\niters = 1000\nmean_marginal_impacts = []\ncoef_list = []\n\n# create iters number of simulated datasets\nfor i in range(iters):\n\n    # create simulated data\n    log_reg_sim_df = logistic_regression_simulation([2, 0.2], [0, 0.1], 0.16, 20000)\n\n    # run regression and get coefficient and intercept\n    log_reg = LogisticRegression()\n    X = np.array(log_reg_sim_df['var']).reshape(-1, 1)\n    y = log_reg_sim_df['binary_target']\n    log_reg.fit(X, y)\n\n    coef = log_reg.coef_[0][0]\n    intercept = log_reg.intercept_[0]\n\n    # run the model outputs through the partial derivatives for each simulated observation\n    log_reg_sim_df['contribution'] = log_reg_sim_df['var'].apply(lambda x : coef*exp(intercept + (x*coef))/\n                                                                         (((exp(intercept + (x*coef)) + 1))**2))\n\n    # calculate the mean of the derivative values\n    temp_mean_marginal_impact = log_reg_sim_df['contribution'].mean()\n\n    # save the original coefficient and marginal impact for \n    # this simulation in a list \n    mean_marginal_impacts.append(temp_mean_marginal_impact)\n    coef_list.append(coef)\n\n# show the distribution of simulated mean marginal impacts\nplt.hist(mean_marginal_impacts, bins = 20)\n```", "```py\nimport numpy as np\nimport pandas as pd\nfrom matplotlib import pyplot as plt\nimport statsmodels.api as sm\n\niters = 1000\nsm_marginal_effects = []\n\nfor i in range(iters):\n\n    # simulate data\n    log_reg_sim_df = logistic_regression_simulation([2, 0.2], [0, 0.1], 0.16, 20000)\n\n    # define target and predictor variables\n    X = np.array(log_reg_sim_df['var'])\n    y = log_reg_sim_df['binary_target']\n\n    # add constant to formula - statsmodels.Logit doesn't automatically include\n    # an intercept like sklearn\n    X_with_intercept = sm.add_constant(X)\n    log_reg_sm = sm.Logit(y, X_with_intercept)\n    result = log_reg_sm.fit(disp=False)\n\n    # calculate marginal effects\n    marginal_effects = result.get_margeff(at = 'all', method = 'dydx')\n\n    # save mean marginal effects in a list\n    sm_marginal_effects.append(np.mean(marginal_effects.margeff)) \n```"]