- en: How To Deploy and Test Your Models Using FastAPI and Google Cloud Run
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用 FastAPI 和 Google Cloud Run 部署和测试你的模型
- en: 原文：[https://towardsdatascience.com/how-to-deploy-and-test-your-models-using-fastapi-and-google-cloud-run-82981a44c4fe](https://towardsdatascience.com/how-to-deploy-and-test-your-models-using-fastapi-and-google-cloud-run-82981a44c4fe)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/how-to-deploy-and-test-your-models-using-fastapi-and-google-cloud-run-82981a44c4fe](https://towardsdatascience.com/how-to-deploy-and-test-your-models-using-fastapi-and-google-cloud-run-82981a44c4fe)
- en: Learn how to turn your model into a service that runs in the cloud in this end-to-end
    tutorial
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在这个端到端教程中学习如何将你的模型转变为一个在云中运行的服务
- en: '[](https://medium.com/@antonsruberts?source=post_page-----82981a44c4fe--------------------------------)[![Antons
    Tocilins-Ruberts](../Images/363a4f32aa793cca7a67dea68e76e3cf.png)](https://medium.com/@antonsruberts?source=post_page-----82981a44c4fe--------------------------------)[](https://towardsdatascience.com/?source=post_page-----82981a44c4fe--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----82981a44c4fe--------------------------------)
    [Antons Tocilins-Ruberts](https://medium.com/@antonsruberts?source=post_page-----82981a44c4fe--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@antonsruberts?source=post_page-----82981a44c4fe--------------------------------)[![Antons
    Tocilins-Ruberts](../Images/363a4f32aa793cca7a67dea68e76e3cf.png)](https://medium.com/@antonsruberts?source=post_page-----82981a44c4fe--------------------------------)[](https://towardsdatascience.com/?source=post_page-----82981a44c4fe--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----82981a44c4fe--------------------------------)
    [Antons Tocilins-Ruberts](https://medium.com/@antonsruberts?source=post_page-----82981a44c4fe--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----82981a44c4fe--------------------------------)
    ·12 min read·Mar 8, 2023
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·发表于 [Towards Data Science](https://towardsdatascience.com/?source=post_page-----82981a44c4fe--------------------------------)
    ·阅读时间 12 分钟·2023年3月8日
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/109864dbe39d0cc00200a8a32e4dab4a.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/109864dbe39d0cc00200a8a32e4dab4a.png)'
- en: Photo by [Taylor Vick](https://unsplash.com/ko/@tvick?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由 [Taylor Vick](https://unsplash.com/ko/@tvick?utm_source=medium&utm_medium=referral)
    提供，来源于 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: MLOps (Machine Learning Operations) is an increasingly popular function and
    skill among data professionals. More and more, full stack data scientists who
    are capable of taking machine learning (ML) projects from training to production
    are in demand, so if you feel a bit uncomfortable in this area, or you want a
    quick refresher, this post is for you! If you’ve never deployed a model before,
    I highly encourage you to checkout my previous post that gives you more of an
    introduction into ML deployment and explains many concepts that will be used in
    this post.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: MLOps（机器学习运维）在数据专业人员中越来越受欢迎。能够将机器学习（ML）项目从训练到生产的全栈数据科学家需求不断增加，所以如果你在这一领域感觉有些不适，或者想要快速复习一下，这篇文章就是为你准备的！如果你从未部署过模型，我强烈建议你查看我之前的文章，它会更详细地介绍
    ML 部署，并解释许多在本文中会用到的概念。
- en: '[](/introduction-to-ml-deployment-flask-docker-locust-b87b5bd78a17?source=post_page-----82981a44c4fe--------------------------------)
    [## Introduction to ML Deployment: Flask, Docker & Locust'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[](/introduction-to-ml-deployment-flask-docker-locust-b87b5bd78a17?source=post_page-----82981a44c4fe--------------------------------)
    [## 机器学习部署简介：Flask、Docker 和 Locust'
- en: Learn how to deploy your models in Python and measure the performance using
    Locust
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习如何在 Python 中部署你的模型，并使用 Locust 测量性能
- en: towardsdatascience.com](/introduction-to-ml-deployment-flask-docker-locust-b87b5bd78a17?source=post_page-----82981a44c4fe--------------------------------)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: towardsdatascience.com](/introduction-to-ml-deployment-flask-docker-locust-b87b5bd78a17?source=post_page-----82981a44c4fe--------------------------------)
- en: 'This post is going to cover quite a few topics, so feel free to skip to the
    chapters you’re the most interested in. The structure of this post is:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本帖将涵盖相当多的话题，所以可以随意跳到你最感兴趣的章节。本文的结构如下：
- en: '**Use FastAPI to specify API for inference endpoint**'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用 FastAPI 指定推理端点的 API**'
- en: '**Containerise the endpoint using Docker**'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用 Docker 将端点容器化**'
- en: '**Upload the Docker image to Artifact Registry in GCP**'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将 Docker 镜像上传到 GCP 的 Artifact Registry**'
- en: '**Deploy the image to Google Cloud Run**'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将镜像部署到 Google Cloud Run**'
- en: '**Monitor the inference speed and load-test the deployment**'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**监控推理速度并进行负载测试**'
- en: '![](../Images/7b310e2855a73fa27a1ecbf856928cea.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7b310e2855a73fa27a1ecbf856928cea.png)'
- en: Project steps overview. Image by author.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 项目步骤概述。图片由作者提供。
- en: Setup
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置
- en: First things first, you’ll need to install `fastapi` , `uvicorn`and `Docker`
    on your local machine to complete the first two steps. The third and fourth steps
    require you to have an active `Google Cloud Platform` account with enabled `Articat
    Registry` and `Cloud Run` APIs. Luckily, GCP offers a free trial period with free
    credits which you can activate using your Gmail account. In addition, you’ll want
    to install `gcloud` CLI tool which will allow you to interact with your GCP account
    through the CLI. Finally, you’ll want to install Locust for load testing. Exact
    installation steps will depend on your system but below you can find all the links
    to the installation instructions.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要在本地计算机上安装 `fastapi`、`uvicorn` 和 `Docker` 来完成前两步。第三步和第四步需要你拥有一个已启用 `Artifact
    Registry` 和 `Cloud Run` API 的有效 `Google Cloud Platform` 账户。幸运的是，GCP 提供了免费试用期和免费额度，你可以使用
    Gmail 账户激活。此外，你还需要安装 `gcloud` CLI 工具，以便通过 CLI 与 GCP 账户进行交互。最后，你还需要安装 Locust 进行负载测试。具体的安装步骤会根据你的系统有所不同，但下面你可以找到所有安装说明的链接。
- en: '[Install FastAPI and Uvicorn](https://fastapi.tiangolo.com/tutorial/)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[安装 FastAPI 和 Uvicorn](https://fastapi.tiangolo.com/tutorial/)'
- en: '[Download and install Docker](https://docs.docker.com/get-docker/)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[下载并安装 Docker](https://docs.docker.com/get-docker/)'
- en: '[Get free GCP account](https://cloud.google.com/free)'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[获取免费 GCP 账户](https://cloud.google.com/free)'
- en: '[Install gcloud CLI](https://cloud.google.com/sdk/docs/install-sdk)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[安装 gcloud CLI](https://cloud.google.com/sdk/docs/install-sdk)'
- en: '[Install Locust](https://docs.locust.io/en/stable/installation.html)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[安装 Locust](https://docs.locust.io/en/stable/installation.html)'
- en: All the code is available in [this GitHub repo](https://github.com/aruberts/tutorials/tree/main/deployment/fastapi).
    Make sure to pull it and follow along, since it’s the best way to learn (in my
    opinion).
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 所有代码都可以在 [这个 GitHub 仓库](https://github.com/aruberts/tutorials/tree/main/deployment/fastapi)
    中找到。一定要拉取代码并跟着操作，因为这是最好的学习方法（在我看来）。
- en: Project Overview
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: To make the learning more practical, this post will show you how to deploy a
    model for loan default prediction. Model training process is out of scope for
    this post, but you can find an already trained model in the [Github repo](https://github.com/aruberts/tutorials/tree/main/deployment/fastapi).
    The model was trained on the pre-processed [U.S. Small Business Administration
    dataset](https://www.kaggle.com/datasets/mirbektoktogaraev/should-this-loan-be-approved-or-denied)
    (CC BY-SA 4.0 license). Feel free to explore the data dictionary to understand
    what each of the columns mean.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使学习更加实用，本文将展示如何部署一个贷款违约预测模型。模型训练过程超出了本文的范围，但你可以在 [Github 仓库](https://github.com/aruberts/tutorials/tree/main/deployment/fastapi)
    找到一个已经训练好的模型。该模型是在经过预处理的 [美国小企业管理局数据集](https://www.kaggle.com/datasets/mirbektoktogaraev/should-this-loan-be-approved-or-denied)（CC
    BY-SA 4.0 许可证）上训练的。欢迎探索数据字典以了解每一列的含义。
- en: The main goal of this project is to create a working endpoint (called `/predict`)
    which will receive POST requests with information about loan applications (i.e.
    model features) and will output a response with default probabilities.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的主要目标是创建一个工作端点（称为 `/predict`），该端点将接收包含贷款申请信息（即模型特征）的 POST 请求，并输出一个包含违约概率的响应。
- en: '![](../Images/41e332a243b1327c9c909717142cc832.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/41e332a243b1327c9c909717142cc832.png)'
- en: Simplified ML prediction system. Image by author.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 简化的机器学习预测系统。图像由作者提供。
- en: With all of this out of the way, let’s finally get started! First, let’s see
    how we can create an inference API using FastAPI library.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 既然这些都处理完了，我们终于可以开始了！首先，让我们看看如何使用 FastAPI 库创建一个推理 API。
- en: Create Inference API
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建推理 API
- en: What even is API?
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 API？
- en: 'An API (Application Programming Interface) is a set of established protocols
    for external programs to interact with your application. To explain it a bit more
    intuitively, here’s a quote from a really [good answer](https://stackoverflow.com/questions/6220618/what-does-it-mean-to-create-an-api-on-the-web)
    on Stack Overflow:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: API（应用程序编程接口）是一组已建立的协议，用于外部程序与您的应用程序进行交互。为了更直观地解释一下，这里有一个来自 [Stack Overflow
    上一个很好的回答](https://stackoverflow.com/questions/6220618/what-does-it-mean-to-create-an-api-on-the-web)
    的引用：
- en: Web APIs are entry points on an application running on a web server that permit
    other tools to interact with that web service in some way. Think of it as a “user
    interface” for software. A list of URLs and how to interact with them is all *any*
    web API is, in the end.
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Web APIs 是在网络服务器上运行的应用程序的入口点，允许其他工具以某种方式与该网络服务交互。可以将其视为软件的“用户界面”。最终，任何 web API
    其实就是一系列 URL 和如何与它们交互的说明，*仅此而已*。
- en: 'In other words, our API will take care of specifying how to interact with the
    application that hosts the ML model. To be more precise, it will specify:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们的 API 将负责指定如何与托管 ML 模型的应用程序进行交互。更准确地说，它将指定：
- en: What’s the URL of the prediction service
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预测服务的 URL 是什么
- en: What information the service expects as input
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务期望的输入信息
- en: What information the service will provide as outputs
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务将提供哪些信息作为输出
- en: FastAPI
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FastAPI
- en: FastAPI is a Python framework for developing web APIs. It’s quite similar to
    Flask (covered in my [previous post](/introduction-to-ml-deployment-flask-docker-locust-b87b5bd78a17))
    but there are a few notable advantages.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 是一个用于开发 Web API 的 Python 框架。它与 Flask 非常相似（在我 [之前的文章](/introduction-to-ml-deployment-flask-docker-locust-b87b5bd78a17)
    中有介绍），但有一些显著的优势。
- en: In-built data validation using Pydantic
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置数据验证使用 Pydantic
- en: Automatic documentation with SwaggerUI
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SwaggerUI 的自动文档生成
- en: Asynchronous task support using ASGI
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ASGI 的异步任务支持
- en: Overall simpler syntaxis
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更简单的语法
- en: The creator of this framework has basically explored every other solution for
    building APIs, decided what he likes about them, and combined all the nice functionalities
    into FastAPI (for which we’re very grateful, so don’t forget to star the [github
    repo](https://github.com/tiangolo/fastapi)).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架的创建者基本上探索了构建 API 的其他所有解决方案，决定了他喜欢哪些功能，并将所有这些良好功能合并到了 FastAPI 中（我们对此非常感激，所以不要忘记给
    [github 仓库](https://github.com/tiangolo/fastapi) 点个星）。
- en: Input and Output Validation
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入和输出验证
- en: Before creating an endpoint, it’s important to define the type of information
    that is expected as input and output. FastAPI accepts JSON requests and responses,
    but it’s crucial to specify the fields that are required and their respective
    data types. To accomplish this, FastAPI utilizes [Pydantic](https://docs.pydantic.dev/),
    which validates type hints during runtime and offers clear and user-friendly error
    messages whenever invalid data is submitted.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建端点之前，定义预期的输入和输出信息类型是很重要的。FastAPI 接受 JSON 请求和响应，但必须指定所需字段及其数据类型。为此，FastAPI
    使用了 [Pydantic](https://docs.pydantic.dev/)，它在运行时验证类型提示，并在提交无效数据时提供清晰且用户友好的错误消息。
- en: The way that Pydantic enforces these data types is through data models. Data
    models are simply Python classes that inherit from `pydantic.BaseModel` and list
    expected fields and their types as class variables. Above you can see how I’ve
    specified the expected input in `LoanApplication` class and the expected output
    in `PredictioutOut` class. This type of strict validation can help you catch errors
    early in the development process and prevent them from causing issues in production.
    We can also specify the acceptable ranges for each of these parameters, but I’ll
    skip this step for now.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic 强制执行这些数据类型的方式是通过数据模型。数据模型只是继承自 `pydantic.BaseModel` 的 Python 类，并将预期字段及其类型列为类变量。上面你可以看到我如何在
    `LoanApplication` 类中指定预期的输入，以及在 `PredictionOut` 类中指定预期的输出。这种严格的验证可以帮助你在开发过程中尽早发现错误，防止它们在生产中引发问题。我们还可以为这些参数指定可接受的范围，但我现在会跳过这一步。
- en: Application and Endpoint Creation
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序和端点创建
- en: FastAPI is used to both create an application and define different endpoints
    that will server as APIs. Here’s a very simple example of a FastAPI application
    that has a prediction endpoint.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 用于创建应用程序并定义作为 API 的不同端点。这里有一个非常简单的 FastAPI 应用示例，其中包含一个预测端点。
- en: 'Let’s digest the code above:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解析一下上面的代码：
- en: It imports the necessary libraries and loads a pre-trained CatBoost model that
    has been saved in a file
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它导入必要的库并加载一个已经保存到文件中的预训练 CatBoost 模型
- en: It creates a FastAPI app instance by assigning `FastAPI` class to the `app`
    variable
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它通过将 `FastAPI` 类分配给 `app` 变量来创建一个 FastAPI 应用实例
- en: It defines an API endpoint for making predictions that expects POST requests
    by decorating a function with the `@app.post("/predict", response_model=PredictionOut)`
    decorator. The `response_model` parameter specifies the expected output format
    of the API endpoint
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它通过用 `@app.post("/predict", response_model=PredictionOut)` 装饰器装饰一个函数来定义一个用于进行预测的
    API 端点，该端点期望 POST 请求。`response_model` 参数指定了 API 端点的预期输出格式。
- en: The `predict` function takes a payload, which is expected to be an instance
    of a Pydantic model called `LoanApplication`. This payload is used to create a
    pandas DataFrame, which is then used to generate a prediction using the pre-trained
    `catboost` model. The predicted probability of default is returned as a JSON object
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`predict`函数接收一个负载，该负载预计是一个名为`LoanApplication`的 Pydantic 模型的实例。这个负载用于创建一个 pandas
    DataFrame，然后用这个 DataFrame 使用预训练的`catboost`模型生成预测。预测的违约概率作为 JSON 对象返回。'
- en: Notice how the previously defined input and output data classes came into play.
    We specify the expected response format using `response_model` parameter in the
    decorator and the request format as the input type hint in the `predict` function.
    Very easy and clean, yet highly effective.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，之前定义的输入和输出数据类是如何发挥作用的。我们使用装饰器中的`response_model`参数指定期望的响应格式，并在`predict`函数中将请求格式作为输入类型提示。非常简单而干净，但非常有效。
- en: There you have it! In a few lines of code, we’ve created an application with
    a prediction endpoint (API) and full fledged data validation capabilities. To
    start up this application locally you can run this command.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！在几行代码中，我们创建了一个带有预测端点（API）和完整数据验证能力的应用程序。要在本地启动此应用程序，你可以运行这个命令。
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If everything goes well, you’ll see that the application is running at the specified
    address.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你会看到应用程序在指定的地址上运行。
- en: '![](../Images/de344917331f9ea5a547173527fd9f6e.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/de344917331f9ea5a547173527fd9f6e.png)'
- en: Screenshot by author
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 截图由作者提供
- en: Documentation with Swagger UI
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Swagger UI 的文档
- en: Here’s a cool thing about FastAPI — we get the documentation for free! Head
    over to the [**http://0.0.0.0:80/docs**](http://0.0.0.0:80/docs)and you should
    see a Swagger UI screen.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 FastAPI 的一个酷炫之处——我们免费获得了文档！前往[**http://0.0.0.0:80/docs**](http://0.0.0.0:80/docs)，你应该能看到一个
    Swagger UI 屏幕。
- en: '![](../Images/d2593915d4bab07b8326db21283924d2.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d2593915d4bab07b8326db21283924d2.png)'
- en: Swagger UI. Screenshot by author.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger UI。截图由作者提供。
- en: In the same screen you can test out your API by clicking on our POST endpoint
    (in green) and editing the default request body. Then, click execute and you’ll
    see what the API responds with.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一屏幕上，你可以通过点击我们的 POST 端点（绿色的）并编辑默认请求体来测试你的 API。然后，点击执行，你将看到 API 的响应。
- en: '![](../Images/d292bf9bf95fcf1c29033bac55a0de06.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d292bf9bf95fcf1c29033bac55a0de06.png)'
- en: Request body in the UI. Screenshot by author.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面中的请求体。截图由作者提供。
- en: If you’ve specified everything correctly, you should get a response code 200
    which means that the request has been successful. The body of this response should
    contain JSON with `default_probability` which we’ve previously specified as output
    of our `/predict` endpoint.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正确地指定了所有内容，你应该会收到响应代码 200，这意味着请求已成功。此响应的主体应包含之前指定的`default_probability`的
    JSON，这是我们`/predict`端点的输出。
- en: '![](../Images/aa00fe6f08323137cb94e6495cdf7c1a.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/aa00fe6f08323137cb94e6495cdf7c1a.png)'
- en: Response body in the UI. Screenshot by author.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面中的响应体。截图由作者提供。
- en: Of course, you can test the API programmatically as well using a `request` library
    but the UI gives you a nice and intuitive alternative.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以使用`request`库以编程方式测试 API，但用户界面为你提供了一个不错且直观的替代方案。
- en: Containerise the Application Using Docker
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 对应用程序进行容器化
- en: As I’ve mentioned in my previous [post](https://medium.com/towards-data-science/introduction-to-ml-deployment-flask-docker-locust-b87b5bd78a17),
    containerisation is the process of encapsulating your application and all of its
    dependencies (including Python) into a self-contained, isolated package that can
    run consistently across different environments (e.g. locally, in the cloud, on
    your friend’s laptop, etc.). FastAPI has a great documentation of how to run FastAPI
    in Docker, so check it out [here](https://fastapi.tiangolo.com/deployment/docker/)
    if you’re interested in more details.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在之前的[帖子](https://medium.com/towards-data-science/introduction-to-ml-deployment-flask-docker-locust-b87b5bd78a17)中提到的，容器化是将应用程序及其所有依赖项（包括
    Python）封装成一个自包含的、隔离的包的过程，这样可以在不同的环境（例如本地、云端、朋友的笔记本等）中一致地运行。FastAPI 有一个关于如何在 Docker
    中运行 FastAPI 的极佳文档，如果你对更多细节感兴趣，可以查看[这里](https://fastapi.tiangolo.com/deployment/docker/)。
- en: Below, you can see a Dockerfile (set of instructions for Docker) for our API.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下面，你可以看到我们 API 的 Dockerfile（Docker 指令集）。
- en: 'It’s identical to the one we’ve used with Flask with exception of the last
    command that gets run. Here’s a brief description of what this Dockerfile achieves:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 除了最后运行的命令外，它与我们在 Flask 中使用的完全相同。以下是对这个 Dockerfile 实现的简要描述：
- en: '`FROM python:3.9-slim`: Specifies the container’s base image as Python version
    3.9 with the slim variant, which is a smaller image compared to the regular Python
    image'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FROM python:3.9-slim`：指定容器的基础镜像为 Python 版本 3.9 的 slim 变体，相较于普通 Python 镜像更小'
- en: '`WORKDIR /app`: This instruction sets the working directory inside the container
    to `/app`'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WORKDIR /app`：这个指令将容器内部的工作目录设置为 `/app`'
- en: '`COPY requirements.txt requirements.txt`: This instruction copies the `requirements.txt`
    file from the host machine to the container''s `/app` directory'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`COPY requirements.txt requirements.txt`：这个指令将 `requirements.txt` 文件从主机复制到容器的
    `/app` 目录'
- en: '`RUN pip install --upgrade pip & RUN pip install -r requirements.txt`: This
    instruction upgrades `pip` and installs the required packages specified in the
    `requirements.txt` file using `pip`'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RUN pip install --upgrade pip & RUN pip install -r requirements.txt`：这个指令升级
    `pip` 并使用 `pip` 安装 `requirements.txt` 文件中指定的所需包'
- en: '`COPY ["loan_catboost_model.cbm", "app.py", "./"] .`: This instruction copies
    the trained CatBoost model, and the `app.py` file, which contains the Python code
    for the application, from the host machine to the container''s `/app` directory'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`COPY ["loan_catboost_model.cbm", "app.py", "./"] .`：这个指令将训练好的 CatBoost 模型和包含应用程序
    Python 代码的 `app.py` 文件从主机复制到容器的 `/app` 目录'
- en: '`CMD ["uvicorn", "app:app", "--host", "0.0.0.0", "--port", "80"]`: This instruction
    specifies the command that should be run when the container starts. It runs the
    `uvicorn` server with the `app` module as the main application at URL `0.0.0.0:80`'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CMD ["uvicorn", "app:app", "--host", "0.0.0.0", "--port", "80"]`：这个指令指定了容器启动时应该运行的命令。它运行
    `uvicorn` 服务器，以 `app` 模块作为主应用程序，URL 为 `0.0.0.0:80`'
- en: Build the Docker Image
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 Docker 镜像
- en: Once the Dockerfile is defined, we need to build a Docker image based on it.
    It’s quite simple to build the image locally, all you need to do is to run the
    following command in the folder where your Dockerfile and the application code
    is.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Dockerfile 被定义，我们需要基于它构建一个 Docker 镜像。构建镜像在本地非常简单，你只需在包含 Dockerfile 和应用代码的文件夹中运行以下命令即可。
- en: '[PRE1]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will create an image called `default-service-fastapi` and will save it
    locally. You can run `docker images` in your CLI to see it listed among the other
    Docker images you have.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为 `default-service-fastapi` 的镜像，并将其保存在本地。你可以在 CLI 中运行 `docker images`
    来查看它是否在你拥有的其他 Docker 镜像中列出。
- en: Push the Image to Google Artifact Registry
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将镜像推送到 Google Artifact Registry
- en: 'The process of pushing this image to Google Artifact Registry is a bit more
    involved but it is very nicely [documented by Google](https://cloud.google.com/artifact-registry/docs/docker/pushing-and-pulling).
    There are five steps to this process:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 将此镜像推送到 Google Artifact Registry 的过程稍微复杂一些，但[Google](https://cloud.google.com/artifact-registry/docs/docker/pushing-and-pulling)提供了非常详尽的文档。这个过程包括五个步骤：
- en: Configure Docker permissions to access your Artifact Registry
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置 Docker 权限以访问你的 Artifact Registry
- en: Enable Artifact Registry in your GCP
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 GCP 中启用 Artifact Registry
- en: Create a repo in the Registry
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Registry 中创建一个仓库
- en: Tag your image using specific naming convention
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用特定的命名约定标记你的镜像
- en: Push the image
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推送镜像
- en: 'To begin with, you’ll need to determine in which location you want to have
    your container stored. You can find a full list [here](https://cloud.google.com/artifact-registry/docs/repositories/repo-locations).
    I’ll be choosing `europe-west2` , so a command for me to authenticate my Docker
    is:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要确定要存储容器的位置。你可以在[这里](https://cloud.google.com/artifact-registry/docs/repositories/repo-locations)找到完整的列表。我将选择`europe-west2`，所以我用来验证我的
    Docker 的命令是：
- en: '[PRE2]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The next two steps can be done in you GCP UI. Go to the Artifact Registry in
    the navigation menu and click the button to enable the API. Then, go to the repositories
    and click **Create Repository** button. In the pop-up menu, specify that this
    is a Docker repository and set its location equal to the previously selected one
    (for me it’s `europe-west2` )
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个步骤可以在你的 GCP UI 中完成。前往导航菜单中的 Artifact Registry，点击按钮以启用 API。然后，前往仓库并点击 **创建仓库**
    按钮。在弹出的菜单中，指定这是一个 Docker 仓库，并将其位置设置为之前选择的那个位置（对我而言是 `europe-west2`）
- en: '![](../Images/396363d0e8cef31425f00c210fa61110.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/396363d0e8cef31425f00c210fa61110.png)'
- en: Google Artifact Registry. Screenshot by author.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Google Artifact Registry。作者截图。
- en: All the setup is done, so let’s begin the main part. To tag an image with appropriate
    name and to push it we need to run two specific commands.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 所有设置完成后，让我们开始主要部分。为了用合适的名称标记镜像并推送它，我们需要运行两个特定的命令。
- en: '[PRE3]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Since the image name is `default-servise-fastapi` , repository name is `ml-images`
    and my project ID is `rosy-flames376113` , the commands for me look as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于镜像名称是 `default-servise-fastapi`，仓库名称是 `ml-images`，而我的项目 ID 是 `rosy-flames376113`，所以对我来说，命令如下：
- en: '[PRE4]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The command will take some time to execute but once it’s done, you’ll be able
    see your Docker image in your Artifact Registry UI.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 命令执行可能需要一些时间，但一旦完成，你将能够在你的 Artifact Registry 界面中看到你的 Docker 镜像。
- en: By the way, you can find your Project ID or create a new project in the GCP
    UI by clicking the dropdown button next to your Project name (My First Project
    in the example below).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，你可以在 GCP UI 中通过点击项目名称旁边的下拉按钮（下例中的“我的第一个项目”）来查找你的项目 ID 或创建一个新项目。
- en: '![](../Images/49da8f89293c5d16e97fa33f3c50e6e0.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/49da8f89293c5d16e97fa33f3c50e6e0.png)'
- en: GCP UI. Screenshot by author.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: GCP UI。截图由作者提供。
- en: Deploy Container on Google Cloud Run
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Google Cloud Run 上部署容器
- en: The actual deployment step is relatively easy with GCP. The only thing you need
    to take care of is to enable the Cloud Run API in your GCP project by going to
    the **Cloud Run** section in navigation menu and clicking on the button to enable
    the API.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的部署步骤在 GCP 中相对简单。你需要做的唯一事情是通过进入导航菜单中的 **Cloud Run** 部分并点击启用 API 的按钮来启用 Cloud
    Run API。
- en: There are two ways to create a service in Cloud Run — through the CLI or in
    the UI. I’m going to show you how to do it using CLI, and you can explore the
    UI option on your own.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cloud Run 中创建服务有两种方式 — 通过 CLI 或在 UI 中。我将向你展示如何使用 CLI，你可以自行探索 UI 选项。
- en: '[PRE5]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This command will create a `default-service` (a.k.a our API) from the previously
    uploaded image in the Artifact Registry. In addition, it also specifies the region
    (the same as our Docker image), the port to expose, and the RAM available to the
    service. Other parameters that you can specify, you can check out in the [official
    documentation](https://cloud.google.com/sdk/gcloud/reference/run/deploy).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将从之前上传的 Artifact Registry 镜像中创建一个 `default-service`（即我们的 API）。此外，它还指定了区域（与我们的
    Docker 镜像相同）、要暴露的端口以及可用于服务的 RAM。你可以在 [官方文档](https://cloud.google.com/sdk/gcloud/reference/run/deploy)
    中查看你可以指定的其他参数。
- en: '![](../Images/937a02cab0e345f245d353fc3303a175.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/937a02cab0e345f245d353fc3303a175.png)'
- en: If you see a url in your command line — congrats! Your model is officially deployed!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在命令行中看到一个 URL — 恭喜！你的模型已经正式部署了！
- en: Test the Deployment
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试部署
- en: Similar to the previous post, I’ll be using Locust to test the deployment. Here’s
    the test scenario that will be tested — the user sends a request with loan information
    and receives a response with default probability (very unrealistic but works for
    our purposes).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的帖子类似，我将使用 Locust 来测试部署。这里是将要测试的测试场景 — 用户发送带有贷款信息的请求，并接收带有默认概率的响应（虽然不现实，但适用于我们的目的）。
- en: With local Flask deployment, my laptop could take up to ~180 requests per second
    before it started failing. In addition, the response time was gradually increasing
    with the number of requests per second. Let’s run the test for our cloud deployment
    and see if it performs any better. To launch the test, run `locust -f app_test.py`
    (`app_test.py` contains the test scenario from above) and input the URL of your
    server in the UI located be default at **http://0.0.0.0:8089.**I’ve put the limit
    of users as 300 with the spawn rate of 5 but you can change it to whatever you
    like.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地 Flask 部署的情况下，我的笔记本电脑在开始出现故障之前可以处理多达 ~180 个请求每秒。此外，响应时间随着每秒请求数量的增加而逐渐增加。让我们对我们的云部署进行测试，看看它的表现是否更好。要启动测试，请运行
    `locust -f app_test.py`（`app_test.py` 包含上述测试场景），并在默认位于 **http://0.0.0.0:8089**
    的 UI 中输入你的服务器的 URL。我将用户限制设置为 300，生成速率为 5，但你可以根据需要进行更改。
- en: '**Keep in mind that Cloud Run bills per request**, so be mindful with these
    parameters!'
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**请注意 Cloud Run 按请求计费**，所以要谨慎设置这些参数！'
- en: '![](../Images/822f938fd0d4a7b8d8d2a9deeff7b56f.png)![](../Images/0026493fd63420c28ae190a4c0d1515e.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/822f938fd0d4a7b8d8d2a9deeff7b56f.png)![](../Images/0026493fd63420c28ae190a4c0d1515e.png)'
- en: Local Deployment (Left) vs Cloud Deployment (Right) Load Tests. Charts by author.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本地部署（左）与云部署（右）负载测试。图表由作者提供。
- en: After the traffic reaches its peak, here’re the charts that I see for my server.
    First things first, the server didn’t fail even with 300 requests per second which
    is great news. This means that cloud deployment is more robust than running a
    model on your local machine. Secondly, the median response time is way lower and
    stays almost constant with the increased traffic which means that this deployment
    is also more performant.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当流量达到峰值后，这里是我为我的服务器看到的图表。首先，服务器在每秒300个请求的情况下没有崩溃，这真是好消息。这意味着云部署比在本地机器上运行模型更为可靠。其次，中位响应时间更低，并且在流量增加的情况下几乎保持不变，这意味着该部署性能也更佳。
- en: There are however two notable peaks in the 95th percentiles — in the beginning
    of the test and closer to the end. The first spike can be explained by the fact
    that Cloud Run servers stand idle until they start receiving traffic. This means
    that the service needs to warm-up, so low speeds and even some failures are to
    be expected in the beginning. The second bump is probably due to the server starting
    to reach its capacity. However, you might notice that by the end of the test,
    95th percentile speed started to decrease. This is due to our service starting
    to automatically scale-up (thanks Google!) as you can see in the dashboard below.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在第95百分位数中有两个显著的峰值——测试开始时和接近结束时。第一个峰值可以解释为Cloud Run服务器在开始接收流量之前保持空闲。这意味着服务需要预热，因此在开始时可能会出现较低的速度甚至一些失败。第二个峰值可能是由于服务器开始接近其容量。然而，你可能会注意到，在测试结束时，第95百分位数速度开始下降。这是因为我们的服务开始自动扩展（感谢Google！），正如你在下面的仪表板中所看到的。
- en: '![](../Images/fe4dc24a9bbe5b91d2066c6a598c12d2.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/fe4dc24a9bbe5b91d2066c6a598c12d2.png)'
- en: Metrics Dashboard in Cloud Run. Screenshot by author.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Run中的指标仪表板。作者截图。
- en: At its peak, the service actually had 12 instances running, instead of 1\. I’d
    say that this is the main advantage of managed services like Cloud Run — you don’t
    need to worry about scalability of your deployment. Google will take care of adding
    new resources (as long as you can pay of course) and will ensure smooth running
    of your application.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在峰值时，该服务实际上运行了12个实例，而不是1个。我认为这是像Cloud Run这样的托管服务的主要优势——你不需要担心部署的可扩展性。Google会负责添加新资源（当然只要你能支付），并确保你的应用程序平稳运行。
- en: Conclusion
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: 'This has been quite a ride, so let’s summarise everything we’ve done in this
    post:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这段经历非常精彩，所以让我们总结一下我们在这篇文章中所做的一切：
- en: Created a basic APIs with an inference endpoint using FastAPI
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用FastAPI创建了一个带有推理端点的基本API
- en: Containerised the API using Docker
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker对API进行了容器化
- en: Built the Docker image and pushed it to the Artifact Registry in GCP
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建了Docker镜像并将其推送到GCP中的Artifact Registry
- en: Turned this image into a service using Google Cloud Run
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Google Cloud Run将此图像转化为服务
- en: Tested the deployment’s robustness and inference speed using Locust
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Locust测试了部署的鲁棒性和推理速度
- en: Really well done for following through these chapters! I hope that now you feel
    more confident about the deployment step of ML process and can put your own models
    into production. Let me know if you have any questions remaining, and I’ll try
    to cover them in the next posts.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 非常棒，继续阅读这些章节！我希望现在你对ML过程中的部署步骤感到更自信，并且可以将自己的模型投入生产。如果你还有任何问题，请告诉我，我会在下一个帖子中尽量解答。
- en: Not A Member Yet?
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还不是会员？
- en: '[](https://medium.com/@antonsruberts/membership?source=post_page-----82981a44c4fe--------------------------------)
    [## Join Medium with my referral link - Antons Tocilins-Ruberts'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@antonsruberts/membership?source=post_page-----82981a44c4fe--------------------------------)
    [## 使用我的推荐链接加入Medium - Antons Tocilins-Ruberts'
- en: Read every story from Antons Tocilins-Ruberts (and thousands of other writers
    on Medium). Your membership fee directly…
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阅读Antons Tocilins-Ruberts的每一个故事（以及Medium上的其他成千上万的作者的故事）。你的会员费直接…
- en: medium.com](https://medium.com/@antonsruberts/membership?source=post_page-----82981a44c4fe--------------------------------)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: medium.com](https://medium.com/@antonsruberts/membership?source=post_page-----82981a44c4fe--------------------------------)
