- en: 30 SQL Queries Explained Through Their Pandas Equivalents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/sql-for-people-who-love-pandas-a-10-minute-yet-thorough-tutorial-c189de9d417d](https://towardsdatascience.com/sql-for-people-who-love-pandas-a-10-minute-yet-thorough-tutorial-c189de9d417d)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SQL made much easier for people who love Pandas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://ibexorigin.medium.com/?source=post_page-----c189de9d417d--------------------------------)[![Bex
    T.](../Images/516496f32596e8ad56bf07f178a643c6.png)](https://ibexorigin.medium.com/?source=post_page-----c189de9d417d--------------------------------)[](https://towardsdatascience.com/?source=post_page-----c189de9d417d--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----c189de9d417d--------------------------------)
    [Bex T.](https://ibexorigin.medium.com/?source=post_page-----c189de9d417d--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----c189de9d417d--------------------------------)
    ·10 min read·Jun 9, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4804e3d33ecae544cceeee4a0f1df5f4.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by me with Midjourney
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a world dominated by SQL since 1974, along came Pandas in 2008, offering
    attractive features like built-in visualization and flexible data handling. It
    quickly became the go-to tool for data exploration, overshadowing SQL.
  prefs: []
  type: TYPE_NORMAL
- en: But don’t be fooled, SQL still holds its ground. It’s the second most in-demand
    and third fastest-growing language for data science (see [here](/the-most-in-demand-skills-for-data-scientists-in-2021-4b2a808f4005)).
    So, while Pandas steals the spotlight, SQL remains a vital skill for any data
    scientist.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s find out how easy it is to learn SQL when you already know Pandas.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a Database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Setting up an SQL workspace and connecting to a sample database can be a real
    pain. First, you need to install your favorite SQL flavor (PostgreSQL, MySQL,
    etc.) and download an SQL IDE. Doing those here would draw us away the article’s
    purpose, so we will use a shortcut.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we will directly run SQL queries in a Jupyter Notebook without
    additional steps. All we need to do is install the `ipython-sql` package using
    pip:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After the installation, start a new Jupyter session and run this command in
    the notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: and you are all set!
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate how basic SQL statements work, we will be using [the Chinook SQLite
    database](https://github.com/lerocha/chinook-database), which has 11 tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'To load the dataset and its 11 tables as separate variables into our environment,
    we can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The statement starts with `%sql` in-line magic command that tells the notebook
    interpreter we will be running SQL commands. It is followed by the path that the
    downloaded Chinook database is in.
  prefs: []
  type: TYPE_NORMAL
- en: The valid paths should always start with `sqlite:///` prefix for SQLite databases.
    Above, we are connecting to the database stored in the 'data' folder of the current
    directory. If you want to pass an absolute path, the prefix should start with
    four forward slashes - `sqlite:////`
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to connect to a different database flavor, you can refer to this
    [excellent article](/heres-how-to-run-sql-in-jupyter-notebooks-f26eb90f3259).
  prefs: []
  type: TYPE_NORMAL
- en: Taking a First Look at the Tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we always do in Pandas is to use the `.head()` function to
    take a first look at the data. Let''s learn how to do that in SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/dc7f4d416bfea6b0cacc14a983ddf7b5.png)'
  prefs: []
  type: TYPE_IMG
- en: The dataset is licensed for commercial use as well.
  prefs: []
  type: TYPE_NORMAL
- en: The first keyword in the above query is `SELECT`. It is equivalent to the brackets
    operator in Pandas, where we select specific columns. But, the SELECT keyword
    is followed by a * (asterisk). ***** is an SQL operator that selects everything
    (all rows and columns) from a table specified after the `FROM` keyword. LIMIT
    is used to minimize the output returned. So, the above query is equivalent to
    `df.head()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t want to select all columns, you can specify one or more column
    names after the SELECT keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e3c518e6fc2cdd19719295689634550e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The equivalent Pandas operation is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Another useful keyword in SQL is `DISTINCT`. Adding this keyword before any
    column name returns its unique values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/125978d65bce95c1364fb4730bcdee41.png)'
  prefs: []
  type: TYPE_IMG
- en: Comments in SQL are written with double dashes.
  prefs: []
  type: TYPE_NORMAL
- en: Counting the Number of Rows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like Pandas has `.shape` attribute on its DataFrames, SQL has a `COUNT`
    function to display the number of rows in a table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/8a30d20e157f0b8ef126e0ec0aa776d2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'More helpful info would be counting the number of unique values in a particular
    column. We can do this by adding the DISTINCT keyword into COUNT:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a8db55163ef326a09e4d2ef03b920ca6.png)'
  prefs: []
  type: TYPE_IMG
- en: Filtering Results With WHERE Clauses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just looking and counting rows is pretty lame. Let’s see how we can filter rows
    based on conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s look at the songs which cost more than a dollar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b01521ec956e0db7dd095502ba029040.png)'
  prefs: []
  type: TYPE_IMG
- en: Songs that cost more than a dollar.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional statements are written in the WHERE clause, which always comes after
    FROM and before the LIMIT keywords. Using conditionals is pretty similar to how
    we do it in Pandas but I dare say the SQL version is more readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the COUNT function when using conditionals. For example, let’s
    see the number of songs that are priced between 1 and 10 dollars:'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the SQL version is much more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a6c7eee67f788d3de10c5e57e6788542.png)'
  prefs: []
  type: TYPE_IMG
- en: The number of songs that cost between 1 and 10 dollars.
  prefs: []
  type: TYPE_NORMAL
- en: Above we chained two conditions with the boolean operator AND. Other boolean
    operators (OR, NOT) are used similarly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s see all the invoices that have Paris *or* Berlin as a billing city:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4824e7acf91c1958acbf49ab817b4c3b.png)'
  prefs: []
  type: TYPE_IMG
- en: The invoices that are billed from either Berlin or Paris
  prefs: []
  type: TYPE_NORMAL
- en: 'The **equality** operator in SQL requires only one ‘=’ (equal) sign. The **inequality**
    operator is represented with either ‘!=’ or ‘<>’ operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ffad28285f3fea6e1f373cbf9e4132f1.png)'
  prefs: []
  type: TYPE_IMG
- en: The invoices where the billing city isn’t Berlin or Paris
  prefs: []
  type: TYPE_NORMAL
- en: Easier Filtering With BETWEEN And IN
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar conditionals are used very often, and writing them out with simple booleans
    becomes cumbersome. For example, Pandas has `.isin()` function which checks if
    a value belongs to a list of values.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to select invoices for five cities, we would have to write five
    chained conditions. Luckily, SQL supports a similar IN operator like `.isin()`
    so we don''t have to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/327884228f87e946f7439adaf40a86c3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The list of values after IN should be given as a tuple, not as a list. You
    can also negate the condition with the NOT keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/82549dfe24a4c8c67c1aa10a9b19c437.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another common filtering operation on numeric columns is to select values within
    a range. For this, BETWEEN keyword can be used, which is equivalent to `pd.Series.between()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4847efd137d14dc78ff08b57d62e06b4.png)'
  prefs: []
  type: TYPE_IMG
- en: Choosing the invoices with billing amount between 5 and 15.
  prefs: []
  type: TYPE_NORMAL
- en: Checking For Nulls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every data source has missing values, and databases are no exception. Just
    like there are several ways to explore the missing values in Pandas, there are
    specific keywords that check the existence of null values in SQL. The below query
    counts the number of rows with missing values in BillingState:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/83423d4f16fa55426964a7a000f18c11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can add the NOT keyword between IS and NULL to discard missing values of
    a particular column:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/012687577373b387bf9dbdf4286dd5c7.png)'
  prefs: []
  type: TYPE_IMG
- en: Better String Matching With LIKE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the WHERE clause, we filtered columns based on exact text values. But often,
    we may want to filter textual columns based on a pattern. In Pandas and pure Python,
    we would use regular expressions for pattern matching, which are very powerful
    but regex requires time to master.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an alternative, SQL offers a ‘%’ wildcard as a placeholder to match any
    character 0 or more times. For example, the ‘gr%’ string matches’ great,’ ‘groom,’
    ‘greed,’ and ‘%ex%’ matches any text with ‘ex’ in the middle, etc. Let’s see how
    to use it with SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3027ca269d06ef9e1a87879479a72d61.png)'
  prefs: []
  type: TYPE_IMG
- en: The above query finds all songs that start with ‘B.’ The string that contains
    the wildcard should come after the LIKE keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s find all songs that contain the word ‘beautiful’ in their titles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/54dd60788a78237eaa41b85e9cff6ede.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also use other boolean operators next to LIKE:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1720b5fe6e18b784bda4f6db6122e87c.png)'
  prefs: []
  type: TYPE_IMG
- en: There are many other wildcards in SQL that have different functionalities. You
    can see the complete list and their usage [here](https://www.w3schools.com/sql/sql_wildcards.asp).
  prefs: []
  type: TYPE_NORMAL
- en: Aggregate Functions in SQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is also possible to perform basic arithmetic operations on columns. These
    operations are called aggregate functions in SQL, and the most common ones are
    `AVG, SUM, MIN, MAX`. Their functionality should be clear from their names:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f10d9d963c9631af2a374f9c040bf26c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Aggregate functions give only a single result for the column you used them
    on. This means you cannot aggregate across one column and select other unaggregated
    columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/be6816913bd9ab3e0f3a9288c47e37cc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can combine aggregate functions with conditionals using WHERE clauses just
    as easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/83b9f728d822c748e59f368e21c23d24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It is also possible to use arithmetic operators such as +, -, *, / on columns,
    and simple numbers. When used on columns, the operation is performed element-wise:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0e944272637a2ea34be7c5ce7406e5bf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'One thing to note about arithmetic operations: if you perform operations on
    integers only, SQL thinks that you are expecting an integer as the answer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/2cc93888d6c83c6e87e5b7d0368febd6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Instead of returning 3.33…, the result is 3\. To get a float result, you should
    use at least one float number in the query or use all floats to be safe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/2432fdca12e14d0a42b848f8fc0b83bd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using this knowledge, let’s calculate the average duration of a song in minutes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2c5b0339aedae5044c05d0283519ae82.png)'
  prefs: []
  type: TYPE_IMG
- en: If you pay attention to the above column, its name is written as “*the query
    used to generate that column*.” Because of this behavior, using long calculations,
    such as finding the standard deviation or variance of a column, can be an issue
    because the column name will be as large as the query itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid this, SQL allows aliasing, similar to aliasing import statements in
    Python. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/533ccfaee872774e4c06b69c86b72455.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using `as` keyword after a single item in a `SELECT` statement tells SQL that
    we are aliasing. Here are more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/dd8bb65d466cc86d6be7896e4e50504e.png)'
  prefs: []
  type: TYPE_IMG
- en: You can use aliasing just as easily for columns with long names.
  prefs: []
  type: TYPE_NORMAL
- en: Ordering Results in SQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like Pandas has `sort_values` method, SQL supports ordering columns via
    `ORDER BY` clause. Passing a column name after the clause sorts the results in
    ascending order:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5e1d89c8ce00f2d1ef9a301f7bc33924.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We order the tracks table in ascending order by the composer’s name. Note that
    the ORDER BY statement should always come after the WHERE clause. It is also possible
    to pass two or more columns to ORDER BY:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/404087b630ec2fbf87892ebf4042f8bc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also reverse the ordering by passing the `DESC` keyword after each
    column name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/39e48cc6cf81385ea9c6a0934a32fbea.png)'
  prefs: []
  type: TYPE_IMG
- en: The above query returns three columns after ordering the UnitPrice and Compose
    in descending order and the name in ascending order (`ASC` is a default keyword).
  prefs: []
  type: TYPE_NORMAL
- en: Grouping in SQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most powerful functions of Pandas is the `groupby`. You can use
    it to transform a table into virtually any shape you want. Its very close cousin
    in SQL - `GROUP BY` clause can be used to achieve the same functionality. For
    example, the below query counts the number of songs in each genre:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3c12aa5902654883336982ec27625a74.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The difference between the GROUP BY in SQL and `groupby` in Pandas is that
    SQL does not allow selecting columns that weren''t given in the GROUP BY clause.
    For example, adding an extra free column in the above query generates an error:'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you can choose as many columns in the SELECT statement as you like
    as long as you are using some type of aggregate function on them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/00c7826c53ce7056b61a5391803e32a6.png)'
  prefs: []
  type: TYPE_IMG
- en: The above query includes almost all the topics we have learned up to this point.
    We are grouping by both album ID and genre ID, and for each group, we calculate
    the average duration and price of a song. We are also making efficient use of
    aliasing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make the query even more powerful by ordering by the average duration
    and genre count:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/45426a4b24bb076f7fd4fde15730e1a5.png)'
  prefs: []
  type: TYPE_IMG
- en: Pay attention to how we use the alias names of the aggregate functions in the
    ORDER BY clause. Once you alias a column or the result of the aggregate function,
    you can refer to them only by their alias for the rest of the query.
  prefs: []
  type: TYPE_NORMAL
- en: Using conditionals with HAVING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, SQL does not allow conditional filtering using aggregate functions
    in the WHERE clause. For example, we want to select only the genres where the
    number of songs is greater than 100\. Let’s try this with the WHERE clause:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The correct way of filtering rows based on the results of aggregate functions
    is using the HAVING clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/10f729ee3f781fa996eff4bd3655ba0e.png)'
  prefs: []
  type: TYPE_IMG
- en: HAVING clause is usually used with GROUP BY. Whenever you want to filter rows
    using aggregate functions, the HAVING clause is the way to go!
  prefs: []
  type: TYPE_NORMAL
- en: All images were generated by myself.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By now, you should have realized how powerful SQL can be and how much more readable
    it becomes compared to Pandas. Even though we learned a ton, we have barely scratched
    the surface.
  prefs: []
  type: TYPE_NORMAL
- en: For practice problems, I recommend [Data Lemur](https://datalemur.com/questions?category=SQL)
    or [LeetCode](https://leetcode.com/) if you are feeling adventurous.
  prefs: []
  type: TYPE_NORMAL
- en: Loved this article and, let’s face it, its bizarre writing style? Imagine having
    access to dozens more just like it, all written by a brilliant, charming, witty
    author (that’s me, by the way :).
  prefs: []
  type: TYPE_NORMAL
- en: For only 4.99$ membership, you will get access to not just my stories, but a
    treasure trove of knowledge from the best and brightest minds on Medium. And if
    you use [my referral link](https://ibexorigin.medium.com/membership), you will
    earn my supernova of gratitude and a virtual high-five for supporting my work.
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://ibexorigin.medium.com/membership?source=post_page-----c189de9d417d--------------------------------)
    [## Join Medium with my referral link — Bex T.'
  prefs: []
  type: TYPE_NORMAL
- en: Get exclusive access to all my ⚡premium⚡ content and all over Medium without
    limits. Support my work by buying me a…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ibexorigin.medium.com](https://ibexorigin.medium.com/membership?source=post_page-----c189de9d417d--------------------------------)
  prefs: []
  type: TYPE_NORMAL
