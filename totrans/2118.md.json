["```py\nimport requests\nimport base64\nimport cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef query(input_data):\n    response = requests.post({link to get the blackbox score}, \n                              json={'data': input_data})\n    return response.json()\n```", "```py\n def get_scores(input_image):\n    # Some preprocessing since the query accepted only bytes\n\n    _, input_image = cv2.imencode('.png', input_image)  \n    image_bytes = input_image.tobytes()\n    input_data = base64.b64encode(image_bytes).decode()\n    result = query(input_data)\n\n    \"\"\"\n    the result is a json dict {} with the variable 'output' or 'flag', \n    the output consists of scores for 1000 classes of which two are timber\n    wolf and granny smith. Initially the score for timber wolf is around 0.29\n    and the score for granny smith id 0.0005\n    \"\"\"\n\n    dict_score = {\"timber wolf\" : 0, \"Granny Smith\" : 0}\n\n    try:\n        print(result['flag'])\n    except:\n        pass\n\n    # the scores in the output are always sorted so the first score \n    # is always the predicted score\n\n    dict_score[\"predicted_class\"] = result['output'][0][1]\n    dict_score[\"predicted_score\"] = result['output'][0][0]\n\n    # next we get the scores for our wanted target and our original class\n    count = 0\n    for sublist in result['output']:\n        score, class_name = sublist\n        if class_name == \"timber wolf\":\n            dict_score['timber wolf'] = score\n            count+=1\n        elif class_name == \"Granny Smith\":\n            dict_score[\"Granny Smith\"] = score\n            if count ==1:\n                break\n\n    return dict_score\n```", "```py\n# Load your image\ninput_image = cv2.imread('/timber_wolf.png')\n# Get the dimensions of the original image\nimage_height, image_width, _ = input_image.shape\n\n# Define the size of the window (dxd)\n# initially I had a large window size for testing purposes \n# to identify regions of high interest\nwindow_size = 1 #image_height//64\n\n# get the initial scores\nscores = get_scores(input_image)\n\ndict_pixels ={'pixels':[]}\n\nbest_score_tw =  scores['timber wolf'] #the current/best score for timber wolf\nbest_score_gs = scores['Granny Smith'] #the current/best score for granny smith\n\nprint(best_score_tw, best_score_gs)\n\nmax_iter = 75\niter_1=-1\n\npixel_count = -1 # number of pixels that have been changed\nmax_pixel_count = 40 # number of pixels we want to change\n\ntemp_image = input_image\nrand_red_best, rand_green_best = (0, 0)\nrow_best, col_best = (0, 0)\n\nwhile pixel_count < max_pixel_count:\n  while iter_1 < max_iter:\n    # although I did change the values from time to time\n    row = np.random.randint(192,388) \n    col = np.random.randint(192,388)\n\n    iter_1 +=1\n\n    output_image = input_image.copy()\n\n    left = row\n    upper = col\n    right = min(x + window_size, image_width)\n    lower = min(y + window_size, image_height)\n\n    # the pixel values for RGB were kept close to the color of the apple \n    rand_red = np.random.randint(0,153)\n    rand_green = np.random.randint(170,255)\n    rand_blue = 0#np.random.randint(0,255)\n    output_image[upper:lower, left:right] = [rand_red, rand_green, rand_blue]\n    scores = get_scores(output_image)\n    # I actually also changed this a couple of times depending on where the output was\n\n    #if (scores['timber wolf'] - scores['Granny Smith']) < min_score  :\n    # initially I wanted pixels that bridged that gap between both classes the most.\n    # Once granny smith score crossed the timberwolf score I only cared about increasing\n    # score for granny smith class as long as timberwolf stayed below granny smith sclass\n    if (best_score_tw > scores['timber wolf']) and (best_score_gs < scores['Granny Smith'])\n\n        temp_image = output_image\n        best_score_tw = scores['timber wolf']\n        best_score_gs = scores['Granny Smith']\n        rand_red_best = rand_red\n        rand_green_best = rand_green\n        min_diff =  scores['timber wolf'] - scores['Granny Smith']\n        best_row, best_col = row, col\n\n        print(iter_1, [rand_red,rand_green,0], ':', row,col, \";\\n\",min_diff,'\\n')\n\n  pixel_count += 1\n  input_image = temp_image\n  scores = get_scores(input_image)\n\n  print(pixel_count,\n        '\\n', row, col, [rand_red_best, rand_green_best, 0],\n        '\\n', scores, '\\n')\n\n  dict_pixels['pixels'].append(([row_best,col_best],[rand_red_best,rand_green_best,0]))\n\nnp.save('/output_image.npy', input_image)\nnp.save('/pixel_data.npy', dict_pixels)\n\nscores = get_scores(input_image)\nbest_score_tw =  scores['timber wolf']\nbest_score_gs = scores['Granny Smith']\nprint(best_score_tw, best_score_gs)\n```"]