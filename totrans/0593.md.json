["```py\nfrom PIL import Image\n\nImage.effect_mandelbrot((512, 512), (-3, -2.5, 2, 2.5), 100).show()\n```", "```py\nnum1 = 2 + 1j\nnum2 = 12.3 + 23.1j\n\ntype(num1)\n```", "```py\ncomplex\n```", "```py\n2 + 3j == complex(2, 3)\n```", "```py\nTrue\n```", "```py\nnum1.real\n```", "```py\n2.0\n```", "```py\nnum2.imag\n```", "```py\n23.1\n```", "```py\nabs(1 + 3.14j)\n```", "```py\n3.295390720385065\n```", "```py\ndef sequence(c, n=7) -> list:\n    z_list = list()\n\n    z = 0\n    for _ in range(n):\n        z = z ** 2 + c\n        z_list.append(z)\n\n    return z_list\n```", "```py\nimport pandas as pd\n\ndf = pd.DataFrame()\ndf['element'] = [f\"z_{i}\" for i in range(7)]\n\n# Random numbers\ncs = [0, 1, -1, 2, 0.25, -.1]\n\nfor c in cs:\n    df[f\"c={c}\"] = sequence(c)\n\ndf\n```", "```py\ndef is_stable(c, n_iterations=20):\n    z = 0\n\n    for _ in range(n_iterations):\n        z = z ** 2 + c\n\n        if abs(z) > 2:\n            return False\n    return True\n```", "```py\nis_stable(1)\n```", "```py\nFalse\n```", "```py\nis_stable(0.2)\n```", "```py\nTrue\n```", "```py\nis_stable(0.26)\n```", "```py\nTrue\n```", "```py\nis_stable(0.26, n_iterations=30)\n```", "```py\nFalse\n```", "```py\nimport numpy as np\n\ndef candidate_values(xmin, xmax, ymin, ymax, pixel_density):\n    # Generate a 2D grid of real and imaginary values\n    real = np.linspace(xmin, xmax, num=int((xmax-xmin) * pixel_density))\n    imag = np.linspace(ymin, ymax, num=int((ymax-ymin) * pixel_density))\n\n    # Cross each row of `xx` with each column of `yy` to create a grid of values\n    xx, yy = np.meshgrid(real, imag)\n\n    # Combine the real and imaginary parts into complex numbers\n    matrix = xx + 1j * yy\n\n    return matrix\n```", "```py\nc = candidate_values(-2, 0, -1.2, 1.2, 1)\n\nc.shape\n```", "```py\n(2, 2)\n```", "```py\nc = candidate_values(-2, 0, -1.2, 1.2, 25)\n\nc.shape\n```", "```py\n(60, 50)\n```", "```py\nc = candidate_values(-2, 0.7, -1.2, 1.2, pixel_density=25)\n\nmandelbrot_mask = np.vectorize(is_stable)(c, n_iterations=20)\nmandelbrot_mask.shape\n```", "```py\n(60, 67)\n```", "```py\nimport matplotlib.pyplot as plt\n\nplt.imshow(mandelbrot_mask, cmap=\"binary\")\n\n# Turn off the axes and use tight layout\nplt.axis(\"off\")\nplt.tight_layout()\n```", "```py\nc = candidate_values(-2, 0.7, -1.2, 1.2, pixel_density=1024)\n\nmandelbrot_mask = np.vectorize(is_stable)(c, n_iterations=30)\n\nplt.imshow(mandelbrot_mask, cmap=\"binary\")\nplt.gca().set_aspect(\"equal\")\nplt.axis(\"off\")\nplt.tight_layout()\n```", "```py\nfrom dataclasses import dataclass\n\n@dataclass\nclass Mandelbrot: # Inspired by the Real Python article shared above\n    n_iterations: int\n\n    def is_stable(self, c: complex) -> bool:\n        z = 0\n\n        for _ in range(self.n_iterations):\n            z = z ** 2 + c\n            if abs(z) > 2:\n                return False\n\n        return True\n```", "```py\nmandelbrot = Mandelbrot(n_iterations=30)\n\nmandelbrot.is_stable(0.1)\n```", "```py\nTrue\n```", "```py\nmandelbrot.is_stable(1 + 4.4j)\n```", "```py\nFalse\n```", "```py\n@dataclass\nclass Mandelbrot:\n    max_iterations: int\n\n    def escape_count(self, c: complex) -> int:\n        z = 0\n        for iteration in range(self.max_iterations):\n            z = z ** 2 + c\n            if abs(z) > 2:\n                return iteration\n        return self.max_iterations\n```", "```py\nmandelbrot = Mandelbrot(max_iterations=50)\n\nmandelbrot.escape_count(-0.1) # stable\n```", "```py\n50\n```", "```py\nmandelbrot.escape_count(0.26) # unstable\n```", "```py\n29\n```", "```py\n@dataclass\nclass Mandelbrot:\n    max_iterations: int\n\n    def escape_count(self, c: complex) -> int:\n        z = 0\n        for i in range(self.max_iterations):\n            z = z ** 2 + c\n            if abs(z) > 2:\n                return i\n        return self.max_iterations\n\n    def stability(self, c: complex) -> float:\n        return self.escape_count(c) / self.max_iterations\n```", "```py\n@dataclass\nclass Mandelbrot:\n    max_iterations: int\n\n    def escape_count(self, c: complex) -> int:\n        z = 0\n        for i in range(self.max_iterations):\n            z = z ** 2 + c\n            if abs(z) > 2:\n                return i\n        return self.max_iterations\n\n    def stability(self, c: complex) -> float:\n        return self.escape_count(c) / self.max_iterations\n\n    def is_stable(self, c: complex) -> bool:\n        # Return True only when stability is 1\n        return self.stability(c) == 1\n```", "```py\nmandelbrot = Mandelbrot(max_iterations=50)\n\nmandelbrot.stability(-.1)\n```", "```py\n1.0\n```", "```py\nmandelbrot.is_stable(-.1)\n```", "```py\nTrue\n```", "```py\nmandelbrot.stability(2)\n```", "```py\n0.02\n```", "```py\nmandelbrot.is_stable(2)\n```", "```py\nFalse\n```", "```py\n@dataclass\nclass Mandelbrot:\n    max_iterations: int\n\n    # ... The rest of the code from above\n\n    @staticmethod\n    def candidate_values(xmin, xmax, ymin, ymax, pixel_density):\n        real = np.linspace(xmin, xmax, num=int((xmax-xmin) * pixel_density))\n        imag = np.linspace(ymin, ymax, num=int((ymax-ymin) * pixel_density))\n\n        xx, yy = np.meshgrid(real, imag)\n        matrix = xx + 1j * yy\n\n        return matrix\n\n    def plot(self, xmin, xmax, ymin, ymax, pixel_density=64, cmap=\"gray_r\"):\n        c = Mandelbrot.candidate_values(xmin, xmax, ymin, ymax, pixel_density)\n\n        # Apply `stability` over all elements of `c`\n        c = np.vectorize(self.stability)(c)\n\n        plt.imshow(c, cmap=cmap, extent=[0, 1, 0, 1])\n        plt.gca().set_aspect(\"equal\")\n        plt.axis('off')\n        plt.tight_layout()\n```", "```py\nmandelbrot = Mandelbrot(max_iterations=30)\n\nmandelbrot.plot(\n    xmin=-2, xmax=0.5, \n    ymin=-1.5, ymax=1.5, \n    pixel_density=1024,\n)\n```", "```py\nmandelbrot = Mandelbrot(max_iterations=30)\n\nmandelbrot.plot(\n    xmin=-2, xmax=0.5, \n    ymin=-1.5, ymax=1.5, \n    pixel_density=1024,\n    cmap=\"gist_heat\"\n)\n```"]