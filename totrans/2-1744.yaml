- en: 'Python Type Hinting: From Type Aliases To Type Variables and New Types'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 类型提示：从类型别名到类型变量和新类型
- en: 原文：[https://towardsdatascience.com/python-type-hinting-from-type-aliases-to-type-variables-and-new-types-a4a9e0400b6b](https://towardsdatascience.com/python-type-hinting-from-type-aliases-to-type-variables-and-new-types-a4a9e0400b6b)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/python-type-hinting-from-type-aliases-to-type-variables-and-new-types-a4a9e0400b6b](https://towardsdatascience.com/python-type-hinting-from-type-aliases-to-type-variables-and-new-types-a4a9e0400b6b)
- en: PYTHON PROGRAMMING
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PYTHON 编程
- en: See type aliases, type variables and new types in action
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看类型别名、类型变量和新类型的实际应用
- en: '[](https://medium.com/@nyggus?source=post_page-----a4a9e0400b6b--------------------------------)[![Marcin
    Kozak](../Images/d7faf62e48ed81dab5d8ad92819fff54.png)](https://medium.com/@nyggus?source=post_page-----a4a9e0400b6b--------------------------------)[](https://towardsdatascience.com/?source=post_page-----a4a9e0400b6b--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----a4a9e0400b6b--------------------------------)
    [Marcin Kozak](https://medium.com/@nyggus?source=post_page-----a4a9e0400b6b--------------------------------)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@nyggus?source=post_page-----a4a9e0400b6b--------------------------------)[![Marcin
    Kozak](../Images/d7faf62e48ed81dab5d8ad92819fff54.png)](https://medium.com/@nyggus?source=post_page-----a4a9e0400b6b--------------------------------)[](https://towardsdatascience.com/?source=post_page-----a4a9e0400b6b--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----a4a9e0400b6b--------------------------------)
    [Marcin Kozak](https://medium.com/@nyggus?source=post_page-----a4a9e0400b6b--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----a4a9e0400b6b--------------------------------)
    ·15 min read·Apr 26, 2023
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: ·发表于 [Towards Data Science](https://towardsdatascience.com/?source=post_page-----a4a9e0400b6b--------------------------------)
    ·15 分钟阅读·2023年4月26日
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/7194d200a270aae3a3eee222159f61df.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7194d200a270aae3a3eee222159f61df.png)'
- en: Python offers type hints. The choice is still yours. Photo by [William Felker](https://unsplash.com/@gndclouds?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了类型提示。选择权仍在你手中。图片来自 [William Felker](https://unsplash.com/@gndclouds?utm_source=medium&utm_medium=referral)
    [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: 'As I wrote in the article below, if you want to use type hints in Python, do
    it the right way:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在下面的文章中所写，如果你想在 Python 中使用类型提示，请以正确的方式进行：
- en: '[](https://betterprogramming.pub/pythons-type-hinting-friend-foe-or-just-a-headache-73c7849039c7?source=post_page-----a4a9e0400b6b--------------------------------)
    [## Python’s Type Hinting: Friend, Foe, or Just a Headache?'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://betterprogramming.pub/pythons-type-hinting-friend-foe-or-just-a-headache-73c7849039c7?source=post_page-----a4a9e0400b6b--------------------------------)
    [## Python 的类型提示：朋友、敌人还是只是个麻烦？'
- en: Type hinting’s popularity is increasing in the Python community. Where will
    this lead us? What can we do to use it…
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型提示在 Python 社区中的受欢迎程度正在增加。这会把我们带向何方？我们可以做些什么来使用它……
- en: betterprogramming.pub](https://betterprogramming.pub/pythons-type-hinting-friend-foe-or-just-a-headache-73c7849039c7?source=post_page-----a4a9e0400b6b--------------------------------)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: betterprogramming.pub](https://betterprogramming.pub/pythons-type-hinting-friend-foe-or-just-a-headache-73c7849039c7?source=post_page-----a4a9e0400b6b--------------------------------)
- en: 'What is *the right way*? Simply put, one that makes your code *readable* and
    *correct* from a point of view of static type checkers. So, two things: *readable*
    and *correct.*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 *正确的方式*？简单来说，就是使你的代码从静态类型检查器的角度看起来 *可读* 和 *正确* 的方式。所以，两件事：*可读* 和 *正确*。
- en: Among the things I mentioned in the article above was that creating [type aliases](https://mypy.readthedocs.io/en/stable/kinds_of_types.html#type-aliases)
    is a great way of increasing readability. We will start our discussion with them,
    focusing on when they can help indeed. Then, we move on to using type variables
    (`typing.TypeVar`) and new types (`typing.NewType`), which will help us achieve
    what we wouldn’t be able to achieve using regular type aliases.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的文章中我提到的事情之一是创建 [类型别名](https://mypy.readthedocs.io/en/stable/kinds_of_types.html#type-aliases)
    是提高可读性的好方法。我们将从它们开始讨论，重点讨论它们何时确实能提供帮助。然后，我们转向使用类型变量 (`typing.TypeVar`) 和新类型 (`typing.NewType`)，这些将帮助我们实现常规类型别名无法实现的目标。
- en: I will use Python 3.11 and `mypy` version 1.2.0.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 Python 3.11 和 `mypy` 版本 1.2.0。
- en: 'Put simply, the point of using type aliases is twofold:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，使用类型别名的目的有两个：
- en: to let the user know, in a relatively simple way, what type an argument should
    have (*should*, as we’re still talking about *type hints*), and
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以相对简单的方式让用户知道参数应该是什么类型（*应该*，因为我们仍在谈论 *类型提示*），以及
- en: to make static checkers happy.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让静态检查器满意。
- en: 'Making static checkers happy should make *us* happy, too: An unhappy type checker
    usually means errors, or at the very least some inconsistencies.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让静态检查器满意也应该让*我们*满意：一个不满意的类型检查器通常意味着错误，或至少是一些不一致性。
- en: For some users, point 2 is the only one worth mentioning — since static checking
    is the only reason they use type hints. It helps them avoid mistakes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些用户来说，第二点是唯一值得提及的——因为静态检查是他们使用类型提示的唯一原因。它帮助他们避免错误。
- en: Sure, that’s great — but that’s not all. Type hints can help us do more than
    that. And note that if our only aim is to satisfy static checkers, type aliases
    would have no use, as they don’t help static checkers at all. They help the user.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这很棒——但这不是全部。类型提示可以帮助我们做更多的事情。并且请注意，如果我们的唯一目标是满足静态检查器，类型别名将没有用，因为它们根本不帮助静态检查器。它们帮助的是用户。
- en: For me, both points are equally important. These days, when reading a function,
    I pay close attention to its annotations. When written well, they help me understand
    the function. When written poorly — not to mention incorrectly — they make the
    function less readable than had it been defined without any annotations whatsoever.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，这两个方面同样重要。如今，当我阅读一个函数时，我会特别注意其注释。注释写得好，它们能帮助我理解函数；注释写得不好——更不用说写得错误了——它们会使函数的可读性不如没有注释时那样好。
- en: Let’s start off with type aliases. I will show you their two main use cases.
    Then, we will see type aliases can help in rather simple situations, and sometimes
    we need something more. In our case, type variables and new types will come to
    rescue.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从类型别名开始。我会向你展示它们的两个主要用例。接着，我们将看到类型别名在相对简单的情况下如何提供帮助，有时我们需要更多的东西。在我们的案例中，类型变量和新类型将提供帮助。
- en: Type aliases for complex annotations
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复杂注释的类型别名
- en: 'Type aliases offer a simple yet powerful tool to make type hints clearer. I
    will reuse here a nice and convincing example from [Python documentation on type
    aliases](https://docs.python.org/3/library/typing.html#type-aliases):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 类型别名提供了一种简单而强大的工具，使类型提示更清晰。我将在这里重用[Python文档中的类型别名](https://docs.python.org/3/library/typing.html#type-aliases)中的一个很好的且有说服力的例子：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As the documentation says, the above type signature for `servers` is *exactly*
    equivalent to the one used below:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如文档所说，上述`servers`的类型签名*正好*等于下面使用的签名：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you see, the equivalency is not full: while the two signatures are indeed
    equivalent in terms of code, they do differ in readability. The point here lies
    in this type signature:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，等价性并不完全：虽然这两个签名在代码上确实是等效的，但它们在可读性上有所不同。关键在于这个类型签名：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Although it’s difficult to read and understand, after redefining to `Sequence[Server]`
    using several type aliases, it has become much clearer. What helps is the information
    conveyed by the type aliases used in the signature. Good naming can do wonders.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管阅读和理解起来比较困难，但通过使用几个类型别名将其重定义为`Sequence[Server]`后，已经变得更加清晰。类型别名在签名中传达的信息很有帮助。良好的命名可以产生奇迹。
- en: 'Note that we could make this type signature a little different, by adding one
    more type alias:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们可以通过添加一个更多的类型别名来使这个类型签名有所不同：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: but to me, `Sequence[Server]` is much better than `Servers`, as I immediately
    see I deal with an object that implements the `Sequence` protocol. It can be a
    list, for instance. Besides, we already have the argument’s name `servers`, so
    creating a type alias `Servers` seems redundant.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，`Sequence[Server]`比`Servers`要好得多，因为我立刻看到我处理的是一个实现了`Sequence`协议的对象。它可以是一个列表。例如，我们已经有了参数的名称`servers`，所以创建一个类型别名`Servers`似乎是多余的。
- en: 'Surely, understanding this very signature to its last detail using these type
    aliases is not simple:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，理解这个签名的每一个细节，使用这些类型别名并不简单：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'but thanks to the type aliases `ConnectionOptions`, `Address`, and `Server`
    and their clear meaning, it’s much simpler than understanding this signature:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 但由于类型别名`ConnectionOptions`、`Address`和`Server`及其明确的含义，这比理解以下签名要简单得多：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Simply put, with so complex types, raw type signatures will make static checkers
    happy — but they will unlikely make the users’ lives easier. Type aliases can
    help achieve that — they help communicate additional information about a variable,
    function, class or method to the user. They act as a communication tool.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，面对如此复杂的类型，原始的类型签名虽然让静态检查器满意——但不太可能让用户的生活变得更轻松。类型别名可以帮助实现这一点——它们有助于将关于变量、函数、类或方法的附加信息传达给用户。它们充当了一种沟通工具。
- en: 'Type aliases as a communication tool: Further considerations'
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型别名作为沟通工具：进一步的考虑
- en: Okay, let’s jump into another example. This time, we will try to utilize type
    aliases in order to improve our communication with the user in a simpler situation
    than before.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们跳到另一个例子。这次，我们将尝试利用类型别名来改善与用户的沟通，在一个比之前更简单的情况中。
- en: As we saw, the most important such communication tool is good naming. A good
    function, class or method name should clearly indicate its responsibility. When
    you see a name of `calculate_distance()`, you know that this function will, well,
    calculate distance; you would be surprised to see that such a function returns
    a tuple of two strings. When you see a `City` class, you know the class will somehow
    represent a city — not an animal, a car or a beaver.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，最重要的沟通工具是良好的命名。一个好的函数、类或方法名称应该明确表明其责任。当你看到 `calculate_distance()` 的名称时，你知道这个函数会计算距离；你会对看到一个返回两个字符串的元组的函数感到惊讶。当你看到
    `City` 类时，你知道这个类会以某种方式表示一个城市——而不是一个动物、一辆车或一只海狸。
- en: Annotations can help convey even more information than the function’s (class’s,
    method’s) and its arguments’ names. In other words, we want type hints not only
    to hint what types should be used, but also to help the user understand our functions
    and classes — and to help them provide correct values. As already mentioned, this
    can be done thanks to well-named type aliases.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注释可以传达比函数（类、方法）及其参数名称更多的信息。换句话说，我们希望类型提示不仅能提示应该使用哪些类型，还能帮助用户理解我们的函数和类——并帮助他们提供正确的值。正如之前提到的，这可以通过命名良好的类型别名来实现。
- en: 'Let’s start off with a simple example, this time using a variable type hint.
    Imagine we have something like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的例子开始，这次使用变量类型提示。假设我们有如下的东西：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Sure, we know the variable represents a length of something. But that’s all
    we know. First, of what? A better name could help:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们知道这个变量表示某物的长度。但这就是我们所知道的。首先，是什么长度？一个更好的名字可能会有所帮助：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Clear now. Imagine you’re a delivery guy and you’re to decide if the parcel
    will fit into your car. Well, will it?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在清楚了。想象一下你是一名送货员，你需要决定包裹是否能放进你的车里。那么，它能放进去吗？
- en: If one has made one’s decision based on the above knowledge, one is either an
    I-will-handle-any-parcel kind of guy or a better-not-to-risk one. In neither case
    was this an informed decision. We miss the units, don’t we?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人根据上述知识做出了决定，他要么是那种“我会处理任何包裹”的人，要么是“最好不要冒险”的人。在这两种情况下，这都不是一个经过深思熟虑的决定。我们缺少单位，不是吗？
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Better! But this is still just a comment, and it’s better if the code itself
    provided this information; it does not above, but it does here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 更好！但这仍然只是一个注释，如果代码本身提供这些信息会更好；上面没有提供，但这里提供了：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We have used a type alias again. But remember, this is just a type alias, and
    for Python, `length_of_parcel` is still just a `float`, nothing else. It means
    far more to us, though — that the parcel is 73.5 cm long.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用了类型别名。但请记住，这只是一个类型别名，对于 Python 来说，`length_of_parcel` 仍然只是一个 `float`，别无其他。然而，对我们来说，这意味着很多——这个包裹的长度是
    73.5 厘米。
- en: 'Let’s move on to a more complicated situation, that is, from variable annotation
    to function annotation. Imagine we want to implement a function that calculates
    the circumference of a rectangle. Let’s start with no annotation:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们进入一个更复杂的情况，即从变量注释到函数注释。假设我们想实现一个计算矩形周长的函数。我们从没有注释开始： '
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Simple. Pythonic¹. Correct.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 简单。符合 Python 习惯¹。正确。
- en: 'We’re already familiar with the problem: without annotations, the user does
    not know what sort of data the function expects. Centimeters? Inches? Meters?
    Kilometers? In fact, the function will work with strings:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉了这个问题：没有注释，用户不知道函数期望什么样的数据。厘米？英寸？米？公里？实际上，函数将处理字符串：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Khm. Surely, this works — but makes no sense. Do we want the user to be able
    to use our function for stuff like that? Do we want the user to say:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯。确实，这有效——但没有意义。我们希望用户能够用我们的函数处理这样的东西吗？我们希望用户说：
- en: Hey, their function told me that when I create a rectangle with the side lengths
    of `"a"` and `"X"`, this rectangle has the circumference of `"aaXX"`, haha!
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 嘿，他们的函数告诉我，当我用边长为 `"a"` 和 `"X"` 的矩形时，这个矩形的周长是 `"aaXX"`，哈哈！
- en: 'Nah, better not. Sure, the function’s name does say what the function does,
    but it would help to let the user know what sort of data the function expects.
    Then we could respond:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 不，还是不行。确实，函数的名称说明了函数的作用，但如果能让用户知道函数期望什么样的数据会更有帮助。然后我们可以回应：
- en: Hey, can’t you read? Don’t you see the function expects floating-point numbers?
    Or maybe you think a string is a floating-point number, haha?
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 嘿，你不能读吗？难道你看不出这个函数期望浮点数吗？或者你认为字符串是浮点数，哈哈？
- en: I think it’s always better to avoid such haha-discussions. So, it’s a big yes
    to type hints. Let’s go on.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为最好避免这种哈哈式讨论。所以，类型提示是一个大好的选择。我们继续吧。
- en: 'Okay, so we have a rectangle, it has four sides, and `x` and `y` are their
    lengths. It doesn’t matter which unit the users provides, as the function works
    for *any* length unit; it can be centimeters, inches, kilometers, anything that
    is a length unit. What does matter, however — and in fact, what makes much of
    a difference — is that both `x` and `y` be provided in *the same* units. Otherwise,
    the function will not work correctly. This is fine:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们有一个矩形，它有四条边，`x`和`y`是它们的长度。用户提供什么单位并不重要，因为函数适用于*任何*长度单位；它可以是厘米、英寸、公里，任何长度单位。真正重要的是——实际上，区别很大——是`x`和`y`都必须使用*相同*单位。否则，函数将无法正确工作。这是可以的：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'But this is not:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 但这不是：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The problem is that even though this call makes no sense and we know it, it
    *is correct* from a Python perspective — both
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，即使这个调用毫无意义，我们也知道这一点，但从Python的角度来看，它*是正确的*——两者都一样。
- en: 'dynamically: we will get `24`; and'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态地：我们会得到`24`；以及
- en: 'statically: `x` and `y` are both floating-point numbers.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态地：`x`和`y`都是浮点数。
- en: The problem is, we did not let the user — and Python, for that matter — know
    that the two arguments, `x` and `y`, should be in *the same units*, just that
    they should use floating-point numbers. For Python, a float is a float, and it
    does not distinguish kilometers from inches, not to mention kilograms.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，我们没有让用户——以及Python——知道两个参数`x`和`y`应该是*相同单位*的，只是他们应该使用浮点数。对于Python而言，浮点数就是浮点数，它不区分公里和英寸，更不用说千克了。
- en: 'Let’s check out if we can use type hinting to do something with this. In other
    words: Can we use type hints to let the user know that they should use the same
    type for both arguments, and that the return value would be of this type, too?'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下是否可以使用类型提示来做些事情。换句话说：我们能否使用类型提示让用户知道他们应该为两个参数使用相同的类型，并且返回值也是这种类型呢？
- en: 'The simplest annotation would be one using floating-point numbers:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的注解是使用浮点数：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This function signature is a little better than that without annotations, as
    at least the user is informed they should use `float`s. But again, inches? Centimeters?
    Meters? And actually, why not kilograms?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数签名比没有注解的稍好，因为至少用户知道他们应该使用`float`。但还是，英寸？厘米？米？实际上，为什么不使用千克？
- en: 'So, let’s try a type alias:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们尝试一个类型别名：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Clear, isn’t it? `mypy` will clap:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 清楚了吧？`mypy`会鼓掌：
- en: '![](../Images/caaa035c5928dcf8bd14424204d2e14d.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/caaa035c5928dcf8bd14424204d2e14d.png)'
- en: So will `Pylance`. The user knows that they should provide centimeters, and
    that the function will return the circumference in centimeters. `Cm` is a type
    alias, which basically means it’s still `float`, and there is no difference between
    `Cm` and `float`. But the point is, *the user knows*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pylance`也是如此。用户知道他们应该提供厘米，并且函数会以厘米为单位返回周长。`Cm`是一个类型别名，这基本上意味着它仍然是`float`，`Cm`和`float`之间没有区别。但关键是，*用户知道*。'
- en: 'Static checkers, however, will not be too helpful in this case. You can provide
    an additional type alias of `float`, and it will be treated just the same as `Cm`
    and as any `float`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，静态检查器在这种情况下不会太有帮助。你可以提供一个`float`的额外类型别名，它将与`Cm`以及任何`float`一样被对待：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The type checker is fully okay with this, as both `Cm` and `M` are just aliases
    of the same type, that is, `float`. Basically, for static checkers `Cm` is equivalent
    not only to `float`, but also to `M`. Thus, if you want to use type aliases in
    such instances, you have to remember that they are merely… aliases — and nothing
    more!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 类型检查器对此完全没问题，因为`Cm`和`M`只是相同类型的别名，即`float`。基本上，对于静态检查器而言，`Cm`不仅等同于`float`，也等同于`M`。因此，如果你想在这种情况下使用类型别名，你必须记住它们只是……别名——仅此而已！
- en: I am sure you’ve noticed another big disadvantage of the above signature that
    used the `Cm` type alias. Why should the user provide `x` and `y` in centimeters
    when they have them in inches, or any other unit? Convert? And then what, convert
    back? That would be *i-n-s-a-n-e*!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你已经注意到使用`Cm`类型别名的上面签名的另一个大缺点。为什么用户要用厘米提供`x`和`y`，而他们的单位是英寸或其他单位？转换？然后怎么办，转换回来？那*简直疯狂*！
- en: Well… Maybe we could create a distance-related (or length-related) `float` alias?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯……也许我们可以创建一个与距离（或长度）相关的`float`别名？
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`mypy` will clap again, as the only thing we’ve changed is the name. But this
    did not change anything else: The user still can make the very same error of providing
    values in different units, both of which will be `DistanceUnit`s, like centimeters
    and inches. At least the user knows they should not provide kilograms.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`mypy`将再次发出警告，因为我们唯一更改的是名称。但这并没有改变其他任何东西：用户仍然可以犯提供不同单位值的相同错误，这些值都将是`DistanceUnit`，如厘米和英寸。至少用户知道他们不应该提供千克。'
- en: As you see, type aliases will not help us solve this problem. On the one hand,
    I think we can assume that anyone using Python should know that when calculating
    the circumference of a rectangle, one should provide the lengths of the sides
    in the same units. This is not Python knowledge. This is simple maths.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，类型别名无法帮助我们解决这个问题。一方面，我认为我们可以假设使用Python的人应该知道在计算矩形周长时，应该以相同的单位提供边的长度。这不是Python知识。这是简单的数学。
- en: 'However, in some other scenarios you might want to make things clear, as not
    always are things as clear as with calculating a rectangle’s circumference. We
    know type aliases will not help, so let’s move on to two other `typing`’s tools:
    type variables (`TypeVar`) and new types (`NewType`). Will they help?'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在一些其他场景中，你可能想要让事情变得清晰，因为并非所有事情都像计算矩形周长那样清晰。我们知道类型别名没有帮助，所以让我们转向`typing`的其他两个工具：类型变量（`TypeVar`）和新类型（`NewType`）。它们会有帮助吗？
- en: Type variables and new types
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型变量和新类型
- en: If you really want to implement so detailed type hinting, you can. Beware, however,
    that this will make the code more complex. To this end, `typing.NewType` and `typing.TypeVar`
    can help.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的想实现如此详细的类型提示，你可以这么做。然而，请注意，这会使代码变得更复杂。为此，`typing.NewType`和`typing.TypeVar`可以提供帮助。
- en: 'Let’s start with `NewType`. This is a `typing` tool to create new types with
    a minimal runtime overhead (see Appendix 1). Types created that way offer minimal
    functionality, so you should prefer them when you don’t need anything more than
    just clear type hints and a possibility to convert a value to and from this type.
    Its advantage is that it works with static checkers (as we will see in a moment).
    Its disadvantage — in my opinion, quite a big one — is that a type created using
    `typing.NewType` is not treated as a type by `isinstance` (at least in Python
    3.11.2 — I hope this will change in future versions):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`NewType`开始。这是一个`typing`工具，用于创建具有最小运行时开销的新类型（参见附录1）。以这种方式创建的类型提供的功能很有限，因此当你只需要明确的类型提示和将值转换到这种类型的可能性时，你应该优先使用它们。它的优点是它与静态检查工具兼容（正如我们稍后将看到的）。它的缺点——在我看来，这是一个相当大的缺点——是使用`typing.NewType`创建的类型不被`isinstance`视为类型（至少在Python
    3.11.2中如此——我希望将来版本会有所改变）：
- en: '![](../Images/573e1532ff99a3a8921a0981a95e8067.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/573e1532ff99a3a8921a0981a95e8067.png)'
- en: 'Screenshot from Python 3.11.2: typing.NewType types are not considered types
    by isinstance(). Image by author.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.11.2的截图：`typing.NewType`类型不被`isinstance()`视为类型。图片由作者提供。
- en: For me, this is a serious issue. But as you will see, `typing.NewType` types
    can still be very useful, with small overhead (as shown in Appendix 1).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，这是一个严重的问题。但正如你将看到的，`typing.NewType`类型仍然非常有用，开销较小（如附录1所示）。
- en: So, we want to create types representing our distance-related units. The problem
    is, we will have to create as many types as many units we want to take into account.
    For simplicity, let’s limit them to a couple of most important length units based
    on [International System of Units (SI units)](https://en.wikipedia.org/wiki/International_System_of_Units).
    This is how you would proceed when working on your project in which the number
    of types is limited. When working on a framework to be used by others, however,
    you should create more types.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们想要创建代表我们距离相关单位的类型。问题是，我们需要创建的类型数量与我们要考虑的单位数量相同。为了简化，让我们将它们限制为几个基于[国际单位制（SI单位）](https://en.wikipedia.org/wiki/International_System_of_Units)的最重要的长度单位。这是你在处理项目时的做法，其中类型数量有限。然而，当你在开发一个供他人使用的框架时，你应该创建更多的类型。
- en: 'Four types will do in our case:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，四种类型就足够了：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`NewType` creates subtypes — so, `Mm`, `Cm`, `M` and `Km` are all subtypes
    of float. They can be used anywhere where `float` can be used, but a static checker
    will not accept a regular `float` value where any of these four subtypes are to
    be used. You will need to convert such a `float` value to the type of choice;
    for example, you could do `distance = Km(30.24)`, meaning that the distance in
    question is equal to `30` km and `240` m.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewType` 创建子类型——因此，`Mm`、`Cm`、`M` 和 `Km` 都是 float 的子类型。它们可以在任何 `float` 可以使用的地方使用，但静态检查器将不接受任何这些四种子类型应使用的普通
    `float` 值。你需要将这样的 `float` 值转换为所需的类型；例如，你可以执行 `distance = Km(30.24)`，意味着距离为 `30`
    公里和 `240` 米。'
- en: 'Let’s see the types used to annotate this simple function:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看用于注解这个简单函数的类型：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`Pylance` screams:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pylance` 听到：'
- en: '![](../Images/89d5185db608ee6ffcebf2f716fd73ae.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/89d5185db608ee6ffcebf2f716fd73ae.png)'
- en: Screenshot from Pylance from VSCode. Image by author
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 VSCode 的 Pylance 截图。图片由作者提供
- en: 'This is because `x / 1_000_000` gives a float while we indicated that the function
    returns a value of the `Mm` type. To achieve this, we need to convert the returned
    value to the expected type:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `x / 1_000_000` 给出一个浮点数，而我们指明函数返回 `Mm` 类型的值。为实现这一点，我们需要将返回值转换为预期的类型：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you see, types created using `typing.NewType` can be used as callables (before
    Python 3.10 they were functions; now they are classes) in order to convert a value
    to their type. This is very convenient in situations like this one.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用 `typing.NewType` 创建的类型可以作为可调用对象（在 Python 3.10 之前它们是函数；现在它们是类）用于将值转换为它们的类型。这在这种情况下非常方便。
- en: But how will this help us with our `get_rectangle_circumference()` function?
    We still have four different subtypes of `float` and we want to make the function
    return the very type that its `x` and `y` arguments have.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 但这将如何帮助我们处理 `get_rectangle_circumference()` 函数？我们仍然有四种不同的 `float` 子类型，我们希望函数返回其
    `x` 和 `y` 参数的确切类型。
- en: 'It’s time to introduce a new `typing` tool, type variables, or `typing.TypeVar`.
    As it occurs, a type variable can help us achieve what we need:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是引入新 `typing` 工具——类型变量，或 `typing.TypeVar` 的时候了。事实证明，类型变量可以帮助我们实现所需的功能：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Unlike before, when we used type aliases, this time you cannot mix up different
    types. Let’s see how a static type checker, `Pylance`, treats three different
    calls of this function:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前使用类型别名时不同，这次你不能混合不同的类型。让我们看看静态类型检查器 `Pylance` 如何处理此函数的三种不同调用：
- en: '*Floats will not work:*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*浮点数无效：*'
- en: '![](../Images/2a403237066cb4f86b45ff1770b3eb7e.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2a403237066cb4f86b45ff1770b3eb7e.png)'
- en: (1) Floats don’t work. Image by author
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: (1) 浮点数无效。图片由作者提供
- en: '*You can’t mix up different types:*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*你不能混合不同的类型：*'
- en: '![](../Images/787e98ba19a1f03db104b625d668aae0.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/787e98ba19a1f03db104b625d668aae0.png)'
- en: (2) Two different types don’t work. Image by author
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: (2) 两种不同的类型无效。图片由作者提供
- en: '*The only way for the function to pass a static check is to use the same type
    for both lengths:*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数通过静态检查的唯一方法是对两个长度使用相同类型：*'
- en: '![](../Images/d747748400c93f00038b053464f1bcc9.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d747748400c93f00038b053464f1bcc9.png)'
- en: (3) Only the same type for both arguments work. Image by author
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: (3) 仅相同类型的两个参数有效。图片由作者提供
- en: 'Of course, the type of the return value will match the type of the two arguments
    — so, for instance, when you provide meters, you will get meters. This is why
    we needed the `t = type(x)` line. We could make the function a little shorter:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，返回值的类型将与两个参数的类型匹配——例如，当你提供米时，你会得到米。这就是为什么我们需要 `t = type(x)` 行的原因。我们可以使函数稍微简短一些：
- en: '![](../Images/26ff8eb2b0ef6c685618d1160274405e.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/26ff8eb2b0ef6c685618d1160274405e.png)'
- en: A shorter version of the function. Image by author
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 更短版本的函数。图片由作者提供
- en: For intermediate and advanced Pythonistas, both versions will likely be equally
    readable; for a beginner, however, the former may be easier to understand.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于中级和高级 Python 使用者，两种版本的可读性可能相当；然而，对于初学者来说，前者可能更容易理解。
- en: 'Note that a `DistanceUnit` type alias would *not* work the same way:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`DistanceUnit` 类型别名*不会*以相同方式工作：
- en: '![](../Images/44b7b3f233b954db4567d6150f638644.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/44b7b3f233b954db4567d6150f638644.png)'
- en: Type alias for DistanceUnit does not work as required. Image by author
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: DistanceUnit 的类型别名无法按要求工作。图片由作者提供
- en: Here, you can mix up different types in a call to `get_rectangle_circumference()`,
    something we wanted to avoid; something a type variable helped us achieve.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以在调用 `get_rectangle_circumference()` 时混合不同类型，这正是我们想要避免的；而类型变量帮助我们实现了这一点。
- en: And so, here we are, we got what we wanted. Although the task did not seem overly
    complex, type aliases were not enough to achieve our aim. Nevertheless, `typing`’s
    type variables (`TypeVar`) and new types (`NewType`) came to rescue.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们达到了我们想要的目标。尽管任务看起来不算复杂，但类型别名并不足以实现我们的目的。然而，`typing` 的类型变量（`TypeVar`）和新类型（`NewType`）提供了帮助。
- en: Conclusion
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: 'Type hints are not required in Python; they are optional. Sometimes it’s better
    to omit them altogether. When you’re forced to use them, however, you should use
    them wisely: let them be a help to you and your code users, not a hindrance.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示在 Python 中不是必需的；它们是可选的。有时最好完全省略它们。然而，当你不得不使用它们时，应该明智地使用它们：让它们对你和你的代码用户有所帮助，而不是成为障碍。
- en: I hope you’re now ready to use `typing`’s type aliases, type variables and new
    types in your own projects, at least in similar, rather simple, scenarios. When
    doing so, do remember *not to overuse* these tools. To be honest, I seldom decide
    to use type variables and new types. So, before deciding you’re opening these
    doors, think twice. Your code will definitely be much more complicated, so you
    must have a good reason behind doing this.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你现在已经准备好在自己的项目中使用 `typing` 的类型别名、类型变量和新类型，至少在类似的、相对简单的场景中使用。在这样做时，请记住*不要过度使用*这些工具。老实说，我很少决定使用类型变量和新类型。因此，在决定打开这些门之前，请三思。你的代码肯定会变得复杂得多，所以你必须有充分的理由去做这个决定。
- en: We’ve covered the basic ideas of using type aliases, type variables and new
    types in the Python type-hinting system. There’s much more to the topic, as Python’s
    static checking system is still developing, but this *more* comes at a cost of
    much greater complexity. Let’s leave it as is for today, and we’ll return to the
    topic some other day, when we’ll be ready to focus on more advanced aspects of
    Python type hinting.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了在 Python 类型提示系统中使用类型别名、类型变量和新类型的基本概念。这个话题还有很多内容，因为 Python 的静态检查系统仍在发展，但这种*更多*会带来更大的复杂性。今天就先说到这里，我们以后会在准备好专注于
    Python 类型提示的更高级方面时再回到这个话题。
- en: Footnotes
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚注
- en: ¹ If someone wants to scream at me that this is *not* Pythonic because the function
    is not annotated, let me remind this person that type hints are *optional* in
    Python. If something is optional, it cannot be a decisive factor behind a claim
    that code is or is not Pythonic.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ 如果有人想对我大喊这不是*Pythonic*，因为函数没有注解，那么请让我提醒这个人，类型提示在 Python 中是*可选的*。如果某样东西是可选的，它不能作为声明代码是否
    Pythonic 的决定性因素。
- en: Appendix 1
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 1
- en: 'Time overhead of `typing.NewType` is visibly smaller when compared to, for
    example, a float-based custom class. The simple snippet below uses `perftester`
    to benchmark the two aspects:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 与例如基于浮点数的自定义类相比，`typing.NewType` 的时间开销明显更小。下面的简单代码片段使用 `perftester` 来基准测试这两个方面：
- en: Is creating a new type faster using `typing.NewType` or a custom class?
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `typing.NewType` 或自定义类创建新类型哪个更快？
- en: Which of the two kinds of types is quicker to use (specifically, to convert
    a float value to this type)?
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪种类型的使用更快（具体来说，将浮点值转换为该类型）？
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here are the results I got on my machine:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我在我的机器上得到的结果：
- en: '![](../Images/ba00d3201791a4548a40489ee91a88a5.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ba00d3201791a4548a40489ee91a88a5.png)'
- en: 'Benchmark results: the typing-based approach is faster. Image by author.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试结果：基于 typing 的方法更快。图片作者提供。
- en: Clearly, `typing.NewType` creates a new type significantly — an order of magnitude
    — faster than a custom class does. They are, however, more or less similarly fast
    in creating a new class instance.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`typing.NewType` 创建新类型的速度显著比自定义类快一个数量级。然而，它们在创建新类实例方面的速度差异不大。
- en: 'The above benchmark code is simple and shows that `perftester` offers a very
    simple API. If you want to learn more about it, read the article below:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的基准测试代码很简单，表明 `perftester` 提供了一个非常简单的 API。如果你想了解更多，阅读下面的文章：
- en: '[](/benchmarking-python-functions-the-easy-way-perftester-77f75596bc81?source=post_page-----a4a9e0400b6b--------------------------------)
    [## Benchmarking Python Functions the Easy Way: perftester'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[基准测试 Python 函数的简单方法：perftester](https://towardsdatascience.com/benchmarking-python-functions-the-easy-way-perftester-77f75596bc81?source=post_page-----a4a9e0400b6b--------------------------------)
    [## 基准测试 Python 函数的简单方法：perftester'
- en: You can use perftester to benchmark Python functions the easy way
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你可以使用 perftester 以简单的方式基准测试 Python 函数
- en: towardsdatascience.com](/benchmarking-python-functions-the-easy-way-perftester-77f75596bc81?source=post_page-----a4a9e0400b6b--------------------------------)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[前往数据科学](https://towardsdatascience.com/benchmarking-python-functions-the-easy-way-perftester-77f75596bc81?source=post_page-----a4a9e0400b6b--------------------------------)'
- en: 'You can of course use the `timeit` module for such benchmarks:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然可以使用 `timeit` 模块进行这种基准测试：
- en: '[](/benchmarking-python-code-with-timeit-80827e131e48?source=post_page-----a4a9e0400b6b--------------------------------)
    [## Benchmarking Python code with timeit'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[](/benchmarking-python-code-with-timeit-80827e131e48?source=post_page-----a4a9e0400b6b--------------------------------)
    [## 使用 timeit 进行 Python 代码基准测试'
- en: The most popular tool for time benchmarking of Python code, the built-in timeit
    module offers more than most…
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最受欢迎的 Python 代码时间基准测试工具，内置的 timeit 模块提供了超出大多数工具的功能…
- en: towardsdatascience.com](/benchmarking-python-code-with-timeit-80827e131e48?source=post_page-----a4a9e0400b6b--------------------------------)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: towardsdatascience.com](/benchmarking-python-code-with-timeit-80827e131e48?source=post_page-----a4a9e0400b6b--------------------------------)
- en: 'Thanks for reading. If you enjoyed this article, you may also enjoy other articles
    I wrote; you will see them [here](https://medium.com/@nyggus). And if you want
    to join Medium, please use my referral link below:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢阅读。如果你喜欢这篇文章，你可能也会喜欢我写的其他文章；你可以在[这里](https://medium.com/@nyggus)看到。如果你想加入
    Medium，请使用我下面的推荐链接：
- en: '[](https://medium.com/@nyggus/membership?source=post_page-----a4a9e0400b6b--------------------------------)
    [## Join Medium with my referral link - Marcin Kozak'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@nyggus/membership?source=post_page-----a4a9e0400b6b--------------------------------)
    [## 使用我的推荐链接加入 Medium - Marcin Kozak'
- en: Read every story from Marcin Kozak (and thousands of other writers on Medium).
    Your membership fee directly supports…
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阅读 Marcin Kozak 的每一个故事（以及 Medium 上成千上万其他作家的故事）。你的会员费直接支持…
- en: medium.com](https://medium.com/@nyggus/membership?source=post_page-----a4a9e0400b6b--------------------------------)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: medium.com](https://medium.com/@nyggus/membership?source=post_page-----a4a9e0400b6b--------------------------------)
