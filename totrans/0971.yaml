- en: 'Geospatial Indexing and Scoring: Unlocking the Power of Location-Based Data
    Analysis'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/geospatial-indexing-and-scoring-unlocking-the-power-of-location-based-data-analysis-b77a7599b4c](https://towardsdatascience.com/geospatial-indexing-and-scoring-unlocking-the-power-of-location-based-data-analysis-b77a7599b4c)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A hands-on guide on geospatial indexing using Python & H3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://ransakaravihara.medium.com/?source=post_page-----b77a7599b4c--------------------------------)[![Ransaka
    Ravihara](../Images/ac09746938c10ad8f157d46ea0de27ca.png)](https://ransakaravihara.medium.com/?source=post_page-----b77a7599b4c--------------------------------)[](https://towardsdatascience.com/?source=post_page-----b77a7599b4c--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----b77a7599b4c--------------------------------)
    [Ransaka Ravihara](https://ransakaravihara.medium.com/?source=post_page-----b77a7599b4c--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----b77a7599b4c--------------------------------)
    ·7 min read·Jan 25, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6b75f0648ad78b2c59482c7d2ccc6497.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Antoine Merour](https://unsplash.com/@amerour?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: In this article, we will discuss geospatial indexing and scoring and how it
    can be made easy for developers. Geospatial indexing is the process of creating
    an index on a set of data that has a geographic location associated with it, such
    as latitude and longitude. Scoring, on the other hand, is the process of ranking
    or ordering the data based on specific criteria. Together, geospatial indexing
    and scoring can create powerful and efficient applications that can quickly retrieve
    and display geographic data.
  prefs: []
  type: TYPE_NORMAL
- en: Geospatial indexing and scoring can be complex and time-consuming, but with
    the right tools and techniques, it can be made simple. This article will explore
    how we can use Uber's H3 library for indexing and scoring tasks.
  prefs: []
  type: TYPE_NORMAL
- en: For a better understanding, let's define the hypothetical problem statement.
  prefs: []
  type: TYPE_NORMAL
- en: As a Data Scientist at a retail company, you have been tasked with a critical
    project. The company needs to organize and understand the different regions it
    operates.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The end goal of this project is to split regions into different pieces and identify
    critical hotspots across each region. This information will be helpful for the
    company to understand which areas are most important for their business and where
    they should focus their efforts.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: But your job doesn't end there. The company also needs you to assign an "importance
    score" to each of its outlets. This score will be based on the previously mentioned
    hotspot mechanism. The outlets that are located near potential hotspots have a
    higher importance score.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Alright, let's start building this solution.
  prefs: []
  type: TYPE_NORMAL
- en: Steps to follow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: – [Know your data (Understand the data)](#9242)
  prefs: []
  type: TYPE_NORMAL
- en: – [Splitting region into small hexagons](#a839)
  prefs: []
  type: TYPE_NORMAL
- en: – [Derive a score for each hexagon in the region](#add6)
  prefs: []
  type: TYPE_NORMAL
- en: – [Define outlet importance score](#2edc)
  prefs: []
  type: TYPE_NORMAL
- en: 1️⃣ Know your data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Based on the problem statement, we have two datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Points of interest dataset — To derive importance scores
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Outlet location dataset
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Note: The data provided is randomly generated and does not reflect real-world
    scenarios. You can access this data from* [*here*](https://github.com/Ransaka/Spatial-indexing-with-h3/tree/master/data)*.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/af295a3610a20c4565e786ece872ea4e.png)![](../Images/6d06804d9764462f2e02871a8682dc72.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's plot the POI category distribution.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d65f8600e9bf1e3d7d62b9ba887e7cfd.png)'
  prefs: []
  type: TYPE_IMG
- en: Additionally, we will require regions' geographical information. I already created
    the regions' JSON file via the *geojson.io* website.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let's put it all together.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/61431557b42db7e6369dbee391342ec1.png)'
  prefs: []
  type: TYPE_IMG
- en: What we have so far | Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: In the above diagram, you can see two layers.
  prefs: []
  type: TYPE_NORMAL
- en: Rectangular geojson layer — Represents the region we are analyzing
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Points of interest layer — Provides points of interest dataset for the region
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2️⃣ Splitting region into small hexagons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To pinpoint hotspots across a specific area, it's necessary to divide the region
    into smaller sections. One way to do this is by using hexagons. Hexagons are particularly
    useful in this context because of the advantages they offer, such as their ability
    to evenly divide an area and the ability to accurately represent geographical
    shapes. If you have any further questions about why hexagons are used or the benefits
    they offer, you can refer to the official documentation of H3 for more information.
  prefs: []
  type: TYPE_NORMAL
- en: In simpler terms, by choosing the correct resolution, multiple locations can
    be represented by a single hexagon cell.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0e5f63ee0b807359544640b2e06a78bf.png)'
  prefs: []
  type: TYPE_IMG
- en: Map multiple points to one hexagon | Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: '[## H3 | H3'
  prefs: []
  type: TYPE_NORMAL
- en: Hexagonal hierarchical geospatial indexing system H3 offers an easy API for
    indexing coordinates into a hexagonal grid…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: h3geo.org.](https://h3geo.org/?source=post_page-----b77a7599b4c--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: We can use H3's `*polyfill*`function to split a given region into hexagons.
    But before that, we have to convert the region geojson file into a shapely polygon
    format.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the above snippet, the `polygon_to_h3` function will convert the input polygon
    into a list of hexagons. Also, you have to provide the resolution parameter. The
    resolution parameter defines the size of the hexagon. Based on the provided resolution
    parameter, we can split the given region into hexagons, like below.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c5a2536918b77cd158aacb2a23c440f4.png)'
  prefs: []
  type: TYPE_IMG
- en: Converting geojson tile into a list of hexagons | Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: In this instance, a resolution of 8 was utilized. According to the documentation,
    hexagons with a solution of 8 have an area of 0.737327598 square kilometers. In
    this specific case, the region was divided into 912 hexagons.
  prefs: []
  type: TYPE_NORMAL
- en: 3️⃣ Derive a score for each hexagon in the region
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we have split regions into hexagons, we can now work on deriving the scores
    for each hexagon.
  prefs: []
  type: TYPE_NORMAL
- en: 'The methodology for this process includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Assigning a unique hexagon ID to each point of interest in the dataset.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Establishing the scoring criteria, with weighting given to each category.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Joining the scored dataset with the region dataset.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/db4a45b58bf38644b788325d9baf9f83.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's overlay the scoring layer on top of the base region hexagons. The figure
    on the right illustrates how scores are assigned to each hexagon. The height of
    the bar reflects the importance score.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/bd8668bb067fbc57340156a879f766b2.png)![](../Images/14344f12fb07b9860a6fbb7f629062e2.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: Let's check how derived scores are distributed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/87dd1c77a6aed36b8b098d0febfd0583.png)'
  prefs: []
  type: TYPE_IMG
- en: Score distribution | Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: With all of the hexagons in the region now scored, it is time to create a new
    data layer for visualization.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ca2ef40844387c6b697cbff5a8eb0799.png)![](../Images/35bfe710f91dc9b52b438a79453634b2.png)'
  prefs: []
  type: TYPE_IMG
- en: Region's hotspots | Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: Please note the color code above, greyish-blue colored hexagons represent low-importance
    hexagons, while pink and cream-colored hexagons represent relatively important
    hexagons within the region.
  prefs: []
  type: TYPE_NORMAL
- en: 4️⃣ Define outlet importance score
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now have a dataset containing scores for all the hexagons in the selected
    region. This allows us to identify the area's most critical (hotspot) hexagons.
    This solves half of the problem. Next, we need to define the importance scores
    for the outlets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps that will be followed include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Assigning unique hexagon IDs to the outlet dataset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each outlet, identify the closest *K* hexagons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defining the importance of the outlet based on scores of the *K* hexagons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/35edafbe67d7d0efa9d98131ec4ad016.png)'
  prefs: []
  type: TYPE_IMG
- en: In the code snippet above, the `k_ring` function is used to retrieve the nearest
    K hexagons for each outlet. You will also notice that in this case, K has been
    set to 3.
  prefs: []
  type: TYPE_NORMAL
- en: Let's visualize the data to understand better what we have accomplished in this
    step.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e9fb9d242b1839679569ae7cf3803d04.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: Now we are almost done. Because we have defined the scores for each hexagon
    cell in this region, all we need to do is aggregate the nearby hexagon scores
    for each outlet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/6fe3c37ba18b537b6e87cb8e3ec242ca.png)'
  prefs: []
  type: TYPE_IMG
- en: Final Scoring | Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: Great, we have now successfully established the importance score for each outlet.
    With that, both objectives have been accomplished. Well done! :)
  prefs: []
  type: TYPE_NORMAL
- en: You can access all codes below the GitHub repo.
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://github.com/Ransaka/Spatial-indexing-with-h3.git?source=post_page-----b77a7599b4c--------------------------------)
    [## GitHub - Ransaka/Spatial-indexing-with-h3'
  prefs: []
  type: TYPE_NORMAL
- en: You can't perform that action at this time. You signed in with another tab or
    window. You signed out in another tab or…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: github.com](https://github.com/Ransaka/Spatial-indexing-with-h3.git?source=post_page-----b77a7599b4c--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This simplified example highlights some of the valuable capabilities of the
    H3 library. From measuring the distance between two geographic locations to performing
    nearest neighbor analysis, the H3 library offers a wide range of options. By incorporating
    spatial indexing at the appropriate time, not only can resources be saved, but
    costs can also be reduced. The reason is that performing mathematical operations
    on point data can consume a significant amount of memory, but memory usage can
    be greatly minimized with indexing.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks for reading! Connect with me on [LinkedIn](https://www.linkedin.com/in/ransaka/).
  prefs: []
  type: TYPE_NORMAL
