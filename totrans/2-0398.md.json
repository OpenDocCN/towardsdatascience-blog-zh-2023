["```py\nmkdir prime_fact\ncd prime_fact\n```", "```py\npython -m venv .venv\nsource .venv/bin/activate\npip install maturin\n```", "```py\nmaturin init --bindings pyo3\n```", "```py\n// Include Python-related symbols\nuse pyo3::prelude::*;\n\n// The 'pymodule' macro is used to implement Python modules\n#[pymodule]\nfn prime_fact(_py: Python, m: &PyModule) -> PyResult<()> {\n    Ok(())\n}\n```", "```py\n/// Calculates the prime factors of the given number.\n// Use the macro 'pyfunction' to expose the function to the Python interface\n#[pyfunction]\n// The function takes in an unsigned 128-bit integer (u128)\n// The return value is a Python object constructed from a vector of u128\nfn factorize(mut n: u128) -> PyResult<Vec<u128>> {\n    // Initialize an empty vector (equivalent of a list) for the factors\n    let mut factors = Vec::new();\n\n    // 2 is the only even prime, so try it first\n    while n % 2 == 0 {\n        factors.push(2);\n        n /= 2;\n    }\n\n    let mut i = 3;\n    while i <= n.sqrt() + 1 {\n        if n % i == 0 {\n            factors.push(i);\n            n /= i;\n        } else {\n            i += 2;\n        }\n    }\n\n    if n > 2 {\n        factors.push(n);\n    }\n\n    // Return successfully the vector of factors\n    Ok(factors)\n}\n```", "```py\n#[pymodule]\nfn prime_fact(_py: Python, m: &PyModule) -> PyResult<()> {\n    // Add the 'factorize' function to the module\n    m.add_function(wrap_pyfunction!(factorize, m)?)?;\n    Ok(())\n}\n```", "```py\nmaturin develop\n```", "```py\n# From within the project root directory \nmaturin build\npip install .\n```", "```py\n# Import the module\nimport prime_fact\n\nn = 17376382193\n# Call the function\nfactors = prime_fact.factorize(n)\nprint(f'{n} = {\" * \".join(map(str, factors))}')\n```", "```py\n17376382193 = 17 * 191 * 5351519\n```", "```py\nuse pyo3::prelude::*;\nuse num_integer::Roots;\n\n/// Calculates the prime factors of the given number.\n#[pyfunction]\nfn factorize(mut n: u128) -> PyResult<Vec<u128>> {\n    let mut factors = Vec::new();\n\n    while n % 2 == 0 {\n        factors.push(2);\n        n /= 2;\n    }\n\n    let mut i = 3;\n    while i <= n.sqrt() + 1 {\n        if n % i == 0 {\n            factors.push(i);\n            n /= i;\n        } else {\n            i += 2;\n        }\n    }\n\n    if n > 2 {\n        factors.push(n);\n    }\n\n    Ok(factors)\n}\n\n/// A Python module implemented in Rust.\n#[pymodule]\nfn prime_fact(_py: Python, m: &PyModule) -> PyResult<()> {\n    m.add_function(wrap_pyfunction!(factorize, m)?)?;\n    Ok(())\n}\n```", "```py\nfrom prime_fact import factorize as rust_factorize\nimport math\nimport timeit\n\ndef py_factorize(n):\n    factors = []\n\n    while n % 2 == 0:\n        factors.append(2)\n        n = n / 2\n\n    for i in range(3, round(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            factors.append(i)\n            n = n / i\n\n    if n > 2:\n        factors.append(n)\n\n    return factors\n\n# Benchmark\n\nCOUNT_NUMBER = 10\nREPEAT_NUMBER = 5\nNUMBER = 123456789061514\n\npy_time = timeit.repeat(lambda: py_factorize(NUMBER), repeat=REPEAT_NUMBER, number=COUNT_NUMBER, globals=globals())\npy_time = sum(py_time) / len(py_time)\n\nrust_time = timeit.repeat(lambda: rust_factorize(NUMBER), repeat=REPEAT_NUMBER, number=COUNT_NUMBER, globals=globals())\nrust_time = sum(rust_time) / len(rust_time)\n\nprint(f\"Python: {py_time} seconds\")\nprint(f\"Rust:   {rust_time} seconds\")\n```", "```py\nPython: 2.531 seconds\nRust:   0.014 seconds\n```"]