- en: Creating Dynamic Choropleth Visualizations Using Plotly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/creating-dynamic-choropleth-visualizations-using-plotly-61d266cbe9b4](https://towardsdatascience.com/creating-dynamic-choropleth-visualizations-using-plotly-61d266cbe9b4)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Using a simple-to-learn package to create a complex visualization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://hd2zm.medium.com/?source=post_page-----61d266cbe9b4--------------------------------)[![Hari
    Devanathan](../Images/9c793030ed7d21a2ed2955c57fa19273.png)](https://hd2zm.medium.com/?source=post_page-----61d266cbe9b4--------------------------------)[](https://towardsdatascience.com/?source=post_page-----61d266cbe9b4--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----61d266cbe9b4--------------------------------)
    [Hari Devanathan](https://hd2zm.medium.com/?source=post_page-----61d266cbe9b4--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----61d266cbe9b4--------------------------------)
    ·12 min read·Dec 18, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/17c9e259f0a21a20f9cdd5fc479fc7db.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [NASA](https://unsplash.com/@nasa?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing data is a step that gets overlooked by data scientists. It helps
    us tell stories by analyzing and curating data into a form easy to understand.
    By removing all the technical detail and noise and highlighting key information,
    data scientists can explain the importance of their work to non-technical managers
    and executives.
  prefs: []
  type: TYPE_NORMAL
- en: There are many tools to help visualize data. For years, Microsoft Excel dominated
    the static visualization market. Over time, we gravitated to dynamic visualizations
    and flexibility to showcase more data in a cleaner manner. Two types of tools
    helped create dynamic visuals.
  prefs: []
  type: TYPE_NORMAL
- en: '**Business Intelligence and Analytics Software:** Tableau, PowerBI'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open-sourced programming libraries:** D3.js, Plotly Dash'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third party software tools like Tableau and PowerBI are excellent for non-technical
    folks. Drag and drop interfaces and abstractions allow analysts to create dynamic
    dashboards easily. The drawbacks are
  prefs: []
  type: TYPE_NORMAL
- en: software tools are expensive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a bit of a learning curve to learn these tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: limits to visualization design; software may not allow some components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open-sourced programming libraries are excellent for technical folks. Those
    comfortable with software engineering can follow the documentation to create flexible
    dynamic visualizations with ease. Furthermore, these packages are free to use
    (with Plotly offering a paid version for its enterprise Dash components).
  prefs: []
  type: TYPE_NORMAL
- en: The difference between D3.js and Plotly are the following
  prefs: []
  type: TYPE_NORMAL
- en: D3.js is designed in JavaScript, Plotly is designed in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: D3.js has been around longer than Plotly, and thus has better community support
    and a more mature ecosystem(extensive examples and tutorials).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: D3.js requires engineers to understand the low-level details of web development
    (HTML, CSS, JavaScript) in order to use it effectively. Plotly abstracts such
    details in simple-to-use Python classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: D3.js has a steep learning curve due to its JavaScript nature (asynchronous,
    Domain Object Model, functions), but can build a variety of complex dynamic visualizations.
    Plotly has a small learning curve due to its Python nature, but is limited to
    the kind of visualizations users can build.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If this was in 2019, I would recommend D3.js. At that time, Plotly was severely
    constrained on the kinds of visualizations I would have liked to build.
  prefs: []
  type: TYPE_NORMAL
- en: However, I took a look at Plotly again and was impressed with its improvements.
    The clean interface makes it easy to rival some D3.js’s custom visualizations.
    Furthermore, I don’t have to learn the intricacies of JavaScript to utilize the
    package effectively.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, I was able to create a complex visualization in just 147 lines of code.
    Below is the video of the visualization.
  prefs: []
  type: TYPE_NORMAL
- en: '**Video 1**: Names Dashboard [Video](https://www.youtube.com/watch?v=NmDFOqCduts&t=4s)
    created by Author'
  prefs: []
  type: TYPE_NORMAL
- en: So what does the visualization do?
  prefs: []
  type: TYPE_NORMAL
- en: It has a map that shows how many people have a particular first name. The particular
    first name is based on the far-right dropdown **Choose Name To See Popularity
    Per State On Map**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The names recommended by the **Choose Name To See Popularity Per State On Map**
    dropdown are the most popular N names in the USA. These N names are filtered by
    the middle dropdown **Top N Names,** where N can be 5, 10, or 15.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These names are also filtered by **Gender.** The **Gender** filter is on the
    far left, where users can choose Male or Female.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the visualization is drilled down by **Gender, Top N Names,** and **Choose
    Name To See Popularity Per State On Map,** the map then displays the popularity
    of a selected name by state AND by year. There is a year filter that a user can
    drag through to show the popularity of the selected name over time *instantaneously.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a user clicks on a state, the bar graph below is updated. The bar graph takes
    the state and year of the map upon the click and displays the Top N Popular Names
    in that given state and year. The Top N Names are based on the filter **Top N
    Names.**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a loading spinner to suggest when data is currently being loaded in,
    thus improving the user experience.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The amazing part? This complex visualization was completed in just ***148 lines***
    of Python code. Some of the complex pieces were added in 1–3 lines of code! Check
    out the repository below.
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://github.com/hd2zm/Data-Science-Projects/blob/master/Name-Dashboard/name_dashboard.py?source=post_page-----61d266cbe9b4--------------------------------)
    [## Data-Science-Projects/Name-Dashboard/name_dashboard.py at master · hd2zm/Data-Science-Projects'
  prefs: []
  type: TYPE_NORMAL
- en: Contribute to hd2zm/Data-Science-Projects development by creating an account
    on GitHub.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: github.com](https://github.com/hd2zm/Data-Science-Projects/blob/master/Name-Dashboard/name_dashboard.py?source=post_page-----61d266cbe9b4--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: I was amazed at how intuitive the package is. The creators put a lot of thought
    into making this easy for people who have limited programming experience.
  prefs: []
  type: TYPE_NORMAL
- en: While the documentation is straightforward, I’ll go over how I built each component.
  prefs: []
  type: TYPE_NORMAL
- en: Plotly Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Load in data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two datasets we’re loading
  prefs: []
  type: TYPE_NORMAL
- en: '**names_by_state_cleaned.csv** — a custom dataset that lists all the first
    names of a person, the number of people with such name, the year, and the state.
    This dataset was downloaded and cleaned by the [Social Security administration
    website](https://www.ssa.gov/oact/babynames/). The datasets are [publicly available
    for commercial use](https://www.ssa.gov/oact/babynames/limits.html). Datasets
    were downloaded as folders containing many .txt files, and were merged into one
    CSV file using a custom script. This CSV file is 150 MB, and pretty big to upload
    to Github. For convenience sake, I’m attacking a sample screenshot of the dataset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/3f83048ed8a40109994a39ae2687666f.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1**: Sample dataset of **names_by_state_cleaned.csv**'
  prefs: []
  type: TYPE_NORMAL
- en: '**us-states.json** — a dataset of geographical coordinates of all states in
    the USA. This is used to create the choropleth map. This is 88KB, and can be easily
    loaded in memory. [I’ve uploaded the json to the git repo containing the visualization
    code](https://github.com/hd2zm/Data-Science-Projects/blob/master/Name-Dashboard/us-states.json).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After creating the app, I load the two datasets in memory. Disclaimer: I [explain
    later](#000f) why loading in the csv file in memory isn’t a good idea from a production
    standpoint. For now, I’ll keep it as is.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: HTML Layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here’s the HTML design for the application
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Below is a screenshot of the layout that generates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/243917335446fc96376687007e016925.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 2:** Screenshot of dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: For those who are new to web development, Plotly abstracts all the complexities
    of HTML and CSS. Here are all the main components from the application.
  prefs: []
  type: TYPE_NORMAL
- en: Header 1, which is the title of the visualization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/6e9a72c0af8806367699504f7dfce714.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot of title of visualization
  prefs: []
  type: TYPE_NORMAL
- en: HTML Div with class name `filters`. This contains the Gender Header ( `html.Div`),
    Gender options in radio button format ( `dcc.RadioItems` ), Top N Names Header
    ( `html.Div`), Top N Names options in radio button format ( `dcc.RadioItems` ),
    Choose Name Header ( `html.Div`), and Choose Name dropdown ( `dcc.Dropdown` )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/87cf842acc605b11af111fb65d25bbcb.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3:** Screenshot of different filters for the visualization. A radio
    button filter for Gender, aradio button filter for Top N Names, and a drop down
    filter for Popular Name'
  prefs: []
  type: TYPE_NORMAL
- en: 'A loading spinner ( `dcc.Loading` ) that encompasses two graphs ( `dcc.Graph`
    ): one with id of `map` (see map from **Figure 2)** and one with id of `bar_top_n`
    (see bar chart from **Figure 2**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/32aa74c7107cc08e778a1cda5319ee58.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 4:** Screenshot of loading spinner from visualization.'
  prefs: []
  type: TYPE_NORMAL
- en: I was impressed that creating a loading spinner took 4 lines of code. This complexity
    requires a combination of CSS, HTML, and/or JavaScript in a website. Plotly abstracted
    those details so non-technical users can easily create a user friendly experience.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, I enjoyed how Plotly kept the HTML DOM Structure while naming elements.
    As a former web developer, I quickly picked up on learning Plotly because of that
    HTML familiarity. Furthermore, I liked their utilization of the `children` parameter
    so the elements can be rearranged in an organized fashion. As a software developer,
    it’s better to write code that is maintainable than to write code that is efficient,
    yet confusing to read.
  prefs: []
  type: TYPE_NORMAL
- en: You may notice some values like `initial_rank` or `initial_sex` in the `dcc`
    elements. Those are my custom variables I created before the app HTML layout.
    Here are these variables below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This is why you see the bar graph in **Figure 2** set to the default title
    upon loading: Top 5 Popular Male Names In AK of 1910'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7e6043f482788b9810bdaa835ac18559.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5:** Bar Chart of initial values from dashboard upon loading.'
  prefs: []
  type: TYPE_NORMAL
- en: The goal is to have default options populated when the user first loads the
    dashboard. The user can then navigate through clicks.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the HTML layout, it’s time to add actions. What happens when
    we click on the dropdowns, radio buttons, or map? We utilize JavaScript callback
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Callback functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A JavaScript callback is a function which is to be executed after another function
    has finished execution. JavaScript is asynchronous, which allows it to run functions
    in the background while your application is running. Callbacks are used to execute
    logic after certain events, such as mouse-clicks or typing.
  prefs: []
  type: TYPE_NORMAL
- en: Plotly’s template for callback functions is as follows
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Inputs and outputs take in two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: id of div
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: type of input received from div
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From HTML Layout, here are the following div ids we have
  prefs: []
  type: TYPE_NORMAL
- en: sex-radio-selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: rank-dropdown-selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: top-rank-name-dropdown-selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: loading-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: bar_top_n
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of input can be parameters in `dcc` elements (`dcc.Dropdown` , `dcc.RadioButton`
    ) , `clickData` , `hoverData` , etc. Below is the callback function for the visualization.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The choropleth map and bar chart are created using plotly express figures, and
    returned as part of the output. The order of output returned in the function matters,
    as it should correlate to the Output order specified in the callback template.
    The same holds true for Inputs.
  prefs: []
  type: TYPE_NORMAL
- en: The choropleth has an animation frame parameter, which takes in ‘year’. This
    creates the animation slider by year, shown in in **Figure 6** and **Figure 7**.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5e4c031725d713f5d8f02fef9190469c.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6:** Choropleth Map of Number of people named John in year 1910'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f124b4edcb1f97c0b32722ef353fbe4a.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7:** Choropleth Map of Number of people named John after moving slider
    to year 1940'
  prefs: []
  type: TYPE_NORMAL
- en: The state and year variables are set to `inital_state` and `initial_year` ,
    which were specified above. However, we would want to change those if a user clicked
    on a given state and a given year. Hence the if statement check if `click_data`
    is true, indicating if the `clickData` event is fired.
  prefs: []
  type: TYPE_NORMAL
- en: If `click_data` is true, we set `state=click_data[points][0]['location']` and
    `year=clic_data['points'][0]['customdata']` . Furthermore, we defined the input
    `click_data` as `Input("map", "clickData")` . This means that we’re acknowledging
    a click if it happened on the map and updating the state and year based on the
    `location` and `customdata` properties of the map. Those are parameters defined
    when creating the choropleth map ( `locations=’state'` and `custom_data='year'`
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/055dbba79d7100d5b76da23ce7405def.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 8:** Choropleth Map and Bar Chart, with tooltip shown upon hovering
    on Colorado. Toolitp gives current year, state on hover, and number of people
    with name John.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/64494862f1dc08ef0621afc1018e744d.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 9:** Loading spinner after clicking on state Colorado from **Figure
    8.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/defc1d42da670dcd937396a485566e90.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 10:** Bar graph updated to include Top 5 Popular male Names in state
    of Colorado from 1910\. This is created after user clicked on Colorado in **Figure
    7** and **Figure 8**. You can see different popular names in Colorado as compared
    to Arkansas in **Figure 7** (Charles and William are popular in Colorado instead
    of Paul and Robert in Arkansas).'
  prefs: []
  type: TYPE_NORMAL
- en: Other inputs from dropdowns are used in filtering the data frame of names that
    was initially loaded in. Below are how the filters operate after they are modified
    by the callback function.
  prefs: []
  type: TYPE_NORMAL
- en: Gender Filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../Images/ff87a41c2e2f93f60c79a617d5ef806d.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11:** Dashboard from **Figure 6** after clicking on Gender Female
    radio button. The choropleth map is empty because it had to replace the names
    in the Popular Name Filter (dropdown) from male names to female names. The default
    name John isn’t among the list of female names, so you’ll have to select a female
    name from the dropdown to populate the map.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c04aaa0bc5eb9a3d80eb866f45bfc0b9.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 12:** Dashboard from Figure 11 after selecting on name Helen from
    Popular Name dropdown filter. Now, bar chart is populated with top 5 popular female
    names in Arkansas of 1910 instead of male names. Grey states in the map indicate
    that no one was named Helen in that year and state.'
  prefs: []
  type: TYPE_NORMAL
- en: Top Rank Filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../Images/118303e6926f7b09e6a9c28c221c12c8.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 13:** Map visualization of popularity of John in 1967\. Bar Graph
    of Top 5 popular male names in Texas of 1967.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2f110e7bab58ab2ba8bb220f7097f8ad.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 14:** Loading spinner after clicking on Top N Names radio button 15
    instead of 5'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9d5061bd61331a16ee4904fa0d9136d5.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 15:** Same map as **Figure 13** except with bar chart updated to top
    15 names in Texas of 1967\. Bar chart also has over option to see number of people
    named William in Texas of 1967.'
  prefs: []
  type: TYPE_NORMAL
- en: Popular Name Filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../Images/74a2f15fae71472841146654193eda8e.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 16:** Dashboard with gender male, top 15 names, map with popularity
    of John, and bar chart of top 15 popular male names in Texas of 1910\. Dropdown
    of popularity map shows top 15 names from bar chart populated, with Willie hovered
    over.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c501a3b2ef1f22450a2eebe3e67b2257.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 17:** Dashboard from **Figure 16** after clicking on Willie in the
    Popular Name Filter. Map updates with popularity of Willie over state and year.'
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tips to Improve Visualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use SQL Databases and Queries for Optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may have noticed in the video that the loading spinner takes 4+ seconds
    to load in the data from any filter changes EXCEPT for year. This is because the
    Plotly Dash app reads all 150MB of data from a CSV file in memory, and queries
    select data while the application is running. Hence, why it takes a while to process
    the data frame.
  prefs: []
  type: TYPE_NORMAL
- en: It is much faster to read from a database and select data using SQL queries.
    Now, you’re not loading in all data into memory. Just some parts. Furthermore,
    SQL databases are more compact and take up less memory than CSV files.
  prefs: []
  type: TYPE_NORMAL
- en: Making the Bar Graph More Dynamic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The visualization’s core component is the map of a single name’s popularity
    over location and time. The bar graph of the top N names in a single year or time
    may be redundant, as it contains the same information as the top_rank_name_dropdown
    filter.
  prefs: []
  type: TYPE_NORMAL
- en: The top_rank_name_dropdown filter could be removed, and the bar graph can highlight
    the current name that the map is showing. If a user clicks on another bar with
    a different name, the map updates. If a user clicks on a state in a map, the bar
    graph will update with the top N names, state user selected, and year the slider
    was last on.
  prefs: []
  type: TYPE_NORMAL
- en: Have The Bar Graph Update on The Year Slider On The Map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It seems confusing that the map can be filtered by the year slider, but the
    bar cannot. The bar can be updated by state and year if the user clicks on a state
    on the map. This might be a confusing experience if a bar graph is from a different
    year than what the map year is on the slider.
  prefs: []
  type: TYPE_NORMAL
- en: There might be a way to have the same year filter for both the map and the bar
    graph, but I have yet to come across that solution.
  prefs: []
  type: TYPE_NORMAL
- en: My best guess is to see if there’s an event fired off when moving the year slider.
    Then in the callback, update the bar graph to reflect the current year. However,
    this current approach doesn’t do that because we’re loading in 150MB of data in
    memory, and filtering it in memory. So there would be a tremendous lag time when
    moving the slider.
  prefs: []
  type: TYPE_NORMAL
- en: Revise Top N Filter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some states and years that only have 8 popular names in the dataset
    (Arkansas in 1910). This doesn’t reflect well on the Top N Filter, which shows
    8 bar graphs even when clicking on radio buttons 10 or 15\. Perhaps such buttons
    need to be hidden and replaced with a Top 8 radio button in this special circumstance.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This tutorial showed how to create a complex, dynamic visualization using Plotly.
    While there are ways to improve the visualization, this nevertheless shows how
    easy it is to use this open-source package. With more technical engineers and
    data/business analysts switching to data science, we need better tools to help
    them convey the data to the executives in clean manners. Based on the free costs
    and little learning curve, Plotly puts itself as one of the best packages an aspiring
    data scientist should keep in his/her arsenal.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks for reading! If you want to read more of my work, view my [Table of Contents](https://hd2zm.medium.com/table-of-contents-read-this-first-a124146f566c).
  prefs: []
  type: TYPE_NORMAL
- en: If you’re not a Medium paid member, but are interested in subscribing just to
    read tutorials and articles like this, [click here](https://hd2zm.medium.com/membership)
    to enroll in a membership. Enrolling in this link means I get paid for referring
    you to Medium.
  prefs: []
  type: TYPE_NORMAL
