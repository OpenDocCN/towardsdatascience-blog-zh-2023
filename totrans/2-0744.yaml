- en: Discretizing the Continues Features in Reinforcement Learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/discretizing-the-continues-features-in-reinforcement-learning-b69b388215ea](https://towardsdatascience.com/discretizing-the-continues-features-in-reinforcement-learning-b69b388215ea)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How to convert infinite variables to a discrete space using tile coding and
    Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://eligijus-bujokas.medium.com/?source=post_page-----b69b388215ea--------------------------------)[![Eligijus
    Bujokas](../Images/061fd30136caea2ba927140e8b3fae3c.png)](https://eligijus-bujokas.medium.com/?source=post_page-----b69b388215ea--------------------------------)[](https://towardsdatascience.com/?source=post_page-----b69b388215ea--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----b69b388215ea--------------------------------)
    [Eligijus Bujokas](https://eligijus-bujokas.medium.com/?source=post_page-----b69b388215ea--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----b69b388215ea--------------------------------)
    ·6 min read·Mar 13, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/bdde8e9b4d25e844f699ec37d46e776f.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Ehud Neuhaus](https://unsplash.com/@paramir?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: 'This article is a continuation of the Reinforcement Learning series. To recap,
    visit these articles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/first-steps-in-the-world-of-reinforcement-learning-using-python-b843b76538e3?source=post_page-----b69b388215ea--------------------------------)
    [## First Steps in the World Of Reinforcement Learning using Python'
  prefs: []
  type: TYPE_NORMAL
- en: Original Python implementation of how to find the best places to be in one of
    the fundamental worlds of reinforcement…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/first-steps-in-the-world-of-reinforcement-learning-using-python-b843b76538e3?source=post_page-----b69b388215ea--------------------------------)
    [](/temporal-differences-with-python-first-sample-based-reinforcement-learning-algorithm-54c11745a0ee?source=post_page-----b69b388215ea--------------------------------)
    [## Temporal Differences with Python — First Sample-Based Reinforcement Learning
    Algorithm
  prefs: []
  type: TYPE_NORMAL
- en: Coding up and understanding the TD(0) algorithm using Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/temporal-differences-with-python-first-sample-based-reinforcement-learning-algorithm-54c11745a0ee?source=post_page-----b69b388215ea--------------------------------)
    [](/the-values-of-actions-in-reinforcement-learning-using-q-learning-cb4b03be5c81?source=post_page-----b69b388215ea--------------------------------)
    [## The Values of Actions in Reinforcement Learning using Q-learning
  prefs: []
  type: TYPE_NORMAL
- en: The Q-learning algorithm implemented from scratch in Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/the-values-of-actions-in-reinforcement-learning-using-q-learning-cb4b03be5c81?source=post_page-----b69b388215ea--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 'The last article about Q-Learning explored the concept of assigning a number
    to a state action pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0a6720d5ff36a0a18c56ea8abdc8fd1c.png)'
  prefs: []
  type: TYPE_IMG
- en: Q value function
  prefs: []
  type: TYPE_NORMAL
- en: The states used were states that can be listed and written into a table. For
    example, we indexed all the available positions in a maze that our agent can be
    in. Even in a huge maze (imagine a million times million grid) we can still assign
    a unique index to each state and straightforwardly use the states when filling
    out the Q-table.
  prefs: []
  type: TYPE_NORMAL
- en: Often in practice, the states that our agent is in cannot be uniquely indexed
    and fit into a table. For example, imagine that the state is the angle of the
    wheel which can be turned exactly one time and it can take ANY value in the range
    **[-360, 360]** degrees. The wheel can be turned at exactly **12.155…, 152.1568…**
    and so on degrees. We cannot index all the unique degrees and create a table —
    the amount of possibilities is infinite.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, we would still like to use all the algorithms that RL has to offer.
    Thus, the first step is to create a discrete feature space from the features that
    have infinite possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: One of the popular techniques to discretize a continuous feature space is the
    so-called **tile coding** algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition of tile coding is as follows¹:'
  prefs: []
  type: TYPE_NORMAL
- en: Tile coding is a method for representing a continuous state space by dividing
    the state space into a number of overlapping regions, called tiles, and then representing
    the state by the set of tiles that it falls into.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We can represent a simple 1 feature discretization with the following code
    and graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/bf16b9a4f2371e723d57d763e6b9171d.png)'
  prefs: []
  type: TYPE_IMG
- en: Tiling coding in action for x=0.46; Graph by author
  prefs: []
  type: TYPE_NORMAL
- en: To understand tile coding, we need to perfectly understand what is going on
    in the above graph.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom-most horizontal line is the feature **x** which can obtain any value
    in the range [0, 1].
  prefs: []
  type: TYPE_NORMAL
- en: Each red line is a ***tiling*** which is used in discretizing the feature **x**.
  prefs: []
  type: TYPE_NORMAL
- en: Each tiling is divided into **tiles**, which are evenly spaced out.
  prefs: []
  type: TYPE_NORMAL
- en: The blue dashed line is a random value taken from the x range. The question
    is, how do we use the 4 tilings and 8 tiles to create a discrete state out of
    the x feature value?
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a **value s** from a continues x feature:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For each tiling:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize a vector of size equal to the number of tiles. Fill it with 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculate in what tile the **s value** falls. Save that index **i**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fill in the vector coordinate **i** with value 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, stack all the vectors into one vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us work out the example presented in the graph. For the first tiling, directly
    above the feature space x, the blue value falls into the 5th tiling space. Thus,
    the feature vector of the first tiling is:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[0, 0, 0, 0, 1, 0, 0, 0]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the second tiling, we repeat the same process and end up with the vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[0, 0, 0, 0, 1, 0, 0, 0]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The third and fourth tilings vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[0, 0, 0, 1, 0, 0, 0, 0]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[0, 0, 0, 1, 0, 0, 0, 0]**'
  prefs: []
  type: TYPE_NORMAL
- en: The final discrete vector, representing the blue dashed “state” is
  prefs: []
  type: TYPE_NORMAL
- en: '[**0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
    0, 0, 0, 1, 0, 0, 0, 0**]'
  prefs: []
  type: TYPE_NORMAL
- en: Let's do one more example with an x value of 0.44 to understand the process
    fully.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/acb2b1c7de719853a1ad91f8db1b8ee1.png)'
  prefs: []
  type: TYPE_IMG
- en: x=0.44; Graph by author
  prefs: []
  type: TYPE_NORMAL
- en: 'Each tiling vector (starting from the bottom):'
  prefs: []
  type: TYPE_NORMAL
- en: '**[0, 0, 0, 0, 1, 0, 0, 0]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[0, 0, 0, 1, 0, 0, 0, 0]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[0, 0, 0, 1, 0, 0, 0, 0]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[0, 0, 1, 0, 0, 0, 0, 0]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Final state vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[**0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
    0, 0, 1, 0, 0, 0, 0, 0**]'
  prefs: []
  type: TYPE_NORMAL
- en: The final state representing the vector will be of length **N tilings * N tiles.**
  prefs: []
  type: TYPE_NORMAL
- en: The process of assigning a vector to a state that is presented by 2 features
    follows a very similar algorithm. The tilings now are not horizontal lines but
    rectangles.
  prefs: []
  type: TYPE_NORMAL
- en: Let us imagine that our state is comprised of continuous x and y variables,
    each ranging from 0 to 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will divide the whole feature space with 2 tilings, each comprised of 4
    tiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6fa1a58693ac1f05241117af30017e0c.png)'
  prefs: []
  type: TYPE_IMG
- en: 2D continues space; Graph by author
  prefs: []
  type: TYPE_NORMAL
- en: The grey zone in the above graph represents the original feature space. Each
    red tiling is divided into 4 tiles. We want to create a vector representing the
    state for the blue point (0.44, 0.44).
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm is the same as in the 1D case, but now we assign the index for
    the point falling into a tile going from left to right, going from the top left:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/996fe8c04ca108a1624e6f1bfbe675b4.png)'
  prefs: []
  type: TYPE_IMG
- en: Indexing the tiling; Graph by author
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, for the first and second tiling, the blue point will fall into the 3rd
    tile and the resulting state vectors would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[0, 0, 1, 0]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[0, 0, 1, 0]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'And the final vector would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[0, 0, 1, 0, 0, 0, 1, 0]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking another point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/42423ea91b3e52464c09f4c2357b6819.png)'
  prefs: []
  type: TYPE_IMG
- en: Another 2D point; Graph by author
  prefs: []
  type: TYPE_NORMAL
- en: 'The vectors would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[1, 0, 0, 0]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[0, 0, 1, 0]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the final vector being:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[0, 0, 1, 0, 0, 0, 1, 0]**'
  prefs: []
  type: TYPE_NORMAL
- en: The intuition to create vectors representing states in 3D and above dimensions
    is the same as in the above examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'A powerful implementation in Python can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](http://incompleteideas.net/tiles/tiles3.html?source=post_page-----b69b388215ea--------------------------------)
    [## RLAI open web page'
  prefs: []
  type: TYPE_NORMAL
- en: RLAI open web page by Here we describe software implementing the core part of
    the idea of tile coding as described in…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: incompleteideas.net](http://incompleteideas.net/tiles/tiles3.html?source=post_page-----b69b388215ea--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: In this article, I showcased how to go from continuous feature space to finite
    vectors to represent states using tile coding. In the next article of this RL
    series, I will use this encoding to assign action values to each of such states.
  prefs: []
  type: TYPE_NORMAL
- en: Happy learning and stay tuned!
  prefs: []
  type: TYPE_NORMAL
- en: '[1]'
  prefs: []
  type: TYPE_NORMAL
- en: '**Author:** *Richard Sutton*'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** [http://www.incompleteideas.net/book/8/node6.html#:~:text=Tile%20coding%20is%20a%20form,exhaustive%20partitions%20of%20input%20space](http://www.incompleteideas.net/book/8/node6.html#:~:text=Tile%20coding%20is%20a%20form,exhaustive%20partitions%20of%20input%20space).'
  prefs: []
  type: TYPE_NORMAL
