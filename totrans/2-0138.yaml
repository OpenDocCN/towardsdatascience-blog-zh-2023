- en: 7 Examples to Master Categorical Data Operations with Python Pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/7-examples-to-master-categorical-data-operations-with-python-pandas-51cdcb0228ba](https://towardsdatascience.com/7-examples-to-master-categorical-data-operations-with-python-pandas-51cdcb0228ba)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use category data type when working with low-cardinality categorical features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://sonery.medium.com/?source=post_page-----51cdcb0228ba--------------------------------)[![Soner
    Yıldırım](../Images/c589572e9d1ee176cd4f5a0008173f1b.png)](https://sonery.medium.com/?source=post_page-----51cdcb0228ba--------------------------------)[](https://towardsdatascience.com/?source=post_page-----51cdcb0228ba--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----51cdcb0228ba--------------------------------)
    [Soner Yıldırım](https://sonery.medium.com/?source=post_page-----51cdcb0228ba--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----51cdcb0228ba--------------------------------)
    ·8 min read·Nov 9, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a0de95c1f991d735d8dc687318a5f381.png)'
  prefs: []
  type: TYPE_IMG
- en: (image created by author)
  prefs: []
  type: TYPE_NORMAL
- en: 'Categorical variables can take on a value from a limited number of values,
    which are usually fixed. Here are some examples of categorical variables:'
  prefs: []
  type: TYPE_NORMAL
- en: English skill level indicator (A1, A2, B1, B2, C1, C2)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blood type of a person (A, B, AB, 0)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Demographic information such as race and gender
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Education level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pandas provides a dedicated data type of categorical variables ( `category`
    or `CategoricalDtype` ). Although such data can also be stored with `object` or
    `string` data types, there are several advantages of using the `category` data
    type. We’ll learn about these advantages but let’s first start with how to work
    with the categorical data.
  prefs: []
  type: TYPE_NORMAL
- en: When we create a Series or DataFrame with textual data, its data type becomes
    `object` by default. To use `category` data type, we need to explicitly define
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Although the values are the same, the data types are different as shown with
    `dtype` when you print the Series.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll go over 7 sets of examples to learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Category data type in DataFrames
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Categories
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding and updating values
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding and removing categories
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Order among categories
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Renaming categories
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Advantages of using category data type
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Example 1 — category data type in DataFrames
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can declare `category` data type when creating the Series or DataFrame as
    we did above. We can also convert them to `category` afterwards using the `astype`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: In the code snippet below, we first create a DataFrame with two columns of `object`
    data type. Then, we change the data type of the `blood_type` column to `category`
    . Remember each column of a DataFrame is a Series.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Example 2 — categories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Pandas Series of `category` data type is defined with the categories. By default,
    categories are determined as the unique values in the series.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The categories are shown when we print the brands. We can also extract them
    using the `categories` method available via the cat accessor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It returns an index of the categories.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also define categories while creating the Series, which can be done
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The value “Honda” does not exist in the Series currently but it can be added
    since it’s listed among the categories.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3 — adding and updating values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To add a new value in a Series of `category` data type or replace an existing
    one, we should pick a value from the defined categories. Otherwise, Pandas change
    the data type of the Series to `object` .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When we added the new item “Honda”, which is not among the listed categories,
    we ended up with a Series of `object` data type.
  prefs: []
  type: TYPE_NORMAL
- en: If we try to change one of the existing values with a value different from the
    existing categories, Pandas will raise a type error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There are different ways of fixing this problem. For instance, we can add “Honda”
    as a new category before using it in the Series.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Example 4— adding and removing categories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can add multiple categories at once using a Python list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Just like we can add new categories, it is possible to remove existing categories.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that if the Series includes values that belong to a
    removed category (i.e. a category that no longer exists), these values become
    a missing value (i.e. NaN).
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `categories` method to extract the existing categories from a
    Series.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Example 5— order among categories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some cases, there is an order among categories (e.g. S < M < L). There are
    different ways of enforcing such as order.
  prefs: []
  type: TYPE_NORMAL
- en: One option is to use the `as_ordered` function to add an order to an existing
    Series of categorical data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We now see an order among the categories but it’s wrong. Pandas assigns alphabetical
    order for the string data, which actually makes sense. We can fix this by reordering
    the categories (check the next example).
  prefs: []
  type: TYPE_NORMAL
- en: The sizes Series in the previous example have ordered categories but with a
    a wrong order. Let’s fix it using the `reorder_categories` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We write the categories in the desired order inside a Python list and pass it
    to the `reorder_categories` method.
  prefs: []
  type: TYPE_NORMAL
- en: To remove the order from the categories, we can use the `as_unordered` method.
    Let’s apply it to the sizes Series created in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It is also possible to enforce the order while creating the Series using the
    `ordered` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The ordering is determined based on the order in which we write the categories
    (in this example, it’s C, B, A).
  prefs: []
  type: TYPE_NORMAL
- en: Example 6— renaming categories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use the `rename_categories` method if we need to rename the categories.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we created a Series called “division” with the categories
    C, B, and A. Let’s rename these categories.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As we see in the output, renaming categories also updates the values in the
    Series.
  prefs: []
  type: TYPE_NORMAL
- en: Example 7— Advantages of using category data type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main data structure of Pandas is DataFrame, which is a two-dimensional data
    structure with labeled rows and columns. Each column in a DataFrame is also a
    Series object. Thus, we can easily use categorical data types in a DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we’ll create a sample DataFrame and then add a new column by
    changing the data type of an existing column to category.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The DataFrame we created looks like below. The `brand` and `brand_categorical`
    columns store the same data but with different data types.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b69016b17a2ca150af7dccebcecb961d.png)'
  prefs: []
  type: TYPE_IMG
- en: The first 5 rows of the cars DataFrame (image by author)
  prefs: []
  type: TYPE_NORMAL
- en: What is the purpose of using categorical data type over object or string data
    types? The data is the same anyways.
  prefs: []
  type: TYPE_NORMAL
- en: The answer is the memory usage. Especially if the number of distinct values
    is much less than the total number of values (low-cardinality), you’ll save a
    ton of memory space by using category data type instead of object.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s confirm by calculating the memory usage of the columns in the cars DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It calculates the memory usage in bytes. We use 8 times less memory with category
    data type compared to the object data type. This difference matters more when
    we work with larger datasets (e.g. millions of rows).
  prefs: []
  type: TYPE_NORMAL
- en: Final words
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Category data type is relatively less common than other string-based data types.
    The reason might be that we usually encode string-based data before using it in
    a machine learning model. However, even for data cleaning and preparation, category
    data type offers important advantages. Thus, if a string-based variable contains
    a few distinct values compared to the total values, I strongly recommend using
    category data type.
  prefs: []
  type: TYPE_NORMAL
- en: Thank you for reading. Please let me know if you have any feedback.
  prefs: []
  type: TYPE_NORMAL
