- en: 'From Python to Julia: Basic Data Manipulation and EDA'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/from-python-to-julia-basic-data-manipulation-and-eda-51171b34f685](https://towardsdatascience.com/from-python-to-julia-basic-data-manipulation-and-eda-51171b34f685)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/775edd50e2dd483b847e2e3422ad51eb.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/@wangshenghao1993?source=post_page-----51171b34f685--------------------------------)[![Wang
    Shenghao](../Images/c59ca7f4fc77ca81f6b670ea5435ac19.png)](https://medium.com/@wangshenghao1993?source=post_page-----51171b34f685--------------------------------)[](https://towardsdatascience.com/?source=post_page-----51171b34f685--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----51171b34f685--------------------------------)
    [Wang Shenghao](https://medium.com/@wangshenghao1993?source=post_page-----51171b34f685--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----51171b34f685--------------------------------)
    ·7 min read·Jun 20, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: As an emerging programming language in the space of statistical computing, Julia
    is gaining more and more attention in recent years. There are two features which
    make Julia superior over other programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: Julia is a high-level language like Python. Therefore, it is easy to learn and
    use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Julia is a compiled language, designed to be as fast as C/C++.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When I first got to know Julia, I was attracted by its computing speed. So I
    decided to give Julia a try, and see if I can use it practically in my daily work.
  prefs: []
  type: TYPE_NORMAL
- en: As a data science practitioner, I develop prototype ML models for various purposes
    using Python. To learn Julia quickly, I’m going to mimic my routine process of
    building a simple ML model with both Python and Julia. By comparing the Python
    and Julia code side by side, I can easily capture the syntax difference of the
    two languages. That’s how this blog will be arranged in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before getting started, we need to first install Julia on our workstation. The
    installation of Julia takes the following 2 steps.
  prefs: []
  type: TYPE_NORMAL
- en: Download the installer file from the [official website](https://julialang.org/downloads/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unzip the installer file and create a symbolic link to the Julia binary file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following blog provides a detailed guideline on installing Julia.
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/coffee-in-a-klein-bottle/install-julia-1-5-on-ubuntu-bb8be4b2571d?source=post_page-----51171b34f685--------------------------------)
    [## Installing Julia on Ubuntu'
  prefs: []
  type: TYPE_NORMAL
- en: A quick tutorial on how to install Julia on Ubuntu and add the kernel to Jupyter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/coffee-in-a-klein-bottle/install-julia-1-5-on-ubuntu-bb8be4b2571d?source=post_page-----51171b34f685--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Dataset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I’m going to use a [credit card fraud detection dataset](https://www.kaggle.com/mlg-ulb/creditcardfraud)
    obtained from Kaggle. The dataset contains 492 frauds out of 284,807 transactions.
    There are in total of 30 features including transaction time, amount, and 28 principal
    components obtained with PCA. The “Class” of the transaction is the target variable
    to be predicted, which indicates whether a transaction is a fraud.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to Python, the Julia community developed various packages to support
    the needs of the Julia users. The packages can be installed using Julia’s package
    manager `Pkg` , which is equivalent to Python’s `pip` .
  prefs: []
  type: TYPE_NORMAL
- en: The fraud detection data I use is in the typical .csv format. To load the csv
    data as a dataframe in Julia, both `CSV` and `DataFrame` packages need to be imported.
    The DataFrame package can be treated as the Pandas equivalent in Julia.
  prefs: []
  type: TYPE_NORMAL
- en: Load structured data as dataframe — Julia implementation
  prefs: []
  type: TYPE_NORMAL
- en: Here’s how the imported data looks like.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d91b107709ab9964b873762dde7b8d71.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: In Jupyter, the loaded dataset can be displayed as shown in the above image.
    If you’d like to view more columns, one quick solution will be to specify the
    environment variable `ENV["COLUMNS"]` . Otherwise, only fewer than 10 columns
    will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: The equivalent Python implementation is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/03acf15b0edae9844435162ed1caf119.png)'
  prefs: []
  type: TYPE_IMG
- en: Load structured data as dataframe — Python implementation (Image by author)
  prefs: []
  type: TYPE_NORMAL
- en: Exploratory Data Analysis (EDA)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploratory analysis allows us to examine the data quality and discover the
    patterns among the features, which can be extremely useful for feature engineering
    and training ML models.
  prefs: []
  type: TYPE_NORMAL
- en: Basic statistics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can start with computing some simple statistics of the features, such as
    mean, standard deviation. Similar to Pandas in Python, Julia’s DataFrame package
    provides a `describe` function for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b4171bf435fb5d0cf53f556733cb8596.png)'
  prefs: []
  type: TYPE_IMG
- en: Generate basic statistics using the describe function in Julia (Image by author)
  prefs: []
  type: TYPE_NORMAL
- en: The `describe` function allows us to generate 12 types of basic statistics.
    We can choose which one to generate by changing the `:all` argument such as `describe(df,
    :mean, :std)` . It’s a little annoying that the `describe` function will keep
    omitting the display of statistics if we do not specify `:all` , even if the upper
    limit for the number of displayable columns is set. This is something the Julia
    community can work on in future.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1998da45bdfc44db02e435ccb06f5e85.png)'
  prefs: []
  type: TYPE_IMG
- en: Julia omits printing specified statistics :-/ (Image by author)
  prefs: []
  type: TYPE_NORMAL
- en: Class balance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fraud detection datasets usually suffer from the issue of extreme class imbalance.
    Therefore, we’d like to find out the distribution of the data between the two
    classes. In Julia, this can be done by applying the [“split-apply-combine”](https://dataframes.juliadata.org/stable/man/split_apply_combine/)
    functions, which is equivalent to Pandas’ “groupby-aggregate” function in Python.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/bed59312c9243b3f67f14a0c4ba96d91.png)'
  prefs: []
  type: TYPE_IMG
- en: Check the class distribution — Julia implementation (Image by author)
  prefs: []
  type: TYPE_NORMAL
- en: In Python, we can achieve the same purpose by using the `value_counts()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/843ba904904542765e2f5ae7b22fb149.png)'
  prefs: []
  type: TYPE_IMG
- en: Check the class distribution — Python implementation (Image by author)
  prefs: []
  type: TYPE_NORMAL
- en: Univariate analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, let’s look into the distribution of features using histograms. In particular,
    we take the transaction amount and time as examples, since they are the only interpretable
    features in the dataset.
  prefs: []
  type: TYPE_NORMAL
- en: In Julia, there is a handy library called [StatsPlots](https://github.com/JuliaPlots/StatsPlots.jl),
    which allows us to plot various commonly used statistical graphs including histogram,
    bar chart, box plot etc.
  prefs: []
  type: TYPE_NORMAL
- en: The following code plots the histograms for the transaction amount and time
    in two subplots. It can be observed that the transaction amount is highly skewed.
    For most transactions, the transaction amount is below 100\. The transaction time
    follows a bimodal distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Plot the distribution of transaction time & transaction amount — Julia implementation
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5073b3a8a64416930bd02302c86addb6.png)'
  prefs: []
  type: TYPE_IMG
- en: Plot the distribution of transaction time & transaction amount — Julia implementation
    (Image by author)
  prefs: []
  type: TYPE_NORMAL
- en: In Python, we can use matplotlib and seaborn to create the same chart.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f041c2a0f6b7ee3187c3c6675f48bf7c.png)'
  prefs: []
  type: TYPE_IMG
- en: Plot the distribution of transaction time & transaction amount —Python implementation
    (Image by author)
  prefs: []
  type: TYPE_NORMAL
- en: Bivariate analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the above univariate analysis shows us the general pattern of the transaction
    amount and time, it does not tell us how they are related to the fraud flag to
    be predicted. To have a quick overview for the relationship between the features
    and the target variable, we can create a correlation matrix and visualize it using
    a heatmap.
  prefs: []
  type: TYPE_NORMAL
- en: Before creating the correlation matrix, we need to take note that our data is
    highly imbalanced. In order to better capture the correlation, the data needs
    to be downsampled so that the impact of the features won’t get “diluted” due to
    the data imbalance. This exercise requires dataframe slicing and concatenation.
    The following code demonstrates the implementation of downsampling in Julia.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4f92e0191c910f8dcbe9665b7c2fdb89.png)'
  prefs: []
  type: TYPE_IMG
- en: Downsampling of data in Julia (Image by author)
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code counts the number of the fraud transactions, and combines
    the fraud transactions with the same number of the non-fraud transactions. Next,
    we can create a heatmap to visualise the correlation matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Plot a heatmap to visualize the correlation matrix — Julia implementation
  prefs: []
  type: TYPE_NORMAL
- en: The resulting heatmap is shown as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3ef1faf7dba7104d965cf688d21110b1.png)'
  prefs: []
  type: TYPE_IMG
- en: Feature correlation heatmap plotted by Julia (Image by author)
  prefs: []
  type: TYPE_NORMAL
- en: Here’s the equivalent implementation of downsampling and plotting heatmap in
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b4b193d59bb2424e8c96a594efca5555.png)'
  prefs: []
  type: TYPE_IMG
- en: Downsampling and plotting correlation heatmap — Python implementation (Image
    by author)
  prefs: []
  type: TYPE_NORMAL
- en: 'After having an overview of the feature correlation, we would like to zoom
    into the features with significant correlation with the target variable, which
    is “Class” in this case. From the heatmap, it can be observed that the following
    PCA transformed features carry a positive relationship with “Class”: V2, V4, V11,
    V19, whereas the features which carry a negative relationship include V10, V12,
    V14, V17\. We can use boxplots to examine the impact of these highlighted features
    to the target variable.'
  prefs: []
  type: TYPE_NORMAL
- en: In Julia, boxplots can be created using the aforementioned [StatsPlots](https://github.com/JuliaPlots/StatsPlots.jl)
    package. Here I use the 4 features positively correlated with “Class” as an example
    to illustrate how to create boxplots.
  prefs: []
  type: TYPE_NORMAL
- en: Create boxplots to visualize the impact of features to “Class” — Julia implementation
  prefs: []
  type: TYPE_NORMAL
- en: The `@df` here serves as a macro which indicates creating a boxplot over the
    target dataset, i.e. `balanced_df`. The resulting plot is shown as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a2778178ab52654a8fc5dda21e270382.png)'
  prefs: []
  type: TYPE_IMG
- en: Boxplots of features with positive correlation over “Class” (Image by author)
  prefs: []
  type: TYPE_NORMAL
- en: The following code can be used to create the same boxplot in Python.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e2d8dfd45c64cba5bf37bf7f778888e7.png)'
  prefs: []
  type: TYPE_IMG
- en: Create boxplots to visualize the impact of features to “Class” — Python implementation
    (Image by author)
  prefs: []
  type: TYPE_NORMAL
- en: Intermission
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I’m going to pause here with a quick comment on my “user experience” with Julia
    so far. In terms of the language syntax, Julia seems to be somewhere in between
    Python and R. There are Julia packages which provide comprehensive support to
    the various needs of data manipulation and EDA. However, since the development
    of Julia is still in the early stage, the programming language still lacks resources
    and community support. It can take a lot of time to search for a Julia implementation
    of certain data manipulation exercises such as [unnesting a list-like dataframe
    column](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.explode.html).
    Furthermore, the syntax of Julia is nowhere close to getting stabilized like Python
    3\. At this point, I won’t say Julia is a good choice of programming language
    for large businesses and enterprises.
  prefs: []
  type: TYPE_NORMAL
- en: We are not done with building the fraud detection model. I will continue in
    the next blog. Stay tuned!
  prefs: []
  type: TYPE_NORMAL
- en: Jupyter notebook can be found on [Github](https://github.com/Shenghao1993/shenghao-blogs-work/tree/main/julia-traditional-ml).
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Machine Learning Group of ULB (Université Libre de Bruxelles)](http://mlg.ulb.ac.be).
    (no date). *Credit Card Fraud Detection* [Dataset]. [https://www.kaggle.com/datasets/mlg-ulb/creditcardfraud](https://www.kaggle.com/datasets/mlg-ulb/creditcardfraud)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
