- en: 'Python to Rust: Breaking Down 3 Big Obstacles'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ä» Python åˆ° Rustï¼šç ´è§£ 3 å¤§éšœç¢
- en: åŸæ–‡ï¼š[https://towardsdatascience.com/python-to-rust-breaking-down-3-big-obstacles-094eb99e331d](https://towardsdatascience.com/python-to-rust-breaking-down-3-big-obstacles-094eb99e331d)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://towardsdatascience.com/python-to-rust-breaking-down-3-big-obstacles-094eb99e331d](https://towardsdatascience.com/python-to-rust-breaking-down-3-big-obstacles-094eb99e331d)
- en: Python pro to Rust rookie â€” a data scientistâ€™s transition tale
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python é«˜æ‰‹åˆ° Rust æ–°æ‰‹â€”â€”ä¸€åæ•°æ®ç§‘å­¦å®¶çš„è¿‡æ¸¡æ•…äº‹
- en: '[](https://dennisbakhuis.medium.com/?source=post_page-----094eb99e331d--------------------------------)[![Dennis
    Bakhuis](../Images/4dc6dca031cdedbb044a1d0a6b142186.png)](https://dennisbakhuis.medium.com/?source=post_page-----094eb99e331d--------------------------------)[](https://towardsdatascience.com/?source=post_page-----094eb99e331d--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----094eb99e331d--------------------------------)
    [Dennis Bakhuis](https://dennisbakhuis.medium.com/?source=post_page-----094eb99e331d--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://dennisbakhuis.medium.com/?source=post_page-----094eb99e331d--------------------------------)[![Dennis
    Bakhuis](../Images/4dc6dca031cdedbb044a1d0a6b142186.png)](https://dennisbakhuis.medium.com/?source=post_page-----094eb99e331d--------------------------------)[](https://towardsdatascience.com/?source=post_page-----094eb99e331d--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----094eb99e331d--------------------------------)
    [Dennis Bakhuis](https://dennisbakhuis.medium.com/?source=post_page-----094eb99e331d--------------------------------)'
- en: Â·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----094eb99e331d--------------------------------)
    Â·8 min readÂ·Dec 12, 2023
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Â·å‘è¡¨äº [Towards Data Science](https://towardsdatascience.com/?source=post_page-----094eb99e331d--------------------------------)
    Â·é˜…è¯»æ—¶é—´ 8 åˆ†é’ŸÂ·2023å¹´12æœˆ12æ—¥
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/2c60e597f6041cb1288d3e3032c05b6f.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2c60e597f6041cb1288d3e3032c05b6f.png)'
- en: 'Figure 1: The snake and the crab. (Crab: [Romina BM](https://unsplash.com/photos/a-group-of-red-mushrooms-ZWrsjySNfxY);
    Snake: [Mohan Moolepetlu](https://unsplash.com/photos/close-up-photo-of-brown-and-gray-snake-VUr5nmC1IM4);
    composition by author).'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ 1ï¼šè›‡å’ŒèƒèŸ¹ã€‚ï¼ˆèƒèŸ¹ï¼š[Romina BM](https://unsplash.com/photos/a-group-of-red-mushrooms-ZWrsjySNfxY)ï¼›è›‡ï¼š[Mohan
    Moolepetlu](https://unsplash.com/photos/close-up-photo-of-brown-and-gray-snake-VUr5nmC1IM4)ï¼›ç”±ä½œè€…ç¼–æ’ï¼‰ã€‚
- en: Everybody around me knows that I am a big fan of ğŸ Python. I started using Python
    about 15 years ago when I was fed up with [Mathworks Matlab](https://www.mathworks.com/products/matlab.html).
    While the idea of Matlab seemed nice, after [mastering Python](https://medium.com/towards-data-science/master-python-in-10-minutes-a-day-ac32996b5ded)
    I never looked back. I even became a sort of evangelist of Python at my University
    and â€œspread the wordâ€.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘å‘¨å›´çš„æ¯ä¸ªäººéƒ½çŸ¥é“æˆ‘æ˜¯ä¸€ä¸ªå¿ å®çš„ğŸ Python ç²‰ä¸ã€‚æˆ‘å¤§çº¦ 15 å¹´å‰å¼€å§‹ä½¿ç”¨ Pythonï¼Œå½“æ—¶æˆ‘å¯¹[Mathworks Matlab](https://www.mathworks.com/products/matlab.html)æ„Ÿåˆ°åŒå€¦ã€‚å°½ç®¡
    Matlab çš„æƒ³æ³•çœ‹èµ·æ¥ä¸é”™ï¼Œä½†åœ¨[æŒæ¡ Python](https://medium.com/towards-data-science/master-python-in-10-minutes-a-day-ac32996b5ded)åï¼Œæˆ‘å†ä¹Ÿæ²¡æœ‰å›å¤´ã€‚æˆ‘ç”šè‡³åœ¨æˆ‘çš„å¤§å­¦æˆä¸ºäº†
    Python çš„ä¸€ç§å¸ƒé“è€…ï¼Œå¹¶â€œä¼ æ’­è¿™ä¸ªæ¶ˆæ¯â€ã€‚
- en: The ability to code does not make you a software developer.
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¼–å†™ä»£ç çš„èƒ½åŠ›å¹¶ä¸ä»£è¡¨ä½ æ˜¯ä¸€ä¸ªè½¯ä»¶å¼€å‘äººå‘˜ã€‚
- en: 'At my current employer [TenneT](https://www.tennet.eu/), a large [transmission
    system operator](https://en.wikipedia.org/wiki/Transmission_system_operator) in
    the Netherlands and Germany, we are building a *document parsing and validation
    solution* with a team of about 10 people. Building such a solution, especially
    in a team, is much harder than I thought. This also made me more interested in
    proper paradigms of software engineering. I always thought that my code is not
    too bad, but after looking at work from my software engineer friends: man there
    is so much to learn!'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ç›®å‰çš„é›‡ä¸»[TenneT](https://www.tennet.eu/)â€”â€”è·å…°å’Œå¾·å›½çš„å¤§å‹[ä¼ è¾“ç³»ç»Ÿè¿è¥å•†](https://en.wikipedia.org/wiki/Transmission_system_operator)â€”â€”æˆ‘ä»¬æ­£åœ¨ä¸çº¦
    10 äººçš„å›¢é˜Ÿä¸€èµ·æ„å»ºä¸€ä¸ª*æ–‡æ¡£è§£æå’ŒéªŒè¯è§£å†³æ–¹æ¡ˆ*ã€‚æ„å»ºè¿™æ ·çš„è§£å†³æ–¹æ¡ˆï¼Œå°¤å…¶æ˜¯åœ¨å›¢é˜Ÿä¸­ï¼Œæ¯”æˆ‘æƒ³è±¡çš„è¦å›°éš¾å¾—å¤šã€‚è¿™ä¹Ÿè®©æˆ‘å¯¹è½¯ä»¶å·¥ç¨‹çš„æ­£ç¡®èŒƒå¼æ›´æ„Ÿå…´è¶£ã€‚æˆ‘ä¸€ç›´è®¤ä¸ºæˆ‘çš„ä»£ç è¿˜ä¸é”™ï¼Œä½†åœ¨çœ‹åˆ°æˆ‘è½¯ä»¶å·¥ç¨‹å¸ˆæœ‹å‹çš„å·¥ä½œåï¼šå¤©å“ªï¼Œè¿˜æœ‰å¾ˆå¤šéœ€è¦å­¦ä¹ çš„åœ°æ–¹ï¼
- en: As I learned about topics like [strong typing](https://en.wikipedia.org/wiki/Strong_and_weak_typing),
    [SOLID principles](https://en.wikipedia.org/wiki/SOLID), and general programming
    architectures, I also glanced at other languages and how *they* solved the problem.
    Especially [Rust](https://www.rust-lang.org) caught my eye as I often saw Python
    packages that were based on Rust (e.g. [Polars](https://pola.rs/)).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æˆ‘å­¦ä¹ [å¼ºç±»å‹](https://en.wikipedia.org/wiki/Strong_and_weak_typing)ã€[SOLID åŸåˆ™](https://en.wikipedia.org/wiki/SOLID)å’Œä¸€èˆ¬ç¼–ç¨‹æ¶æ„ç­‰ä¸»é¢˜æ—¶ï¼Œæˆ‘ä¹Ÿç•¥å¾®äº†è§£äº†å…¶ä»–è¯­è¨€ä»¥åŠ*å®ƒä»¬*å¦‚ä½•è§£å†³é—®é¢˜ã€‚ç‰¹åˆ«æ˜¯[Rust](https://www.rust-lang.org)å¸å¼•äº†æˆ‘çš„æ³¨æ„ï¼Œå› ä¸ºæˆ‘ç»å¸¸çœ‹åˆ°åŸºäº
    Rust çš„ Python åŒ…ï¼ˆä¾‹å¦‚ï¼š[Polars](https://pola.rs/)ï¼‰ã€‚
- en: To get a proper introduction to Rust I followed the [***official Rustlings course***](https://github.com/rust-lang/rustlings/)
    which is a local Git repository with 96 small coding *problems*. While it was
    quite doable, Rust is very different than Python. The Rust compiler is a very
    strict fellow that does not take *maybe* for an answer. Below are my three major
    differences between Rust and Python.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†æ›´å¥½åœ°äº†è§£ Rustï¼Œæˆ‘è·Ÿéšäº†[***å®˜æ–¹ Rustlings è¯¾ç¨‹***](https://github.com/rust-lang/rustlings/)ï¼Œè¿™æ˜¯ä¸€ä¸ªåŒ…å«
    96 ä¸ªå°ç¼–ç¨‹*é—®é¢˜*çš„æœ¬åœ° Git ä»“åº“ã€‚è™½ç„¶å®ƒæ˜¯å®Œå…¨å¯ä»¥åšåˆ°çš„ï¼Œä½† Rust ä¸ Python éå¸¸ä¸åŒã€‚Rust ç¼–è¯‘å™¨éå¸¸ä¸¥æ ¼ï¼Œæ— æ³•æ¥å—*ä¹Ÿè®¸*çš„ç­”æ¡ˆã€‚ä»¥ä¸‹æ˜¯æˆ‘è®¤ä¸º
    Rust å’Œ Python ä¹‹é—´çš„ä¸‰ä¸ªä¸»è¦åŒºåˆ«ã€‚
- en: '*Disclaimer: while I am quite proficient with Python, my other languages are
    a bit Rusty (pun intended). I am still learning Rust and I may have understood
    parts incorrectly.*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*å…è´£å£°æ˜ï¼šè™½ç„¶æˆ‘å¯¹ Python éå¸¸ç†Ÿç»ƒï¼Œä½†æˆ‘çš„å…¶ä»–è¯­è¨€æœ‰ç‚¹ç”Ÿç–ï¼ˆåŒå…³è¯­ï¼‰ã€‚æˆ‘ä»åœ¨å­¦ä¹  Rustï¼Œå¹¶ä¸”å¯èƒ½æœ‰äº›éƒ¨åˆ†ç†è§£ä¸å®Œå…¨ã€‚*'
- en: '![](../Images/18b6b0dc602c2a6cb72766e755250dd8.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/18b6b0dc602c2a6cb72766e755250dd8.png)'
- en: 'Figure 2: We made it to the finish line (screenshot by author).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ 2ï¼šæˆ‘ä»¬æˆåŠŸæŠµè¾¾ç»ˆç‚¹ï¼ˆæˆªå›¾ç”±ä½œè€…æä¾›ï¼‰ã€‚
- en: 1\. Ownership, Borrowing, and lifetimes
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1\. æ‰€æœ‰æƒã€å€Ÿç”¨å’Œç”Ÿå‘½å‘¨æœŸ
- en: Ownership and borrowing are probably the most fundamental aspect of the Rust
    programming language. It is designed to ensure memory safety without the need
    of a so called garbage collector. This is a unique concept to Rust and I have
    not yet seen it in other languages.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€æœ‰æƒå’Œå€Ÿç”¨å¯èƒ½æ˜¯ Rust ç¼–ç¨‹è¯­è¨€ä¸­æœ€åŸºæœ¬çš„æ–¹é¢ã€‚å®ƒæ—¨åœ¨ç¡®ä¿å†…å­˜å®‰å…¨ï¼Œæ— éœ€æ‰€è°“çš„åƒåœ¾å›æ”¶å™¨ã€‚è¿™æ˜¯ Rust çš„ç‹¬ç‰¹æ¦‚å¿µï¼Œæˆ‘è¿˜æ²¡æœ‰åœ¨å…¶ä»–è¯­è¨€ä¸­çœ‹åˆ°è¿‡ã€‚
- en: Lets start with an example where we declare a value `42` to the variable `answer_of_life`.
    Rust will now allocate some space in the memory (this is a bit more complex but
    lets keep it simple for now) and attach *â€œownershipâ€* to this variable. It is
    important to know that there can only be one owner at a time. Some operations
    â€œtransfer ownershipâ€, making the previous variable references invalid. This ensures
    memory safety by preventing issues such as double-freeing memory, data races,
    and dangling references.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ä»ä¸€ä¸ªä¾‹å­å¼€å§‹ï¼Œæˆ‘ä»¬å°†å€¼`42`èµ‹ç»™å˜é‡`answer_of_life`ã€‚Rust ç°åœ¨å°†åœ¨å†…å­˜ä¸­åˆ†é…ä¸€äº›ç©ºé—´ï¼ˆè¿™ç¨å¾®å¤æ‚ä¸€äº›ï¼Œä½†æˆ‘ä»¬ç°åœ¨ä¿æŒç®€å•ï¼‰ï¼Œå¹¶å°†*â€œæ‰€æœ‰æƒâ€*é™„åŠ åˆ°è¯¥å˜é‡ã€‚é‡è¦çš„æ˜¯è¦çŸ¥é“ä¸€æ¬¡åªèƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…ã€‚ä¸€äº›æ“ä½œâ€œè½¬ç§»æ‰€æœ‰æƒâ€ï¼Œä½¿å¾—ä¹‹å‰çš„å˜é‡å¼•ç”¨æ— æ•ˆã€‚è¿™é€šè¿‡é˜²æ­¢åŒé‡é‡Šæ”¾å†…å­˜ã€æ•°æ®ç«äº‰å’Œæ‚¬æŒ‚å¼•ç”¨ç­‰é—®é¢˜æ¥ç¡®ä¿å†…å­˜å®‰å…¨ã€‚
- en: 'Source 1: Ownership, ownership transfer, and scope.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: æ¥æº 1ï¼šæ‰€æœ‰æƒã€æ‰€æœ‰æƒè½¬ç§»å’Œä½œç”¨åŸŸã€‚
- en: A term that is also used in other languages is *scope*. This is can be seen
    as a sort of area in which a part of code *â€œlivesâ€*. Every time when the code
    leaves a scope all variables that have ownership are deallocated. This is something
    that is fundamentally different in Python. Python uses a garbage collector that
    deallocates variables when there are no references to it. In the example in *source
    1* the transfer ownership from variable `s1` to `s2` and thereafter, variable
    `s1` is not usable anymore.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å…¶ä»–è¯­è¨€ä¸­ä¹Ÿä½¿ç”¨çš„ä¸€ä¸ªæœ¯è¯­æ˜¯*ä½œç”¨åŸŸ*ã€‚è¿™å¯ä»¥è¢«è§†ä¸ºä»£ç *â€œå­˜åœ¨â€*çš„æŸç§åŒºåŸŸã€‚æ¯æ¬¡ä»£ç ç¦»å¼€ä¸€ä¸ªä½œç”¨åŸŸæ—¶ï¼Œæ‰€æœ‰æ‹¥æœ‰æ‰€æœ‰æƒçš„å˜é‡éƒ½ä¼šè¢«è§£é™¤åˆ†é…ã€‚è¿™æ˜¯ Python
    ä¸­æ ¹æœ¬ä¸åŒçš„ä¸œè¥¿ã€‚Python ä½¿ç”¨åƒåœ¾å›æ”¶å™¨ï¼Œåœ¨æ²¡æœ‰å¯¹å˜é‡çš„å¼•ç”¨æ—¶è§£é™¤åˆ†é…å˜é‡ã€‚åœ¨*æ¥æº 1*çš„ä¾‹å­ä¸­ï¼Œä»å˜é‡`s1`åˆ°`s2`çš„æ‰€æœ‰æƒè½¬ç§»ä¹‹åï¼Œå˜é‡`s1`å°±ä¸å†å¯ç”¨äº†ã€‚
- en: As a Python user ownership can be confusing as is a real struggle in the beginning.
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½œä¸º Python ç”¨æˆ·ï¼Œæ‰€æœ‰æƒå¯èƒ½ä¼šè®©äººæ„Ÿåˆ°å›°æƒ‘ï¼Œç‰¹åˆ«æ˜¯åœ¨å¼€å§‹æ—¶ç¡®å®æ˜¯ä¸€ä¸ªæŒ‘æˆ˜ã€‚
- en: 'In the example in *source 1* is a bit simplistic. Rust enforces you to think
    where a variable is made and how it should be transferred. For example, when you
    use a parameter to a function ownership can be transferred as seen in *Source
    2*:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨*æ¥æº 1*çš„ä¾‹å­ä¸­æœ‰äº›è¿‡äºç®€å•ã€‚Rust å¼ºåˆ¶è¦æ±‚ä½ æ€è€ƒå˜é‡æ˜¯å¦‚ä½•åˆ›å»ºçš„ä»¥åŠå®ƒåº”è¯¥å¦‚ä½•è¢«è½¬ç§»ã€‚ä¾‹å¦‚ï¼Œå½“ä½ å°†å‚æ•°ä¼ é€’ç»™å‡½æ•°æ—¶ï¼Œæ‰€æœ‰æƒå¯ä»¥è¢«è½¬ç§»ï¼Œå¦‚*æ¥æº
    2*ä¸­æ‰€ç¤ºï¼š
- en: 'Source 2: a function takes ownership, invalidating the original variable.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: æ¥æº 2ï¼šä¸€ä¸ªå‡½æ•°è·å–æ‰€æœ‰æƒï¼Œä»è€Œä½¿åŸå§‹å˜é‡æ— æ•ˆã€‚
- en: Only transferring ownership can be cumbersome and maybe for some use-cases even
    unworkable so Rust came up with a so called *borrowing* system. Instead of transferring
    ownership, a variable agrees to borrow the variable while the original variable
    stays owner. By default a borrow variable is immutable, i.e. read only, but by
    adding the `mut` keyword, a borrow can even be mutable. While there can be *unlimited
    immutable borrows*, only a single mutable borrow is allowed. In *Source 3* I show
    an example of two immutable borrows and one mutable borrow. All variables will
    be removed when the function goes out of scope.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ä»…ä»…è½¬ç§»æ‰€æœ‰æƒå¯èƒ½ä¼šå¾ˆéº»çƒ¦ï¼Œç”šè‡³å¯¹äºä¸€äº›ä½¿ç”¨åœºæ™¯æ¥è¯´å¯èƒ½æ— æ³•å®ç°ï¼Œå› æ­¤ Rust æå‡ºäº†ä¸€ä¸ªæ‰€è°“çš„*å€Ÿç”¨*ç³»ç»Ÿã€‚å˜é‡é€šè¿‡å€Ÿç”¨åŒä¸€ä¸ªå˜é‡æ¥é¿å…è½¬ç§»æ‰€æœ‰æƒï¼Œè€ŒåŸå˜é‡ä»ç„¶æ˜¯æ‰€æœ‰è€…ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œå€Ÿç”¨çš„å˜é‡æ˜¯ä¸å¯å˜çš„ï¼Œå³åªè¯»ï¼Œä½†é€šè¿‡æ·»åŠ 
    `mut` å…³é”®å­—ï¼Œå€Ÿç”¨å¯ä»¥å˜æˆå¯å˜çš„ã€‚è™½ç„¶å¯ä»¥æœ‰*æ— é™å¤šä¸ªä¸å¯å˜å€Ÿç”¨*ï¼Œä½†åªå…è®¸æœ‰ä¸€ä¸ªå¯å˜å€Ÿç”¨ã€‚åœ¨*æº 3*ä¸­ï¼Œæˆ‘å±•ç¤ºäº†ä¸¤ä¸ªä¸å¯å˜å€Ÿç”¨å’Œä¸€ä¸ªå¯å˜å€Ÿç”¨çš„ä¾‹å­ã€‚å½“å‡½æ•°è¶…å‡ºä½œç”¨åŸŸæ—¶ï¼Œæ‰€æœ‰å˜é‡å°†è¢«ç§»é™¤ã€‚
- en: 'Source 3: two immutable and one mutable borrows.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: æº 3ï¼šä¸¤ä¸ªä¸å¯å˜å’Œä¸€ä¸ªå¯å˜å€Ÿç”¨ã€‚
- en: 'Lifetimes is a concept in Rust that is related to borrowing and ownership and
    helps the compiler to enforce rules on how long references can be valid. You can
    get into a situation that you create a structure or a function that is build using
    two borrows. This means that now the result of the function or the structure might
    depend on the previous inputs. To make this more explicit, we can express relationships
    by annotating lifetimes. See an example in *source 4*:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ç”Ÿå‘½å‘¨æœŸæ˜¯ Rust ä¸­ä¸å€Ÿç”¨å’Œæ‰€æœ‰æƒç›¸å…³çš„æ¦‚å¿µï¼Œå¸®åŠ©ç¼–è¯‘å™¨å¼ºåˆ¶æ‰§è¡Œå¼•ç”¨æœ‰æ•ˆçš„æ—¶é•¿ã€‚ä½ å¯èƒ½ä¼šé‡åˆ°åˆ›å»ºä¸€ä¸ªä½¿ç”¨ä¸¤ä¸ªå€Ÿç”¨çš„ç»“æ„æˆ–å‡½æ•°çš„æƒ…å†µã€‚è¿™æ„å‘³ç€ç°åœ¨å‡½æ•°æˆ–ç»“æ„çš„ç»“æœå¯èƒ½ä¾èµ–äºä¹‹å‰çš„è¾“å…¥ã€‚ä¸ºäº†ä½¿è¿™ä¸€ç‚¹æ›´æ˜ç¡®ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡æ³¨é‡Šç”Ÿå‘½å‘¨æœŸæ¥è¡¨è¾¾å…³ç³»ã€‚åœ¨*æº
    4*ä¸­æŸ¥çœ‹ç¤ºä¾‹ï¼š
- en: 'Source 4: Lifetimes syntax can be confusing at first but eventually it helps.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: æº 4ï¼šç”Ÿå‘½å‘¨æœŸè¯­æ³•åˆçœ‹å¯èƒ½ä»¤äººå›°æƒ‘ï¼Œä½†æœ€ç»ˆä¼šæœ‰æ‰€å¸®åŠ©ã€‚
- en: 'Ownership, borrowing, and lifetimes are not easy to cope with but definitely
    forces you to create better code. At least, when you can get past the compiler
    (-:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 'æ‰€æœ‰æƒã€å€Ÿç”¨å’Œç”Ÿå‘½å‘¨æœŸè™½ç„¶ä¸æ˜“å¤„ç†ï¼Œä½†ç¡®å®è¿«ä½¿ä½ ç¼–å†™æ›´å¥½çš„ä»£ç ã€‚è‡³å°‘ï¼Œå½“ä½ èƒ½å¤Ÿé€šè¿‡ç¼–è¯‘å™¨çš„æ£€æŸ¥æ—¶ï¼ˆ-:'
- en: 2\. Rust does not take None for an answer
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2. Rust ä¸æ¥å— `None` ä½œä¸ºç­”æ¡ˆ
- en: 'Something that is very common in Python is not possible in Rust: having a value
    that is set to `None`. It is a deliberate design choice that aligns with Rustâ€™s
    goals of safety, predictability, and zero-cost abstractions.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Python ä¸­éå¸¸å¸¸è§çš„äº‹æƒ…åœ¨ Rust ä¸­æ˜¯ä¸å¯èƒ½çš„ï¼šè®¾ç½®ä¸€ä¸ªå€¼ä¸º `None`ã€‚è¿™æ˜¯ä¸€ä¸ªä¸ Rust çš„å®‰å…¨æ€§ã€å¯é¢„æµ‹æ€§å’Œé›¶æˆæœ¬æŠ½è±¡ç›®æ ‡ä¸€è‡´çš„è®¾è®¡é€‰æ‹©ã€‚
- en: 'The safety aspect is similar to the ownership, borrowing, and lifetimes aspect
    of rust: prevent the possibility of references pointing to unallocated memory.
    By not giving the possibility to return `None` will result in more predictability
    as it forces the developer to explicitly handle cases where a number might be
    absent. Due to memory safety and predictable behavior Rust can achieve all its
    high-level language features without sacrificing performance.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: å®‰å…¨æ€§æ–¹é¢ç±»ä¼¼äº Rust çš„æ‰€æœ‰æƒã€å€Ÿç”¨å’Œç”Ÿå‘½å‘¨æœŸæ–¹é¢ï¼šé˜²æ­¢å¼•ç”¨æŒ‡å‘æœªåˆ†é…çš„å†…å­˜ã€‚é€šè¿‡ä¸å…è®¸è¿”å› `None`ï¼Œå°†å¯¼è‡´æ›´é«˜çš„å¯é¢„æµ‹æ€§ï¼Œå› ä¸ºå®ƒè¿«ä½¿å¼€å‘è€…æ˜¾å¼å¤„ç†å¯èƒ½ç¼ºå°‘æ•°å­—çš„æƒ…å†µã€‚ç”±äºå†…å­˜å®‰å…¨å’Œå¯é¢„æµ‹è¡Œä¸ºï¼ŒRust
    å¯ä»¥å®ç°æ‰€æœ‰é«˜çº§è¯­è¨€åŠŸèƒ½è€Œä¸ä¼šç‰ºç‰²æ€§èƒ½ã€‚
- en: None shall not pass â€” Gandalf the Grey
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: â€œNone shall not passâ€ â€” ç”˜é“å¤«ç°è¢
- en: 'Just denying `None` would make Rust a terrible language, therefore, the creators
    come with a nice alternative: the Enums `Option` and `Result`. With these Enums
    we can explicitly represent the presence of absence of a value. It also makes
    the error handling very elegant. Lets consider *Source 5* for an example of `Option`.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ä»…ä»…æ‹’ç» `None` ä¼šä½¿ Rust æˆä¸ºä¸€ä¸ªç³Ÿç³•çš„è¯­è¨€ï¼Œå› æ­¤åˆ›ä½œè€…æå‡ºäº†ä¸€ä¸ªä¸é”™çš„æ›¿ä»£æ–¹æ¡ˆï¼šæšä¸¾ `Option` å’Œ `Result`ã€‚é€šè¿‡è¿™äº›æšä¸¾ï¼Œæˆ‘ä»¬å¯ä»¥æ˜¾å¼åœ°è¡¨ç¤ºå€¼çš„å­˜åœ¨æˆ–ç¼ºå¤±ã€‚è¿™ä¹Ÿä½¿å¾—é”™è¯¯å¤„ç†éå¸¸ä¼˜é›…ã€‚è®©æˆ‘ä»¬è€ƒè™‘*æº
    5*ä¸­çš„ `Option` ç¤ºä¾‹ã€‚
- en: 'Source 5: Using Option to return an optional answer and handle special cases.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: æº 5ï¼šä½¿ç”¨ Option è¿”å›å¯é€‰ç­”æ¡ˆå¹¶å¤„ç†ç‰¹æ®Šæƒ…å†µã€‚
- en: '***Wait a minute!*** Didnâ€™t you say that there was no `None`? This was also
    something that tricked me the first time, but None here is a special Enum struct
    that does not take a parameter. Also `Some` is a special struct, but that can
    take a parameter. Our function *divide()* returns one of these possible Enum values
    and we can later check what it is and act accordingly.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '***ç­‰ä¸€ä¸‹ï¼*** ä½ ä¸æ˜¯è¯´æ²¡æœ‰ `None` å—ï¼Ÿè¿™ä¹Ÿæ˜¯ç¬¬ä¸€æ¬¡è®©æˆ‘æ„Ÿåˆ°å›°æƒ‘çš„åœ°æ–¹ï¼Œä¸è¿‡è¿™é‡Œçš„ `None` æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„æšä¸¾ç»“æ„ä½“ï¼Œä¸æ¥å—å‚æ•°ã€‚`Some`
    ä¹Ÿæ˜¯ä¸€ä¸ªç‰¹æ®Šçš„ç»“æ„ä½“ï¼Œä½†å¯ä»¥æ¥å—å‚æ•°ã€‚æˆ‘ä»¬çš„å‡½æ•°*divide()*è¿”å›è¿™äº›å¯èƒ½çš„æšä¸¾å€¼ä¹‹ä¸€ï¼Œéšåæˆ‘ä»¬å¯ä»¥æ£€æŸ¥å®ƒæ˜¯ä»€ä¹ˆï¼Œå¹¶æ®æ­¤é‡‡å–è¡ŒåŠ¨ã€‚'
- en: Without None and forcing a return value makes Rust very predictable.
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ²¡æœ‰ `None` å¹¶ä¸”å¼ºåˆ¶è¿”å›å€¼ä½¿å¾— Rust éå¸¸å¯é¢„æµ‹ã€‚
- en: The main function uses a *match* construct to do the result handling which is
    very convenient. It is somewhat similar to a *switch*/*case* construct in other
    languages except Python (see Figure 2 for Guidoâ€™s response). The *match* checks
    if it is Enum `Some` or Enum `None` and performs the associated action.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸»å‡½æ•°ä½¿ç”¨ *match* ç»“æ„æ¥å¤„ç†ç»“æœï¼Œè¿™éå¸¸æ–¹ä¾¿ã€‚å®ƒæœ‰ç‚¹ç±»ä¼¼äºå…¶ä»–è¯­è¨€ä¸­çš„ *switch*/*case* ç»“æ„ï¼ˆå‚è§å›¾ 2 ä¸­ Guido çš„å›åº”ï¼‰ã€‚*match*
    æ£€æŸ¥æ˜¯å¦æ˜¯ Enum `Some` æˆ– Enum `None` å¹¶æ‰§è¡Œç›¸å…³æ“ä½œã€‚
- en: 'Figure 3: [Tweet/reaction](https://twitter.com/gvanrossum/status/1276336548296810496)
    of Guido van Rossum on switch/case.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ 3ï¼š[Guido van Rossum å¯¹ switch/case çš„æ¨æ–‡/ååº”](https://twitter.com/gvanrossum/status/1276336548296810496)ã€‚
- en: The `Option` Enum is a special structure for functions that can return a value
    or not. For functions that can return a value or an error, Rust has an even more
    explicit Enum called `Result`. The idea is exactly the same, with the main difference
    that `Option` has a default â€œerrorâ€ value `None` set, while `Result` needs an
    explicit â€œerrorâ€ type. This type can be a simple string or a more explicit Struct
    to identify the error. In *Source 6* the divide function is rewritten using `Result`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`Option` æšä¸¾æ˜¯ä¸€ç§ç‰¹æ®Šçš„ç»“æ„ï¼Œç”¨äºå¤„ç†å¯èƒ½è¿”å›å€¼æˆ–ä¸è¿”å›å€¼çš„å‡½æ•°ã€‚å¯¹äºå¯ä»¥è¿”å›å€¼æˆ–é”™è¯¯çš„å‡½æ•°ï¼ŒRust æœ‰ä¸€ä¸ªæ›´ä¸ºæ˜ç¡®çš„æšä¸¾ï¼Œç§°ä¸º `Result`ã€‚å®ƒä»¬çš„æ€æƒ³å®Œå…¨ç›¸åŒï¼Œä¸»è¦åŒºåˆ«åœ¨äº
    `Option` æœ‰ä¸€ä¸ªé»˜è®¤çš„â€œé”™è¯¯â€å€¼ `None`ï¼Œè€Œ `Result` éœ€è¦ä¸€ä¸ªæ˜ç¡®çš„â€œé”™è¯¯â€ç±»å‹ã€‚è¿™ä¸ªç±»å‹å¯ä»¥æ˜¯ç®€å•çš„å­—ç¬¦ä¸²ï¼Œä¹Ÿå¯ä»¥æ˜¯æ›´æ˜ç¡®çš„ç»“æ„ä½“æ¥æ ‡è¯†é”™è¯¯ã€‚åœ¨
    *æ¥æº 6* ä¸­ï¼Œdivide å‡½æ•°ä½¿ç”¨ `Result` é‡æ–°ç¼–å†™ã€‚'
- en: 'Source 6: The Result Enum is a great way to return a value or an error.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: æ¥æº 6ï¼š`Result` æšä¸¾æ˜¯ä¸€ç§å¾ˆå¥½çš„è¿”å›å€¼æˆ–é”™è¯¯çš„æ–¹å¼ã€‚
- en: The Rust developers saw that the *match* construct can sometimes be a bit tedious
    and therefore, added `if let` and `while let` operators. These operators are similar
    to *match* but give some nice syntactic sugar with juicy icing. There is even
    a very cool `?` operator (not shown here) which even adds a cherry on top of the
    juicy icing!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Rust å¼€å‘è€…å‘ç° *match* ç»“æ„æœ‰æ—¶å¯èƒ½æœ‰äº›ç¹çï¼Œå› æ­¤æ·»åŠ äº† `if let` å’Œ `while let` æ“ä½œç¬¦ã€‚è¿™äº›æ“ä½œç¬¦ç±»ä¼¼äº *match*ï¼Œä½†æä¾›äº†ä¸€äº›æ¼‚äº®çš„è¯­æ³•ç³–å’Œä¸°å¯Œçš„è£…é¥°ã€‚ç”šè‡³è¿˜æœ‰ä¸€ä¸ªéå¸¸é…·çš„
    `?` æ“ä½œç¬¦ï¼ˆè¿™é‡Œæœªå±•ç¤ºï¼‰ï¼Œå®ƒä¸ºä¸°å¯Œçš„è£…é¥°æ·»åŠ äº†ä¸€ä¸ªæ¨±æ¡ƒåœ¨ä¸Šé¢ï¼
- en: 'Source 7: if let and while let are creating beautiful syntactic sugar!'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: æ¥æº 7ï¼š`if let` å’Œ `while let` æ­£åœ¨åˆ›é€ ç¾ä¸½çš„è¯­æ³•ç³–ï¼
- en: Using Python I learned to use the Optional keyword to type a result for being
    a value or None. But I have to agree that Rust has solved this part very neatly.
    I can imagine that the Python community will also move more towards this style,
    similar to what is going on with strong(er) typing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ Python æ—¶ï¼Œæˆ‘å­¦ä¼šäº†ä½¿ç”¨ Optional å…³é”®å­—æ¥ä¸ºç»“æœç±»å‹å®šä¹‰å€¼æˆ– Noneã€‚ä½†æˆ‘ä¸å¾—ä¸æ‰¿è®¤ Rust åœ¨è¿™æ–¹é¢å¤„ç†å¾—éå¸¸ç²¾å¦™ã€‚æˆ‘å¯ä»¥æƒ³è±¡ï¼ŒPython
    ç¤¾åŒºä¹Ÿä¼šæœç€è¿™ç§é£æ ¼å‘å±•ï¼Œç±»ä¼¼äºå¼ºç±»å‹åŒ–çš„è¶‹åŠ¿ã€‚
- en: 3\. Where are the classes?
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3\. ç±»åœ¨å“ªé‡Œï¼Ÿ
- en: 'Both Python and Rust can be used in the two programming paradigms: functional
    programming (FP) and object oriented programming (OOP). However Rust takes a different
    flavor on how it implements these so called objects. In Python we have a typical
    `class` object for which we can associate variables and methods. As with many
    other languages such as Java, we can now use this method as a base and expand
    functionality by creating new objects that inherit methods and variables from
    their parent.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Python å’Œ Rust éƒ½å¯ä»¥ç”¨äºä¸¤ç§ç¼–ç¨‹èŒƒå¼ï¼šå‡½æ•°å¼ç¼–ç¨‹ï¼ˆFPï¼‰å’Œé¢å‘å¯¹è±¡ç¼–ç¨‹ï¼ˆOOPï¼‰ã€‚ç„¶è€Œï¼ŒRust å®ç°è¿™äº›æ‰€è°“çš„å¯¹è±¡çš„æ–¹å¼æœ‰æ‰€ä¸åŒã€‚åœ¨ Python
    ä¸­ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ªå…¸å‹çš„ `class` å¯¹è±¡ï¼Œå¯ä»¥å…³è”å˜é‡å’Œæ–¹æ³•ã€‚åƒè®¸å¤šå…¶ä»–è¯­è¨€ï¼ˆå¦‚ Javaï¼‰ä¸€æ ·ï¼Œæˆ‘ä»¬ç°åœ¨å¯ä»¥å°†è¿™ä¸ªæ–¹æ³•ä½œä¸ºåŸºç¡€ï¼Œé€šè¿‡åˆ›å»ºç»§æ‰¿çˆ¶ç±»æ–¹æ³•å’Œå˜é‡çš„æ–°å¯¹è±¡æ¥æ‰©å±•åŠŸèƒ½ã€‚
- en: 'In Rust, there is no `class` keyword and objects are fundamentally different
    from Python. Rust uses a trait system for code reuse and polymorphism which can
    give the same benefits as multiple inheritance, but without the problems associated
    with multiple inheritance. Multiple inheritance is often used to combine or share
    various functionality with multiple classes but it can make the code complex and
    ambiguous. A famous problem is the so called *diamond* problem shown in *Source
    8*:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Rust ä¸­ï¼Œæ²¡æœ‰ `class` å…³é”®å­—ï¼Œå¯¹è±¡ä¸ Python çš„æ ¹æœ¬ä¸åŒã€‚Rust ä½¿ç”¨ç‰¹è´¨ç³»ç»Ÿæ¥å®ç°ä»£ç é‡ç”¨å’Œå¤šæ€ï¼Œè¿™å¯ä»¥å¸¦æ¥ä¸å¤šé‡ç»§æ‰¿ç›¸åŒçš„å¥½å¤„ï¼Œä½†æ²¡æœ‰å¤šé‡ç»§æ‰¿æ‰€å¸¦æ¥çš„é—®é¢˜ã€‚å¤šé‡ç»§æ‰¿é€šå¸¸ç”¨äºç»“åˆæˆ–å…±äº«å¤šä¸ªç±»çš„å„ç§åŠŸèƒ½ï¼Œä½†å®ƒå¯èƒ½ä½¿ä»£ç å˜å¾—å¤æ‚å’Œæ¨¡ç³Šã€‚ä¸€ä¸ªè‘—åçš„é—®é¢˜æ˜¯
    *é’»çŸ³* é—®é¢˜ï¼Œå¦‚ *æ¥æº 8* æ‰€ç¤ºï¼š
- en: 'Source 8: The diamond problem: it is not clear which method is used.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: æ¥æº 8ï¼šé’»çŸ³é—®é¢˜ï¼šä¸æ¸…æ¥šä½¿ç”¨äº†å“ªä¸ªæ–¹æ³•ã€‚
- en: While I think we can easily work around this problem, if I would create a new
    language, I would also try to do this differently. For multiple inheritance, the
    goal was mostly to share similar functionality with other objects. This is done
    much more elegantly in Rust using the Trait system. This method is not unique
    to Rust as similar systems are used in Scala, Kotlin, and Haskell.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: è™½ç„¶æˆ‘è®¤ä¸ºæˆ‘ä»¬å¯ä»¥å¾ˆå®¹æ˜“åœ°è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä½†å¦‚æœæˆ‘åˆ›å»ºä¸€ç§æ–°çš„è¯­è¨€ï¼Œæˆ‘ä¹Ÿä¼šå°è¯•ä»¥ä¸åŒçš„æ–¹å¼æ¥åšã€‚å¯¹äºå¤šé‡ç»§æ‰¿ï¼Œç›®æ ‡ä¸»è¦æ˜¯ä¸å…¶ä»–å¯¹è±¡å…±äº«ç›¸ä¼¼çš„åŠŸèƒ½ã€‚åœ¨Rustä¸­ï¼Œé€šè¿‡ä½¿ç”¨Traitç³»ç»Ÿï¼Œè¿™ç§æ–¹æ³•åšå¾—æ›´ä¼˜é›…ã€‚è¿™ç§æ–¹æ³•å¹¶ä¸æ˜¯Rustç‹¬æœ‰çš„ï¼Œç±»ä¼¼çš„ç³»ç»Ÿä¹Ÿåœ¨Scalaã€Kotlinå’ŒHaskellä¸­ä½¿ç”¨ã€‚
- en: 'Classes in Rust are created from Enums and Structs. On its own, these are only
    data structures but we can add functionality to these classes. We could do this
    directly, however, by using traits this functionality can be shared with multiple
    â€œclassesâ€. A big benefit for using traits is that we can check beforehand if a
    certain trait is implemented. See the following example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Rustä¸­çš„ç±»æ˜¯ç”±æšä¸¾ï¼ˆEnumsï¼‰å’Œç»“æ„ä½“ï¼ˆStructsï¼‰åˆ›å»ºçš„ã€‚å•ç‹¬æ¥çœ‹ï¼Œè¿™äº›åªæ˜¯æ•°æ®ç»“æ„ï¼Œä½†æˆ‘ä»¬å¯ä»¥å‘è¿™äº›ç±»æ·»åŠ åŠŸèƒ½ã€‚æˆ‘ä»¬å¯ä»¥ç›´æ¥è¿™æ ·åšï¼Œç„¶è€Œï¼Œé€šè¿‡ä½¿ç”¨ç‰¹å¾ï¼Œè¿™äº›åŠŸèƒ½å¯ä»¥ä¸å¤šä¸ªâ€œç±»â€å…±äº«ã€‚ä½¿ç”¨ç‰¹å¾çš„ä¸€ä¸ªå¤§å¥½å¤„æ˜¯æˆ‘ä»¬å¯ä»¥æå‰æ£€æŸ¥æŸä¸ªç‰¹å¾æ˜¯å¦è¢«å®ç°ã€‚è¯·å‚è§ä»¥ä¸‹ç¤ºä¾‹ï¼š
- en: 'Source 9: Adding a shared trait to two structs.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 'Source 9: ä¸ºä¸¤ä¸ªç»“æ„ä½“æ·»åŠ ä¸€ä¸ªå…±äº«ç‰¹å¾ã€‚'
- en: 'In this example, we have a `Speaker` trait representing characters that can
    speak. We implement this trait for two types: `Jedi` and `Droid`. Each type provides
    its own implementation of the `speak` method.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ª`Speaker`ç‰¹å¾ï¼Œè¡¨ç¤ºèƒ½å¤Ÿè¯´è¯çš„è§’è‰²ã€‚æˆ‘ä»¬ä¸ºä¸¤ç§ç±»å‹`Jedi`å’Œ`Droid`å®ç°äº†è¿™ä¸ªç‰¹å¾ã€‚æ¯ç§ç±»å‹éƒ½æä¾›äº†è‡ªå·±å¯¹`speak`æ–¹æ³•çš„å®ç°ã€‚
- en: The `introduce` function takes any type that implements the `Speaker` trait
    and calls the `speak` method. In the `main` function, we create instances of `Jedi`
    (Obi-Wan Kenobi) and `Droid` (R2-D2) and pass them to the `introduce` function,
    showcasing polymorphism.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`introduce`å‡½æ•°æ¥å—ä»»ä½•å®ç°äº†`Speaker`ç‰¹å¾çš„ç±»å‹ï¼Œå¹¶è°ƒç”¨`speak`æ–¹æ³•ã€‚åœ¨`main`å‡½æ•°ä¸­ï¼Œæˆ‘ä»¬åˆ›å»ºäº†`Jedi`ï¼ˆObi-Wan
    Kenobiï¼‰å’Œ`Droid`ï¼ˆR2-D2ï¼‰çš„å®ä¾‹ï¼Œå¹¶å°†å®ƒä»¬ä¼ é€’ç»™`introduce`å‡½æ•°ï¼Œå±•ç¤ºäº†å¤šæ€æ€§ã€‚'
- en: For me, as a Pythonista [ğŸ](https://emojipedia.org/snake), the Rust trait system
    was very confusing. It took me a while to appreciate the elegance of the syntax.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹æˆ‘æ¥è¯´ï¼Œä½œä¸ºä¸€ä¸ªPythonista [ğŸ](https://emojipedia.org/snake)ï¼ŒRustçš„ç‰¹å¾ç³»ç»Ÿéå¸¸ä»¤äººå›°æƒ‘ã€‚æˆ‘èŠ±äº†ä¸€æ®µæ—¶é—´æ‰æ¬£èµåˆ°å…¶è¯­æ³•çš„ä¼˜é›…ã€‚
- en: Wrap up
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ€»ç»“
- en: Rust is a very cool language but is definitely not an easy one to learn. The
    Rustlings course showed me a bit the basics, but I am by far not yet proficient
    enough to pick up big projects. But I really like how Rust is forcing you to write
    better and safer code.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Rustæ˜¯ä¸€é—¨éå¸¸é…·çš„è¯­è¨€ï¼Œä½†ç»å¯¹ä¸æ˜¯ä¸€é—¨å®¹æ˜“å­¦ä¹ çš„è¯­è¨€ã€‚Rustlingsè¯¾ç¨‹è®©æˆ‘äº†è§£äº†ä¸€äº›åŸºç¡€çŸ¥è¯†ï¼Œä½†æˆ‘è¿œè¿œæ²¡æœ‰è¶³å¤Ÿç†Ÿç»ƒæ¥æ‰¿æ‹…å¤§å‹é¡¹ç›®ã€‚ä½†æˆ‘çœŸçš„å¾ˆå–œæ¬¢Rustå¦‚ä½•è¿«ä½¿ä½ ç¼–å†™æ›´å¥½ã€æ›´å®‰å…¨çš„ä»£ç ã€‚
- en: Python will still be my daily driver. At work, our document pipe-line is built
    fully in Python and also in the machine learning world I do not see everything
    change to another language. Python is just too easy to learn and even if you are
    a terrible developer (not me of course (-;) you can get the job done.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Pythonä»ç„¶æ˜¯æˆ‘çš„æ—¥å¸¸ä½¿ç”¨è¯­è¨€ã€‚åœ¨å·¥ä½œä¸­ï¼Œæˆ‘ä»¬çš„æ–‡æ¡£ç®¡é“å®Œå…¨ç”¨Pythonæ„å»ºï¼Œè€Œä¸”åœ¨æœºå™¨å­¦ä¹ é¢†åŸŸï¼Œæˆ‘çœ‹ä¸åˆ°æ‰€æœ‰çš„ä¸œè¥¿éƒ½æ¢æˆå¦ä¸€ç§è¯­è¨€ã€‚Pythonå®åœ¨æ˜¯å¤ªå®¹æ˜“å­¦ä¹ äº†ï¼Œå³ä½¿ä½ æ˜¯ä¸€ä¸ªç³Ÿç³•çš„å¼€å‘è€…ï¼ˆå½“ç„¶ä¸æ˜¯æˆ‘
    (-;)ï¼‰ï¼Œä½ ä¹Ÿå¯ä»¥å®Œæˆå·¥ä½œã€‚
- en: There is however a small momentum towards Rust. Of course, some packages like
    Polars and Pydantic are built using Rust, but also HuggingFace has released their
    own first version of a Machine Learning framework built in Rust called Candle.
    So I think it is not a bad idea to learn a bit of Rust!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼ŒRustçš„åŠ¿å¤´æ­£åœ¨å°å¹…ä¸Šå‡ã€‚å½“ç„¶ï¼Œä¸€äº›åŒ…å¦‚Polarså’ŒPydanticæ˜¯ä½¿ç”¨Rustæ„å»ºçš„ï¼Œä½†HuggingFaceä¹Ÿå‘å¸ƒäº†ä»–ä»¬è‡ªå·±çš„ç¬¬ä¸€ä¸ªç”¨Rustæ„å»ºçš„æœºå™¨å­¦ä¹ æ¡†æ¶ç‰ˆæœ¬ï¼Œåä¸ºCandleã€‚æ‰€ä»¥æˆ‘è®¤ä¸ºå­¦ä¹ ä¸€ç‚¹Rustå¹¶ä¸æ˜¯ä¸€ä¸ªåä¸»æ„ï¼
- en: My next (or actually current) journey for Rust is participating in the [Advent
    of Code 2023](https://adventofcode.com/) using Rust. I am also looking into Leptos
    and plan to create a profile website. Still a lot to learn!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä¸‹ä¸€æ­¥ï¼ˆæˆ–å®é™…ä¸Šæ˜¯å½“å‰ï¼‰Rustçš„æ—…ç¨‹æ˜¯ä½¿ç”¨Rustå‚ä¸[Advent of Code 2023](https://adventofcode.com/)ã€‚æˆ‘è¿˜åœ¨ç ”ç©¶Leptosï¼Œå¹¶è®¡åˆ’åˆ›å»ºä¸€ä¸ªä¸ªäººç½‘ç«™ã€‚è¿˜æœ‰å¾ˆå¤šä¸œè¥¿éœ€è¦å­¦ä¹ ï¼
- en: Please let me know if you have any comments! Feel free to connect on [LinkedIn](https://linkedin.com/in/dennisbakhuis).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ æœ‰ä»»ä½•æ„è§ï¼Œè¯·å‘Šè¯‰æˆ‘ï¼æ¬¢è¿åœ¨[LinkedIn](https://linkedin.com/in/dennisbakhuis)ä¸Šè”ç³»ã€‚
