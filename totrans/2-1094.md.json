["```py\n# Imports\nimport pandas as pd\nimport numpy as np\nimport scipy.stats as scs\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly.express as px\nfrom distfit import distfit\n```", "```py\n# Creating success ratio\ndf2c = (\n    df\n    .query('ecomm > 0 & brick_mortar > 0')\n    .assign(total_trx = df['brick_mortar'] + df['ecomm'],\n            ratio = df['ecomm']/(df['brick_mortar'] + df['ecomm'])  )         \n)\n\ndisplay(df2c)\n```", "```py\n# Looking at the distribution\npx.histogram(df2c,\n             x='ratio', nbins=20,\n             template=\"simple_white\", width = 1000,\n             title='Histogram of the Ratio Brick & Mortar vs e-Comm')\n```", "```py\n# Our distribution\nX = df2c['ratio']\n\n# Alternatively limit the search for only a few theoretical distributions.\ndfit = distfit(method='parametric', todf=True, distr=['beta'])\n\n# Fit model on input data X.\ndfit.fit_transform(X)\n\n# Print the bet model results.\ndfit.model\n--------------\n[OUT]\n[distfit] >INFO> fit\n[distfit] >INFO> transform\n[distfit] >INFO> [beta] [0.11 sec] [RSS: 0.823271] [loc=0.011 scale=0.941]\n[distfit] >INFO> Compute confidence intervals [parametric]\n{'name': 'beta',\n 'score': 0.8232713059833795,\n 'loc': 0.011363636363636362,\n 'scale': 0.9411483584238516,\n >>>'arg': (0.850939343634336, 1.4553354599535102),<<<\n 'params': (0.850939343634336,\n  1.4553354599535102,\n  0.011363636363636362,\n  0.9411483584238516),\n 'model': <scipy.stats._distn_infrastructure.rv_continuous_frozen at 0x7838c17ad570>,\n 'bootstrap_score': 0,\n 'bootstrap_pass': None,\n 'color': '#e41a1c',\n 'CII_min_alpha': 0.030238213140192628,\n 'CII_max_alpha': 0.8158034848017729}\n```", "```py\nimport matplotlib.pyplot as plt\n# Create subplot\nfig, ax = plt.subplots(1,3, figsize=(18, 7))\n# Plot PDF with histogram\ndfit.plot(chart='PDF', ax=ax[0])\n# Plot the CDF\ndfit.plot(chart='CDF', ax=ax[1]);\ndfit.qqplot(X, ax=ax[2])\n```", "```py\n# Alpha and Beta values\na,b = 0.850939343634336, 1.4553354599535102\n```", "```py\n# Calculating Bayes Estimates\ndf2c = (df2c\n        .assign(emp_bayes = (df2c['ecomm'] + a)/(df2c['total_trx'] + a + b) )\n        )\n```", "```py\n# Scatterplot\nfig = sns.scatterplot(data = df2c,\n                 x= 'ratio', y= 'emp_bayes',\n                 s=50)\n\n# Slope line\nplt.plot([0,1], [0,1], linestyle='--', color='red');\n```", "```py\n# Calculate a1 and b1\ndf2 = (df2c\n       .assign(a1 = df2c.ecomm + a,\n               b1 = df2c.total_trx - df2c.ecomm + b,)\n)\n```", "```py\n# Calculating the CI and add to the dataset\ndf2 = (df2\n          .assign( low = scs.beta.interval(.95, df2.a1, df2.b1)[0],\n                   high = scs.beta.interval(.95, df2.a1, df2.b1)[1] )\n          .sort_values('total_trx', ascending=False)\n           )\n```", "```py\n# customer ID to string for better visualization\ndf2['customer'] = df2.customer.astype('string')\n\n# Number of customers to plot\nn_cust = 100\n\n# Plot\nplt.figure(figsize=(25,7))\nplt.scatter(df2.customer[:n_cust], df2.emp_bayes[:n_cust], color='black', s=100 )\nplt.bar(df2.customer[:n_cust], df2.low[:n_cust], label='low', color='white', zorder=1 )\nplt.bar(df2.customer[:n_cust], df2.high[:n_cust], label='high', zorder=0 )\nplt.legend();\n```"]