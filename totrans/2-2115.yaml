- en: Tips and Tricks for Working with Strings in Polars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/tips-and-tricks-for-working-with-strings-in-polars-ec6bb74aeec2](https://towardsdatascience.com/tips-and-tricks-for-working-with-strings-in-polars-ec6bb74aeec2)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: From sorting column names to splitting columns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://weimenglee.medium.com/?source=post_page-----ec6bb74aeec2--------------------------------)[![Wei-Meng
    Lee](../Images/10fc13e8a6858502d6a7b89fcaad7a10.png)](https://weimenglee.medium.com/?source=post_page-----ec6bb74aeec2--------------------------------)[](https://towardsdatascience.com/?source=post_page-----ec6bb74aeec2--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----ec6bb74aeec2--------------------------------)
    [Wei-Meng Lee](https://weimenglee.medium.com/?source=post_page-----ec6bb74aeec2--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----ec6bb74aeec2--------------------------------)
    ·9 min read·Jan 17, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/dcdf237f50b5028ea8a4c18ac4d7898f.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Raphael Schaller](https://unsplash.com/@raphaelphotoch?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: In my past articles on Polars ([https://medium.com/search?q=wei-meng+lee+polars](https://medium.com/search?q=wei-meng+lee+polars)),
    I dived into how to get started with Polars, how its lazy evaluation mode allows
    you to optimize your queries and make processing large datasets efficient, as
    well as the how to use it to perform various tasks such as data cleansing, data
    analytics, and data visualization.
  prefs: []
  type: TYPE_NORMAL
- en: 'One area that I did not dive into in more details is strings processing, which
    is a very commonly topic when dealing with dataframes. In this article, I will
    run through some of the tips and techniques you can use when performing string
    processing in Polars. They are:'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting DataFrame columns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Counting length of strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting Columns Based on Headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering Rows with Regex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Splitting String Columns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing String Values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All Headers In Polars Must be String Type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we dive into the various tips and tricks, it is important to remember
    that in Polars all column headers are of string type. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/9a3525a54b857eec56756b52deab2280.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The above shows a Polars DataFrame with four columns. Note that unlike Pandas
    where column headers can be of numeric type, in Polars all column headers must
    be of string type. The following is **not** allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you really want to use numbers as column headers, you need to convert them
    to strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Sorting Columns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To sort the columns in a Polars DataFrame, first use the Python `sorted()`
    function to sort the column names and then use the `select()` function to rearrange
    the order of the columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `select()` function returns a new DataFrame with the columns rearranged:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f142bdb117c912cf02e1a4ccf5661c76.png)'
  prefs: []
  type: TYPE_IMG
- en: All images created in this article are created by the author
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The default sort order of the `sorted()` function is alphabetical. To sort
    it in reverse order, set the `reverse` parameter to `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/0b272c5380135528a2f181b0d886c548.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You might be tempted to sort using the square bracket notation (like in Pandas):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: However, this is not recommended if you are going to use the result with other
    Polars function as this approach cannot be used with lazy evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the square bracket notation if you simply want to have a glance
    of how the data looks like.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Counting the Length of Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes you need to count the length of strings in a particular column. To
    illustrate this, I have the following self-created CSV file named **names.csv**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s first load this into a Polars DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/c716d58c888417f5687d97500b4d724d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can use the `lengths()` function to get the length of each name and then
    store it in a new column named **length_of_name**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/15be3991c81149d0577cc911ba088c97.png)'
  prefs: []
  type: TYPE_IMG
- en: Selecting Columns Based on Headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In my earlier article on Polars ([https://towardsdatascience.com/getting-started-with-the-polars-dataframe-library-6f9e1c014c5c](/getting-started-with-the-polars-dataframe-library-6f9e1c014c5c)),
    I showed that you can use the `select()` function to select the columns from a
    dataframe. Let’e dive into this in more details using the Titanic dataset.
  prefs: []
  type: TYPE_NORMAL
- en: '**Source of Data**: The data source for this section is from [https://www.kaggle.com/datasets/tedllh/titanic-train](https://www.kaggle.com/datasets/tedllh/titanic-train).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Licensing —** Database Contents License (DbCL) v1.0 [https://opendatacommons.org/licenses/dbcl/1-0/](https://opendatacommons.org/licenses/dbcl/1-0/)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Loading the Titanic dataset, you see that it has 12 columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/32d935a6d0af970fe576ce373532a740.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you only want to retrieve the **Name** and **Age** columns, put them into
    a list and pass it to the `select()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/d6bfd61eee91c4ff3e242d35224b23a6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you want *all* columns except the **PassengerId** column, use the `pl.exclude()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/dd93527f024bd4ccf087b05b51f1aaca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `exclude()` function supports regular expressions. The following example
    retrieves all columns except those who name starts with “S”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/5f0f112b0db98e101402314d29eea22b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you want to retrieve specific columns, use the `pl.col()` function. The
    following example retrieves all columns with starts with “S”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/6538399c8809b03aafb983293fe5de5e.png)'
  prefs: []
  type: TYPE_IMG
- en: Filtering Rows with Regex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides the `pl.col()` function, the `contains()` function also supports regex.
    The following code snippet retrieves all rows that has the names ending with “William”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/f0f6b7df958dc7f76f9483b47f37c3e3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also try out the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[Ww]illiam`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(?i)illiam`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`^William`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can you figure out what they do?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a challenge: How do you find all the names that does *not* end with
    “William”?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you could use a regex to do that, but the easiest is to use the `is_not()`
    function to negate the condition specified in the `contains()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/e8102b7eb570b6fd9586612f29d303f5.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that Polars does not support look-around, including look-ahead and look-behind
    for regex.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Splitting String Columns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another popular activity regarding strings is column-splitting. Let’s now split
    the **name** column (in the **names.csv** file) based on the space using the `split()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is a new column named **split_name** as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/dd04a214ddf9889ddb5bfb517ff03d26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice that the names are now split into a list of strings. What you need to
    do next is to convert the list of strings into multiple columns, representing
    the first and last name. You can do so using the `with_column()` and the `pl.struct()`
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `with_column()` function returns a new DataFrame with a column updated.
    In this case, I will update the `split_name` column with a structure using the
    `pl.struct()` function, which iterates through the list of names in the **split_name**
    column. Think of the structure as a collection of columns. The updated dataframe
    now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6ef53174a109b045452f9731ce436b55.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notably, the **split_name** column is now of type `struct`. The final step
    is to use the `unnest()` function to decompose a `struct` column into individual
    columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The final result looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/264ef3b593565818bd3597919d6b341d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s now try another example using the Titanic dataset. In particular, I want
    to focus on the **Name** column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a snapshot of the unique names in the **Name** column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The names are saved in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Last Name, Title. First Name`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ideally, you can use regular expression in the `split()` function. You can
    use the following regex for splitting the **Name** column into Last Name, Title,
    and First Name:'
  prefs: []
  type: TYPE_NORMAL
- en: '`‘([\’A-Za-z ()”//.-]+), ([A-Za-z]+). ([A-Za-z ()”//.-]*)’`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This regular expression was discussed in my earlier article:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[](/feature-engineering-using-regular-expression-regex-in-pandas-dataframe-c965380316da?source=post_page-----ec6bb74aeec2--------------------------------)
    [## Feature Engineering using Regular Expression (RegEx) in Pandas DataFrame'
  prefs: []
  type: TYPE_NORMAL
- en: Discover how to manipulate your string columns easily using Regular Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/feature-engineering-using-regular-expression-regex-in-pandas-dataframe-c965380316da?source=post_page-----ec6bb74aeec2--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, at the time of writing the `split()` function in Polars does
    not support regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'So the strategy is to perform the split multiple times:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ba52331a15b5a7cb0353577658da7d49.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here’s the first split:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The result now shows that the **Last Name** is extracted, followed by the **First
    Name**, which contains the title as well as the first name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4c6e537834cb5d50f0e9eab2f1042664.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And here’s the second split:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the title is extracted from the first name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/58832fd35ba06cd7b570fb51a13c923b.png)'
  prefs: []
  type: TYPE_IMG
- en: Replacing String Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Replacing string values in your dataframe is another common task that you perform
    routinely. For the passenger names in the Titanic dataset, there are a number
    of overlapping titles that are used. For example, for female passengers, some
    titles used are Ms, Miss, Mlle, Mlle, and Mme. You would usually want to reduce
    the number of titles to a more manageable number.
  prefs: []
  type: TYPE_NORMAL
- en: 'To replace a string in a column, use the `replace()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The above code snippet replaces all occurences of “Mlle.” in the **Name** column
    with “Miss.”. If you want to replace more than one title with “Miss.”, you can
    use a regex, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The above code snippet replaces “Mlle.”, “Ms.”, and “Mme.” with “Miss.”.
  prefs: []
  type: TYPE_NORMAL
- en: If you like reading my articles and that it helped your career/study, please
    consider signing up as a Medium member. It is $5 a month, and it gives you unlimited
    access to all the articles (including mine) on Medium. If you sign up using the
    following link, I will earn a small commission (at no additional cost to you).
    Your support means that I will be able to devote more time on writing articles
    like this.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://weimenglee.medium.com/membership?source=post_page-----ec6bb74aeec2--------------------------------)
    [## Join Medium with my referral link - Wei-Meng Lee'
  prefs: []
  type: TYPE_NORMAL
- en: Read every story from Wei-Meng Lee (and thousands of other writers on Medium).
    Your membership fee directly supports…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: weimenglee.medium.com](https://weimenglee.medium.com/membership?source=post_page-----ec6bb74aeec2--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Working with strings in Polars is similar to that in Pandas. In addition, if
    you are familiar with regex, it will certainly make your life much easier. I have
    used quite a number of functions in this article and so here’s a handy guide for
    you to remember the next time you perform strings processing in Polars:'
  prefs: []
  type: TYPE_NORMAL
- en: '`select()` — select the columns that you want from the DataFrame'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`with_column()` — returns a new DataFrame with a column updated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unnest()` — decomposes a struct column into individual columns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`str.lengths()` — returns the length of the string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`str.contains()` — checks if a string contains the specified string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`str.split()` — splits a string based on the specified string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`str.replace()` — replaces a string with another string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pl.exclude()` — excludes specific columns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pl.col()` — includes specific columns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pl.struct()` — a column containing a collection of columns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
