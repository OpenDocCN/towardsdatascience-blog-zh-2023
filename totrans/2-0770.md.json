["```py\nimport pandas as pd\n\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.neighbors import KNeighborsRegressor\nfrom sklearn.linear_model import Lasso, Ridge, ElasticNetCV\n\nfrom pmdarima.datasets import load_taylor\n\n# src module available here: https://github.com/vcerqueira/blog\nfrom src.tde import time_delay_embedding\n\nseries = load_taylor(as_series=True)\nseries.index = pd.date_range(end=pd.Timestamp(day=27, month=8, year=2000), periods=len(series), freq='30min')\nseries.name = 'Series'\nseries.index.name = 'Index'\n\n# train test split\ntrain, test = train_test_split(series, test_size=0.1, shuffle=False)\n\n# ts for supervised learning\ntrain_df = time_delay_embedding(train, n_lags=10, horizon=1).dropna()\ntest_df = time_delay_embedding(test, n_lags=10, horizon=1).dropna()\n\n# creating the predictors and target variables\nX_train, y_train = train_df.drop('Series(t+1)', axis=1), train_df['Series(t+1)']\nX_test, y_test = test_df.drop('Series(t+1)', axis=1), test_df['Series(t+1)']\n\n# defining four models composing the ensemble\nmodels = {\n    'RF': RandomForestRegressor(),\n    'KNN': KNeighborsRegressor(),\n    'LASSO': Lasso(),\n    'EN': ElasticNetCV(),\n    'Ridge': Ridge(),\n}\n\n# training and getting predictions\ntest_forecasts = {}\nfor k in models:\n    models[k].fit(X_train, y_train)\n    test_forecasts[k] = models[k].predict(X_test)\n\n# predictions as pandas dataframe\nforecasts_df = pd.DataFrame(test_forecasts, index=y_test.index)\n```", "```py\nimport rpy2.robjects as ro\n\n# polynomially weighted average\nmethod = 'MLpol'\n\n# defining the R function in a Python multi-line string\nro.r(\n    \"\"\"\n    define_mixture_r <-\n      function(model) {\n        library(opera)\n\n        opera_model <- mixture(model = model, loss.type = 'square')\n\n        return(opera_model)\n      }\n    \"\"\"\n)\n\n# storing the function in the global environment\ndefine_mixture_func = ro.globalenv['define_mixture_r']\n\n# using the function\nopera_model = define_mixture_func(method)\n```", "```py\nfrom rpy2.robjects import pandas2ri\n\nro.r(\n    \"\"\"\n    update_mixture_r <-\n      function(opera_model, predictions,trues) {\n        library(opera)\n        for (i in 1:length(trues)) {\n            opera_model <- predict(opera_model, newexperts = predictions[i, ], newY = trues[i])\n        }\n        return(opera_model)\n      }\n    \"\"\"\n)\n\nupdate_mixture_func = ro.globalenv['update_mixture_r']\n# activating automatic data conversions\npandas2ri.activate()\n\n# using the function above\n## predictions is a pandas DataFrame and trues is a pandas Series\n## opera_model is a rpy2 object that represents a R data structure\nnew_opera_model = update_mixture_func(opera_model, predictions, trues)\n\n# deactivating automatic data conversions\npandas2ri.deactivate()\n```", "```py\n# https://github.com/vcerqueira/blog/blob/main/src/ensembles/opera_r.py\nfrom src.ensembles.opera_r import Opera\n\nopera = Opera('MLpol')\nopera.compute_weights(forecasts_df, y_test)\n\nensemble = (opera.weights.values * forecasts_df).sum(axis=1)\n```"]