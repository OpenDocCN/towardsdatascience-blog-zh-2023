- en: 'Mastering Modular Programming: How to Take Your Python Skills to the Next Level'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/mastering-modular-programming-how-to-take-your-python-skills-to-the-next-level-ba14339e8429](https://towardsdatascience.com/mastering-modular-programming-how-to-take-your-python-skills-to-the-next-level-ba14339e8429)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Best Practices for Writing Modular Python Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://federicotrotta.medium.com/?source=post_page-----ba14339e8429--------------------------------)[![Federico
    Trotta](../Images/e997e3a96940c16ab5071629016d82fd.png)](https://federicotrotta.medium.com/?source=post_page-----ba14339e8429--------------------------------)[](https://towardsdatascience.com/?source=post_page-----ba14339e8429--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----ba14339e8429--------------------------------)
    [Federico Trotta](https://federicotrotta.medium.com/?source=post_page-----ba14339e8429--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----ba14339e8429--------------------------------)
    ·9 min read·Apr 10, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7aee29745d7f4d3995e0b85e5c9f67d3.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by [Jeon Sang-O](https://pixabay.com/it/users/jeonsango-1594796/?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=1498954)
    on [Pixabay](https://pixabay.com/it//?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=1498954)
  prefs: []
  type: TYPE_NORMAL
- en: I recently wrote an article on [Python classes](https://medium.com/towards-data-science/python-classes-made-easy-the-definitive-guide-to-object-oriented-programming-881ed609fb6),
    where I said that classes are used as modules in Python, very often.
  prefs: []
  type: TYPE_NORMAL
- en: In this article, I’ll describe what a module is, how to use modules, and why
    you should use modules in Python.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this article, if you’ve never used a module, you’ll switch your
    mind. You’ll change your programming approach and use modules whenever you can.
    I’m sure of that.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can understand you: when I discovered modules and their power, I started
    to use them every time I can.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The only difference between me and you is that I didn’t find any complete and
    valuable resource that treated **all you need** to know about Python modules:
    this is why I’ve created this article.'
  prefs: []
  type: TYPE_NORMAL
- en: I found fragmented resources here and there. So, thanks to these and thanks
    to the advice of senior developers, after some days, I had a complete picture
    of Python modules.
  prefs: []
  type: TYPE_NORMAL
- en: After this article, I’m sure you’ll have the picture clear too and don’t need
    anything else to search to understand this topic. So, if you’re a beginner in
    Python, or if you’re a “navigate” Pythonista but never developed with modules,
    then this article is definitely for you.
  prefs: []
  type: TYPE_NORMAL
- en: Why you should modularize your Python code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, let’s start our discussion with some reasons why you should use
    modules in Python. I found 6:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Better code organization**. Modules allow developers to organize their code
    into reusable units; these can be imported and used in other programs. This means
    that you shouldn’t think anymore about your Python application as a whole program
    where you write all your code. You’ll have a main file where you load and use
    the modules. We’ll see the idea in a practical way in the next paragraphs.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Code reusability**. This is one of the advantages of modules: you create
    an independent program that can be imported and reused in other programs. Maybe,
    with slight changes; but often, you can use it as is. This helps us save a lot
    of time and the amount of code written: writing similar code occurs more often
    than you think.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Namespace management**. If you''ve ever coded in any language, you’ve faced
    several moments where you have to name variables. Well, as the code grows into
    your application, you may need to write variables with similar names. Modularity
    helps us fix names so that we don’t have to recreate the wheel each time because
    we’ll use names created in our modules even in our main file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Collaboration**. When working on a firm or when collaborating with friends
    on distributed projects (especially using Git), modularity allows us to work independently
    on modules. This way we can avoid overlapping problems in the same file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Easier debugging**. If you’ve debugged a 200 lines application you know how
    painful it is. Finding an error where you have tens of lines of code can need
    days. Modularity avoids all this pain because the modules are independent of each
    other. They represent small programs, so we can debug them easier than a monolith
    application.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Performance optimization**. Modules can optimize the performance of your
    machine because we can import only the code we need in the particular application
    we are developing.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are modules in Python?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As [1] says: “*By module, in Python, we intend packages and libraries, but
    even any piece of code that is separable from other code and that can work on
    its own”*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, basically, every Python program is a module because it can work on its
    own. But this doesn’t mean we can import all modules. Or, better: this doesn’t
    mean it always makes sense to import a module into another file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say you want to create a Python file that checks if three folders
    exist. If not, it creates them. It can be something like that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This file can be saved as `folders.py` and run. It works on its own, and so
    is a module. But let me ask you a question: does it make sense to import it into
    another Python file?'
  prefs: []
  type: TYPE_NORMAL
- en: Stop reading for a moment and answer this question.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, the answer is no, and for a simple reason: it’s too specific. I mean:
    if you ever need to recreate these three folders into another folder, you can
    move the file into the new folder and run it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, when we import modules what we want is generality. This is why we create
    classes and functions as modules: because they’re general. If you want to reuse
    the above module in other files, you have to generalize it. For example, we can
    create a function like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'So, this function can be useful to check if, in a specific folder, there are
    three general folders. But this time, the names can be any because they are passed
    as arguments of the function. Then, if they do not exist, they are created. So,
    for example, we can invoke it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: And then our function checks if “audio”, “image” and “documents” exist as folders
    in the directory where your Python file is. If not, it creates them.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code makes sense to be imported into another Python file because is general:
    wherever we may need to check for three folders, we can use it. We just need to
    declare the name of the three folders.'
  prefs: []
  type: TYPE_NORMAL
- en: How to use modules in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Schematically, modules work like that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/64d582ba1b9dd824fd71bafc7de85593.png)'
  prefs: []
  type: TYPE_IMG
- en: How modules work schematically. Image by Author.
  prefs: []
  type: TYPE_NORMAL
- en: We have a “principal” Python file that usually can be called `main.py`. In that
    Python file, we import two modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Maybe you didn’t notice, but in the above code, we have imported `os` that
    is a Python module that helps create, manage, and remove directories. This means
    that, when managing directories, we don’t need to create our custom functions
    (or classes): we can use the `os` module and apply it to our specific cases. For
    example, we have used `os.makedirs` that creates folders.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But apart from known modules and packages, how can we use modularity in Python
    in our everyday programming activities? Well, if you’ve never used the power of
    modularity, you’ll have to “switch” your mind; but believe me: it’s worth it!'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t use modules, your Python applications look something like that
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8a41ae08b68f7b7e1c62481ffd3000f8.png)'
  prefs: []
  type: TYPE_IMG
- en: A monolith Python application. Image by Author.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in one file you:'
  prefs: []
  type: TYPE_NORMAL
- en: Create functions and classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoke the function and classes created with variables or whatever you may need.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instead, if you use modules, your Python application becomes something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1450b35cf5692b0d77caa10d15d31fe5.png)'
  prefs: []
  type: TYPE_IMG
- en: A modularized Python application. Image by Author.
  prefs: []
  type: TYPE_NORMAL
- en: So, this way, you create two functions and two classes in separate Python files
    — that are modules. Then, you import them into the main file.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, your folder organization should be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you can create how many `packages` subfolders you may need.
  prefs: []
  type: TYPE_NORMAL
- en: The important thing is that in each subfolder there must be an `__init__.py`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what it is, and how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: A practical example in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, let’s make a practical Python example. Let''s create a project called `my_project`
    where we have:'
  prefs: []
  type: TYPE_NORMAL
- en: A `main.py` file that is our main file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A subfolder called `operations`, where we’ll have three Python files: `__init__.py`,
    `addition.py`, `subtraction.py`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, this is our structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We want to create two simple modules that will make the sum and the difference
    of two integers. If the input is not an integer, the program will return an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the two modules can be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'and this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we’d like to import these two modules into our main file. To do so, we
    have to write the following in the `__init__.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: So, the `__init__.py` is a Python file that is necessary to use when we work
    with modules because, somehow, it tells the main file that in the folder `operations`
    there are some packages to import. So, in the `__init__.py`, we have to declare
    all the functions that are in the packages, as shown above.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the `main.py` can be programmed, for example, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'So, a couple of considerations on the main file:'
  prefs: []
  type: TYPE_NORMAL
- en: As the modules contain just one function each, we could write `from operations.addition
    import *`. Anyway, is a good practice to import just the functions and the classes
    we use from a module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we can see, the main file is very clean. It just has the imports, the declaration
    of the variables using the imported methods, and the print of the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Final tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'My advice, which is taken from seniors, is to create a class for each module
    because it’s more maintainable. However, this is not a must: it depends on what
    you are coding.'
  prefs: []
  type: TYPE_NORMAL
- en: In the above example, I created two separate modules containing one function
    each. One alternative would be to create a class called, for example, `Operations`
    and to code the two functions as its method.
  prefs: []
  type: TYPE_NORMAL
- en: This would be helpful because we’d create “similar functions” in just one file
    and make one import in the main file.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, don’t always take advice as a must: take them, but reason on what you need
    to create, having in mind the optimization you need.'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, tell me: how excited are you by this methodology? Well, when I clarified
    my mind on modules I started applying them to my daily work, and, believe me,
    it only got better.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, I hope I have clarified this topic to you; and if I didn’t, please: let
    me know in the comment. I can create other articles as a corollary to that one.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Subscribe to* [*my Substack newsletter*](https://federicotrotta.substack.com/?r=1ep1nf&utm_campaign=pub-share-checklist)
    *to get more on Python.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Join Medium through* [***my referral link***](https://federicotrotta.medium.com/membership)*:
    unlock all the content on Medium for 5$/month (with no additional fee).*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Find/contact me here:* [*https://bio.link/federicotrotta*](https://bio.link/federicotrotta)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Found it useful?* ***Buy me a*** [***Ko-fi***](https://ko-fi.com/federicotrotta)***.***'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*More from me:*'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/python-classes-made-easy-the-definitive-guide-to-object-oriented-programming-881ed609fb6?source=post_page-----ba14339e8429--------------------------------)
    [## Python Classes Made Easy: The Definitive Guide to Object-Oriented Programming'
  prefs: []
  type: TYPE_NORMAL
- en: Boost your Python skills with this comprehensive class reference
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'towardsdatascience.com](/python-classes-made-easy-the-definitive-guide-to-object-oriented-programming-881ed609fb6?source=post_page-----ba14339e8429--------------------------------)
    [](/python-loops-a-complete-guide-on-how-to-iterate-in-python-b29e0d12211d?source=post_page-----ba14339e8429--------------------------------)
    [## Python Loops: A Complete Guide On How To Iterate in Python'
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging the power of loops in Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/python-loops-a-complete-guide-on-how-to-iterate-in-python-b29e0d12211d?source=post_page-----ba14339e8429--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: '*Videography:*'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] If __name__ == “__main__” for Python Developers ([video](https://www.youtube.com/watch?v=NB5LGzmSiCs))'
  prefs: []
  type: TYPE_NORMAL
