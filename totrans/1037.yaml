- en: Having Trouble Understanding Quantum Machine Learning?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://towardsdatascience.com/having-trouble-understanding-quantum-machine-learning-ce8a941d8c70](https://towardsdatascience.com/having-trouble-understanding-quantum-machine-learning-ce8a941d8c70)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Implementing the Quantum Approximate Optimization Algorithm using functional
    programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://pyqml.medium.com/?source=post_page-----ce8a941d8c70--------------------------------)[![Frank
    Zickert | Quantum Machine Learning](../Images/ae361c0d68d13dac21bb86c7496d2917.png)](https://pyqml.medium.com/?source=post_page-----ce8a941d8c70--------------------------------)[](https://towardsdatascience.com/?source=post_page-----ce8a941d8c70--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----ce8a941d8c70--------------------------------)
    [Frank Zickert | Quantum Machine Learning](https://pyqml.medium.com/?source=post_page-----ce8a941d8c70--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ¬∑Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----ce8a941d8c70--------------------------------)
    ¬∑7 min read¬∑Mar 2, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: Do you want to get started with Quantum Machine Learning? Have a look at [**Hands-On
    Quantum Machine Learning With Python**](https://www.pyqml.com/volume1?provider=medium&origin=troubleunderstanding)**.**
  prefs: []
  type: TYPE_NORMAL
- en: This article will explain the most important parts of the Quantum Approximate
    Optimization Algorithm (QAOA). QAOA is a machine learning algorithm that you can
    use to solve combinatorial optimization problems.
  prefs: []
  type: TYPE_NORMAL
- en: The special thing is this algorithm caters to the specificities of quantum computers
    ‚Äî a new kind of computer that promises exponential speedups in problem-solving.
  prefs: []
  type: TYPE_NORMAL
- en: Even though quantum machine learning (QML) ‚Äî that is, using quantum computing
    to solve machine learning algorithms ‚Äî is one of the most promising technologies,
    **it is as challenging!**
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, this article aims to explain the concepts underlying QAOA in an accessible
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum computing, optimization, and machine learning rely heavily on mathematics.
    Unless you‚Äôre a mathematician, it will be a daunting endeavor.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, some QML libraries, such as IBM Qiskit, solve this problem. They
    provide easy-to-use interfaces and hide all the complexity from you.
  prefs: []
  type: TYPE_NORMAL
- en: As I showed in [my previous post](https://medium.com/@pyqml/quantum-wildfire-fighting-e828497b7b89),
    they even take care of the problem formulation.
  prefs: []
  type: TYPE_NORMAL
- en: In that post, I used the **Quantum Approximate Optimization Algorithm** (QAOA)
    to solve a combinatorial optimization problem ‚Äî how to respond to wildfires.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/de8c69995f2f0c7f748fdc4cd94a6927.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by the author using Stable Diffusion
  prefs: []
  type: TYPE_NORMAL
- en: The only thing you have to do is to specify the individual values of your problem.
  prefs: []
  type: TYPE_NORMAL
- en: It is too good to be true, no?
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/62d3fb053da8cc4693d4388f3321913d.png)'
  prefs: []
  type: TYPE_IMG
- en: Even though these libraries let you use quantum machine learning without bothering
    about math, quantum mechanics, or anything complicated, they likewise do not teach
    you much.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to understand how an algorithm works, you‚Äôre right back to where
    you started. If the Qiskit library is that good, why don‚Äôt you look at their examples
    to understand how the QAOA works?
  prefs: []
  type: TYPE_NORMAL
- en: The following figure depicts an excerpt of their example.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e4b744e73e5e0faef07b00748930ba71.png)'
  prefs: []
  type: TYPE_IMG
- en: Taken from the [Qiskit documentation](https://qiskit.org/textbook/ch-applications/qaoa.html)
  prefs: []
  type: TYPE_NORMAL
- en: I think there‚Äôs not much to add, is there?
  prefs: []
  type: TYPE_NORMAL
- en: ‚Ä¶
  prefs: []
  type: TYPE_NORMAL
- en: A little, perhaps.
  prefs: []
  type: TYPE_NORMAL
- en: So, let me offer you an alternative explanation. One that does not ask for a
    math degree. But one that exploits the expressiveness of functional programming
    (in Python).
  prefs: []
  type: TYPE_NORMAL
- en: The story of functional programming is quickly told.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming breaks down an application into a set of functions. Ideally,
    functions only take inputs and produce outputs and have no internal state that
    affects the output produced for a given input.
  prefs: []
  type: TYPE_NORMAL
- en: In that sense, the QAOA algorithm is a function that solves a `problem` by `optimize`ing
    a set of `params`. In other words, we aim to find the best values for these `params`.
  prefs: []
  type: TYPE_NORMAL
- en: To decide which `params` are best, we `assess` them based on the result we obtain
    from `compute` ing a (quantum) `circuit` that uses these `params` to encode the
    problem (`problem_circuit`) and its solution (`ansatz_circuit`).
  prefs: []
  type: TYPE_NORMAL
- en: This is what Qiskit‚Äôs description refers to as a **variational algorithm.**
    It uses a classical optimization algorithm that makes queries to a quantum computer.
  prefs: []
  type: TYPE_NORMAL
- en: And this is the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Pretty neat, isn‚Äôt it?
  prefs: []
  type: TYPE_NORMAL
- en: Let‚Äôs proceed to the innermost function, `to_circuit`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This function takes the `problem` and the `params`. We use the size of the `problem`
    to determine the number of quantum bits (qubits) in our quantum circuit.
  prefs: []
  type: TYPE_NORMAL
- en: A qubit is the basic unit of computation in a quantum computer. Even though
    its internal state is pretty complicated, when you look at it, it is either 0
    or 1 ‚Äî just like a regular bit.
  prefs: []
  type: TYPE_NORMAL
- en: We start with applying the Hadamard gate (`h`) to all qubits. This puts the
    qubits into a state where they are equally likely to result in 0 and 1.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we append two sub-circuits using the functions `problem_circuit` and `ansatz_circuit`.
    This is what Qiskit‚Äôs explanation refers to as *‚Äúthe unitary U(Œ≤,Œ≥) has a specific
    form and is composed of two unitaries U(Œ≤) and U(Œ≥)...‚Äù*
  prefs: []
  type: TYPE_NORMAL
- en: The first function `problem_circuit` adds a quantum circuit representing the
    problem we aim to solve.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we loop through all `relations` in our `problem`. Apparently,
    we expect a `relation` to consist of a pair of integer values (`i, j`). We apply
    the `rzz` gate on the two qubits at these positions. The `rzz` gate is a parameterized
    (by parameter `gamma`) rotation around the ZZ-axis of a two-qubit system.
  prefs: []
  type: TYPE_NORMAL
- en: The second function `ansatz_circuit` adds a quantum circuit representing the
    solution to our problem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This time, we loop through all parts of our problem and apply the `rx` gate
    on the respective qubit. This is a parameterized (by parameter `beta`) rotation
    around the X-axis of a qubit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Essentially, these circuits use the two `params` (called `beta` and `gamma`)
    to create a quantum circuit that produces a particular quantum state that Qiskit
    describes vividly as **|ùúì(ùõΩ,ùõæ)‚ü©**. Here, ùúì (‚Äúpsi‚Äù) is a placeholder for a quantum
    state. ùõΩ and ùõæ are the parameters that define this state.
  prefs: []
  type: TYPE_NORMAL
- en: This quantum circuit creates a state that could result in any value, good or
    bad. Of course, we would prefer to create meaningful results. Therefore, we need
    a measure of ‚Äúgoodness.‚Äù That‚Äôs the purpose of the `assess` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Given our `problem`, we calculate the `performance` of a result that we obtained
    from executing the quantum circuit. We look at the `relations` inside the `problem`
    definition and decrease (note lower is better here) the performance if the qubits
    representing this `relation` are not equal (`solution[i] != solution[j]`). Remember,
    a qubit either results in 0 or 1\. So, `solution[i]` and `solution[j]` are either
    0 or 1.
  prefs: []
  type: TYPE_NORMAL
- en: Now, with the ability to create circuits and assess their results, we can feed
    a classical optimization algorithm. This algorithm repeatedly evaluates different
    values and their results, based on which it moves towards values that promise
    better results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'So, let‚Äôs look at the structure of the problem. We used two characteristics
    of it: `size` and `relations`. So, let‚Äôs create a `class` to hold these data.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we need to formulate the instance of our problem and feed it into the
    `qaoa` algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We define the problem to consist of three nodes (`0, 1, 2`) and a couple of
    relations. The nodes `0, 1` and `1, 2` are connected. The following listing denotes
    the output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `nfev` denotes the number of iterations. And most importantly, `x` represents
    the `params` values that produced the best results.
  prefs: []
  type: TYPE_NORMAL
- en: To see what these values mean, we feed these values back into the circuit and
    look at the result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/3a6ff4cbb0e450f344ca2432af9e16e4.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: 'The output shows that two solutions occur more frequently: `010` and `101`.
    So, these denote the solution to the problem specified.'
  prefs: []
  type: TYPE_NORMAL
- en: When we look back into `assess` function, we see that we value each `relation`
    as `-1` if the two connected nodes have different values. Further, we defined
    `0, 1` and `1, 2` to be connected.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, the best solutions are those where these connected nodes have different
    values. And these are `010` and `101`.
  prefs: []
  type: TYPE_NORMAL
- en: This problem is known as Max-Cut. It is the same problem solved in Qiskit‚Äôs
    example and could be considered the ‚ÄúHello World‚Äù of combinatorial optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This post explains the essential parts of the Quantum Approximate Optimization
    Algorithm (QAOA). Even though it is neither the first nor the only explanation,
    it does not require you to study mathematics first.
  prefs: []
  type: TYPE_NORMAL
- en: A non-mathematical explanation has quite a few advantages.
  prefs: []
  type: TYPE_NORMAL
- en: It is much more accessible to most of us.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is hands-on. We directly solved a problem with it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see how the parts of the algorithm fit together.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you want to get started with Quantum Machine Learning? Have a look at [**Hands-On
    Quantum Machine Learning With Python**](https://www.pyqml.com/volume1?provider=medium&origin=troubleunderstanding)**.**
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c3892c668b9d47f57e47f1e6d80af7b6.png)'
  prefs: []
  type: TYPE_IMG
- en: Get the first three chapters [for free](https://www.pyqml.com/volume1?provider=medium&origin=troubleunderstanding).
  prefs: []
  type: TYPE_NORMAL
- en: 'The brand-new **Volume 2: Combinatorial Optimization** is all about how to
    solve optimization problems using the Variational Quantum Eigensolver and the
    **Quantum Approximate Optimization Algorithm**.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Claim your copy now](https://www.pyqml.com/volume2?provider=medium&origin=troubleunderstanding).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/301b7c95ad0fe4b0dcbb7e3cf0fdc708.png)'
  prefs: []
  type: TYPE_IMG
