- en: Demystifying Dependence and Why it Is Important in Causal Inference and Causal
    Validation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/demystifying-dependence-and-why-it-is-important-in-causal-inference-and-causal-validation-4263b18d5f04](https://towardsdatascience.com/demystifying-dependence-and-why-it-is-important-in-causal-inference-and-causal-validation-4263b18d5f04)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A step-by-step guide in understanding the concept of dependence and how to apply
    it to validate directed acyclic graphs using Python
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://grahamharrison-86487.medium.com/?source=post_page-----4263b18d5f04--------------------------------)[![Graham
    Harrison](../Images/c6bfe00c6e0cfcdf3bd042c7fdc03554.png)](https://grahamharrison-86487.medium.com/?source=post_page-----4263b18d5f04--------------------------------)[](https://towardsdatascience.com/?source=post_page-----4263b18d5f04--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----4263b18d5f04--------------------------------)
    [Graham Harrison](https://grahamharrison-86487.medium.com/?source=post_page-----4263b18d5f04--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----4263b18d5f04--------------------------------)
    ·16 min read·Nov 11, 2023
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2acee73c46470784e1400ed88bbbe08b.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
- en: Photo by [Ana Municio](https://unsplash.com/@lamunix?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash)
    on [Unsplash](https://unsplash.com/photos/gray-and-brown-stones-on-gray-ground-PbzntH58GLQ?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Causal Inference is an emergent branch of data science concerned with determining
    the cause-and-effect relationship between events and outcomes and it has the potential
    to significantly add to the value that machine learning can generate for organisations.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: For example, a traditional machine learning algorithm can predict which loan
    customers are likely to default thereby enabling proactive intervention with customers.
    However, although this algorithm will be useful to reduce loan defaults, it will
    have no concept of why they occurred and whilst pro-active intervention is useful
    knowing the reasons for defaults would enable the underlying cause to be addressed.
    In this world pro-active intervention may no longer be necessary because the factors
    that lead to defaulting have been permanently cured.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: This is the promise of Causal Inference and why it has the potential to deliver
    significant impact and outcomes to those organisations that can harness that potential.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of different approaches but the most common approach typically
    starts by augmenting the data with a “Directed Acyclic Graph” which encapsulates
    and visualises the causal relationships in the data and then uses causal inference
    techniques to ask “what-if” type questions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: The Problem
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Directed Acyclic Graph (DAG) that encapsulates the causal relationships in
    the data is typically constructed manually (or semi-manually) by data scientists
    and domain experts working together. Hence the DAG could be wrong which would
    invalidate any causal calculations leading to flawed conclusions and potentially
    incorrect decisions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: The Opportunity
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A range of techniques exist for “Causal Validation” (the process of validating
    the DAG against the data) and if these techniques work they can minimise or eliminate
    errors in the DAG thereby ensuring that the calculations and conclusions are error-free.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: The Way Forward
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The statistical concept of dependence between random variables can be used to
    ascertain whether a relationship that exists in the DAG also exists in the data;
    if it does exist the DAG is more likely to be correct and if not it is more likely
    to be incorrect.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to need an example DAG to work through the problem which has enough
    nodes and links to enable a deep exploration of causal validation …
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/cd401cc91ab871411a3df74e01fef9cc.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
- en: Example DAG that will be used throughout the article — Image by Author
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Each node in a DAG is either having a causal effect on other node(s) or other
    node(s) are having a causal effect on it and the direction of the arrow is the
    direction of the causal effect. For example, one of the causes of “B” is “C” and
    one of the causes of “C” is “F”.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: The example DAG is fictitious hence the node letters / names are unimportant,
    however “X” is intended to be the “treatment”, “Y” is the “effect,” and all the
    other nodes are having some causal impact that would, in a real-world example,
    obscure the true effects of X on Y.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Note that the light-blue nodes have no inputs (exogenous in causal terminology)
    and the dark-blue nodes have one or more inputs (endogenous in the terminology).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: To get started we will also need some data that matches the DAG. The dataset
    below is entirely synthetic and has been generated by the author. It exactly encapsulates
    and matches the structure suggested by the DAG and contains no erroneous or faulty
    relationships …
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/23142b03ead0c51efecb36617405554e.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
- en: Synthetic, fictitious dataset that is associated with the DAG — Image by Author
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Another thing we need before we can get started is a way of extending the pandas
    `DataFrame` and `Series` classes with custom methods so that the code we write
    is clean, concise and easy to understand.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Here is a link to one of my previous articles that provides an end-to-end tutorial
    on how to extend data frames and why it is a useful thing to do …
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[](/how-to-extend-pandas-dataframes-with-custom-methods-to-supercharge-code-functionality-readability-f4ae983ad715?source=post_page-----4263b18d5f04--------------------------------)
    [## How to Extend Pandas DataFrames with Custom Methods to Supercharge Code Functionality
    & Readability'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: A step-by-step guide to extending pandas DataFrames with custom methods including
    full examples for implementing…
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个逐步指南，介绍如何通过自定义方法扩展 pandas DataFrames，包括实施的完整示例 …
- en: towardsdatascience.com](/how-to-extend-pandas-dataframes-with-custom-methods-to-supercharge-code-functionality-readability-f4ae983ad715?source=post_page-----4263b18d5f04--------------------------------)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[towardsdatascience.com](/how-to-extend-pandas-dataframes-with-custom-methods-to-supercharge-code-functionality-readability-f4ae983ad715?source=post_page-----4263b18d5f04--------------------------------)'
- en: Understanding Dependence
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解依赖性
- en: One definition of dependence is as follows …
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖性的一个定义如下 …
- en: Dependence between two random variables means that the occurrence or value of
    one variable affects the occurrence or value of the other. Variables are considered
    dependent if the occurrence or value of one variable provides information about
    the occurrence or value of the other variable.
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 两个随机变量之间的依赖性意味着一个变量的发生或值会影响另一个变量的发生或值。如果一个变量的发生或值提供了关于另一个变量的发生或值的信息，则这两个变量被认为是相关的。
- en: To unpack this, let’s take another look at our example DAG and consider the
    causal factors that affect node Y …
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了深入了解这一点，让我们再看一下我们的示例 DAG，并考虑影响节点 Y 的因果因素 …
- en: '![](../Images/290380d5018508aeb10f34dcc346a75b.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/290380d5018508aeb10f34dcc346a75b.png)'
- en: DAG with causal factors affecting Y highlighted — Image by Author
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 突出显示影响 Y 的因果因素的 DAG — 作者提供的图片
- en: In this visualisation we can see that node Y is caused by (and hence dependent
    on) 5 different factors — C , E , F , G and X.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个可视化中，我们可以看到节点 Y 是由 5 个不同因素造成的（因此也依赖于这些因素） — C、E、F、G 和 X。
- en: Now lets take another look at the data that the DAG is representing …
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们再看一下 DAG 所表示的数据 …
- en: '![](../Images/a87ef178b3188e067c9b179e369a2885.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a87ef178b3188e067c9b179e369a2885.png)'
- en: Review of the first 5 rows of data from the df_causal DataFrame — Image by Author
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: df_causal DataFrame 中前 5 行数据的回顾 — 作者提供的图片
- en: This synthetic data set was created by the author to facilitate the article
    so I happen to know that the relationship between node Y and those dependent factors
    is as follows …
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个合成数据集是作者为方便本文创建的，所以我知道节点 Y 与这些依赖因素之间的关系如下 …
- en: '**Y = 3C + 3E + 2F + 2.5G + 1.5X + ε**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**Y = 3C + 3E + 2F + 2.5G + 1.5X + ε**'
- en: '(Note: ε represents the error term)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: （注：ε 代表误差项）
- en: … and this can be tested and verified by picking a row (in this case I have
    chosen the 3rd row) applying that formula to the data …
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: … 这一点可以通过选择一行（在这种情况下，我选择了第 3 行）并将该公式应用于数据来测试和验证 …
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can now see why and how Y is dependent on C, E, F, G and X. If the value
    of one of those dependent variables changes, the value of Y will also change.
    We can also see from the DAG that Y should not be dependent (for example) on node
    D because there is no link between D and Y.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到 Y 如何以及为何依赖于 C、E、F、G 和 X。如果这些依赖变量中的一个值发生变化，Y 的值也会变化。我们还可以从 DAG 中看到 Y
    不应依赖（例如）节点 D，因为 D 和 Y 之间没有连接。
- en: The statement “Y is dependent on C, E, F, G and X” can be represented in a mathematical
    formula as follows …
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: “Y 依赖于 C、E、F、G 和 X” 的表述可以用数学公式表示如下 …
- en: '![](../Images/a94fa5224968e1d531aa8cde4caa2c17.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a94fa5224968e1d531aa8cde4caa2c17.png)'
- en: Image by Author
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 作者提供的图片
- en: … and the statement “Y is independent of D” is represented as follows …
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: … 以及“Y 与 D 独立” 的表述如下 …
- en: '![](../Images/04b9fcfec170531347cc5aa88c9d4409.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04b9fcfec170531347cc5aa88c9d4409.png)'
- en: Image by Author
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 作者提供的图片
- en: The ⫫ symbol is called a “double up-tack” but the ⫫̸ symbol does not have a
    commonly accepted name so I have adopted “slashed double up-tack” through personal
    preference.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ⫫ 符号被称为“双向交叉符号”，但 ⫫̸ 符号没有一个普遍接受的名称，所以我个人习惯称之为“斜杠双向交叉符号”。
- en: Some articles and texts use a single up-tack (⊥ and ⊥̸) instead of double up-tacks
    but double up-tacks are more common hence that is the standard that I have adopted
    and used throughout this article and the associated Python code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一些文章和文本使用单向交叉符号（⊥ 和 ⊥̸）代替双向交叉符号，但双向交叉符号更为常见，因此这是我在本文及相关 Python 代码中采用的标准。
- en: To recap then, statistical dependence between two random variables means that
    “the occurrence or value of one variable affects the occurrence or value of the
    other” and we now know how this looks visually in the DAG, how to represent it
    as a mathematical formula (e.g. **Y = 3C + 3E + 2F + 2.5G + 1.5X + ε**) and also
    how to represent it using the slashed double up-tack notation (e.g. Y ⫫̸ C, E,
    F, G, X).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，两个随机变量之间的统计依赖意味着“一个变量的发生或数值影响另一个变量的发生或数值”，我们现在知道这在DAG中是如何可视化的，如何用数学公式表示（例如**Y
    = 3C + 3E + 2F + 2.5G + 1.5X + ε**），以及如何用斜杠双向箭头符号表示（例如Y ⫫̸ C、E、F、G、X）。
- en: From Dependence to Causal Validation
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从依赖关系到因果验证
- en: Causal Inference typically starts with a set of data and then augments that
    data with a DAG. There are emerging techniques that can reverse engineer a DAG
    from the data but they are not accurate or consistent hence the most common approach
    to developing a DAG is to ask the domain experts what they think the causal relationships
    are and then to validate or test that DAG against the data and amend it as necessary
    if validation fails.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因果推断通常从一组数据开始，然后用DAG扩充这些数据。虽然有些新兴技术可以从数据中反向工程生成DAG，但它们并不准确或一致，因此开发DAG的最常见方法是询问领域专家他们认为的因果关系，然后验证或测试该DAG是否符合数据，并在验证失败时进行必要的修正。
- en: The DAG has proposed that Y is dependent on C, E, F, G and X and if this dependency
    exists in the data then there will be confidence that the causal links pointing
    into node Y are valid and correct and there is a mathematical notation that can
    be used to represent this as follows …
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: DAG已经提出Y依赖于C、E、F、G和X，如果这种依赖在数据中存在，那么可以确信指向节点Y的因果链接是有效和正确的，并且可以用如下数学符号表示……
- en: '![](../Images/7d1be63d07a51c7371b0adc52771cd4a.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7d1be63d07a51c7371b0adc52771cd4a.png)'
- en: Image by Author
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由作者提供
- en: This scary-looking formula is actually very simple to understand. The “G” subscript
    of the first slashed double up-tack dependency symbol means “in the graph” (i.e.
    the DAG) and the second “D” subscript means “in the data” (note that I have seen
    a “P” subscript in some of the literature but “D” makes more sense to me so that
    is what I have adopted).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个看起来吓人的公式其实非常容易理解。第一个斜杠双向箭头符号的“G”下标表示“在图中”（即DAG），而第二个“D”下标表示“在数据中”（注意，我见过一些文献中使用“P”下标，但“D”对我来说更有意义，因此我采用了“D”）。
- en: Armed with that knowledge, the whole formula can be read as “If Y is dependent
    on C, E, F, G and X in the graph then Y should also be dependent on C, E, F, G
    and X in the data.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 具备这些知识后，整个公式可以被解读为“如果图中的Y依赖于C、E、F、G和X，那么Y在数据中也应该依赖于C、E、F、G和X”。
- en: It follows then that we just need a mechanism in Python that can detect dependencies
    in the data. That mechanism can then be used to check each node in the DAG that
    has in-coming connections and if dependencies are detected in the data that match
    those in the DAG we can be reasonably confident that there are no spurious connections
    (causal links) and that the DAG is a valid representation of the data in this
    respect.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们只需要一个Python机制来检测数据中的依赖关系。然后可以使用该机制检查DAG中具有传入连接的每个节点，如果在数据中检测到的依赖关系与DAG中的匹配，我们可以合理地确信没有虚假的连接（因果链接），并且DAG在这方面是数据的有效表示。
- en: Observing Dependence in the Data
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察数据中的依赖关系
- en: Let’s start by visualising the relationships that exist in the data between
    C, E, F, G and X and our node of interest Y …
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始可视化数据中C、E、F、G和X与我们关注的节点Y之间的关系……
- en: '![](../Images/5f5c35ed6754ce4e6677ada75543ef7f.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5f5c35ed6754ce4e6677ada75543ef7f.png)'
- en: Image by Author
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由作者提供
- en: The chart on the right is plotting Y on the x axis and separate lines for C,
    E, F, G and X on the y axis. If Y is dependent on these other variables then changing
    the value of one of them should change the value of Y. This means that there should
    be a positive or negative co-efficient and the lines should exhibit a noticeable
    slope (either upwards or downwards).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧的图表将Y绘制在x轴上，将C、E、F、G和X分别绘制在y轴上。如果Y依赖于这些其他变量，那么改变其中一个变量的值应该会改变Y的值。这意味着应该存在一个正或负的系数，并且这些线应该表现出明显的斜率（向上或向下）。
- en: Given that there are definite slopes we can see that 𝑌⫫̸ 𝐶,𝐸,𝐹,𝐺,𝑋 is true i.e.
    that Y is dependent on C, E, F, G and X **in the data**.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在明确的斜率，我们可以看到𝑌⫫̸ 𝐶,𝐸,𝐹,𝐺,𝑋是正确的，即Y在数据中依赖于C、E、F、G和X**。
- en: If however there is no dependence then changing the value of a variable would
    have little or no effect on Y, the co-efficient should be close to zero and the
    line should have no slope i.e. it should be flat.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: This can be demonstrated by adding the relationship between Y and D to the chart
    remembering that there is no causal link from D to Y in the DAG so there should
    be no relationship between Y and D in the data either …
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/29419ca82d443e6ace8f4bfb53ad7158.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: This is looking exactly how we would expect it. C, E, F, G and X all have clear
    slopes and either a negative or positive co-efficient clearly showing that if
    the value of those variables changes, the value of Y will be changed so Y is dependent
    on those variables.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: However the slope for D is flat and the co-efficient is very small (just -0.029)
    so changing the value of D will have a negligible effect on the value of Y and
    hence the causal relationship 𝑌⫫𝐷 (Y is independent of D) exists in the data.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Dependency in the Data in Python
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The proposed method for detecting dependencies in the data uses the ols class
    from the statsmodels.formula.api library to perform an ordinary least squares
    (OLS) regression.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: The ols class can be fitted to a data set and the the coefficients or slopes
    that exist in the data can be extracted and interpreted. Here is how it is done
    …
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b7e7c7a721ec0164576975dd169b8a0b.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: The key data in the summary is the middle table which provides some analysis
    of the variables C, E, F, G and X in respect of their relationship with Y. For
    example the ols analysis is proposing the following -
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 𝑌=2.03𝐶+3.02𝐸+1.84𝐹+6.33𝐺+1.54𝑋−25.2
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: and this is not too far away from the formula that I used to create the dataset
    which was …
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 𝑌=3𝐶+3𝐸+2𝐹+2.5𝐺+1.5𝑋+ε
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: The biggest difference is for node G but for the purposes of validation the
    magnitude of the co-efficient is not really important, just that a coefficient
    exists and that the slope is not flat.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the `coef` column the other item of interest is the `P>|t|` or p-value
    column which works as follows ...
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: The null hypothesis is that there is no relationship between the variable (e.g.
    E) and the dependent variable (e.g. Y)
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the p-value is greater than the alpha (usually set at 0.05) then the null
    hypothesis is rejected i.e. there is a relationship i.e. there is dependence.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For example the p-values for E, G and X are all below 0.05 so the null hypothesis
    can be rejected and dependence can be assumed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: But what about C ad F? C has a p-value of 0.076 which is slightly above alpha
    and F has a value if 0.275 which is significantly above our chosen alpha (0.05).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: We could just increase alpha until we conclude that all of the variables are
    dependent but that approach will not work very well in the long run as it will
    start concluding dependence where none exists.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: When I did the original development I almost gave up at this point assuming
    that ols could not be used as a reliable method to detect dependence across my
    DAGs and data but then I took another look at the ols analysis.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我进行最初开发时，我几乎在这一点上放弃了，认为ols不能作为检测我的DAG和数据中依赖关系的可靠方法，但随后我重新审视了ols分析。
- en: A co-efficient can be observed for all 5 variables, but the p-value is conclusive
    in only 3 out of the 5\. I then swapped to using the `coef` but further on down
    the line I found instances where the p-value worked but the `coef` did not.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对所有5个变量可以观察到系数，但p值仅在5个中的3个上具有决定性。我随后转而使用`coef`，但在后续的过程中，我发现p值有效而`coef`无效的情况。
- en: After many frustrating hours and a lot of trial-and-error I came established
    a method which uses both values and that exhibits a high degree of accuracy that
    has been rigorously tested against a lot of different data and DAGs.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在经历了许多令人沮丧的小时和大量的反复试验后，我建立了一种方法，它结合了两个值，并且展现出高度的准确性，经严格测试对比了大量不同的数据和DAG。
- en: Here is the method that I use to detect dependency …
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我用来检测依赖关系的方法…
- en: '[PRE1]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The test I have adopted through trial and error is as follows …
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我通过反复试验采用的测试方法如下…
- en: If the p-value is greater than 0.05 AND the co-efficient is less than or equal
    to 1.0 then assume no dependency, otherwise assume dependency.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果p值大于0.05且系数小于或等于1.0，则假定没有依赖关系，否则假定存在依赖关系。
- en: This approach does not follow the statistical approach which would be just to
    consider the p-value in isolation but a significant amount of testing has suggested
    that it works very reliably.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法并不遵循统计方法，仅仅考虑p值，但大量测试表明它非常可靠。
- en: Optimising the Python Code
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化Python代码
- en: One drawback with the approach above is that the formula is embedded in the
    code i.e. in `ols_formula = "Y ~ C + E + F + G + X"` and also in the declarations
    of `dependent_variable` and `variables` and this will lead to code repetition
    in a real-world example.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法的一个缺点是公式嵌入在代码中，即在`ols_formula = "Y ~ C + E + F + G + X"`以及`dependent_variable`和`variables`的声明中，这会在实际示例中导致代码重复。
- en: It would be much better if a way could be found to extend the `DataFrame` class
    to be able to perform dependency tests generically on any dataset.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果能找到一种方法来扩展`DataFrame`类，以便能在任何数据集上通用地进行依赖性测试，那将会更好。
- en: Fortunately it is easy to add custom methods to the `DataFrame` class by using
    a technique called "monkey patching". If you would like a step-by-step tutorial
    please take a look at my tutorial article ...
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，通过使用一种称为“猴子补丁”的技术，向`DataFrame`类添加自定义方法非常简单。如果你想要逐步教程，请查看我的教程文章…
- en: '[](/how-to-extend-pandas-dataframes-with-custom-methods-to-supercharge-code-functionality-readability-f4ae983ad715?source=post_page-----4263b18d5f04--------------------------------)
    [## How to Extend Pandas DataFrames with Custom Methods to Supercharge Code Functionality
    & Readability'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[](/how-to-extend-pandas-dataframes-with-custom-methods-to-supercharge-code-functionality-readability-f4ae983ad715?source=post_page-----4263b18d5f04--------------------------------)
    [## 如何扩展Pandas DataFrames以增强代码功能性和可读性'
- en: A step-by-step guide to extending pandas DataFrames with custom methods including
    full examples for implementing…
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一步步扩展pandas DataFrames的自定义方法的指南，包括实现的完整示例…
- en: towardsdatascience.com](/how-to-extend-pandas-dataframes-with-custom-methods-to-supercharge-code-functionality-readability-f4ae983ad715?source=post_page-----4263b18d5f04--------------------------------)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[towardsdatascience.com](/how-to-extend-pandas-dataframes-with-custom-methods-to-supercharge-code-functionality-readability-f4ae983ad715?source=post_page-----4263b18d5f04--------------------------------)'
- en: Here is the optimised code that enables any dependency test to be executed against
    any dataset …
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是优化后的代码，它能够在任何数据集上执行任何依赖性测试…
- en: Once the `DataFrame` class has been extended with the `dependence` method, it
    is trivially easy to test any dependency test.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`DataFrame`类扩展了`dependence`方法，测试任何依赖性测试将变得非常简单。
- en: For example, we can try out 𝑌⫫̸𝐶,𝐸,𝐹,𝐺,𝑋 which should validate as `True` with
    no errors ...
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以尝试𝑌⫫̸𝐶,𝐸,𝐹,𝐺,𝑋，这应该验证为`True`且没有错误…
- en: '![](../Images/45d9d09bd277f3fffb2a4a67b27e5075.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/45d9d09bd277f3fffb2a4a67b27e5075.png)'
- en: Image by Author
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 作者提供的图片
- en: We can try out 𝑌⫫̸𝐶,𝐸,𝐹,𝐺,𝑋,𝐷 which should validate as `False` indicating that
    "D" is an error because Y is not dependent on it ...
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试𝑌⫫̸𝐶,𝐸,𝐹,𝐺,𝑋,𝐷，这应该验证为`False`，表示"D"是一个错误，因为Y不依赖于它…
- en: '![](../Images/d473cc439c247524f601e2832e64bba9.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d473cc439c247524f601e2832e64bba9.png)'
- en: Image by Author
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 作者提供的图片
- en: These tests both pass and the success rate is very high across all of the DAGs
    and datasets I have tried out to ascertain the accuracy of this approach.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Bringing it All Together
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To summarise, the relatively small code-base presented above achieves an impressive
    outcome i.e. to enable any dependency test to be carried out on any dataset to
    indicate whether that test passes or not and where it fails to specifically highlight
    the errors.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: However, more is needed. Let’s assume that when we consulted our domain experts
    the DAG they produced contained an error and that those experts had assumed that
    a causal link (or dependency) existed from node D to node Y.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: The proposed DAG would now look like this …
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/22a4b93964ccce5e5112f983fcfb1719.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Armed with our new capability we can easily test the DAG out for node Y as follows
    …
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: … and as we have seen in the results above node “D” will be accurately identified
    as an “error”. We have therefore identified a “spurious edge” i.e. a link that
    exists in the DAG but that does not exist in the data and this tells us that the
    DAG must be adjusted to removed that spurious edge in order to be accurate.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: It therefore follows that the following must hold …
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Start with a proposed DAG.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Iterate over all nodes.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute a dependency test for all incoming connections.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accumulate a list of all errors.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The accumulated list of errors will instantly indicate all spurious edges /
    connections / dependencies which must be removed from the proposed DAG to produce
    a new DAG that is free of all spurious edges (i.e. dependencies that exist in
    the DAG but not in the data).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: The code to achieve this is as follows …
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Full Algorithm to Detect Spurious Edges in the DAG
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With these few lines of code it is now possible to test any DAG (represented
    by a set of edges) against any data (represented by a pandas `DataFrame`) to see
    if there are any "spurious" edges in the DAG that do not exist in the data.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by testing the case where the DAG correctly represents all of the
    causal links in the data (remembering that `df_causal` correctly represents the
    DAG as it was synthetically created by the author to be an exact representation)
    ...
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: No errors were detected where the DAG matches the data.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s add a non-existent causal link D => Y into our DAG and re-run the
    code …
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/22a4b93964ccce5e5112f983fcfb1719.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The “spurious” edge was correctly identified in the DAG! But what about when
    there are multiple spurious causal relationships in the DAG that do not exist
    in the data? Will our algorithm still perform?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: To test this out a second non-existent causal link A => E is added to the DAG
    …
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/73746a399cf9cbe55e900a81eb48321f.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This test has also passed. If two spurious causal relationships are added to
    the DAG that do not exist in the data they are both correctly detected and identified
    as errors.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Algorithm to Destruction
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These promising results give rise to the question “So, just how accurate is
    this methods?” i.e. how many spurious causal relationships can continue to be
    added to the DAG before it fails to detect them correctly.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这些有希望的结果引发了一个问题：“那么，这种方法到底有多准确？”即在 DAG 中可以继续添加多少虚假因果关系而不被正确检测到。
- en: To answer this questions the author devised a challenging test that started
    by identifying every single valid causal link that could exist in the DAG but
    that does not. In the case of this particular DAG the full set of possible links
    looks like this …
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这些问题，作者设计了一个具有挑战性的测试，首先识别 DAG 中每一个可能存在但实际上不存在的有效因果链接。对于这个特定的 DAG，所有可能链接的完整集合如下……
- en: '![](../Images/803272ebb3328bbd0dba172ff00f907b.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/803272ebb3328bbd0dba172ff00f907b.png)'
- en: Image by Author
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 作者提供的图片
- en: A test harness was then used to randomly select any 3 of the possible missing
    links at the same time, and to repeat that test for different sets in order to
    ascertain the accuracy of the validation algorithm.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，使用测试工具随机选择任何 3 个可能缺失的链接，同时重复测试不同的集合，以确定验证算法的准确性。
- en: The results are astounding. The simple algorithm presented here detects any
    combination of 3 spurious links (using the example DAG and data) with 100% accuracy.
    Even changing the test to select any 12 of the possible spurious links together
    produces an accuracy of 90%!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 结果令人震惊。这里提出的简单算法能够以 100% 的准确率检测任何 3 个虚假链接的组合（使用示例 DAG 和数据）。即便将测试改为选择任何 12 个可能的虚假链接，一样可以达到
    90% 的准确率！
- en: 'Bonus Section: Separate vs. Combined Dependency Testing'
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录部分：分开与组合依赖测试
- en: Throughout the article the set of dependencies for a given node has been established
    by looking at all of the “parent” nodes and then creating a single statement of
    dependences, for example …
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在整篇文章中，通过查看所有的“父”节点来建立给定节点的依赖集合，然后创建一个依赖声明，例如……
- en: '![](../Images/a94fa5224968e1d531aa8cde4caa2c17.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a94fa5224968e1d531aa8cde4caa2c17.png)'
- en: Image by Author
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 作者提供的图片
- en: You may be wondering if the same set of tests are equivalent …
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道相同的测试集是否等效……
- en: '![](../Images/d4b3396d6463ee1d91826993c5af3e17.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d4b3396d6463ee1d91826993c5af3e17.png)'
- en: Image by Author
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 作者提供的图片
- en: One of the challenges the author faced was to assume that these separate tests
    are equivalent to the single overall test when detecting spurious edges but trial-and-error
    during testing led to the firm conclusion that this is not the case.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 作者面临的挑战之一是假设这些单独的测试等同于检测虚假边的单个整体测试，但测试中的试错过程得出了明确结论，即情况并非如此。
- en: When looking for the spurious edge Y => D the implementing the 𝑌⫫̸𝐶,𝐸,𝐹,𝐺,𝑋,𝐷
    test was 100% reliable but testing separately for 𝑌⫫̸𝐷 does not work and this
    was proven by executing many rounds of automated testing to compare the accuracy
    of the two methods.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在寻找虚假边 Y => D 时，实现 𝑌⫫̸𝐶,𝐸,𝐹,𝐺,𝑋,𝐷 测试是 100% 可靠的，但单独测试 𝑌⫫̸𝐷 不起作用，这通过执行多轮自动化测试来比较这两种方法的准确性得到了证明。
- en: The assumption is that because the formula that encapsulates the relationships
    between these variables is **𝑌 = 3𝐶 + 3𝐸 + 2𝐹 + 2.5𝐺 + 1.5𝑋 + ε** the OLS test
    which underpins the implementation of dependency needs to consider all of the
    variables together and this also bears out another truism in causal inference
    …
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 假设是因为封装这些变量之间关系的公式是**𝑌 = 3𝐶 + 3𝐸 + 2𝐹 + 2.5𝐺 + 1.5𝑋 + ε**，实现依赖的 OLS 测试需要考虑所有变量在一起，这也验证了因果推断中的另一个真理……
- en: '**it is very difficult or maybe even impossible to reverse engineer a DAG from
    the data but when a “first stab” has been made that gets most of the way there
    the task becomes achievable**'
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**从数据中逆向工程一个 DAG 是非常困难甚至可能不可能，但当进行“初步尝试”并接近目标时，任务变得可实现**'
- en: 'The morale of this section is: consider all of the incoming relationships for
    each node together when testing for dependency because if they are tested separately
    it simply does not work.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的要点是：在测试依赖关系时，考虑每个节点的所有输入关系，因为如果单独测试，它根本不起作用。
- en: Connect and Get in Touch …
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接并保持联系……
- en: If you enjoyed this article, you can get unlimited access to thousands more
    by becoming a Medium member for just $5 a month by [clicking on my referral link](https://grahamharrison-86487.medium.com/membership)
    (I will receive a proportion of the fees if you sign up using this link at no
    extra cost to you).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢这篇文章，你可以通过成为 Medium 会员，每月仅需 5 美元，即可无限访问更多内容，点击[我的推荐链接](https://grahamharrison-86487.medium.com/membership)（如果你通过此链接注册，我将获得费用的一部分，且对你没有额外费用）。
- en: '[](https://grahamharrison-86487.medium.com/membership?source=post_page-----4263b18d5f04--------------------------------)
    [## Join Medium with my referral link - Graham Harrison'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://grahamharrison-86487.medium.com/membership?source=post_page-----4263b18d5f04--------------------------------)
    [## 通过我的推荐链接加入 Medium - Graham Harrison'
- en: As a Medium member, a portion of your membership fee goes to writers you read,
    and you get full access to every story…
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作为 Medium 会员，你的会员费用的一部分将会流向你阅读的作者，你可以全面访问所有故事…
- en: grahamharrison-86487.medium.com](https://grahamharrison-86487.medium.com/membership?source=post_page-----4263b18d5f04--------------------------------)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: grahamharrison-86487.medium.com](https://grahamharrison-86487.medium.com/membership?source=post_page-----4263b18d5f04--------------------------------)
- en: … or connect by …
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: … 或者通过 … 连接
- en: '[Subscribing to a free e-mail whenever I publish a new story](https://grahamharrison-86487.medium.com/subscribe).'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[订阅我的免费电子邮件，以便在我发布新故事时及时获取](https://grahamharrison-86487.medium.com/subscribe)。'
- en: '[Taking a quick look at my previous articles](https://grahamharrison-86487.medium.com/).'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[快速浏览我的上一篇文章](https://grahamharrison-86487.medium.com/)。'
- en: '[Downloading my free strategic data-driven decision making framework](https://relentless-originator-3199.ck.page/5f4857fd12).'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[下载我的免费战略数据驱动决策框架](https://relentless-originator-3199.ck.page/5f4857fd12)。'
- en: Visiting my data science website — [The Data Blog](https://www.the-data-blog.co.uk/).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 访问我的数据科学网站 — [数据博客](https://www.the-data-blog.co.uk/)。
