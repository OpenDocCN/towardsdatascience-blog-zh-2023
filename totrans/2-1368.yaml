- en: Is Julia Faster than Python and Numba?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/is-julia-faster-than-python-and-numba-897c53694621](https://towardsdatascience.com/is-julia-faster-than-python-and-numba-897c53694621)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Optimisation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Numba is very fast, but is it fast enough?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@maclayton?source=post_page-----897c53694621--------------------------------)[![Mike
    Clayton](../Images/2d37746b13b7d2ff1c6515893914da97.png)](https://medium.com/@maclayton?source=post_page-----897c53694621--------------------------------)[](https://towardsdatascience.com/?source=post_page-----897c53694621--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----897c53694621--------------------------------)
    [Mike Clayton](https://medium.com/@maclayton?source=post_page-----897c53694621--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----897c53694621--------------------------------)
    ·16 min read·Sep 19, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/69fa7749831310e9eb6a02054d9ee87d.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Stanos](https://unsplash.com/@stan_remnev?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
    on [Unsplash](https://unsplash.com/photos/2Yj6MBvJ0sg?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
  prefs: []
  type: TYPE_NORMAL
- en: '**Numba is a widely used optimisation library for Python that elevates function
    execution times into the same ballpark as the C language, and C is undoubtedly
    rapid.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Is that level of optimisation enough to compete with a newer, purpose built,
    targeted language like Julia? And if so, are there any caveats to achieving that
    level of execution speed in Python?**'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../Images/4aa570daa0aa0c472205cffbdcfa200e.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Ann H](https://www.pexels.com/photo/yellow-letter-tiles-1888003/)
    on [Pexels](https://www.pexels.com/#)
  prefs: []
  type: TYPE_NORMAL
- en: 'I have previously written an [article comparing NumPy to Julia](/is-julia-really-faster-than-python-and-numpy-242e0a5fe34f).
    The outcome was essentially that Julia is indeed faster than NumPy, in general.
    However, it is a bit more nuanced than that, so I encourage you to check out the
    article to get the whole story:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/is-julia-really-faster-than-python-and-numpy-242e0a5fe34f?source=post_page-----897c53694621--------------------------------)
    [## Is Julia Really Faster than Python and Numpy?'
  prefs: []
  type: TYPE_NORMAL
- en: The speed of C with the simplicity of Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/is-julia-really-faster-than-python-and-numpy-242e0a5fe34f?source=post_page-----897c53694621--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most common responses to that article was something along the lines
    of:'
  prefs: []
  type: TYPE_NORMAL
- en: Well you should also use Numba. It is simple to implement, and makes things
    even faster!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -quite a few people
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: …so this article is going to attempt to address that suggestion head on.
  prefs: []
  type: TYPE_NORMAL
- en: Does using Numba match, or even exceed, the speed of Julia? Is it as easy to
    use and implement as people seem to claim? And, are there any downsides?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s find out…
  prefs: []
  type: TYPE_NORMAL
- en: A quick primer on Julia
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../Images/0d756d1fe48b6f81c08fe8e1cfc26c38.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Ann H](https://www.pexels.com/photo/yellow-letter-tiles-1888003/)
    on [Pexels](https://www.pexels.com/#)
  prefs: []
  type: TYPE_NORMAL
- en: As some of you may not have read the [previous article about NumPy](/is-julia-really-faster-than-python-and-numpy-242e0a5fe34f),
    I will repeat the “What is Julia?” section included in that article here, but
    feel free to skip ahead if you have already read the previous article.
  prefs: []
  type: TYPE_NORMAL
- en: What is Julia?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just in case you have no idea what Julia is, here is a quick primer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Julia](https://julialang.org/) is an open source language that is dynamically
    typed, intuitive, and easy to use like Python, but with the speed of execution
    of a language like C.'
  prefs: []
  type: TYPE_NORMAL
- en: It has been around approximately 11 years (born in 2012), so it is a relatively
    new language. However, it is at a stage of maturity where you wouldn’t call it
    a fad.
  prefs: []
  type: TYPE_NORMAL
- en: 'The original creators of the language are active in a relevant field of work:'
  prefs: []
  type: TYPE_NORMAL
- en: For the work we do — scientific computing, machine learning, data mining, large-scale
    linear algebra, distributed and parallel computing — …
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '- [julialang.org](https://julialang.org/blog/2012/02/why-we-created-julia/)
    — Jeff Bezanson, Stefan Karpinski, Viral B. Shah, Alan Edelman'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'All in all, it is a **modern language specifically designed to be used in the
    field of data science**. The aims of the creators themselves tell you a great
    deal:'
  prefs: []
  type: TYPE_NORMAL
- en: We want the speed of C with the dynamism of Ruby. We want a language that’s
    homoiconic, with true macros like Lisp, but with obvious, familiar mathematical
    notation like Matlab. We want something as usable for general programming as Python,
    as easy for statistics as R, as natural for string processing as Perl, as powerful
    for linear algebra as Matlab, as good at gluing programs together as the shell.
    Something that is dirt simple to learn, yet keeps the most serious hackers happy.
    We want it interactive and we want it compiled.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (Did we mention it should be as fast as C?)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '- [julialang.org](https://julialang.org/blog/2012/02/why-we-created-julia/)
    — Jeff Bezanson, Stefan Karpinski, Viral B. Shah, Alan Edelman'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Sounds quite exciting right?
  prefs: []
  type: TYPE_NORMAL
- en: '*Incidentally, if you want an idea as to how Python and Julia compare side-by-side
    in terms of syntax and general usage, then you may want to check out my other
    article, which takes an in depth look at running a deep learning image classification
    problem using both Julia (Flux) and Python (TensorFlow):*'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/julias-flux-vs-python-s-tensorflow-how-do-they-compare-574a3fb5e059?source=post_page-----897c53694621--------------------------------)
    [## Julia’s Flux vs Python’s TensorFlow: How Do They Compare?'
  prefs: []
  type: TYPE_NORMAL
- en: An end-to-end deep learning project comparison
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/julias-flux-vs-python-s-tensorflow-how-do-they-compare-574a3fb5e059?source=post_page-----897c53694621--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: What is Numba, and why is it so fast (and popular)?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../Images/2a1aaf170dbbf7c9485d0cd5023662a6.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Towfiqu barbhuiya](https://unsplash.com/@towfiqu999999?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
    on [Unsplash](https://unsplash.com/photos/oZuBNC-6E2s?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind Numba is extremely simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pre-compile the Python code to machine code, and execute the compiled code
    rather than the Python code. Or for a little more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Numba translates Python functions to optimized machine code at runtime using
    the industry-standard [LLVM](https://llvm.org/) compiler library. Numba-compiled
    numerical algorithms in Python can approach the speeds of C or FORTRAN.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -[numba.pydata.org](https://numba.pydata.org/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To approach the speed of C (or FORTRAN) by definition means that Numba is indeed
    going to be extremely fast.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation is (generally) easy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the major pluses to the way Numba is implemented is that it is, in most
    cases, very easy to use. Here is an example of a normal Python function, and then
    the equivalent Numba function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Literally a single decorator! It would appear to be verging on criminal not
    to implement Numba on every function. (more on the reality of that later…)
  prefs: []
  type: TYPE_NORMAL
- en: So should I replace NumPy with Numba?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Numba is not a replacement, or alternative, to NumPy. It is designed to be utilised
    **in addition** to NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: Numba is designed to be used with NumPy arrays and functions. Numba generates
    specialized code for different array data types and layouts to optimize performance.
    Special decorators can create [universal functions](https://docs.scipy.org/doc/numpy/reference/ufuncs.html)
    that broadcast over NumPy arrays just like NumPy functions do.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[-numba.pydata.org](https://numba.pydata.org/)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is excellent, as NumPy is already extremely powerful, and Numba just elevates
    it even further. Plus, there is no requirement to re-write all your NumPy code
    if you decide you want to utilise Numba.
  prefs: []
  type: TYPE_NORMAL
- en: Numba’s other tricks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The compilation step is only the start. Numba has an extensive set of additional
    features that can potentially further increase execution speed. Some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[***Parallel processing***](https://numba.readthedocs.io/en/stable/user/parallel.html)—
    if you have a CPU with multiple cores, you can potentially use them in parallel
    to speed up processing'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[***Fastmath***](https://numba.readthedocs.io/en/stable/user/performance-tips.html#fastmath)
    — reduce numerical accuracy to gain speed of execution'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[***Cache***](https://numba.readthedocs.io/en/stable/user/jit.html#cache) —
    save compiled code in a cache to reduce compile overhead on repeat future usage'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[***CUDA***](https://numba.readthedocs.io/en/stable/cuda/index.html)— Use your
    GPU for your calculations'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are of course more options than the four above, and plenty of customisation
    should you need it. This article will primarily focus on parallel processing and
    Fastmath from the list above.
  prefs: []
  type: TYPE_NORMAL
- en: Using a GPU (CUDA) warrants a whole other article to do it justice, so that
    won’t be covered in this article.
  prefs: []
  type: TYPE_NORMAL
- en: The disadvantages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two main negative points to Numba.
  prefs: []
  type: TYPE_NORMAL
- en: The first, and most obvious, is that **compilation is required**, and compilation
    takes time.
  prefs: []
  type: TYPE_NORMAL
- en: If the function is only executed once, the compilation time may be a significant
    disadvantage. However, if the code requires repeat usage of the compiled function
    (like in a loop), then the disadvantage could become negligible. It all depends
    on the circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: …compilation is required, and compilation takes time.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The second, as per the quote directly from the Numba website itself, is that
    Numba can only be implemented on functions it is designed to be used with.
  prefs: []
  type: TYPE_NORMAL
- en: Numba is an open source JIT compiler that translates **a subset of Python and
    NumPy code** into fast machine code.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[-numba.pydata.org](https://numba.pydata.org/)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I will point out that the functions available are quite extensive, so you may
    not find that this is an issue, but it is a negative point all the same. There
    is also quite a bit of in built flexibility to allow custom code to be written,
    such as [NumPy ufuncs](https://numba.readthedocs.io/en/stable/user/vectorize.html#).
    So there are some workarounds if you do have quite unique requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The basis of the speed test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../Images/5c49768600b5c778213e8806c5df4352.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by [StockSnap](https://pixabay.com/users/stocksnap-894430/?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=2606859)
    from [Pixabay](https://pixabay.com//?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=2606859)
  prefs: []
  type: TYPE_NORMAL
- en: As alluded to in the introduction to this article, this particular article is
    the culmination of two previous articles.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first provides a guide on how to utilise NumPy vectorization to speed up
    your Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/how-to-speedup-data-processing-with-numpy-vectorization-12acac71cfca?source=post_page-----897c53694621--------------------------------)
    [## How to Speedup Data Processing with Numpy Vectorization'
  prefs: []
  type: TYPE_NORMAL
- en: Up to 8000 times faster than normal functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/how-to-speedup-data-processing-with-numpy-vectorization-12acac71cfca?source=post_page-----897c53694621--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: '…a natural progression was to see how NumPy, and it’s implementation of vectorization
    stacked up against Julia:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/is-julia-really-faster-than-python-and-numpy-242e0a5fe34f?source=post_page-----897c53694621--------------------------------)
    [## Is Julia Really Faster than Python and Numpy?'
  prefs: []
  type: TYPE_NORMAL
- en: The speed of C with the simplicity of Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/is-julia-really-faster-than-python-and-numpy-242e0a5fe34f?source=post_page-----897c53694621--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: …and now, mainly due to comments on the previous Julia article, I think it will
    be interesting to see how Julia stacks up against the added features of Numba.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s get into it!
  prefs: []
  type: TYPE_NORMAL
- en: How will the tests work?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../Images/912092a1bd5b04350e215a97c5f87798.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Nguyen Dang Hoang Nhu](https://unsplash.com/@nguyendhn?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
    on [Unsplash](https://unsplash.com/photos/cbEvoHbJnIE?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
  prefs: []
  type: TYPE_NORMAL
- en: There will be three different function tested. Each function will increase in
    complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Function 1 — A simple summation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The inputs (**a** and **b**) to the following functions are defined as a 1D
    array/vector with one million elements. Each element is a random number taken
    from a normal distribution, and of type float32.
  prefs: []
  type: TYPE_NORMAL
- en: For the Python function, the arrays will be NumPy arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Function 2 — A loop function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Loops are ubiquitous, and therefore worth looking at.
  prefs: []
  type: TYPE_NORMAL
- en: The input arrays will be the same as for Function 1.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Function 3 — Matrix manipulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Matrix manipulation is a key component of many algorithms and tasks in the field
    of data science (especially deep learning), and so is an important factor to consider.
  prefs: []
  type: TYPE_NORMAL
- en: Input into the functions will take the form of a 100 by 100 matrix of random
    numbers taken from a normal distribution.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Additional investigations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make things a little more informative, the following items will also be
    investigated:'
  prefs: []
  type: TYPE_NORMAL
- en: All of the Numba functions will be timed both with and without the inclusion
    of the compilation stage. This will help judge the impact of compilation on overall
    execution time
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A single iteration, and multiple iterations will be performed. Again, to investigate
    the impact of compilation on execution time
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apart from the ‘normal’ running of the functions, the effectiveness of parallel
    processing in both Numba and Julia will be compared
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The additional benefits of the Fastmath parameter in Numba will be investigated
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The measurements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The timing of the functions will be conducted using the [timeit module](https://docs.python.org/3/library/timeit.html)
    in Python and the [BenchmarkTools module](https://juliaci.github.io/BenchmarkTools.jl/stable/)
    in Julia.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Some general information (environment, versions, etc.)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All numbers that will follow were run on the exact same hardware, which uses
    an 4 core/8 thread CPU (i7–4790K) (exact details are printed in the Jupyter notebooks).
  prefs: []
  type: TYPE_NORMAL
- en: 'The software versions were as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Julia:** 1.9.2'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python:** 3.11.4'
  prefs: []
  type: TYPE_NORMAL
- en: '**NumPy:** 1.23.5'
  prefs: []
  type: TYPE_NORMAL
- en: '**Numba:** 0.57.1'
  prefs: []
  type: TYPE_NORMAL
- en: The notebooks for this article
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../Images/7a23361e1a8b46a4e777f807d816a9df.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Jessica Lewis](https://www.pexels.com/photo/ball-point-pen-on-opened-notebook-606541/)
    on [Pexels](https://www.pexels.com/)
  prefs: []
  type: TYPE_NORMAL
- en: 'All the code used to generate the results in this article are available in
    their entirety in two Jupyter notebooks here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://github.com/thetestspecimen/notebooks/tree/main/julia-numba-comparison?source=post_page-----897c53694621--------------------------------)
    [## notebooks/julia-numba-comparison at main · thetestspecimen/notebooks'
  prefs: []
  type: TYPE_NORMAL
- en: Jupyter notebooks. Contribute to thetestspecimen/notebooks development by creating
    an account on GitHub.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: github.com](https://github.com/thetestspecimen/notebooks/tree/main/julia-numba-comparison?source=post_page-----897c53694621--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: The results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../Images/cbe240e6d9f026ec916742b4a45f619a.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Anna Nekrashevich](https://www.pexels.com/photo/magnifying-glass-on-top-of-document-6801648/)
    on [Pexels](https://www.pexels.com/)
  prefs: []
  type: TYPE_NORMAL
- en: Starting with…
  prefs: []
  type: TYPE_NORMAL
- en: A simple summation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all over a single iteration.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/58ef2049cc84e1743e349b89f3e93e06.png)'
  prefs: []
  type: TYPE_IMG
- en: A simple summation of two arrays over one iteration — Graph by Author
  prefs: []
  type: TYPE_NORMAL
- en: This first run over a single iteration is just to illustrate the significant
    overhead, compared to the overall execution time, that the compilation of the
    function **may** have when using Numba.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth pointing this out to avoid falling into the trap of just using Numba
    for everything, and not thinking about whether it is appropriate. If you have
    to execute a relatively simple function only once, then it will typically be better
    to just use NumPy directly, or at least take advantage of [caching](https://numba.readthedocs.io/en/stable/user/jit.html#cache)
    if your situation allows for it.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s increase the iterations to reduce the impact of the initial compilation.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/89251f787087fcb1410f7b63d0fd1aa8.png)'
  prefs: []
  type: TYPE_IMG
- en: A simple summation of two arrays over 10000 iterations — Graph by Author
  prefs: []
  type: TYPE_NORMAL
- en: Well, there you have it. Julia is dead last!
  prefs: []
  type: TYPE_NORMAL
- en: In reality the difference is small (10000 iterations — Julia[7.2s] — NumPy[5.1s]),
    but it is a difference all the same.
  prefs: []
  type: TYPE_NORMAL
- en: Even more surprising is that Numba actually makes the execution slightly slower
    than NumPy, even if the Numba compilation time is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: This goes a long was to illustrate that *properly* vectorized NumPy calculations
    are very well optimised, which is another element to consider when thinking about
    about whether Numba is worth using for your particular application.
  prefs: []
  type: TYPE_NORMAL
- en: '***Note:*** *for more detail on what exactly NumPy vectorization is, and how
    it works, please check out my previous article where I go into detail:*'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/how-to-speedup-data-processing-with-numpy-vectorization-12acac71cfca?source=post_page-----897c53694621--------------------------------)
    [## How to Speedup Data Processing with Numpy Vectorization'
  prefs: []
  type: TYPE_NORMAL
- en: Up to 8000 times faster than normal functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/how-to-speedup-data-processing-with-numpy-vectorization-12acac71cfca?source=post_page-----897c53694621--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Looped Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Moving on to a more realistic and slightly more complicated scenario, let’s
    have a look at a looping function.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, running element by element through a 1 million element array and
    replacing each element based on an if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/575ccf1c2aa455dd85b03e8c61e739ff.png)'
  prefs: []
  type: TYPE_IMG
- en: A loop funciton over 100 iterations (**Comp** — includes the function compilation
    time, **Para** — parallel processing)— Graph by Author
  prefs: []
  type: TYPE_NORMAL
- en: Yet again, Numba comes out on top.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, even including the compilation time in the Numba run still has
    Numba coming out faster than Julia. Obviously, if the iterations were less, this
    lead would diminish, and then ultimately reverse. However, the execution stage
    is definitely quicker.
  prefs: []
  type: TYPE_NORMAL
- en: You will also note that parallel processing can help significantly in the case
    of both Julia and Numba. Some slight adjustments to the function must be made
    but nothing too extreme.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Julia it is just a case of adding `Threads.@threads` in front of the for
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: For Numba it just requires adding `parallel=True` to the decorator and swapping
    out `np.arange` for `prange`(i.e. [parallel range](https://numba.pydata.org/numba-doc/latest/user/parallel.html?highlight=prange)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Another few additional microseconds were gained via the use of [Fastmath](https://numba.pydata.org/numba-doc/latest/user/performance-tips.html?highlight=fastmath#fastmath),
    which essentially reduces precision to gain execution speed. This could be very
    useful in the realms of machine/deep learning where high numeric precision is
    not necessarily required when training a model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again just a simple addition to the decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Matrix manipulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Matrix manipulation is an essential part of Data Science workflow and specifically
    deep learning/neural networks.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that in mind, I thought it might be interesting to see how Julia and Numba
    cope with chaining some different matrix manipulations together. Including:'
  prefs: []
  type: TYPE_NORMAL
- en: the ubiquitous dot product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: transposition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: reshaping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: summation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: square root
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: absolute value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: average value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/11f13a8a0fd7e4593271f29348367508.png)'
  prefs: []
  type: TYPE_IMG
- en: Matrix manipulation over 20 iterations (**Comp** — includes the function compilation
    time, **Para** — parallel processing) — Graph by Author
  prefs: []
  type: TYPE_NORMAL
- en: Julia comes out on top in this case, by quite a margin (approx. 10 times quicker).
    Why this is is difficult to say, and would require further investigation. However,
    I suspect it will be down to some of the limitations of Numba, which I will discuss
    further in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to note here is that due to the extended execution time of this
    function compared to Functions 1 and 2, the compilation time is already insignificant
    at just 20 iterations.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately though, Numba is as quick as they say, and it is easy to use **in
    the majority of cases**. It easily pushes Python and it’s ecosystem into the territory
    of Julia, and in general bang up to date.
  prefs: []
  type: TYPE_NORMAL
- en: With some caveats…
  prefs: []
  type: TYPE_NORMAL
- en: The Limitations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../Images/1b13fc39d5096096b5e1dd1140a9f81e.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [RDNE Stock project](https://www.pexels.com/photo/woman-hand-holding-paper-bag-7564158/)
    on [Pexels](https://www.pexels.com/)
  prefs: []
  type: TYPE_NORMAL
- en: It is fair to say that Numba can indeed keep up, and sometimes exceed Julia
    in terms of execution speed.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is one major difference between Julia and Numba. Numba is an
    external library for a language, whereas the methods used in Julia are native
    methods integrated in to the core language.
  prefs: []
  type: TYPE_NORMAL
- en: Numba is an external library for a language, whereas the methods used in Julia
    are native methods integrated in to the core language.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'What this essentially means is that with Julia you are very unlikely to hit
    incompatibility issues or limitations on method application. The same cannot be
    said for Numba. Not only are the limitations of the application of Numba explicitly
    defined in the official documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Supported Python features](https://numba.readthedocs.io/en/stable/reference/pysupported.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Supported NumPy features](https://numba.readthedocs.io/en/stable/reference/numpysupported.html)'
  prefs: []
  type: TYPE_NORMAL
- en: …but you are much more likely to find bugs due to incompatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Some bugs I found
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code in this article is very limited. Pretty simple functions. However,
    I still had issues with Numba, and had to adjust my analysis as a result.
  prefs: []
  type: TYPE_NORMAL
- en: On the last benchmarks conducted on 2D arrays/matrices (Function 3), there were
    various adjustments that had to be made just to get the function to run when using
    Numba.
  prefs: []
  type: TYPE_NORMAL
- en: '**It should be noted that none of the following are a problem when using straight
    Python/NumPy without Numba.**'
  prefs: []
  type: TYPE_NORMAL
- en: You cannot use `np.reshape` with a second argument (i.e. you cannot specify
    the re-order type ‘F’, ‘C’ etc.). This was an issue as Julia and Python use a
    different matrix index ordering as default, and attempting to keep things as comparable/fair
    as possible required looking into this second argument
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`np.matmul` is not supported and therefore you have to use `np.dot`. This is
    not an issue for 2D arrays like those used in this article, but these methods
    are not equivalent for higher dimensional arrays, and you therefore may have an
    issue if you rely on `np.matmul` for higher dimensional arrays.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Open bug](https://github.com/numba/numba/issues/5433) — using `np.reshape`
    after a transpose requires a copy to be taken, or it fails'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Open bug](https://github.com/numba/numba/issues/6714) — no support for integer
    arrays with `np.dot`. Having been forced to abandon`np.matmul` for `np.dot` (due
    to point 2), I now had another issue during testing before moving to floats'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I lost quite a bit of time with the four points above, as it is not always clear
    whether you are doing something wrong (i.e. trying to implement something that
    is not supported), or dealing with a bug. If I wasn’t dealing with “play” code
    for an article, and this was project code, it could become quite frustrating.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../Images/6480554e0174618f60b14cd1368bdc38.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Ann H](https://www.pexels.com/photo/yellow-letter-tiles-1888003/)
    on [Pexels](https://www.pexels.com/#)
  prefs: []
  type: TYPE_NORMAL
- en: 'Numba is excellent, and most importantly everything people claim it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fast and easy to implement**'
  prefs: []
  type: TYPE_NORMAL
- en: …and yes, to generalise, it is basically as fast as Julia. As long as it is
    used in the appropriate circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: However, I can’t overlook the fact that Numba has some serious limitations when
    compared directly to Julia. Of course, the importance of those limitations will
    vary depending on your own requirements, and particular constraints.
  prefs: []
  type: TYPE_NORMAL
- en: In the real world, all this basically means is that if your current projects,
    or infrastructure, rely on Python, and changing to a new language is too much
    (lack of experienced devs, too much legacy code, not enough budget etc.). Then
    due to the hard work and persistence of the devs behind libraries like NumPy and
    Numba, Python is still bang up to date in terms of speed and features in the field
    of Data Science. Numba, and NumPy, very effectively fill a gap.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, when writing code in Julia you well are aware of the fact that the
    base language is heavily optimised without any external libraries. It is also
    designed with data science in mind from the ground up, as that is what the creators
    needed themselves:'
  prefs: []
  type: TYPE_NORMAL
- en: For the work we do — scientific computing, machine learning, data mining, large-scale
    linear algebra, distributed and parallel computing — …
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '- [julialang.org](https://julialang.org/blog/2012/02/why-we-created-julia/)
    — Jeff Bezanson, Stefan Karpinski, Viral B. Shah, Alan Edelman'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You don’t have to be aware, or knowledgeable, about external libraries and tools
    to ensure that your project is fast with Julia. It will be fast by default. This
    allows more thought to go into what you are trying to achieve, rather than constantly
    having to consider the best way to speed things up, or optimise.
  prefs: []
  type: TYPE_NORMAL
- en: That is why, **if reasonably possible**, it makes a lot of sense to switch over
    to Julia (in my opinion!).
  prefs: []
  type: TYPE_NORMAL
- en: '***Note:*** *If you want to know more about the ins and outs of Julia for something
    like deep learning when compared to Python (TensorFlow), then be sure to take
    a look at this article:*'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/julias-flux-vs-python-s-tensorflow-how-do-they-compare-574a3fb5e059?source=post_page-----897c53694621--------------------------------)
    [## Julia’s Flux vs Python’s TensorFlow: How Do They Compare?'
  prefs: []
  type: TYPE_NORMAL
- en: An end-to-end deep learning project comparison
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/julias-flux-vs-python-s-tensorflow-how-do-they-compare-574a3fb5e059?source=post_page-----897c53694621--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: If you found this article interesting or useful, remember to follow me, or [sign
    up for my newsletter](https://medium.com/@maclayton/subscribe) for more content
    like this.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven’t already, you could also consider [subscribing to Medium](https://medium.com/@maclayton/membership).
    Your membership fee directly supports, not just me, but other writers you read
    too. You’ll also get full unrestricted access to every story on Medium.
  prefs: []
  type: TYPE_NORMAL
- en: Using my referral link to sign up will grant me a small kickback with zero effect
    on your membership, so thank you if you choose to do so.
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/@maclayton/membership?source=post_page-----897c53694621--------------------------------)
    [## Join Medium with my referral link - Mike Clayton'
  prefs: []
  type: TYPE_NORMAL
- en: As a Medium member, a portion of your membership fee goes to writers you read,
    and you get full access to every story…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/@maclayton/membership?source=post_page-----897c53694621--------------------------------)
  prefs: []
  type: TYPE_NORMAL
