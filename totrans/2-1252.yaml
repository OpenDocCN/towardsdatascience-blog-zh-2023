- en: How to Test Your Unit Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://towardsdatascience.com/how-to-test-your-unit-tests-afe18d6e19d8](https://towardsdatascience.com/how-to-test-your-unit-tests-afe18d6e19d8)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Unit Testing](https://medium.com/tag/unit-testing)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A brief introduction to mutation testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://dr-robert-kuebler.medium.com/?source=post_page-----afe18d6e19d8--------------------------------)[![Dr.
    Robert K√ºbler](../Images/3b8d8b88f76c0c43d9c305e3885e7ab9.png)](https://dr-robert-kuebler.medium.com/?source=post_page-----afe18d6e19d8--------------------------------)[](https://towardsdatascience.com/?source=post_page-----afe18d6e19d8--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----afe18d6e19d8--------------------------------)
    [Dr. Robert K√ºbler](https://dr-robert-kuebler.medium.com/?source=post_page-----afe18d6e19d8--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ¬∑Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----afe18d6e19d8--------------------------------)
    ¬∑5 min read¬∑Jan 16, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/fbcb034d926169de17728b3dae68786b.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Erik Mclean](https://unsplash.com/@introspectivedsgn?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: 'In my last article, I talked about how unit testing is an essential aspect
    of the work of a data scientist because incorrect code leads to faulty analyses.
    One way to improve unit testing is to use **property-based testing** alongside
    **example-based testing**, i.e. the *normal* way of unit testing. You can check
    out my last article here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/stop-hardcoding-your-unit-tests-e6643dfd254b?source=post_page-----afe18d6e19d8--------------------------------)
    [## Stop Hardcoding Your Unit Tests'
  prefs: []
  type: TYPE_NORMAL
- en: A guide to property-based testing in Python using Hypothesis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/stop-hardcoding-your-unit-tests-e6643dfd254b?source=post_page-----afe18d6e19d8--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 'After publishing this article, I [got a response](https://medium.com/@dotcom.software/mutation-testing-is-also-an-amazing-technique-to-verify-if-weve-missed-any-edge-cases-in-our-unit-e3c63cae1a06)
    from **.com software** pointing me to **mutation testing**, which I want to explain
    to you today. Long story short:'
  prefs: []
  type: TYPE_NORMAL
- en: Mutation testing allows you to spot weak tests.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Weak tests are tests that give you a wrong sense of security because they pass
    **even if you know that they should not pass**, the king of them being `assert
    True` . Replacing these tests makes your whole test suite more meaningful and
    trustworthy.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let‚Äôs see what this is all about!
  prefs: []
  type: TYPE_NORMAL
- en: Weak Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider this very simple function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us assume that you want to write a unit test despite the simplicity of
    this function. A *test_mean.py* file could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Calling `pytest test_mean.py` would then of course result in a passing test.
    Everything is green and we even got 100% coverage! Time to move on to the next
    feature, right? **No!**
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take a close look at the assertion in the test code instead: the second
    argument to the function is zero, meaning that the `y` in the function is basically
    ignored. The input has a special shape that lets the test pass easier than anticipated.
    For example, it would even pass if the function was'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Even after this simple **mutation of the function** ‚Äî changing a plus to a minus
    ‚Äî`test_mean` still passes.
  prefs: []
  type: TYPE_NORMAL
- en: '**This should not happen, i**f the test is any good, it should fail whenever
    we change the definition of the function!'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A test like this is as good as a metal detector that makes a noise even when
    presented with wood. That‚Äôs why we call `test_mean` a **weak test**.
  prefs: []
  type: TYPE_NORMAL
- en: This weak test might be easy to spot here but if you write code that is slightly
    more involved, you might create weak examples by accident and not even notice
    it, giving you a false sense of security.
  prefs: []
  type: TYPE_NORMAL
- en: Mutation Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use **mutation testing** to spot weak tests. The idea of mutation testing
    is quite old already: it was originally proposed by Richard Lipton as a student
    in 1971\. It is also very simple, it is so simple in fact that I gave it away
    already in the last chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Mutate (apply small changes to) the source code of the function that you want
    to test and see if the tests still pass. If they do, they are weak. If they fail
    (and didn‚Äôt fail for the original function), they survived and might be strong.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'You have seen one mutation already, a change from + to -. Besides that, you
    can change:'
  prefs: []
  type: TYPE_NORMAL
- en: '- to +'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: / to * or vice versa,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ‚â• to > or even <,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ‚â§ to < or even >
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: = to != or vice versa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: add or subtract 1 from integers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: add some random characters to strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ‚Ä¶
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: you get the idea. Just simple tweaks that **still produce valid source code**,
    changing the original function that you want to test into something slightly different.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you can do this manually and change your source code a couple of
    times, always followed by a `pytest` . But since this is no fun, [people created
    a package to do just that automatically](https://github.com/boxed/mutmut) and
    log the results.
  prefs: []
  type: TYPE_NORMAL
- en: Mutmut for Convenient Mutation Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Anders Hovm√∂ller aka boxed](https://github.com/boxed) and a lot of other contributors
    created a package called [mutmut](https://github.com/boxed/mutmut) to do the work
    for you.'
  prefs: []
  type: TYPE_NORMAL
- en: First, install it via `pip install mutmut` . Then you have to extract the function(s)
    that you want to test into a file, let‚Äôs call it *function.py*. Let‚Äôs also still
    assume that the test is in *test_mean.py*. Then you can call
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: and it will create some mutations of your *function.py* containing the *mean*
    function that we want to test.
  prefs: []
  type: TYPE_NORMAL
- en: '*If you open* function.py *in an editor that constantly reloads the file while
    mutmut is running, you can even see how the file gets changed live! But don‚Äôt
    worry: mutmut will create a copy of the original file first before it makes modifications.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The output will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/38069b69d36188159342474601ce3ee1.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see several things here, especially **at the bottom**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Three mutants were created. (*side note: + to -, / to *, 2 to 3 in our case*)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Two out of these three mutants were *killed*, meaning that the unit test that
    passed before failed after the file was changed, which is good üéâ.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'One mutant survived, meaning that the test still passed although the source
    code changed. This is bad üôÅ. We have even seen this survivor already:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create an HTML report via `mutmut html` and open it in a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/cc091067fd6dceec2c9a101112a4d40e.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: The design could be better, but it contains the main information about the survivors.
  prefs: []
  type: TYPE_NORMAL
- en: '***Note:*** *Sometimes two weak single tests can make one better test suite.
    For example, if you add the assertion* `*assert mean(-1, 1) == 0*` *‚Äî another
    weak test as the mutant* `*return (x+y) * 2*` *would survive ‚Äî in total no mutant
    would survive mutmut‚Äôs procedure, improving the test suite.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this article, we have seen that passing tests and even 100% test coverage
    can be deceiving. A passing test is nice, but if it still passes even after changing
    the function that is being tested, this is a red flag that indicates that the
    test might be weak.
  prefs: []
  type: TYPE_NORMAL
- en: Mutation testing offers a structured way of changing (mutating) the function.
    The Python library mutmut even allows us to change our source code automatically
    (a backup is created beforehand) and check which tests still pass (üôÅ) and which
    ones fail after the mutation (üéâ).
  prefs: []
  type: TYPE_NORMAL
- en: This hardens your test suite, which in turn lets you produce the correct code
    that is necessary for faultless analyses.
  prefs: []
  type: TYPE_NORMAL
- en: I hope that you learned something new, interesting, and useful today. Thanks
    for reading!
  prefs: []
  type: TYPE_NORMAL
- en: '**As the last point, if you**'
  prefs: []
  type: TYPE_NORMAL
- en: '**want to support me in writing more about machine learning and**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**plan to get a Medium subscription anyway,**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**why not do it** [**via this link**](https://dr-robert-kuebler.medium.com/membership)**?
    This would help me a lot! üòä**'
  prefs: []
  type: TYPE_NORMAL
- en: '*To be transparent, the price for you does not change, but about half of the
    subscription fees go directly to me.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Thanks a lot, if you consider supporting me!**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you have any questions, write me on* [*LinkedIn*](https://www.linkedin.com/in/dr-robert-k%C3%BCbler-983859150/)*!*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
