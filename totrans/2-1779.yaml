- en: The Reingold Tilford Algorithm Explained, with Walkthrough
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 费曼-蒂尔福德算法解析及演示
- en: 原文：[https://towardsdatascience.com/reingold-tilford-algorithm-explained-with-walkthrough-be5810e8ed93](https://towardsdatascience.com/reingold-tilford-algorithm-explained-with-walkthrough-be5810e8ed93)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/reingold-tilford-algorithm-explained-with-walkthrough-be5810e8ed93](https://towardsdatascience.com/reingold-tilford-algorithm-explained-with-walkthrough-be5810e8ed93)
- en: Algorithm to Plot Tree Nodes with Numerical Examples and Python Code
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用数值示例和Python代码绘制树节点的算法
- en: '[](https://kayjanwong.medium.com/?source=post_page-----be5810e8ed93--------------------------------)[![Kay
    Jan Wong](../Images/28e803eca6327d97b6aa97ee4095d7bd.png)](https://kayjanwong.medium.com/?source=post_page-----be5810e8ed93--------------------------------)[](https://towardsdatascience.com/?source=post_page-----be5810e8ed93--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----be5810e8ed93--------------------------------)
    [Kay Jan Wong](https://kayjanwong.medium.com/?source=post_page-----be5810e8ed93--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://kayjanwong.medium.com/?source=post_page-----be5810e8ed93--------------------------------)[![Kay
    Jan Wong](../Images/28e803eca6327d97b6aa97ee4095d7bd.png)](https://kayjanwong.medium.com/?source=post_page-----be5810e8ed93--------------------------------)[](https://towardsdatascience.com/?source=post_page-----be5810e8ed93--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----be5810e8ed93--------------------------------)
    [Kay Jan Wong](https://kayjanwong.medium.com/?source=post_page-----be5810e8ed93--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----be5810e8ed93--------------------------------)
    ·9 min read·Sep 12, 2023
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·发表于[Towards Data Science](https://towardsdatascience.com/?source=post_page-----be5810e8ed93--------------------------------)
    ·阅读时长9分钟·2023年9月12日
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/4962af380309f59d5a1af978e2bb8265.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4962af380309f59d5a1af978e2bb8265.png)'
- en: Photo by [Sergiu Vălenaș](https://unsplash.com/@svalenas?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 由[Sergiu Vălenaș](https://unsplash.com/@svalenas?utm_source=medium&utm_medium=referral)拍摄，来源于[Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: The 1981 Reingold-Tilford algorithm creates a visually pleasing representation
    of hierarchical data by arranging nodes in a tree structure to maximize readability.
    In other words, it is an algorithm for retrieving the `(x, y)` coordinates of
    every node in a tree.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 1981年的费曼-蒂尔福德算法通过将节点安排在树结构中以最大化可读性，从而创建了一个视觉上令人愉悦的层级数据表示。换句话说，它是一个用于检索树中每个节点的`(x,
    y)`坐标的算法。
- en: According to the [paper](https://reingold.co/tidier-drawings.pdf), there are
    a few aesthetic rules that a good tree diagram should follow,
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[论文](https://reingold.co/tidier-drawings.pdf)，一个好的树状图应遵循一些美学规则，
- en: 1\. Nodes at the same depth should lie along a straight line, and the straight
    lines defining the depths should be parallel
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 同一深度的节点应排列在一条直线上，并且定义深度的直线应当平行。
- en: ''
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 2\. A left child should be positioned to the left of its parent node and a right
    child to the right (only applicable to binary trees)
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 左子节点应位于其父节点的左侧，右子节点应位于右侧（仅适用于二叉树）
- en: ''
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 3\. A parent should be centered over their children
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 父节点应当居中于其子节点上方
- en: ''
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 4\. A tree and its mirror image should produce drawings that are a reflection
    of one another, and a subtree should be drawn the same way regardless of where
    it occurs in the tree
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 树及其镜像应产生互为反射的图形，子树的绘制方式应与其在树中的位置无关
- en: Determining the `y` coordinates of the nodes is straightforward, whereas the
    `x` coordinates are slightly more tricky. This article will attempt to explain
    the algorithm with numerical examples on a slightly more complex tree than the
    other papers and articles I have read, so more scenarios can be covered. I will
    also introduce extra terminologies not used in the original paper to better distinguish
    between the different terms.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 确定节点的`y`坐标是简单的，而`x`坐标稍微复杂一些。本文将尝试用数值示例解释算法，树的复杂度略高于我所读过的其他论文和文章，以便涵盖更多场景。我还将介绍一些原论文中没有使用的额外术语，以更好地区分不同的术语。
- en: An important intuition about the algorithm is that it will plot the tree from
    a left-to-right direction. You can think of the leftmost node having a coordinate
    of `(0, 0)`, and the various subtrees will shift rightwards accordingly.
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于算法的一个重要直觉是，它将从左到右绘制树。你可以将最左侧的节点视为`(0, 0)`坐标，各个子树将相应地向右移动。
- en: '**Fun fact**: `scikit-learn` Python library is also using this algorithm to
    plot decision trees!'
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Terminology
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before determining the final coordinates of every node, 3 terms are crucial.
    The original paper references the terms `x` and `mod`, but in my explanation,
    I will use an additional `shift` term for better clarity.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '`**x**` refers to the initial `x` coordinate of the node purely based on the
    node’s position (it is not the final `x` coordinate)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**mod**` refers to the amount of shift for the node’s descendants (but not
    the node itself), to make the children centered with respect to itself'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**shift**` refers to the amount of shift for the node’s descendants, including
    itself, to not overlap with the subtrees to the left of itself'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It may not be very clear now why these 3 terms are needed to determine the final
    `x` coordinate of every node — hopefully, this will be clearer after going through
    the numerical examples. In the following sections, the following tree structure
    will be used to explain the algorithm.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/acc0260e9d3353479bff28c6cb09ccca.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
- en: 'Fig 1: Tree example — Image by author'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: First Pass
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Post-order Traversal of the tree to compute the `x`, `mod`, and `shift` attributes
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In post-order traversal, the tree example will be traversed in alphabetical
    order. There are two parts — Part 1 computes the `x` and `mod` attributes, while
    Part 2 computes the `shift` attribute.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Part 1 of First Pass
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/98fe452458940dfe54510755001ec120.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: 'Fig 2: Tree example with added x attribute (in black) and mod attribute (in
    blue) — Image by author'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, `x` refers to the initial position of the node purely based on
    the node’s position.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: If the node is the leftmost child, `x` will be 0.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For every other node, it will refer to the `x` value of the left sibling and
    add a *sibling distance* to the value.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is an exception to this, if the node is a leftmost child but has children,
    it will try to center itself with respect to the children and set its `x` value
    as the midpoint of its children's `x` values.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the example, we will assume a sibling distance of `1` and notice how the
    `x` attribute of every sibling is exactly sibling distance apart from their left
    sibling. The exception cases are illustrated by the yellow nodes in Fig 2.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: For nodes that are not the leftmost child but have children — they will also
    need to center themselves with respect to their children and will do so using
    the `mod` attribute. The idea is to center the descendants and the amount to shift
    the descendants will be parent `x` minus the midpoint of the children’s `x` values.
    These examples are illustrated by the red nodes in Fig 2\. For example for Node
    `e`, shifting its children `c` and `d` by a value of `1.5` to the right will center
    the children with respect to itself.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: The “final” `x`-coordinates can be easily computed by adding the node’s `x`
    attribute with the sum of the ancestors' `mod` attribute. But we quickly realize
    there are overlaps in the subtrees. For example in the third level, nodes `f`
    and `k` would be overlapping with `x`-coordinates of `3` and `2.5` respectively.
    This will be addressed in Part 2 where the `shift` attribute will be computed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Part 2 of First Pass
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the second part, for every node traversed, we will check for overlaps with
    the subtrees of *all* the left siblings with its subtree. This is also why a post-order
    traversal is performed as it is guaranteed that all left siblings (and their subtrees)
    and the current node’s subtree are already traversed and their `x`, `mod`, and
    `shift` values are known (only the current node’s `shift` value is to be computed).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: To detect overlaps, the rightmost descendant of the left subtree and the leftmost
    descendant of the right subtree is compared at every level. In the paper, this
    is referred to as the *right contour* and *left contour* respectively.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/07d741487f6e08730be6302aae273a06.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: 'Fig 3: Tree example with added shift attribute (in red), subtrees of n and
    g — Image by author'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: For example, when traversing the tree, the following subtrees are compared,
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Node `b` against Node `a` (no overlaps)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node `e` against Nodes `b` and `a` (no overlaps)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node `f` against Nodes `e`, `b`, and `a` (no overlaps)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: so on and so forth…
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The overlap happens when the subtree of Node `n` is compared against the subtree
    of Node `g`. In Fig 3, the right contour of the left subtree is in red, while
    the left contour of the right subtree is in green. The right subtree will be shifted
    such that both subtrees will be separated by a *subtree distance* apart.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: In the example, we will assume a subtree distance of `1` and compare the overlaps
    for each depth.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: In the second depth, the coordinates of `f` and `k` are `3` and `2.5` respectively
    (need to shift `k` to the right by `1.5` to be subtree distance apart from `f`).
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the third depth, the coordinates of `d` and `i` are `2.5` and `2` respectively
    (need to shift `i` to the right by `1.5` to be subtree distance apart from `d`).
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This results in node `n` having to shift rightwards by `1.5` (maximum of the
    shifts from the second and third depth). The `shift` attribute is special as this
    will result in the shifting of the node and its descendants (Node `n` and its
    descendants shift right by `1.5`), and the left and right siblings are also affected.
    Since Node `n` is the second node from the leftmost sibling, Node `h` and its
    descendants will have to shift by `1.5 * (1 / 2) = 0.75`, and Node `q` and its
    descendants will have to shift by `1.5 * (3 / 2) = 2.25` such that all the siblings
    are still centralized with respect to their parent.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3ebaf9b8ad23b7fb985919bc1dbbfbe5.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: 'Fig 4: Tree example with added shift attribute (in red), subtrees of q and
    n — Image by author'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Another overlap happens when comparing the subtree of Node `q` against the subtree
    of Node `n`. The computation here will be elaborated on later in the Relative
    Shifting section of the article. For now, let’s conclude that Node `q` and its
    descendants need to be shifted to the right by `2.25`. Referencing Fig 4, since
    Node `q` is the third node from the leftmost sibling, Node `h` and its descendants
    have to shift by `2.25 * (1 / 3) = 0.75`, and Node `n` and its descendants have
    to shift by `2.25 * (2 / 3) = 1.5` such that all the siblings are still centralized
    with respect to their parent.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Second Pass
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pre-order Traversal of the tree, computing final `x` and `y` values
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/e6ef2c3591dfd2e21a0ab1ea55426f2a.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: 'Fig 5: Tree example with final x and y coordinates — Image by author'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Since all the `x`, `mod`, and `shift` attributes are computed in the first pass,
    these attributes can be summed up to derive the final `x`-coordinate by traversing
    the tree in a top-to-bottom direction by pre-order traversal. Note that the `mod`
    attribute shifts the descendants only, while the `shift` attribute shifts the
    current node and its descendants.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Third Pass
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pre-order Traversal of the tree, adjusting `x` values for any negative cases,
    if any
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: While performing the second pass, any `x` coordinates that are negative due
    to a negative `mod` from the parent can be noted down as an adjustment value and
    handled during the third pass by adding this adjustment value to every node.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Additional Consideration
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Relative Shifting
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Part 2 of the First Pass, the `shift` value was computed in one example by
    comparing the subtrees of Nodes `n` and `g`. It is also mentioned that the `shift`
    will affect the sibling Nodes `h` and `q` as all children have to remain centralized
    with respect to the parent. We can call the shift that affects the siblings a
    *relative shift* as this shift is a result of the direct shift of the right subtree.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Due to this relative shift, there are additional considerations when computing
    the `shift` value between the left and right subtrees as the left subtree will
    be shifted *relatively* later on.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Referencing Fig 4, note that Node `q` is the third node and Node `n` is the
    second node from the leftmost sibling. At the second depth,
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Node `m` will have an intermediate `x` coordinate of 6 (`Node n's mod 2 + Node
    n's shift 1.5 + Node m's x 2.5`).
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node `o` will have an intermediate `x` coordinate of 6.25 (`Node q's mod 4 +
    Node q's shift 2.25`).
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let the shift value be `x` and the subtree distance be `1`. There will be a
    relative shifting whereby Node `m` will be shifted by `(2 / 3) * x` if Node `q`
    is shifted by `x`.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The equation is as such, `(6.25 + x) — (6 + (2 / 3) * x) >= 1`.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving the equation, shift value `x >= 2.25`.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional Parameters
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Subtree separation
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the example above, sibling separation and subtree separation are set to the
    same value. Sibling separation can be differentiated from subtree separation as
    such,
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Sibling separation is used in Part 1 of First Pass and used to determine the
    `x` attribute.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 兄弟节点分隔在第一遍的第1部分中使用，用于确定`x`属性。
- en: Subtree separation is used in Part 2 of First Pass and used to determine the
    `shift` attribute.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子树分隔在第一遍的第2部分中使用，用于确定`shift`属性。
- en: Level separation
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 层级分隔
- en: Level separation can be an additional parameter to determine the distance between
    different levels, and this will be used to determine the `y`-coordinates in the
    second pass.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 层级分隔可以作为一个额外的参数来确定不同层级之间的距离，这将用于确定第二遍中的`y`坐标。
- en: Offset (x-offset, y-offset)
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 偏移（x-offset，y-offset）
- en: Offset parameters can be introduced to shift the whole tree by a constant value
    of `x-offset` and `y-offset` and can be introduced in the second pass when the
    final `x` and `y`-coordinates are computed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 可以引入偏移参数来通过`x-offset`和`y-offset`的常量值来移动整个树，这可以在第二遍中引入，当计算最终的`x`和`y`坐标时。
- en: Python Code Implementation
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python代码实现
- en: I have implemented a Python Code Example of the Reingold Tilford algorithm [here](https://github.com/kayjan/bigtree/blob/master/bigtree/utils/plot.py)
    which follows this article closely, with first, second, and third pass and referencing
    `x`, `mod`, and `shift` attributes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我已实现了一个Python代码示例的Reingold Tilford算法，[这里](https://github.com/kayjan/bigtree/blob/master/bigtree/utils/plot.py)跟随本文
    closely，包括第一、第二和第三遍，并引用了`x`、`mod`和`shift`属性。
- en: Related Links
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关链接
- en: '[1] Official Paper (6 pages, code in Pascal): [https://reingold.co/tidier-drawings.pdf](https://reingold.co/tidier-drawings.pdf)'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[1] 官方论文（6页，Pascal代码）：[https://reingold.co/tidier-drawings.pdf](https://reingold.co/tidier-drawings.pdf)'
- en: 'Explanation (Easiest to read, pseudo-code in C+): [https://rachel53461.wordpress.com/2014/04/20/algorithm-for-drawing-trees/](https://rachel53461.wordpress.com/2014/04/20/algorithm-for-drawing-trees/)'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 说明（最易读，C+伪代码）：[https://rachel53461.wordpress.com/2014/04/20/algorithm-for-drawing-trees/](https://rachel53461.wordpress.com/2014/04/20/algorithm-for-drawing-trees/)
- en: 'Explanation (Good to read next): [https://www.drdobbs.com/positioning-nodes-for-general-trees/184402320?pgno=4](https://www.drdobbs.com/positioning-nodes-for-general-trees/184402320?pgno=4)'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 说明（推荐阅读）：[https://www.drdobbs.com/positioning-nodes-for-general-trees/184402320?pgno=4](https://www.drdobbs.com/positioning-nodes-for-general-trees/184402320?pgno=4)
- en: 'Explanation (With animation of contour and shifting): [https://williamyaoh.com/posts/2023-04-22-drawing-trees-functionally.html](https://williamyaoh.com/posts/2023-04-22-drawing-trees-functionally.html)'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 说明（带有轮廓和偏移动画）：[https://williamyaoh.com/posts/2023-04-22-drawing-trees-functionally.html](https://williamyaoh.com/posts/2023-04-22-drawing-trees-functionally.html)
