- en: A Comprehensive Guide to Using Pandas in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/a-comprehensive-guide-to-using-pandas-in-python-4bc32a14f2ec](https://towardsdatascience.com/a-comprehensive-guide-to-using-pandas-in-python-4bc32a14f2ec)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Learn how to work with one of the most famous data manipulation libraries in
    Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://ivopbernardo.medium.com/?source=post_page-----4bc32a14f2ec--------------------------------)[![Ivo
    Bernardo](../Images/39887b6f3e63a67c0545e87962ad5df0.png)](https://ivopbernardo.medium.com/?source=post_page-----4bc32a14f2ec--------------------------------)[](https://towardsdatascience.com/?source=post_page-----4bc32a14f2ec--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----4bc32a14f2ec--------------------------------)
    [Ivo Bernardo](https://ivopbernardo.medium.com/?source=post_page-----4bc32a14f2ec--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----4bc32a14f2ec--------------------------------)
    ·21 min read·Jul 18, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/47725403daa0167f7868b12b8ce2150f.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [stonewyq](https://unsplash.com/pt-br/@stonewyq) @ Unsplash.com
  prefs: []
  type: TYPE_NORMAL
- en: When you start to work with Python in the context of Data Analysis, Engineering
    or Science, `pandas`is (likely) one of the first libraries that you will have
    to learn about. This incredible library enables you to manipulate two very important
    objects in the Python language — the 1 dimensional `Series` and the two dimensional
    `DataFrame`. These objects are part of a lot of data pipelines and mastering them
    is crucial to start your Pytyon career.
  prefs: []
  type: TYPE_NORMAL
- en: Dataframes are widely used throughout data science and analytics, as they enable
    the creation of multidimensional and multi-type objects. The goal of this post
    is to provide a very complete guide on how to use some famous `pandas` functions
    and how to work with the most important features of the library. Hopefully, after
    reading this guide, you will be ready to work with the most important `pandas`
    eatures. It may also be very common that you are migrating from a SQL background,
    so I’ll try to leave a comparison with SQL code throughout some instructions in
    the post, so that it is easier to compare the instructions between the two frameworks.
    But, keep in mind that knowing SQL is definitely not a requirement to learn `pandas`
    !
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout this post, we’ll use a variety of data to learn about `pandas`,
    namely:'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll build our own `pandas` Series and DataFrames using object creation commands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll work with three datasets containing information about stock prices, available
    here ([https://www.kaggle.com/datasets/rprkh15/sp500-stock-prices](https://www.kaggle.com/datasets/rprkh15/sp500-stock-prices))
    — namely, we’ll use *Ford, Apple* and *Abbvie* stock price data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this post we’ll cover the most famous `pandas` features, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating dataframes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting rows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting columns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining dataframes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plotting data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouping data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chaining functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without further ado, let’s start!
  prefs: []
  type: TYPE_NORMAL
- en: Importing the Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start, we need to import the `pandas` library into our Python environment
    to make sure that we can work with all the functions we will see throughout the
    post.
  prefs: []
  type: TYPE_NORMAL
- en: If you are new to Python, this is a standard in the language. We must import
    external libraries before using them in our code, as external libraries are not
    available on our environment when we install Python (on Windows) or in the base
    version (available on Mac or Ubuntu). This concept of library is pretty common
    in Open Source languages, as it is the main way that the community uses to extend
    the base features of the language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Importing pandas is easy, we just need to run the following code in our Python
    Notebook or executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: And now you must be questioning yourself.. why `pandas as pd` ? Mostly, this
    is done so that we can use the library’s functions using an *alias*. As we will
    need to refer the library name every time we call a function in our code, it will
    be easier to use a shorter *alias* like `pd`. Pandas users commonly use this standard,
    and you see it in a lot of code scattered on the internet.
  prefs: []
  type: TYPE_NORMAL
- en: The Pandas Series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No, Pandas do not have a TV Show!
  prefs: []
  type: TYPE_NORMAL
- en: 'A `pandas` Series is a uni-dimensional object able to store one data type at
    a single time. For example, let’s create a simple `pandas` Series with different
    integers using the `pd.Series` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/805a5e55ad9771b026d51a90980000cb.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of pd.Series command — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me pause here for a moment. `pd.Series` means that we are calling the `Series`
    method from the `pd` (alias for pandas!) library we have loaded in our environment.
    This is a standard syntax in the Python language: *library.method*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our series contains 5 integers: 10, 20, 30, 40, 50\. In the output of our command,
    we also see `dtype: int 64` . By default pandas, stores integers has a 64-bit
    integer, allowing for a larger range of values when defining our numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from integers, we can also store floats in a `pd.Series`by passing numbers
    with decimal places in the `pd.Series`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/e603bffda8a4304d6e945eee8f02f9b4.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of pd.Series command with float numbers — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: Notice that our `dtype` is now `float64` . Any calculation done on top of these
    values will keep the numeric precision. We’ll see that in a bit!
  prefs: []
  type: TYPE_NORMAL
- en: 'Naturally, we can also store strings in a `pd.Series` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/939a50d9799f57cfbbb4f5f3413f1635.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of pd.Series command with strings — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t get too confused but in `pandas`, strings are stored with the *object*
    data type. In fact, most of the data (except time based datatypes, categoricals
    or boolean) that is not either `integers` or `floats` will be stored as an `object`
    data type — for example, defining a `Series` with nested lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/6a2829c23708861d268b53af61a97195.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of pd.Series command with lists — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t master lists in Python, don’t worry too much. This is a pretty
    uncommon operation and I’ve just done this experiment to show you how the `object`
    data type is not exclusive to text data.
  prefs: []
  type: TYPE_NORMAL
- en: 'A caveat — watch out for situations when you try to define a mix of strings
    and numbers in a `pd.Series` , as this turns the entire object into a string (object):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/b9508696d4824b4ad57915b73fb1f7e8.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of pd.Series command with Mixed Data Types — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, we can save our objects using the assignment operator `=`. Let’s
    save this last series in an object named `series_1`, so that we can conveniently
    call `pandas`methods on it later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'One property we can access on our `pd.Series` object is the `dtype` property.
    Accessing the `dtype` will output the data type stored in our Series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/123afd378a7d924f065a9200ad72d83e.png)'
  prefs: []
  type: TYPE_IMG
- en: Data Type Object — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: This will print the type of object our series contains — in the `series_1` example,
    the data type stored in it is `'O'` , for object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this first section of the `pandas` guide, we’ve seen the `pd.Series` , an
    object type that is, in a nutshell:'
  prefs: []
  type: TYPE_NORMAL
- en: '- Series are *unidimensional* objects that can store a single dimension at
    a time.'
  prefs: []
  type: TYPE_NORMAL
- en: '- They can only hold one single data type at a time.'
  prefs: []
  type: TYPE_NORMAL
- en: But.. we still have a lot to cover in our guide! For example, what if we want
    to retrieve specific elements from our `pd.Series`? Can we do that in pandas?
  prefs: []
  type: TYPE_NORMAL
- en: Yes, we can! And to do it, we need to rely on the concept of an *index*, something
    we will see next!
  prefs: []
  type: TYPE_NORMAL
- en: Indexing Series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the neat tricks of `pandas` is that we can attach indexes to our data
    and use a value to retrieve elements from our objects.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let me create a `pandas` series with some *countries* and *capitals:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we have something new on our `series` — the index argument! This
    argument unlocks the ability to give custom indexes to our values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4fd826027b041ae1e2c2539171d3d3ab.png)'
  prefs: []
  type: TYPE_IMG
- en: countries_series object — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: On the left side we have the values for the indexes. On the right side, we have
    the values stored in the `pandas Series` —text values with the capitals of each
    city.
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine that we would like to retrieve the capital of `Portugal`from the
    `countries_series`— before using the named index, one way to do that is to provide
    **the numeric index, in the following way:**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/65f4c9e027968a52fee57e9a856cc789.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of Numeric Indexing Example— Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: Even if we don’t provide any custom index to the `series` , the numeric **indexing
    will always work!**
  prefs: []
  type: TYPE_NORMAL
- en: But, of course, this is not very practical. What if we have 200 countries in
    our table? How can we retrieve the data without having to memorize the 200 indexes?
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, we can also use named indexes to retrieve our data by providing the
    custom index inside the square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/65f4c9e027968a52fee57e9a856cc789.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of Named Indexing Example — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a more meaningful way to extract data from our `pandas` Series. Using
    indexes, we can extract specific data points from our object. Another common technique
    we use `pandas`is using lists to extract multiple elements at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/b3eda564294e50d05c77b50e5f3eeb6e.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of Multiple Numeric Indexing Example — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: In the example above, we are extracting two data points from our `countries_series`
    — the elements on position 1 and 2\. Remember that Python indexes start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'With named indexes, we can also pass multiple elements by passing a list inside
    the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/b3eda564294e50d05c77b50e5f3eeb6e.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of Multiple Numeric Indexing Example — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know the series object is an essential step to understand the staple
    object of pandas — the dataframe! We’ve seen that series object can only store
    data in one dimension and with a single type every time. This is a major setback
    that would prevent us from being productive on our data pipelines and that’s why
    we need to study an object that is a bit more complex! Let’s see that next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating DataFrames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve only dealt with unidimensional and single type objects. This is
    not very practical, of course, particularly when we want to work with more complex
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating dataframes is relatively easy — we can use the `pd.DataFrame` function
    to create one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'My `df_example` contains one column with three integer rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/248e62a244fddc86d0cdff9797d3dd1b.png)'
  prefs: []
  type: TYPE_IMG
- en: Example of DataFrame Object — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'A good thing about dataframes is that they support two dimensional objects
    (rows and columns). Let’s add another column to our data, something that `Series`
    do not support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `df_example` now looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7b07b45ab9be27acfa2cfaf335eaf2e3.png)'
  prefs: []
  type: TYPE_IMG
- en: DataFrame with Two Rows— Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'Uh-oh! Our `pd.DataFrame` command adds data row-by-row. Notice that we passed
    a list of lists with the data: `[[''John'',''Joe'',''Anne''], [24,23,22]]` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two ways to correct this behavior, either we transpose our `DataFrame`
    , or change the data structure we will feed to the `pd.DataFrame` — let’s start
    by transposing the `dataframe` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This operation results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/683d4a0a74446002dfadef1843dd6b71.png)'
  prefs: []
  type: TYPE_IMG
- en: DataFrame with Two Columns — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling the`.T` property of a DataFrame will transpose the object, switching
    the rows with the columns. A more meaningful way to pass data into `pd.DataFrame`
    in this format is to use the power of Python dictionaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an explanation of what this dataframe creates:'
  prefs: []
  type: TYPE_NORMAL
- en: '`students_name` will contain three names: `John` , `Joe` and `Anne` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`age` will contain three ages: 24, 23 and 22.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/85bc412ea9673e3dcc19614bbfe15f72.png)'
  prefs: []
  type: TYPE_IMG
- en: DataFrame with Column Names — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'With this object, we immediately give column names: `students_name` and `age`
    . The column names will take the values of the keys of dictionary we are passing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We know that, in this table, we only have one row per student — it would be
    interesting to have the name of the student as our index, so that we can benefit
    from the index properties available in `pandas` objects. We can do that by declaring
    the student name as an index instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `df_example` has a new look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8ca91086a43c9f195acf5a6e0d58f77e.png)'
  prefs: []
  type: TYPE_IMG
- en: DataFrame with Index — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: Notice that `student_name` is no longer a column but it is being used as an
    index of the object. This means that we can now use all the indexing properties
    we’ve learned before — can you guess what `df_example['John']` will yield?
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/11675c4fcc020e52b9b16dd2d4dd968d.png)'
  prefs: []
  type: TYPE_IMG
- en: Indexing `John` from df_example — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'An error! Why? As DataFrames are multidimensional objects, we are not able
    to index them directly, just like we’ve done with `pd.Series` but we can rely
    on the `loc` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/a2b46c23a815f1403b366ede28bd0d12.png)'
  prefs: []
  type: TYPE_IMG
- en: Indexing `John` from df_example — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also retrieve multiple values from our `DataFrame` by passing a list
    into `loc` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/a4c4151e323e8b86c22a1b1161454fd7.png)'
  prefs: []
  type: TYPE_IMG
- en: Indexing `John` and `Anne` from df_example — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: In the practical example, we’ll see how we can expand selecting and indexing
    values to columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, let’s see how to index our `pandas` DataFrame by numeric index. For
    that, we need to rely on `iloc` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/a2b46c23a815f1403b366ede28bd0d12.png)'
  prefs: []
  type: TYPE_IMG
- en: Indexing `John` from df_example — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: This command will index the first row of our DataFrame and it acts similarly
    to the named version of indexing `df_example.loc['John']` .
  prefs: []
  type: TYPE_NORMAL
- en: We’ve had our introduction to `Series` and `DataFrame` — let’s now dive deeper
    into a more practical example using the stock price data. This will help you understand
    more about pandas and how to use this great library.
  prefs: []
  type: TYPE_NORMAL
- en: Reading CSVs into DataFrames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I’ve detailed in the introduction of the blog post, we’re going to use a
    subset of a Kaggle dataset available [here](https://www.kaggle.com/datasets/rprkh15/sp500-stock-prices).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by reading two *CSV* files into DataFrame objects. This can be
    achieved by accessing the `pd.read_csv` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We’ve created two different data frames called `apple` and `ford` that will
    hold different information for both companies.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s do a small pipeline where we’ll explore the content and structure
    of our newly created objects!
  prefs: []
  type: TYPE_NORMAL
- en: Exploring our Newly Available DataFrames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll look into the `apple` DataFrame. The first thing that
    most people do as soon as they have a dataframe object is to call the `.head()`
    and `.tail()` methods. Let’s see the output of both below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/294470d58046afd16d7a253983178d4b.png)'
  prefs: []
  type: TYPE_IMG
- en: apple DataFrame top 10 rows — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: The `head` command extracts the top *n* rows from a DataFrame and shows it in
    the output. *n* is the integer we pass inside the method of the DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: '`tail` will, as you may have guessed, return the last *n* elements of the DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/c27de34d6b7c8b3a38a079c02b2bbb5d.png)'
  prefs: []
  type: TYPE_IMG
- en: apple DataFrame bottom 10 rows — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: These two commands are analogous to sorting tables in SQL and calling `LIMIT`
    . For instance, a query ``SELECT * FROM `APPLE` LIMIT 10`` would achieve the same
    result (assuming the rows are sorted by date).
  prefs: []
  type: TYPE_NORMAL
- en: 'When we have a DataFrame, it’s extremely usual to understand it’s structure
    by using some neat `pandas` properties. Let’s detail some of them below:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.shape` method that gives us the number of rows and columns, in the format
    of *(number of rows, number of columns)*. For example `apple.shape` will give
    us the information that our DataFrame contains 10.483 rows and 8 columns:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/1a8a7ade80dff8f0bd961d4407764217.png)'
  prefs: []
  type: TYPE_IMG
- en: apple DataFrame shape
  prefs: []
  type: TYPE_NORMAL
- en: '`.columns` will give us a list of our column names:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/edda411f3c9dae3ae0d50ca51181af3b.png)'
  prefs: []
  type: TYPE_IMG
- en: apple DataFrame column names
  prefs: []
  type: TYPE_NORMAL
- en: '`.index` will give us a name of our indexes (row names):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/82c0020629d15e22c87122ce0387c0f1.png)'
  prefs: []
  type: TYPE_IMG
- en: apple DataFrame row names
  prefs: []
  type: TYPE_NORMAL
- en: We haven’t provided an index to our DataFrame (it’s still using the automatic
    numeric index created by the `read.csv` function). We’ll learn how to assign meaningful
    named indexes in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: '`.describe()` gives us a cool overview of all numeric columns:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/0804a02fcd94440bacbb982a9e9c6d1c.png)'
  prefs: []
  type: TYPE_IMG
- en: pandas Describe command — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: The `describe`method outputs important statistics about our numeric columns
    such as the average, standard deviation, minimum, quantile data and maximum of
    the distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to take a peek at the values of a certain column, you can select
    the column directly — there are two main ways to do this in pandas:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using indexing, we pass the name of the column inside the square brackets (similarly
    to how we select rows in pd.Series):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/0b595da4ba109159a6a948869755a6e1.png)'
  prefs: []
  type: TYPE_IMG
- en: apple Volume column — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the dot notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/0b595da4ba109159a6a948869755a6e1.png)'
  prefs: []
  type: TYPE_IMG
- en: apple Volume column — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'Python programmers tend to prefer the indexing method for two main reasons:
    it’s hard to pass the column name as a parameter in the dot notation and the latter
    does not support columns with blank spaces in the name.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Oh, and want to retrieve an average or a standard deviation from a specific
    `pandas` column really fast? Just call the method on top of the object! For example,
    to calculate the `mean` Volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/d9a1a8af147783a4ccc1f8ebf6a8f6ef.png)'
  prefs: []
  type: TYPE_IMG
- en: apple Volume mean — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a complex pandas DataFrame with multiple columns and rows,
    let’s learn how we can subset information expanding our knowledge with `iloc`
    and `loc`
  prefs: []
  type: TYPE_NORMAL
- en: Subsetting Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More than explaining you every nuance of the indexing methods in Pandas, in
    this section we will answer questions about our data with code! In this way, you
    will be able to practice the translation between natural language and indexing
    methods that can be used in the library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by trying to select the rows that will answer some questions:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Can we select the days where Apple’s closing stock price was higher than $20?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can answer this question by providing `apple.loc[apple[‘Close''] > 20]`
    .This code will output all days that respect this condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/25dc10f1fba202927cd054cd9b31e01a.png)'
  prefs: []
  type: TYPE_IMG
- en: apple data subset — days with Closing Stock Price above 20$— Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: This is a really feature that we can achieve by using `.loc` . Notice that inside
    the loc we now pass our condition`apple[‘Close'] > 20` and the output will respect
    that condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'But.. what if I want to subset a range of values, for example: *Can we select
    the days where Apple’s closing stock price was between 20$ and 30$?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can achieve that by wrapping our conditions in parenthesis inside the `.loc`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '`apple.loc[(apple[‘Close''] > 20) & (apple[‘Close''] < 30)]`'
  prefs: []
  type: TYPE_NORMAL
- en: The ampersand `(&)`connects our conditions with an AND condition, while the
    pipe symbol`(|)`is used for OR conditions.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/148f980d559b75dc27f5326a7fdf79d3.png)'
  prefs: []
  type: TYPE_IMG
- en: apple data subset — days with Closing Stock Price above 20$ and below 30$ —
    Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me translate the conditions above into SQL-like code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On `apple.loc[apple[‘Close''] > 20]` , we are doing something similar to this
    query: `SELECT * FROM ''apple'' WHERE Close > 20` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On `apple.loc[(apple[‘Close''] > 20) & (apple[‘Close''] < 30)]` , we are doing
    something similar to this query: `SELECT * FROM ''apple'' WHERE Close > 20 AND
    Close < 30`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can also retrieve specific columns from our multidimensional object using
    a magic trick. Just by adding a comma in the `.loc` , we can subset columns (that
    are considered the second dimension of the object):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/f43438dc218f819621ea1964900633a8.png)'
  prefs: []
  type: TYPE_IMG
- en: apple data subset — Volume from days where stock price was above 20$ — Image
    by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'Above, we are answering the question: *What is the Volume of the days where
    Apple’s closing stock price was higher than $20?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Translating this into SQL: `SELECT Volume FROM ''apple'' WHERE Close > 20`
    .'
  prefs: []
  type: TYPE_NORMAL
- en: But, what if we want multiple columns? Can you guess how to change the `pandas`
    code above?
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: List indexing!'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/749061cf1c569b7eefde33caf3426a65.png)'
  prefs: []
  type: TYPE_IMG
- en: apple data subset — Volume and Close from days where stock price was above 20$—
    Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: Another common wrangling operation consists of grouping data. Let’s see how
    we can do that in the next section!
  prefs: []
  type: TYPE_NORMAL
- en: Grouping Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Right now, my data is too granular — I would like to extract the average price
    per year of `apple` and `ford` stock price. To do that, we need to do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new column that will contain the year extracted from the `Date`column.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extract the mean of the `Close` price grouped by year column.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have an issue with the `Date` column — why? Because, right now, it is being
    considered an `Object` column as we can see by calling the `.dtypes` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/b2add89e45374da1a3d29ca929e56012.png)'
  prefs: []
  type: TYPE_IMG
- en: apple DataFrame data types — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: Although we can perform a substring operation to extract year, it would be better
    to use datetime properties to extract information from this Date. Let me introduce
    another data type available in `pandas` — the `datetime` !
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert an object into `datetime` , we can call the `to_datetime` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the argument of the `to_datetime` function, we can pass the column(s) that
    we want to convert to date. Notice that we can convert this column because it
    has a format expected by `pandas` dates (more information about formats in the
    official documentation of the [library](https://pandas.pydata.org/docs/reference/api/pandas.to_datetime.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the returning object `dtype` changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7b89d3343c33b827c35125b796ed25f2.png)'
  prefs: []
  type: TYPE_IMG
- en: Datetime Conversion — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'Having this `datetime`object, we can access `dt`properties and conveniently
    extract the year using `.dt.year`. Let’s try that below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/480c1083f53bd1cc599454dd45cb9b2d.png)'
  prefs: []
  type: TYPE_IMG
- en: Year Column — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'But, how can we add this column to our existing DataFrame? That’s super easy
    — we just assign it to something that does not exist (yet!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a new column in our apple DataFrame named `Year`, containing
    the extracted year from the `Date`column.:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/13f9bd81787505eed1ae5bcbf9295ce9.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating Year Column — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: First part of our process is completed! Now, let’s go for the second part, where
    we will produce an average of the `Close` price by `Year` — that sounds difficult,
    right?
  prefs: []
  type: TYPE_NORMAL
- en: But it is not! As you probably guessed, things in `pandas` are super simple,
    after getting the hang of how the library works. First, we need to call the `groupby`
    method that enables us to.. well.. group by a column!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `groupby` method does not output anything (other than a generic method
    output), it just prepares `pandas` to receive something that will be grouped by
    the column in the argument. After generating the `groupby` object, we can pass
    the column that we want to aggregate and the metric:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/4c6a3f78216bfb2a28bf8793097e47cc.png)'
  prefs: []
  type: TYPE_IMG
- en: First rows of generated group by Object — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also do other calculations with other functions — for example, extracting
    the max per group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/eb939a49e4f97dadde3af4be63ee6654.png)'
  prefs: []
  type: TYPE_IMG
- en: First rows of generated group by Object — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'This last instruction can be translated into the following SQL query: `SELECT
    Year, max(Close) as max_close from apple group by Year` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also perform aggregations on multiple columns at the same time, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0ab045a97697e99dc2222ae38174d11e.png)'
  prefs: []
  type: TYPE_IMG
- en: Extracting the max from Close and Volume columns — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on to the Combining tables section, let’s create two aggregated
    tables with information about the Dividends per share paid by each company after
    the year 2000:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Ok, let’s take this last instruction a bit slow as we are compounding on a
    couple of things we’ve learned throughout the blog post:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are filtering our data for every row after 2000: `apple.loc[apple.Year
    >= 2000]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will return a DataFrame where we can apply `groupby` and `sum`later, using
    `groupby(['Year'])['Dividends'].sum()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s visualize our `apple_dividends` DataFrame (?):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/777363d210af98c6a6a1cf06813e8a69.png)'
  prefs: []
  type: TYPE_IMG
- en: pandas grouped by Series— Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'When we perform group by operations that return a single column, we output
    a `pd.Series` and not a DataFrame. We can explicitly convert the object into a
    `DataFrame` by wrapping it into a `pd.DataFrame` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in DataFrame format — looking at the `apple_dividends` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/148440bd9d684d84737a25918e7f49ff.png)'
  prefs: []
  type: TYPE_IMG
- en: pandas grouped by object — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: It would be interesting to combine these DataFrames into a single object. That’s
    something we will take care of in the next section!
  prefs: []
  type: TYPE_NORMAL
- en: Combining Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, I’m going to show you how to combine DataFrames in multiple
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Vertically, by stacking or appending them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Horizontally by using a join.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, let’s learn how to stack tables vertically (similarly to a `UNION` operator)
    — we can do that by providing `pd.concat` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a DataFrame with the dividend data for both companies. In
    the current format, it will be hard to understand which company the row refers
    to. An alternative is to create a new column in the original DataFrames that state
    the name of the company:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/7cb2e9f0607e8d2352e0e3e8ac65b4f5.png)'
  prefs: []
  type: TYPE_IMG
- en: Sample of combined apple and ford dividends data — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'The indexes repeat themselves, which may be weird, although it may come in
    handy when indexing data from the same year:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/4dee9677f5acbd0b89c36963de8cbd10.png)'
  prefs: []
  type: TYPE_IMG
- en: Subset of 2015 data — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'We could also prefer to have this data with two time series side by side. To
    do that, we have to change our original data a bit and think about the process
    in the context of a table join. If we want to keep the `year` as index, we can
    use the `merge` function to combine the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/2590097157261ae701e4e1ba9ed74274.png)'
  prefs: []
  type: TYPE_IMG
- en: Joined Dividends Data — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'The example above is similar to doing the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As `pandas`does not support two columns with the same name during a merge, Python
    automatically adds an _x or _y suffix to differentiate the columns based on their
    origin in the tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can also use the convenient `on` argument, that supports
    joins by any column. To have our `Year` as column, we can reset the index of both
    tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Pay attention to the `inplace=True` in this query. This is a very important
    property in Python! Some operations may be done inplace, meaning that the object
    is changed dynamically, without a need to reassign it. In the example above, we
    just reset the index of both tables, turning the Year into a column:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/43f876040387945e76428b41ac81519d.png)'
  prefs: []
  type: TYPE_IMG
- en: Index Reset example — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can use the `Year` in the merge function, explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/6957bbfa7d582252116132ccf7f6a9da.png)'
  prefs: []
  type: TYPE_IMG
- en: Joined Dividends Data by column — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: This may be useful if you want to combine data by a specific column that does
    not belong to the index of the DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: Having our «table saved, let’s finish this blog post by looking at some simple
    `pandas` plotting capabilities!
  prefs: []
  type: TYPE_NORMAL
- en: Plotting Capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`pandas` contains an awesome integration with Python `matplotlib` . A cool
    way to plot data is just to call `.plot()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/0a598bbad8d737ec1b54df104235d061.png)'
  prefs: []
  type: TYPE_IMG
- en: Apple’s Dividends Plot — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'And if I call a plot on both pandas series, they will show up in the same plot
    at the same time, enabling us to compare the dividends of both companies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/354d6c8a104576718a51f9f4d57cfd33.png)'
  prefs: []
  type: TYPE_IMG
- en: Ford and Apple’s Dividends Plot — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: This plot is still a bit incomplete — we don’t have any title, axis legend,
    x-axis label or indication of which company each line refers to. Can we improve
    it using the `.plot()` function?
  prefs: []
  type: TYPE_NORMAL
- en: 'For sure! Instead of calling the `.plot` method on the column, we can call
    it method on the entire DataFrame and control `x` and `y` axis based on that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: There are some properties that we can’t change on the `.plot()` method. For
    example, adding a custom legend to the lines must be done using the `matplotlib`
    library, by calling `plt.legend()` after creating our plot.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3d3818627777839473e0640352819b87.png)'
  prefs: []
  type: TYPE_IMG
- en: Ford and Apple’s Dividends Plot — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also change the type of plot by using the `kind` argument — for example,
    let’s view the dividends in a bar plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/3f01fbeab0d0d5c37973d8761a5a95b9.png)'
  prefs: []
  type: TYPE_IMG
- en: Ford and Apple’s Dividends Bar Plot — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: Although limited, `pandas` plotting capabilities add an extra flavor to the
    library’s features and it is very handy, particularly for plots related to a quick
    exploratory analysis of the data. The downside of using the `pandas` plotting
    API is that there are multiple `matplotlib` features that aren’t available, so
    it is normal that we import the two libraries, particularly when we want to create
    more complex plots.
  prefs: []
  type: TYPE_NORMAL
- en: And that’s it! Thank you for taking the time to read this post and I hope you’ve
    enjoyed learning about pandas.
  prefs: []
  type: TYPE_NORMAL
- en: This library is a must for every professional or student that wants to work
    with DataFrames inside Python. Getting to know this object will also be very important
    for working with other frameworks (such as spark) or languages (such as R). Using
    `pandas`has become a very crucial skill for data scientists, engineers and analysts.
    I do believe that `pandas` will continue to be used throughout the next decade,
    as it is already engrained in a lot of data science pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the downside, there’s a couple of limitations of `pandas` , namely:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Memory Usage: Pandas may have a bad performance for large and diverse DataFrames.
    Other frameworks like `PySpark` may be more suited for these operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mutability: For people that never worked with Python, the mutability property
    may be confusing, at first. Handing mutability incorrectly is one of the most
    common mistakes peopl make when working with the library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not able to deal with unstructured data. Although pandas may support lists or
    dictionaries as column, storing unstructured data inside it is a massive headache
    and a process that is error prone.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a summary, let’s detail some of the topics that we’ve approached during
    the blog post:'
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with the unidimensional `pandas`object, the `Series`, an object that
    works similarly to R vectors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating, indexing and doing all sorts of operations with the main `pandas`
    object, the `DataFrame`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read external objects, such as CSV files into `DataFrame`objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining different `DataFrames`, both vertically (append) and horizontally
    (joining data).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plotting data using the `matplotlib` API in `pandas`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After reading this post, I recommend that you read the `pandas`official documentation
    and experiment with a few functions that we haven’t covered in the blog post,
    such as [windowing operations](https://pandas.pydata.org/docs/user_guide/window.html)
    or [DataFrame reshaping](https://pandas.pydata.org/docs/user_guide/reshaping.html).
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, if you are on the path towards becoming a data scientists, you
    may find it relevant to learn about [NumPy](https://numpy.org/), [Matplotlib](https://matplotlib.org/),
    [scikit-learn](https://scikit-learn.org/stable/) or [PySpark](https://spark.apache.org/docs/latest/api/python/).
  prefs: []
  type: TYPE_NORMAL
- en: Do you think I’m missing something in this Comprehensive Guide? Let me know
    in the comments below so I can add it!
  prefs: []
  type: TYPE_NORMAL
- en: '*If you would like to drop by my Python courses, feel free to join* ***my free
    course*** *here (*[*Python For Busy People — Python Introduction in 2 Hours*](https://www.udemy.com/course/python-for-busy-people-python-introduction-2-hours/?referralCode=1588B6BF72D40253CDD4)*)*
    ***or a longer 16 hour version*** *(*[*The Complete Python Bootcamp for Beginners*](https://www.udemy.com/course/the-python-for-absolute-beginners-bootcamp/?couponCode=MEDIUMJULY)*)
    where you have a 30-day refund policy if it’s not a fit for you. My Python courses
    are suitable for beginners/mid-level developers and I would love to have you on
    my class!*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/92d3f3ac73c061a7abf0aee526aaca95.png)'
  prefs: []
  type: TYPE_IMG
- en: '[Python for Absolute Beginners Course](https://www.udemy.com/course/the-python-for-absolute-beginners-bootcamp/?couponCode=MEDIUMJULY)
    — Image by Author'
  prefs: []
  type: TYPE_NORMAL
- en: '*The dataset used on this post is licensed under a* [*Creative Commons Attribution
    CC0 Public Domain.*](https://creativecommons.org/licenses/by/4.0/legalcode)'
  prefs: []
  type: TYPE_NORMAL
