["```py\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom catboost import CatBoostRegressor\nsns.set()\n\n# Number of training and testing examples\nn = 1000\n\n# Generate random x values between 0 and 1\nx_train = np.random.rand(n)\nx_test = np.random.rand(n)\n\n# Generate random noise for the target\nnoise_train = np.random.normal(0, 0.3, n)\nnoise_test = np.random.normal(0, 0.3, n)\n\n# Set the slope and y-intercept of the line\na, b = 2, 3\n\n# Generate y values according to the equation y = ax + b + noise\ny_train = a * x_train + b + noise_train\ny_test = a * x_test + b + noise_test\n```", "```py\n# Store quantiles 0.01 through 0.99 in a list\nquantiles = [q/100 for q in range(1, 100)]\n\n# Format the quantiles as a string for Catboost\nquantile_str = str(quantiles).replace('[','').replace(']','')\n\n# Fit the multi quantile model\nmodel = CatBoostRegressor(iterations=100,\n                          loss_function=f'MultiQuantile:alpha={quantile_str}')\n\nmodel.fit(x_train.reshape(-1,1), y_train)\n\n# Make predictions on the test set\npreds = model.predict(x_test.reshape(-1, 1))\npreds = pd.DataFrame(preds, columns=[f'pred_{q}' for q in quantiles])\n```", "```py\nfig, ax = plt.subplots(figsize=(10, 6))\nax.scatter(x_test, y_test)\n\nfor col in ['pred_0.05', 'pred_0.5', 'pred_0.95']:\n    ax.scatter(x_test.reshape(-1,1), preds[col], alpha=0.50, label=col)\n\nax.legend()\n```", "```py\ncoverage_90 = np.mean((y_test <= preds['pred_0.95']) & (y_test >= preds['pred_0.05']))*100\nprint(coverage_90) \n# Output: 91.4\n```", "```py\n# Give the model a new input of x = 0.4\nx = np.array([0.4])\n\n# We expect the mean of this array to be about 2*0.4 + 3 = 3.8\n# We expect the standard deviation of this array to be about 0.30\ny_pred = model.predict(x.reshape(-1, 1))\n\nmu = np.mean(y_pred)\nsigma = np.std(y_pred)\nprint(mu) # Output: 3.836147287742427\nprint(sigma) # Output: 0.3283984093786787\n\n# Plot the predicted distribution\nfig, ax = plt.subplots(figsize=(10, 6))\n_ = ax.hist(y_pred.reshape(-1,1), density=True)\nax.set_xlabel('$y$')\nax.set_title(f'Predicted Distribution $P(y|x=4)$, $\\mu$ = {round(mu, 3)}, $\\sigma$ = {round(sigma, 3)}')\n```", "```py\n# Create regions of the domain that have variable noise\nbounds = [(-10, -8), (-5, -4), (-4, -3), (-3, -1), (-1, 1), (1, 3), (3, 4), (4, 5), (8, 10)]\nscales = [18, 15, 8, 11, 1, 2, 9, 16, 19]\n\nx_train = np.array([])\nx_test = np.array([])\ny_train = np.array([])\ny_test = np.array([])\n\nfor b, scale in zip(bounds, scales):\n\n    # Randomly select the number of samples in each region \n    n = np.random.randint(low=100, high = 200)\n\n    # Generate values of the domain between b[0] and b[1]\n    x_curr = np.linspace(b[0], b[1], n)\n\n    # For even scales, noise comes from an exponential distribution\n    if scale % 2 == 0:\n\n        noise_train = np.random.exponential(scale=scale, size=n)\n        noise_test = np.random.exponential(scale=scale, size=n)\n\n    # For odd scales, noise comes from a normal distribution\n    else:\n\n        noise_train = np.random.normal(scale=scale, size=n)\n        noise_test = np.random.normal(scale=scale, size=n)\n\n    # Create training and testing sets\n    y_curr_train = x_curr**2  + noise_train\n    y_curr_test = x_curr**2  + noise_test\n\n    x_train = np.concatenate([x_train, x_curr])\n    x_test = np.concatenate([x_test, x_curr])\n    y_train = np.concatenate([y_train, y_curr_train])\n    y_test = np.concatenate([y_test, y_curr_test])\n```", "```py\nmodel = CatBoostRegressor(iterations=300,\n                          loss_function=f'MultiQuantile:alpha={quantile_str}')\n\nmodel.fit(x_train.reshape(-1,1), y_train)\n\npreds = model.predict(x_test.reshape(-1, 1))\npreds = pd.DataFrame(preds, columns=[f'pred_{q}' for q in quantiles])\n\nfig, ax = plt.subplots(figsize=(10, 6))\nax.scatter(x_test, y_test)\n\nfor col in ['pred_0.05', 'pred_0.5', 'pred_0.95']:\n\n    quantile = int(float(col.split('_')[-1])*100)\n    label_name = f'Predicted Quantile {quantile}'\n    ax.scatter(x_test.reshape(-1,1), preds[col], alpha=0.50, label=label_name)\n\nax.set_xlabel('x')\nax.set_ylabel('y')\nax.set_title('Testing Data for Example 2 with Predicted Quantiles')\nax.legend()\n```", "```py\ncoverage_90 = np.mean((y_test <= preds['pred_0.95']) & (y_test >= preds['pred_0.05']))*100\nprint(coverage_90) \n# Output: 90.506\n```"]