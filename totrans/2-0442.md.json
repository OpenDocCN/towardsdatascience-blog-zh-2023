["```py\nfrom langchain.chains import ConversationChain\n\n# Create conversation chain\nconversation = ConversationChain(memory, prompt, llm)\n\n# Run conversation chain\nconversation.predict(input=\"Hi there!\")\n\n# Obtain the LLM response: \"Hello! How can I assist you today?\"\n\n# We can keep calling conversation chain\nconversation.predict(input=\"I'm doing well! Just having a conversation with an AI.\")\n# Obtain the LLM response: \"That sounds like fun! I'm happy to chat with you. Is there anything specific you'd like to talk about?\"\n```", "```py\nimport os\nimport openai\nfrom langchain.prompts import (\n    ChatPromptTemplate, \n    MessagesPlaceholder, \n    SystemMessagePromptTemplate, \n    HumanMessagePromptTemplate\n)\nfrom langchain.prompts import PromptTemplate\nfrom langchain.chains import LLMChain\nfrom langchain.chains import ConversationChain\nfrom langchain.chat_models import ChatOpenAI\nfrom langchain.memory import ConversationBufferMemory\n```", "```py\nclass Chatbot:\n    \"\"\"Class definition for a single chatbot with memory, created with LangChain.\"\"\"\n\n    def __init__(self, engine):\n        \"\"\"Select backbone large language model, as well as instantiate \n        the memory for creating language chain in LangChain.\n        \"\"\"\n\n        # Instantiate llm\n        if engine == 'OpenAI':\n            # Reminder: need to set up openAI API key \n            # (e.g., via environment variable OPENAI_API_KEY)\n            self.llm = ChatOpenAI(\n                model_name=\"gpt-3.5-turbo\",\n                temperature=0.7\n            )\n\n        else:\n            raise KeyError(\"Currently unsupported chat model type!\")\n\n        # Instantiate memory\n        self.memory = ConversationBufferMemory(return_messages=True)\n```", "```py\ndef instruct(self, role, oppo_role, language, scenario, \n             session_length, proficiency_level, \n             learning_mode, starter=False):\n    \"\"\"Determine the context of chatbot interaction. \n    \"\"\"\n\n    # Define language settings\n    self.role = role\n    self.oppo_role = oppo_role\n    self.language = language\n    self.scenario = scenario\n    self.session_length = session_length\n    self.proficiency_level = proficiency_level\n    self.learning_mode = learning_mode\n    self.starter = starter\n\n    # Define prompt template\n    prompt = ChatPromptTemplate.from_messages([\n        SystemMessagePromptTemplate.from_template(self._specify_system_message()),\n        MessagesPlaceholder(variable_name=\"history\"),\n        HumanMessagePromptTemplate.from_template(\"{input}\")\n    ])\n\n    # Create conversation chain\n    self.conversation = ConversationChain(memory=self.memory, prompt=prompt, \n                                          llm=self.llm, verbose=False)\n```", "```py\nself.role = {'name': 'Customer', 'action': 'ordering food'}\n```", "```py\ndef _specify_system_message(self):\n    \"\"\"Specify the behavior of the chatbot, which consists of the following\n       aspects:\n\n    - general context: conducting conversation/debate under given scenario\n    - the language spoken\n    - purpose of the simulated conversation/debate\n    - language complexity requirement\n    - exchange length requirement\n    - other nuance constraints\n\n    Outputs:\n    --------\n    prompt: instructions for the chatbot.\n    \"\"\" \n```", "```py\n# Determine the number of exchanges between two bots\nexchange_counts_dict = {\n    'Short': {'Conversation': 8, 'Debate': 4},\n    'Long': {'Conversation': 16, 'Debate': 8}\n}\nexchange_counts = exchange_counts_dict[self.session_length][self.learning_mode]\n```", "```py\n# Determine number of sentences in one debate round\nargument_num_dict = {\n    'Beginner': 4,\n    'Intermediate': 6,\n    'Advanced': 8\n} \n```", "```py\nif self.proficiency_level == 'Beginner':\n    lang_requirement = \"\"\"use as basic and simple vocabulary and\n    sentence structures as possible. Must avoid idioms, slang, \n    and complex grammatical constructs.\"\"\"\n\nelif self.proficiency_level == 'Intermediate':\n    lang_requirement = \"\"\"use a wider range of vocabulary and a variety of sentence structures. \n    You can include some idioms and colloquial expressions, \n    but avoid highly technical language or complex literary expressions.\"\"\"\n\nelif self.proficiency_level == 'Advanced':\n    lang_requirement = \"\"\"use sophisticated vocabulary, complex sentence structures, idioms, \n    colloquial expressions, and technical language where appropriate.\"\"\"\n\nelse:\n    raise KeyError('Currently unsupported proficiency level!')\n```", "```py\n# Compile bot instructions \nif self.learning_mode == 'Conversation':\n    prompt = f\"\"\"You are an AI that is good at role-playing. \n    You are simulating a typical conversation happened {self.scenario}. \n    In this scenario, you are playing as a {self.role['name']} {self.role['action']}, speaking to a \n    {self.oppo_role['name']} {self.oppo_role['action']}.\n    Your conversation should only be conducted in {self.language}. Do not translate.\n    This simulated {self.learning_mode} is designed for {self.language} language learners to learn real-life \n    conversations in {self.language}. You should assume the learners' proficiency level in \n    {self.language} is {self.proficiency_level}. Therefore, you should {lang_requirement}.\n    You should finish the conversation within {exchange_counts} exchanges with the {self.oppo_role['name']}. \n    Make your conversation with {self.oppo_role['name']} natural and typical in the considered scenario in \n    {self.language} cultural.\"\"\"\n\nelif self.learning_mode == 'Debate':\n    prompt = f\"\"\"You are an AI that is good at debating. \n    You are now engaged in a debate with the following topic: {self.scenario}. \n    In this debate, you are taking on the role of a {self.role['name']}. \n    Always remember your stances in the debate.\n    Your debate should only be conducted in {self.language}. Do not translate.\n    This simulated debate is designed for {self.language} language learners to \n    learn {self.language}. You should assume the learners' proficiency level in {self.language} \n    is {self.proficiency_level}. Therefore, you should {lang_requirement}.\n    You will exchange opinions with another AI (who plays the {self.oppo_role['name']} role) \n    {exchange_counts} times. \n    Everytime you speak, you can only speak no more than \n    {argument_num_dict[self.proficiency_level]} sentences.\"\"\"\n\nelse:\n    raise KeyError('Currently unsupported learning mode!')\n```", "```py\n# Give bot instructions\nif self.starter:\n    # In case the current bot is the first one to speak\n    prompt += f\"You are leading the {self.learning_mode}. \\n\"\n\nelse:\n    # In case the current bot is the second one to speak\n    prompt += f\"Wait for the {self.oppo_role['name']}'s statement.\"\n```", "```py\nclass DualChatbot:\n    \"\"\"Class definition for dual-chatbots interaction system, \n      created with LangChain.\"\"\"\n\n    def __init__(self, engine, role_dict, language, scenario, proficiency_level, \n                 learning_mode, session_length):\n\n        # Instantiate two chatbots\n        self.engine = engine\n        self.proficiency_level = proficiency_level\n        self.language = language\n        self.chatbots = role_dict\n        for k in role_dict.keys():\n            self.chatbots[k].update({'chatbot': Chatbot(engine)})\n\n        # Assigning roles for two chatbots\n        self.chatbots['role1']['chatbot'].instruct(role=self.chatbots['role1'], \n                                                   oppo_role=self.chatbots['role2'], \n                                                   language=language, scenario=scenario, \n                                                   session_length=session_length, \n                                                   proficiency_level=proficiency_level, \n                                                   learning_mode=learning_mode, starter=True)\n\n        self.chatbots['role2']['chatbot'].instruct(role=self.chatbots['role2'], \n                                                   oppo_role=self.chatbots['role1'], \n                                                   language=language, scenario=scenario, \n                                                   session_length=session_length, \n                                                   proficiency_level=proficiency_level, \n                                                   learning_mode=learning_mode, starter=False) \n\n        # Add session length\n        self.session_length = session_length\n\n        # Prepare conversation\n        self._reset_conversation_history()\n```", "```py\n# For \"conversation\" mode\nself.chatbots= {\n                'role1': {'name': 'Customer', \n                          'action': 'ordering food',\n                          'chatbot': Chatbot()},\n                'role2': {'name': 'Waitstaff', \n                          'action': 'taking the order',\n                          'chatbot': Chatbot()}\n              }\n\n# For \"debate\" mode\nself.chatbots= {\n                'role1': {'name': 'Proponent', \n                          'chatbot': Chatbot()},\n                'role2': {'name': 'Opponent', \n                          'chatbot': Chatbot()}\n              }\n```", "```py\ndef _reset_conversation_history(self):\n    \"\"\"Reset the conversation history.\n    \"\"\"    \n    # Placeholder for conversation history\n    self.conversation_history = []\n\n    # Inputs for two chatbots\n    self.input1 = \"Start the conversation.\"\n    self.input2 = \"\" \n```", "```py\ndef step(self):\n    \"\"\"Make one exchange round between two chatbots. \n    \"\"\"        \n\n    # Chatbot1 speaks\n    output1 = self.chatbots['role1']['chatbot'].conversation.predict(input=self.input1)\n    self.conversation_history.append({\"bot\": self.chatbots['role1']['name'], \"text\": output1})\n\n    # Pass output of chatbot1 as input to chatbot2\n    self.input2 = output1\n\n    # Chatbot2 speaks\n    output2 = self.chatbots['role2']['chatbot'].conversation.predict(input=self.input2)\n    self.conversation_history.append({\"bot\": self.chatbots['role2']['name'], \"text\": output2})\n\n    # Pass output of chatbot2 as input to chatbot1\n    self.input1 = output2\n\n    # Translate responses\n    translate1 = self.translate(output1)\n    translate2 = self.translate(output2)\n\n    return output1, output2, translate1, translate2\n```", "```py\n def translate(self, message):\n      \"\"\"Translate the generated script into English. \n      \"\"\"        \n\n      if self.language == 'English':\n          # No translation performed\n          translation = 'Translation: ' + message\n\n      else:\n          # Instantiate translator\n          if self.engine == 'OpenAI':\n              # Reminder: need to set up openAI API key \n              # (e.g., via environment variable OPENAI_API_KEY)\n              self.translator = ChatOpenAI(\n                  model_name=\"gpt-3.5-turbo\",\n                  temperature=0.7\n              )\n\n          else:\n              raise KeyError(\"Currently unsupported translation model type!\")\n\n          # Specify instruction\n          instruction = \"\"\"Translate the following sentence from {src_lang} \n          (source language) to {trg_lang} (target language).\n          Here is the sentence in source language: \\n\n          {src_input}.\"\"\"\n\n          prompt = PromptTemplate(\n              input_variables=[\"src_lang\", \"trg_lang\", \"src_input\"],\n              template=instruction,\n          )\n\n          # Create a language chain\n          translator_chain = LLMChain(llm=self.translator, prompt=prompt)\n          translation = translator_chain.predict(src_lang=self.language,\n                                              trg_lang=\"English\",\n                                              src_input=message)\n\n      return translation\n```", "```py\ndef summary(self, script):\n    \"\"\"Distill key language learning points from the generated scripts. \n    \"\"\"  \n\n    # Instantiate summary bot\n    if self.engine == 'OpenAI':\n        # Reminder: need to set up openAI API key \n        # (e.g., via environment variable OPENAI_API_KEY)\n        self.summary_bot = ChatOpenAI(\n            model_name=\"gpt-3.5-turbo\",\n            temperature=0.7\n        )\n\n    else:\n        raise KeyError(\"Currently unsupported summary model type!\")\n\n    # Specify instruction\n    instruction = \"\"\"The following text is a simulated conversation in \n    {src_lang}. The goal of this text is to aid {src_lang} learners to learn\n    real-life usage of {src_lang}. Therefore, your task is to summarize the key \n    learning points based on the given text. Specifically, you should summarize \n    the key vocabulary, grammar points, and function phrases that could be important \n    for students learning {src_lang}. Your summary should be conducted in English, but\n    use examples from the text in the original language where appropriate.\n    Remember your target students have a proficiency level of \n    {proficiency} in {src_lang}. You summarization must match with their \n    proficiency level. \n\n    The conversation is: \\n\n    {script}.\"\"\"\n\n    prompt = PromptTemplate(\n        input_variables=[\"src_lang\", \"proficiency\", \"script\"],\n        template=instruction,\n    )\n\n    # Create a language chain\n    summary_chain = LLMChain(llm=self.summary_bot, prompt=prompt)\n    summary = summary_chain.predict(src_lang=self.language,\n                                    proficiency=self.proficiency_level,\n                                    script=script)\n\n    return summary\n```", "```py\nimport streamlit as st\nfrom streamlit_chat import message\nfrom chatbot import DualChatbot\nimport time\nfrom gtts import gTTS\nfrom io import BytesIO\n```", "```py\n# Define the language learning settings\nLANGUAGES = ['English', 'German', 'Spanish', 'French']\nSESSION_LENGTHS = ['Short', 'Long']\nPROFICIENCY_LEVELS = ['Beginner', 'Intermediate', 'Advanced']\nMAX_EXCHANGE_COUNTS = {\n    'Short': {'Conversation': 8, 'Debate': 4},\n    'Long': {'Conversation': 16, 'Debate': 8}\n}\nAUDIO_SPEECH = {\n    'English': 'en',\n    'German': 'de',\n    'Spanish': 'es',\n    'French': 'fr'\n}\nAVATAR_SEED = [123, 42]\n\n# Define backbone llm\nengine = 'OpenAI'\n```", "```py\n# Set the title of the app\nst.title('Language Learning App 🌍📖🎓')\n\n# Set the description of the app\nst.markdown(\"\"\"\nThis app generates conversation or debate scripts to aid in language learning 🎯 \n\nChoose your desired settings and press 'Generate' to start 🚀\n\"\"\")\n\n# Add a selectbox for learning mode\nlearning_mode = st.sidebar.selectbox('Learning Mode 📖', ('Conversation', 'Debate'))\n\nif learning_mode == 'Conversation':\n    role1 = st.sidebar.text_input('Role 1 🎭')\n    action1 = st.sidebar.text_input('Action 1 🗣️')\n    role2 = st.sidebar.text_input('Role 2 🎭')\n    action2 = st.sidebar.text_input('Action 2 🗣️')\n    scenario = st.sidebar.text_input('Scenario 🎥')\n    time_delay = 2\n\n    # Configure role dictionary\n    role_dict = {\n        'role1': {'name': role1, 'action': action1},\n        'role2': {'name': role2, 'action': action2}\n    }\n\nelse:\n    scenario = st.sidebar.text_input('Debate Topic 💬')\n\n    # Configure role dictionary\n    role_dict = {\n        'role1': {'name': 'Proponent'},\n        'role2': {'name': 'Opponent'}\n    }\n    time_delay = 5\n\nlanguage = st.sidebar.selectbox('Target Language 🔤', LANGUAGES)\nsession_length = st.sidebar.selectbox('Session Length ⏰', SESSION_LENGTHS)\nproficiency_level = st.sidebar.selectbox('Proficiency Level 🏆', PROFICIENCY_LEVELS)\n```", "```py\nif \"bot1_mesg\" not in st.session_state:\n    st.session_state[\"bot1_mesg\"] = []\n\nif \"bot2_mesg\" not in st.session_state:\n    st.session_state[\"bot2_mesg\"] = []\n\nif 'batch_flag' not in st.session_state:\n    st.session_state[\"batch_flag\"] = False\n\nif 'translate_flag' not in st.session_state:\n    st.session_state[\"translate_flag\"] = False\n\nif 'audio_flag' not in st.session_state:\n    st.session_state[\"audio_flag\"] = False\n\nif 'message_counter' not in st.session_state:\n    st.session_state[\"message_counter\"] = 0\n```", "```py\nif 'dual_chatbots' not in st.session_state:\n\n    if st.sidebar.button('Generate'):\n\n        # Add flag to indicate if this is the first time running the script\n        st.session_state[\"first_time_exec\"] = True \n\n        with conversation_container:\n            if learning_mode == 'Conversation':\n                st.write(f\"\"\"#### The following conversation happens between \n                                {role1} and {role2} {scenario} 🎭\"\"\")\n\n            else:\n                st.write(f\"\"\"#### Debate 💬: {scenario}\"\"\")\n\n            # Instantiate dual-chatbot system\n            dual_chatbots = DualChatbot(engine, role_dict, language, scenario, \n                                        proficiency_level, learning_mode, session_length)\n            st.session_state['dual_chatbots'] = dual_chatbots\n\n            # Start exchanges\n            for _ in range(MAX_EXCHANGE_COUNTS[session_length][learning_mode]):\n                output1, output2, translate1, translate2 = dual_chatbots.step()\n\n                mesg_1 = {\"role\": dual_chatbots.chatbots['role1']['name'], \n                        \"content\": output1, \"translation\": translate1}\n                mesg_2 = {\"role\": dual_chatbots.chatbots['role2']['name'], \n                        \"content\": output2, \"translation\": translate2}\n\n                new_count = show_messages(mesg_1, mesg_2, \n                                          st.session_state[\"message_counter\"],\n                                          time_delay=time_delay, batch=False,\n                                          audio=False, translation=False)\n                st.session_state[\"message_counter\"] = new_count\n\n                # Update session state\n                st.session_state.bot1_mesg.append(mesg_1)\n                st.session_state.bot2_mesg.append(mesg_2)\n```", "```py\nif 'dual_chatbots' in st.session_state:  \n\n    # Show translation \n    if translate_col.button('Translate to English'):\n        st.session_state['translate_flag'] = True\n        st.session_state['batch_flag'] = True\n\n    # Show original text\n    if original_col.button('Show original'):\n        st.session_state['translate_flag'] = False\n        st.session_state['batch_flag'] = True\n\n    # Append audio\n    if audio_col.button('Play audio'):\n        st.session_state['audio_flag'] = True\n        st.session_state['batch_flag'] = True\n\n    # Retrieve generated conversation & chatbots\n    mesg1_list = st.session_state.bot1_mesg\n    mesg2_list = st.session_state.bot2_mesg\n    dual_chatbots = st.session_state['dual_chatbots']\n\n    # Control message appearance\n    if st.session_state[\"first_time_exec\"]:\n        st.session_state['first_time_exec'] = False\n\n    else:\n        # Show complete message\n        with conversation_container:\n\n            if learning_mode == 'Conversation':\n                st.write(f\"\"\"#### {role1} and {role2} {scenario} 🎭\"\"\")\n\n            else:\n                st.write(f\"\"\"#### Debate 💬: {scenario}\"\"\")\n\n            for mesg_1, mesg_2 in zip(mesg1_list, mesg2_list):\n                new_count = show_messages(mesg_1, mesg_2, \n                                        st.session_state[\"message_counter\"],\n                                        time_delay=time_delay,\n                                        batch=st.session_state['batch_flag'],\n                                        audio=st.session_state['audio_flag'],\n                                        translation=st.session_state['translate_flag'])\n                st.session_state[\"message_counter\"] = new_count\n```", "```py\n # Create summary for key learning points\n    summary_expander = st.expander('Key Learning Points')\n    scripts = []\n    for mesg_1, mesg_2 in zip(mesg1_list, mesg2_list):\n        for i, mesg in enumerate([mesg_1, mesg_2]):\n            scripts.append(mesg['role'] + ': ' + mesg['content'])\n\n    # Compile summary\n    if \"summary\" not in st.session_state:\n        summary = dual_chatbots.summary(scripts)\n        st.session_state[\"summary\"] = summary\n    else:\n        summary = st.session_state[\"summary\"]\n\n    with summary_expander:\n        st.markdown(f\"**Here is the learning summary:**\")\n        st.write(summary)\n```", "```py\ndef show_messages(mesg_1, mesg_2, message_counter,\n                  time_delay, batch=False, audio=False,\n                  translation=False):\n    \"\"\"Display conversation exchanges. This helper function supports\n    displaying original texts, translated texts, and audio speech.\n\n    Output:\n    -------\n    message_counter: updated counter for ID key\n    \"\"\"    \n\n    for i, mesg in enumerate([mesg_1, mesg_2]):\n        # Show original exchange ()\n        message(f\"{mesg['content']}\", is_user=i==1, avatar_style=\"bottts\", \n                seed=AVATAR_SEED[i],\n                key=message_counter)\n        message_counter += 1\n\n        # Mimic time interval between conversations\n        # (this time delay only appears when generating \n        # the conversation script for the first time)\n        if not batch:\n            time.sleep(time_delay)\n\n        # Show translated exchange\n        if translation:\n            message(f\"{mesg['translation']}\", is_user=i==1, avatar_style=\"bottts\", \n                    seed=AVATAR_SEED[i], \n                    key=message_counter)\n            message_counter += 1\n\n        # Append autio to the exchange\n        if audio:\n            tts = gTTS(text=mesg['content'], lang=AUDIO_SPEECH[language])  \n            sound_file = BytesIO()\n            tts.write_to_fp(sound_file)\n            st.audio(sound_file)\n\n    return message_counter\n```", "```py\nimport streamlit as st\nfrom streamlit_chat import message\n\nmessage(\"Hellp, I am a Chatbot, how may I help you?\") \nmessage(\"Hey, what's a chatbot\", is_user=True) \n```", "```py\nstreamlit run app.py\n```"]