- en: A Simple Way to Speed Up Your Python Code — Stay Up to Date
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/a-simple-way-to-speed-up-your-python-code-stay-up-to-date-e633b73619f9](https://towardsdatascience.com/a-simple-way-to-speed-up-your-python-code-stay-up-to-date-e633b73619f9)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Optimisation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up to 15 times faster just by updating a library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@maclayton?source=post_page-----e633b73619f9--------------------------------)[![Mike
    Clayton](../Images/2d37746b13b7d2ff1c6515893914da97.png)](https://medium.com/@maclayton?source=post_page-----e633b73619f9--------------------------------)[](https://towardsdatascience.com/?source=post_page-----e633b73619f9--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----e633b73619f9--------------------------------)
    [Mike Clayton](https://medium.com/@maclayton?source=post_page-----e633b73619f9--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----e633b73619f9--------------------------------)
    ·13 min read·Jan 10, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/00e95122bcff0ce1559075682885c4cd.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by [Gerd Altmann](https://pixabay.com/users/geralt-9301/?utm_source=link-attribution&amp%3Butm_medium=referral&amp%3Butm_campaign=image&amp%3Butm_content=1672346)
    from [Pixabay](https://pixabay.com//?utm_source=link-attribution&amp%3Butm_medium=referral&amp%3Butm_campaign=image&amp%3Butm_content=1672346)
  prefs: []
  type: TYPE_NORMAL
- en: '**A lot of time and money is spent trying to optimise code so that it can be
    as fast and efficient as possible, and within the field of data science this is
    becoming even more important due to the vast datasets that are now required to
    be processed.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**A simple, and often overlooked, way of achieving code optimisation is just
    to make sure that your language of choice, and associated libraries, are as up
    to date as they can reasonably be.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**You will probably be surprised how relatively little time and effort, can
    result in some significant benefits.**'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is a fairly obvious statement to say that staying up to date could help “optimise”
    your code, but blindly updating your software or libraries without understanding
    what is changing is potentially a recipe for disaster.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this article you should have a good idea of why you should stay
    up to date. You will have a solid plan of action to ensure you can hit a balance
    between ensuring you are optimised, and not wasting valuable time. In addition,
    you will also be aware of the potential pitfalls that can arise, and how to avoid
    them.
  prefs: []
  type: TYPE_NORMAL
- en: To round things off, a concrete example using the latest release of NumPy (1.24.0)
    to illustrate the real world benefits of keeping your software and libraries bang
    up to date.
  prefs: []
  type: TYPE_NORMAL
- en: Why should I stay up to date?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../Images/bd173c0ac5eff15b33b05ecd1ded7806.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Ann H](https://www.pexels.com/photo/why-text-on-a-pink-surface-11141733/)
    from [Pexels](https://www.pexels.com/)
  prefs: []
  type: TYPE_NORMAL
- en: 'The simple answer is that you can benefit from items such as:'
  prefs: []
  type: TYPE_NORMAL
- en: brand new features
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: optimisations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: bug fixes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All implemented for you by people who know software well, because remember…
  prefs: []
  type: TYPE_NORMAL
- en: You are not a software development expert
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are a data science professional (or enthusiast), which I’m going to assume
    you are, then your main concern is processing, manipulating and analysing data
    to gain insights and predictions.
  prefs: []
  type: TYPE_NORMAL
- en: Although you may have a certain level of competence with regard to software
    development, and general coding, it would be fair to say that it is not your expertise.
  prefs: []
  type: TYPE_NORMAL
- en: As such, it is perfectly reasonable that you rely on a high level intuitive
    language (Python, R, Matlab etc.), and a mountain of libraries that provide a
    whole host of functionality and optimisation relevant to your field of work. Allowing
    you to concentrate on **your** profession.
  prefs: []
  type: TYPE_NORMAL
- en: Rely on the experts, they know better
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you can build optimisation into your code, great! But it should not be the
    thing that is consuming your time.
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, there is an army of other professionals, who know software
    development extremely well. They are working hard to ensure the language and libraries
    you use are optimised, and constantly improved. Providing you with the exact tools
    you need to apply to your work.
  prefs: []
  type: TYPE_NORMAL
- en: However, to take advantage of these optimisations you need to pay attention,
    or you may be missing out.
  prefs: []
  type: TYPE_NORMAL
- en: Read the release notes, it’s important
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../Images/888baa6b6c8a1a51bc4cf2b2bde723e1.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Pixabay](https://www.pexels.com/photo/background-beverage-blank-brown-459458/)
  prefs: []
  type: TYPE_NORMAL
- en: New versions of both the language, and associated libraries, are released with
    surprising regularity. However, if you don’t pay attention to what is actually
    changing, then you may miss out on the potential benefits, or introduce bugs /
    nonsensical parameters.
  prefs: []
  type: TYPE_NORMAL
- en: A good example of both of these situations is an algorithm update applied to
    the NumPy `np.in1d` function in NumPy 1.24.0, which is also utilised in the widely
    used `np.isin` function.
  prefs: []
  type: TYPE_NORMAL
- en: '`np.in1d` (used by `np.isin`) can now switch to a faster algorithm (up to >10x
    faster) when it is passed two integer arrays. This is often automatically used,
    but you can use `kind="sort"` or `kind="table"` to force the old or new method,
    respectively.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -[numpy.org](https://numpy.org/doc/stable/release/1.24.0-notes.html#faster-version-of-np-isin-and-np-in1d-for-integer-arrays)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Missing out on gains
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to note in the quote above that `kind="table"` is “often automatically
    used”, which implies **not always**.
  prefs: []
  type: TYPE_NORMAL
- en: You could be missing out on a 10x speed gain
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'You could be missing out on a 10x speed gain just because you didn’t meet the
    requirements set by the developers to automatically use the new method:'
  prefs: []
  type: TYPE_NORMAL
- en: If None, will automatically choose ‘table’ if the required memory allocation
    is less than or equal to 6 times the sum of the sizes of *ar1* and *ar2*, otherwise
    will use ‘sort’. This is done to not use a large amount of memory by default,
    **even though ‘table’ may be faster in most cases**.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -[numpy.org](https://numpy.org/doc/stable/reference/generated/numpy.in1d.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you read the release notes, then simply adding `kind=”table”` in the method
    parameters would be the simple change you needed to ensure a significant benefit
    in speed of execution, regardless of memory allocation.
  prefs: []
  type: TYPE_NORMAL
- en: '***Note:*** *this automatic selection is likely introduced to ensure the new
    method doesn’t cause bugs in your code. There are cases where it could use more
    memory than the previous method, which may be a problem in memory restricted environments.
    Very sensible edge case coverage by the developers.*'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing bugs or confusing code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you don’t set the new parameter (because you didn’t read the release notes),
    then very sensibly the developers set a default.
  prefs: []
  type: TYPE_NORMAL
- en: If None, will automatically choose ‘table’ if the required memory allocation
    is less than or equal to 6 times the sum of the sizes of *ar1* and *ar2.*
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -[numpy.org](https://numpy.org/doc/stable/reference/generated/numpy.in1d.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Great! So you may automatically get a speed up of 10x. However:'
  prefs: []
  type: TYPE_NORMAL
- en: If ‘table’ is chosen, *assume_unique* will have no effect.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[-numpy.org](https://numpy.org/doc/stable/reference/generated/numpy.in1d.html)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this case “assume_unique” having no effect is a minor problem, as the developers
    look like they have covered edge cases to ensure that if you previously assigned
    “assume_unique” it will just be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is messy, as your code specifies a parameter that is irrelevant,
    which could cause confusion for other people (or even you) in the future.
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth noting that there may be cases where the developers weren’t
    so thorough, or breaking changes couldn’t be avoided. If that happens, then you
    will suddenly have code that doesn’t run.
  prefs: []
  type: TYPE_NORMAL
- en: New methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apart from potentially missing out on the improvement for the methods you already
    use in your code, you may miss out on completely new methods that would be of
    potential use to your project or workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a previous article about one hot encoding data I touched on a new method
    implemented in the recently released Pandas 1.5.0 called `[from_dummies()](https://pandas.pydata.org/docs/reference/api/pandas.from_dummies.html)`,
    which is a reversal for `[get_dummies()](https://pandas.pydata.org/docs/reference/api/pandas.get_dummies.html#pandas.get_dummies)`,
    a commonly used one hot encoding method from Pandas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/the-best-methods-for-one-hot-encoding-your-data-c29c78a153fd?source=post_page-----e633b73619f9--------------------------------)
    [## The Best Methods for One-Hot Encoding Your Data'
  prefs: []
  type: TYPE_NORMAL
- en: OneHotEncoder vs get_dummies vs to_categorical
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/the-best-methods-for-one-hot-encoding-your-data-c29c78a153fd?source=post_page-----e633b73619f9--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Prior to the release of this method, reversal of the one hot encoding would
    have been a manual procedure.
  prefs: []
  type: TYPE_NORMAL
- en: There are a whole host of new methods created across the libraries that you
    use, but the only way to be aware of when they appear is to review the release
    notes.
  prefs: []
  type: TYPE_NORMAL
- en: whatever method the developers have implemented will be optimised and less prone
    to bugs
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: …and remember, it is *likely* that whatever method the developers have implemented
    will be optimised and less prone to bugs than something you have coded yourself.
    They are professional software developers after all, and producing bug free well
    tested code is no easy feat.
  prefs: []
  type: TYPE_NORMAL
- en: A strategy to keep up to date
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../Images/349d110b2a03b367db34b781eb65d683.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Patrick Perkins](https://unsplash.com/@patrickperkins?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
    on [Unsplash](https://unsplash.com/photos/ETRPjvb0KM0?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
  prefs: []
  type: TYPE_NORMAL
- en: Time is money, as the famous aphorism goes.
  prefs: []
  type: TYPE_NORMAL
- en: The reality is that a typical project may include a mountain of libraries, so
    it may not be practical to read the release notes for every library, for every
    tiny update, so it may be wise to prioritise.
  prefs: []
  type: TYPE_NORMAL
- en: Update on specific release points
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is quite common to see numbering conventions that include three numbers separated
    by dots. For example the current release of NumPy is 1.24.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Being aware of what these numbers (generally) signify can help plan when to
    pay attention:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Major version number** (**1**.24.0): large and significant changes to the
    software or library. **Can include changes that are not backward compatible.**
    This requires careful review before upgrading.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minor version number** (1.**24**.0): typically a minor feature change / changes,
    or a larger set of bug fixes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Patch version number** (1.24.**0**): typically a smaller set of bug fixes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the major version number changes it is **absolutely essential** that you
    review the release notes, as there could be breaking changes (i.e. your code could
    stop working completely in some cases).
  prefs: []
  type: TYPE_NORMAL
- en: The minor version number change is something you should be paying attention
    to, as it is optimal in terms potential gains, and new or improved methods.
  prefs: []
  type: TYPE_NORMAL
- en: The patch version number can generally be passed over if you don’t have time,
    unless you are waiting for a known bug to be fixed.
  prefs: []
  type: TYPE_NORMAL
- en: Pick the most important libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If time is of the essence, you should pick the libraries that are most utilised,
    or most relevant to the project (i.e. those with the biggest impact), and keep
    up to speed with any relevant changes as updates arrive. As detailed in the previous
    section this should involve mainly paying attention to major and minor version
    number changes.
  prefs: []
  type: TYPE_NORMAL
- en: It is not essential that you update the library for every patch release, but
    keeping track of the changes that are published will give you the opportunity
    to update when it is beneficial to the project.
  prefs: []
  type: TYPE_NORMAL
- en: In reality, the smaller the update you apply, the easier it is to pin down bugs
    when they do occur, reducing time taken for mitigation, and lessening the risk
    involved.
  prefs: []
  type: TYPE_NORMAL
- en: Update strategy - Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pay attention to major version number changes for **ALL** libraries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pay attention to minor version number changes for libraries that are most utilised,
    or most relevant to the project
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Patch version number changes can mostly be passed over without review, unless
    you are actively waiting for a bug to be fixed
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The potential dangers of upgrading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../Images/6e5ea85c6eb1dfb87df8a0ce4fedebcd.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Raúl Nájera](https://unsplash.com/@reinf?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
    on [Unsplash](https://unsplash.com/photos/MggK54YixfU?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
  prefs: []
  type: TYPE_NORMAL
- en: As already discussed, there are some real gains to be had from keeping up to
    date, but it can also cause unwanted problems, and lost time, due to debugging
    new errors.
  prefs: []
  type: TYPE_NORMAL
- en: Again, this can mostly be avoided by paying attention to the release notes.
  prefs: []
  type: TYPE_NORMAL
- en: 'I will refer you to the release notes of NumPy for version 1.24.0 as an example
    of what to expect. It is well laid out with lots of information (not always the
    case with all libraries/software):'
  prefs: []
  type: TYPE_NORMAL
- en: '[## Release notes - NumPy v1.24 Manual'
  prefs: []
  type: TYPE_NORMAL
- en: Edit description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: numpy.org](https://numpy.org/doc/stable/release.html?source=post_page-----e633b73619f9--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: The main problems that you will face are generally due to one of the following.
  prefs: []
  type: TYPE_NORMAL
- en: Deprecations / Expired Deprecations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is probably the main item to pay attention to. When a method becomes deprecated
    it will eventually be removed (timescales vary). This is excellent as, assuming
    you are aware of the deprecation being applied, it gives you time to implement
    a work around, or switch to an updated method from the library.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you are looking at the release notes and notice one of your methods
    is listed in expired deprecations, then an immediate fix is required before upgrade,
    as your code will literally stop working.
  prefs: []
  type: TYPE_NORMAL
- en: Compatibility notes / changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is less severe than a deprecation, but can be tricky as they can change
    behaviour and/or outputs of functions. Something you may not immediately notice
    if you weren’t aware of it.
  prefs: []
  type: TYPE_NORMAL
- en: '**array.fill(scalar) may behave slightly different**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`numpy.ndarray.fill` may in some cases behave slightly different now due to
    the fact that the logic is aligned with item assignment.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Previously casting may have produced slightly different answers when using values
    that could not be represented in the target `dtype` or when the target had `object`
    dtype.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -[numpy.org](https://numpy.org/doc/stable/release/1.24.0-notes.html#array-fill-scalar-may-behave-slightly-different)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “May behave slightly differently” is about as vague as it gets! A perfect example
    of something that could cause ‘interesting’ bugs if it is relevant to your code.
    The above would be worth looking into should you have a very sensitive implementation
    that uses this function.
  prefs: []
  type: TYPE_NORMAL
- en: What if I can’t upgrade?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../Images/97d22ef76954ff1e60fca24d5c320e01.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Towfiqu barbhuiya](https://www.pexels.com/photo/possible-written-on-a-chalkboard-9755375/)
    from [Pexels](https://www.pexels.com/)
  prefs: []
  type: TYPE_NORMAL
- en: In industry the reality is that you may have limitations on the upgrade process
    that are outside of your control. This could be caused by a choice of base operating
    system / container, or due to limitations in other areas of the project you are
    working on that require very specific versioning.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, without solid information, no decisions can be made.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: However, it is still worth keeping up to date with the developments of key packages
    and libraries. If nothing else it is ammunition to push for what might be quite
    a complicated, and/or costly, upgrade process to be put into action, as the benefits
    may outweigh the upgrade cost. Remember, without solid information, no real decisions
    can be made.
  prefs: []
  type: TYPE_NORMAL
- en: A concrete example of the benefits of staying up to date
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../Images/b233616be939455e68a49de199266087.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Rodolfo Quirós](https://www.pexels.com/photo/selective-focus-photography-cement-2219024/)
    from [Pexels](https://www.pexels.com/)
  prefs: []
  type: TYPE_NORMAL
- en: Fairly recently, NumPy had a minor version number change from 1.23.5 to 1.24.0\.
    As explained in an earlier section of this article, a minor version number change,
    can result in “minor feature changes”, rather than just the simple bug fixes that
    a patch update would bring.
  prefs: []
  type: TYPE_NORMAL
- en: 'A couple of these “minor feature changes” claim to result in significantly
    sped up versions of their original functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '***np.in1d***'
  prefs: []
  type: TYPE_NORMAL
- en: '`np.in1d` (used by `np.isin`) can now switch to a faster algorithm (up to >10x
    faster)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[-numpy.org](https://numpy.org/doc/stable/release/1.24.0-notes.html#faster-version-of-np-isin-and-np-in1d-for-integer-arrays)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '***NumPy comparison functions***'
  prefs: []
  type: TYPE_NORMAL
- en: The comparison functions (`numpy.equal`, `numpy.not_equal`, `numpy.less`, `numpy.less_equal`,
    `numpy.greater` and `numpy.greater_equal`) are now much faster as they are now
    vectorized with universal intrinsics. For a CPU with SIMD extension AVX512BW,
    the performance gain is up to 2.57x, 1.65x and 19.15x for integer, float and boolean
    data types, respectively (with N=50000).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -[numpy.org](https://numpy.org/doc/stable/release/1.24.0-notes.html#faster-version-of-np-isin-and-np-in1d-for-integer-arrays)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Testing the claims
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although I have no reason to doubt the numbers, I thought it might be interesting
    to test it out in practise, so the following sections will run benchmarks between
    the old an new versions to see what real world speed gains can be realised.
  prefs: []
  type: TYPE_NORMAL
- en: Notebooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the code that follows is available in jupyter notebooks.
  prefs: []
  type: TYPE_NORMAL
- en: This section gives details on the location of the notebooks, and also the requirements
    for the environment setup for online environments such as [Colab](https://colab.research.google.com/)
    and [Deepnote](https://deepnote.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The raw notebooks can be found here for your local environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://github.com/thetestspecimen/notebooks/tree/main/python-libraries-update?source=post_page-----e633b73619f9--------------------------------)
    [## notebooks/python-libraries-update at main · thetestspecimen/notebooks'
  prefs: []
  type: TYPE_NORMAL
- en: You can't perform that action at this time. You signed in with another tab or
    window. You signed out in another tab or…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: github.com](https://github.com/thetestspecimen/notebooks/tree/main/python-libraries-update?source=post_page-----e633b73619f9--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: …or get kickstarted in either deepnote or colab.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python 1.24.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![](../Images/698d457d36991043ae3d8cf1dc379519.png)](https://deepnote.com/launch?url=https%3A%2F%2Fgithub.com%2Fthetestspecimen%2Fnotebooks%2Fblob%2Fmain%2Fpython-libraries-update%2Fpython_libraries_1.24.0.ipynb)[![](../Images/f372f5abb268152c9e786769541e99de.png)](https://colab.research.google.com/github/thetestspecimen/notebooks/blob/main/python-libraries-update/python_libraries_1.24.0.ipynb)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python 1.23.5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![](../Images/50735f40a54c7ce1361aca97ca6e6fc2.png)](https://deepnote.com/launch?url=https%3A%2F%2Fgithub.com%2Fthetestspecimen%2Fnotebooks%2Fblob%2Fmain%2Fpython-libraries-update%2Fpython_libraries_1.23.5.ipynb)[![](../Images/c48d803704c5f75f7d69a0fecd00942b.png)](https://colab.research.google.com/github/thetestspecimen/notebooks/blob/main/python-libraries-update/python_libraries_1.23.5.ipynb)'
  prefs: []
  type: TYPE_NORMAL
- en: Environment Setup — Local or Deepnote
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whether using a local environment, or deepnote, all that is needed is to ensure
    that the appropriate version of NumPy is available. The easiest way to achieve
    this is to add it to your “requirements.txt” file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For deepnote you can create a file called “requirements.txt” in the files section
    in the right pane and add the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: (change the version number as appropriate).
  prefs: []
  type: TYPE_NORMAL
- en: Environment Setup — Colab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As there is no access to something like a “requirements.txt” file in colab
    you will need to explicitly install the correct version of NumPy. To do this run
    the following code in a blank cell to install the appropriate version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: (change the version number as appropriate).
  prefs: []
  type: TYPE_NORMAL
- en: Then refresh the web page before trying to run any code.
  prefs: []
  type: TYPE_NORMAL
- en: The test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following speed tests were run to give an overview of the improvements
    to the `np.in1d` and `np.equal` methods when using the latest NumPy version (1.24.0)
    compared to the previous version (1.23.5):'
  prefs: []
  type: TYPE_NORMAL
- en: Two integer arrays with length 50000 using method `np.equal` (method run 1 million
    times) — **should be up to 2.75x faster with numpy 1.24.0 according to the documentation**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Two boolean arrays with length 50000 using method `np.equal` (method run 1 million
    times) — **should be up to 19.15x faster with numpy 1.24.0 according to the documentation**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Two integer arrays compared using `np.in1d` using `kind="sort"` (method run
    10 thousand times) — this method is available in both numpy 1.23.5 and 1.24.0
    — **should be the same speed in numpy 1.23.5 and 1.24.0 (a good cross-check between
    notebooks to ensure that the results of the other tests can be directly compared)**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Two integer arrays compared using `np.in1d` using the new `kind="table"` method
    (method run 10 thousand times) — this method is only available in numpy 1.24.0
    — **should be up to 10x faster than the “sort” method according to the documentation**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***Input data***'
  prefs: []
  type: TYPE_NORMAL
- en: '***Timeit setup***'
  prefs: []
  type: TYPE_NORMAL
- en: Results — NumPy 1.23.5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Results-NumPy 1.24.0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/bdc50faa3043c57c7f6845d38e2c1f24.png)'
  prefs: []
  type: TYPE_IMG
- en: Results comparison — Image by author
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the results sections, the results achieved are roughly
    inline with what was expected, and all methods achieve an increase in speed of
    execution:'
  prefs: []
  type: TYPE_NORMAL
- en: Two integer arrays using method `np.equal` — **4.67x faster** with numpy 1.24.0
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Two boolean arrays using method `np.equal` — **15.56x faster** with numpy 1.24.0
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Two integer arrays compared using `np.in1d` using the `kind="sort"` method —
    **more or less exactly the same execution time** using numpy 1.23.5 and 1.24.0
    as expected (18.5 seconds for 10000 iterations)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Two integer arrays compared using `np.in1d` using the new `kind="table"` method
    — **3.84x faster** with numpy 1.24.0 and the newly introduced `kind="table"` method
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The efforts of software developers to constantly improve the languages and libraries
    that we all use on a daily basis should not be ignored. It is one of the easiest
    and most accessible ways to improve the efficiency, speed and reliability of your
    projects code.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the very small example outlined in this article, the benefits
    can be quite significant. All it takes a little organisation, and the willingness
    to invest some time into reviewing the release notes for your most important libraries
    / software.
  prefs: []
  type: TYPE_NORMAL
- en: If you found this article interesting or useful, remember to follow me, or [sign
    up for my newsletter](https://medium.com/@maclayton/subscribe) for more content
    like this.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven’t already, you could also consider [subscribing to Medium](https://medium.com/@maclayton/membership).
    Your membership fee directly supports, not just me, but other writers you read
    too. You’ll also get full unrestricted access to every story on Medium.
  prefs: []
  type: TYPE_NORMAL
- en: Using my referral link to sign up will grant me a small kickback with zero effect
    on your membership, so thank you if you choose to do so.
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/@maclayton/membership?source=post_page-----e633b73619f9--------------------------------)
    [## Join Medium with my referral link - Mike Clayton'
  prefs: []
  type: TYPE_NORMAL
- en: Read every story from Mike Clayton (and thousands of other writers on Medium).
    Your membership fee directly supports…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/@maclayton/membership?source=post_page-----e633b73619f9--------------------------------)
  prefs: []
  type: TYPE_NORMAL
