- en: Add interactivity to your web apps with React
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 React 为你的网页应用添加互动性
- en: 原文：[https://towardsdatascience.com/a-step-by-step-guide-to-develop-a-map-based-application-part-iii-ad501c4aa35b](https://towardsdatascience.com/a-step-by-step-guide-to-develop-a-map-based-application-part-iii-ad501c4aa35b)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/a-step-by-step-guide-to-develop-a-map-based-application-part-iii-ad501c4aa35b](https://towardsdatascience.com/a-step-by-step-guide-to-develop-a-map-based-application-part-iii-ad501c4aa35b)
- en: A Step-by-Step Guide to Develop a Map-Based Application (Part III)
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 《逐步指南：开发基于地图的应用程序（第三部分）》
- en: '[](https://medium.com/@jacky.kaub?source=post_page-----ad501c4aa35b--------------------------------)[![Jacky
    Kaub](../Images/e66c699ee5a9d5bbd58a1a72d688234a.png)](https://medium.com/@jacky.kaub?source=post_page-----ad501c4aa35b--------------------------------)[](https://towardsdatascience.com/?source=post_page-----ad501c4aa35b--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----ad501c4aa35b--------------------------------)
    [Jacky Kaub](https://medium.com/@jacky.kaub?source=post_page-----ad501c4aa35b--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@jacky.kaub?source=post_page-----ad501c4aa35b--------------------------------)[![Jacky
    Kaub](../Images/e66c699ee5a9d5bbd58a1a72d688234a.png)](https://medium.com/@jacky.kaub?source=post_page-----ad501c4aa35b--------------------------------)[](https://towardsdatascience.com/?source=post_page-----ad501c4aa35b--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----ad501c4aa35b--------------------------------)
    [Jacky Kaub](https://medium.com/@jacky.kaub?source=post_page-----ad501c4aa35b--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----ad501c4aa35b--------------------------------)
    ·24 min read·Feb 20, 2023
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·发表在[Towards Data Science](https://towardsdatascience.com/?source=post_page-----ad501c4aa35b--------------------------------)
    ·阅读时间24分钟·2023年2月20日
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/87da49187774c09f8bfac884d0cfcb7a.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/87da49187774c09f8bfac884d0cfcb7a.png)'
- en: Photo by [Edgar](https://unsplash.com/@ymoran?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 照片由[Edgar](https://unsplash.com/@ymoran?utm_source=medium&utm_medium=referral)拍摄，[Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)提供
- en: Maps are a powerful tool for visualizing and understanding geographic data but
    they need specific skills to be designed efficiently.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 地图是可视化和理解地理数据的强大工具，但设计地图需要特定的技能以提高效率。
- en: In this step-by-step guide, we are going to take a deep dive into building a
    map-based application to show the customers' prices of gas stations around them.
    We will cover the different key steps of a product, from original proof of concept
    (POC) to the minimum viable product (MVP)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇逐步指南中，我们将深入探讨构建基于地图的应用程序，以展示客户周围加油站的价格。我们将涵盖从最初的概念验证（POC）到最小可行产品（MVP）的不同关键步骤。
- en: 'Articles in the series:'
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系列文章：
- en: '[Part I: The proof-of-concept — Build a minimalist demo](/a-step-by-step-guide-to-develop-a-map-based-application-part-i-757766b04f77)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[第一部分：概念验证—构建一个极简演示](/a-step-by-step-guide-to-develop-a-map-based-application-part-i-757766b04f77)'
- en: '[Part II: How to use React to build web apps (Static Layout)](/a-step-by-step-guide-to-develop-a-map-based-application-part-ii-6d3fa7dbd8b9)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[第二部分：如何使用 React 构建网页应用（静态布局）](/a-step-by-step-guide-to-develop-a-map-based-application-part-ii-6d3fa7dbd8b9)'
- en: 'Part III: Add interactivity to your web apps with React'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分：使用 React 为你的网页应用添加互动性
- en: '[Part IV: Build a back-end with PostgreSQL, FastAPI, and Docker](/build-a-back-end-with-postgresql-fastapi-and-docker-7ebfe59e4f06)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[第四部分：使用 PostgreSQL、FastAPI 和 Docker 构建后端](/build-a-back-end-with-postgresql-fastapi-and-docker-7ebfe59e4f06)'
- en: A bit of context around this article
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于这篇文章的一些背景信息
- en: This article is the direct continuation of Part II in which we started to build
    the UI of the web app using React.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本文是第二部分的直接延续，其中我们开始使用 React 构建网页应用的用户界面。
- en: '[In the previous article](/a-step-by-step-guide-to-develop-a-map-based-application-part-ii-6d3fa7dbd8b9),
    we started to explore the potential of React to build web applications and in
    particular for our Gas Station Finder. We ended up with a nice application layout
    that can be run locally on a test-server locally, but nothing yet interactive
    to really navigate through our data. I will not go over what we covered in part
    II and I strongly recommend going through it first as they are part of a whole.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[在上一篇文章中](/a-step-by-step-guide-to-develop-a-map-based-application-part-ii-6d3fa7dbd8b9)，我们开始探索
    React 构建网页应用的潜力，特别是用于我们的加油站查找器。我们得到了一个不错的应用布局，可以在本地测试服务器上运行，但尚未具备真正导航数据的互动功能。我不会重述第二部分的内容，强烈建议先阅读第二部分，因为它们是整体的一部分。'
- en: 'In this post, we are going to finalize the React component and conclude on
    the client-side part of our product. In particular, we are going to cover the
    following topics:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇文章中，我们将完成 React 组件的开发，并总结我们产品的客户端部分。特别地，我们将涵盖以下主题：
- en: Managing and passing states from component to component
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理和传递组件间的状态
- en: Import and consume data from an API endpoint
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 API 端点导入并使用数据
- en: Update dynamically a page with new data
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用新数据动态更新页面
- en: Build a few interactive components (slider, special text box…)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一些交互组件（滑块、特殊文本框……）
- en: Handle API errors
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 API 错误
- en: By the end of the article, our application will be fully reactive, and the next
    step will be to look at the server side of the application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 到文章结尾时，我们的应用将完全具有反应性，下一步将是查看应用的服务器端。
- en: '![](../Images/7d6d059096e24371bd028a7d6ee3f231.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7d6d059096e24371bd028a7d6ee3f231.png)'
- en: The final render of the web app, Author Illustration
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Web 应用的最终渲染，作者插图
- en: As usual, you can find the full code covered in this article on [the related
    GitHub page](https://github.com/jkaub/fuel-station-viewer-react-interactive).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，你可以在[相关 GitHub 页面](https://github.com/jkaub/fuel-station-viewer-react-interactive)找到本文涵盖的完整代码。
- en: '*Side note: Things are changing fast. I wrote this article in March 2023 and
    I am using* ***React 18.2.0\.*** *If you read this article years after its publication,
    it might be a bit outdated. So be careful with what you will read below.*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*附注：事情变化很快。我在 2023 年 3 月写了这篇文章，并使用的是* ***React 18.2.0\.*** *如果你在文章发布多年后阅读它，可能会有些过时。所以要小心你下面所读的内容。*'
- en: A bit of theory behind React state management
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于 React 状态管理的一些理论
- en: In modern React, we define components just as “fancy” asynchronous functions.
    Those run perpetually and “listen” to some events (for example, a user clicking
    on it, the mousse passing on it, etc…) to execute stuff when an event happens
    (like modifying a variable that will update what is displayed in the screen —
    we call those callback functions).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代 React 中，我们将组件定义为“花哨”的异步函数。这些函数会不断运行，并“监听”某些事件（例如，用户点击它、鼠标经过它等），以在事件发生时执行操作（例如修改一个变量，从而更新屏幕上显示的内容——我们称这些为回调函数）。
- en: To make the magic happens, the variables that are meant to be modified by callbacks
    to change the rendering of the component have to be defined in a special way,
    and we call the “state” variables (they manage the state of the application).
    When those variables are modified, all the code inside the component is rerun,
    which can result in changes in the user screen.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使魔法发生，所有意图通过回调函数修改的变量必须以一种特殊方式定义，我们称之为“状态”变量（它们管理应用的状态）。当这些变量被修改时，组件内部的所有代码都会重新执行，这可能导致用户屏幕上的变化。
- en: Define “state” variables
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义“状态”变量
- en: Let’s have a look at how to define those state variables.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何定义这些状态变量。
- en: 'We start with a very simple example which creates a button that changes color
    when a user clicks on it:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个非常简单的例子开始，这个例子创建了一个按钮，当用户点击它时按钮的颜色会改变：
- en: '![](../Images/a3b073790489e59936c3f07df9405700.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a3b073790489e59936c3f07df9405700.png)'
- en: A simple component that changes color, Author Illustration
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的颜色变化组件，作者插图
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s check the code line by line.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行检查代码。
- en: First, we import the “useState” hook, which will be used to create the state
    variable that can be modified by callbacks. I will not go into the details, but
    a “hook” is simply a special feature that helps build React interactive components
    out of functions. We will cover two “hooks” in this article, but many more exists
    for a lot of different use cases…
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入“useState”钩子，它将用于创建可以被回调函数修改的状态变量。我不会详细介绍，但“钩子”仅仅是一种特殊的功能，有助于通过函数构建 React
    交互组件。我们将在本文中涵盖两个“钩子”，但还有许多其他钩子适用于不同的用例…
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we create our state variable using the useState hook. When you create
    a variable this way you are actually creating two things:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 useState 钩子创建我们的状态变量。当你以这种方式创建变量时，实际上是创建了两样东西：
- en: 'the variable itself (in our case: colorIdx)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量本身（在我们的例子中：colorIdx）
- en: 'A “setter”: a function that will allow you to modify properly your variable
    (setColorIdx)'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个“setter”：一个函数，它将允许你正确修改变量（setColorIdx）
- en: useState(0) means that we initiate our variable colorIdx to 0.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: useState(0) 意味着我们将变量 colorIdx 初始化为 0。
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can then create what we call in React an “**arrow function**” to define the
    callback that will modify the variable colorIdx. An arrow function is nothing
    more than a function with a simpler syntax, which is particularly convenient for
    defining callbacks. The equivalent in python would be the lambda functions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在 React 中创建一个“**箭头函数**”来定义将修改变量 colorIdx 的回调函数。箭头函数只是具有更简单语法的函数，这对于定义回调函数特别方便。其等效于
    Python 中的 lambda 函数。
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The value put inside setColorIdx will become the new value of colorIdx. In the
    case above, every time we call onClickCallBack, we change the value of colorIdx
    from 1 to 0 or from 0 to 1.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 放入 setColorIdx 中的值将成为 colorIdx 的新值。在上述情况下，每次我们调用 onClickCallBack 时，我们都会将 colorIdx
    的值从 1 改为 0 或从 0 改为 1。
- en: Then, we bind our callback to the “onClick” event of the button, so that every
    time the user clicks on it, it will result in changing the index colorIdx.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将回调函数绑定到按钮的“onClick”事件上，这样每次用户点击按钮时，就会导致 colorIdx 索引发生变化。
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This colorIdx is then used to modify directly the color style of the button,
    in such a way that it changes from “red” to “green” with every click.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用这个 colorIdx 直接修改按钮的颜色样式，使其在每次点击时从“红色”变为“绿色”。
- en: The useEffect hook
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: useEffect 钩子
- en: The logic above will work well most of the time. The state of a variable is
    modified after a particular event, it re-triggers all the code inside the component,
    and the display on the screen is refreshed.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 上述逻辑在大多数情况下会正常工作。变量的状态在特定事件后被修改时，它会重新触发组件内部的所有代码，并刷新屏幕上的显示。
- en: Nevertheless, in some cases, you don’t want all your code to be re-run when
    a state variable has been modified. This is the case for example when you make
    an API call and download data at the first render of your widget. This data might
    be useful to be downloaded only one time, but once the widget is rendered the
    first time, you don’t want the call to be made multiple times every time a state
    variable is modified.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，你不希望每次状态变量被修改时，所有代码都重新执行。例如，当你在小部件首次渲染时进行 API 调用并下载数据时。这些数据可能只需要下载一次，但一旦小部件第一次渲染后，你不希望每次状态变量修改时都进行多次调用。
- en: 'Let’s take again the example of our button, I simply add a log to illustrate
    the code being rerun at every click:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 再次以我们的按钮为例，我简单地添加了一个日志来说明每次点击时代码被重新运行的情况：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](../Images/679bb3b8783f896f7cb94e201b5ebd50.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/679bb3b8783f896f7cb94e201b5ebd50.png)'
- en: All the code is rerun when the variable state is modified, Author illustration
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当变量状态被修改时，所有代码都会重新运行，作者插图
- en: The avoid this issue, React proposes the useEffect hook. The idea of that hook
    is that every line of code defined inside will be executed only at the initialization
    of the component or when the state variables from a watch list are updated.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，React 提出了 useEffect 钩子。这个钩子的思路是，定义在其中的每一行代码只会在组件初始化时执行，或者当观察列表中的状态变量更新时执行。
- en: 'useEffect takes two parameters:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: useEffect 接受两个参数：
- en: 'one function: The code that will be executed during initialization and when
    certain state variables are modified'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个函数：在初始化期间以及某些状态变量被修改时会执行的代码
- en: one array (the “watch list”) is used to control the re-run of the code inside
    the function.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数组（“观察列表”）用于控制函数内部代码的重新运行。
- en: In the example below, the console.log(“click”) will be executed only at the
    initialization of the widget as the watch list is empty.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，console.log(“click”) 只会在小部件初始化时执行，因为观察列表为空。
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![](../Images/aa3117c19c072e0f31adba264b8cda76.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/aa3117c19c072e0f31adba264b8cda76.png)'
- en: The log “click” is triggered only at the initialization, Author Illustration
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 日志“click”只在初始化时触发，作者插图
- en: Retrieve data for our Gas Station Finder app
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的加油站查找应用程序检索数据
- en: We have now all the theoretical material to add reactivity to our components.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有了为组件添加反应性的所有理论材料。
- en: 'The first thing we want to do is to retrieve the filtered data around a given
    postal code and for a particular gas type. To do this we will need several things:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是根据给定的邮政编码和特定的气体类型检索过滤后的数据。为此，我们需要几个步骤：
- en: Create a state variable that will contain all the information of the stations,
    that can be used by the table and the graph
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个状态变量，该变量将包含所有车站的信息，表格和图表都可以使用这些信息
- en: Make a callback that will trigger an API call and update the relevant state
    variable
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个回调函数来触发 API 调用并更新相关的状态变量
- en: Dropdown
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下拉菜单
- en: Let’s start with the Dropdown. In the previous article, the component used to
    be static and nothing would happen if a user was selecting another gas type.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从下拉菜单开始。在上一篇文章中，该组件是静态的，当用户选择另一个燃料类型时没有任何反应。
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](../Images/787cf98c9cd653ea05f8b3cfea3031a7.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/787cf98c9cd653ea05f8b3cfea3031a7.png)'
- en: 'As of now, the value in the <select> tag is hard-coded to “SP95”. We are going
    to replace it with a state variable using useState:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，<select>标签中的值被硬编码为“SP95”。我们将使用useState替换它：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We now need to modify the value when the “onChange” event is fired in the dropdown:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要在“onChange”事件在下拉菜单中触发时修改值：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The onChange callback has an input “event” which contains the information related
    to the change. In our case, we are interested in the new dropdown value accessible
    in “event.target.value”.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: onChange回调有一个输入“event”，其中包含与更改相关的信息。在我们的例子中，我们对“event.target.value”中访问的新下拉值感兴趣。
- en: 'As one of the first interactive components, let’s detail exactly what is happening
    here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个交互式组件之一，让我们详细说明一下这里发生了什么：
- en: The component is initiated with the variable gasType, defined by a useState
    initialized to “SP95”, so this is what will appear in the dropdown box at first.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件初始化时，gasType变量由初始化为“SP95”的useState定义，因此这将首先出现在下拉菜单框中。
- en: When a user changes the value, it fires the “onChange” callback, which will
    call our handleChange function.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户更改值时，它触发“onChange”回调，这将调用我们的handleChange函数。
- en: In handleChange, we fire the setter of our gasType with the new value of the
    variable accessible via event.target.value, which as result modifies gasType and
    the rendering of the app
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在handleChange中，我们用通过`event.target.value`访问的新变量值来触发gasType的setter，这将修改gasType及应用的渲染。
- en: '![](../Images/d0f7f09021f56836385fc6d144cd4211.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d0f7f09021f56836385fc6d144cd4211.png)'
- en: The dropdown is now showing the latest clicked value, Author Illustration
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下拉菜单现在显示最新的点击值，作者插图
- en: The Postal Code TextArea
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 邮政编码文本区域
- en: 'The logic will be very similar for the text area for postal code with one difference:
    we will enforce our “onChange” function so that only numbers, up to 5 digits,
    can be accepted. To do this, we just test the next value via a regular expression
    (only digits, up to 5) and update the postalCode value only if it matches our
    regex.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于邮政编码的文本区域，逻辑非常类似，只是有一个不同之处：我们会强制“onChange”函数，只接受最多5位的数字。为此，我们只需通过正则表达式（仅数字，最多5位）测试下一个值，并仅在匹配正则表达式时更新postalCode值。
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![](../Images/b8b3501858577982ff2827b9977ef28a.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b8b3501858577982ff2827b9977ef28a.png)'
- en: Illustration of the text area with the controller in place, Author Illustration
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 带有控制器的文本区域插图，作者插图
- en: The button “Find Stations”
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按钮“查找车站”
- en: When the button is hit, we want to pass the information from the Dropdown and
    the TextArea to an API that will send back stations, prices, and metadata in a
    30km radius around the city of interest.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当按钮被点击时，我们想将下拉菜单和文本区域的信息传递给一个API，该API将返回感兴趣城市30公里半径内的车站、价格和元数据。
- en: Clicking on a button can be accessed via another callback named onClick, which
    is fired when a left click happens on it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮可以通过名为onClick的回调访问，当左键点击时触发。
- en: Let’s prepare our function for now and simply log postalCode and gasType.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备函数，只需记录postalCode和gasType。
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![](../Images/c1e5847ee18a91d523301acf4dd115e9.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c1e5847ee18a91d523301acf4dd115e9.png)'
- en: When we click on Find Stations, we retrieve the latest information from the
    two fields, Author Illustration
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击“查找车站”时，我们从两个字段中检索最新信息，作者插图
- en: A word about the API
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于API的一句话
- en: In the following article, we will discuss more in detail how to set up the server-side
    API using Python + FastAPI. I assume for now that the service is already available
    and that it provides a GET endpoint that provides all the data needed from a postal
    code and a gas type.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的文章中，我们将更详细地讨论如何使用Python + FastAPI设置服务器端API。现在假设服务已经可用，并且提供一个GET端点，提供从邮政编码和燃料类型获取的所有数据。
- en: 'For example, use the below URL:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用下面的URL：
- en: '[http://API_URL/stations?oil_type=SP95&postal_code=60560](http://api_url/stations?oil_type=SP95&postal_code=60560)'
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://API_URL/stations?oil_type=SP95&postal_code=60560](http://api_url/stations?oil_type=SP95&postal_code=60560)'
- en: will result in sending the metadata of all stations in a 30km radius as well
    as lat/lon from the center of research and the circle coordinates that will be
    consumed to generate the graph and the table.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 将发送所有车站的元数据，30公里半径内的经纬度，以及用于生成图表和表格的圆圈坐标。
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Passing information from one component to another
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递信息从一个组件到另一个组件
- en: Another thing to discuss now before going further is the way to pass the information
    from our StationsFilter component to our App component.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在继续之前需要讨论的事情是如何将信息从我们的 StationsFilter 组件传递到我们的 App 组件。
- en: In React, information can be propagated from parent to children using “props”.
    This “props” is an object (key/values) that will contain the different elements
    passed as attributes in the tag.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 中，信息可以通过“props”从父组件传递到子组件。这个“props”是一个对象（键/值），其中包含作为标签属性传递的不同元素。
- en: In the example below we access a variable in the Child component via props.childVariable.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们通过 props.childVariable 访问子组件中的一个变量。
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This way, we can propagate values from Parent to Child. But what about the other
    way around? If you modify a value in Child that you would like to pass to Parent,
    you can do exactly as above, but instead of passing the variable, you can pass
    the setter. And thus, when a callback is fired in Child, it can fire the setter
    from Parent, which will modify the variable define in Parent.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们可以从父组件向子组件传播值。但反过来怎么样？如果你在子组件中修改了一个值，并希望将其传递给父组件，你可以像上面一样做，但不是传递变量，而是传递设置器。这样，当子组件中触发回调时，它可以触发来自父组件的设置器，从而修改父组件中定义的变量。
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the snippet above, every time a click is done, we fire a function that takes
    the current variable (in props.childVariable), adds +1, and fires the setter that
    will set “variable” in Parent to variable+1.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，每次点击时，我们会触发一个函数，该函数获取当前变量（在 props.childVariable 中），加 1，然后触发设置器，以便将“变量”在父组件中设置为变量+1。
- en: Finalizing our API call
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成我们的 API 调用
- en: With this bit of theory in mind, let’s finalize our component. We start by creating
    multiple state variables in App.js that will be used to store the information
    from the API.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这点理论后，让我们完成我们的组件。我们首先在 App.js 中创建多个状态变量，用于存储来自 API 的信息。
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We then pass the setter to our StationsFilter component, where we will load
    the data from the API.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将设置器传递给我们的 StationsFilter 组件，在那里我们将从 API 加载数据。
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We need now to prepare the API call. In React, this is done using the “fetch”
    method, which takes an URL (for the requests) as well as extra parameters such
    as headers or extra request parameters. Let’s implement it directly in our “HandleClick”
    function used earlier.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要准备 API 调用。在 React 中，这可以通过使用“fetch”方法完成，该方法接受一个 URL（用于请求）以及额外的参数，如头信息或其他请求参数。让我们直接在之前使用的“HandleClick”函数中实现它。
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Going line by line:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一行一行地解释：
- en: We first use “fetch” which, by default, makes a GET call to the URL passed in
    the parameter. In our case, we form the URL to include the state variable gasType
    and postalCode
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先使用“fetch”，默认情况下，它对传递的 URL 进行 GET 调用。在我们的例子中，我们形成 URL 以包含状态变量 gasType 和 postalCode。
- en: fetch is an asynchronous function, we need to wait for it to complete before
    processing the data sent by the API. To do so, we use the callback .then() that
    we chain to our API call. When the fetch call is completed, it will automatically
    run the code in .then(). In that case, we receive a Response (from the API) that
    we convert into JSON using res.json(). This is also an asynchronous function,
    so processing its results has to be done by chaining another .then() callback
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: fetch 是一个异步函数，我们需要等待它完成后再处理 API 发送的数据。为此，我们使用回调 .then()，将其链式连接到我们的 API 调用。当
    fetch 调用完成时，它将自动运行 .then() 中的代码。在这种情况下，我们接收到一个响应（来自 API），我们使用 res.json() 将其转换为
    JSON。这也是一个异步函数，因此处理其结果必须通过链式调用另一个 .then() 回调来完成。
- en: In the last .then(), we retrieve the data parsed as JSON and we simply unpack
    it to lat, lon, and stations_infos. We then fire the different setter defined
    in App.js to update the different state variables. Note that in the case of stationsData,
    we use the spread operation [**…**someArray] which will create a copy of someArray.
    This is to make sure we create a new array to pass to stationsData and not just
    a reference to someArray which could cause some unexpecting behaviors.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在最后的 .then() 中，我们检索数据并将其解析为 JSON，然后简单地解包为 lat、lon 和 stations_infos。然后我们触发在 App.js
    中定义的不同设置器，以更新不同的状态变量。请注意，在 stationsData 的情况下，我们使用扩展操作 [**…**someArray]，这将创建 someArray
    的副本。这是为了确保我们创建一个新的数组传递给 stationsData，而不是仅仅引用 someArray，这可能会导致一些意外的行为。
- en: Clicking on the button will now fire the API call that will ultimately update
    the state variables in App.js.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮现在将触发 API 调用，最终更新 App.js 中的状态变量。
- en: Connect the StationsTable component
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接 StationsTable 组件
- en: If your recall from previous the article, we built the preview of StationsTable
    by using a pre-loaded JSON, which is following exactly the same format as what
    is stored now in the stationsData variable.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得之前的文章，我们通过使用一个预加载的 JSON 构建了 StationsTable 的预览，这个 JSON 的格式与当前存储在 stationsData
    变量中的完全一致。
- en: Downloading the data from the API and storing them in stationsData was the difficult
    part. Now we just need to modify slightly our StationsTable component to use stationsData
    instead of the pre-loaded JSON.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 从 API 下载数据并将其存储在 stationsData 中是困难的部分。现在我们只需稍微修改我们的 StationsTable 组件，以便使用 stationsData
    替代预加载的 JSON。
- en: First, we add an attribute to StationsTable the state variable stationsData
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在 StationsTable 中添加了一个名为 stationsData 的状态变量。
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We then add props to the declaration of the function in StationsTable.js
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们向 StationsTable.js 中的函数声明添加 props。
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we replace the pre-loaded JSON with the stationsData contained in
    the object props:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们用包含在对象 props 中的 stationsData 替换预加载的 JSON。
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: And that’s it, the data in the table will be replaced by the prices of stations
    around the city of interest every time we click on the button.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，每次我们点击按钮时，表格中的数据将会被我们感兴趣的城市周边的站点价格替代。
- en: '![](../Images/b1e8638e91fc74c7cabec35f8555e385.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b1e8638e91fc74c7cabec35f8555e385.png)'
- en: The update of the Table in action, Author Illustration
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 表格更新中的实际操作，作者插图。
- en: Generate the Map with the state variables
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用状态变量生成地图。
- en: 'You should start to be used to it by now, we are going to proceed as before:
    pass the data from App to StationsMap via the attributes of the tag, add props
    to StationsMap, and modify the relevant part of each of the trace we have pre-generated
    in the last article.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该现在已经习惯了，我们将按照之前的步骤进行：通过标签的属性将数据从 App 传递到 StationsMap，向 StationsMap 添加 props，并修改我们在上一篇文章中预生成的每个轨迹的相关部分。
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now in StationsMap.js, we will create the different traces one by one, following
    the template provided by the python figure (from Part I of this series), and replace
    the relevant data when needed.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在 StationsMap.js 中，我们将逐一创建不同的轨迹，按照 Python figure 提供的模板（本系列的第一部分），并在需要时替换相关数据。
- en: I show you here two examples below, then it becomes a bit redundant.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里展示两个示例，然后变得有些冗余。
- en: 'The trace for the circle around the perimeter of the research:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 研究周边的圆圈轨迹：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The black border of the oil stations:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 石油站的黑色边框：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Note: Mapbox traces require unique identifiers for each trace. To do so, we
    can use a very convenient toolbox called **uuid** which can generate random ids
    for us.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Mapbox 轨迹需要每个轨迹的唯一标识符。为此，我们可以使用一个非常方便的工具包 **uuid**，它可以为我们生成随机 id。
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When all our traces are defined, we can put them in a list that will be used
    as an attribute for our plotly component:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义好所有轨迹后，我们可以将它们放入一个列表中，该列表将作为我们 plotly 组件的属性。
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we can take care of the chart layout, using the same method: we take the
    dictionary exposed by the python figure and replace the “hardcoded” attributes
    with our state variables to make the layout interactive. In particular, we need
    to modify the “lat” and “lon” of the center of the layout to make sure that each
    time a user makes a request, the map will automatically recenter on the city of
    that request.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以处理图表布局，使用相同的方法：我们获取由 Python figure 暴露的字典，并用我们的状态变量替换“硬编码”的属性，使布局具有互动性。特别是，我们需要修改布局中心的“lat”和“lon”，以确保每次用户发起请求时，地图会自动重新聚焦到该请求的城市。
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Also, note something very important here: we are passing our **Mapbox access
    token** in the layout. This is something you don’t want to expose publicly, so
    you should NEVER hard-code it somewhere, or it could be usable by other people
    for other purposes.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，注意这里一个非常重要的事项：我们在布局中传递了我们的 **Mapbox 访问令牌**。这是你不想公开暴露的内容，所以你绝对不要将其硬编码在任何地方，否则其他人可能会将其用于其他目的。
- en: 'To add any secret variable in your project, you should add them within a .env
    file in the root of your project:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要在项目中添加任何秘密变量，你应该在项目根目录中添加一个 .env 文件：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The .env should be added to your .gitignore in such a way that you cannot push
    it accidentally to a public place.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: .env 应该被添加到你的 .gitignore 文件中，以防你意外将其推送到公共地方。
- en: In React, you need to respect the prefix REACT_APP_ which will be the only variables
    read by the framework.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 中，你需要遵守前缀 REACT_APP_，这将是框架读取的唯一变量。
- en: 'In our case, our .env looks simple like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，.env 看起来很简单，如下所示：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With our “data” and “layout” directly plugged into our states variable, we can
    simply generate our plotly graph the same way as we did in the previous article.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们直接连接到 states 变量的“data”和“layout”，我们可以像在上一篇文章中一样简单地生成我们的 plotly 图表。
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Let’s have a look at the web app in action!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看网页应用的实际效果！
- en: '![](../Images/82e0a523f4ff03027b99c0c9811a9bca.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/82e0a523f4ff03027b99c0c9811a9bca.png)'
- en: The API call interactively modifies the map and the table now, Author Illustration
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: API 调用现在可以交互地修改地图和表格，作者插图
- en: Improving the details
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进细节
- en: 'Our app answers now the main “user story”: from a type of oil and a postal
    code, we are able to retrieve and display information about the prices from the
    surrounding stations. And it is already a great step achieved. We would like now
    to improve a bit the user experience with a few improvements that will be detailed
    in this section.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用现在满足了主要的“用户故事”：通过一种油的类型和一个邮政编码，我们能够检索并显示周围加油站的价格信息。这已经是一个很大的进步。我们现在希望通过一些改进来进一步提升用户体验，这些改进将在本节中详细介绍。
- en: Initiate the Application with an API call
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 API 调用启动应用程序
- en: Our current version of the app initiate in the middle of nowhere, in the middle
    of the sea. This can be a bit disturbing for a user that would arrive there for
    the first time. In order to remove this, we are going to initiate the application
    with an API call around Paris for SP98.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前版本的应用程序在一个毫无标记的地方启动，即在海洋中央。这对于首次到达的用户可能会有点困扰。为了解决这个问题，我们将通过一个 API 调用在巴黎附近为
    SP98 启动应用程序。
- en: To do so, we are going to use the useEffect “hook” that we described in the
    first part of this article.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将使用在本文第一部分中描述的 useEffect “hook”。
- en: 'To do so, we start by passing the API call logic in App.js:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们首先在 App.js 中传递 API 调用逻辑：
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We then wrap this function in a useEffect hook with gasType=”SP98" and postalCode
    = “75001” which corresponds to the city center of Paris.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将这个函数包装在一个 useEffect hook 中，使用 gasType=”SP98" 和 postalCode = “75001”，这对应于巴黎市中心。
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As I pass an empty list in the second parameter of the useEffect, this bit of
    code will only be executed at the component initialization, which is exactly what
    we want.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我在 useEffect 的第二个参数中传递了一个空列表，这段代码将只在组件初始化时执行，这正是我们所期望的。
- en: Finally, now that we embedded all our update call logic in a function, we can
    do a bit of refactoring to our StationsFilter component by passing this function
    instead of all the setters for our state variables.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，现在我们将所有更新调用逻辑嵌入到一个函数中，我们可以对 StationsFilter 组件进行一些重构，将这个函数传递而不是所有状态变量的设置函数。
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And in StationsFilter.js, we just trigger this new function in the “HandleButtonClick”
    callback:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在 StationsFilter.js 中，我们只需在“HandleButtonClick”回调中触发这个新函数：
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Adding a distance slider
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加一个距离滑块
- en: In the current version of the app, we are displaying on the screen all the stations
    in a 30km perimeter, which can make sense in low-density areas but that can also
    be really heavy for high-density areas.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的当前版本中，我们在屏幕上显示了 30 公里范围内的所有加油站，这在低密度区域可能有意义，但在高密度区域可能会非常繁重。
- en: '![](../Images/924b15938260b7e18dcca085c1264531.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/924b15938260b7e18dcca085c1264531.png)'
- en: The 30km perimeter research… In which there is way too much information displayed,
    Author's Illustration
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 30 公里范围的搜索……其中显示了太多信息，作者插图
- en: To solve this issue, we are going to use a slider to control the perimeter of
    the research, from 1 km to 30 km. With React we have access to a large ecosystem
    of libraries and tools, and after some research, I found a slider component that
    would fit well in the Gas Finder App [here](https://www.npmjs.com/package/react-slider).
    I’ll not detail the styling here, only the interactions.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将使用一个滑块来控制搜索范围，从 1 公里到 30 公里。借助 React，我们可以访问大量的库和工具，在一些研究之后，我发现一个适合
    Gas Finder 应用的滑块组件 [这里](https://www.npmjs.com/package/react-slider)。我不会在这里详细描述样式，只关注交互部分。
- en: 'Let’s start by installing the react library:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 首先安装 react 库：
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can import the component simply in our project:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简单地将组件导入到我们的项目中：
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The slider will control another state variable (the filtering distance). Let’s
    add it to our App.py. I initiate it to 5km as a starting point.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 滑块将控制另一个状态变量（过滤距离）。让我们将其添加到我们的 App.py 中。我将其初始值设置为 5 公里作为起点。
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We will integrate the slider between the StationsFilter and the StationsTable.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把滑块集成到 StationsFilter 和 StationsTable 之间。
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: I will not go too much into the details here and pass on the .css, the component
    takes many parameters such as classes with the thumb and track, and minimum and
    maximum values. I modified the values based on the examples from [the documentation](https://zillow.github.io/react-slider/).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在这里详细说明 .css，组件接受许多参数，例如带有滑块和轨道的类，最小值和最大值。我根据 [文档](https://zillow.github.io/react-slider/)
    的示例修改了这些值。
- en: 'Two interesting things to note:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 两点值得注意：
- en: As for our Dropdown, we can control the value of the slider via our state variable.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至于我们的下拉菜单，我们可以通过状态变量控制滑块的值。
- en: 'We will modify distanceFilter by using another callback: onAfterChange which
    will fire only after the user stops moving the thumb.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将通过使用另一个回调函数 onAfterChange 来修改距离过滤器，它将在用户停止移动滑块后触发。
- en: At that point, our slider control distanceFilter, and we now need to use it
    to filter the data points. To achieve this, we need to create another array, which
    will be a filtered version of stationsData (the data taken from the API).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的滑块控制距离过滤器，我们现在需要使用它来过滤数据点。为此，我们需要创建另一个数组，它将是 stationsData（从 API 获取的数据）的过滤版本。
- en: '[PRE39]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We can now simply pass this filteredData instead of stationsData to our components
    and it will automatically update the stations visible based on the distance.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将这个 filteredData 传递给我们的组件，而不是 stationsData，它将根据距离自动更新可见的站点。
- en: 'There is one last thing to do: control the trace that shows the circle showing
    the perimeter of the research. Currently, the circle is based on the output sent
    by the API based on a 30km distance.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 还有最后一件事要做：控制显示研究范围周边的圆圈的轨迹。目前，圆圈是基于 API 发送的 30km 距离。
- en: 'There are two ways to make the modification: we could create a new API endpoint
    that would send us the array of points based on a lat/lon/radius and keep the
    logic of creating the circle in the backend, especially if you are more comfortable
    with python. This solution has the massive disadvantage that it will multiply
    the number of API calls every time a user plays a bit with the slider, which is
    something we would like to avoid for performance purposes.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以进行修改：我们可以创建一个新的 API 端点，它会根据纬度/经度/半径向我们发送点数组，并将创建圆形的逻辑保留在后端，特别是如果你更熟悉
    Python。这种解决方案有一个巨大的缺点，就是每次用户稍微调整滑块时都会增加 API 调用的次数，我们希望避免这种情况以提高性能。
- en: The other solution is to transpose our python function to calculate the circle
    in Javascript, which will be calculated directly on the client side of the application.
    We will go with that second option for performance reasons.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案是将我们的 Python 函数转置为 JavaScript 中计算圆形的函数，这将在客户端直接计算。出于性能原因，我们将选择第二种方案。
- en: 'Let’s start by creating a new utils folder located in StationsMap and containing
    a file drawCircle.js:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个新的 utils 文件夹，位于 StationsMap 中，并包含一个 drawCircle.js 文件：
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'I will transpose exactly the function that we used in python in Part I, but
    this time, in Javascript:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我将精确地转置我们在第一部分中使用的 Python 函数，但这次是在 JavaScript 中：
- en: '[PRE41]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: I will not go into the detail of that formula, it is a basic mathematical operation
    and is not relevant to this article. The main function, calcPointsOnCircle, is
    taking a lat/lon representing the center of the circle, a radius, and the number
    of points we desire. It returns an array made of tuples of (lat, lon).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会详细说明那个公式，它是一个基本的数学操作，与本文无关。主要函数 calcPointsOnCircle 接受表示圆心的纬度/经度、半径和所需的点数。它返回一个由
    (lat, lon) 元组组成的数组。
- en: An important point nevertheless if you are new to Javascript is that to make
    your function usable by other files, you need to export it at the end of the file.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，如果你是 JavaScript 新手，一个重要的点是，为了使你的函数可供其他文件使用，你需要在文件末尾导出它。
- en: '[PRE42]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The function can be now used directly in StationsMap to calculate interactively
    the circle based on the current state variables (lat/lon and selected distance).
    Let’s have a look at the code modifications.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个函数可以直接在 StationsMap 中使用，以根据当前状态变量（纬度/经度和选择的距离）互动计算圆形。让我们看看代码的修改。
- en: '[PRE43]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This concludes this section. By now, we have an interactive slider that controls
    the data displayed on the screen based on a filter on the distance.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 本节到此为止。到目前为止，我们有一个交互式滑块，它根据距离的过滤器控制屏幕上显示的数据。
- en: '![](../Images/41b705b976195dfdfd9224f07f9d5c10.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/41b705b976195dfdfd9224f07f9d5c10.png)'
- en: The slider in action, Author Illustration
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 滑块的操作，作者插图
- en: Keep current zoom level
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持当前的缩放级别
- en: At this point, every time a user play with the slider, it will reset the plotly
    view and regenerate the layout. The problem with this is that it also reset the
    zoom, which is a behavior we want to avoid, see the illustration below.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，每次用户操作滑块时，它都会重置 plotly 视图并重新生成布局。问题在于这也重置了缩放，这是我们想要避免的行为，见下图。
- en: '![](../Images/e4ce31ef495059ee907e529c0132ac49.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e4ce31ef495059ee907e529c0132ac49.png)'
- en: Issues with zoom, Author Illustration
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放问题，作者插图
- en: 'One way to tackle the problem is to control the zoom with the slider value
    so that it automatically adapts to the circle size. In our case, this is a very
    easy modification to perform as we are incrementing distanceFilter 1 by 1\. Thus,
    the simplest way is to create a mapping {current distance value -> zoom wanted}
    and use it to automatically control the zoom level. In StationsMap:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一种方法是通过滑块值来控制缩放，以便它自动适应圆的大小。在我们的例子中，这是一项非常简单的修改，因为我们是逐步增加距离过滤器。因此，最简单的方法是创建一个映射
    {当前距离值 -> 所需缩放} 并用它来自动控制缩放级别。在 StationsMap 中：
- en: '[PRE44]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*Note: to do the mapping, I simply iteratively looked for the best zoom level
    given the circle at different values (30,25,20…) and I performed a linear interpolation
    for the values in between.*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意：为了进行映射，我简单地迭代寻找了不同值（30,25,20…）下的最佳缩放级别，并对中间值进行了线性插值。*'
- en: Adding a title above the table
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在表格上方添加标题
- en: This is a little change to the app but it brings more clarity to the end user.
    When a request is made, we want a title to show explicitly the location of the
    research and the type of fuel.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对应用程序的一个小修改，但它为最终用户带来了更多的清晰度。当发出请求时，我们希望标题能够明确显示研究的位置和燃料类型。
- en: The API call provides already the city information and the gas type can be updated
    when a click is made on the button to make a new request.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: API 调用已经提供了城市信息，当点击按钮发起新请求时，燃料类型可以被更新。
- en: We are going to pass very quickly on the modifications to make as it is mostly
    reusing what we did until now with updating/passing state variables from one component
    to another.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将很快处理需要修改的内容，因为这主要是重新使用我们到目前为止所做的工作，通过从一个组件传递/更新状态变量到另一个组件。
- en: In App.js, we create our two new state variables
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在 App.js 中，我们创建了两个新的状态变量
- en: '[PRE45]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We can then update the ApiCallAndUpdateState function which is used when a user
    clicks a button.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以更新 ApiCallAndUpdateState 函数，这个函数在用户点击按钮时被调用。
- en: '[PRE46]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can now simply add a header between the StationsFilter and StationsTable:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在 StationsFilter 和 StationsTable 之间简单地添加一个标题：
- en: '[PRE47]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This now results in a header appearing above the table showing the current location
    of the research, as wanted.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这现在导致表格上方出现了一个标题，显示了研究的当前位置，符合要求。
- en: '![](../Images/20dec1084d96f7c700d17259eb4b5a73.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/20dec1084d96f7c700d17259eb4b5a73.png)'
- en: Adding a header above the table brings more clarity, User Illustration
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在表格上方添加标题带来了更多的清晰度，用户插图
- en: Consistent colors in the maps
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地图上的一致颜色
- en: In plotly, not precise lower and upper bounds when defining a heatmap will result
    by default stretching the scale to the minimum and maximum values of the population.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在 plotly 中，当定义热图时，未准确设置上下限将默认将比例拉伸到人口的最小值和最大值。
- en: 'This has a major disadvantage: In the case of a station that prices really
    lower or really higher than average, the color scale will not have a relevant
    meaning anymore.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个主要的缺点：如果某个站点的价格远低于或远高于平均值，则颜色比例将不再具有相关意义。
- en: Another problem we might meet is that the stations' colors will change depending
    on the distance used to filter because the number of stations will change, so
    will the max/min prices, and so, ultimately, the scale.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能遇到的问题是，站点的颜色会根据用于过滤的距离而变化，因为站点的数量会改变，最大/最小价格也会改变，因此最终，比例也会变化。
- en: To avoid the issue, we need to decide on a minimum and maximum value. Given
    the divergence color map used, we would like also the bounds to be symmetric.
    There are many possible solutions to that problem, I personally decided to go
    on “Price average in the 30km radius +/- 10%”, assuming that prices above or below
    that 10% around the average are anyway too high or too low.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，我们需要决定一个最小值和最大值。鉴于使用的发散颜色图，我们还希望这些范围是对称的。这个问题有很多可能的解决方案，我个人决定使用“30公里半径内的价格平均值
    +/- 10%”，假设高于或低于这个平均值10%的价格无论如何都太高或太低。
- en: 'To compute the average, we need to take the non-filtered data and calculate
    the sum over length. This is done in Javascript using the reduce method:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算平均值，我们需要取未过滤的数据并计算总和。此操作在 Javascript 中使用 reduce 方法完成：
- en: '[PRE48]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Note that sumPrice and avgPrice don’t need to be state variables: they will
    be always calculated when the new stationsData is updated.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，sumPrice 和 avgPrice 不需要作为状态变量：它们将始终在更新新的 stationsData 时计算。
- en: 'We can pass now avgPrice to StationsMap via the props as usual:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以像往常一样通过 props 将 avgPrice 传递给 StationsMap：
- en: '[PRE49]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: And update the chart by thresholding the prices above or below the defined bound.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 并通过对价格进行阈值处理来更新图表，以使其高于或低于定义的边界。
- en: '[PRE50]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The next figure illustrates the difference between standard bounds and our
    custom bounds, which brings more contrast:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 下一张图展示了标准边界和我们自定义边界之间的区别，这带来了更多对比度：
- en: '![](../Images/cd7b80951eb60603bb68864dc80d2a9f.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/cd7b80951eb60603bb68864dc80d2a9f.png)'
- en: Setting a lower/upper bound increase the color contrast, Author Illustration
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 设置上下边界会增加颜色对比度，作者插图
- en: Cleaning hover information in the chart
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理图表中的悬停信息
- en: 'Part of the small details to fix, the default hover from plotly needs a bit
    of customization. There are currently two main problems:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 需要修复的小细节，plotly 的默认悬停需要一点自定义。目前有两个主要问题：
- en: The hover event triggered when a user checks a station shows also the lat/lon
    by default, which is not something we want to see (we would like to see only the
    price)
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户检查一个站点时触发的悬停事件默认也显示 lat/lon，这不是我们想看到的（我们只想看到价格）
- en: When the mousse passes on the black trace or the red dot, coordinates are also
    displayed and we would like to remove this interaction
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当鼠标经过黑色轨迹或红点时，也会显示坐标，我们希望移除这种交互
- en: For the first point, we can simply pass a **hovertemplate** parameter that controls
    the content displayed when there is a mousse hover. The below formula includes
    only the parameter in the “text” attribute and <extra></extra> remove the default
    box.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一点，我们可以简单地传递一个**hovertemplate** 参数，该参数控制鼠标悬停时显示的内容。下面的公式仅在“text”属性中包含该参数，<extra></extra>
    移除默认的框。
- en: '[PRE51]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: For the second point, it is even easier, we just need to pass a parameter
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二点，更简单，我们只需传递一个参数
- en: '[PRE52]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: which will completely remove the hover interaction for the trace.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这将完全移除轨迹的悬停交互。
- en: Handle API errors
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理 API 错误
- en: 'There is a last thing we will explore in this article: handling an API error.
    If a user tries a postal code that is not in the database, the API is returning
    a custom error 400\. When this happens, we want to modify our text field to make
    the user understand there was a problem with his input and highlight the input
    field in red.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们还将探索最后一件事：处理 API 错误。如果用户尝试一个不在数据库中的邮政编码，API 将返回自定义错误 400。当发生这种情况时，我们希望修改文本字段以使用户理解其输入存在问题，并用红色突出显示输入字段。
- en: Let’s start by adding a new state variable in App.js
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始在 App.js 中添加一个新的状态变量
- en: '[PRE53]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We can now modify our fetch method to include an action when something abnormal
    happens.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以修改我们的 fetch 方法，以便在发生异常时执行某些操作。
- en: The first step is to throw an error if we don’t receive a proper response from
    the API.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是如果我们没有收到 API 的正确响应，则抛出一个错误。
- en: '[PRE54]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'After that, we need to catch this error at the end of our processing pipeline,
    and setApiError to “true”. We need also to make sure that apiError is set back
    to “false” after a good request:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要在处理管道的末尾捕捉此错误，并将 setApiError 设置为“true”。我们还需要确保在请求成功后 apiError 被设置回“false”：
- en: '[PRE55]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We can finally pass apiError to our StationsForm component and modify the styling
    of the postalCode text field. One way of doing it is to add an extra class to
    the text field when apiError is “true”…
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以最终将 apiError 传递给我们的 StationsForm 组件，并修改邮政编码文本字段的样式。实现这一点的一种方法是，当 apiError
    为“true”时向文本字段添加额外的类……
- en: '[PRE56]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: … and add extra CSS for that input-error class
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: … 并为该 input-error 类添加额外的 CSS
- en: '[PRE57]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '![](../Images/6b819b63d2df6aa49a7a8b064cc004b0.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6b819b63d2df6aa49a7a8b064cc004b0.png)'
- en: When a wrong postal code is used, the text field change with a red border, Author
    Illustration
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用错误的邮政编码时，文本字段会更改为红色边框，作者插图
- en: Conclusion
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: This last implementation concludes completely the chapter dedicated to the development
    of the UI of a web app using React.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的实现完全结束了专门用于开发 React 网络应用程序 UI 的章节。
- en: React is gaining more and more traction in the data scientist/data analyst community,
    and even if there is certainly a lot of time to invest in learning the framework,
    we saw through this example that once mastered, this allows us to build robust,
    powerful, and responsive applications.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: React 在数据科学家/数据分析师社区中越来越受欢迎，尽管学习这个框架需要投入大量时间，但通过这个例子我们看到，一旦掌握，它可以让我们构建出稳健、强大且响应迅速的应用程序。
- en: With the UI completed, are now halfway to the completion of the prototype phase.
    In the next article, we are going to talk about the server side and prepare our
    API and our database.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: UI 完成后，我们现在已经完成了原型阶段的一半。在下一篇文章中，我们将讨论服务器端，并准备我们的 API 和数据库。
