- en: The Guide to Recommender Metrics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://towardsdatascience.com/the-guide-to-recommender-metrics-c5d72193ea2b](https://towardsdatascience.com/the-guide-to-recommender-metrics-c5d72193ea2b)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Evaluating a recommender system offline can be tricky
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://dr-robert-kuebler.medium.com/?source=post_page-----c5d72193ea2b--------------------------------)[![Dr.
    Robert K√ºbler](../Images/3b8d8b88f76c0c43d9c305e3885e7ab9.png)](https://dr-robert-kuebler.medium.com/?source=post_page-----c5d72193ea2b--------------------------------)[](https://towardsdatascience.com/?source=post_page-----c5d72193ea2b--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----c5d72193ea2b--------------------------------)
    [Dr. Robert K√ºbler](https://dr-robert-kuebler.medium.com/?source=post_page-----c5d72193ea2b--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ¬∑Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----c5d72193ea2b--------------------------------)
    ¬∑10 min read¬∑Nov 12, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a0e23c68bcbb7f9ec133307392f474e1.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Darius Cotoi](https://unsplash.com/@dariuscotoi?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Think of the YouTube main page, which displays videos that you might like, or
    Amazon which suggests you buy more of the products they sell. These are examples
    of **recommender systems** that try to show the things, you most likely want to
    interact with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us assume that you have built a recommender system with a method of your
    choice as well. The question is: how do you evaluate it **offline**, **before
    you put it in production** and let it serve recommendations on a website?'
  prefs: []
  type: TYPE_NORMAL
- en: In this article, you will learn exactly that! Additionally, I will tell you
    **why you should be careful** with these metrics.
  prefs: []
  type: TYPE_NORMAL
- en: For a more thorough introduction, please refer to my other article which also
    shows you how to build a recommender system from scratch using TensorFlow.
  prefs: []
  type: TYPE_NORMAL
- en: '[](/introduction-to-embedding-based-recommender-systems-956faceb1919?source=post_page-----c5d72193ea2b--------------------------------)
    [## Introduction to Embedding-Based Recommender Systems'
  prefs: []
  type: TYPE_NORMAL
- en: Learn to build a simple matrix factorization recommender in TensorFlow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/introduction-to-embedding-based-recommender-systems-956faceb1919?source=post_page-----c5d72193ea2b--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Offline Evaluation of a Recommender
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us find a definition for a recommender first that encompasses most systems
    you might design or find in the wild.
  prefs: []
  type: TYPE_NORMAL
- en: For us, a recommender is an algorithm that takes at least a user as an input
    and outputs an ordered list of items to recommend to this user.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/3acf18e0094ba1625ed777809df9ec49.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: Why *at least* a user? There could be more inputs such as the time of year that
    can help the model learn not to recommend Chocolate Santas in summer.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, a fruit recommender *R* that we have built can do things like
    *R*(Alice) = [apple, orange, cherry].
  prefs: []
  type: TYPE_NORMAL
- en: '***Note:*** *The user could be something else, maybe even another article.
    This could be relevant if you want to build a recommender for* ***alternatives***
    *when some article in your shop is out of stock. So, your recommender takes an
    article as an input and outputs its alternatives. Let us stick with classical
    user-item recommendations, though.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What follows now is a list of offline recommender metrics that you can use to
    assess the quality of your recommender system. I will show you how they are defined,
    and which details to pay attention to when using them.
  prefs: []
  type: TYPE_NORMAL
- en: '*Train-test splitting*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will assume that we have done some form of train-test splitting to get meaningful
    metrics. Otherwise, we will only measure the ability of our recommender system
    to overfit. Assume that we have data like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1084ebf74e2131efa5c2916e32ce0d35.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: '**Read:** User **A** bought/watched/listened to item **X** (e.g. movie or song).
    I will go with ‚Äúbought‚Äù for the rest of the article.'
  prefs: []
  type: TYPE_NORMAL
- en: There are many options to split, and you should choose one or the other depending
    on the application.
  prefs: []
  type: TYPE_NORMAL
- en: '**Random split:** You take all rows and randomly split them into train and
    test.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Temporal split:** You select a threshold date and put all entries before
    this date into train, and the rest into test.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ‚Ä¶
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Usually, I go for a temporal split, whenever I have a date column because it
    behaves exactly as the model is intended to be used: we **train** a model on **past
    data**, and we want it to **perform well** in the **future**. But think if this
    makes sense in your case as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Alright, after we have defined some split let us proceed to the metrics!
  prefs: []
  type: TYPE_NORMAL
- en: Regression Metrics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the best case, you don‚Äôt only have transactional data √† la user **A** bought
    item **X**, but even some kind of **explicit** feedback, such as a user rating
    (1‚Äì5 stars). In this case, you can also let your model **output** not only a list
    of items but also their **predicted rating**. Then you can take any regression
    metric you like, such as the mean squared error or the mean absolute error to
    measure how far your predicted ratings are from the actual ones. This is nothing
    new, hence we leave it at that.
  prefs: []
  type: TYPE_NORMAL
- en: Alignment Metrics for Recommender Systems From Implicit Feedback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will assume that we do **not** have any explicit feedback such as a star
    rating, but only implicit feedback such as ‚Äúuser **A** bought item **X**‚Äù from
    now on. For more information about implicit feedback, check out at least the introduction
    of my other article:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/recommender-systems-from-implicit-feedback-using-tensorflow-recommenders-8ba36a976c57?source=post_page-----c5d72193ea2b--------------------------------)
    [## Recommender Systems From Implicit Feedback Using TensorFlow Recommenders'
  prefs: []
  type: TYPE_NORMAL
- en: When customers don‚Äôt explicitly tell you what they want
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/recommender-systems-from-implicit-feedback-using-tensorflow-recommenders-8ba36a976c57?source=post_page-----c5d72193ea2b--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Preparation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All the metrics that we will cover work with two ingredients:'
  prefs: []
  type: TYPE_NORMAL
- en: a list of items that a user bought in the **test set**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the recommendation list (this is the prediction!) for the same user after training
    the model on the **training set**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following metrics measure how well these two lists are aligned. Let us see
    how in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us assume that we have only a single user **Alice** for now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'in the test set, Alice bought the following items: üççüçéüçâüçåüçí'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The recommender outputs the following: üçåüçêüçíüçàüçá (in this order)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We call the items that Alice got recommended **and** were bought by her in
    the test set **relevant**. In our case: üçå and üçí. Items that were suggested but
    not bought by Alice are irrelevant, namely üçê, üçà and üçá.'
  prefs: []
  type: TYPE_NORMAL
- en: '*If we have several users, we just compute the following metrics for each single
    user and take the average over all users. Also, we will define a lot of metrics
    with an* ***@*k** *suffix. This only means that we* ***truncate the recommended
    list to* k *articles*** *and then compute the metric.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Precision@k
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In words:'
  prefs: []
  type: TYPE_NORMAL
- en: Out of the top (first) k recommended items, how many % are relevant to Alice?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let us calculate the precision@3\. In reality, Alice bought üççüçéüçâüçåüçí, but got suggested
    üçåüçêüçí by the recommender system as the first 3 items. How many of these 3 items
    were relevant? Well, only üçå and üçí appeared in the test set, so this makes **precision@3
    = 2/3 ‚âà 66,7%**.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reminder:** Our recommender suggests Alice üçåüçêüçíüçàüçá.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can calculate precision@*k* for all other *k*‚Äôs that way: precision@1 =
    1/1, precision@2 = 1/2, precision@4 = 2/4, precision@5 = 2/5\. As a general formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/112734e2fa634c6e03508962744f8158.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: Here, rel*·µ¢* is either 0 or 1, depending on whether the item in position *i*
    of the recommended list is relevant (1) or not (0).
  prefs: []
  type: TYPE_NORMAL
- en: '*Starting from now, we will work with the rel·µ¢ only because then we don‚Äôt have
    to keep in mind which of the fruits are relevant and which not. So, we turn üçåüçêüçíüçàüçá
    into* ***[1, 0, 1, 0, 0]*** *since üçå and üçí are relevant.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This metric is straightforward because you only have to count how many items
    were relevant. Still, this metric comes in some flavors. For example, if our recommender
    shows 5 items, but Alice only ever bought 3 in the test set. Then it is impossible
    for the recommender to score 100%, the maximum would be 3/5 = 60%. If you think
    this is unfair, you can adjust the metric by not dividing the sum *k*, but by
    **either *k* or the** **total number of items that Alice bought in the test set**,
    whatever is smaller.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a17204ed35b0d6ec2a74b826c2a9c678.png)'
  prefs: []
  type: TYPE_IMG
- en: total = total number of items that Alice bought in the test set.Image by the
    author.
  prefs: []
  type: TYPE_NORMAL
- en: '**The disadvantage of precision@*k***: The order of the recommendations is
    ignored. The precision@5 for the recommendations with relevance scores [1, 0,
    1, 0, 0] is the same as for [0, 0, 0, 1, 1], although having the relevant items
    higher in the list is preferable. You also want your relevant search engine result
    to be in the first place and not in the 7th.'
  prefs: []
  type: TYPE_NORMAL
- en: Recall@*k*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This one is similar to the precision@*k*.
  prefs: []
  type: TYPE_NORMAL
- en: Out of all relevant items, how many % were recommended to Alice?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let us compute the recall@2: Alice bought **in total** the 5 items üççüçéüçâüçåüçí and
    got recommended *üçåüçê i*n the first two places*.* Only the single item üçå was covered
    by our recommender, so recall@2 = 1/5.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also compute: recall@1 = 1/5, recall@3 = 2/5, recall@4 = 2/5, recall@5
    = 2/5\. In general:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e7c07c03035256d991c1bd513eeb840c.png)'
  prefs: []
  type: TYPE_IMG
- en: total = total number of items that Alice bought in the test set.Image by the
    author.
  prefs: []
  type: TYPE_NORMAL
- en: Again, you can argue that this is sometimes unfair. Even a perfect recommender
    cannot cover all of the **total** items if *k* < **total**. For example, the maximum
    value for recall@2 is 2/5, if the first two items are relevant. You can adjust
    it as well, and it turns out that you end up with the same formula as for the
    adjusted precision@*k*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/065286e705f662bc6df681de5d0d4213.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: '**The disadvantage of recall@*k***: The same as before. The order of the recommendations
    is ignored.'
  prefs: []
  type: TYPE_NORMAL
- en: NDCG@k
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This one is a bit tougher because it consists of two parts: **DCG** and **IDCG**.
    But before we start, one piece of information in advance: this one cares about
    the recommendation order! So, let us see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DCG**: This is short for discounted cumulative gain. It has the formula'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6b1a1ad40cc3fd354e87ec8bf0c70d00.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see why the recommendation order matters ‚Äî each relevancy term
    rel*·µ¢* gets punished for being further down the list. rel‚ÇÅ gets divided by log‚ÇÇ(2)
    = 1, rel‚ÇÇ gets divided by log‚ÇÇ(3) ‚âà 1.585, rel‚ÇÉ gets divided by log‚ÇÇ(4) = 2, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: So the relevant items should better be positioned at the top of the list, where
    the **discounting** (punishment) terms are still low.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this metric alone is that it is unbounded. In our example [1,
    0, 1, 0, 0], the DCG@3 is 1/log‚ÇÇ(2) + 0/log‚ÇÇ(3) + 1/log‚ÇÇ(4) = 1 + 0.5 = 1.5\.
    That‚Äôs why we will now compute an **upper bound for the DCG** by checking how
    well a perfect recommender would perform.
  prefs: []
  type: TYPE_NORMAL
- en: '**IDCG:** This is short for **ideal** discounted cumulative gain. Our recommender
    that outputs a relevancy pattern of [1, 0, 1, 0, 0] is not perfect. A truly **perfect
    recommender** would place all the items that Alice bought in the test set at the
    top of the list, i.e. the relevancy pattern would be [1, 1, 1, 1, 1] since Alice
    bought 5 items.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Note:*** *If Alice would have bought only 2 items in the test set, a perfect
    recommender would output [1, 1, 0, 0, 0] instead because there are no more relevant
    items to fill the recommendation list.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So, the DCG cannot be higher than if all 5 recommended items would be relevant
    in our case. We can compute IDCG@3 = 1/log‚ÇÇ(2) + 1/log‚ÇÇ(3) + 1/log‚ÇÇ(4) ‚âà 2.131.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/868f4dbe9a58437bc2b2a6979e82c2ce.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: '**NDCG**: Finally, we can define the **normalized** discounted cumulative gain
    NDCG@*k* as'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/cd33b1c0af482fe870a947eb4a39b630.png)'
  prefs: []
  type: TYPE_IMG
- en: So, in our case, NDCG@3 = DCG@3 / IDCG@3 ‚âà 1.5 / 2.131 ‚âà **0.704**.
  prefs: []
  type: TYPE_NORMAL
- en: We can test what happens if we make our recommender worse, for example, if the
    relevancy pattern would be [0, 1, 1] . Then the DCG@3 is 0/log‚ÇÇ(2) + 1/log‚ÇÇ(3)
    + 1/log‚ÇÇ(4) ‚âà 1.131 and the NDCG@3 ‚âà 1.131 / 2.131 ‚âà 0.531 < 0.704.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion & Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../Images/9bd83022523ae67ab5860803d147b8a2.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [ANIRUDH](https://unsplash.com/@lanirudhreddy?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, great, we have discussed some common metrics. We have also seen how these
    metrics measure how good a ranking output by a recommender matches items that
    a user bought. However, please ask yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: Is this really what we want?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After all, the users have bought these items already, even **without the help
    of our recommender** (since we are developing it right now!). So, we basically
    measure how well our recommender can show the things that the customers would
    buy anyway.
  prefs: []
  type: TYPE_NORMAL
- en: It might be that the *interaction rate* (share of people who click on it) of
    our recommender increases when we use it in production. But I am not sure if this
    is a win since chances are that they would have bought a lot of these items anyway.
    Maybe we just provided them with a shortcut on a start page. This is not a bad
    thing because it might translate into higher customer satisfaction, which can
    be good for other goals. But it might not have the big impact on revenue that
    you want it to have.
  prefs: []
  type: TYPE_NORMAL
- en: To increase revenue ‚Äî which is often your ultimate goal ‚Äî maybe it makes more
    sense to show items to the users that they would not buy on their own. But this
    is hard to measure offline. You have to implement a recommender and then test
    it **online**, so you can see what your customers really want.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, you could test a recommender with a **high diversity**, i.e.,
    a recommender that shows items from different categories. Or do you think it is
    always wise to show 100% comedies to someone on Netflix, even if this person likes
    comedies? Maybe it makes sense to show different genres as well.
  prefs: []
  type: TYPE_NORMAL
- en: But, as I said, that is what you have to test online using **A/B tests**. Maybe
    your users like to be recommended the things that they buy anyway, but maybe not.
  prefs: []
  type: TYPE_NORMAL
- en: Don‚Äôt guess, just test.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**In the best case, you can observe a correlation between one of your offline
    metrics with the online KPI you care about. Then it makes sense to optimize for
    this offline metric. But if you don‚Äôt have this correlation, be careful when throwing
    away a model just because its NDCG is lower than another model‚Äôs NDCG.**'
  prefs: []
  type: TYPE_NORMAL
- en: I hope that you learned something new, interesting, and valuable today. Thanks
    for reading!
  prefs: []
  type: TYPE_NORMAL
- en: '*If you have any questions, write me on* [*LinkedIn*](https://www.linkedin.com/in/dr-robert-k%C3%BCbler-983859150/)*!*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: And if you want to dive deeper into the world of algorithms, give my new publication
    **All About Algorithms** a try! I‚Äôm still searching for writers!
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/all-about-algorithms?source=post_page-----c5d72193ea2b--------------------------------)
    [## All About Algorithms'
  prefs: []
  type: TYPE_NORMAL
- en: From intuitive explanations to in-depth analysis, algorithms come to life with
    examples, code, and awesome‚Ä¶
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/all-about-algorithms?source=post_page-----c5d72193ea2b--------------------------------)
  prefs: []
  type: TYPE_NORMAL
