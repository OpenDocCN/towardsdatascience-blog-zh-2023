["```py\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef generate_signal(frequency, duration, sampling_rate):\n    t = np.linspace(0, duration, int(sampling_rate * duration), endpoint=False)\n    signal = np.sin(2 * np.pi * frequency * t)\n    return t, signal\n\ndef plot_signals(t, original_signal, filtered_signal, title):\n    plt.figure(figsize=(10, 6))\n    plt.plot(t, original_signal, label='Original Signal', linewidth=2)\n    plt.plot(t, filtered_signal, label='Filtered Signal', linestyle='dashed', linewidth=2)\n    plt.title(title)\n    plt.xlabel('Time (s)')\n    plt.ylabel('Amplitude')\n    plt.legend()\n    plt.grid(True)\n    plt.show()\n```", "```py\nfrom scipy.signal import butter, lfilter\n\ndef apply_antialiasing(signal, cutoff_frequency, sampling_rate, order=4):\n    # Design a low-pass Butterworth filter (maximal flat magnitute)\n    nyquist = 0.5 * sampling_rate\n    # Nyquist law in practice\n    normal_cutoff = cutoff_frequency / nyquist\n    b, a = butter(order, normal_cutoff, btype='low', analog=False)\n\n    # Apply the filter to the signal\n    filtered_signal = lfilter(b, a, signal)\n    return filtered_signal\n```", "```py\n frequency = 30.0          # Frequency of the signal\nduration = 1.0            # Duration of the signal in seconds\nsampling_rate = 100.0     # Sampling rate in Hz\ncutoff_frequency = 20.0   # Cutoff frequency of the anti-aliasing filter\n\n# Generate a signal\nt, original_signal = generate_signal(frequency, duration, sampling_rate)\n\n# Apply anti-aliasing filter\nfiltered_signal = apply_antialiasing(original_signal, cutoff_frequency, sampling_rate)\n\n# Plot the original and filtered signals\nplot_signals(t, original_signal, filtered_signal, 'Original and Filtered Signals')\n```", "```py\nfrom scipy.signal import butter, cheby1, cheby2, ellip, lfilter\ndef apply_filter(signal, cutoff_frequency, sampling_rate, filter_type='butter', order=4):\n    nyquist = 0.5 * sampling_rate\n    normal_cutoff = cutoff_frequency / nyquist\n\n    if filter_type == 'butter':\n        b, a = butter(order, normal_cutoff, btype='low', analog=False)\n    elif filter_type == 'cheby1':\n        b, a = cheby1(order, 5, normal_cutoff, btype='low', analog=False)\n    elif filter_type == 'cheby2':\n        b, a = cheby2(order, 40, normal_cutoff, btype='low', analog=False)\n    elif filter_type == 'ellip':\n        b, a = ellip(order, 5, 40, normal_cutoff, btype='low', analog=False)\n\n    filtered_signal = lfilter(b, a, signal)\n    return filtered_signal\n```", "```py\n def plot_signals_subplots(t, original_signal, filtered_signals, titles):\n    num_filters = len(filtered_signals)\n\n    fig, axes = plt.subplots(num_filters + 1, 1, figsize=(12, 2 * (num_filters + 1)))\n\n    # Plot original signal\n    axes[0].plot(t, original_signal, label='Original Signal', linewidth=2, alpha=0.7)\n    axes[0].set_title('Original Signal')\n    axes[0].set_xlabel('Time (s)')\n    axes[0].set_ylabel('Amplitude')\n    axes[0].legend()\n    axes[0].grid(True)\n\n    # Plot filtered signals\n    for i, (filtered_signal, filter_type) in enumerate(zip(filtered_signals, filter_types)):\n        label = f'Filtered Signal ({filter_type})'\n        axes[i + 1].plot(t, filtered_signal, label=label, linestyle='dashed', linewidth=2)\n        axes[i + 1].set_title(f'Filtered Signal ({filter_type})')\n        axes[i + 1].set_xlabel('Time (s)')\n        axes[i + 1].set_ylabel('Amplitude')\n        axes[i + 1].legend()\n        axes[i + 1].grid(True)\n\n    plt.tight_layout()\n    plt.show()\n```", "```py\n# Generate a signal (exactly the same as previous)\nt, original_signal = generate_signal(frequency, duration, sampling_rate)\n\n# Apply different filters\nfilter_types = ['butter', 'cheby1', 'cheby2', 'ellip']\nfiltered_signals = [apply_filter(original_signal, cutoff_frequency, sampling_rate, f) for f in filter_types]\n\n# Plot the original and filtered signals\nplot_signals(t, original_signal, filtered_signals, 'Original and Filtered Signals')\n```", "```py\ndef generate_signal_with_noise(frequency, duration, sampling_rate, noise_amplitude=0.1):\n    t = np.linspace(0, duration, int(sampling_rate * duration), endpoint=False)\n    signal = np.sin(2 * np.pi * frequency * t)\n\n    # Add noise to the signal\n    noise = noise_amplitude * np.random.normal(size=len(signal))\n    signal_with_noise = signal + noise\n\n    return t, signal_with_noise\n```", "```py\n# Generate a noisy signal\nt, original_signal = generate_signal(frequency, duration, sampling_rate)\nt, original_signal_with_noise = generate_signal_with_noise(frequency, duration, sampling_rate, noise_amplitude=0.8)\n# Apply different filters\nfilter_types = ['butter', 'cheby1', 'cheby2', 'ellip']\nfiltered_signals = [apply_filter(original_signal_with_noise, cutoff_frequency, sampling_rate, f) for f in filter_types]\n\n# Plot the original and filtered signals\nplot_signals_subplots(t, original_signal_with_noise, filtered_signals, 'Original and Filtered Signals')\n```", "```py\nfrom statsmodels.tsa.seasonal import seasonal_decompose    \n\n# Generate a signal with noise\nt, original_signal_with_noise = generate_signal_with_noise(frequency, duration, sampling_rate, noise_amplitude=0.8)\n\n# Perform seasonal decomposition\ndecomposition = seasonal_decompose(original_signal_with_noise, period=25)  # Adjust the period as needed\n\n# Get the trend, seasonal, and residual components\ntrend = decomposition.trend\nseasonal = decomposition.seasonal\nresidual = decomposition.resid\n\n# Plot signals in separate subplots\nplot_signals_subplots(t, original_signal_with_noise, [trend, seasonal, residual], 'Original Signal with Noise and Decomposed Components')\n```", "```py\ndef generate_signal_with_wear_and_noise(frequency, duration, sampling_rate, wear_slope=0.02, noise_amplitude=0.1):\n    t = np.linspace(0, duration, int(sampling_rate * duration), endpoint=False)\n    signal = np.sin(2 * np.pi * frequency * t)\n\n    # Simulate equipment wearing with a linear trend\n    wear = wear_slope * t\n    signal_with_wear = signal + wear\n\n    # Add noise to the signal\n    noise = noise_amplitude * np.random.normal(size=len(signal))\n    signal_with_wear_and_noise = signal_with_wear + noise\n\n    return t, signal_with_wear_and_noise\n```", "```py\n# Generate a signal with equipment wearing and noise\n    t, original_signal_with_wear_and_noise = generate_signal_with_wear_and_noise(\n        frequency, duration, sampling_rate, wear_slope=0.5, noise_amplitude=0.1\n    )\n\n    # Perform seasonal decomposition\n    decomposition = seasonal_decompose(original_signal_with_wear_and_noise, period=25)  # Adjust the period as needed\n\n    # Get the trend, seasonal, and residual components\n    trend = decomposition.trend\n    seasonal = decomposition.seasonal\n    residual = decomposition.resid\n\n    # Plot signals in separate subplots with component names\n    plot_signals_subplots(t, original_signal_with_wear_and_noise, [trend, seasonal, residual], 'Signal with Wearing and Noise, and Decomposed Components')\n```"]