- en: Developing an Autonomous Dual-Chatbot System for Research Paper Digesting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/developing-an-autonomous-dual-chatbot-system-for-research-paper-digesting-ea46943e9343](https://towardsdatascience.com/developing-an-autonomous-dual-chatbot-system-for-research-paper-digesting-ea46943e9343)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A project walk-through for the concept, implementation, and demonstration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://shuaiguo.medium.com/?source=post_page-----ea46943e9343--------------------------------)[![Shuai
    Guo](../Images/d673c066f8006079be5bf92757e73a59.png)](https://shuaiguo.medium.com/?source=post_page-----ea46943e9343--------------------------------)[](https://towardsdatascience.com/?source=post_page-----ea46943e9343--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----ea46943e9343--------------------------------)
    [Shuai Guo](https://shuaiguo.medium.com/?source=post_page-----ea46943e9343--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----ea46943e9343--------------------------------)
    ·28 min read·Aug 14, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ccf2282defca7f209f1bce829d03c604.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Aaron Burden](https://unsplash.com/@aaronburden?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: As a researcher, reading and understanding scientific papers has always been
    a crucial part of my daily routine. I still remember the tricks I learned in grad
    school for how to digest a paper efficiently. However, with countless research
    papers being published every day, I felt overwhelmed to keep up to date with the
    latest research trends and insights. The old tricks I learned can only help so
    much.
  prefs: []
  type: TYPE_NORMAL
- en: Things start to change with the recent development of large language models
    (LLMs). Thanks to their remarkable contextual understanding capability, LLMs can
    fairly accurately identify relevant information from the user-provided documents
    and generate high-quality answers to the user’s questions about the documents.
    A myriad of document Q&A tools have been developed based on this idea and some
    tools are designed specifically to assist researchers in understanding complex
    papers within a relatively short amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although it’s definitely a step forward, I noticed some friction points when
    using those tools. One of the main issues I had is prompt engineering. Since the
    quality of LLM responses depends heavily on the quality of my questions, I often
    found myself spending quite some time crafting the “perfect” question. This is
    especially challenging when reading papers in unfamiliar research fields: oftentimes
    I simply don’t know what questions to ask.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This experience got me thinking: is it possible to develop a system that can
    automate the process of Q&A about research papers? A system that can distill key
    points from a paper more efficiently and autonomously?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously, I worked on [a project where I developed a dual-chatbot system
    for language learning](https://medium.com/towards-data-science/building-an-ai-powered-language-learning-app-learning-from-two-ai-chatting-6db7f9b0d7cd).
    The concept there was simple yet effective: by letting two chatbots chat in a
    user-specified foreign language, the user could learn the practical usage of the
    language by simply observing the conversation. The success of this project led
    me to an interesting thought: could a similar dual-chatbot system be useful for
    understanding research papers as well?'
  prefs: []
  type: TYPE_NORMAL
- en: So, in this blog post, we are going to bring this idea to life. Specifically,
    we will walk through the process of developing a dual-chatbot system that can
    digest research papers in an autonomous manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this journey a fun experience, we are going to approach it as a software
    project and run a Sprint: we will begin with "ideation", where we introduce the
    concept of leveraging a dual-chatbot system to tackle our problem. Then comes
    the “Sprint execution”, during which we’ll incrementally build the features of
    our design. Lastly, we will show our demo in the “Sprint review” and reflect on
    the learnings and future opportunities in the “Sprint Retrospective”.'
  prefs: []
  type: TYPE_NORMAL
- en: Ready to run the Sprint? let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: This is the 2nd blog on my series of LLM projects. The 1st one is [Building
    an AI-Powered Language Learning App](/building-an-ai-powered-language-learning-app-learning-from-two-ai-chatting-6db7f9b0d7cd),
    and the 3rd one is [Training Soft Skills in Data Science with Real-Life Simulations](/training-soft-skills-in-data-science-with-real-life-simulations-a-role-playing-dual-chatbot-c80dec3dd08c).
    Feel free to check them out!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Table of Content**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**·** [**1\. Concept: dual-chatbot system**](#87c3) **·** [**2\. Sprint Planning:
    what we want to build**](#08c8) **·** [**3\. Feature 1: Document Embedding Engine**](#c8d4)
    **·** [**4\. Feature 2: Dual-Chatbot System**](#bd53)'
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [4.1 Abstract chatbot class](#0806)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [4.2 Journalist chatbot class](#0a1e)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [4.3 Author bot class](#55dc)
  prefs: []
  type: TYPE_NORMAL
- en: '∘ [4.4 Quick test: the interview](#2a76)'
  prefs: []
  type: TYPE_NORMAL
- en: '**·** [**5\. Feature 3: User Interaction**](#3784)'
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [5.1 Creating the chat environment (in Jupyter Notebook)](#1372)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [5.2 Implementing PDF highlighting functionality](#e992)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [5.3 Allowing user input for questions](#b3df)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [5.4 Allowing downloading the generated script](#aff5)
  prefs: []
  type: TYPE_NORMAL
- en: '**·** [**6\. Sprint Review: show the demo!**](#a1e2) **·** [**7\. Sprint Retrospective**](#0d19)'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Concept: dual-chatbot system'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The foundation of our solution lies in the concept of a dual-chatbot system.
    As its name implies, this system involves two chatbots (powered by large language
    models) engaging in an autonomous dialogue. By specifying a high-level task description
    and assigning relevant roles to the chatbots, users can guide the conversation
    toward their desired direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'To give a concrete example: [in my previous project where a dual-chatbot is
    developed for assisting language learning](https://medium.com/towards-data-science/building-an-ai-powered-language-learning-app-learning-from-two-ai-chatting-6db7f9b0d7cd),
    the learner (user) can specify a real-life scenario (e.g., dining at a restaurant)
    and assign roles for chatbots to play (e.g., bot 1 as the waitstaff and bot 2
    as the customer), the two bots would then simulate a conversation in the user’s
    chosen foreign language, mimicking the interaction between the assigned roles
    in the given scenario. This allows an on-demand generation of fresh, scenario-specific
    language learning materials, therefore helping users better understand language
    usage in real-life situations.'
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we adapt this concept for the autonomous digestion of research papers?
  prefs: []
  type: TYPE_NORMAL
- en: The key lies in the **role assignment**. More specifically, one bot could take
    the role of a “**journalist**”, whose main task is to conduct an interview to
    understand and extract key insights from a research paper. Meanwhile, the other
    bot could play the role of an “**author**”, who has full access to the research
    paper and is tasked with providing comprehensive answers to the “journalist” bot’s
    queries.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to interaction, the journalist bot will initiate the dialogue
    and kicks off the interview process. The author bot will then serve as a conventional
    document Q&A engine and answer the journalist’s questions based on the relevant
    context of the research paper. The journalist bot then follows up with additional
    questions for further clarification. Through this iterative Q&A process, the key
    contributions, methodology, and findings of the research paper could be automatically
    extracted.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5bb2d4d17a40f755bd0509a680ddc114.png)'
  prefs: []
  type: TYPE_IMG
- en: An illustration of the workflow of the dual-chatbot system. (Image by author)
  prefs: []
  type: TYPE_NORMAL
- en: 'This dual-chatbot system described above introduces a shift from the traditional
    user-chatbot interaction: instead of users thinking about the right questions
    to ask the LLM model, the introduced “journalist” bot will automatically come
    up with suitable questions on the user’s behalf. This approach could bypass the
    need for users to craft appropriate prompts, thus significantly reducing the users’
    cognitive load. This is especially useful when delving into unfamiliar research
    fields. Overall, the dual-chatbot system may constitute a more user-friendly,
    efficient, and engaging method for distilling complex scientific research papers.'
  prefs: []
  type: TYPE_NORMAL
- en: Next up, let’s move to Sprint planning and define several user stories we would
    like to address in this project.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Sprint Planning: what we want to build'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the concept in place, it’s time to plan our current Sprint. In line with
    the common practice of Agile development, our Sprint planning will evolve around
    user stories.
  prefs: []
  type: TYPE_NORMAL
- en: In Agile development, **a user story** is a concise, informal, and simple description
    of a feature or functionality from an end-user perspective. It is a common practice
    used in Agile development to define and communicate requirements in a way that
    is understandable and actionable for the development team.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '🎯 **User story 1: document embedding**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “As a user, I want to input research papers in PDF format into the system, and
    I want the system to convert my input paper into a **machine-readable format**
    so that the dual-chatbot system can understand and analyze it efficiently.” (Generated
    by GPT-4)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This user story focuses on data ingestion. Essentially, we need to build a data-processing
    pipeline that includes document loading, splitting, embedding creation, and embedding
    storage.
  prefs: []
  type: TYPE_NORMAL
- en: Here, “embeddings” refer to the numerical representations of the text data.
    By creating a numerical representation of each part of a research paper, the author
    bot can better understand the semantic meaning of the research paper and be able
    to accurately answer the journalist bot’s questions.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we need to have a database to store the computed embeddings of
    the research paper. This database needs to be readily accessible by the author
    bot to facilitate fast and accurate answer generation.
  prefs: []
  type: TYPE_NORMAL
- en: In section 3, we will address this user story by leveraging the **OpenAI Embeddings
    API** along with the meta’s **FAISS vector store**.
  prefs: []
  type: TYPE_NORMAL
- en: '🎯 **User story 2: dual-chatbot**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “As a user, I want to observe an autonomous conversation between two chatbots
    — one playing the role of a ‘journalist’ asking questions and the other playing
    the role of an ‘author’ answering them, derived from the contents of the research
    paper. This will help me understand the paper’s key points without needing to
    read it in its entirety or craft my own questions.” (Generated by GPT-4)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This user story represents the cornerstone of our project: the development
    of the dual-chatbot system. As discussed in the “Concept” section, we need to
    construct two types of chatbot classes: one that is able to develop a series of
    questions to query the details of the paper (i.e., the journalist bot), and another
    that can leverage document embeddings to generate comprehensive answers to these
    questions (i.e., the author bot).'
  prefs: []
  type: TYPE_NORMAL
- en: In section 4, we will focus on addressing this user story by using the **LangChain**
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: '🎯 **User story 3: chat environment**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “As a user, I want an intuitive chat interface where I can watch the chatbots’
    conversation unfold in real-time.” (Generated by GPT-4)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The goal of this user story is to build a chat environment where users can view
    the generated dialogue between the journalist and author bots. In the spirit of
    MVP (minimum viable product), we will use simple **Jupyter widgets** to demonstrate
    the chat environment in section 5.1.
  prefs: []
  type: TYPE_NORMAL
- en: '🎯 **User story 4: PDF highlighting**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “As a user, I want to have the corresponding parts in the original research
    paper highlighted based on the chatbot’s discussion. This will help me to quickly
    locate the sources of the information discussed during the conversation.” (Generated
    by GPT-4)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This user story focuses on providing the users with the traceability of the
    Q&A. For every answer generated by the author bot, it is natural for users to
    understand precisely where the discussed information is originating from in the
    research paper. Not only does this feature enhances the transparency of our dual-chatbot
    system, but it also allows for a more interactive and engaging user experience.
  prefs: []
  type: TYPE_NORMAL
- en: In section 5.2, we will leverage LangChain’s **conversational retrieval chain**
    to return the sources the author bot used to generate the answers and the **PyMuPDF**
    library to highlight the corresponding texts in the original PDF.
  prefs: []
  type: TYPE_NORMAL
- en: '🎯 **User story 5: user input**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “As a user, I want to be able to intervene and ask my own questions in the midst
    of the chatbot’s conversation, this way I can direct the conversation and extract
    the information I need from the paper.” (Generated by GPT-4)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This user story focuses on the need for user participation. While our target
    dual-chatbot system is designed to be autonomous, we also need to provide the
    option for users to ask their own questions. This feature ensures that the conversation
    does not just go in a direction set by the bots, but it can be guided by the user’s
    own curiosity and interests. Also, it is very likely that users may get inspired
    by watching the first rounds of conversation, and would like to ask follow-up
    questions or dig deeper into certain aspects that are of particular interest to
    them. All these underline the importance of user intervention.
  prefs: []
  type: TYPE_NORMAL
- en: In section 5.3, we will address this user story by upgrading our user interface
    in Jupyter Notebook.
  prefs: []
  type: TYPE_NORMAL
- en: '🎯 **User story 6: download scripts**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “As a user, I want to be able to download a transcript of the chatbot conversation.
    This will allow me to review the key points offline or share the information with
    my colleagues.” (Generated by GPT-4)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This user story focuses on the accessibility and shareability of the generated
    content. Although users can view the conversation in a dedicated chat environment,
    it is beneficial to provide users with a record of the discussion that they can
    review later and share with others.
  prefs: []
  type: TYPE_NORMAL
- en: In section 5.4, we will use the **PDFDocument** libraryto convert the generated
    script into a PDF file for users to download.
  prefs: []
  type: TYPE_NORMAL
- en: So much for the planning, time to get to work!
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1aa4c455b93f11b7eb1154eaf4fd48c5.png)'
  prefs: []
  type: TYPE_IMG
- en: Our planned user stories. (Image by author)
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Feature 1: Document Embedding Engine'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s implement the first feature of our paper digesting app: the document
    embedding engine. Here, we will build a data-processing class with the functionality
    of document loading, splitting, embedding creation, and storage. This addresses
    our first user story:'
  prefs: []
  type: TYPE_NORMAL
- en: “As a user, I want to input research papers in PDF format into the system, and
    I want the system to convert my input paper into a **machine-readable format**
    so that the dual-chatbot system can understand and analyze it efficiently.” (Generated
    by GPT-4)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We start by creating a `embedding_engine.py` file and import necessary libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We then instantiate an embedding model by using OpenAI embeddings API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define the function for loading and processing PDF files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have used `PyMuPDFLoader` to load the PDF file, which, under the hood,
    leverages the PyMuPDF library to parse the PDF file. The returned `documents`
    variable is a list of LangChain `Document()` objects. Each `Document()` object
    corresponds to one page of the original PDF, with the page content stored in the
    `page_content` key and associated metadata (e.g., page number, etc.) stored in
    the `metadata` key.
  prefs: []
  type: TYPE_NORMAL
- en: After parsing the loaded PDF, we used `RecursiveCharacterTextSplitter` from
    LangChain to split the original PDF into multiple smaller chunks. Since the author
    bot will later use relevant texts from the PDF to answer questions, creating small
    chunks of text can not only help the author bot to focus on specific details to
    answer the question, but also ensure that the context provided to the author bot
    will not exceed the token limit of the employed LLM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we set up the vector store to manage the text embedding vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used Facebook AI Similarity Search (FAISS) library to serve as our
    vector store, which takes the loaded PDF and the embedding engine as the inputs
    to its constructor. The created `self.vectorstore` holds the embedding vectors
    of individual PDF chunks we created earlier. At query time, it will invoke the
    embedding engine to embed the question and then retrieve the embedding vectors
    that are ‘most similar’ to the embedded query. The texts that correspond to the
    most similar embedding vectors will be fed to the author bot as the context to
    assist its answer generation. This process is known as **vector search** and forms
    the backbone for document Q&A.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we create a helper function to generate a short summary of the paper.
    This will be useful later for setting the stage for the journalist bot.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: we resort to LLMs to create the summary. Technically speaking, we can achieve
    that goal by using LangChain’s `load_summarize_chain`, which takes the LLM model
    and the summarization method as inputs.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of the summarization method, here, we have used the **stuff** method,
    which simply “stuff” all the documents into a single context and prompts the LLM
    to generate the summary. For other more advanced methods, please refer to the
    [official page](https://python.langchain.com/docs/use_cases/summarization) of
    LangChain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Great! Now that we have developed the `Embedder` class to handle the document
    loading, splitting, as well as embedding creation and storage, we can move on
    to the core of our app: the dual-chatbot system.'
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Feature 2: Dual-Chatbot System'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we address our second user story:'
  prefs: []
  type: TYPE_NORMAL
- en: “As a user, I want to observe an autonomous conversation between two chatbots
    — one playing the role of a ‘journalist’ asking questions and the other playing
    the role of an ‘author’ answering them, derived from the contents of the research
    paper. This will help me understand the paper’s key points without needing to
    read it in its entirety or craft my own questions.” (Generated by GPT-4)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We will start by creating an abstract base class for defining the common behaviors
    of the chatbots. Afterward, we will develop the individual journalist bot and
    the author bot that inherit from the chatbot base class. We put all the class
    definitions in `chatbot.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1 Abstract chatbot class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since our journalist bot and the author bot share a lot of similarities (as
    they are all role-playing bots), it is a good practice to encapsulate the definition
    of their shared behaviors within an abstract base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We defined three common methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`instruct`: this method is used to set up the chatbot and attach memory to
    it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`step`: this method is used to feed input to the chatbot and receive the bot’s
    response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`specify_system_message`: this method is used to give the chatbot specific
    instructions regarding how it should behave during the conversation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the chatbot template in place, we are ready to create two specific chatbot
    roles, i.e., the journalist bot and the author bot.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2 Journalist chatbot class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The journalist bot’s role is to interview the author bot and extract key insights
    from a research paper. With that in mind, let’s fill the template methods with
    concrete code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor method, besides specifying a backbone LLM, another important
    component for the journalist bot is the memory object. Memory tracks the conversation
    history and serves as the key to helping the journalist bot avoid repetitive or
    irrelevant questions and generate meaningful follow-up questions. Technically,
    we achieved that by using the `ConversationBufferMemory` provided by LangChain,
    which simply prepends the last few inputs/outputs to the current input of the
    chatbot.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set up the journalist chatbot by creating a`ConversationChain`, with
    the previously defined backbone LLM, the memory object, as well as the prompt
    for the chatbot. Note that we have also specified `topic` (the paper topic) and
    `abstract` (the paper summary), which will be used later to provide the context
    of the paper to the journalist bot.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In LangChain, the prompt generation and ingestion for instructing the chatbot
    are handled via different prompt templates. For our current application, the most
    critical piece is setting the `SystemMessagePromptTemplate`, as it allows us to
    give a *high-level purpose* to the journalist bot and also define its desired
    behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: The followings are the details of the instruction. Note that the instruction/prompt
    is generated and optimized by using ChatGPT (GPT-4). This is beneficial as in
    the current case, the LLM-generated prompts tend to consider more nuances than
    the human-crafted ones. Additionally, generating high-level instructions with
    LLM represents a more scalable solution for adapting the systems to other scenarios
    beyond “journalist-author” interactions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we provided the journalist bot with the paper’s research domain and abstract
    to serve as the base for initial questions. This mirrors the real-world scenario
    where a journalist initially only knows a little about the paper and needs to
    ask questions to gather more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need a `step` method to interact with the journalist bot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the input prompt will be the author bot’s answer to the journalist
    bot’s previous question. If the conversation has not started yet, the input prompt
    will simply be “Start the conversation”, to prompt the journalist bot to start
    the interview.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it for the journalist bot. Let’s now turn to the author bot.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3 Author bot class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The author bot’s role is to answer questions raised by the journalist bot based
    on the research paper. Here is the constructor method for the author bot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two things changed here: first of all, unlike the journalist bot,
    the author bot should be able to access the full paper. Therefore, the vector
    store we created earlier needs to be provided to the constructor. Also, note that
    we are not using the memory object (e.g., `ConversationBufferMemory`) to track
    chat history anymore. Instead, we will simply use a list to store the history
    and later pass it explicitly to the author bot. Each element of the list will
    be a tuple of (query, answer). Both ways of maintaining conversation history are
    supported in LangChain.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set up the conversation chain for the author bot.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the author bot needs to answer questions by first retrieving relevant
    context, we adopted a `ConversationalRetrievalChain`. To quote from the official
    document of LangChain:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ConversationalRetrievalChain** first combines the chat history (either explicitly
    passed in or retrieved from the provided memory) and the query into a standalone
    question, then looks up relevant documents from the retriever, and finally passes
    those documents and the query to a question answering chain to return a response.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Therefore, in addition to the backbone LLM, we also need to supply the chain
    with a vector store. Note that here we specified the number of returned relevant
    documents (PDF chunks) via `search_kwargs`. In general, selecting the right number
    is not a trivial task and deserves careful consideration of balancing accuracy,
    relevance, comprehensiveness, and computational resources. Lastly, we set `return_source_documents`
    to True, which is important for ensuring transparency and traceability in the
    Q&A process.
  prefs: []
  type: TYPE_NORMAL
- en: 'To interact with the author bot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As discussed previously, we explicitly supplied the chat history (a list of
    previous query-answer tuples) to the conversation chain. As a result, we also
    need to manually append the newly obtained query-answer tuple to the chat history.
    For the response, we get not only the answer but also the source documents (PDF
    chunks) used by the author bot to generate the answer, which will be used later
    to highlight the corresponding texts in PDF.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we inform the role of the author bot and specify detailed instructions.
    Same as the journalist bot, the instruction/prompt for the author bot is also
    generated and optimized by using ChatGPT (GPT-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: That’s it for constructing the author bot.
  prefs: []
  type: TYPE_NORMAL
- en: '4.4 Quick test: the interview'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Time to take two bots for a ride!
  prefs: []
  type: TYPE_NORMAL
- en: To see if the developed journalist and author bot can engage in meaningful conversation
    toward the goal of digesting the paper, we pick one sample scientific research
    paper and run the test.
  prefs: []
  type: TYPE_NORMAL
- en: As I was working on physics-informed machine learning recently, here, I picked
    an arXiv paper named “[**Improved Training of Physics-Informed Neural Networks
    with Model Ensembles**](https://arxiv.org/abs/2204.05108)**”** (CC BY 4.0 license)for
    the test.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The generated conversation script is shown below. Note that to save space,
    some of the author bot’s answers are not shown in full:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a6e2d39406c7e6052ecb73d4b7f171fe.png)'
  prefs: []
  type: TYPE_IMG
- en: The interview between the developed journalist bot and the author bot. (Image
    by author)
  prefs: []
  type: TYPE_NORMAL
- en: Since the author bot only passively answers questions (i.e., a conventional
    Q&A agent), we focus our attention on the behavior of the journalist bot to assess
    if it can properly steer the interview. Here we can see that the journalist bot
    started with a general question about the paper (the motivation), then adapted
    its questions to dig deeper into the methodology of the proposed strategy. Overall,
    the behavior of the developed journalist bot aligns with our expectations and
    it is capable of conducting the interview toward distilling the key points from
    the given paper. Not bad😃
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Feature 3: User Interaction'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we wrap our previous experiment into a proper user interface.
    Toward that end, we will address three user stories to incrementally build the
    desired features.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1 Creating the chat environment (in Jupyter Notebook)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start with the 3rd user story:'
  prefs: []
  type: TYPE_NORMAL
- en: “As a user, I want an intuitive chat interface where I can watch the chatbots’
    conversation unfold in real-time.” (Generated by GPT-4)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To keep things simple, we opt for Jupyter widgets as they allow quickly building
    a chat environment entirely in Jupyter Notebook.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we set up the layout of displaying conversation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We created a button (`bot_ask`) such that when the user clicks it, a callback
    function `bot_ask_clicked` will be invoked and one round of conversation between
    the journalist and author bot will be generated. Afterward, we used the HTML widgets
    to display the conversation as HTML content in the notebook.
  prefs: []
  type: TYPE_NORMAL
- en: The callback function `bot_ask_clicked` is defined below. Besides showing the
    journalist bot’s question and the author bot’s answer, we also indicated the location
    (i.e., page number) of the relevant source texts. This is possible because the
    `step()` method of the author bot also returns the `source` variable, which is
    a list of LangChain `Document` object that contains the page content and its associated
    metadata.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Putting everything together, we have the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c229c6cb979f88ccfa584285bad8c376.png)'
  prefs: []
  type: TYPE_IMG
- en: Chat interface. (Image by author)
  prefs: []
  type: TYPE_NORMAL
- en: 5.2 Implementing PDF highlighting functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our current UI, we only indicated on which pages the author bot looked for
    the answers to the journalist bot’s question. Ideally, the user would expect the
    relevant texts to be highlighted in the original PDF to allow quick reference.
    This is the motivation for the 4th user story:'
  prefs: []
  type: TYPE_NORMAL
- en: “As a user, I want to have the corresponding parts in the original research
    paper highlighted based on the chatbot’s discussion. This will help me to quickly
    locate the sources of the information discussed during the conversation.” (Generated
    by GPT-4)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To achieve this goal, we employed the PyMuPDF library to search for relevant
    texts and perform text highlighting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the code above, the `phrases` is a list of strings, where each string represents
    one of the source texts used by the author bot to generate the answers. To highlight
    the texts, the code first loops over each page of the PDF and find if the `phrase`is
    contained on that page. Once the phrase is found, it will be highlighted in the
    original PDF.
  prefs: []
  type: TYPE_NORMAL
- en: 'To integrate this highlighting functionality into our previously developed
    chat UI, we first need to update the callback function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the appearance of our UI stays the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e8b533bd5592b34a12daba5bd0529daa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'under the hood, we would have a new PDF file, with relevant texts (on pages
    1 and 10) properly highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/99ac9965f679532207a325f2837beb8c.png)'
  prefs: []
  type: TYPE_IMG
- en: 5.3 Allowing user input for questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Up till now, all the conversations between the two bots are autonomous. Ideally,
    users should also be able to ask their own questions if they see fit. This is
    exactly what we want to address for the 5th user story:'
  prefs: []
  type: TYPE_NORMAL
- en: “As a user, I want to be able to intervene and ask my own questions in the midst
    of the chatbot’s conversation, this way I can direct the conversation and extract
    the information I need from the paper.” (Generated by GPT-4)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To achieve that goal, we can add another button such that the user can decide
    if a new round of exchange should be initiated by the journalist bot or the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The above callback function is essentially the same as the callback function
    for defining journalist-author interaction. The only difference is that the “question”
    will be directly input by the user. Also, to make the interview logic consistent,
    we appended the user question to the journalist bot’s memory, as if the user-supplied
    question was raised by the journalist bot.
  prefs: []
  type: TYPE_NORMAL
- en: 'We updated the main UI logic accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is what we got, where users can input their own questions and get
    answered by the author bot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/37cd0f3b65a6b848749b8cd02a2b9a99.png)'
  prefs: []
  type: TYPE_IMG
- en: Besides letting the journalist bot ask questions, users also have the opportunity
    to ask their own questions. (Image by author)
  prefs: []
  type: TYPE_NORMAL
- en: 5.4 Allowing downloading the generated script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far so good! As the last feature to implement, we want to be able to save
    the conversation history to our disk for later reference. This is the goal of
    the 6th user story:'
  prefs: []
  type: TYPE_NORMAL
- en: “As a user, I want to be able to download a transcript of the chatbot conversation.
    This will allow me to review the key points offline or share the information with
    my colleagues.” (Generated by GPT-4)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Toward that end, we added another button for downloading the script and attach
    a callback function to the button. In this callback, we used PDFDocument to convert
    the conversation script into a PDF file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We updated the main UI logic accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have a download button appearing in the UI. When the user clicks it,
    a paper summary PDF file will be automatically generated and downloaded to the
    local folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/fd7da4e202f776400d99d8d260d01c21.png)'
  prefs: []
  type: TYPE_IMG
- en: Users now have the option to download the script of the generated conversation.
    (Image by author)
  prefs: []
  type: TYPE_NORMAL
- en: '6\. Sprint Review: show the demo!'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s time to put up a demo to showcase our hard work 💪
  prefs: []
  type: TYPE_NORMAL
- en: 'In this demo, we showed the full functionality of our developed dual-chatbot
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: The two bots can autonomously engage in an interview with the goal of digesting
    the main points from the paper.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user can jump into the conversation as well and ask interested questions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relevant texts for the generated answers are automatically highlighted in the
    original PDF.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The conversation history can be downloaded to the local folder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have successfully addressed all the user stories, good work 🎉 Now Sprint
    review is over, time for some retrospectives.
  prefs: []
  type: TYPE_NORMAL
- en: 7\. Sprint Retrospective
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this project, we focused on solving the problem of efficiently digesting
    complex research papers. Toward that end, we developed a dual-chatbot system where
    one bot plays the “journalist” while the other bot plays the “author”, and two
    bots are engaged in an interview. In doing so, the journalist bot can act on behalf
    of the user and query the key points of the paper. This is beneficial as it eliminates
    the need for users to devise their own questions — an activity that can be challenging
    and time-consuming, particularly when dealing with unfamiliar subjects.
  prefs: []
  type: TYPE_NORMAL
- en: The success of the devised dual-chatbot approach relies critically on the journalist
    bot’s ability to steer the interview and generate insightful and relevant questions.
    In the current implementation, we used GPT-3.5-Turbo as the backbone LLM. To further
    enhance the user experience, it may be necessary to employ GPT-4 to boost the
    journalist bot’s reasoning capability.
  prefs: []
  type: TYPE_NORMAL
- en: What’s also important is that the journalist bot needs to be capable of interpreting
    and understanding the technical terms and concepts used in the broader research
    field to which the paper belongs. Besides using advanced LLM, fine-tuning the
    existing LLM on research papers of the target domain could be a promising strategy
    to pursue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking ahead, there are several possibilities to extend our current project:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Better UI design.** For simplicity, we have used Jupyter Notebook to showcase
    the main idea of the dual-chatbot system. We could certainly use more sophisticated
    libraries (e.g., Streamlit) to build a more user-friendly, engaging UI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multimodal capability.** For example, text-to-speech (TTS) techniques can
    be used to create audio over the generated script. This could be beneficial to
    users as they can keep consuming the content during a commute, exercising, or
    other activities where reading isn’t convenient.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Accessing external databases.** It would be great if the dual-chatbot system
    could have access to larger external repositories of research papers, such that
    the author bot could offer comparison analysis with respect to the latest developments
    in the fields of interest, thereby synthesizing insights across multiple papers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generating literature review.** Since the generated interview scripts can
    serve as condensed yet richer (than paper abstracts) versions of the full papers,
    we could first accumulate the scripts for a variety of papers in a specific research
    field, and then request a separate LLM to generate comprehensive reviews of that
    field, based on analyzing the accumulated interview scripts. This feature would
    be especially valuable for researchers when they are initiating a new research
    project or a literature review paper.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What a fruitful Sprint we had! If you find my content useful, you could buy
    me a coffee [here](https://www.buymeacoffee.com/Shuaiguo09f) 🤗 Thank you very
    much for your support! As always, you can find the companion notebook with full
    code [here](https://github.com/ShuaiGuo16/research_paper_digesting_with_dual_chatbot)
    💻 Looking forward to sharing with you more exciting LLM projects. Stay tuned!
  prefs: []
  type: TYPE_NORMAL
