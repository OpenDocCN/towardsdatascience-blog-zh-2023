- en: Demystifying Rotation Matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/demystifying-rotation-matrix-6c8885c691d6](https://towardsdatascience.com/demystifying-rotation-matrix-6c8885c691d6)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How to rotate a vector in R²
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@smertatli?source=post_page-----6c8885c691d6--------------------------------)[![Mert
    Atli](../Images/2ce3ad8e4e3533aa889e1972ca52b02b.png)](https://medium.com/@smertatli?source=post_page-----6c8885c691d6--------------------------------)[](https://towardsdatascience.com/?source=post_page-----6c8885c691d6--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----6c8885c691d6--------------------------------)
    [Mert Atli](https://medium.com/@smertatli?source=post_page-----6c8885c691d6--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----6c8885c691d6--------------------------------)
    ·6 min read·Nov 1, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: A rotation matrix is like a magical tool in the world of linear algebra, designed
    to spin vectors around in space with precision and ease. Imagine you have a vector,
    a little arrow pointing somewhere in space, and you want to turn it around a certain
    point, like spinning a key around a keyring. That’s exactly what a rotation matrix
    helps you do.
  prefs: []
  type: TYPE_NORMAL
- en: To see how the rotation matrix emerges, lets start with a vector in R² and try
    to rotate it along horizontal axis.
  prefs: []
  type: TYPE_NORMAL
- en: Rotating a vector in R²
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The figure below shows a vector **v** in R² that makes the angle **a** with
    horizontal axis. Let’s say that we want to rotate it ‘b degrees’ counter-clock
    wise along the horizontal axis, which is denoted by **v’**.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/19c48b2f1c07578044de81caa85bd4ae.png)'
  prefs: []
  type: TYPE_IMG
- en: From v to v’ via rotation
  prefs: []
  type: TYPE_NORMAL
- en: '**As we can see, the rotation just changes the direction of v and keeps the
    length(a.k.a ‘magnitude’) same.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In R², we can represent the vector v as the ordered tuple (m, n) with first
    element in horizontal axis, and the second element in the vertical axis. From
    trigonometry, we know that the coordinates of **v**=(m, n) can be represented
    as (||v||.cos(a), ||v||.sin(a)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/28f3ee9f4f9a7a86b827fa0ff627cc0d.png)'
  prefs: []
  type: TYPE_IMG
- en: The coordinates of a vector given its length and the angle
  prefs: []
  type: TYPE_NORMAL
- en: 'So similarly, v’ can be represented as (||v||.cos(a+b), ||v||.sin(a+b)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9ce5c072cf2a52f94f4a0da00f08c5ff.png)'
  prefs: []
  type: TYPE_IMG
- en: The coordinates of v and v’
  prefs: []
  type: TYPE_NORMAL
- en: 'So our problem is to find a mapping from v to v’. **Any vector can be transformed
    to another vector through matrix multiplication, especially when it comes to rotations.**
    If you have a vector **v** and you want to transform it to another vector **v′**
    through rotation, then there exists a rotation matrix **A** that can accomplish
    this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e1bbb11c00d146cbb93b4877df9d54d2.png)'
  prefs: []
  type: TYPE_IMG
- en: Matrix A as a map from v to v’
  prefs: []
  type: TYPE_NORMAL
- en: 'From the equation above, it seems to be a good idea to represent **v** and
    **v’** as vectors to do some calculations with them. The vector representation
    of v is as follows (the first element is horizontal and the second element is
    vertical axis):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2e5581ee04f45a5efb0e3b8926287a59.png)'
  prefs: []
  type: TYPE_IMG
- en: vector representation of v
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the vector representation of v’ is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/93d82a6d8177e217990725dad81d943c.png)'
  prefs: []
  type: TYPE_IMG
- en: vector representation of v’
  prefs: []
  type: TYPE_NORMAL
- en: 'So we have v and v’ as vectors. We don’t know the elements of the rotation
    matrix A yet, so lets denote them by variables x, y, z, and t:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/86aa8a3d3629258c93e1a2f3a2ed9655.png)'
  prefs: []
  type: TYPE_IMG
- en: From v to v’ via rotation matrix
  prefs: []
  type: TYPE_NORMAL
- en: 'By doing matrix vector multiplication on the left hand side and then by equating
    it to the expressions on the right hand side, we can easily get the values of
    x, y, z, and t:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ca61ed4f1a708bb35056334948cfebf7.png)'
  prefs: []
  type: TYPE_IMG
- en: Finding values of variables x, y, z, and t
  prefs: []
  type: TYPE_NORMAL
- en: 'So this gives us a rotation matrix as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/445efe6130336c8d2ab2f6d1e0c04f9d.png)'
  prefs: []
  type: TYPE_IMG
- en: Rotation matrix
  prefs: []
  type: TYPE_NORMAL
- en: This is the rotation matrix that we need to rotate any vector v **b degrees
    counter-clock wise along the horizontal axis**. Looks cryptical? Let’s explore
    it further.
  prefs: []
  type: TYPE_NORMAL
- en: Properties of Rotation Matrix in R²
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s explore some special cases to justify the rotation matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 0-degree rotation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A 0-degree rotation means that the object or vector is not rotated at all; it
    stays in its original position and orientation. In terms of transformation matrices,
    a 0-degree rotation can be represented by the identity matrix. This result makes
    sense because a 0-degree rotation should not change the vector’s position or orientation.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f9db3cc389bc724df7956deffa984d91.png)'
  prefs: []
  type: TYPE_IMG
- en: Rotation matrix with 0 degree
  prefs: []
  type: TYPE_NORMAL
- en: 180-degree rotation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A 180-degree rotation means that the object or vector is rotated half a circle
    from its original position. For a 2D vector, this rotation will flip the vector
    to the opposite quadrant, changing both its x and y components to their negatives.
    **This result makes sense because a 180-degree rotation should flip the vector
    to the opposite direction.** For instance, if you have a vector pointing straight
    up, a 180-degree rotation would flip it to point straight down.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/68d4ac9a2fefdaa9599b9deadb2ab8dc.png)'
  prefs: []
  type: TYPE_IMG
- en: First *β* degree, then -*β* degree rotation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a vector undergoes a rotation by an angle ***β*** and then undergoes another
    rotation by an angle **-*β***, the two rotations effectively cancel each other
    out, resulting in the vector returning to its original position and orientation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since there will be two matrix multiplication, one for **β** and the other
    for **-β** degree rotation, it is equivalent to multiply v by a matrix **A’**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/67b3d060b04359ff3c932b5d4ffd69fd.png)'
  prefs: []
  type: TYPE_IMG
- en: When we calculate the **A’**, we end up with an identity matrix! So **A’ ⋅ v**
    is equal to **v** itself! The key for the calculations below is that **cosine
    is an even function and sine is an odd function**. So **cos(-b) = cos(b)**, and
    **sin(-b) = -sin(b):**
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/761d0d46694d5b43a6375fe140118974.png)'
  prefs: []
  type: TYPE_IMG
- en: Rotate b, then rotate -b degree
  prefs: []
  type: TYPE_NORMAL
- en: What about R³ ?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The general concept of rotation using matrices can indeed be extended from 2D
    to 3D and even beyond, to higher-dimensional spaces.
  prefs: []
  type: TYPE_NORMAL
- en: In 2D, a rotation matrix can be used to rotate a vector around the origin. The
    rotation matrix depends on the angle of rotation, and it transforms the original
    vector to a new position while preserving its length.
  prefs: []
  type: TYPE_NORMAL
- en: '**When we move to 3D, the idea is similar, but we have to consider rotations
    around different axes.** In 3D space, you can rotate a vector around the x-axis,
    y-axis, or z-axis. For each type of rotation, there is a corresponding rotation
    matrix. Just like in 2D, the length of the vector is preserved during the rotation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simplified breakdown:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rotation around the x-axis: The y and z components of the vector change, but
    the x component stays the same.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rotation around the y-axis: The x and z components of the vector change, but
    the y component stays the same.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rotation around the z-axis: The x and y components of the vector change, but
    the z component stays the same.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The rotation matrices for 3D rotations take into account the angle of rotation
    and the axis of rotation.** When you multiply a vector by one of these rotation
    matrices, you get a new vector that has been rotated around the specified axis
    by the specified angle.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The same logic applies: if you rotate a vector and then rotate it back by the
    same angle in the opposite direction (using the inverse rotation), you end up
    back at the original vector.'
  prefs: []
  type: TYPE_NORMAL
- en: This idea can be extended to higher dimensions as well, though visualizing rotations
    becomes more complex as you move beyond 3D. In any dimension, the concept of using
    matrices to perform rotations and the properties of these rotations (such as preserving
    the length of the vector) remain consistent.
  prefs: []
  type: TYPE_NORMAL
- en: '*Unless otherwise noted, all images are by the author.*'
  prefs: []
  type: TYPE_NORMAL
