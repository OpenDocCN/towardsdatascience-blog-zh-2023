- en: Effectively Use %timeit, %lprun, and %mprun to Write Efficient Python Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/effectively-use-timeit-lprun-and-mprun-to-write-efficient-python-code-f06fb8457049](https://towardsdatascience.com/effectively-use-timeit-lprun-and-mprun-to-write-efficient-python-code-f06fb8457049)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A hands-on guide on how to use magic commands to test the most efficient python
    code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://suemnjeri.medium.com/?source=post_page-----f06fb8457049--------------------------------)[![Susan
    Maina](../Images/a3ac5f206f175c711a9e7779283fc18d.png)](https://suemnjeri.medium.com/?source=post_page-----f06fb8457049--------------------------------)[](https://towardsdatascience.com/?source=post_page-----f06fb8457049--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----f06fb8457049--------------------------------)
    [Susan Maina](https://suemnjeri.medium.com/?source=post_page-----f06fb8457049--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----f06fb8457049--------------------------------)
    ·11 min read·Mar 8, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3e9e1405f4a9150be078fd1dfff4beda.png)'
  prefs: []
  type: TYPE_IMG
- en: '[https://pixabay.com/images/id-534120/](https://pixabay.com/images/id-534120/)'
  prefs: []
  type: TYPE_NORMAL
- en: I recently did a coding interview where one of the passing considerations was
    how optimized the code was. Unfortunately, I failed the test not because the code
    did not work (which it did) or the logic was wrong (which it was not) but because
    my code was not optimized.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a data scientist, efficient code:'
  prefs: []
  type: TYPE_NORMAL
- en: Saves time when processing and analyzing large or complex data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promotes scalability, ensuring your datasets can handle larger datasets and
    complex models.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates reusable and modular code, which again saves time and reduces errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is easily maintained and updated because it’s simple and understandable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: is shareable with a broader audience because it can work on less powerful hardware.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Optimized code == efficient code***'
  prefs: []
  type: TYPE_NORMAL
- en: 'In python, efficient code is:'
  prefs: []
  type: TYPE_NORMAL
- en: Pythonic — It uses python’s [unique style and idioms](https://peps.python.org/pep-0020/)
    in the way it was intended by the founders and the community.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Readable —It’s easy to read and understand what the code does. For example,
    following [correct naming](https://realpython.com/python-pep8/#naming-conventions)
    conventions, being mindful of [white space](https://realpython.com/python-pep8/#whitespace-in-expressions-and-statements),
    and using fewer lines of code where possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fast — Should run in the least possible time, consuming minimum amounts of memory
    and resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Companies and employers prefer optimized code that can easily scale and allow
    new developers to get on board quickly.
  prefs: []
  type: TYPE_NORMAL
- en: In this article, we’ll cover four python [magic commands](https://ipython.readthedocs.io/en/stable/interactive/magics.html)
    that test how efficient our code is. We’ll also perform tasks using different
    code approaches and measure the most efficient method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Magic commands —** These are special python commands that start with `%`
    or `%%` and are supported in [Jupyter](https://jupyter.org/) notebooks and the
    [Ipython](https://ipython.org/) kernel. They provide a quick and powerful way
    to perform tasks such as timing code (discussed in this article), displaying visualizations,
    and navigating directories.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Line magics:* These have a single % and operate on one line of input.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Cell magics:* These have two %% and operate on multiple lines of code or a
    cell block.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note.** You may be familiar with the ‘!’ symbol, which is a short form of
    the magic command `%system`. This command executes shell commands directly in
    the notebook, such as installing packages using `!pip install package`.'
  prefs: []
  type: TYPE_NORMAL
- en: To display all built-in python [magic commands](https://ipython.org/ipython-doc/dev/interactive/magics.html),
    use `%lsmagic`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b905d20eb3d392ff23fbb03d3e5550cc.png)'
  prefs: []
  type: TYPE_IMG
- en: Displaying magic commands by author
  prefs: []
  type: TYPE_NORMAL
- en: To find out what a magic command does, use the code *%magic_command****?***
    to display its documentation in place.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f194600162cb91f792d1e1ab175c28e4.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot by author
  prefs: []
  type: TYPE_NORMAL
- en: 1\. %timeit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[This](https://ipython.readthedocs.io/en/stable/interactive/magics.html#magic-timeit)
    magic command measures the time it takes for a single line of code to execute.
    It runs the code several times and returns the average execution time.'
  prefs: []
  type: TYPE_NORMAL
- en: '***%timeit syntax*:** The command is followed by the code to test, all in one
    line.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Example output
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Output explained:'
  prefs: []
  type: TYPE_NORMAL
- en: '*32.4 ns =* The average execution time. Use the table below for time conversions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*1.17 ns =* The standard deviation of the measurements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/f803f9744a64bf15cb32db69b838ab3e.png)'
  prefs: []
  type: TYPE_IMG
- en: Units-of-time table by the author
  prefs: []
  type: TYPE_NORMAL
- en: '*7 runs =* The number of runs, or iterations, to repeat the process. We have
    different runs to account for variations in factors such as memory usage and CPU
    load, which may remain the same in one run but differ in others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*10,000,000 loops =* The number of times to execute the code per iteration.
    Therefore, the code runs a total of `runs*loops` times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of runs and loops are automatically determined based on the code
    complexity, but you can also pass them as arguments, as discussed below.
  prefs: []
  type: TYPE_NORMAL
- en: '***Task 1: Timing one line of code — compare [] vs list() for instantiating
    a list.***'
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating a list using literal symbols []*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Creating a list using list()*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Output explained:** Using the literal symbols takes 34.6 ns, less than half
    the time when using the function name (92.8 ns).'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, when instantiating a python list, tuple, or dictionary, it is more
    efficient to use their literal symbols than their function names.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The same can be said when creating a list of numbers using the range function.
    List unpacking using `*` is more efficient than using the `list()` name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Specifying runs and loops —** After the `%timeit` command, you can pass in
    as arguments your desired runs and loops using -r and -n respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 2\. %%timeit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This command is prefixed by **two** percentage signs. It measures the average
    time taken to execute a cell block that contains multiple code lines.
  prefs: []
  type: TYPE_NORMAL
- en: '***%%timeit Syntax:*** The command is written at the start of a cell block,
    immediately followed by the lines of code to be timed beneath it.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '***Task 2: Timing multiple lines of code (a cell block) — Compare a for-loop
    VS a list comprehension that squares all the numbers from 0 to 1000.***'
  prefs: []
  type: TYPE_NORMAL
- en: '[*For-loop*](https://builtin.com/software-engineering-perspectives/can-you-put-a-for-loop-in-an-if-statement)
    *—* Below, we use `%%timeit` and pass in our desired number of runs (5) and loops
    per run (1000).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The code takes 198 microseconds to execute.
  prefs: []
  type: TYPE_NORMAL
- en: '*List comprehension —* Here we use `%timeit` with one percentage sign because
    we’re measuring only one line of code.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The list comprehension code is faster at 173 microseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, whenever possible, and if it does not compromise readability, use
    a list comprehension over a for-loop.
  prefs: []
  type: TYPE_NORMAL
- en: '%lprun — Line profiling'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This command comes from the [line-profiler](https://pypi.org/project/line-profiler/)
    library, which outlines the time performance of a python function, program, or
    script.
  prefs: []
  type: TYPE_NORMAL
- en: It checks how long each line of code in the function takes and returns an output
    of the line-by-line analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '***%lprun syntax:*** the command is followed by -f which means that we are
    analyzing a function. You then pass in the function name, then the function call
    with its parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The line profiler is *not* built in python and needs to be installed the first
    time you use it in your system. You also need to load it into the ipython session
    every time you are running a new kernel.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The table returned is an analysis of each line in the function, with the following
    columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Line number:* the position of the line in the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hits:* Number of times the line was executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Time:* Total time taken by the line. The timer unit is specified at the top
    of the table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Per Hit:* The average time it took to execute a line (Time/Hits)*.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*% Time:* The percentage of time taken per line compared to other lines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line contents:* The actual source code of the line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Task 3: Timing a Function — compare a for-loop VS a built-in python function
    for removing duplicates from a list.***'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, both functions take in a list, remove duplicates, and return
    a list of unique items.
  prefs: []
  type: TYPE_NORMAL
- en: '*Using a for-loop*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/3d07e7951ae968678e3b76e394a6499e.png)'
  prefs: []
  type: TYPE_IMG
- en: The timer unit is in seconds (1e-07 s), which equals 0.1 microseconds as per
    the table below. The whole function ran for 14.6 microseconds, and the for-loop
    codes were run severally (many hits).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f803f9744a64bf15cb32db69b838ab3e.png)'
  prefs: []
  type: TYPE_IMG
- en: Units-of-time table by author
  prefs: []
  type: TYPE_NORMAL
- en: '*Using the* [*set()*](https://www.w3schools.com/python/python_sets.asp) *function*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/6bbc1c93d31854c0a62a2472c665e8cc.png)'
  prefs: []
  type: TYPE_IMG
- en: This function only had one code line, which was run once (1 hit). The whole
    function ran for 3.3 microseconds.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, whenever possible, utilize the built-in functions that perform
    the task you desire. This is because they are optimized for their operations.
    Here is a list of [built-in python functions](https://www.w3schools.com/python/python_ref_functions.asp)
    that you can leverage in your code.
  prefs: []
  type: TYPE_NORMAL
- en: '%mprun — Memory profiling'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This command comes from the [memory profiler](https://pypi.org/project/memory-profiler/)
    library, which outlines the memory usage of a function.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, where `%lprun` measures the time, `%mprun` measures the memory consumed
    and returns a line-by-line analysis of the memory resources.
  prefs: []
  type: TYPE_NORMAL
- en: However, with `%mprun`, the function needs to be saved in a separate python
    file. This file can be saved in your current working directory, which you then
    import into your session, and run the command on it. We’ll do all this soon.
  prefs: []
  type: TYPE_NORMAL
- en: Again, you need to install the memory profiler library into your system, then
    load it into the current kernel session.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '***%mprun syntax:*** the command is followed by -f, then the function name,
    and finally the function call.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The table returned contains the following information for every code line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Line #:* The line number being executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mem usage:* the memory used by the Python interpreter after executing this
    line of code, measured in bytes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Increment:* the difference in memory used from the previous line. Think of
    it as the impact of this line on memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Occurrences:* the number of instances of items of the same type created in
    this line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line Contents:* the source code on that line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Task 4: Timing a function in a Pandas DataFrame —* *What is the most efficient
    way to perform calculations on a Pandas column?***'
  prefs: []
  type: TYPE_NORMAL
- en: In our example below, we’ll work with a [Pandas](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html)
    Dataframe and perform some calculations on a column. I am using the Kaggle dataset
    ‘fuel consumption’ available [here](https://www.kaggle.com/datasets/ahmettyilmazz/fuel-consumption)
    under the [Open Database](http://opendatacommons.org/licenses/dbcl/1.0/) license.
  prefs: []
  type: TYPE_NORMAL
- en: First, import the Pandas library, then load the dataset into the current session.
    Be sure to [install](https://www.geeksforgeeks.org/how-to-fix-no-module-named-pandas/)
    the Pandas Library first if the code returns a *module not found* error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/38d25e102aece6cd129a36b0b9564afe.png)'
  prefs: []
  type: TYPE_IMG
- en: First 5 rows of the dataset by author
  prefs: []
  type: TYPE_NORMAL
- en: The function takes in a Pandas dataframe, multiplies a column’s values by a
    scalar, and returns a modified dataframe. We will test four functions to check
    the most memory-efficient approach.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that `%mprun` must access the function from a file. To save the functions
    in one file, run the cell block below where the top line is `%%file your_file.py.`
    This creates and writes (or overwrites) the contents into `your_file.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Next, load the memory profiler extension and import your functions from the
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Method 1: Using* [*apply with a lambda*](/lambda-functions-with-practical-examples-in-python-45934f3653a8)
    *function*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/9540666299ca986072ca75ebe5923969.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: The `apply` function line where the multiplication happens results in 45,000
    occurrences and a 1.6 MB memory increment.
  prefs: []
  type: TYPE_NORMAL
- en: '*Method 2: Using a list comprehension*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/ae35266cfac30230251c6a80d148feda.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Using a list comprehension halves the number of occurrences to around 22,500\.
    However, a similar memory increase of 1.7 MB is noted for the two lines.
  prefs: []
  type: TYPE_NORMAL
- en: '*Method 3: Direct multiplication.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/2a55ef79766f54349820e3d2e0169d1c.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the direct multiplication method results in only one occurrence of this
    item in memory and a very little memory increment of 0.4 MB.
  prefs: []
  type: TYPE_NORMAL
- en: '*Method 4: Using* [*NumPy*](/4-fundamental-numpy-properties-every-data-scientist-must-master-c906236eb44b)
    *by first calling* `*Series.values*` *to convert the column into a NumPy array.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/66a2fad939d620fe794bdebcb1745f9a.png)'
  prefs: []
  type: TYPE_IMG
- en: The fourth method involves first converting the column into a [NumPy](/4-fundamental-numpy-properties-every-data-scientist-must-master-c906236eb44b)
    array and then multiplying it by the scalar value. As in the previous method 3,
    there is only one occurrence of the item in memory and a similar memory increase
    of 0.4 MB.
  prefs: []
  type: TYPE_NORMAL
- en: '**Speed of direct multiplication VS NumPy multiplication.**'
  prefs: []
  type: TYPE_NORMAL
- en: Numpy calculation is faster, even though it consumes the same memory as the
    direct method. See the results of the two functions using `%lprun` which measures
    the time taken per line.
  prefs: []
  type: TYPE_NORMAL
- en: '*Direct multiplication — Slower*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/55850a0cbfb97582442c23846c3ad8d0.png)'
  prefs: []
  type: TYPE_IMG
- en: Direct multiplication by author
  prefs: []
  type: TYPE_NORMAL
- en: '*NumPy''s calculation — Faster*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/fb7a96c9e17f93f960a6a610acbaaa95.png)'
  prefs: []
  type: TYPE_IMG
- en: NumPy's multiplication by the author
  prefs: []
  type: TYPE_NORMAL
- en: The NumPy calculation (the column is first converted into a NumPy array using
    `Series.values`) is faster, taking only 137 ms compared to 1,150 ms for the direct
    multiplication. The percentage time is also much less at 9.7% compared to 45%
    with direct multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, numeric calculations in a dataframe are most efficient using
    NumPy, as it is optimized for element-wise operations.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this article, we discussed the importance of writing efficient and optimized
    code in python. We looked at different code examples and identified the most efficient
    coding approach.
  prefs: []
  type: TYPE_NORMAL
- en: We explored four magic commands; `%timeit`, `%%timeit`, `%lprun,` and `%mprun`.
    The first three test the time taken to execute code, while the last one measures
    the memory consumed. We also learned that line magics operate on one line of code
    and are prefixed by one %. On the other hand, cell magics are prefixed by two
    %% and they operate on multiple code lines directly beneath it.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you enjoyed the article. To receive more like these whenever I publish
    a new one, subscribe [here](https://suemnjeri.medium.com/subscribe/@suemnjeri).
    If you are not yet a medium member and would like to support me as a writer, follow
    [this link](https://medium.com/@suemnjeri/membership) to subscribe for $5 and
    I will earn a small commission. Thank you for reading!
  prefs: []
  type: TYPE_NORMAL
- en: '**References**'
  prefs: []
  type: TYPE_NORMAL
- en: '[MCoding’s 25 nooby python habits on YouTube](https://youtu.be/qUeud6DvOWI)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Finxter’s 29 top built-in python functions with examples.](https://blog.finxter.com/pythons-top-29-built-in-functions-with-examples/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 3\. [Magic Commands for Profiling in Jupyter Notebook](/magic-commands-for-profiling-in-jupyter-notebook-d2ef00e29a63)
  prefs: []
  type: TYPE_NORMAL
