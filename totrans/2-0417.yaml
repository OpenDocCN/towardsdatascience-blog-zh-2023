- en: Build a back-end with PostgreSQL, FastAPI, and Docker
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PostgreSQL、FastAPI 和 Docker 构建一个后端
- en: 原文：[https://towardsdatascience.com/build-a-back-end-with-postgresql-fastapi-and-docker-7ebfe59e4f06](https://towardsdatascience.com/build-a-back-end-with-postgresql-fastapi-and-docker-7ebfe59e4f06)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/build-a-back-end-with-postgresql-fastapi-and-docker-7ebfe59e4f06](https://towardsdatascience.com/build-a-back-end-with-postgresql-fastapi-and-docker-7ebfe59e4f06)
- en: A step-by-step guide to develop a map-based application (Part IV)
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发基于地图的应用程序的逐步指南（第四部分）
- en: '[](https://medium.com/@jacky.kaub?source=post_page-----7ebfe59e4f06--------------------------------)[![Jacky
    Kaub](../Images/e66c699ee5a9d5bbd58a1a72d688234a.png)](https://medium.com/@jacky.kaub?source=post_page-----7ebfe59e4f06--------------------------------)[](https://towardsdatascience.com/?source=post_page-----7ebfe59e4f06--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----7ebfe59e4f06--------------------------------)
    [Jacky Kaub](https://medium.com/@jacky.kaub?source=post_page-----7ebfe59e4f06--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@jacky.kaub?source=post_page-----7ebfe59e4f06--------------------------------)[![Jacky
    Kaub](../Images/e66c699ee5a9d5bbd58a1a72d688234a.png)](https://medium.com/@jacky.kaub?source=post_page-----7ebfe59e4f06--------------------------------)[](https://towardsdatascience.com/?source=post_page-----7ebfe59e4f06--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----7ebfe59e4f06--------------------------------)
    [Jacky Kaub](https://medium.com/@jacky.kaub?source=post_page-----7ebfe59e4f06--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----7ebfe59e4f06--------------------------------)
    ·28 min read·Mar 14, 2023
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·发表于 [Towards Data Science](https://towardsdatascience.com/?source=post_page-----7ebfe59e4f06--------------------------------)
    ·阅读时间 28 分钟·2023 年 3 月 14 日
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/0c94c9aabf27aae32cad325a9448c7da.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0c94c9aabf27aae32cad325a9448c7da.png)'
- en: Photo by [Caspar Camille Rubin](https://unsplash.com/@casparrubin?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图片来自 [Caspar Camille Rubin](https://unsplash.com/@casparrubin?utm_source=medium&utm_medium=referral)
    于 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: Maps are a powerful tool for visualizing and understanding geographic data but
    they need specific skills to be designed efficiently.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 地图是可视化和理解地理数据的强大工具，但需要特定的技能才能高效设计。
- en: In this step-by-step guide, we are going to take a deep dive into building a
    map-based application to show the customers prices of gas stations around them.
    We will cover the different key steps of a product, from original proof of concept
    (POC) to the minimum viable product (MVP)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个逐步指南中，我们将深入探讨如何构建一个基于地图的应用程序，以展示客户周围加油站的价格。我们将涵盖产品的不同关键步骤，从最初的概念验证（POC）到最小可行产品（MVP）。
- en: 'Articles in the series:'
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系列文章：
- en: '[Part I: The proof-of-concept — Build a minimalist demo](/a-step-by-step-guide-to-develop-a-map-based-application-part-i-757766b04f77)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[第一部分：概念验证——构建一个简约的演示](/a-step-by-step-guide-to-develop-a-map-based-application-part-i-757766b04f77)'
- en: '[Part II: How to use React to build web apps (Static Layout)](/a-step-by-step-guide-to-develop-a-map-based-application-part-ii-6d3fa7dbd8b9)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[第二部分：如何使用 React 构建网页应用（静态布局）](/a-step-by-step-guide-to-develop-a-map-based-application-part-ii-6d3fa7dbd8b9)'
- en: '[Part III: Add interactivity to your web apps with React](/a-step-by-step-guide-to-develop-a-map-based-application-part-iii-ad501c4aa35b)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[第三部分：使用 React 为你的网页应用添加互动性](/a-step-by-step-guide-to-develop-a-map-based-application-part-iii-ad501c4aa35b)'
- en: 'Part IV: Build a back-end with PostgreSQL, FastAPI, and Docker'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第四部分：使用 PostgreSQL、FastAPI 和 Docker 构建后端
- en: A bit of context around this article
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于这篇文章的一些背景信息
- en: In the previous articles in this series, we built the front end of the gas station
    finder using **React**, and we considered the back end as a “black box” that was
    only providing the relevant data.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在系列文章的前几部分，我们使用 **React** 构建了加油站查找器的前端，并将后端视为一个仅提供相关数据的“黑箱”。
- en: In this part, we are going to detail step by step how to build the back end
    using powerful tools such as **PostgreSQL** or **FastAPI**.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将详细介绍如何使用强大的工具，如 **PostgreSQL** 或 **FastAPI**，一步一步构建后端。
- en: You can find the full code of this project in my [Github page](https://github.com/jkaub/station-prices-app-full).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在我的 [Github 页面](https://github.com/jkaub/station-prices-app-full) 找到该项目的完整代码。
- en: Why do we need a clean back end?
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么我们需要一个干净的后端？
- en: 'In the first part of this series, we created some utility functions to obtain
    data on-the-fly from fuel stations directly from the public provider. While this
    was sufficient for our proof of concept, we now need a more robust system for
    several reasons:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本系列的第一部分中，我们创建了一些实用函数，以便从公共提供商直接获取燃料站的数据。虽然这对于我们的概念验证足够了，但由于多种原因，我们现在需要一个更强大的系统：
- en: 'Performances & Latency: Processing the data in real-time, including parsing
    the XML, formatting, and filtering, is computationally expensive and would be
    impractical for an application that expects frequent use.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能与延迟：实时处理数据，包括解析 XML、格式化和过滤，计算成本高，对于预期频繁使用的应用程序来说，可能不切实际。
- en: 'Reliability: To ensure that our application is not impacted by unexpected changes
    or downtime of third-party data sources. Relying solely on data from external
    portals would put our application at risk, as even a simple change to a field
    name by the provider could generate bugs and downtime on our side while we patch
    the change. By building our own database, we have greater control over the data,
    and we can perform necessary updates and maintenance without relying on external
    parties.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可靠性：确保我们的应用程序不会受到第三方数据源的意外更改或停机的影响。仅依赖外部门户的数据会使我们的应用程序面临风险，因为即使提供商简单地更改字段名称也可能导致我们这边的错误和停机，而我们需要修补这些变化。通过构建我们自己的数据库，我们可以对数据有更大的控制权，进行必要的更新和维护，而无需依赖外部方。
- en: 'Customization: With our own database, we can customize the data to meet our
    technical specs, add other external data sources, build custom views of the data
    for different use cases, etc…'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义：通过我们自己的数据库，我们可以定制数据以满足技术规格，添加其他外部数据源，为不同的用例构建自定义数据视图等……
- en: To address these requirements, we will build our own database and API that can
    handle data acquisition, processing, and delivery to the front end. This will
    involve running a PostgreSQL database with **Docker**, using P**ython** and s**qlalchemy**
    to interact with the database, and making geo-queries using the **PostGIS** extension.
    We will also explore how to build a simple API using **FastAPI** and **SQLmodel**.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足这些需求，我们将构建自己的数据库和 API，处理数据获取、处理和前端交付。这将包括使用 **Docker** 运行 PostgreSQL 数据库，使用
    **Python** 和 **sqlalchemy** 与数据库交互，并使用 **PostGIS** 扩展进行地理查询。我们还将探索如何使用 **FastAPI**
    和 **SQLmodel** 构建一个简单的 API。
- en: 'The chart below is a simple schema of the different components of the app:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下图是应用程序不同组件的简单示意图：
- en: '![](../Images/82f48ca69d17fa4fea7c496bd09b7ad1.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/82f48ca69d17fa4fea7c496bd09b7ad1.png)'
- en: A simple view of the different components of our app, Author Illustration
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序不同组件的简单视图，作者插图
- en: What this article covers
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本文涵盖的内容
- en: 'In this article, we focus on our internal database and the creation of the
    API. In particular, we will:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们专注于内部数据库和 API 的创建。具体来说，我们将：
- en: Run a PostgreSQL database using Docker
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 运行 PostgreSQL 数据库
- en: Use python and sqlalchemy to interact with the database
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 python 和 sqlalchemy 与数据库交互
- en: Make geo-queries with PostGIS extension
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PostGIS 扩展进行地理查询
- en: Build a simple API using FastAPI and SQLmodel
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 FastAPI 和 SQLmodel 构建一个简单的 API
- en: Containerizing our Project and running it with **docker-compose**
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **docker-compose** 容器化我们的项目并运行
- en: Create a local PostgreSQL instance with Docker
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 创建本地 PostgreSQL 实例
- en: Docker is an open-source containerization platform that allows you to run applications
    in a consistent and isolated environment. Setting up a PostgreSQL server with
    Docker has several advantages, including being able to install the application
    in a standardized way without risking conflicts with other configurations on your
    system.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 是一个开源容器化平台，允许你在一致且隔离的环境中运行应用程序。使用 Docker 设置 PostgreSQL 服务器有几个优点，包括能够以标准化的方式安装应用程序，而不必担心与系统上其他配置冲突。
- en: In our case, we will set up our Postgre server directly inside a container.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们将直接在容器内部设置 Postgre 服务器。
- en: I’ll assume here you already have Docker installed on your computer, as the
    installation method differs from system to system.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里假设你已经在计算机上安装了 Docker，因为安装方法因系统而异。
- en: Get the container image
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取容器镜像
- en: A docker image can be seen as the specification of everything that is needed
    to build a container dedicated to a particular task. It does nothing on its own,
    but it is used to build the containers (a dedicated virtual environment) where
    your application will live. We can create our own custom images using a Dockerfile
    (we will cover this later) or we can download pre-made images from a wide range
    of open-source images shared by the community.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像可以看作是构建一个专用于特定任务的容器所需的所有规格。它本身不做任何事情，但用于构建容器（一个专用虚拟环境），你的应用程序将运行在其中。我们可以使用
    Dockerfile 创建我们自己的自定义镜像（稍后会讨论），或者我们可以从社区共享的各种开源镜像中下载现成的镜像。
- en: In our case, we want an image that will help us to create a container with PostgreSQL
    running in it, and we can use the [official image](https://hub.docker.com/_/postgres)
    for that purpose.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们需要一个可以帮助我们创建运行 PostgreSQL 的容器的镜像，我们可以使用 [官方镜像](https://hub.docker.com/_/postgres)
    来实现这一目的。
- en: 'We start by downloading the PostgreSQL image on docker. This is done in the
    Shell:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从在 Docker 上下载 PostgreSQL 镜像开始。这是在 Shell 中完成的：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Run the Postgre container
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行 Postgre 容器
- en: 'Once the image is downloaded in Docker, we can build the container based on
    it with the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦镜像在 Docker 中下载完成，我们可以使用以下命令基于它构建容器：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let’s decrypt it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解密它。
- en: '-itd is a combination of 3 parameters:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: -itd 是三个参数的组合：
- en: -d means we run the container in detached mode. In this mode, the container
    will run in the background and we can continue to use our terminal for other stuff.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -d 表示我们以分离模式运行容器。在这种模式下，容器将在后台运行，我们可以继续使用终端进行其他操作。
- en: -i specifies that our container will run in interactive mode. It will allow
    us to go inside the container and interact with it
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -i 指定我们的容器将以交互模式运行。这将允许我们进入容器并与之交互。
- en: -t means a pseudo-terminal will be available inside of the container to interact
    with it, which will bring a more seamless and intuitive interaction with the container
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -t 表示容器内部将提供一个伪终端，以便与容器进行交互，这将带来更无缝和直观的交互体验。
- en: -e generate environmental variables inside the container. In this case, the
    environmental variables POSTGRES_USER and POSTGRES_PASSWORD are also used to generate
    a new user of our PostgreSQL instance with the given password. Without this, we
    could still access the PostgreSQL instance with the default user/password (postgre/postgre)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: -e 用于在容器内部生成环境变量。在这种情况下，环境变量 POSTGRES_USER 和 POSTGRES_PASSWORD 还用于用给定的密码生成我们的
    PostgreSQL 实例的新用户。如果没有这个，我们仍然可以使用默认用户/密码（postgre/postgre）访问 PostgreSQL 实例。
- en: -p is used to map a port from the local machine to the docker container. The
    default port used for PostgreSQL is 5432\. If it was already used in your local
    machine, you could use this parameter to map the 5432 from the container to another
    port of your machine.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: -p 用于将本地机器的端口映射到 Docker 容器中。PostgreSQL 的默认端口是 5432。如果它已经在你的本地机器上被使用，你可以使用这个参数将容器中的
    5432 映射到你机器上的另一个端口。
- en: '-v is a very important parameter in our case: it allows us to map a volume
    from our machine (in our case the folder `~/db` ) to the volume inside of the
    container where the SQL data are stored by default (`/var/lib/postgresql/data`
    ). By doing this mapping, we create a persistent volume that will remain even
    after the container is stopped. Thus, our database will persist even when we stop
    using the container, and will be available for later uses.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: -v 是一个在我们这种情况下非常重要的参数：它允许我们将一个卷从我们的机器（在我们这种情况下是文件夹 `~/db` ）映射到容器内部的卷，其中 SQL
    数据默认存储在 `/var/lib/postgresql/data`。通过进行这种映射，我们创建了一个持久卷，即使容器停止后也会保留。因此，我们的数据库将持续存在，即使我们停止使用容器，之后也可以使用。
- en: — name is just a flag to name the container, which will be useful to access
    it later on
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: — name 只是一个标志，用于给容器命名，这将有助于我们以后访问它。
- en: 'We can check that the container is active by using the below command which
    will display the list of running containers on our machine:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用下面的命令检查容器是否处于活动状态，该命令将显示我们机器上运行的容器列表：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Returning:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First interactions with PostgreSQL
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 PostgreSQL 的初步交互
- en: Our PostgreSQL instance is now running inside our container, we can now interact
    with it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 PostgreSQL 实例现在正在容器中运行，我们可以与它进行交互。
- en: Create the Database
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数据库
- en: As a starting point, let’s create a first database that will contain the different
    tables of our project.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 作为起点，让我们创建一个包含项目不同表格的第一个数据库。
- en: 'To do so, we need to enter our container. Remember that this is possible as
    we specified the -it parameters when initializing the container. The below command
    line will do the job:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要进入容器。记住，这可能是因为我们在初始化容器时指定了 -it 参数。下面的命令行将完成这项工作：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The command prompt now should be:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 命令提示符现在应该是：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'meaning we are logged with the root user in the container. We can connect to
    PostgreSQL using the user (-U)/password (-d) as follow:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们以 root 用户身份登录到容器中。我们可以使用用户 (-U)/密码 (-d) 连接到 PostgreSQL，如下所示：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once in the PostgreSQL instance, we can interact with it using SQL queries,
    and in particular, create a new database to host our future tables.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入 PostgreSQL 实例，我们可以使用 SQL 查询与之交互，特别是创建一个新的数据库来托管我们未来的表。
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can verify that the database has been created by running
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行来验证数据库是否已经创建
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'which will show the different databases in the system. Among some default databases
    created at the initialization of the instance, we can find the one we just created:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示系统中的不同数据库。在一些在实例初始化时创建的默认数据库中，我们可以找到刚刚创建的那个：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that we have set up our PostgreSQL instance, we could interact with our
    database by manually writing SQL queries in **psql** to create tables and import
    data from .csv files. While this approach is suitable for one-time use, it can
    become cumbersome and error-prone in the long run if we need to frequently update
    our tables.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了 PostgreSQL 实例，我们可以通过手动在**psql**中编写 SQL 查询来创建表和从 .csv 文件导入数据。虽然这种方法适用于一次性使用，但如果我们需要频繁更新表，它可能会变得繁琐且容易出错。
- en: Therefore, to facilitate automation, we will use a Python framework to interact
    with the database and its tables. This will allow us to easily create, update,
    and query our database using code, making the process more efficient and less
    error-prone.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了促进自动化，我们将使用 Python 框架与数据库及其表进行交互。这将允许我们通过代码轻松创建、更新和查询数据库，使过程更加高效且减少错误。
- en: Open a session with sqlalchemy
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用 sqlalchemy 打开一个会话
- en: SQLalchemy is an open-source SQL toolkit and Object Relational Mapper (ORM)
    for Python developers. It proposes a set of high-level functions to interact with
    databases rather than writing SQL queries.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: SQLalchemy 是一个开源 SQL 工具包和对象关系映射（ORM）工具，供 Python 开发者使用。它提供了一组高级函数来与数据库交互，而不是编写
    SQL 查询。
- en: It is particularly convenient as it will allow us to define the structure of
    our tables using Python classes (also named “models” here) and work with object-oriented
    paradigms. Our python ORM, **sqlalchemy** will be particularly useful in the next
    part when we build the backend API.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这特别方便，因为它允许我们使用 Python 类（在这里也称为“模型”）定义表的结构，并使用面向对象的范式。我们的 Python ORM，**sqlalchemy**，在下一部分构建后端
    API 时将特别有用。
- en: Let’s start by installing the libraries needed for the project. On top of sqlalchemy,
    we will also use **psycopg2** which is a PostgreSQL adapter for python and can
    be used as a connector by sqlalchemy.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始安装项目所需的库。在 sqlalchemy 的基础上，我们还将使用**psycopg2**，这是一个 PostgreSQL 适配器，可被 sqlalchemy
    用作连接器。
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can now effectively create a session to our database directly in Python:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以直接在 Python 中有效地创建一个会话来访问我们的数据库：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Explaining step by step this script:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一步步解释这个脚本：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The create_engine method is used to hold the connection to the database. We
    need to specify here a database URL that includes all the information required
    to connect to our database.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: create_engine 方法用于保持与数据库的连接。我们需要在这里指定一个数据库 URL，该 URL 包含连接到我们数据库所需的所有信息。
- en: The first part of that URL postgresql**://** is there to specify that we are
    using a PostgreSQL connection and that what will follow will be the specs of a
    connection for that type of database. If you are using a different database such
    as SQLite, you will have a different base and different specs.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该 URL 的第一部分 postgresql**://** 是为了指定我们正在使用 PostgreSQL 连接，并且接下来将是该类型数据库连接的规格。如果你使用的是不同的数据库，如
    SQLite，你将会有不同的基本 URL 和规格。
- en: jkaub:jkaubis the login information to connect to our database.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jkaub:jkaub 是连接到我们数据库的登录信息。
- en: localhostis the server on which we run the database. A server IP could also
    be used to connect to remote servers, or, as we will see later in the case of
    a cluster of containers, we could also use a container name in certain cases.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: localhost 是运行数据库的服务器。服务器 IP 也可以用来连接远程服务器，或者，如我们稍后会看到的，在容器集群的情况下，我们在某些情况下也可以使用容器名称。
- en: /stations is used to specify the database we want to connect to. In our case,
    we connect to the one we just created, “stations”.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: /stations 用于指定我们想要连接的数据库。在我们的例子中，我们连接到我们刚刚创建的“stations”。
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This part of the code is just used for now to test that the connection worked
    well. Our database has no table to query yet, so we are just running a dummy query.
    It should return (1,), which means the connexion succeeded.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分代码目前仅用于测试连接是否成功。我们的数据库还没有表可以查询，所以我们只是运行一个虚拟查询。它应该返回 (1,)，这意味着连接成功。
- en: Building the API with FastAPI
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 FastAPI 构建 API
- en: Now that we have set up our PostgreSQL database in a Docker container and accessed
    it using the SQLAlchemy engine, it’s time to develop the API for interacting with
    the database.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在 Docker 容器中设置了 PostgreSQL 数据库，并使用 SQLAlchemy 引擎访问了它，现在是时候开发与数据库交互的 API
    了。
- en: 'There are several benefits of using an API here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 API 有几个好处：
- en: It offers reusability and platform/language agnosticism, allowing multiple services
    to use the same API endpoint.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了可重用性和平台/语言的独立性，允许多个服务使用相同的 API 端点。
- en: It separates the database logic from the application logic, making it easier
    to modify one without affecting the other as long as the inputs/outputs are respected.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将数据库逻辑与应用逻辑分开，使得只要输入/输出被尊重，修改一个而不影响另一个变得更加容易。
- en: It adds a layer of security as you can control who has access to the database
    with an authorization system.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它增加了一层安全性，因为你可以通过授权系统控制谁可以访问数据库。
- en: Finally, an API is scalable and can run on multiple servers, making it flexible
    for managing the workload. By creating a well-defined set of URLs, we will be
    able to retrieve, modify, insert, or delete data from our database via the API.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，API 是可扩展的，可以在多个服务器上运行，使其在管理工作负载方面非常灵活。通过创建一组明确的 URL，我们将能够通过 API 从数据库中检索、修改、插入或删除数据。
- en: About FastAPI
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于 FastAPI
- en: '[FastAPI](https://fastapi.tiangolo.com/) is a modern python framework particularly
    efficient in building lightweight API developed by [Sebastián Ramírez](https://github.com/tiangolo).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[FastAPI](https://fastapi.tiangolo.com/) 是一个现代的 Python 框架，在构建轻量级 API 方面特别高效，由
    [Sebastián Ramírez](https://github.com/tiangolo) 开发。'
- en: It is particularly efficient when combined with **sqlalchemy** and [**pydantic**](https://docs.pydantic.dev/),
    a python library used for data validation (for example it can control that a date
    is actually a date, that a number is a number, etc…). Used together, it allows
    us to handle and query effectively tables directly via the framework.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 结合**sqlalchemy**和[**pydantic**](https://docs.pydantic.dev/)这两个用于数据验证的 Python
    库时，它特别高效（例如，它可以检查一个日期是否确实是日期，一个数字是否确实是数字，等等）。一起使用，它使我们能够通过框架有效地处理和查询表格。
- en: Even better, [Sebastián Ramírez](https://github.com/tiangolo) designed also
    another library, [**sqlmodel**](https://sqlmodel.tiangolo.com/) that combines
    both pydantic and sqlalchemy to remove some of the redundancies and simplify even
    more the architecture of the APIs.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 更棒的是，[Sebastián Ramírez](https://github.com/tiangolo) 还设计了另一个库，[**sqlmodel**](https://sqlmodel.tiangolo.com/)，它结合了
    pydantic 和 sqlalchemy，去除了一些冗余，并进一步简化了 API 的架构。
- en: If you have yet to become familiar with FastAPI, I recommend you to have a look
    at [this tutorial](https://fastapi.tiangolo.com/tutorial/) first, which is really
    well done.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还不熟悉 FastAPI，我建议你先看看[这个教程](https://fastapi.tiangolo.com/tutorial/)，这个教程做得非常好。
- en: Before starting the project, we will need to install multiple libraries.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始项目之前，我们需要安装多个库。
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**uvicorn** is the tool that will run the API server and is well-suited to
    work in tandem with FastAPI'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**uvicorn** 是运行 API 服务器的工具，并且非常适合与 FastAPI 一起使用。'
- en: '**fastapi** is the core engine of the API, that we will use to create the different
    endpoints'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**fastapi** 是 API 的核心引擎，我们将用它来创建不同的端点。'
- en: '**sqlmodel** combines the sqlalchemy ORM with the power of type verification
    of pydantic'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sqlmodel** 将 sqlalchemy ORM 与 pydantic 的类型验证功能结合起来'
- en: '**geolochemy2** is an extension of sqlalchemy used to perform geoqueries'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**geolochemy2** 是 sqlalchemy 的一个扩展，用于执行地理查询。'
- en: Initialize the models
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化模型
- en: Let’s create a new repository for our API Project, starting with the definition
    of our models with **sqlmodel**. A “model” is nothing more than a python class
    that represents a table in SQL.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的 API 项目创建一个新的仓库，从使用**sqlmodel**定义模型开始。 “模型”只是一个代表 SQL 中表格的 Python 类。
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Our project will have 3 tables and will follow the initial design we built in
    [part I](/a-step-by-step-guide-to-develop-a-map-based-application-part-i-757766b04f77).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目将包含 3 个表格，并遵循我们在 [part I](/a-step-by-step-guide-to-develop-a-map-based-application-part-i-757766b04f77)
    中构建的初始设计。
- en: One table containing the information related to cities (postal codes, locations)
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含与城市相关的信息（邮政编码、位置）的表格
- en: One table containing information about the gas prices
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含关于燃气价格信息的表格
- en: One table containing information about the stations
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含关于车站信息的表格
- en: Combining those tables with joins and geofilters will help us build the final
    output requested by the front-end side.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过联接和地理过滤器组合这些表，将帮助我们构建前端请求的最终输出。
- en: 'Let’s have a look at the first table, the Cities table:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看一下第一个表格，Cities 表：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The class “Cities” inherit from the class SQLModel, combining both sqlalchemy**’s**
    ORM features and pydantic’s typing control.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 类 “Cities” 继承自 SQLModel 类，结合了 sqlalchemy**’s** ORM 特性和 pydantic 的类型控制。
- en: The parameter table=True indicates to automatically create the corresponding
    table if it does not exist yet in the database, matching columns names and columns
    typing.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 参数 table=True 表示如果数据库中尚不存在相应的表，则会自动创建该表，并匹配列名和列类型。
- en: Each attribute of the class will define each column with its type. In particular,
    “id” will be our primary key. Using Optional will indicate sqlalchemy to automatically
    generate ids by incrementation if we don’t provide one.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 类的每个属性将定义每一列及其类型。特别是，“id”将作为我们的主键。使用 Optional 将指示 sqlalchemy 如果我们不提供 id，则自动生成
    id。
- en: 'We also provide the models for the two other tables:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提供了另外两个表的模型：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that in the case of the table Stations, we are using station_id as the
    primary key, and unlike GasPrices, the field will be mandatory. If the field is
    empty when sent to the table, it will generate an error message.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在 Stations 表中，我们使用 station_id 作为主键，与 GasPrices 不同，该字段是必填的。如果在发送到表格时该字段为空，将会生成错误信息。
- en: Initialize the engine
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化引擎
- en: In another dedicated file to keep the project structured, we are going to initiate
    the engine. We call that file services.py.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个专用文件中，为了保持项目结构化，我们将初始化引擎。我们称之为 services.py。
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The connection to the DB is done in the same way as the one presented before.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到数据库的方式与之前介绍的相同。
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note the function create_db_and_tables(): this function will be called during
    the initialization of the API, will look-up the models defined in models.py, and
    will create them directly inside the SQL database if they don’t already exist.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意函数 create_db_and_tables()：该函数将在 API 初始化期间被调用，查看 models.py 中定义的模型，并直接在 SQL
    数据库中创建它们（如果它们尚不存在的话）。
- en: Hands-on the API
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实操 API
- en: We can now start the development of the main component in which we are going
    to put the endpoints (= the URL that will allow us to interact with the database).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始开发主要组件，我们将在其中放置端点（即允许我们与数据库交互的 URL）。
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first thing we want to do is configure FastAPI when it starts up and deal
    with API authorizations.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是配置 FastAPI 在启动时的设置，并处理 API 授权。
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'An important point to note: by default, our front does not have the access
    to make API calls, and if you forget to configure the middleware part, you will
    expose yourself to errors on the front-end side. You could decide to allow all
    origins by using:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的点是：默认情况下，我们的前端没有访问 API 调用的权限，如果你忘记配置中间件部分，将会在前端出现错误。你可以决定通过使用以下方式允许所有来源：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: but this is not something I recommend for safety reasons, as you would basically
    open your API to the world once it is online. Our front end is currently running
    locally at localhost:3000, so this is the domain we will allow.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 但由于安全原因，我不推荐这样做，因为一旦上线，你基本上会将 API 向全世界开放。我们的前端目前在 localhost:3000 上本地运行，所以这是我们将允许的域名。
- en: 'At that point, we can already launch the API, by using the following command
    line:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 到那时，我们已经可以通过使用以下命令行来启动 API：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The — reload simply means that each time we will save a modification in the
    API while it is running, it will reload to include those changes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: — reload 只是意味着每次在 API 正在运行时保存修改，它将重新加载以包含这些更改。
- en: 'Once started, you can see some logs displayed in the shell, in particular:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动，你可以看到一些日志显示在终端中，特别是：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: indicates that the API server is running on localhost (equivalent to the IP
    127.0.0.1), port 8000.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 表示 API 服务器正在 localhost（等同于 IP 127.0.0.1）上的 8000 端口运行。
- en: As explained earlier, starting the API will also trigger the creation of empty
    tables in the DB (if they don’t already exist). So from the moment you have initiated
    your API for the first time, the models you create with table=True will have a
    dedicated table in the database.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，启动 API 还会触发数据库中空表的创建（如果它们尚不存在）。因此，从你第一次启动 API 的那一刻起，使用 table=True 创建的模型将在数据库中有一个专用表。
- en: 'We can check this easily from within the PostgresSQL container in psql. Once
    connected as the main user, we first connect to the database station:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在 psql 中从 PostgresSQL 容器内部轻松检查这一点。连接为主用户后，我们首先连接到数据库 station：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can now check that our tables have been well created:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以检查我们的表是否已正确创建：
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Which will return:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can also verify that the columns match our models by running a description
    query in psql, for example, for cities:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过在 psql 中运行描述查询来验证列是否与我们的模型匹配，例如，对于 cities 表：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Building our first request — Adding rows to Cities with a POST request
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建我们的第一个请求 — 使用 POST 请求向 Cities 添加行
- en: The Cities table will be filled only one time and is used to match postal codes
    with lat/lon of cities, which will be particularly helpful later to query around
    those locations using a postal code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Cities 表只会填充一次，并用于将邮政编码与城市的经纬度匹配，这在后续使用邮政编码查询这些位置时特别有帮助。
- en: As of now, the data are stored in a .csv and we want to design a POST call that
    will be used to update the table adding one row at a time if it is not yet in
    the database. The API calls are put inside the main.py file.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，数据存储在 .csv 文件中，我们想设计一个 POST 调用，用于更新表格，如果数据还不在数据库中，则一次添加一行。API 调用被放在 main.py
    文件中。
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let’s have a look at this piece of code line by line:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行查看这段代码：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Each API endpoint is defined using a decorator. We are defining here two things:
    the type of request (get, post, put, delete…) and the URL endpoint associated
    (/add-city/).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 API 端点都是通过装饰器定义的。我们在这里定义了两件事：请求的类型（get、post、put、delete…）和关联的 URL 端点 (/add-city/)。
- en: In this particular case, we will be able to do a POST request at http://127.0.0.1:8000/add-city/
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的案例中，我们将能够在 http://127.0.0.1:8000/add-city/ 执行 POST 请求
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We pass in the function the different parameters to be used in the query. In
    our case, the post request will look for an instance of Cities, which will be
    passed via a JSON in our request. This JSON will contain the values for each column
    of the Cities Table for the new row we want to add.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不同的参数传递给函数以用于查询。在我们的案例中，post 请求将寻找 Cities 的实例，这将通过 JSON 传递在我们的请求中。此 JSON
    将包含我们想要添加的新行的 Cities 表的每列的值。
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To connect to the database we open a Session. Each query needs its own session.
    Using this methodology will be particularly useful in case something unexpected
    happens inside the session: all changes made between the initialization of the
    session and the commit() will be rolled back in case of a problem.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到数据库，我们打开一个 Session。每个查询需要自己的会话。使用这种方法在会话内部出现意外情况时特别有用：在会话初始化和 commit() 之间所做的所有更改将在出现问题时回滚。
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, the object is added to the database and then commit. From the moment it
    is committed the operations cannot be rolled back. The refresh is used to update
    the “city” object with any modification operated by the DB. In our case, for example,
    an incremental “id” is automatically added.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，对象被添加到数据库中，然后进行提交。从提交的那一刻起，操作无法回滚。refresh 用于更新 DB 进行的任何修改的“city”对象。在我们的案例中，例如，会自动添加递增的“id”。
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We conclude the request by sending the object city in the form of a JSON.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过以 JSON 格式发送 city 对象来结束请求。
- en: 'We can now try the request in python (this need to be done with the API running,
    of course):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在 python 中尝试请求（当然需要 API 正在运行）：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note that the keys of the JSON we are sending in the request match the name
    of the columns of the table we want to update. The parameter “id” is optional,
    it will be automatically added to the operation and we don’t need to bother about
    it.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在请求中发送的 JSON 键与我们要更新的表的列名称匹配。参数“id”是可选的，它将自动添加到操作中，我们不需要担心它。
- en: 'This should trigger in the API shell the following line:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在 API shell 中触发以下行：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Meaning the request was successful. We can then verify that the line has been
    well-added. Going back to psql in our docker, we can try the following query:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着请求成功。我们可以进一步验证该行是否已正确添加。返回到我们 docker 中的 psql，我们可以尝试以下查询：
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'which will display:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示：
- en: '[PRE39]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: demonstrating that the row has been effectively added by the API in our DB.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 演示该行已被 API 有效添加到我们的数据库中。
- en: On top of that, we don’t want a postal code to be added twice. To do so, we
    are going to query the Cities table, filter the table based on the postal code
    we are trying to send, and return an HTML error in case we find a row with that
    postal code, which will result in avoiding postal_code duplicates.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们不希望邮政编码被重复添加。为此，我们将查询 Cities 表，根据我们尝试发送的邮政编码过滤表，并在找到具有该邮政编码的行时返回 HTML 错误，从而避免邮政编码重复。
- en: '[PRE40]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In this new block of code we are performing our first database query using
    sqlalchemy ORM: instead of writing classical SQL (“SELECT FROM”) we are using
    a set of functions to query directly our database.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段新代码中，我们使用 sqlalchemy ORM 执行了第一次数据库查询：我们没有编写经典的 SQL（“SELECT FROM”），而是使用了一组函数来直接查询数据库。
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: .query is equivalent to SELECT … FROM …, in our case, we select everything from
    the table cities
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.query` 相当于 SELECT … FROM …，在我们的案例中，我们从 cities 表中选择所有内容。'
- en: .filter is equivalent to the WHERE statement. In particular, we want to match
    entries that are equal to the postal code of the object we are sending (represented
    by the variable city)
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.filter` 相当于 WHERE 语句。特别地，我们要匹配与我们发送的对象的邮政编码相等的条目（由变量 city 表示）。'
- en: .first() is self-explanatory and is equivalent to LIMIT 1.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.first()` 是自解释的，相当于 LIMIT 1。'
- en: if no row is found, exist will be None and the exception will not be raised,
    so we will add the object to the database. If a row matches with the postal code,
    the API request will return an error with status_code 400 and the post request
    will be interrupted without the element being added.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有找到行，则 `exist` 将为 None，并且不会引发异常，因此我们将把对象添加到数据库中。如果某行与邮政编码匹配，API 请求将返回状态码
    400 的错误，且 POST 请求将被中断，元素不会被添加。
- en: 'If we try now to send the exact same request as before, we will see the API
    returning an error message:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试发送完全相同的请求，将看到 API 返回错误消息：
- en: '[PRE42]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: And the row has not been added to the table.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 而且该行没有被添加到表中。
- en: From that point, we can simply loop through our .csv and add all the cities
    one by one to populate the table cities.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，我们可以简单地遍历 `.csv` 并逐一添加所有城市，以填充 cities 表。
- en: Adding rows to the Gasprices and Stations tables with a POST request
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 POST 请求向 Gasprices 和 Stations 表中添加行
- en: We will pass very quickly on the construction of these API calls as they are
    very similar to the previous one.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将非常快速地跳过这些 API 调用的构建，因为它们与之前的非常相似。
- en: '[PRE43]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The only interesting thing to notice here is that we are using a double filter
    query to make sure that we add a row only if there was a new update for the oil_id.
    This way, we ensure that future updates will not create duplicates if a price
    has not moved from one day to another, saving some space in the DB.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一需要注意的有趣之处在于，我们使用了双重过滤查询，以确保仅在 `oil_id` 有新更新时才添加一行。这样，我们确保了未来的更新不会在价格没有变化的情况下创建重复项，从而节省了数据库空间。
- en: To retrieve the gas prices and ingest them, we are simply recycling our parsing
    code from [Part I](/a-step-by-step-guide-to-develop-a-map-based-application-part-i-757766b04f77),
    get the corresponding dataset and loop through it making a POST call for each
    entry.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检索和处理油价，我们只是回收了来自 [Part I](/a-step-by-step-guide-to-develop-a-map-based-application-part-i-757766b04f77)
    的解析代码，获取相应的数据集并循环遍历，为每个条目进行 POST 调用。
- en: 'The script below is executed outside of the API scope to upload data to the
    DB:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本在 API 范围之外执行，以将数据上传到数据库：
- en: '[PRE44]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*Note: I chose here for simplicity to push the data row by row. We could have
    also designed the endpoint to push the data by batches and send a list of JSON.*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意：为了简化起见，我在这里选择逐行推送数据。我们也可以设计端点以批量推送数据，并发送 JSON 列表。*'
- en: Building the GET query used in the front-end
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建前端使用的 GET 查询
- en: At this point, our database is fully filled and the script above could be eventually
    used to update it with more recent data, and we can start building the GET request
    used in the front end to query the prices of a specific fuel for the stations
    around a particular city.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点为止，我们的数据库已完全填充，以上脚本可以用于用更近期的数据更新数据库，我们可以开始构建前端用来查询特定城市周围加油站特定燃料价格的 GET 请求。
- en: I decided to dedicate a full section to this particular query, due to its complexity
    (we are going to use all the tables defined so far, make joins and geofilters)
    but also because we need to operate some changes at this point to integrate spatial
    features to our database, installing add-ons and modifying some models. While
    this could have been done directly from the start, it is common in real projects
    to operate modifications and I think it is interesting to show you how we can
    do it here smoothly.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我决定为这个特定查询专门设置一个完整的章节，因为它的复杂性（我们将使用到目前为止定义的所有表，进行连接和地理过滤），同时因为我们需要在此时对数据库进行一些更改，以集成空间功能，安装附加组件和修改一些模型。虽然这可以从一开始就直接完成，但在实际项目中进行修改是常见的，我认为展示如何平滑地完成这一过程是很有趣的。
- en: Installing PostGIS
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 PostGIS
- en: PostGIS is an extension to PostgreSQL that will allow us to build geo-queries,
    which implies a spatial component. For example in our case, we would be able to
    select all rows from stations in a 30km radius from a point of interest.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: PostGIS 是 PostgreSQL 的一个扩展，允许我们构建地理查询，这意味着需要一个空间组件。例如，在我们的情况下，我们能够选择距离某个兴趣点
    30 公里半径内的所有车站数据行。
- en: Now we don’t want to install directly PostGIS in our running container, because
    this installation will be “lost” every time we need to pop a new container, which
    is based on an image in which only PostgreSQL is installed.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们不想直接在运行的容器中安装 PostGIS，因为每次我们需要弹出一个新的容器时，这个安装会“丢失”，新容器基于仅安装 PostgreSQL 的镜像。
- en: Instead, we are going to simply change the image we are using to build the container
    and replace it with one containing both PostgreSQL and PostGIS. We will provide
    the same persistent storage where our DB is currently located, so the new container
    will also have access to it.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将简单地更改用于构建容器的镜像，并将其替换为包含 PostgreSQL 和 PostGIS 的镜像。我们将提供相同的持久存储位置，以便新容器也可以访问它。
- en: To build the container with the PostGIS extension, we first pull the latest
    PostGIS image from docker, then we kill and remove the current PostgreSQL container,
    and build the new one with the new image.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建包含 PostGIS 扩展的容器，我们首先从 docker 中拉取最新的 PostGIS 镜像，然后杀死并删除当前的 PostgreSQL 容器，并用新的镜像构建一个新的容器。
- en: '[PRE45]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We can then access the container as we were doing previously, but we are now
    using a version of PostgreSQL including PostGIS.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像之前一样访问容器，但现在我们使用的是包括 PostGIS 的 PostgreSQL 版本。
- en: 'We now need to add the extension to our existing database. We first reconnect
    to the DB:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要将扩展添加到现有数据库中。我们首先重新连接到数据库：
- en: '[PRE46]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then we include in it the PostGIS extension:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在其中包含 PostGIS 扩展：
- en: '[PRE49]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Modifying our Stations model
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改我们的 Stations 模型
- en: Now that we have PostGIS up and running in our database, we need to modify our
    Stations table to be able to perform a geo-query. More precisely, we need to add
    a “geometry” field that is understood and converted to an actual location on Earth.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的数据库中已经运行了 PostGIS，我们需要修改我们的 Stations 表以便能够执行地理查询。更准确地说，我们需要添加一个“geometry”字段，该字段被理解并转换为地球上的实际位置。
- en: There are multiple ways of building maps or indicating a location on Earth,
    each way with its own projections and referenced coordinate system. To make sure
    one system can speak to another, we need to make sure they speak the same language
    which can include making conversion of units (the same way we could convert meters
    to feet, or kilograms to pounds).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 建立地图或标示地球上的位置有多种方法，每种方法都有其自己的投影和参考坐标系统。为了确保一个系统能够与另一个系统对话，我们需要确保它们使用相同的语言，这可能包括单位的转换（就像我们可以将米转换为英尺，或将千克转换为磅）。
- en: For coordinates, we are using something called a “Geodetic Parameter Dataset”
    (EPSG). Latitudes and Longitudes (EPSG 4326) are expressed as angles and it is
    not possible to directly convert this to distances (Euclidean Geometry, including
    distance calculation, cannot be applied on the surface of a sphere directly as
    it is, because, by nature, this is not a euclidean surface..). Instead, they need
    to be projected to a plan representation, which is handled nicely in PostGIS as
    long as we are aware of it and apply the appropriate conversions.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 对于坐标，我们使用称为“地理参数数据集”（EPSG）的东西。纬度和经度（EPSG 4326）以角度表示，无法直接转换为距离（欧几里得几何，包括距离计算，不能直接应用于球面，因为本质上这不是一个欧几里得表面）。相反，需要将其投影到平面表示中，这在
    PostGIS 中处理得很好，只要我们注意并应用适当的转换。
- en: 'As a starting point, we need to add a new field in our Stations database which
    can be interpreted as a “geometrical” coordinate. From within our database:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 作为起点，我们需要在 Stations 数据库中添加一个可以被解释为“几何”坐标的新字段。在我们的数据库中：
- en: '[PRE50]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This line will modify our stations' table with a new field “geom” which is a
    PostGIS geomtry of type “point”, expressed using EPSG 4326 (the EPSG of latitude/longitude
    system). The field is for now empty for all the rows, but we can fill it very
    easily still in SQL to update the current table (which is not empty at this point).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行将修改我们的 stations 表，添加一个新的字段 “geom”，它是类型为 “point” 的 PostGIS 几何图形，使用 EPSG 4326（经纬度系统的
    EPSG）表示。该字段目前对所有行为空，但我们仍然可以在 SQL 中轻松填充它，以更新当前表（此时表并不为空）。
- en: '[PRE51]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The above SQL query will SET the geom column for each row of the Stations table
    with a Point made from the longitudes/latitudes. Note that we are using here two
    PostGIS functions, ST_MakePoint and ST_SetSRID to help us define the geometry
    in SQL.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的 SQL 查询将为 Stations 表的每一行设置 geom 列，使用由经度/纬度构建的点。注意我们在这里使用了两个 PostGIS 函数，ST_MakePoint
    和 ST_SetSRID，来帮助我们在 SQL 中定义几何图形。
- en: We can check how this new geometry is stored in the DB
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查这个新的几何图形在数据库中的存储方式
- en: '[PRE52]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: You can see here that the geometry is encoded in a string which is the Well-Known
    Binary (WKB) format, which is efficient to store geometries. I’ll not expand on
    this, but don’t be surprised if you see this in your datasets, you might need
    to decode this to a more readable format if needed.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里看到，几何图形以字符串编码，这种格式是 Well-Known Binary (WKB)，它在存储几何图形时非常高效。我不会进一步展开这个内容，但如果你在数据集中看到这个格式不要感到惊讶，如果需要，你可能需要将其解码为更可读的格式。
- en: Now, we also need to also update the Stations class in our model.py file to
    include this new field, and for this, we are using the type “Geometry” from **geoalchemy**.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还需要更新 model.py 文件中的 Stations 类以包含这个新字段，为此我们使用 **geoalchemy** 的 “Geometry”
    类型。
- en: '[PRE54]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Last modification to make: we want the geometry to be automatically calculated
    in the POST call (in main.py) using the latitude and longitude parameters:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的修改是：我们希望在 POST 调用（在 main.py 中）时，使用纬度和经度参数自动计算几何图形：
- en: '[PRE55]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Here we are creating a point via a string using another format named WKTElement,
    which is a way to encode geometry using human-readable strings. Our string is
    then converted to geometry via the **geolalchemy** function WKTElement, which
    implicitly converts it into the WKB format to be encoded in the database.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过字符串创建一个点，使用另一种名为 WKTElement 的格式，这是一种使用人类可读的字符串编码几何图形的方式。我们的字符串随后通过 **geolalchemy**
    函数 WKTElement 转换为几何图形，该函数隐式地将其转换为 WKB 格式以便编码到数据库中。
- en: Note that “geom” is not JSON serializable, so we need to modify it or remove
    it before sending back the station object via the API.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，“geom”不是 JSON 可序列化的，因此我们需要在通过 API 发送站点对象之前修改或删除它。
- en: Build the final GET query
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建最终的 GET 查询
- en: The goal of the GET query is to retrieve all the stations within a 30km radius
    from a city identified via its postal code and show the fuel latest price of a
    certain type (also used in the query) of all the stations queried with a bunch
    of prettified stuff like a normalized address or a google map link.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: GET 查询的目标是从通过邮政编码识别的城市中检索30公里半径内的所有站点，并显示查询中提到的某种类型的所有站点的燃料最新价格，并附上一些美化的信息，如规范化的地址或
    Google 地图链接。
- en: '[PRE56]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We are going to do this in two steps:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分两步进行：
- en: First building an efficient SQL query to perform the joins and filtering operations
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先构建一个高效的 SQL 查询来执行连接和过滤操作
- en: Modify the output of the query using python functions before sending the results
    via the API
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在通过 API 发送结果之前，使用 Python 函数修改查询的输出。
- en: 'Unlike other queries where the parameters were passed as a JSON in the body
    of the request, we will use here another convention, in which the query parameters
    are passed directly in the URL, see the example below:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他参数通过请求体中的 JSON 传递的查询不同，我们在这里将使用另一种约定，即将查询参数直接传递在 URL 中，见下面的示例：
- en: '[PRE57]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In FastAPI, this is done very naturally by simply adding inputs to the function
    used to build the endpoint:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FastAPI 中，这可以通过简单地向用于构建端点的函数中添加输入来自然完成：
- en: '[PRE58]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The first thing we want to retrieve now is the latitude and longitude of the
    city associated with a postal code. If no city is associated with the postal code,
    the API should return an error code stating that no postal code was found.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要首先检索的是与邮政编码相关联的城市的纬度和经度。如果没有与邮政编码关联的城市，API 应该返回一个错误代码，说明未找到邮政编码。
- en: '[PRE59]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Next, we are going to build a series of subqueries. Each subquery will not be
    evaluated until the final query is fully executed. It will help us keep a readable
    code and optimize the query as sqlalchemy ORM dynamically optimize the query based
    on those subqueries.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构建一系列子查询。每个子查询在最终查询完全执行之前不会被评估。这将帮助我们保持代码的可读性，并优化查询，因为 sqlalchemy ORM
    会根据这些子查询动态优化查询。
- en: The first subquery we want to make is to select all the stations from the Stations
    table that are within a 30km radius of the city already queried.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要执行的第一个子查询是从 Stations 表中选择所有在已查询城市 30 公里半径范围内的车站。
- en: '[PRE60]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Numerous interesting things to note here.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有许多有趣的地方需要注意。
- en: We select only a few columns in session.query( … ) and we are not keeping the
    geom column which is done only for filtering purposes. In standard SQL, it would
    have been made doing “SELECT station_id, adress, cp, city, latitude, longitude
    FROM stations”.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只在 session.query( … ) 中选择了少量列，并且不保留 geom 列，该列仅用于过滤。在标准 SQL 中，这可以通过 “SELECT
    station_id, adress, cp, city, latitude, longitude FROM stations” 来完成。
- en: We are using **ST_Distance**, an in-built function of geoalchemy used to compute
    the distance between two geographies (another geoalchemy type).
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用**ST_Distance**，这是 geoalchemy 的内置函数，用于计算两个地理位置之间的距离（另一种 geoalchemy 类型）。
- en: ST_Distance could work also with geometries, but the output would become an
    angular distance (remember that lat/lon are expressed in angles), which is not
    what we want.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ST_Distance 也可以与几何对象一起工作，但输出将变成角度距离（请记住，纬度/经度是以角度表示的），这不是我们想要的。
- en: To convert geometries to geographies, we simply use another inbuilt function,
    ST_GeoFromWKB, which will automatically project our geometry in their reference
    system to a point on Earth.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将几何对象转换为地理对象，我们只需使用另一个内置函数 ST_GeoFromWKB，它会自动将我们的几何体投影到其参考系统中，以在地球上形成一个点。
- en: Next, we filter the Gasprices table based on the desired oil_type (SP95, Gazole,
    etc..)
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们根据所需的 oil_type（如 SP95、Gazole 等）过滤 Gasprices 表。
- en: '[PRE61]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We also need to filter the Gasprices table based on the latest prices available
    in the dataset. This is not an easy task because all updates are not done at the
    same time for all the prices. We are going to build the subquery in two steps.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要根据数据集中最新的价格来过滤 Gasprices 表。这不是一项容易的任务，因为所有价格的更新不是同时完成的。我们将分两步构建子查询。
- en: First, we perform an aggregation by taking the station_id and the last update
    date from the price_wanted_gas sub-table.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过从 price_wanted_gas 子表中提取 station_id 和最后更新时间来执行聚合。
- en: '[PRE62]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This information is then used to help us filter price_wanted_gas via a join
    where only the rows with the latest update prices are kept. The “and_” method
    allows us to use multiple conditions in our join operation.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用这些信息帮助我们通过连接过滤 price_wanted_gas，其中仅保留最新更新价格的行。“and_” 方法允许我们在连接操作中使用多个条件。
- en: '[PRE63]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Finally, we operate a final join between the last_price_full subtable (containing
    all the latest prices of a given fuel) and the stations subtable (including all
    the stations within a 30km radius) and retrieve all the results.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在 last_price_full 子表（包含给定燃料的所有最新价格）和 stations 子表（包括所有在 30 公里半径内的车站）之间进行最终连接，并检索所有结果。
- en: '[PRE64]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Arrived at that point, we retrieved a filtered list of relevant stations merged
    with the relevant information from the GasPrices table (ie: prices) and we just
    need to post-process the output to fit the requirements of the front. As the table
    has been already cleaned and filtered at that point, this final postprocessing
    step can be done in raw Python without impacting too much the performances.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 到达这一点时，我们检索了经过过滤的相关车站列表，并将其与 GasPrices 表中的相关信息（即：价格）合并，我们只需要对输出结果进行后处理，以符合前端的要求。由于此时表格已经被清理和过滤，因此最终的后处理步骤可以在原生
    Python 中完成，而不会对性能产生太大影响。
- en: I will only elaborate a little on that final post-processing step as it is not
    in the core of the article but fill free to check the [GitHub](https://github.com/jkaub/station-prices-app-full)
    repository for more information.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我将稍微详细说明这个最终的后处理步骤，因为它不在文章的核心部分，但请随时查看 [GitHub](https://github.com/jkaub/station-prices-app-full)
    仓库以获取更多信息。
- en: '[PRE65]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We can now test and verify that the query is returning the relevant output.
    We could use a request in Python to check, but FastAPI also provides in-built
    documentation for all your endpoint in which you can test your API, available
    at [http://localhost:8000/docs](http://localhost:8000/docs)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以测试并验证查询是否返回了相关输出。我们可以使用 Python 请求进行检查，但 FastAPI 还提供了所有端点的内置文档，您可以在 [http://localhost:8000/docs](http://localhost:8000/docs)
    测试您的 API。
- en: '![](../Images/d98f30901a0a542ae5e477d2d7662e46.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d98f30901a0a542ae5e477d2d7662e46.png)'
- en: Screenshot of FastAPI in-built documentation, Author Illustration
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 内置文档的截图，作者插图
- en: Containerizing the application
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器化应用程序
- en: Now that we have an API up and running, we will finish this article by packaging
    our application in containers.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个运行中的 API，我们将通过将应用程序打包到容器中来完成本文。
- en: 'This is how our project will be organized:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们项目的组织方式：
- en: '[PRE66]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We are going to use the Dockerfile in api/ to containerize the API, and use
    docker-compose to manage simultaneously the API and the database.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 api/ 中的 Dockerfile 来容器化 API，并使用 docker-compose 同时管理 API 和数据库。
- en: The folder db/ is the volume the PostgreSQL container uses to persist the database.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 文件夹 db/ 是 PostgreSQL 容器用来持久化数据库的卷。
- en: Packaging our API
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打包我们的 API
- en: To package our API we will simply build a docker image that will replicate the
    environment and dependencies required to run our API. This docker image will contain
    everything necessary to run our API, including the code, runtime, system tools,
    libraries, and configurations.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打包我们的 API，我们将简单地构建一个 docker 镜像，该镜像将复制运行 API 所需的环境和依赖项。这个 docker 镜像将包含运行 API
    所需的所有内容，包括代码、运行时、系统工具、库和配置。
- en: 'To do so, we need to write a Dockerfile which will contain the series of instructions
    to set up a FastAPI environment. Writing a Dockerfile is relatively easy when
    you understood the principle: it is like configuring a new machine from the beginning.
    In our case:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要编写一个 Dockerfile，其中包含设置 FastAPI 环境的一系列指令。编写 Dockerfile 相对容易，只要理解了原理：它就像是从头开始配置一台新机器。在我们的案例中：
- en: We need to install the relevant version of python
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要安装相关版本的 Python
- en: Setup the working directory
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置工作目录
- en: Copy the relevant files in our working directory (including the requirements.txt
    which is mandatory to pip install all the libraries needed for the project
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将相关文件复制到我们的工作目录中（包括 requirements.txt 文件，该文件是使用 pip install 安装项目所需所有库的强制要求）
- en: Installing the libraries with pip install
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 pip install 安装库
- en: Expose FastAPI port
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暴露 FastAPI 端口
- en: Run the command that initializes the API (uvicorn main:app — reload)
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行初始化 API 的命令（uvicorn main:app — reload）
- en: 'Translated in Docker language, this becomes:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 用 Docker 语言翻译过来，这变成了：
- en: '[PRE67]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We also need to take care of the requirement.txt file in which we precise all
    the libraries used and their versions.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要处理 requirements.txt 文件，其中明确列出所有使用的库及其版本。
- en: '[PRE68]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'With these updates made, we can now build the image of our container (from
    within the folder with the Dockerfile):'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这些更新之后，我们现在可以构建容器镜像（在包含 Dockerfile 的文件夹内）：
- en: '[PRE69]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Using docker-compose
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 docker-compose
- en: '**docker-compose** is a tool for defining and running multi-container Docker
    applications. In our case, we want to run both our SQL container as well as the
    FastAPI container. I will assume you have already docker-compose installed on
    your computer. If this is not the case, please follow [those instructions](https://docs.docker.com/compose/install/).'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**docker-compose** 是一个用于定义和运行多容器 Docker 应用程序的工具。在我们的案例中，我们希望同时运行 SQL 容器和 FastAPI
    容器。我将假设您已经在计算机上安装了 docker-compose。如果没有，请按照[这些说明](https://docs.docker.com/compose/install/)进行操作。'
- en: In order to use docker-compose, we simply need to configure a `docker-compose.yml`
    file in the root directory of our project, which defines the services that make
    up our application and their respective configurations.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 docker-compose，我们只需在项目的根目录中配置一个 `docker-compose.yml` 文件，该文件定义了构成应用程序的服务及其各自的配置。
- en: The `docker-compose.yml` file uses YAML syntax to define a set of services,
    each representing a container that will be run as part of the global application.
    Each service can specify its image, build context, environment variables, persistent
    volumes, ports, etc…
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose.yml` 文件使用 YAML 语法定义了一组服务，每个服务代表一个将作为全球应用程序的一部分运行的容器。每个服务可以指定其镜像、构建上下文、环境变量、持久化卷、端口等……'
- en: 'This is how looks our docker-compose.yml:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的 docker-compose.yml 文件的样子：
- en: '[PRE70]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'As you can see, we are defining two services:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们定义了两个服务：
- en: one for the API, named now FastAPI, which is built on the Docker image fast-api-station
    that we created in the previous sub-section. For this service, we are exposing
    port 80 from the container to our local port 8000.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于API的服务，现在名为FastAPI，构建在我们在前一个小节中创建的Docker镜像fast-api-station上。对于这个服务，我们将容器的80端口暴露给本地的8000端口。
- en: one for the DB, running on the PostGIS image. We are specifying the same environmental
    variable as we were doing before and the same volume to persist in the database.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于DB，运行在PostGIS镜像上。我们指定了与之前相同的环境变量和相同的卷以持久化数据库。
- en: One last small modification
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最后一个小修改
- en: We used to connect to the SQL engine using the local IP. As we are now running
    the API and PostgreSQL in two different environments, we need to switch the way
    we connect to the database.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们曾经使用本地IP连接到SQL引擎。由于我们现在在两个不同的环境中运行API和PostgreSQL，我们需要更改连接数据库的方式。
- en: 'docker-compose manage on its own network between the different containers and
    make it easy for us to connect from one service to another. In order to connect
    to the SQL service from the API service, we can specify the name of the service
    to which we want to connect in the engine creation:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: docker-compose自行管理不同容器之间的网络，并使我们能够轻松地从一个服务连接到另一个服务。为了从API服务连接到SQL服务，我们可以在引擎创建时指定要连接的服务名称：
- en: '[PRE71]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Running the back-end
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行后端
- en: 'Now that we have configured everything, we can just run our back-end application
    by doing:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置好了所有内容，我们可以通过以下方式运行我们的后端应用程序：
- en: '[PRE72]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: And the API will be available via port 8000
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: API将通过8000端口提供服务。
- en: '[PRE73]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Conclusion
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: In this article, we have been working on the back end of our GasFinder Application.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇文章中，我们一直在处理我们GasFinder应用程序的后端。
- en: We decided to store all the relevant data of the Application in our own storage
    solution to avoid all problems that could have been related to relying on a third-party
    connection.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定将应用程序的所有相关数据存储在我们自己的存储解决方案中，以避免所有可能与依赖第三方连接相关的问题。
- en: We leveraged Docker and PostgreSQL+PostGIS to build a database allowing us to
    perform efficient geo-queries and used the Python framework FastAPI + SQLModel
    to build an efficient API that can be used to interact with the database and serve
    data to the frontend developed in the previous articles.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用了Docker和PostgreSQL+PostGIS构建了一个数据库，使我们能够执行高效的地理查询，并使用Python框架FastAPI + SQLModel构建了一个高效的API，可以用来与数据库交互，并向前端提供数据，这些前端是在之前的文章中开发的。
- en: As of now, we have a Prototype based on “production standard” tools (React,
    PostgreSQL, FastAPI… ) that can run 100% locally. In the final part of this series,
    we will have a look at how to make the application live and automatically update
    our SQL tables to always provide the latest information available.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们有一个基于“生产标准”工具（React、PostgreSQL、FastAPI等）的原型，可以在本地100%运行。在本系列的最后部分，我们将看看如何使应用程序上线并自动更新我们的SQL表，以始终提供最新的信息。
