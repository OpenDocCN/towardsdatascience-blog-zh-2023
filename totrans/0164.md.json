["```py\nimport numpy as np\nimport itertools\n\ndef permut_sign(a):\n    \"\"\"\n    The sign of a permutation is simply the number of inversions.\n    This is a simple, O(n^2) algorithm for finding the inversions. It can\n    be done more efficiently with merge sort in O(n.log(n)) time.\n    \"\"\"\n    cnt = 0\n    for i in range(len(a)):\n        for j in range(i+1, len(a)):\n            if a[i] > a[j]:\n                cnt += 1\n    # Convert the 0-1 into -1 and +1\n    return (cnt % 2 - .5) * -2\n\ndef leibniz_determinant(a):\n    \"\"\"\n    Here, a is the matrix whose determinant we want to calculate.\n    \"\"\"\n    n = len(a)\n    arr = np.arange(n)\n    determinant = 0\n    for perm in itertools.permutations(arr):\n        sign1 = permut_sign(perm)\n        term = 1\n        for i in range(len(perm)):\n            j = int(perm[i])\n            term = term * a[i, j]\n        determinant += sign1 * term\n    return determinant\n\na = np.array([[2, 1, 5],\n              [4, 3, 1],\n              [2, 2, 5]])\n\ndet1 = leibniz_determinant(a)\ndet2 = np.linalg.det(a)\nprint(abs(det1 - det2) <= 0.00001)\n```"]