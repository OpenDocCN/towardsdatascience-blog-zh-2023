["```py\n#normal function\ndef loop_function(a, b):\n    c = np.zeros(a.shape, dtype=np.float32)\n    for i in np.arange(c.shape[0]):\n        if a[i] < b[i]:\n            c[i] = 1.0\n        else:\n            c[i] = 2.0\n    return c, a + b\n\n#the same function implemented with Numba implemented\n@njit\ndef loop_function_numba(a, b):\n    c = np.zeros(a.shape, dtype=np.float32)\n    for i in np.arange(c.shape[0]):\n        if a[i] < b[i]:\n            c[i] = 1.0\n        else:\n            c[i] = 2.0\n    return c, a + b\n```", "```py\n# Example of an input array\nseries1 = np.random.randn(1000000).astype(np.float32)\n\n# Python + NumPy + Numba\n@njit\ndef sum_nums_numba(a, b):\n    return a + b\n```", "```py\n# Example of an input array\nseries1 = randn(MersenneTwister(12), Float32, 1000000);\n\n# Julia\nfunction sum_nums(a::Vector{Float32}, b::Vector{Float32})\n    return a + b\nend\n```", "```py\n# Python + NumPy + Numba\n@njit\ndef loop_function_numba(a, b):\n    c = np.zeros(a.shape, dtype=np.float32)\n    for i in np.arange(c.shape[0]):\n        if a[i] < b[i]:\n            c[i] = 1.0\n        else:\n            c[i] = 2.0\n    return c, a + b\n```", "```py\n# Julia\nfunction loop_function(a::Vector{Float32}, b::Vector{Float32})\n    c::Vector{Float32} = zeros(Float32, size(a))\n    for i = 1:size(c)[1]\n        a[i] < b[i] ? c[i] = 1.0 : c[i] = 2.0\n end\n return c, a + b\nend\n```", "```py\n# Example of an input matrix\nmatrix1 = np.random.randn(100,100).astype(np.float32)\n\n# Python + NumPy + Numba\n@njit\ndef matrix_func(mat_a, mat_b):\n    a = mat_a.T\n    c = np.dot(mat_b,a)\n    d = c.reshape(50,50,4)\n    e = mat_b.reshape(50,4,50)\n    f = d.reshape(200,50)\n    g = e.reshape(50,200)\n    h = np.dot(f,g)\n    i = h.reshape(40000)\n    result = 0.0\n    for j in np.arange(i.shape[0]):\n        result = result + (i[j] - np.sum(i)) / np.sqrt(abs(np.average(i)))\n    return result\n```", "```py\n# Example of an input matrix\nmatrix1 = randn(MersenneTwister(12), Float32, 10000);\nmatrix1 = reshape(matrix1,(100,100));\n\n# Julia\nfunction matrix_func(mat_a, mat_b)\n    a = mat_a'\n    c = mat_b * a\n    d = reshape(c,(50,50,4))\n    e = reshape(mat_b,(50,4,50))\n    f = reshape(d,(200,50))\n    g = reshape(e,(50,200))\n    h = f * g\n    i = reshape(h,40000)\n    result = 0.0\n    for j = 1:size(i)[1]\n        result = result + (i[j] - sum(i)) / sqrt(abs(mean(i)))\n    end\n    return result\nend\n```", "```py\niterations = 10000\ntimeit.timeit(stmt=numba_func, setup=setup, number=iterations)\n```", "```py\n@benchmark sum_nums(rand_array1, rand_array2) samples=10000\n```", "```py\n# Python + NumPy + Numba\n@njit\ndef loop_function_numba(a, b):\n    c = np.zeros(a.shape, dtype=np.float32)\n    for i in np.arange(c.shape[0]):\n        if a[i] < b[i]:\n            c[i] = 1.0\n        else:\n            c[i] = 2.0\n    return c, a + b\n```", "```py\n# parallelised Julia function\nfunction loop_function_para(a::Vector{Float32}, b::Vector{Float32})\n    c::Vector{Float32} = zeros(Float32, size(a))\n    Threads.@threads for i = 1:size(c)[1]\n        a[i] < b[i] ? c[i] = 1.0 : c[i] = 2.0\n end\n return c, a + b\nend\n```", "```py\n@njit(parallel=True)\ndef loop_function_numba_par(a, b):\n    c = np.zeros(a.shape, dtype=np.float32)\n    for i in prange(c.shape[0]):\n        if a[i] < b[i]:\n            c[i] = 1.0\n        else:\n            c[i] = 2.0\n    return c, a + b\n```", "```py\n@njit(parallel=True, fastmath=True)\ndef loop_function_numba_par_fast(a, b):\n    c = np.zeros(a.shape, dtype=np.float32)\n    for i in prange(c.shape[0]):\n        if a[i] < b[i]:\n            c[i] = 1.0\n        else:\n            c[i] = 2.0\n    return c, a + b\n```", "```py\n# the Python code for reference\n@njit\ndef matrix_func(mat_a, mat_b):\n    a = mat_a.T\n    c = np.dot(mat_b,a)\n    d = c.reshape(50,50,4)\n    e = mat_b.reshape(50,4,50)\n    f = d.reshape(200,50)\n    g = e.reshape(50,200)\n    h = np.dot(f,g)\n    i = h.reshape(40000)\n    result = 0.0\n    for j in np.arange(i.shape[0]):\n        result = result + (i[j] - np.sum(i)) / np.sqrt(abs(np.average(i)))\n    return result\n```"]