- en: The Utility of Regular Expressions in Data Science
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/the-utility-of-regular-expressions-in-data-science-babf94285966](https://towardsdatascience.com/the-utility-of-regular-expressions-in-data-science-babf94285966)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An illustration of common applications with Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://thomasdorfer.medium.com/?source=post_page-----babf94285966--------------------------------)[![Thomas
    A Dorfer](../Images/9258a1735cee805f1d9b02e2adf01096.png)](https://thomasdorfer.medium.com/?source=post_page-----babf94285966--------------------------------)[](https://towardsdatascience.com/?source=post_page-----babf94285966--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----babf94285966--------------------------------)
    [Thomas A Dorfer](https://thomasdorfer.medium.com/?source=post_page-----babf94285966--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----babf94285966--------------------------------)
    ·7 min read·Jan 5, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5966cb182cb7e1ef7df827d76ab910c0.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Kevin Ku](https://unsplash.com/@ikukevk) on [Unsplash](https://unsplash.com/photos/w7ZyuGYNpRQ)
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Time and again, data scientists find themselves in a situation where they have
    to determine whether particular fields in their data conform to the required text
    format or whether a particular string is present or absent. In other situations,
    they may have to replace a particular string in their data with another. To achieve
    this, they utilize what has become the norm for these types of problems: **regular
    expressions**.'
  prefs: []
  type: TYPE_NORMAL
- en: This article will briefly cover what regular expressions are, introduce some
    basic characters required to form the corresponding search patterns, illustrate
    some commonly used functions in Python, and lastly go over some practical use
    cases that are frequently encountered in the everyday life of a data scientist.
  prefs: []
  type: TYPE_NORMAL
- en: What Are Regular Expressions?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Regular Expression, or Regex, is a set of characters that enables the search
    and — if desired — the replacement of a specific text pattern. It is an extremely
    convenient technique that data scientists can apply in order to circumvent the
    mundane and cumbersome task of manual search.
  prefs: []
  type: TYPE_NORMAL
- en: In order to define these search patterns, one has to familiarize oneself with
    the corresponding syntax. A comprehensive, yet succinct, cheat sheet for Python-based
    regex syntax is provided by [Dataquest](https://www.dataquest.io/wp-content/uploads/2019/03/python-regular-expressions-cheat-sheet.pdf).
    While this article will not go through all of these use cases, it is still worth
    highlighting some basic characters used to define the search patterns (Table 1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8db7a7ccc22f9d90ac07be15ae8099ce.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Table 1: Basic characters for defining regex search patterns. Figure by Author,
    inspired by [Dataquest](https://www.dataquest.io/wp-content/uploads/2019/03/python-regular-expressions-cheat-sheet.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: Regular Expressions in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python offers a module named [**re**](https://docs.python.org/3/library/re.html)
    which provides an extensive set of regular expression matching operations. Here,
    we will focus on four commonly used module functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Search:** Matches the first instance of an expression.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Find All:** Matches all instances of an expression.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Sub:** Used to replace a string with another.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Split:** Used to split a string based on a specified delimiter.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s illustrate these concepts further by looking at some concrete examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the **search** function only returns the first instance of the
    expression as an *re.Match* object. The **findall** function, on the other hand,
    matches all instances of the expression and returns them in a list. Using the
    **sub** function, one can substitute a particular string for another — in this
    case, *Paris* was replaced by *Rome*. Finally, a string can be broken up by using
    the **split** function and specifying a specific delimiter — in this case, the
    period symbol. Note that we had to use the escape character `\` before the period
    in order to escape its special meaning in a regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: Utility in the Data Sciences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pattern-based searching is a concept that data scientists encounter frequently.
    Let’s go through some of them in order to highlight the utility of having regular
    expressions as a tool in one’s toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: Verify Text Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A pretty common scenario is the analysis of tabular data, whereby the task
    is to check whether the fields in a particular column conform to the desired format.
    Let’s assume we have some contrived data in a file called `sample.csv`, which
    contains the following columns: email address, city, state, and ZIP code (Table
    2).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6f0fefd9957b87db5a92f4ebe0db8d77.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Table 2: Tabular, contrived data containing email and geographical information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we would like to verify that all email addresses are in the format of
    `firstname.lastname@gmail.com`. Utilizing regular expressions, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The **search** function will return `None` if the pattern does not match the
    string input. If we print out these scenarios, we can immediately detect that
    the first and last names of the email address in row 0 are not separated by a
    period and that the email address in row 3 uses Hotmail instead of Gmail.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar way, we can verify whether the ZIP codes in the data conform to
    the standard, 5-digit format.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can see that in row 2, the ZIP code is erroneous as it is only comprised
    of four digits.
  prefs: []
  type: TYPE_NORMAL
- en: The same principle can be applied for a variety of format-specific field entries
    such as dates, URLs, phone numbers, IP addresses, social security numbers, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Detect Obfuscated Words
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Text can be analyzed for certain phrases, words, or obfuscations thereof. For
    instance, spammers tend to obfuscate specific words in the hope of bypassing spam
    filters. An example would be to use *j@ckpot, jackp0t,* or *j@ackp0t* instead
    of *jackpot*. A regular expression can ensure that not only the word of interest
    but also some of its obfuscations are captured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define a set of characters to be matched at a specific position, such
    as `[a@]` at position 1 and `[o0]` at position 5\. As a result, all of our above-mentioned
    obfuscations of the word *jackpot* are being matched.
  prefs: []
  type: TYPE_NORMAL
- en: Correct Formats or Spellings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s assume we have some text data that includes dates in American format,
    i.e. `MM/DD/YYYY`. However, we would like to convert all dates in that corpus
    into the more widely used format of `DD/MM/YYYY`. Again, regular expressions can
    be applied to solve this particular problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We successfully replaced *04/06/2023* with *06/04/2023*. Specifically, we are
    grouping the expressions corresponding to month (group 1), day (group 2), and
    year (group 3), using `( )`. In order to swap month and day, we simply need to
    specify the desired group order in the replacement argument — in our case, `r"\2\1\3"`.
    Note that we are using a raw string notation here to escape the special handling
    of backslashes that would otherwise occur in a string literal not prefixed with
    `r`.
  prefs: []
  type: TYPE_NORMAL
- en: Similar methods can be applied for correcting spellings in a text document,
    such as replacing *gray* with *grey*, or vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Applications in Computational Biology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another field that extensively uses regular expressions is computational biology.
    Proteins are comprised of a string of amino acids, which, after folding into their
    final three-dimensional structure, typically exert a particular function in our
    body. Detecting the presence or absence of certain structural motifs — a short
    amino acid pattern associated with distinct functions — can be critical in gaining
    a better understanding of its eventual functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we have a list of short proteins and we would like to find those
    that contain the following motif: `xC[DA]GG{Y}`. This is biological notation and
    is interpreted as follows: any amino acid (x), followed by Cysteine (C), followed
    by either Aspartic Acid (D) or Alanine (A), followed by two consecutive Glycines
    (G), followed by any amino acid except Tyrosine (Y). Using regular expressions
    in Python, we can detect proteins with this motif as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This approach correctly identifies two proteins that contain the desired motif
    that we were looking for.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen, regular expressions are incredibly useful across a wide variety
    of disciplines, ranging from email spam filters all the way to computational biology.
    This article only demonstrates a few scenarios where regular expressions are commonly
    applied, but the space of applicability is truly vast. While they do have limitations
    and are certainly not a panacea for all text processing problems, regular expressions
    should be considered an essential tool in every data scientist’s toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[1] *Data Science Cheat Sheet*. Dataquest. Retrieved January 4, 2023, from
    [https://www.dataquest.io/wp-content/uploads/2019/03/python-regular-expressions-cheat-sheet.pdf](https://www.dataquest.io/wp-content/uploads/2019/03/python-regular-expressions-cheat-sheet.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] *Regular expression operations*. Python. Retrieved January 4, 2023, from
    [https://docs.python.org/3/library/re.html](https://docs.python.org/3/library/re.html)'
  prefs: []
  type: TYPE_NORMAL
