- en: How to use FILTER in DAX the correct way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/how-to-use-filter-in-dax-the-correct-way-eb621b49527a](https://towardsdatascience.com/how-to-use-filter-in-dax-the-correct-way-eb621b49527a)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The FILTER() function in DAX can be challenging to tame. You can tap into
    some pitfalls, leading to bad performance of your DAX code. Here are some examples
    of how to use FILTER() and how not.*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@salvatorecagliari?source=post_page-----eb621b49527a--------------------------------)[![Salvatore
    Cagliari](../Images/a24b0cefab6e707cfee06cde9e857559.png)](https://medium.com/@salvatorecagliari?source=post_page-----eb621b49527a--------------------------------)[](https://towardsdatascience.com/?source=post_page-----eb621b49527a--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----eb621b49527a--------------------------------)
    [Salvatore Cagliari](https://medium.com/@salvatorecagliari?source=post_page-----eb621b49527a--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----eb621b49527a--------------------------------)
    ·11 min read·Feb 13, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e1e8439b16701f24cc9fe52f0c54ec2a.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Andrea De Santis](https://unsplash.com/@santesson89?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'More than a year ago, I wrote an article about the [FILTER()](https://dax.guide/filter/)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/discover-the-power-of-filter-in-dax-4bfeac3dd786?source=post_page-----eb621b49527a--------------------------------)
    [## Discover the power of FILTER() in DAX'
  prefs: []
  type: TYPE_NORMAL
- en: The FILTER() function in DAX is potent, but it has some intricacies. Let’s dig
    into these details to build a good…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/discover-the-power-of-filter-in-dax-4bfeac3dd786?source=post_page-----eb621b49527a--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: There I explained some details about this powerful function.
  prefs: []
  type: TYPE_NORMAL
- en: What I didn’t do is to explain and show some performance-relevant details of
    FILTER().
  prefs: []
  type: TYPE_NORMAL
- en: If you are new to this function or are unsure how to use it, jump to that article
    to get a basic understanding.
  prefs: []
  type: TYPE_NORMAL
- en: There is some redundancy between my old and this article, but it’s never wrong
    to learn the basics.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, to show you how to use the FILTER() function, I will show you the
    consequences of each variant on the performance and efficiency of each variant.
  prefs: []
  type: TYPE_NORMAL
- en: For this, I will use [DAX Studio](https://daxstudio.org/) and the Server Timings
    in DAX Studio to get performance statistics.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t know this feature in DAX Studio or are unsure about the interpretation
    of the Metrics shown there, read this article, where I dig into this feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/how-to-get-performance-data-from-power-bi-with-dax-studio-b7f11b9dd9f9?source=post_page-----eb621b49527a--------------------------------)
    [## How to get performance data from Power BI with DAX Studio'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes we have a slow Report, and we need to figure out why. We will see
    how to collect performance data and the…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/how-to-get-performance-data-from-power-bi-with-dax-studio-b7f11b9dd9f9?source=post_page-----eb621b49527a--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: The base query
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To define our starting point, I define a base query on my Demo Dataset (See
    the References section for Details):'
  prefs: []
  type: TYPE_NORMAL
- en: 'I want to get a list of Countries and the corresponding Sales, but I want to
    restrict the Brands of the sold Products to these three:'
  prefs: []
  type: TYPE_NORMAL
- en: Contoso
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Northwind Traders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fabrikam
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The base query is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: I will show you how we can alter the line ‘Product’[BrandName] IN ListOfBrands
    and see the consequences of these changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Result looks like this (Snippet):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3d057bfbeb5a98a7ea4d74e090a042d0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1 — Part of the result of the base query (Figure by the Author)
  prefs: []
  type: TYPE_NORMAL
- en: We get 35 rows with all known countries and values for China, Germany, and the
    United States.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Server Timings of the base query are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e4f36006e0520f8139d94717db8bb620.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2 — Server Timing of the base query (Figure by the Author)
  prefs: []
  type: TYPE_NORMAL
- en: The query is executed reasonably quickly with a duration of 0.3 seconds, and
    the efficiency is good as well, as 91.6 % of the time is spent in the Storage
    Engine.
  prefs: []
  type: TYPE_NORMAL
- en: OK, let’s make some modifications and look at the consequences.
  prefs: []
  type: TYPE_NORMAL
- en: The first Variance — Introducing FILTER()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is the first variance of the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This time, I added a filter on the Product table to filter it by the three Brands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the Server Timings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e161f30218fb4ddbdf3846dcc0e16cba.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3 — Server timings of the first variant (Figure by the Author)
  prefs: []
  type: TYPE_NORMAL
- en: The Total execution is almost the same, but the time spent in the Storage Engine
    is more than 100ms longer.
  prefs: []
  type: TYPE_NORMAL
- en: And, instead of three, we have five Storage Engine Queries.
  prefs: []
  type: TYPE_NORMAL
- en: Two of these queries use a CallbackDataID call, meaning that the Storage Engine
    calls the Formula Engine to execute something it cannot do.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, two times the creation of the list of Brands to filter.
  prefs: []
  type: TYPE_NORMAL
- en: DAX Studio marks queries containing a CallbackDataID in bold, as this call is
    unsuitable for performance and efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the first two queries returned over 2’500 rows each. This is called
    materialization.
  prefs: []
  type: TYPE_NORMAL
- en: We should minimize the size of materialization in our DAX expressions.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, 2’517 is the row count of the entire Product table, which means
    that the Formula Engine gets the whole table and needs to filter it afterward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we have a table with hundreds of thousands of rows. This variant
    will load the entire table, which takes:'
  prefs: []
  type: TYPE_NORMAL
- en: · A lot of memory
  prefs: []
  type: TYPE_NORMAL
- en: · A lot of time
  prefs: []
  type: TYPE_NORMAL
- en: OK, using FILTER() in this way is not good at all.
  prefs: []
  type: TYPE_NORMAL
- en: The second variance — FILTER with ALL()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the following variance, we add the [ALL()](https://dax.guide/all/) function
    to the FILTER() call.
  prefs: []
  type: TYPE_NORMAL
- en: The ALL() function removes any Filter on the given table or column and returns
    a table with all values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is still the same, but the Server Timings are radically different
    from the first variance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3c44887a5a2dbd72f13de0c741cbf863.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4 — Server timings of the second variance with ALL() (Figure by the Author)
  prefs: []
  type: TYPE_NORMAL
- en: With this variance, we get almost the same queries and timings as the original
    query without using FILTER().
  prefs: []
  type: TYPE_NORMAL
- en: If we look closely, we discover that the Storage Engine queries are the same
    in both.
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, both queries are equivalent in terms of performance and efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: This is very interesting as it shows the intelligence of the two Engines.
  prefs: []
  type: TYPE_NORMAL
- en: 'The differences are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The base and the second variance replace the filter on the Brand column
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first variance adds a Filter to the Brand column without changing the existing
    filter context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This causes additional queries.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It’s up to you which variance you use. As a lazy person, I prefer to type less
    code to get the same result.
  prefs: []
  type: TYPE_NORMAL
- en: The third variance — Adding VALUES() instead of ALL()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s replace the ALL() function with the [VALUES()](https://dax.guide/values/)
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The VALUES() function with one column returns a table with the source column’s
    distinct values (excluding duplicates).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is still the same: 35 rows with all countries and three values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the Server Timings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a1425af18116324913c4089235b45031.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5 — Server Timings of the third variance with VALUES() (Figure by the
    Author)
  prefs: []
  type: TYPE_NORMAL
- en: Again, we see the same three SE (Storage Engine) queries (Which look the same
    as with the base and the second query) and almost the same duration.
  prefs: []
  type: TYPE_NORMAL
- en: The numbers vary by a minimal amount between executions. But they are very similar
    to the base query.
  prefs: []
  type: TYPE_NORMAL
- en: This shows that using VALUES() is the same as using a simple filter predicate
    or using FILTER() with ALL().
  prefs: []
  type: TYPE_NORMAL
- en: The fourth variance — Adding one more filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to filtering the Brand, I want to filter by the product color as
    well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the numbers in the query result change as we only want to get the
    Red Products Sales.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the Server Timings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/51426980700d7e8e7cb51cb92dfcd9ee.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6 — Server Timings of the fourth variance filtering two columns (Figure
    by the Author)
  prefs: []
  type: TYPE_NORMAL
- en: The result is fascinating.
  prefs: []
  type: TYPE_NORMAL
- en: The query is much faster than before and uses only two SE queries.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the image above, we get one query with one WHERE filtering
    both columns in the Product table.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the SE is very intelligent in combining filters on one table,
    as it eliminates the first query and executes only two instead of three queries.
  prefs: []
  type: TYPE_NORMAL
- en: The fifth variance — Filtering columns from two tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step is to try to filter two columns from two different tables:'
  prefs: []
  type: TYPE_NORMAL
- en: Brand = “Contoso” in the Product table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continent = “Europe” from the Customer table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here is the starting point for this requirement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This doesn’t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d5bc07c6d0323568bf540a95bc82dc8c.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7 — Error when filtering to columns from a different table with FILTER()
    (Figure by the Author)
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason why this cannot function is that the second column is from another
    table that is not part of the Input of the FILTER function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s try it in another way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We use direct filters (predicates) this time without the FILTER() function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This works, and the execution is very fast and efficient:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/87864b168a478b59f45e8c700c4d243e.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8 — Server timings of the fifth variance with direct filters (Figure
    by the Author)
  prefs: []
  type: TYPE_NORMAL
- en: But we want to see something else.
  prefs: []
  type: TYPE_NORMAL
- en: How can we use the FILTER function with columns from separate tables?
  prefs: []
  type: TYPE_NORMAL
- en: The sixth variance — Building a table for FILTER()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We must build an input table for FILTER() from different source tables to achieve
    this.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this purpose, we use [SUMMARIZECOLUMNS()](https://dax.guide/summarizecolumns/)
    to generate a table combining the values from the given columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The SE can interpret this variance to execute only one query to get the result
    (The second query retrieves only the list of the countries):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5a223ba1d4d5eb3c036ee2f7f46b0580.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9 — Server timings and SE query for the sixth variance (Figure by the
    Author)
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the Total execution time is very short.
  prefs: []
  type: TYPE_NORMAL
- en: But, before we conclude, I have one more variance for you.
  prefs: []
  type: TYPE_NORMAL
- en: The seventh variance — Using CROSSJOIN() for FILTER()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last variance uses the [CROSSJOIN()](https://dax.guide/crossjoin/) function.
  prefs: []
  type: TYPE_NORMAL
- en: This function returns a table with the multiplication of each row from the first
    input table with each row from the second table.
  prefs: []
  type: TYPE_NORMAL
- en: Read the article or watch the video in the [DAX Guide](https://dax.guide) article
    linked above for details.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The result still doesn’t change. But the execution pattern is very different:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ea9c0caaf65539136b2e511382e94ce6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10 — Server Timings of seventh variance with CROSSJOIN() (Figure by the
    Author)
  prefs: []
  type: TYPE_NORMAL
- en: Even though the Total execution time isn’t much longer, now we have four SE
    Queries.
  prefs: []
  type: TYPE_NORMAL
- en: But the first two are executed extremely fast.
  prefs: []
  type: TYPE_NORMAL
- en: The first Query retrieves the list of all continents (6 rows), and the second
    retrieves the list of all brands (14 rows).
  prefs: []
  type: TYPE_NORMAL
- en: The third and fourth queries are the same as in the previous variances.
  prefs: []
  type: TYPE_NORMAL
- en: 'But there are more things to consider with this variance:'
  prefs: []
  type: TYPE_NORMAL
- en: The Cross-Join is done by the Formula Engine (FE). This isn’t a problem with
    such a small number of values. But when you have hundreds or thousands of values,
    this will take a tremendous amount of time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This variance generates a table with two columns (Brands and Continents) with
    all possible combinations. This table is filtered with two Predicates (Brand =
    “Contoso” and Continent = “Europe”). Finally, the generated table is applied as
    Filter to the CALCULATE() function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You must use the ALL() function in order to use the CROSSJOIN() function. Without
    the ALL function, you will get an error. As an alternative, use the VALUES() function,
    which leads to the same result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This variance requires much writing without any benefit, as the SE queries are
    the same as in the two variances shown above. But when you need to construct an
    input table for FILTER() in this specific way, now you know it is possible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../Images/51fb3e2b8cefedb2439a062b7845cc34.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Afif Ramdhasuma](https://unsplash.com/ko/@javaistan?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have seen, there are a lot of possible variances for using the FILTER
    function in DAX.
  prefs: []
  type: TYPE_NORMAL
- en: But take care. What appeared to be very quick in my example can be very different
    in your scenario, as you might have another situation with your data.
  prefs: []
  type: TYPE_NORMAL
- en: The more distinct values you have in the columns you need to filter, the more
    you need to pay attention to how you use FILTER().
  prefs: []
  type: TYPE_NORMAL
- en: In my opinion, the direct filter approach is the first and most efficient method
    as it requires the least effort and typing. In most cases, it works right.
  prefs: []
  type: TYPE_NORMAL
- en: So, don’t overwork or overthink your Measures, as the most uncomplicated and
    straightforward approach might be the correct one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Read this if you want to learn more about this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/codex/dont-start-with-optimized-code-it-may-not-be-a-good-idea-2e9c6afa85a1?source=post_page-----eb621b49527a--------------------------------)
    [## Don’t start with optimized code. It may not be a good idea'
  prefs: []
  type: TYPE_NORMAL
- en: The title of this article seems counterintuitive. Why should you not develop
    your solution with the most optimized…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/codex/dont-start-with-optimized-code-it-may-not-be-a-good-idea-2e9c6afa85a1?source=post_page-----eb621b49527a--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I use the Contoso sample dataset, like in my previous articles. You can download
    the ContosoRetailDW Dataset for free from Microsoft [here](https://www.microsoft.com/en-us/download/details.aspx?id=18279).
  prefs: []
  type: TYPE_NORMAL
- en: The Contoso Data can be freely used under the MIT License, as described [here](https://github.com/microsoft/Power-BI-Embedded-Contoso-Sales-Demo).
  prefs: []
  type: TYPE_NORMAL
- en: I enlarged the dataset to make the DAX engine work harder.
  prefs: []
  type: TYPE_NORMAL
- en: The Online Sales table contains 71 million rows (instead of 12.6 million rows),
    and the Retail Sales table contains 18.5 million rows (instead of 3.4 million
    rows).
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/@salvatorecagliari/membership?source=post_page-----eb621b49527a--------------------------------)
    [## Join Medium with my referral link - Salvatore Cagliari'
  prefs: []
  type: TYPE_NORMAL
- en: Read every story from Salvatore Cagliari (and thousands of other writers on
    Medium). Your membership fee directly…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/@salvatorecagliari/membership?source=post_page-----eb621b49527a--------------------------------)
  prefs: []
  type: TYPE_NORMAL
