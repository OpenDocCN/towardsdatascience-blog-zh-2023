- en: 'Comparing List Comprehensions vs. Built-In Functions in Python: Which Is Better?'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/comparing-list-comprehensions-vs-built-in-functions-in-python-which-is-better-1e2c9646fafe](https://towardsdatascience.com/comparing-list-comprehensions-vs-built-in-functions-in-python-which-is-better-1e2c9646fafe)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An in-depth analysis of syntax, readability, and performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://thomasdorfer.medium.com/?source=post_page-----1e2c9646fafe--------------------------------)[![Thomas
    A Dorfer](../Images/9258a1735cee805f1d9b02e2adf01096.png)](https://thomasdorfer.medium.com/?source=post_page-----1e2c9646fafe--------------------------------)[](https://towardsdatascience.com/?source=post_page-----1e2c9646fafe--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----1e2c9646fafe--------------------------------)
    [Thomas A Dorfer](https://thomasdorfer.medium.com/?source=post_page-----1e2c9646fafe--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----1e2c9646fafe--------------------------------)
    ·9 min read·Mar 21, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/24a86e8397f03f62c53d4cf68e844fb2.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by the Author.
  prefs: []
  type: TYPE_NORMAL
- en: Have you ever found yourself scrolling through Netflix on a rainy day, feeling
    overwhelmed by the endless choices of movies and shows to watch?
  prefs: []
  type: TYPE_NORMAL
- en: In programming, the paradox of choice can be just as overwhelming. With so many
    libraries and frameworks available, providing countless different ways of achieving
    the same goal, it’s easy to get lost in a sea of options.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, this situation often arises when a programmer needs to choose between
    a **functional programming** approach, such as the built-in functions `map()`,
    `filter()`, and `reduce()`, and the more Pythonic **list comprehensions**.
  prefs: []
  type: TYPE_NORMAL
- en: In this article, we’ll explore the pros and cons of these distinct approaches
    through the lens of syntax, readability, and performance.
  prefs: []
  type: TYPE_NORMAL
- en: List Comprehensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Python, a list comprehension is a concise method that produces a list based
    on an already existing list. In simple terms, it’s essentially a one-liner of
    a **for loop** with the option to include an **if condition** at the end. The
    syntax can be broken down as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1580b25f72c556932fc1111478f01d23.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by the Author.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume we have a list of numbers, called `numbers`, from which we’d like
    to take the even ones and square them. Now the boring, old school way would be
    to do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'With a list comprehension, however, we can do this in a single line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Either way produces the same result, but the list comprehension provides a
    much clearer and more readable solution as its syntax is literally: *“****Do this***
    *for* ***each value*** *in* ***this list*** *if* ***this condition*** *is met”*.'
  prefs: []
  type: TYPE_NORMAL
- en: Generally, list comprehensions are also faster than regular for loops as they
    don’t have to look up the list and call its `append` method on every iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a pretty good understanding of list comprehensions, let’s move
    on to see how they fare compared to some of the commonly used, built-in functions
    such as `map()`, `filter()`, and `reduce()`. This is the paradox-of-choice part
    I was referring to earlier. Programmers tend to be aware that these various methods
    exist, but which one to choose?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go through each built-in function at a time and compare them to their
    Pythonic counterpart: the list comprehension.'
  prefs: []
  type: TYPE_NORMAL
- en: Map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If your goal is to apply a transformation function to each item in an iterable
    (such as a list), the `map()` function is a good place to start. The syntax is
    quite straightforward and only requires two input arguments: (1) a transformation
    function, and (2) an iterable (i.e. your input list).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we have a list of numbers corresponding to Euros and we’d like to
    convert them to US Dollars. This can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we have to explicitly specify the `list()` function here, since
    `map()` natively returns an iterator — a map object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also note that `map()`allows you to use these anonymous, ad-hoc [lambda functions](/how-to-effectively-use-lambda-functions-in-python-as-a-data-scientist-fd6171554053)
    that allow you to define a function on the fly. If you’d like to learn more about
    lambdas, their syntax, and how to use them, you can take a look at the following
    article:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/how-to-effectively-use-lambda-functions-in-python-as-a-data-scientist-fd6171554053?source=post_page-----1e2c9646fafe--------------------------------)
    [## How to Effectively Use Lambda Functions in Python as a Data Scientist'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to their syntax, capabilities, and applicability in data science
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/how-to-effectively-use-lambda-functions-in-python-as-a-data-scientist-fd6171554053?source=post_page-----1e2c9646fafe--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Comparison with List Comprehension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may have noticed by now that the exact same task could be done with a list
    comprehension as well. So let’s see how they compare with respect to readability
    and performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we will look at three scenarios: (1) list comprehensions, (2)
    `map()` with a predefined input function, and (3) `map()`with an ad-hoc lambda
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In terms of simplicity and readability, the list comprehension appears to be
    winning the race here. The programmer’s intention is immediately apparent and
    there’s no need to include any extra keywords or define additional functions.
    However, it’s worth noting that for more complex operations, separate transformation
    functions may need to be defined, which would take away some of the brownie points
    that list comprehensions generally receive for their readability.
  prefs: []
  type: TYPE_NORMAL
- en: With respect to performance, the example above clearly demonstrates that list
    comprehensions are fastest, followed by `map()` with a predefined input function,
    and lastly `map()` with a lambda function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the thing about using an ad-hoc lambda function: it gets called for
    each item in the input list, resulting in a computational overhead due to the
    creation and destruction of lambda function objects, ultimately leading to degraded
    performance. Predefined functions, by contrast, are optimized and stored in memory,
    which leads to more efficient execution.'
  prefs: []
  type: TYPE_NORMAL
- en: Bottom Line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: List comprehensions clearly have the upper hand over `map()` when it comes to
    performance. In addition, their syntax is easy to read, typically perceived as
    more intuitive, and considered more Pythonic than the one of `map()`, which was
    derived from functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: Filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `filter()` function allows you to select a subset of your iterable based
    on a given condition. Similar to `map()`, it requires two input arguments: (1)
    a filter function, which is often a [lambda function](/how-to-effectively-use-lambda-functions-in-python-as-a-data-scientist-fd6171554053),
    and (2) an iterable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example is given below, where we filter out all odd numbers and only keep
    the even ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Again, similar to `map()`, we have to explicitly state that we want a list returned,
    because `filter()` natively returns an iterator object.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison with List Comprehension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s take a look at the performance difference between the built-in `filter()`
    function, again using both a predefined input function and a lambda, and a list
    comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In terms of readability, the same can be said as above for `map()`: list comprehensions
    are pretty easy to read and don’t require any predefined or ad-hoc functions or
    extra keywords. However, it has been argued that the use of the function `filter()`
    immediately gives away the programmer’s intent of, well, filtering something,
    perhaps more so than the list comprehension does. This is of course a highly subjective
    matter and will depend on the individual’s preferences and tastes.'
  prefs: []
  type: TYPE_NORMAL
- en: Regarding performance, we’re also seeing similar results to the ones obtained
    for `map()`. List comprehensions are fastest, followed by `filter()` with a predefined
    filter function, and `filter()` with an ad-hoc lambda function comes in last.
    Again, this is due to the overhead incurred by lambda functions requiring the
    creation of a new function object at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Bottom Line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: List comprehensions outperform their functional `filter()`counterpart — by nearly
    a factor of 2 — and are typically perceived to be more Pythonic as well. Readability,
    however, is a bit more subjective with this one. While some people prefer the
    intuitive and Pythonic way of list comprehensions, others prefer using the `filter()`
    function as it clearly conveys its functionality and the intention of the programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Reduce
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, let’s take a look at `reduce()`. This build-in function is often used
    in situations that require the accumulation of a single result over multiple steps.
    It also takes two input arguments: (1) a reduce function, and (2) an iterable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example to make its functionality more clear. In this case,
    we would like to compute the product of a list of integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we use a lambda to define our reduce function, which in this case is
    a simple, rolling multiplication over our list of integers. This results in the
    following computation being performed: 1 x 2 x 3 x 4 x 5 = 120.'
  prefs: []
  type: TYPE_NORMAL
- en: Comparison with List Comprehension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Achieving the same goal with a list comprehension is a little trickier this
    time and requires some additional steps, such as the initialization of a variable
    and the use of the [walrus operator](https://docs.python.org/3/whatsnew/3.8.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: While it’s still possible to obtain the same result with a list comprehension,
    these additional steps considerably degrade the readability of our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, there are multiple, low-code alternatives now to both methods,
    such as `math.prod()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Performance-wise, however, there doesn’t seem to be a major difference between
    the two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Bottom Line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Python, the use of `reduce()` for rolling computations to value pairs in
    lists has been slowly declining over the years, mainly due to more efficient and
    intuitive alternatives such as `math.prod()`. Both `reduce()` and list comprehensions
    do not exactly provide a clear-cut syntax here that would provide the reader with
    an easy and quick understanding of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'PS: If you are still a frequent user of `reduce()`, I’d love to hear about
    your use cases in the comments!'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While not as prevalent as in other languages, `map()`, `filter()`, and — occasionally
    — `reduce()` are still used and found in Python-based applications. However, list
    comprehensions tend to be seen as more Pythonic due to their more intuitive syntax
    and can, in most situations, replace `map()` and `filter()` functions, while also
    benefiting from a marked performance boost.
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, the nature of the `reduce()` function makes it hard and more cryptic
    to be replaced by list comprehensions. However, they can be replaced by low-code
    alternatives such as the `math.prod()` function, as we have seen above.
  prefs: []
  type: TYPE_NORMAL
- en: Liked this article?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s connect! You can find me on [Twitter](https://twitter.com/ThomasADorfer)
    and [LinkedIn](https://www.linkedin.com/in/thomasdorfer/).
  prefs: []
  type: TYPE_NORMAL
- en: If you like to support my writing, you can do so through a [Medium Membership](https://thomasdorfer.medium.com/membership),
    which provides you access to all my stories as well as those of thousands of other
    writers on Medium.
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/@thomasdorfer/membership?source=post_page-----1e2c9646fafe--------------------------------)
    [## Join Medium with my referral link — Thomas A Dorfer'
  prefs: []
  type: TYPE_NORMAL
- en: Read every story from Thomas A Dorfer (and thousands of other writers on Medium).
    Your membership fee directly supports…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/@thomasdorfer/membership?source=post_page-----1e2c9646fafe--------------------------------)
  prefs: []
  type: TYPE_NORMAL
