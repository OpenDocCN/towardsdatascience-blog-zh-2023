- en: Protocols in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/protocols-in-python-110943832d98](https://towardsdatascience.com/protocols-in-python-110943832d98)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How to use structural subtyping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@hrmnmichaels?source=post_page-----110943832d98--------------------------------)[![Oliver
    S](../Images/b5ee0fa2d5fb115f62e2e9dfcb92afdd.png)](https://medium.com/@hrmnmichaels?source=post_page-----110943832d98--------------------------------)[](https://towardsdatascience.com/?source=post_page-----110943832d98--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----110943832d98--------------------------------)
    [Oliver S](https://medium.com/@hrmnmichaels?source=post_page-----110943832d98--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----110943832d98--------------------------------)
    ·5 min read·Jul 27, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: 'Python 3.8 introduced a neat new feature: [protocols](https://peps.python.org/pep-0544/).
    Protocols are an alternative to [abstract base classes (ABC)](https://docs.python.org/3/library/abc.html),
    and allow structural subtyping — checking whether two classes are compatible based
    on available attributes and functions alone. In this post we’ll go into the details
    about this and show how to use protocols using practical examples.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/90dd020181af078f64485fe5957a0b41.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Chris Liverani](https://unsplash.com/@chrisliverani?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
    on [Unsplash](https://unsplash.com/photos/9cd8qOgeNIY?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
  prefs: []
  type: TYPE_NORMAL
- en: Typing in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us begin by discussing how Python is typed. It is a dynamically typed language,
    meaning types are inferred at runtime and the following code runs without problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The first call results in an integer addition returning 5, the second in a
    string concatenation returning “str1str2”. This is different to e.g. C++, which
    is statically typed — and we have to provide type declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Static typing offers the advantage of having the potential to catching errors
    at compile time — whereas in dynamically typed languages we only encounter these
    during runtime. On the other hand, dynamic typing can allow quicker prototyping
    and experimentation — one reason why Python has become so popular.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dynamic typing is also called [duck typing](https://en.wikipedia.org/wiki/Duck_typing),
    based on the saying: “if it walks like a duck and it quacks like a duck, then
    it must be a duck”. Ergo: if objects offer the same attributes / functions, they
    should be treated similarly, and e.g. can be passed to functions requiring the
    other type.'
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, especially in larger, more professional software products, this
    unreliability offers more down- than upsides — and the trend thus goes towards
    static type checking, e.g. via [providing type hints with mypy](https://medium.com/towards-data-science/introduction-to-mypy-3d32fc96db75).
  prefs: []
  type: TYPE_NORMAL
- en: '**Subtyping**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One interesting issue — hinted above e.g. in the short paragraph about duck
    typing — is subtyping. If we have a function with signature `foo(x: X)`, what
    other classes except `X` does mypy allow to be passed to the function? (Note we
    now only question typing and type hints — since Python is dynamically typed, as
    discussed before, we can pass any object to `foo` — and if the expected attributes
    / methods are there, it works, and crashes otherwise.) For this, one distinguishes
    structural and nominal subtyping. Structural subtyping is based on class hierarchy
    / inheritance: if class `B` inherits from `A`, it is a subtype of `A` — and thus
    can also be used everywhere where `A` is expected. On the other hand, nominal
    subtyping is defined based on operations available for the given class — if `B`
    offers all attributes / functions provided by `A`, it can be used in all places
    where `A` is expected. One can argue, that the latter method is more “Pythonic”,
    as it more resembles the idea of duck typing.'
  prefs: []
  type: TYPE_NORMAL
- en: Subtyping in Practise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before Python 3.8, one could only use inheritance for subtyping, and e.g. use
    (abstract) base classes (ABCs): here, we define an (abstract) base class — a “blue
    print” for child classes — and then define several child classes inheriting from
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we first define the ABC `Animal`, providing the abstract method
    `feed`. Then, we subclass `Duck` and implement this method. Lastly we define a
    generic `feed` function, accepting an `Animal` as parameter, and then feed this
    animal.
  prefs: []
  type: TYPE_NORMAL
- en: 'This seems legit — where is the problem? Indeed there are a few reasons, why
    one might not want to use this pattern: base classes are often poorly exposed
    and hard to include — i.e. if you want to inherit from a base class in another
    module, maybe a public library, you would have to find the base class. Second,
    you cannot change existing code e.g. in public / third party modules: this is
    a problem if you would like types imported from those to be subtypes of others,
    possibly in combination with other types introduced by you. And lastly, this somewhat
    goes against the idea of Python and duck typing.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Protocols**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Thus, Python 3.8 introduced protocols, alleviating aforementioned issues. Protocols,
    as the name suggests, work implicitly by defining an “interface” of expected attributes
    / methods, and checking whether the classes in question provide these, if necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, `Animal` now is a `Protocol`, and `Duck` does not inherit from
    any base class — still mypy is happy.
  prefs: []
  type: TYPE_NORMAL
- en: '**Subclassing Protocols**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Naturally, we can also subclass protocols — i.e. defining a child protocol
    inheriting from a parent one, extending this. When doing so, we just need to remember
    to inherit both from the parent protocol, as well as `typing.Protocol`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, we specify `Bird` as a specific `Animal` type, and then define
    a function to feed a bird, expecting it to fly away afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: A Short History of Protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All code written above is valid Python, even before Python 3.8 (remember, Python
    is dynamically typed) — we only needed ABCs to satisfy mypy, and it would have
    complained for the latter examples without ABCs. Nevertheless, protocols have
    been around in Python for much longer, just not as visible or explicit as now:
    most Python developers used the term “protocol” as an agreement to conform to
    certain interfaces, just as was made explicit now. One famous example is the [iterator
    protocol](https://www.pythonmorsels.com/iterator-protocol/#:~:text=The%20iterator%20protocol%20is%20how,it%20evaluates%20a%20for%20loop.)
    — an interface describing which methods a [custom iterator](https://medium.com/gitconnected/iterators-in-python-bd7332ddbc00)
    needs to implement. To make this work with mypy without explicit protocols, several
    “tricks” existed, such as custom typing types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Abstract Base Classes vs Protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already discussed possible drawbacks of ABCs (difficulty with external modules
    and interfaces, “unpythonic” code). However, protocols should not replace ABCs,
    but instead both be used. ABCs e.g. are a good way of re-using code: all common
    functionality should be implemented in the base class, and only specific bits
    in the child classes. This is not possible with protocols.'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this post we discussed static vs dynamic typing (duck typing), and how mypy
    handles subtyping. Before Python 3.8, abstract base classes (ABCs) had to be used.
    With the introduction of protocols, Python obtained an elegant way of defining
    “interfaces” and allowing mypy to check adherence to these: in a more Pythonic
    style, protocols allow specifying which attributes / functions classes need to
    implement, and then allowing the usage of all such classes as subtypes of the
    protocol.'
  prefs: []
  type: TYPE_NORMAL
