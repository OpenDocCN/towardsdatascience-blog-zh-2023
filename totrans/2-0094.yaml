- en: These 5 SQL Techniques Cover ~80% of Real-Life Projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/5-advanced-sql-techniques-for-real-life-projects-f2db9b6680e2](https://towardsdatascience.com/5-advanced-sql-techniques-for-real-life-projects-f2db9b6680e2)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Speed up your SQL learning curve
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://thuwarakesh.medium.com/?source=post_page-----f2db9b6680e2--------------------------------)[![Thuwarakesh
    Murallie](../Images/44f1a14a899426592bbd8c7f73ce169d.png)](https://thuwarakesh.medium.com/?source=post_page-----f2db9b6680e2--------------------------------)[](https://towardsdatascience.com/?source=post_page-----f2db9b6680e2--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----f2db9b6680e2--------------------------------)
    [Thuwarakesh Murallie](https://thuwarakesh.medium.com/?source=post_page-----f2db9b6680e2--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----f2db9b6680e2--------------------------------)
    ·8 min read·Mar 8, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9fa3d4a6f9a1bcd3cf96e5b4e65cbdf3.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Possessed Photography](https://unsplash.com/es/@possessedphotography?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Are you curious about SQL but hesitant to dive in? Or maybe you’re already familiar
    with the basics of SQL but struggle to apply it to real-life projects.
  prefs: []
  type: TYPE_NORMAL
- en: I know the feeling.
  prefs: []
  type: TYPE_NORMAL
- en: When I first started learning SQL, I was intimidated by the vast amount of information.
    And even today, I still constantly learn and explore new techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Sure, the basics of SQL, like joins, subqueries, filtering, and ordering, are
    easy to pick up. But you need advanced techniques for complex real-world problems.
  prefs: []
  type: TYPE_NORMAL
- en: In this post, I want to share the five advanced SQL techniques I use the most
    in my everyday work. By mastering these techniques, you’ll be able to accomplish
    almost 80% of production-grade SQL queries, making you a valuable asset to any
    data-driven projects.
  prefs: []
  type: TYPE_NORMAL
- en: '[](/fast-load-data-to-sql-from-python-2d67aea946c0?source=post_page-----f2db9b6680e2--------------------------------)
    [## Python To SQL — I Can Now Load Data 20X Faster'
  prefs: []
  type: TYPE_NORMAL
- en: The good, bad, and ugly ways of uploading large batches of data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/fast-load-data-to-sql-from-python-2d67aea946c0?source=post_page-----f2db9b6680e2--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: I have intentionally not included some other frequently used techniques, such
    as transactions. This list of methods will be very helpful if you’re in an analytical
    role than a software engineer role.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the post, I assumed we were in a Postgres database. But every major
    relational database nowadays offers similar functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Window functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A window function is an analytic function that performs calculations across
    a set of rows related to the current row. The result of a window function is returned
    alongside the original rows in the result set without changing the underlying
    data.
  prefs: []
  type: TYPE_NORMAL
- en: '[](/junior-developers-write-multi-page-sql-queries-seniors-use-window-functions-f82dfeb8e378?source=post_page-----f2db9b6680e2--------------------------------)
    [## Junior Developers Write Multi-Page SQL Queries; Seniors Use Window Functions'
  prefs: []
  type: TYPE_NORMAL
- en: An elegant way to perform computation within the context of a record
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/junior-developers-write-multi-page-sql-queries-seniors-use-window-functions-f82dfeb8e378?source=post_page-----f2db9b6680e2--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: A real-life example of a window function might be calculating the running total
    of sales revenue for a particular product over time. This could be useful for
    identifying trends in sales, such as which products are most popular at certain
    times of the year.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how to use the `SUM` window function to calculate the
    running total of sales revenue for a specific product over time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `SUM` window function is used to calculate the running
    total of `revenue` for a particular `product_id` over time. The `PARTITION BY`
    clause groups the data by `product_id`, and the `ORDER BY` clause sorts the data
    by `date`. The `running_total` column contains the result of the `SUM` window
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why not use** `**group by**`**?**'
  prefs: []
  type: TYPE_NORMAL
- en: This confused me when I first started using window functions.
  prefs: []
  type: TYPE_NORMAL
- en: Yes, you can use `GROUP BY` to aggregate data in PostgreSQL. Yet, using `GROUP
    BY` would provide a different result than a window function.
  prefs: []
  type: TYPE_NORMAL
- en: In the example of calculating the running total of sales revenue for a specific
    product over time, using `GROUP BY` would group the sales data by `product_id`
    and `date`, and then calculate the sum of income for each group. This would give
    you the total revenue for each day rather than the running total of revenue over
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of using `GROUP BY` to aggregate sales data by `product_id`
    and `date`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[Learn more about SQL window functions](https://mode.com/sql-tutorial/sql-window-functions/)'
  prefs: []
  type: TYPE_NORMAL
- en: '2\. CTE: Common table expression'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A CTE is a temporary named result set you can reference within a single SQL
    statement. It defines a subquery that can be referenced multiple times within
    a gigantic query, thus simplifying complex queries.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take an example to understand this better. Suppose you have a table that
    contains all the customer orders. You want to find the sales by product for top-performing
    regions.
  prefs: []
  type: TYPE_NORMAL
- en: Without a CTE, you must write a complex query involving subqueries, joins, and
    aggregation functions. This could make the query challenging to read and understand.
    However, by using a CTE, you can simplify the query and make it more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a classic example to understand the usefulness of CTEs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the above query, we use two CTE to calculate the top-selling products in
    the top-performing regions.
  prefs: []
  type: TYPE_NORMAL
- en: The first CTE, `regional_sales`, calculates the total sales for each region
    by summing the `amount` column of the `orders` table and grouping the results
    by `region`.
  prefs: []
  type: TYPE_NORMAL
- en: The second CTE, `top_regions`, selects only the regions whose total sales are
    greater than 10% of the total sales across all regions. This is done using a subquery
    that calculates the total sales across all regions and divides it by 10.
  prefs: []
  type: TYPE_NORMAL
- en: The main query then joins the `orders` table with the `top_regions` CTE using
    an `IN` clause to filter the results to only include orders from the top-performing
    regions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the rewritten query without using a CTE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: A CTE can simplify complex queries and make them more readable. It makes reusing
    the same subquery multiple times within a larger query easier.
  prefs: []
  type: TYPE_NORMAL
- en: '[Learn more about CTEs](https://learnsql.com/blog/what-is-common-table-expression/)'
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Recursive query
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Have you ever wanted to retrieve data from a database where the data is stored
    in a hierarchical or tree-like structure?
  prefs: []
  type: TYPE_NORMAL
- en: For instance, you may have a product category tree where each category has subcategories,
    and each subcategory can have further subcategories. In such cases, a recursive
    query can be handy.
  prefs: []
  type: TYPE_NORMAL
- en: A recursive query is a query that references itself in the definition. It’s
    useful when traversing a tree or a hierarchical structure in the database and
    retrieving all the related data. In other words, it enables you to select data
    from a table that depends on data from the same table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a recursive query that can be used to traverse a category
    tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We use a CTE with the `WITH` clause to define the recursive query in this example.
    The `RECURSIVE` keyword tells Postgres that it’s a recursive query.
  prefs: []
  type: TYPE_NORMAL
- en: The `category_tree` CTE is defined by two SELECT statements. The first SELECT
    statement selects the root nodes of the category tree (nodes with no parent),
    and the second SELECT statement selects the child nodes recursively. The `UNION
    ALL` operator combines the results of both SELECT statements.
  prefs: []
  type: TYPE_NORMAL
- en: The `depth` column is used to keep track of the depth of each category node
    in the tree. The `path` column is an array that stores the path from the root
    to the current node.
  prefs: []
  type: TYPE_NORMAL
- en: With this query, we can retrieve all the categories in the tree with their respective
    depths and paths.
  prefs: []
  type: TYPE_NORMAL
- en: '[Learn more about Recursive queries](https://learnsql.com/blog/sql-recursive-cte/)'
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Dynamic SQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’ve ever worked with SQL queries, you might have encountered some that
    are pretty complex and need to be generated at run time. Writing such queries
    can be daunting, and executing them can be even more challenging.
  prefs: []
  type: TYPE_NORMAL
- en: In the past, I used to rely on Python to generate complex SQL queries and execute
    them using a database connector such as psycopg2\. This approach was effective
    but not very elegant.
  prefs: []
  type: TYPE_NORMAL
- en: However, I recently discovered dynamic SQL in Postgres, making generating and
    executing complex queries much more manageable. With dynamic SQL, you can dynamically
    create queries based on runtime conditions, which is incredibly useful when dealing
    with complex data structures or business logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you want to retrieve all orders placed on a specific date. In a static
    query, you might write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'But what if you allow the user to select a date range? With dynamic SQL, you
    can generate the query based on user input like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we’ve created a function that takes two parameters, `start_date`
    and `end_date`, and returns a table of orders that fall within that date range.
    The `EXECUTE` statement allows us to generate the query based on the input parameters
    dynamically, and the `USING` clause specifies the values for the query.
  prefs: []
  type: TYPE_NORMAL
- en: This example is rudimentary. But in large-scale projects, you’d need lots of
    SQL generated dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: '[Learn more about Dynamic SQL](https://www.postgresql.org/docs/current/ecpg-dynamic.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Cursors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our queries may run on constrained environments. Running an intensive operation
    on a vast table all at once may not always be preferable. Or we may need more
    control over the operation than applying it to a full table.
  prefs: []
  type: TYPE_NORMAL
- en: This is where cursors come in handy. Cursors allow you to retrieve and manipulate
    data from a result set one row at a time. You can use cursors to iterate through
    a data set and perform complex operations on each row.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you have a table called “products” that contains information about all
    products, including the product ID, product name, and current inventory. You can
    use a cursor to iterate through all orders that contain a specific product and
    update its inventory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we first declare a cursor called “cur_orders” that selects
    all order details that contain a specific product ID. We then define a variable
    called “product_inventory” to store the current inventory of the product.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the loop, we fetch each order ID, product ID, and quantity from the cursor,
    subtract the quantity from the current inventory and update the products table
    with the new inventory value.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we close the cursor and do something after updating the inventory,
    such as logging the changes.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In conclusion, SQL is a powerful language that offers many techniques to work
    with complex data. But learning them all might intimidate you at first.
  prefs: []
  type: TYPE_NORMAL
- en: This blog post explored five of the most commonly used advanced SQL techniques,
    including CTE, Window function, Recursive queries, dynamic queries, and cursors.
    While basic SQL concepts such as joins and subqueries are fundamental to working
    with data, these techniques will help you work on almost any SQL project.
  prefs: []
  type: TYPE_NORMAL
- en: While this post provides an overview of the advanced SQL techniques, it is not
    intended to be an exhaustive discussion of each technique. However, relevant links
    have been provided for those who wish to explore these concepts further. In the
    future, I plan to delve deeper into each of these techniques individually, providing
    a more comprehensive understanding of their capabilities and potential applications.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks for reading, friend! If you enjoyed my article, let’s keep in touch on
    [**LinkedIn**](https://www.linkedin.com/in/thuwarakesh/), [**Twitter**](https://twitter.com/Thuwarakesh),
    and [**Medium**](https://thuwarakesh.medium.com/).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Not a Medium member yet? Please use this link to [**become a member**](https://thuwarakesh.medium.com/membership)
    because, at no extra cost for you, I earn a small commission for referring you.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
