- en: Introduction to mypy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/introduction-to-mypy-3d32fc96db75](https://towardsdatascience.com/introduction-to-mypy-3d32fc96db75)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Static type checking for Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@hrmnmichaels?source=post_page-----3d32fc96db75--------------------------------)[![Oliver
    S](../Images/b5ee0fa2d5fb115f62e2e9dfcb92afdd.png)](https://medium.com/@hrmnmichaels?source=post_page-----3d32fc96db75--------------------------------)[](https://towardsdatascience.com/?source=post_page-----3d32fc96db75--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----3d32fc96db75--------------------------------)
    [Oliver S](https://medium.com/@hrmnmichaels?source=post_page-----3d32fc96db75--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----3d32fc96db75--------------------------------)
    ·8 min read·Apr 6, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1256da4cc8ec98ef8ebafde56c0e759c.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Agence Olloweb](https://unsplash.com/@olloweb?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
    on [Unsplash](https://unsplash.com/photos/d9ILr-dbEdg?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
  prefs: []
  type: TYPE_NORMAL
- en: We mentioned mypy as a must-have in a previous post about [Python best practices](https://medium.com/towards-data-science/best-practices-for-python-development-bf74c2880f87)
    — here, we want to introduce it with more details.
  prefs: []
  type: TYPE_NORMAL
- en: '[mypy](https://mypy.readthedocs.io/en/stable/), as the docs explain, is a “static
    type checker for Python”. This means, it adds type annotations and checks to the
    language Python, which is dynamically typed by design (types are inferred at runtime,
    as opposed to, e.g. C++). Doing so lets you find bugs in your code during compile-time,
    which is a great help — and a must for any semi-professional Python project, as
    explained in my previous post.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this post we will introduce mypy using several examples. Disclaimer: this
    post won’t introduce every mypy feature (not even near it). Instead, I’ll try
    to find a good balance between sufficient details to let you write nearly all
    the code you want — and generating a steep learning curve from zero to solid mypy
    understanding. For more details, I’d like to refer to the official docs or any
    other great tutorial out there.'
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To install mypy, simply run: `pip install mypy`'
  prefs: []
  type: TYPE_NORMAL
- en: However, I would recommend to use some form of dependency management system,
    such as [poetry](https://medium.com/towards-data-science/dependency-management-with-poetry-f1d598591161).
    How to include this and mypy in a larger software project, is explained [here](https://medium.com/towards-data-science/best-practices-for-python-development-bf74c2880f87).
  prefs: []
  type: TYPE_NORMAL
- en: First Steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s motivate the usage of mypy with a first example. Consider the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`multiply` expects two numbers and returns their product. Thus, `multiply(3,
    10)` works well and returns the desired result. But the second statement fails
    and crashes the execution, as we can’t multiply strings. Due to Python being dynamically
    typed, nothing stopped us from coding / executing that statement, and we only
    found the issue at run time — which is problematic.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, mypy comes to the rescue. We can now annotate the arguments, and also
    the return type of the function, as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This annotation won’t change the execution in anyway, in particular, you can
    still run this faulty program. However, before doing so and shipping our program,
    we can now run mypy and check for any possible errors via: `mypy .`'
  prefs: []
  type: TYPE_NORMAL
- en: Running this command will fail, and correctly point out that we can’t pass strings
    to `multiply`. Above command is meant to be executed from the main folder of the
    application, `.` will check every file in the current folder and subdirectories.
    But you can also check specific files via `mypy file_to_check.py`.
  prefs: []
  type: TYPE_NORMAL
- en: This hopefully motivated the need and usage of mypy, now let’s dive deeper.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring mypy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: mypy can be configured in many different ways — without going into details,
    it just needs to find one config file (such as mypy.ini, [pyproject.toml](https://medium.com/towards-data-science/dependency-management-with-poetry-f1d598591161),
    …) with a “mypy” section in it. Here, we will create the default file `mypy.ini`,
    which should live in the project’s main folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s come to possible configuration options. For this, we go back to
    our initial example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Simply running mypy actually yields no errors! That is, because type hints are
    optional by default — and mypy only checks types where an annotation is given.
    We can disable this via the flag `— disallow-untyped-defs`. Furthermore, there
    is a multitude of other flags one can use (see [here](https://mypy.readthedocs.io/en/stable/command_line.html#miscellaneous-strictness-flags)).
    However, in line with the general format of this post, we won’t go into detail
    of all these — and instead just present the strict mode. This mode turns on basically
    all optional checks. And in my experience, the best way of using mypy is to simply
    ask for the strictest checking possible — and then fix (or selectively ignore)
    any upbrought issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, let’s fill the `mypy.ini` file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The section header `[mypy]` is needed for any mypy related configuration, and
    the next line is pretty self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: When we now run mypy as usual, we are getting errors complaining about the missing
    type annotations — which only go away once everything is typed and we remove the
    faulty string call.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s have a closer look at how to annotate with mypy.
  prefs: []
  type: TYPE_NORMAL
- en: Annotating with mypy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section we’ll describe the most common type annotations and mypy keywords.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can annotate primitive types by simply using their Python type, i.e. `bool`,
    `int`, `float`, `str`, …:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Collection Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Starting from Python 3.9 upwards, also the built-in collection types can be
    used as type annotations. That is `list`, `set`, `dict`, …:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we have to specify the contents of the containers (e.g. `int`).
    For mixed types, see below.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier Python Versions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For earlier Python versions, one had to use legacy types from the `typing`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Mixing Contents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As teased above, we might want to create containers holding different data
    types. To do so, we can use the `Union` keyword — which allows us to annotate
    a type as a union of types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the simplifications done in Python 3.9, Python 3.10 (specifically
    [PEP 604](https://peps.python.org/pep-0604/)) introduces an abbreviated notation
    of the `Union` type using the logical or operator (`|`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Other mypy Keywords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section we’ll introduce more essential types and keywords.
  prefs: []
  type: TYPE_NORMAL
- en: None
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`None`, just as in “normal” Python, denotes a `None` value — most commonly
    used for annotating functions without return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Optional
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often, we might come across situations where we want to implement branching
    code based on whether we passed a value for a parameter or not — and often, we
    use `None` to indicate the absence of it. For this, we can use `typing.Optional[X]`
    — which denotes exactly this: it annotates type `X`, but also allows `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Following Python 3.10 and above introduced PEP 604, `Optional` can again be
    shorted to `X | None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that this does not correspond to [required or optional parameters](https://levelup.gitconnected.com/untangling-required-optional-positional-and-keyword-arguments-f7792320a40d),
    which is often confused! An optional parameter is one which we do not have to
    specify when calling a function — whereas mypy’s `Optional` indicates a parameter
    which can be of some type, but also `None`. A possible source of confusion could
    be that a common default value for optional parameters is `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Any
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Any`, as the name suggests (I feel I keep repeating this sentence …) simply
    allows every type — thus effectively turning off any kinds of type checking. Thus,
    try to avoid this whenever you can.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Annotating Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have used mypy to only annotate function parameters and return types.
    It is just natural to extend this to any kind of variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: However, this is somewhat lesser used (and also not enforced by the strict version
    of mypy), as the types of variables are mostly clear from the context. Usually,
    you would only do this when the code is relatively ambiguous and hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Annotating Complex Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section we’ll discuss annotating classes, but also annotating with your
    own and other complex classes.
  prefs: []
  type: TYPE_NORMAL
- en: Annotating Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Annotating classes can be handled pretty quickly: just annotate class functions
    as any other function, but don’t annotate the self argument in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Annotating with Custom / Complex Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With our class defined, we can now use its name as any other type annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, mypy works with most classes and types out of the box, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Fixing mypy Issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section we’ll see how to deal with external libraries which do not support
    typing and selectively disable type checking for certain lines which cause issues
    — on the basis of a slightly more complex example involving [numpy](https://numpy.org/)
    and [matplotlib](https://matplotlib.org/stable/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin with a first version of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We define a simple function computing the sinus of a numpy array, and apply
    it to the input values `x`, which span the space [0, 10]. Then, we plot the sinus
    curve using `matplotlib`.
  prefs: []
  type: TYPE_NORMAL
- en: In this code, we also see the correct typing of numpy arrays using `numpy.typing`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we run mypy on this, we’ll get two errors. The first one is:'
  prefs: []
  type: TYPE_NORMAL
- en: 'error: Returning Any from function declared to return “ndarray[Any, dtype[floating[_32Bit]]]”'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This is a relatively common pattern in mypy. We actually did not do anything
    wrong, but mypy would like it somewhat more explicit — and here — as well as in
    other situations — we have to “force” mypy to accept our code. We can do this
    for example by introducing a proxy variable of the correct type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The next error is:'
  prefs: []
  type: TYPE_NORMAL
- en: 'error: Skipping analyzing “matplotlib”: found module but no type hints or library
    stubs'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This is because `matplotlib` is not typed (yet). Thus, we need to let mypy
    know to exclude it from checking. We do this by adding the following to our mypy.ini
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, note that you can also selectively ignore any lines of code by appending
    `# type: ignore` to it. Do this, if there really is an unsolvable issue with mypy,
    or you want to silence some known but irrelevant warnings / errors. We could have
    also hidden our first error above via this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this post we introduced mypy, which is a static type checker for Python.
    Using mypy, we can (and should) annotate types of variables, parameters and return
    values — giving us a way of sanity checking our program at compile time. mypy
    is very wide-spread, and recommended for any semi-large software project.
  prefs: []
  type: TYPE_NORMAL
- en: We started by installing and configuring mypy. Then, we introduced how to annotate
    primitive and complex types, such as lists, dicts or sets. Next, we discussed
    other important annotators, such as `Union`, `Optional`, `None`, or `Any`. Eventually,
    we showed that mypy supports a wide range of complex types, such as custom classes.
    We finished the tutorial by showing how to debug and fix mypy errors.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it for mypy — I hope, you liked this post, thanks for reading!
  prefs: []
  type: TYPE_NORMAL
