- en: 'Programming in 3D: My First Steps into Quantum Computing'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/programming-in-3d-my-first-steps-into-quantum-computing-566b9b93929d](https://towardsdatascience.com/programming-in-3d-my-first-steps-into-quantum-computing-566b9b93929d)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Tutorial
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A world of computing in multiple dimensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@KoryBecker?source=post_page-----566b9b93929d--------------------------------)[![Kory
    Becker](../Images/53a2493fe53f215d3e715d456b36c553.png)](https://medium.com/@KoryBecker?source=post_page-----566b9b93929d--------------------------------)[](https://towardsdatascience.com/?source=post_page-----566b9b93929d--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----566b9b93929d--------------------------------)
    [Kory Becker](https://medium.com/@KoryBecker?source=post_page-----566b9b93929d--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----566b9b93929d--------------------------------)
    ·9 min read·Feb 22, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/632bdebf55363ec9dc95beb782e83e6d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Source: [Stable Diffusion](https://stablediffusionweb.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: I remember my first quantum experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I was speaking at the Grace Hopper 2018 ([GHC18](https://ghc.anitab.org/2018-attend/))
    conference. I had just visited the incredibly crowded and overwhelming vendor
    expo, and was looking for place to sit for a few minutes.
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, I ended up sitting down to an introductory presentation from
    IBM Quantum on using [Qiskit](https://qiskit.org/), an open-source quantum computing
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: Peering into the looking glass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The presentation was a basic introduction into the concept of a qubit and [superposition](https://medium.com/towards-data-science/the-magic-of-quantum-computing-a-beginners-guide-to-writing-a-magic-number-guessing-game-c1cdb384f457).
  prefs: []
  type: TYPE_NORMAL
- en: I had no idea what superposition was, and yet, I found the presentation absolutely
    enthralling.
  prefs: []
  type: TYPE_NORMAL
- en: Just imagine, the idea of a bit on a computer being able to represent both the
    values 0 and 1 at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: '*How could this be possible?*'
  prefs: []
  type: TYPE_NORMAL
- en: While this ultimately started my [foundation](https://medium.com/towards-data-science/the-magic-of-quantum-computing-a-beginners-guide-to-writing-a-magic-number-guessing-game-c1cdb384f457)
    into quantum computing, it also opened my eyes to the idea of programming at an
    entirely different level.
  prefs: []
  type: TYPE_NORMAL
- en: It felt like programming in 3D.
  prefs: []
  type: TYPE_NORMAL
- en: Programming in the quantum world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On a classical computer, bits are represented with a value of 0 or 1\. This
    is an exclusive condition.
  prefs: []
  type: TYPE_NORMAL
- en: A bit can hold a value of 0 OR 1.
  prefs: []
  type: TYPE_NORMAL
- en: However, it can not be both 0 AND 1 at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: A qubit on a quantum computer, on the other hand, can hold a value of 0 AND
    1 (or a floating point value in between) at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: '*Think about this for a moment*'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we have two bits on a classical computer, we can represent one of the following
    values during a single CPU cycle: 00, 01, 10, 11.'
  prefs: []
  type: TYPE_NORMAL
- en: However, two qubits on a quantum computer can represent those same values simultaneously.
    This means that you can process calculations with quadratic or exponential increases
    in speed!
  prefs: []
  type: TYPE_NORMAL
- en: Similarly to how two qubits can represent four different values simultaneously,
    with three qubits we can represent eight values. Likewise, with four qubits we
    can represent sixteen.
  prefs: []
  type: TYPE_NORMAL
- en: While a classical computer can process n calculations per n bits, a quantum
    computer can process an astounding 2^n calculations per n qubits!
  prefs: []
  type: TYPE_NORMAL
- en: With just 50 qubits you could process 2⁵⁰ calculations in a single CPU cycle.
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to over 140,000 GB of data processed during a single run
    of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Thinking in a higher dimension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since quantum computing can process multiple states for each qubit simultaneously,
    you begin to think in an entirely different way when writing a program.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of writing a program with a single bit and expecting it to result in
    a value of 0 or 1 for a particular calculation, you have to begin thinking in
    a range of percentages.
  prefs: []
  type: TYPE_NORMAL
- en: So, a qubit might be 0 about half of the time, and it might be 1 the other half
    of the time.
  prefs: []
  type: TYPE_NORMAL
- en: This sounds confusion, and it had me confused at first as well — *in fact, it
    still does!*
  prefs: []
  type: TYPE_NORMAL
- en: However, let’s consider a fun example to understand the core difference in programming
    a classical program to programming a quantum computer.
  prefs: []
  type: TYPE_NORMAL
- en: I say hello, you say goodbye
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s suppose that we want to write a program to output “Hello” or “Goodbye”,
    depending on an argument passed in having the value of 1 or 3.
  prefs: []
  type: TYPE_NORMAL
- en: If the function is passed an input of 1, we output the word, “Hello”.
  prefs: []
  type: TYPE_NORMAL
- en: If the function is passed an input of 3, we output the word, “Goodbye”.
  prefs: []
  type: TYPE_NORMAL
- en: These two values are only one bit apart in binary (1 = 01, 3 = 11). We’re keeping
    the first, least significant bit, fixed to a value of 1\. These two values serve
    as a convenient example for a quantum computer.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how we would write a plain classical program with it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Hello
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Goodbye
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is programming at a two-dimensional level.
  prefs: []
  type: TYPE_NORMAL
- en: We have a function that we can understand and it takes a single numeric input.
    We use a conditional statement to check if the value is 1 or 3\. We output the
    message accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Each time this function is executed, we know exactly what the output will be
    according to the input.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what this looks like on a quantum computer.
  prefs: []
  type: TYPE_NORMAL
- en: Programming in 3D
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use the quantum computing framework, Qiskit, to create our program, as
    shown in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/ecc81276f0e11acabf924541c62b1bc6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A quantum computing program for generating a 2-bit number of 01 (1) or 11 (3).
    The first qubit (q0) is set to a value of 1\. The second qubit (q1) is in superposition
    with a value of 0 and 1\. Source: Author, generated by Qiskit.'
  prefs: []
  type: TYPE_NORMAL
- en: The above program uses two qubits. Just like our classical program using an
    input of 1 or 3 to output a message, we can represent the same two values on a
    quantum computer by using two qubits.
  prefs: []
  type: TYPE_NORMAL
- en: Since both of the values in binary, 01 (1) and 11 (3), require the least-significant
    bit to be a value of 1, we invert the first qubit (using the X-gate) to hold a
    value of 1.
  prefs: []
  type: TYPE_NORMAL
- en: '*Now, here comes the amazing part*'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our quantum program can hold two different values at the same time!
  prefs: []
  type: TYPE_NORMAL
- en: While the least significant qubit (q0) is fixed to a value of 1, the most significant
    qubit (q1) will hold a value of both 0 AND 1, effectively representing the integer
    1 or 3\. If this qubit ends up measuring as a value of 0, the resulting binary
    will be 01, and thus result in an integer of 1\. If the qubit measures a value
    of 1, the resulting binary will be 11, and result in an integer of 3.
  prefs: []
  type: TYPE_NORMAL
- en: '**Together, the two qubits are virtually able to represent both the numbers
    1 and 3 at the same time!**'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s run the program and see what the output looks like.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '{‘11’: 526, ‘01’: 498}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A quantum computer outputs the number of times that the two qubits measured
    a value of 11 or 01\. In both cases, notice how only the most-significant qubit
    (the one towards the left) is changing value.
  prefs: []
  type: TYPE_NORMAL
- en: This is the qubit (q1) that we placed in superposition — and this is the part
    where it feels like programming in 3D!
  prefs: []
  type: TYPE_NORMAL
- en: We’re no longer considering a single value. Instead, we now have to think about
    *multiple* values. Specifically, we have to think about both 1 and 3 as an input
    into our greeting program simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6b830b3bcc9dc22177117ef13ea5340f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The distribution of results for 1 or 3 on a quantum computer. Source: Author.'
  prefs: []
  type: TYPE_NORMAL
- en: Half of the time we will receive a 1 as input to our function, while the other
    half of the time we will receive a 3.
  prefs: []
  type: TYPE_NORMAL
- en: The message that our function outputs is tied directly to the chance that the
    second qubit (q1) ends up in a state of 0 or 1.
  prefs: []
  type: TYPE_NORMAL
- en: Running the quantum version
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It takes significant thought to wrap one’s mind around the idea that a quantum
    program will return multiple values.
  prefs: []
  type: TYPE_NORMAL
- en: Since we will get back multiple values, we would need to change the greeting
    program to account for both cases.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Hello
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Goodbye
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The above program slightly modifies our original classical implementation, in
    that we are now checking if any of the resulting counts from measuring the quantum
    circuit have a count greater than zero. If so, we output the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice, the important distinction between the classical and quantum implementations
    of the greeting function:'
  prefs: []
  type: TYPE_NORMAL
- en: The classical version required calling the *greeting()* function two times in
    order to output both messages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The quantum version only requires a single call of *qgreeting()* to output the
    same messages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Superimposing greetings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve modified the greeting program to check the counts from the qubit
    measurements. This let us output two messages from a single call, which helps
    us understand the quantum nature of multiple outcomes from our program.
  prefs: []
  type: TYPE_NORMAL
- en: However, since the qubits truly represent multiple values at the same time,
    instead of displaying two separate greetings, maybe we could superimpose the two
    greetings on top of one another!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: HelGood
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Wow — we’re superimposing the two messages (“Hello” and “Goodbye”) and combining
    them into a single greeting (“HelGood”).
  prefs: []
  type: TYPE_NORMAL
- en: The number of letters output from each greeting comes from the measurement counts
    from each outcome of 01 (1) and 11 (3) in our quantum program.
  prefs: []
  type: TYPE_NORMAL
- en: Since our quantum circuit has a 50/50 chance of resulting in either outcome,
    it’s no surprise that we’re taking the first half of each greeting and joining
    them together.
  prefs: []
  type: TYPE_NORMAL
- en: '*Well, maybe that isn’t quite right either*'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While merging the two greetings together does, indeed, give a sense of the multiple
    values that the quantum program can simultaneously represent, it’s still a bit
    confusing.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, let’s resolve the multiple quantum states into a single answer.
  prefs: []
  type: TYPE_NORMAL
- en: Flattening down quantum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we’ve seen, the quantum *qgreeting()* uses a percentage of counts, resulting
    from the measurements of the quantum program in order to output a message.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have measurement counts for each outcome, let’s just take the majority
    count and pass that as input to our original classical greeting method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the quantum program resulted in {‘11’: 529, ‘01’: 495}, we would use the
    binary result of 11, which equals 3, since it has the highest count.'
  prefs: []
  type: TYPE_NORMAL
- en: Majority rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s use this method to run our original classical greeting method by selecting
    the value with the majority count and passing it as input to our classical program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Hello
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Goodbye
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Goodbye
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Goodbye
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Hello
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Goodbye
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This seems more realistic.
  prefs: []
  type: TYPE_NORMAL
- en: We’re now selecting the majority count and using that message as the output.
    This is actually called measuring in the [computational basis](https://quantumcomputing.stackexchange.com/questions/1410/what-is-meant-by-the-term-computational-basis)
    state.
  prefs: []
  type: TYPE_NORMAL
- en: Notice, the output is returning different messages each time we execute the
    quantum circuit. This is due to the single qubit that we placed in superposition
    (on the most significant qubit).
  prefs: []
  type: TYPE_NORMAL
- en: We no longer have a completely deterministic program where we can be certain
    of the output. Instead, our program runs in the quantum universe!
  prefs: []
  type: TYPE_NORMAL
- en: Quantum computing power and complexity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s just fascinating how we can virtually represent simultaneous values in
    a quantum computing program.
  prefs: []
  type: TYPE_NORMAL
- en: However, it’s not too difficult to see how complex this can become when we start
    considering 3, 4, 10, 20, or 100 qubits in a program.
  prefs: []
  type: TYPE_NORMAL
- en: If only one qubit is placed into superposition (to have a 50/50 random chance
    of resulting in a value of 0 or 1), it may not be too difficult to grasp. After
    all, all of the other qubits will be a fixed value as initially assigned. Only
    the qubit(s) in superposition will hold the possibility for multiple values. However,
    when one or more qubits are in superposition, it becomes increasingly complex
    — but also increasingly more powerful!
  prefs: []
  type: TYPE_NORMAL
- en: In fact, superposition is at the core of gaining quadratic and exponential performance
    increases in quantum programs, compared to their classical counterparts. Since
    they can represent multiple states during a single CPU cycle, they can process
    far more permutations of bits than a classical computer.
  prefs: []
  type: TYPE_NORMAL
- en: Now, I hope it is becoming apparent how programming a quantum computer feels
    like programming in 3D. It’s, simply put, a completely different level from classical
    programming!
  prefs: []
  type: TYPE_NORMAL
- en: Does this sound like fun?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope that this initial discovery into quantum computing has piqued your interest
    as much as it did mine.
  prefs: []
  type: TYPE_NORMAL
- en: I certainly believe it’s this higher dimensional thinking that makes quantum
    computing so enticing, especially for programmers looking to develop their skills
    on an entirely new level.
  prefs: []
  type: TYPE_NORMAL
- en: You can download the complete code example for the greeting program [here](https://gist.github.com/primaryobjects/07db824f3b1b06cf4dbace6f2725052f).
  prefs: []
  type: TYPE_NORMAL
- en: About the Author
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’ve enjoyed this article, please consider following me on [Medium](https://medium.com/@KoryBecker),
    [Twitter](https://twitter.com/PrimaryObjects), and my [web site](https://primaryobjects.com/)
    to be notified of my future posts and research work.
  prefs: []
  type: TYPE_NORMAL
