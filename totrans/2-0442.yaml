- en: 'Building an AI-Powered Language Learning App: Learning From Two AI Chatting'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个 AI 驱动的语言学习应用：从两个 AI 聊天中学习
- en: 原文：[https://towardsdatascience.com/building-an-ai-powered-language-learning-app-learning-from-two-ai-chatting-6db7f9b0d7cd](https://towardsdatascience.com/building-an-ai-powered-language-learning-app-learning-from-two-ai-chatting-6db7f9b0d7cd)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/building-an-ai-powered-language-learning-app-learning-from-two-ai-chatting-6db7f9b0d7cd](https://towardsdatascience.com/building-an-ai-powered-language-learning-app-learning-from-two-ai-chatting-6db7f9b0d7cd)
- en: A step-by-step tutorial on creating a dual-chatbot language learning app with
    Langchain, OpenAI, gTTS, and Streamlit
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个双聊天机器人语言学习应用的逐步教程，使用 Langchain、OpenAI、gTTS 和 Streamlit
- en: '[](https://shuaiguo.medium.com/?source=post_page-----6db7f9b0d7cd--------------------------------)[![Shuai
    Guo](../Images/d673c066f8006079be5bf92757e73a59.png)](https://shuaiguo.medium.com/?source=post_page-----6db7f9b0d7cd--------------------------------)[](https://towardsdatascience.com/?source=post_page-----6db7f9b0d7cd--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----6db7f9b0d7cd--------------------------------)
    [Shuai Guo](https://shuaiguo.medium.com/?source=post_page-----6db7f9b0d7cd--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://shuaiguo.medium.com/?source=post_page-----6db7f9b0d7cd--------------------------------)[![Shuai
    Guo](../Images/d673c066f8006079be5bf92757e73a59.png)](https://shuaiguo.medium.com/?source=post_page-----6db7f9b0d7cd--------------------------------)[](https://towardsdatascience.com/?source=post_page-----6db7f9b0d7cd--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----6db7f9b0d7cd--------------------------------)
    [Shuai Guo](https://shuaiguo.medium.com/?source=post_page-----6db7f9b0d7cd--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----6db7f9b0d7cd--------------------------------)
    ·25 min read·Jun 26, 2023
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·发表于 [Towards Data Science](https://towardsdatascience.com/?source=post_page-----6db7f9b0d7cd--------------------------------)
    ·25 分钟阅读·2023年6月26日
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/6b56edb9154ae8825ea55581c2ab5ee9.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6b56edb9154ae8825ea55581c2ab5ee9.png)'
- en: 'DALL-E Prompt: two friendly robots talking with each other.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: DALL-E 提示：两个友好的机器人相互交谈。
- en: When I first began learning a new language, I like to buy those “conversational
    dialogues” books. I find those books very useful as they help me understand how
    the language worked — not just the grammar and vocabulary, but also how people
    really used it in day-to-day life.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当我第一次开始学习一门新语言时，我喜欢购买那些“对话练习”书籍。我发现这些书籍非常有用，因为它们帮助我理解了语言的运作——不仅仅是语法和词汇，还有人们在日常生活中如何实际使用它。
- en: 'Now with the rise of large language models (LLMs), a thought occurred to me:
    could I replicate these language-learning books in a more interactive, dynamic,
    and scalable format? Could I utilize LLM to create a tool that generates fresh,
    on-demand conversations for language learners?'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在随着大型语言模型（LLMs）的兴起，我想到一个问题：我是否可以以一种更互动、动态和可扩展的形式来复制这些语言学习书籍？我能否利用 LLM 创建一个生成新鲜、按需对话的工具，为语言学习者提供帮助？
- en: This thought inspired the project I would like to share with you today — an
    AI-powered language learning app, where learners can observe and learn from two
    AI chatbots engaged in either a user-defined **conversation** or a **debate**.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法激发了我今天想与大家分享的项目——一个由人工智能驱动的语言学习应用程序，在这个应用中，学习者可以观察并学习两个 AI 聊天机器人进行的用户定义的**对话**或**辩论**。
- en: Regarding the employed tech stack, I have used Langchain, OpenAI API, gTTS,
    and Streamlit to create the application where users can define the roles, scenarios,
    or debate topics, and let the AI generate the content.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 关于所使用的技术栈，我使用了 Langchain、OpenAI API、gTTS 和 Streamlit 来创建这个应用，用户可以定义角色、场景或辩论主题，让
    AI 生成内容。
- en: Demo for the developed language learning app. (Video by author)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 开发的语言学习应用程序演示。（视频由作者提供）
- en: If you’re curious about how it all works, then join me as I walk you through
    the journey of building this interactive dual-chatbot system, step by step 🗺️📍🚶‍♀️.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对它的工作原理感到好奇，那就跟随我一步一步了解构建这个互动双聊天机器人系统的过程 🗺️📍🚶‍♀️。
- en: You can find the complete source code [here](https://github.com/ShuaiGuo16/language_learning_app)*💻*.
    In this blog, we will also go through the key code snippets to explain the ideas.
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以在[这里](https://github.com/ShuaiGuo16/language_learning_app)*💻*找到完整的源代码。在这篇博客中，我们还将介绍关键的代码片段以解释这些想法。
- en: With that in mind, let’s get started!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 既然如此，我们开始吧！
- en: '**Table of Content**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**内容目录**'
- en: · [1\. Project Overview](#209d)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: · [1\. 项目概述](#209d)
- en: · [2\. Prerequisites](#9115)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: · [2\. 前置条件](#9115)
- en: ∘ [2.1 LangChain](#0dee)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [2.1 LangChain](#0dee)
- en: ∘ [2.2 ConversationChain](#3988)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [2.2 ConversationChain](#3988)
- en: · [3\. Project Design](#d70e)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: · [3\. 项目设计](#d70e)
- en: ∘ [3.1 Developing a single chatbot](#c790)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [3.1 开发单一聊天机器人](#c790)
- en: ∘ [3.2 Developing a dual-chatbot system](#5a8a)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [3.2 开发双聊天机器人系统](#5a8a)
- en: · [4\. App Interface Design with Streamlit](#2557)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: · [4\. 使用 Streamlit 的应用界面设计](#2557)
- en: · [5\. Learnings and Future Extensions](#cffe)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: · [5\. 学习成果与未来扩展](#cffe)
- en: · [6\. Conclusion](#954a)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: · [6\. 结论](#954a)
- en: 1\. Project Overview
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1\. 项目概述
- en: As mentioned earlier, our goal is to create a unique language-learning app powered
    by two conversational AI or chatbots. The innovative aspect of this app lies in
    having these chatbots interact with each other, creating realistic dialogues in
    the target language. Users can observe these AI-driven conversations, use them
    as language-learning resources, and understand the practical usage of their chosen
    language.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们的目标是创建一个由两个对话式 AI 或聊天机器人驱动的独特语言学习应用程序。这个应用程序的创新之处在于让这些聊天机器人相互互动，创造出逼真的目标语言对话。用户可以观察这些
    AI 驱动的对话，将其作为语言学习资源，并理解所选语言的实际使用。
- en: In our app, users should have the flexibility to customize their learning experience
    according to their needs. They can adjust several settings including target language,
    learning mode, session length, and proficiency level.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，用户应具备根据自身需求定制学习体验的灵活性。他们可以调整多个设置，包括目标语言、学习模式、会话时长和熟练程度。
- en: '**Target Language** 🔤'
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**目标语言** 🔤'
- en: Users can choose the language they wish to learn. This choice guides the language
    used by the chatbots during their interactions. For the moment, I have included
    support for English — ‘en’, German — ‘de’, Spanish — ‘es’, and French — ‘fr’,
    but it is trivial to add more languages as long as the GPT model has sufficient
    knowledge about them.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以选择他们希望学习的语言。这个选择将指导聊天机器人在互动过程中使用的语言。目前，我已经支持了英语——‘en’，德语——‘de’，西班牙语——‘es’，和法语——‘fr’，但只要GPT模型对这些语言有足够的知识，添加更多语言是微不足道的。
- en: Learning mode 📖
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习模式 📖
- en: This setting lets users select the style of conversation between the chatbots.
    In the **“conversation”** mode, users can define the **roles** (e.g., customer
    and waitstaff) and **actions** (ordering food and taking an order)for each bot
    and specify a **scenario** (at a restaurant), upon which the bots will simulate
    a realistic conversation. In the **“debate”** mode, users are prompted to input
    a debate **topic** (Should we adopt nuclear energy?). The bots then engage in
    a lively debate on the provided topic.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置允许用户选择聊天机器人之间的对话风格。在**“对话”**模式下，用户可以定义**角色**（例如，顾客和服务员）和**动作**（点餐和接单），并指定一个**场景**（在餐厅），聊天机器人将模拟一个逼真的对话。在**“辩论”**模式下，用户被提示输入一个辩论**话题**（我们是否应该采用核能？）。然后，聊天机器人会围绕提供的话题进行激烈的辩论。
- en: The app’s interface should be responsive and dynamically adjusts based on the
    learning mode selected by the user, providing a seamless user experience.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的界面应该是响应式的，并根据用户选择的学习模式动态调整，以提供无缝的用户体验。
- en: Session Length ⏰
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 会话时长 ⏰
- en: The session length setting gives users control over the duration of each chatbot
    conversation or debate. This means they can have short, quick dialogues or longer,
    more in-depth discussions, depending on their preference.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 会话时长设置让用户控制每次聊天机器人对话或辩论的持续时间。这意味着他们可以进行简短的快速对话，或根据个人喜好进行更长时间、更深入的讨论。
- en: Proficiency Level 🏆
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 熟练程度 🏆
- en: This setting tailors the complexity of the chatbot conversation to the user’s
    language skill level. Beginners might prefer simpler conversations, while more
    advanced learners can handle intricate debates or discussions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置将聊天机器人的对话复杂性量身定制为用户的语言能力水平。初学者可能更喜欢简单的对话，而更高级的学习者则可以处理复杂的辩论或讨论。
- en: 'Once the users specify those settings, they can initiate the session and watch
    as the AI chatbots spring into action, carrying out dynamic and interactive dialogues
    in accordance with the user’s preferences. Our overall workflow can be illustrated
    as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户指定了这些设置，他们就可以启动会话，观看 AI 聊天机器人如何根据用户的偏好进行动态和互动的对话。我们的整体工作流程可以如下所示：
- en: '![](../Images/5c17a979a507a63f4be9b4f03e15b7fa.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5c17a979a507a63f4be9b4f03e15b7fa.png)'
- en: Workflow overview. The user-specified settings will be used to configure the
    prompt, which will be fed to the chatbots to generate conversations. The obtained
    script (together with user settings) will be used to populate the app interface.
    (Image by author)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程概述。用户指定的设置将用于配置提示，这些提示将提供给聊天机器人以生成对话。获得的脚本（连同用户设置）将用于填充应用程序界面。（图片由作者提供）
- en: 2\. Prerequisites
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. 前提条件
- en: Before we dive into the development of our app, let’s familiarize ourselves
    with the tools that we will be using. In this section, we’ll briefly introduce
    the LangChain library, specifically the `ConversationChain` module, which serves
    as the backbone of our app.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入开发应用程序之前，让我们熟悉一下我们将使用的工具。在这一部分，我们将简要介绍 LangChain 库，特别是 `ConversationChain`
    模块，它作为我们应用程序的核心部分。
- en: 2.1 LangChain
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 LangChain
- en: Building an application powered by Large Language Models (LLMs) involves many
    complexities. You need to interface with language model providers through API
    calls, connect these models to various data sources, handle the history of user
    interactions, and design pipelines for executing complex tasks. This is where
    the LangChain library comes into play.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个由大型语言模型（LLMs）驱动的应用程序涉及许多复杂性。你需要通过 API 调用与语言模型提供者进行接口连接，将这些模型与各种数据源连接，处理用户互动的历史记录，并设计执行复杂任务的管道。这正是
    LangChain 库发挥作用的地方。
- en: '[**LangChain**](https://python.langchain.com/docs/get_started/introduction)is
    a framework dedicated to streamlining the development of LLM-powered applications.
    It offers a wide array of components that address the common pain points listed
    above. Whether it’s managing interactions with the language model providers, orchestrating
    data connections, maintaining memory for historical interactions, or defining
    intricate task pipelines, LangChain has it covered.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[**LangChain**](https://python.langchain.com/docs/get_started/introduction)是一个旨在简化基于大语言模型（LLM）应用程序开发的框架。它提供了一系列组件，解决了上述常见痛点。无论是管理与语言模型提供者的互动，组织数据连接，维护历史互动的记忆，还是定义复杂的任务管道，LangChain
    都能应对自如。'
- en: A key concept introduced by LangChain is the “**Chain**”. In essence, chains
    allow us to combine multiple components together to create a single, coherent
    application. For example, a fundamental chain type in LangChain is the `LLMChain.`
    It creates a pipeline that first formats the prompt template using the user-provided
    input key values, then passes the formatted instructions to LLM, and finally returns
    the LLM output.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: LangChain 介绍的一个关键概念是“**Chain**”。本质上，链允许我们将多个组件组合在一起，以创建一个统一的应用程序。例如，LangChain
    中的一个基本链类型是 `LLMChain`。它创建了一个管道，首先使用用户提供的输入键值格式化提示模板，然后将格式化的指令传递给 LLM，最后返回 LLM
    的输出。
- en: LangChain hosts a variety of chain types, including `RetrievalQAChain,` for
    question-answering over documents, `SummarizationChain,` for summarizing multiple
    documents, and of course, our focus for today, the `ConversationChain.`
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: LangChain 主持各种链类型，包括 `RetrievalQAChain`，用于对文档进行问答，`SummarizationChain`，用于总结多个文档，以及我们今天的重点，即
    `ConversationChain`。
- en: 2.2 ConversationChain
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 ConversationChain
- en: '`ConversationChain`is used to facilitate interactive conversations by providing
    a framework for exchanging messages and storing conversation history. Here’s a
    sample code snippet to illustrate its usage:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConversationChain` 用于通过提供一个消息交换和存储对话历史的框架来促进互动对话。以下是一个示例代码片段，以说明其用法：'
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, the `ConversationChain` takes three inputs, *memory*, a LangChain
    component that holds the interaction history; *prompt*, the input to the LLM;
    and *llm*, the core large language model (e.g., GPT-3.5-Turbo, etc.).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`ConversationChain` 接受三个输入，*memory*，一个持有互动历史的 LangChain 组件；*prompt*，输入到
    LLM 的内容；以及 *llm*，核心的大型语言模型（例如，GPT-3.5-Turbo 等）。
- en: Once the`ConversationChain` object is instantiated, we can simply call `conversation.predict()`
    with the user input to get LLM’s response. The convenience with `ConversationChain`
    is that we can actually call `conversation.predict()` multiple times, and it automatically
    records the message history under the hood.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `ConversationChain` 对象被实例化，我们只需使用用户输入调用 `conversation.predict()` 即可获得 LLM
    的响应。`ConversationChain` 的便利之处在于，我们实际上可以多次调用 `conversation.predict()`，它会自动在后台记录消息历史。
- en: In the next section, we’ll harness the power of `ConversationChain`to create
    our chatbots and delve into how the memory, prompt template, and LLM are defined
    and utilized.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将利用 `ConversationChain` 的强大功能创建我们的聊天机器人，并深入探讨记忆、提示模板和 LLM 的定义与使用。
- en: If you would like to learn more about LangChain, take a look at their [official
    documentation](https://python.langchain.com/docs/get_started/introduction.html).
    In addition, this [YouTube playlist](https://youtube.com/playlist?list=PLqZXAkvF1bPNQER9mLmDbntNfSpzdDIU5)
    also offers a comprehensive, hands-on introduction.
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于 LangChain 的信息，可以查看他们的[官方文档](https://python.langchain.com/docs/get_started/introduction.html)。此外，这个[YouTube
    播放列表](https://youtube.com/playlist?list=PLqZXAkvF1bPNQER9mLmDbntNfSpzdDIU5)也提供了全面的实践介绍。
- en: 3\. Project Design
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3\. 项目设计
- en: Now that we have a clear understanding of what we want to build and the tools
    to build it, it’s time to roll up our sleeves and dive into the code! In this
    section, we’re going to focus on the nuts and bolts of creating our dual-chatbot
    interaction. First, we’ll explore the class definition for a single chatbot and
    then expand on this to create a dual-chatbot class, enabling our two chatbots
    to interact. We’ll save the design of the app interface using Streamlit for Section
    4.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们对要构建的内容和工具有了明确的了解，就该动手编写代码了！在这一部分，我们将专注于创建双聊天机器人交互的细节。首先，我们将探讨单一聊天机器人的类定义，然后扩展这一定义以创建一个双聊天机器人类，使我们的两个聊天机器人能够互相互动。我们将把使用
    Streamlit 设计应用界面的工作留到第 4 部分。
- en: 3.1 Developing a single chatbot
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 开发一个单一的聊天机器人
- en: In this subsection, we will develop a single chatbot together, which will later
    be integrated into the dual-chatbot system. Let’s start with the overall class
    design, then shift our attention to prompt engineering.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一小节中，我们将一起开发一个单一的聊天机器人，随后将其集成到双聊天机器人系统中。让我们从整体的类设计开始，然后将注意力转向提示工程。
- en: 🏗️ **Class Design**
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 🏗️ **类设计**
- en: Our chatbot class should enable the management of an individual chatbot. This
    involves instantiating a chatbot with a user-specified LLM as its backbone, providing
    instructions based on the user’s intent, and facilitating interactive multi-round
    conversations. With that in mind, let’s start coding.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的聊天机器人类应该能够管理一个单独的聊天机器人。这包括实例化一个以用户指定的 LLM 作为基础的聊天机器人，根据用户的意图提供指令，并支持交互式的多轮对话。考虑到这一点，让我们开始编码吧。
- en: 'First, import the necessary libraries:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，导入必要的库：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we define the class constructor:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义类构造函数：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Currently, you can only choose to use the native OpenAI API. Nevertheless, adding
    more backend LLMs is straightforward since LangChain supports various types (e.g.,
    Azure OpenAI endpoint, Anthropic chat models, PaLM API on Google Vertex AI, etc.).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你只能选择使用原生的 OpenAI API。然而，添加更多后端 LLM 是很简单的，因为 LangChain 支持多种类型（例如 Azure OpenAI
    端点、Anthropic 聊天模型、Google Vertex AI 上的 PaLM API 等）。
- en: Besides LLM, another important component we need to instantiate is *memory*,
    which tracks the conversation history. Here, we use `ConversationBufferMemory`
    for this purpose, which simply prepends the last few inputs/outputs to the current
    input of the chatbot. This is the simplest memory type offered in LangChain and
    it’s sufficient for our current purpose.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 LLM，我们还需要实例化另一个重要的组件——*记忆*，它跟踪对话历史。在这里，我们使用`ConversationBufferMemory`来实现这一目的，它仅仅是在聊天机器人的当前输入前添加最后几条输入/输出。这是
    LangChain 提供的最简单的记忆类型，对于我们当前的目的已经足够。
- en: For a complete overview of other types of memory, please refer to the [official
    docs](https://python.langchain.com/docs/modules/memory/).
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要全面了解其他类型的记忆，请参考[官方文档](https://python.langchain.com/docs/modules/memory/)。
- en: 'Moving on, we need to have a class method that allows us to give instructions
    to the chatbot and make conversations with it. This is what `self.instruct()`
    for:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 继续，我们需要一个类方法，允许我们给聊天机器人下达指令并与其对话。这就是`self.instruct()`的作用：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**We define a couple of settings to allow users to customize their learning
    experience.**'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们定义了一些设置，以便用户可以自定义他们的学习体验。**'
- en: 'In addition to what has been mentioned in “Section 1 Project Overview”, we
    have four new attributes:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在“第 1 部分 项目概述”中提到的内容外，我们还有四个新的属性：
- en: '`self.role/self.oppo_role:` this attribute takes the form of a dictionary that
    records the role name and corresponding actions. For instance:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.role/self.oppo_role:` 这个属性的形式是一个字典，用于记录角色名称及其对应的动作。例如：'
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`self.oppo_role` represents the role taken by the other chatbot engaged in
    the conversation with the current chatbot. It’s essential because the current
    chatbot needs to understand who it is communicating with, providing necessary
    contextual information.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.oppo_role`表示与当前聊天机器人进行对话的另一个聊天机器人所扮演的角色。这是重要的，因为当前聊天机器人需要了解它正在与谁沟通，以提供必要的上下文信息。'
- en: '`self.scenario` sets the stage for the conversation. For “conversation” learning
    mode, `self.scenario`represents the place where the conversation'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.scenario` 为对话设置了场景。对于“对话”学习模式，`self.scenario` 代表对话发生的地方。'
- en: is happening; for “debate” mode, `self.scenario`represents the debating topic.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正在发生；对于“辩论”模式，`self.scenario` 代表辩论的话题。
- en: Finally, `self.starter` is just a boolean flag to indicate if the current chatbot
    will initiate the conversation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`self.starter` 只是一个布尔标志，用于指示当前聊天机器人是否会发起对话。
- en: '**We structure the prompt for the chatbot.**'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们为聊天机器人构建提示。**'
- en: 'In OpenAI, a chat model generally takes a list of messages as input and returns
    a model-generated message as output. LangChain supports `SystemMessage`,`AIMessage`,
    `HumanMessage`: `SystemMessage` helps set the behavior of the chatbot, `AIMessage`
    stores previous chatbot responses, and `HumanMessage` provides requests or comments
    for the chatbot to respond to.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenAI 中，一个聊天模型通常接受一系列消息作为输入，并返回模型生成的消息作为输出。LangChain 支持 `SystemMessage`、`AIMessage`
    和 `HumanMessage`：`SystemMessage` 帮助设置聊天机器人的行为，`AIMessage` 存储以前聊天机器人的响应，`HumanMessage`
    提供聊天机器人需要回应的请求或评论。
- en: LangChain conveniently offers `PromptTemplate` to streamline prompt generation
    and ingestion. For a chatbot application, we need to specify the `PromptTemplate`
    for all three message types. The most critical piece is setting the `SystemMessage`,
    which controls the chatbot’s behavior. We have a separate method, `self._specify_system_message()`,
    to handle this, which we’ll discuss in detail later.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: LangChain 方便地提供了 `PromptTemplate` 来简化提示生成和处理。对于聊天机器人应用，我们需要为所有三种消息类型指定 `PromptTemplate`。最关键的部分是设置
    `SystemMessage`，它控制聊天机器人的行为。我们有一个单独的方法 `self._specify_system_message()` 来处理这个问题，稍后我们会详细讨论。
- en: '**Finally, we bring all the pieces together and construct a** `ConversationChain.`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最后，我们把所有部分整合在一起，构建一个** `ConversationChain`。'
- en: 🖋️ **Prompt Design**
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 🖋️ **提示设计**
- en: 'Our focus now turns to guiding the chatbot in participating in the conversation
    as desired by the user. To this end, we have the `self._specify_system_message()`
    method. The signature of this method is shown below:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的重点是指导聊天机器人根据用户的需求参与对话。为此，我们有 `self._specify_system_message()` 方法。该方法的签名如下所示：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Essentially, this method compiles a string, which will then be fed into the
    `SystemMessagePromptTemplate.from_template()` to instruct the chatbot, as demonstrated
    in the definition of the `self.instruct()` method above. We’ll dissect this “long
    string” in the following to understand how each language learning requirement
    is incorporated into the prompt.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，这个方法编译一个字符串，然后将其输入到 `SystemMessagePromptTemplate.from_template()` 以指示聊天机器人，如上面
    `self.instruct()` 方法的定义所示。我们将在接下来的部分中分析这个“长字符串”，以了解每个语言学习需求如何融入提示中。
- en: 1️⃣ Session length
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 1️⃣ 会话长度
- en: The session length is controlled by directly specifying the maximum number of
    exchanges that can happen within one session. Those numbers are hard-coded for
    the time being.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 会话长度通过直接指定在一个会话中可以发生的最大交换次数来控制。这些数字目前是硬编码的。
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 2️⃣ Number of sentences the chatbot can say in one exchange
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 2️⃣ 聊天机器人在一次交换中可以说的句子数量
- en: Apart from limiting the total number of allowed exchanges, it’s also beneficial
    to restrict how much a chatbot can say within one exchange, or equivalently, the
    number of sentences.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 除了限制允许的总交换次数外，限制聊天机器人在一次交换中可以说多少也是有益的，或者等效地，限制句子数量。
- en: In my experiments, there is usually no need to constrain this in “conversation”
    mode, as the chatbot mimics a real-life dialogue and tends to speak at a reasonable
    length. However, in “debate” mode, it’s necessary to impose a limit. Otherwise,
    the chatbot may continue speaking, eventually generating an “essay” 😆.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的实验中，通常不需要在“对话”模式中限制这个，因为聊天机器人模拟真实对话，往往会在合理的长度内发言。然而，在“辩论”模式下，需要施加限制，否则聊天机器人可能会继续发言，最终生成一篇“文章”
    😆。
- en: 'Similar to limiting the session length, the numbers that restrict the speech
    length are also hard-coded and correspond with the user’s proficiency level in
    the target language:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于限制会话长度，限制演讲长度的数字也是硬编码的，并且与用户在目标语言中的熟练程度相对应：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 3️⃣ Determine speech complexity
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 3️⃣ 确定演讲复杂度
- en: 'Here, we regulate the complexity level of the language the chatbot can use:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调整聊天机器人可以使用的语言复杂度级别：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 4️⃣ Put everything together!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 4️⃣ 把所有内容整合起来！
- en: 'Here’s what the instruction looks like for different learning modes:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是不同学习模式下的指令示例：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 5️⃣ Who speaks first?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 5️⃣ 谁先发言？
- en: 'Finally, we instruct the chatbot whether it should speak first or wait for
    the response from the opponent AI:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们指示聊天机器人是否应该先发言或等待对方AI的回应：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we have completed the prompt design 🎉 As a quick summary, this is what
    we have developed so far:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了提示设计🎉 简要总结一下，这就是我们迄今为止开发的内容：
- en: '![](../Images/6c9261f866e1940098eee750f07557ee.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6c9261f866e1940098eee750f07557ee.png)'
- en: The single chatbot class. (Image by author)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 单一聊天机器人类。（图片由作者提供）
- en: 3.2 Developing a dual-chatbot system
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 开发双聊天机器人系统
- en: Now we arrive at the exciting part! In this subsection, we will develop a dual-chatbot
    class to let two chatbots interact with each other 💬💬
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到了令人兴奋的部分！在这一小节中，我们将开发一个双聊天机器人类，让两个聊天机器人相互互动💬💬
- en: 🏗️ **Class Design**
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 🏗️ **类设计**
- en: 'Thanks to the previously developed single Chatbot class, we can effortlessly
    instantiate two chatbots in the class constructor:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于之前开发的单一聊天机器人类，我们可以轻松地在类构造函数中实例化两个聊天机器人：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `self.chatbots` is a dictionary designed to store information related to
    both bots:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.chatbots`是一个字典，用于存储与两个机器人相关的信息：'
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `self._reset_conversation_history` serves to initiate a fresh conversation
    history and provide the initial instructions to the chatbots:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`self._reset_conversation_history`用于启动一个新的对话历史并提供初始指令给聊天机器人：'
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To facilitate interaction between the two chatbots, we employ `self.step()`
    method. This method allows for one round of interaction between the two bots:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了促进两个聊天机器人之间的互动，我们使用了`self.step()`方法。此方法允许两个机器人之间进行一轮互动：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that we have embedded a method called `self.translate()`. The purpose
    of this method is to translate the script into English. This functionality could
    be useful for language learners as they can understand the meaning of the conversation
    generated in the target language.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们嵌入了一个名为`self.translate()`的方法。此方法的目的是将脚本翻译成英语。此功能对于语言学习者可能很有用，因为他们可以理解在目标语言中生成的对话的含义。
- en: 'To achieve the translation functionality, we can employ the basic `LLMChain`,
    which requires a backend LLM model and a prompt for instruction:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为实现翻译功能，我们可以使用基本的`LLMChain`，它需要一个后台LLM模型和一个指令提示：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, it could be beneficial for language learners to have a summary of
    the key language learning points of the generated conversation script, be it key
    vocabulary, grammar points, or function phrases. For that, we can include a `self.summary()`
    method:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，语言学习者能够获得生成对话脚本的关键语言学习点的总结可能是有益的，无论是关键词汇、语法点还是功能短语。为此，我们可以包含一个`self.summary()`方法：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Similar to the `self.translate()` method, we employed a basic `LLMChain` to
    perform the desired task. Note that we explicitly ask the language model to summarize
    key language learning points based on the user’s proficiency level.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`self.translate()`方法，我们使用了一个基本的`LLMChain`来执行所需的任务。请注意，我们明确要求语言模型根据用户的熟练程度总结关键的语言学习点。
- en: 'With that, we have completed the development of the dual-chatbot class 🥂 As
    a quick summary, this is what we have developed so far:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这一点，我们已经完成了双聊天机器人类的开发🥂 简要总结一下，这就是我们迄今为止开发的内容：
- en: '![](../Images/faa19b5a62676515982824900850cc7b.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/faa19b5a62676515982824900850cc7b.png)'
- en: The single chatbot & Dual-chatbot class. (Image by author)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 单一聊天机器人 & 双聊天机器人类。（图片由作者提供）
- en: 4\. App Interface Design with Streamlit
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 使用Streamlit进行应用程序界面设计
- en: We are now ready to develop the user interface 🖥️ For this project, we will
    use the Streamlit library to construct the frontend.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备开发用户界面🖥️ 对于这个项目，我们将使用Streamlit库来构建前端。
- en: If you’re unfamiliar, Streamlit is an open-source Python library for creating
    interactive web applications focused on data science and machine learning. It
    simplifies the process of building and deploying apps by providing an easy-to-use
    API, live code reloading for instant updates, interactive widgets for user input,
    support for data visualization libraries, and the ability to incorporate rich
    media.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉，Streamlit是一个开源Python库，用于创建专注于数据科学和机器学习的互动式Web应用程序。它通过提供易于使用的API、即时更新的实时代码重载、用于用户输入的互动小部件、对数据可视化库的支持以及包含丰富媒体的能力，简化了构建和部署应用程序的过程。
- en: 'Let’s initiate with a new Python script app.py, and import the necessary libraries:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个新的Python脚本app.py开始，并导入必要的库：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Alongside the main `streamlit`library, we also import the `streamlit_chat` library,
    a community-built Streamlit component specifically designed for creating chatbot
    UIs. Our previously-developed `DualChatbot` class is stored in the *chatbot.py*
    file, so we need to import that as well. Lastly, we import `gTTS`, which stands
    for *Google Text-to-Speech,* to add audio to the bot-generated conversation script
    in this project.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 除了主要的`streamlit`库，我们还导入了`streamlit_chat`库，这是一个由社区构建的Streamlit组件，专门用于创建聊天机器人用户界面。我们之前开发的`DualChatbot`类存储在*chatbot.py*文件中，因此也需要导入该文件。最后，我们导入`gTTS`，即*Google
    Text-to-Speech*，以为这个项目中的机器人生成的对话脚本添加音频。
- en: 'Before we configure the Streamlit interface, let’s first define the language
    learning settings:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置Streamlit界面之前，让我们首先定义语言学习设置：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `AVATAR_SEED` is used for generating different avatar icons for different
    chatbots.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`AVATAR_SEED`用于为不同的聊天机器人生成不同的头像图标。'
- en: 'We begin by setting up the basic layout of the user interface and establishing
    options for the user to select:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始设置用户界面的基本布局，并建立供用户选择的选项：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note the introduction of a `time_delay`variable. It’s used for specifying the
    waiting time between displaying two consecutive messages. If this delay is set
    to zero, the exchanges generated between two chatbots will appear in the app swiftly
    (limited only by OpenAI’s response time). However, for user experience, it could
    be beneficial to allow enough time for the user to read the generated message
    before the next exchange appears.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意引入了`time_delay`变量。它用于指定显示两个连续消息之间的等待时间。如果此延迟设置为零，则两个聊天机器人之间生成的交换将迅速出现在应用程序中（仅受限于OpenAI的响应时间）。然而，为了用户体验，在下一次交换出现之前，允许用户有足够的时间阅读生成的消息可能是有益的。
- en: 'Next, we initialize the Streamlit session state to store user-specific session
    data in the Streamlit app:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们初始化Streamlit会话状态以存储用户特定的会话数据：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here we answer two questions:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们回答两个问题：
- en: 1️⃣ First of all, why do we need “session_state”?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 1️⃣ 首先，我们为什么需要“session_state”？
- en: In Streamlit, every time the user interacts with the app, Streamlit reruns the
    entire script from top to bottom, updating the app’s output accordingly. However,
    this reactive nature of Streamlit can pose a challenge when you want to maintain
    user-specific data or preserve state across different interactions or pages within
    the app. Since Streamlit reloads the script on every user interaction, regular
    Python variables would lose their values, and the app would reset to its initial
    state.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在Streamlit中，每次用户与应用程序交互时，Streamlit会从头到尾重新运行整个脚本，更新应用程序的输出。然而，Streamlit的这种反应性特征在你想要维护用户特定数据或在不同交互或页面之间保留状态时可能会成为挑战。由于Streamlit在每次用户交互时都会重新加载脚本，常规Python变量会丢失其值，应用程序将重置为初始状态。
- en: This is where the session_state comes in. Session state in Streamlit provides
    a way to store and retrieve data that persists throughout the user’s session,
    even when the app is reloaded or the user navigates between different components
    or pages. It allows you to maintain stateful information and preserve the app’s
    context for each user.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`session_state`发挥作用的地方。Streamlit中的会话状态提供了一种存储和检索数据的方式，这些数据在用户会话期间会持久存在，即使应用程序被重新加载或用户在不同组件或页面之间导航时。它允许你保持状态信息并为每个用户保留应用程序的上下文。
- en: 2️⃣ Secondly, what are those variables stored in the session_state?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 2️⃣ 其次，`session_state`中存储了哪些变量？
- en: '“**bot1_mesg**” is a list, where each element of the list is a dictionary that
    holds the messages spoken by the first chatbot. It has the following keys: “role”,
    “content”, and “translation”. The same definition applies to the “**bot2_mesg**”.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: “**bot1_mesg**”是一个列表，其中每个元素都是一个字典，包含第一台聊天机器人说的话。它具有以下键：“role”、“content”和“translation”。同样的定义适用于“**bot2_mesg**”。
- en: “**batch_flag**” is a boolean flag to indicate whether the conversation exchanges
    are shown all at once or with a time delay. In the current design, the chats between
    two bots will appear with a time delay when their conversation is generated for
    the first time. Afterward, the user may want to see the translations of or add
    audio to the generated conversation, the stored conversation messages (in “**bot1_mesg**”
    and “**bot2_mesg**”) will be shown all at once. This is beneficial as we don’t
    need to call OpenAI API again to reduce cost and latency.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: “**batch_flag**” 是一个布尔标志，用于指示对话交流是否一次性显示或有时间延迟。在当前设计中，当两个聊天机器人之间的对话首次生成时，它们的聊天将会有时间延迟地出现。之后，用户可能希望查看生成对话的翻译或添加音频，存储的对话消息（在“**bot1_mesg**”和“**bot2_mesg**”中）将一次性显示。这是有利的，因为我们不需要再次调用
    OpenAI API，从而减少成本和延迟。
- en: “**translate_flag**” and “**audio_flag**” are used to indicate if the translation
    and/or audio will be shown next to the original conversation.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: “**translate_flag**” 和 “**audio_flag**” 用于指示翻译和/或音频是否会显示在原始对话旁边。
- en: “**message_counter**” is a counter that adds one whenever a message from chabot
    is displayed. The idea is to assign the message ID with this counter, as Streamlit
    requires that each UI component needs to have a unique ID.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: “**message_counter**” 是一个计数器，每当一个来自聊天机器人的消息显示时，它会加一。这个想法是将消息 ID 与此计数器关联，因为 Streamlit
    要求每个 UI 组件必须有唯一的 ID。
- en: 'Now we can introduce the logic of letting two chatbots interact and generate
    conversations:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以引入让两个聊天机器人互动并生成对话的逻辑：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Upon running the script for the first time, there will be no “**dual_chatbots**”
    key stored in the session_state (as the dual-chatbot has not been created yet).
    As a result, the code snippet shown above will be executed when the user hits
    the “**Generate**” button on the sidebar. The two chatbots will chat back and
    forth a given number of times, and all the conversation messages are recorded
    in the session_state. The `show_message()`function is a helper function designed
    to be the sole interface to style the message display. We will go back to it at
    the end of this section.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当第一次运行脚本时，会话状态中将没有“**dual_chatbots**”键（因为双聊天机器人尚未创建）。因此，当用户点击侧边栏上的“**Generate**”按钮时，上述代码片段将被执行。两个聊天机器人将往返聊天给定次数，所有对话消息都记录在会话状态中。`show_message()`
    函数是一个辅助函数，旨在成为唯一的接口来样式化消息显示。我们将在本节末尾再次回到它。
- en: 'Now, if the user interacts with the app and changes some settings, Streamlit
    will rerun the entire script from the top. Since we have already generated the
    desired conversation script, there is no need to invoke OpenAI API again. Instead,
    we can simply retrieve the stored information:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果用户与应用互动并更改一些设置，Streamlit 将从头开始重新运行整个脚本。由于我们已经生成了所需的对话脚本，因此无需再次调用 OpenAI
    API。相反，我们可以简单地检索存储的信息：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that there is another flag called “**first_time_exec**” in the session
    state. This is used to indicate if the originally generated script has already
    been shown on the app. If we remove this check, the same messages will appear
    twice when running the app for the first time.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意会话状态中还有一个名为“**first_time_exec**”的标志。这个标志用于指示原始生成的脚本是否已经在应用中显示。如果我们去掉这个检查，应用第一次运行时相同的消息将会出现两次。
- en: The only thing left is the inclusion of the summary of key learning points in
    the UI. For that, we can use `st.expander`. In Streamlit, `st.expander` is useful
    when we have a large amount of content or information that we want to present
    in a condensed form, initially hidden from view. When the user clicks the expander,
    the content within it will expand or collapse, thus revealing or hiding the additional
    details.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一任务是在 UI 中加入关键学习点的总结。为此，我们可以使用 `st.expander`。在 Streamlit 中，`st.expander`
    对于我们希望以简洁形式呈现的大量内容或信息很有用，最初隐藏视图。当用户点击扩展器时，内容将展开或折叠，从而显示或隐藏额外的细节。
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Since the summary of key learning points is also generated by calling OpenAI
    API, we can save the generated summary to the session_state so that the content
    can be retrieved if the script is run a second time.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于关键学习点的总结也是通过调用 OpenAI API 生成的，我们可以将生成的总结保存到会话状态中，以便如果脚本第二次运行时可以检索这些内容。
- en: 'Finally, let’s complete the Streamlit UI design with the helper function `show_message`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们用辅助函数 `show_message` 完成 Streamlit UI 设计：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'A few points warrant further explanation:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个要点需要进一步解释：
- en: 1️⃣ The `message()` object
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 1️⃣ `message()` 对象
- en: 'This is part of the `streamlit_chat` library and is used to display messages.
    In its simplest form, we have:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分属于 `streamlit_chat` 库，用于显示消息。在最简单的形式下，我们有：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![](../Images/3a8358fe3d3a897bcdca1aa15caa5e79.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3a8358fe3d3a897bcdca1aa15caa5e79.png)'
- en: (Image from streamlit_chat [GitHub repository](https://github.com/AI-Yash/st-chat))
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: (图片来自 streamlit_chat [GitHub 仓库](https://github.com/AI-Yash/st-chat))
- en: where the argument `is_user` determines if the message should be left-aligned
    or right-aligned. In our code snippet for `show_message`, we have also specified
    `avatar_style` and `seed` to set the avatar icons for two chatbots. The `key`
    argument is merely for assigning a unique ID for each message, as required by
    the Streamlit.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 其中参数 `is_user` 决定消息是左对齐还是右对齐。在我们的 `show_message` 代码片段中，我们还指定了 `avatar_style`
    和 `seed` 来设置两个聊天机器人的头像图标。`key` 参数仅用于为每条消息分配唯一的 ID，这是 Streamlit 所要求的。
- en: 2️⃣ Text-to-speech
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 2️⃣ 语音合成
- en: 'Here, we use gTTS library to create audio speech in the target language based
    on the generated script. This library is straightforward to use, but it does have
    a limitation: you can only have one voice. After the audio object is generated,
    we can use`st.audio` to create an audio player for each message in the app.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 gTTS 库基于生成的脚本创建目标语言的音频语音。这个库使用起来非常简单，但它有一个限制：你只能使用一种声音。在生成音频对象后，我们可以使用
    `st.audio` 为应用中的每条消息创建一个音频播放器。
- en: 'Great! We have now completed the UI design :) Type the following command in
    your terminal:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们现在已经完成了 UI 设计 :) 在终端中输入以下命令：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You should see the app in your browser and be able to interact with it. Great
    job!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在浏览器中看到应用，并能够与其互动。干得好！
- en: '![](../Images/039cdf24564a65d3616a9dcf5c2ab365.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/039cdf24564a65d3616a9dcf5c2ab365.png)'
- en: The interface of the developed language learning app. (Image by author)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 开发的语言学习应用界面。（作者提供的图片）
- en: 5\. Learnings and Future Extensions
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5\. 学习与未来扩展
- en: Before we finish, I want to share with you some key learnings from this project
    and potential directions for future enhancements.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束之前，我想与你分享一些来自这个项目的关键学习和未来扩展的潜在方向。
- en: 1️⃣ How to stop the conversation?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 1️⃣ 如何结束对话？
- en: 'This problem is actually harder than it looks if you want to do it right. Ideally,
    we would like the conversation to end naturally. However, in some of my experiments,
    I noticed that the chatbots will just keep saying “thank you” or “goodbye” to
    each other toward the end of the conversation, which unnecessarily elongated the
    conversation. A few potential solutions to this issue include:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果想要正确实现，这个问题实际上比看起来要复杂得多。理想情况下，我们希望对话自然结束。然而，在我的一些实验中，我注意到聊天机器人在对话结束时会不断互相说“谢谢”或“再见”，这不必要地延长了对话。一些可能的解决方案包括：
- en: 'Hard Limiting of Exchange Rounds: This is perhaps the easiest solution and
    it’s also what we have adopted in this project. However, it might not always be
    ideal as it can lead to prematurely terminated conversations. As a workaround,
    we’ve instructed the bot in the `SystemMessage`to finish the conversation within
    a set number of exchanges.'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 交换轮次的硬限制：这可能是最简单的解决方案，也是我们在这个项目中采用的解决方案。然而，它可能并不总是理想的，因为它可能导致对话被过早终止。作为解决方法，我们已经在
    `SystemMessage` 中指示机器人在设定的交换轮次内完成对话。
- en: 'Use of “Signal Words”: The chatbot could be programmed to say specific ‘signal
    words’ (e.g., ‘Conversation over’) when it deems the conversation to have naturally
    ended. A logic could then be implemented to spot these ‘signal words’ and end
    the loop accordingly.'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“信号词”：聊天机器人可以被编程以在认为对话自然结束时说出特定的“信号词”（例如，“对话结束”）。然后可以实现逻辑来检测这些“信号词”并相应地结束循环。
- en: 'Post-Processing of the Conversation: Once the chatbots have generated the conversation,
    another LLM could be deployed as an “editor” to prune the conversation. This could
    be an effective approach. However, its drawbacks may include designing an additional
    prompt, incurring extra costs from calling the OpenAI API again, and increasing
    latency.'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对话的后处理：一旦聊天机器人生成了对话，可以部署另一个 LLM 作为“编辑器”来修剪对话。这可能是一个有效的方法。然而，其缺点可能包括设计额外的提示、调用
    OpenAI API 可能产生的额外费用以及增加的延迟。
- en: 2️⃣ How to control language complexity?
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 2️⃣ 如何控制语言复杂性？
- en: 'In my experience, the developed chatbots seemed to have difficulty following
    the instructions regarding the language complexity used in the chat: sometimes
    “intermediate” level of language usage will appear even though the proficiency
    level is set to be “beginner”. One reason may be the current prompt design is
    not sufficient for specifying the nuance between different complexity levels.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，开发的聊天机器人似乎在遵循语言复杂度的指示方面存在困难：有时即使熟练度设定为“初学者”，也会出现“中级”语言使用。这可能是因为当前的提示设计不足以明确区分不同复杂度级别之间的细微差别。
- en: 'There are a couple of ways to address this issue: to begin with, we can perform
    *in-context learning*. That is to say, we provide examples to the chatbots and
    show them what kind of language usage we desire for different complexity levels.
    Another way forward is similar to what we have discussed above: we could use another
    LLM to adjust the complexity of the conversation. Essentially, this extra LLM
    can use the generated script as a starting point and rewrite a new script to match
    the desired proficiency level of the user.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题有几种方法：首先，我们可以进行*上下文学习*。也就是说，我们提供示例给聊天机器人，并展示我们期望在不同复杂度级别中使用的语言。另一种方法与我们之前讨论的类似：我们可以使用另一个LLM来调整对话的复杂性。实质上，这个额外的LLM可以利用生成的脚本作为起点，并重写一个新的脚本，以匹配用户期望的熟练程度。
- en: 3️⃣ Better text-to-speech library?
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 3️⃣ 更好的文本到语音库？
- en: 'The current project only utilized the simple gTTS library to synthesize voices,
    there’s room for improvement. More advanced libraries offer multilingual support,
    multiple-speaker support, and more natural-sounding speech. To name a few: [*pyttsx3*](https://github.com/nateshmbhat/pyttsx3),
    *Amazon Polly*, *IBM Watson TTS*, *Microsoft Azure Cognitive Services TTS*, [*Coqui.ai-TTS*](https://github.com/coqui-ai/TTS),
    as well as a recent release from Meta, [*Voicebox*](https://ai.facebook.com/blog/voicebox-generative-ai-model-speech/).'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当前项目仅使用了简单的gTTS库来合成语音，还有改进的空间。更先进的库提供了多语言支持、多说话者支持以及更自然的语音。比如：[*pyttsx3*](https://github.com/nateshmbhat/pyttsx3)、*Amazon
    Polly*、*IBM Watson TTS*、*Microsoft Azure Cognitive Services TTS*、[*Coqui.ai-TTS*](https://github.com/coqui-ai/TTS)，以及Meta最近发布的[*Voicebox*](https://ai.facebook.com/blog/voicebox-generative-ai-model-speech/)。
- en: 4️⃣ More tests with different scenarios?
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 4️⃣ 更多不同场景的测试？
- en: Due to time constraints, I tested only a few scenarios to ascertain whether
    the chatbots can generate meaningful conversations. These tests identified issues
    in my initial prompt design, providing opportunities for refinement. Additional
    scenario tests would likely reveal overlooked areas and suggest ways to enhance
    the prompt. I’ve compiled a [comprehensive list](https://github.com/ShuaiGuo16/language_learning_app/blob/main/Scenario_ideas.pdf)
    of typical “conversation” scenarios and “debate” topics. Feel free to try them
    out and assess the performance of the current prompt design.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 由于时间限制，我只测试了几个场景，以确定聊天机器人是否能够生成有意义的对话。这些测试发现了我最初提示设计中的问题，提供了改进的机会。额外的场景测试可能会揭示被忽视的领域，并提出改进提示的方法。我已编制了一份[全面的列表](https://github.com/ShuaiGuo16/language_learning_app/blob/main/Scenario_ideas.pdf)
    ，包括典型的“对话”场景和“辩论”话题。随意尝试这些场景，并评估当前提示设计的表现。
- en: 5️⃣ Include other forms of Generative AI?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 5️⃣ 包含其他形式的生成型AI？
- en: This project primarily explored text-to-text (chatbot) and text-to-speech generative
    AI techniques. We could enhance the user experience further by leveraging other
    forms of generative AI, such as **text-to-image** or **text-to-video**.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目主要探索了文本到文本（聊天机器人）和文本到语音的生成型AI技术。我们可以通过利用其他形式的生成型AI，如**文本到图像**或**文本到视频**，进一步提升用户体验。
- en: '**Text-to-Image**: For every user-inputted scenario, we could use text-to-image
    models to create corresponding figures. Displaying these figures alongside the
    generated conversation can provide visual context and enhance language learning
    engagement. Models like *StableDiffusion*, *Midjourney*, and *DALL-E* could be
    used for this purpose.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本到图像**：对于每个用户输入的场景，我们可以使用文本到图像模型来创建相应的图像。将这些图像与生成的对话一起展示，可以提供视觉上下文并增强语言学习的参与感。像*StableDiffusion*、*Midjourney*和*DALL-E*这样的模型可以用于此目的。'
- en: '**Text-to-Video**: To make the app more multimedia-focused, we could generate
    videos based on input scenarios. A tool like [*RunwayML*](https://runwayml.com/)could
    help with this. Furthermore, we might even attempt to create digital humans to
    present the conversation, which could dramatically enhance user experience if
    executed correctly. [*Synthesia*](https://www.synthesia.io/tools/digital-human?utm_term=digital+avatar&utm_campaign=Basic+Search&utm_source=google&utm_medium=cpc&hsa_acc=5132031546&hsa_cam=17790491238&hsa_grp=142067774834&hsa_ad=611252817304&hsa_src=g&hsa_tgt=aud-2090130405830%3Akwd-625911181570&hsa_kw=digital+avatar&hsa_mt=p&hsa_net=adwords&hsa_ver=3&gclid=Cj0KCQjw4s-kBhDqARIsAN-ipH35DgWBi1zs_i0xDB5FBPvzMRgKLYsLvuN2d8MEAdKbw9jFL1TYB2saAsy-EALw_wcB)might
    be a suitable tool for this purpose.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本转视频**：为了让应用更具多媒体功能，我们可以根据输入场景生成视频。像[*RunwayML*](https://runwayml.com/)这样的工具可以帮助实现这一点。此外，我们甚至可以尝试创建数字人来呈现对话，如果执行得当，这可能会大大提升用户体验。[*Synthesia*](https://www.synthesia.io/tools/digital-human?utm_term=digital+avatar&utm_campaign=Basic+Search&utm_source=google&utm_medium=cpc&hsa_acc=5132031546&hsa_cam=17790491238&hsa_grp=142067774834&hsa_ad=611252817304&hsa_src=g&hsa_tgt=aud-2090130405830%3Akwd-625911181570&hsa_kw=digital+avatar&hsa_mt=p&hsa_net=adwords&hsa_ver=3&gclid=Cj0KCQjw4s-kBhDqARIsAN-ipH35DgWBi1zs_i0xDB5FBPvzMRgKLYsLvuN2d8MEAdKbw9jFL1TYB2saAsy-EALw_wcB)可能是一个合适的工具。'
- en: 6️⃣ More language learning settings?
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 6️⃣ 更多语言学习设置？
- en: At present, our app mainly focuses on “conversation” and “debate” learning modes.
    However, the potential for growth is substantial. For instance, we could introduce
    other learning modes such as “storytelling” and “cultural learning.” Additionally,
    we could expand the chatbots’ interaction to cater to more professional and technical
    scenarios. These might include settings like meetings, negotiations, or sectors
    like sales and marketing, law, engineering, and more. Such a feature could be
    helpful for language learners aiming to bolster their *professional* language
    proficiency.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用主要集中于“对话”和“辩论”学习模式。然而，增长潜力巨大。例如，我们可以引入其他学习模式，如“讲故事”和“文化学习”。此外，我们可以扩展聊天机器人的互动，以适应更多专业和技术场景。这些可能包括会议、谈判，或销售与市场、法律、工程等领域。这样的功能可能对那些希望提升*专业*语言能力的语言学习者有帮助。
- en: 6\. Conclusion
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6\. 结论
- en: Wow, what a journey! Thanks a lot for sticking with me so far :) From designing
    prompts to creating chatbots, we’ve certainly covered a lot of ground. Using LangChain
    and Streamlit, we’ve built a functional dual-chatbot system that can be used for
    learning language, not bad!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，多么精彩的旅程！非常感谢你一直陪伴我 :) 从设计提示到创建聊天机器人，我们确实覆盖了很多领域。使用LangChain和Streamlit，我们构建了一个功能齐全的双聊天机器人系统，可以用于语言学习，不错吧！
- en: If you find my content useful, you could buy me a coffee [here](https://www.buymeacoffee.com/Shuaiguo09f)
    🤗 Thank you very much for your support!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得我的内容有用，可以通过[这里](https://www.buymeacoffee.com/Shuaiguo09f)买杯咖啡给我🤗 非常感谢你的支持！
