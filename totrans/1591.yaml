- en: 'Object Oriented Data Science: Refactoring Code'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/object-oriented-data-science-refactoring-code-5bcb4ae7ce72](https://towardsdatascience.com/object-oriented-data-science-refactoring-code-5bcb4ae7ce72)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Elevating machine learning models and data science products with efficient code
    and python classes.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@molly.ruby?source=post_page-----5bcb4ae7ce72--------------------------------)[![Molly
    Ruby](../Images/2a493bd01057722138857a90035347cd.png)](https://medium.com/@molly.ruby?source=post_page-----5bcb4ae7ce72--------------------------------)[](https://towardsdatascience.com/?source=post_page-----5bcb4ae7ce72--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----5bcb4ae7ce72--------------------------------)
    [Molly Ruby](https://medium.com/@molly.ruby?source=post_page-----5bcb4ae7ce72--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----5bcb4ae7ce72--------------------------------)
    ·7 min read·Aug 24, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5a7acfc2f7f532c4ce9e966a929810ad.png)'
  prefs: []
  type: TYPE_IMG
- en: Image created by the author.
  prefs: []
  type: TYPE_NORMAL
- en: For data scientists, code is the backbone of analysis and decision-making. As
    data science applications grow more intricate, from machine learning models embedded
    in software to complex data pipelines orchestrating vast amounts of information,
    developing clean, organized, and maintainable code becomes crucial. Object-oriented
    programming (OOP) unlocks flexibility and efficiencies that enable data scientists
    to respond to changing requirements with agility. OOP introduces the concept of
    classes, which serve as blueprints for creating objects that encapsulate both
    data and the operations that manipulate it. This paradigm shift allows data scientists
    to go beyond traditional functional approaches, promoting modular design and code
    reusability.
  prefs: []
  type: TYPE_NORMAL
- en: In this article, we’ll explore the benefits of refactoring data science code
    by creating classes and deploying object-oriented techniques, and how this approach
    can enhance modularity and reusability.
  prefs: []
  type: TYPE_NORMAL
- en: The Power of Classes in Data Science
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In traditional data science workflows, functions have been the approach for
    encapsulating logic. This is often sufficient as functions allow developers to
    minimize repeated code. However, as projects evolve, maintaining an extensive
    collection of functions might lead to code that’s challenging to navigate, debug,
    and scale.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where classes come into play. A class is a blueprint for creating objects,
    which bundle both data and functions (called methods) that operate on that data.
    By organizing code into classes, developers can achieve several advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modularity and Encapsulation: Classes promote modularity by grouping related
    functionality together. Each class encapsulates its own attributes (data) and
    methods (functions), reducing the risk of global variable pollution and the potential
    for naming conflicts. This helps maintain a clear separation of concerns, making
    code easier to understand and modify.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Reusability: Classes encourage reusability by providing a consistent interface
    for similar tasks across different parts of the project. Once a class is defined,
    it can be instantiated whenever needed and its methods can be used to achieve
    consistent results.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '4\. Inheritance and Polymorphism: Inheritance allows developers to create subclasses
    that inherit attributes and methods from a parent class. This promotes code reuse
    while enabling customization for specific tasks. Polymorphism, another OOP concept,
    lets developers use the same method name across different classes, adapting behavior
    based on the specific implementation.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '5\. Testing and Debugging: Classes facilitate unit testing, as test cases can
    target individual methods within a class, making it easier to identify and fix
    issues, improving the overall robustness of your codebase.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Refactoring to Classes: A Theoretical Example'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s consider a scenario where you’re working on a machine learning project
    that involves data preprocessing, model training, and evaluation. Initially, you
    might have a collection of functions for each step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: While functional decomposition works, over time, there may be many steps that
    occur within the preprocessing, training, and evaluation. This can become challenging
    to manage these functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refactoring the code into classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'By breaking down the workflow into classes, there is more organization, and
    the structure is easier to read and maintain. Each class handles a specific aspect
    of the process. They can be instantiated as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the classes have incorporating classes provides an extra layer
    of structure and flexibility that improve the workflow and usability of the code.
    By embracing the power of classes, this example creates a more robust and scalable
    code base.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refactoring to Classes: A Practical Example'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a practical example, I recently refactored code that was developed in [this
    repository](https://github.com/mollyryanruby/sales_forecasting) 3 years ago into
    [a new repository](https://github.com/mollyryanruby/auto_forecast) to show the
    difference in the code before and after refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the initial repository, many functions encompassed modeling tasks as several
    different models were trained and tested. In the refactored version, there is
    a model class SalesForecasting that encompasses all the modeling tasks. This is
    easier to read and allows the package to be deployed more efficiently as SalesForecasting
    and be instantiated multiple times with different inputs. As a preview the class
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The class “SalesForecasting” serves as a comprehensive blueprint for data-driven
    businesses to anticipate future sales trends through the application of various
    predictive models. Within this class, data scientists can harness the power of
    different modeling techniques, including Linear Regression, Random Forest, XGBoost,
    LSTM (Long Short-Term Memory), and ARIMA (AutoRegressive Integrated Moving Average).
    By encapsulating the forecasting workflow within this class, the process of model
    fitting, prediction, and evaluation becomes streamlined and consistent across
    different model types. Through the “SalesForecasting” class, data scientists can
    efficiently experiment with different algorithms and easily maintain the code
    base.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented programming is a tool for data scientists to architect code
    that mirrors the intricacies of the real-world systems they analyze, enabling
    them to extract valuable insights while maximizing agility. Although python intends
    for classes to be used for instantiation and inheritance, the example above shows
    a first step in which classes are leveraged for modularizing code. As data science
    capabilities expand and teams grow, maintaining efficient code is essential.
  prefs: []
  type: TYPE_NORMAL
- en: '[See the full refactored code base here.](https://github.com/mollyryanruby/auto_forecast/tree/main/auto_forecast)'
  prefs: []
  type: TYPE_NORMAL
