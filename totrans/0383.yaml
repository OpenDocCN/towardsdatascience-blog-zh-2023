- en: 'Beyond Numpy and Pandas: Unlocking the Potential of Lesser-Known Python Libraries'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/beyond-numpy-and-pandas-unlocking-the-potential-of-lesser-known-python-libraries-86d2bdc4d230](https://towardsdatascience.com/beyond-numpy-and-pandas-unlocking-the-potential-of-lesser-known-python-libraries-86d2bdc4d230)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 3 Python libraries for scientific computation you should know as a data professional
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://federicotrotta.medium.com/?source=post_page-----86d2bdc4d230--------------------------------)[![Federico
    Trotta](../Images/e997e3a96940c16ab5071629016d82fd.png)](https://federicotrotta.medium.com/?source=post_page-----86d2bdc4d230--------------------------------)[](https://towardsdatascience.com/?source=post_page-----86d2bdc4d230--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----86d2bdc4d230--------------------------------)
    [Federico Trotta](https://federicotrotta.medium.com/?source=post_page-----86d2bdc4d230--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----86d2bdc4d230--------------------------------)
    ·12 min read·Jul 6, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8d87b395925ef2d403f2cee6542c46b9.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by [OrMaVaredo](https://pixabay.com/it/users/ormavaredo-14515736/?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=5826755)
    on [Pixabay](https://pixabay.com/it//?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=5826755)
  prefs: []
  type: TYPE_NORMAL
- en: Python is one of the most used programming languages in the world and provides
    developers with a wide range of libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, when it comes to data manipulation and scientific computation, we generally
    think of libraries such as `Numpy`, `Pandas`, or `SciPy`.
  prefs: []
  type: TYPE_NORMAL
- en: In this article, we introduce 3 Python libraries you may be interested in.
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Dask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introducing Dask
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dask is a flexible parallel computing library that enables distributed computing
    and parallelism for large-scale data processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, why should we use Dask? As they say on [their website](https://www.dask.org/):'
  prefs: []
  type: TYPE_NORMAL
- en: Python has grown to become the dominant language both in data analytics and
    general programming. This growth has been fueled by computational libraries like
    NumPy, pandas, and scikit-learn. However, these packages weren’t designed to scale
    beyond a single machine. Dask was developed to natively scale these packages and
    the surrounding ecosystem to multi-core machines and distributed clusters when
    datasets exceed memory.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'So, one of the common uses of Dask, [as they say](https://docs.dask.org/en/latest/dataframe.html),
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dask DataFrame is used in situations where pandas is commonly needed, usually
    when pandas fails due to data size or computation speed:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '- Manipulating large datasets, even when those datasets don’t fit in memory'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '- Accelerating long computations by using many cores'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '- Distributed computing on large datasets with standard pandas operations like
    groupby, join, and time series computations'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'So, Dask is a good choice when we need to deal with huge Pandas data frames.
    This is because Dask:'
  prefs: []
  type: TYPE_NORMAL
- en: Allows users to manipulate 100GB+ datasets on a laptop or 1TB+ datasets on a
    workstation
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which is a pretty impressive result.
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens under the hood, is that:'
  prefs: []
  type: TYPE_NORMAL
- en: Dask DataFrames coordinate many pandas DataFrames/Series arranged along the
    index. A Dask DataFrame is partitioned *row-wise*, grouping rows by index value
    for efficiency. These pandas objects may live on disk or on other machines.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'So, we have something like that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/71811bfd3b02b98adc658fe6251dc6ed.png)'
  prefs: []
  type: TYPE_IMG
- en: The difference between a Dask and a Pandas data frame. Image by Author, freely
    inspired by one on the Dask website already quoted.
  prefs: []
  type: TYPE_NORMAL
- en: Some features of Dask in action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, we need to install Dask. We can do it via `pip` or `conda` like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**FEATURE ONE: OPENING A CSV FILE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first feature we can show of Dask is how we can open a CSV. We can do it
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'So, as we can see in the code, the way we use Dask is very similar to Pandas.
    In particular:'
  prefs: []
  type: TYPE_NORMAL
- en: We use the method `read_csv()` exactly as in Pandas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We intercept a column exactly as in Pandas. In fact, if we had a Pandas data
    frame called `df` we’d intercept a column this way: `df[''column_name'']`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We apply the `mean()` method to the intercepted column similar to Pandas, but
    here we also need to add the method `compute()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, even if the methodology of opening a CSV file it’s the same as in Pandas,
    under the hood Dask is effortlessly processing a large dataset that exceeds the
    memory capacity of a single machine.
  prefs: []
  type: TYPE_NORMAL
- en: This means that we can’t see any actual difference, except the fact that a large
    data frame can’t be opened in Pandas, but in Dask we can.
  prefs: []
  type: TYPE_NORMAL
- en: '**FEATURE TWO: SCALING MACHINE LEARNING WORKFLOWS**'
  prefs: []
  type: TYPE_NORMAL
- en: We can use Dask to also create a classification dataset with a huge number of
    samples. We can then split it into the train and the test sets, fit the train
    set with an ML model, and calculate predictions for the test set.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This example stresses the ability of Dask to handle huge datasets even in the
    case of a Machine Learning problem, by distributing computations across multiple
    cores.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, we can create a “Dask dataset” for a classification case with
    the method `dask_datasets.make_classification()`, and we can specify the number
    of samples and chunks (even, very huge!).
  prefs: []
  type: TYPE_NORMAL
- en: Similarly as before, the predictions are obtained with the method `compute()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**FEATURE THREE: EFFICIENT IMAGE PROCESSING**'
  prefs: []
  type: TYPE_NORMAL
- en: The power of parallel processing that Dask utilizes can also be applied to images.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, we could open multiple images, resize them, and save them resized.
    We can do it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'So, here’s the process:'
  prefs: []
  type: TYPE_NORMAL
- en: We open all the “.jpg” images in the current folder (or in a folder that you
    can specify) with the method `dask_image.imread.imread("image*.jpg")`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We resize them all at 300x300 using a list comprehension in the method `da.stack()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We compute the result with the method `compute()`, as we did before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We save all the resized images with the for cycle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2\. SymPy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introducing Sympy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you need to make mathematical calculations and computations and want to stick
    to Python, you can try Sympy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Indeed: why use other tools and software, when we can use our beloved Python?'
  prefs: []
  type: TYPE_NORMAL
- en: 'As per what they write [on their website](https://www.sympy.org/en/index.html),
    Sympy is:'
  prefs: []
  type: TYPE_NORMAL
- en: a Python library for symbolic mathematics. It aims to become a full-featured
    computer algebra system (CAS) while keeping the code as simple as possible in
    order to be comprehensible and easily extensible. SymPy is written entirely in
    Python.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'But why use SymPy? They suggest:'
  prefs: []
  type: TYPE_NORMAL
- en: SymPy is…
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**- Free:** Licensed under BSD, SymPy is free both as in speech and as in beer.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**- Python-based:** SymPy is written entirely in Python and uses Python for
    its language.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**- Lightweight:** SymPy only depends on mpmath, a pure Python library for
    arbitrary floating point arithmetic, making it easy to use.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**- A library:** Beyond use as an interactive tool, SymPy can be embedded in
    other applications and extended with custom functions.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So, it basically has all the characteristics that can be loved by Python addicts!
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see some of its features.
  prefs: []
  type: TYPE_NORMAL
- en: Some features of SymPy in action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, we need to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**FEATURE ONE: SOLVING AN ALGEBRAIC EQUATION**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need to solve an algebraic equation, we can use SymPy like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'So, that’s the process:'
  prefs: []
  type: TYPE_NORMAL
- en: We define the symbols of the equation with the method `symbols()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We write the algebraic equation with the method `Eq`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We solve the equation with the method `solve()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When I was at the University I used different tools to solve these kinds of
    problems, and I have to say that SymPy, as we can see, is very readable and user-friendly.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, indeed: it’s a Python library, so how could that be any different?'
  prefs: []
  type: TYPE_NORMAL
- en: '**FEATURE TWO: CALCULATING DERIVATIVES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculating derivatives is another task we may mathematically need, for a lot
    of reasons when analyzing data. Often, we may need calculations for any reason,
    and SympY really simplifies this process. In fact, we can do it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'So, as we can see, the process is very simple and self-explainable:'
  prefs: []
  type: TYPE_NORMAL
- en: We define the symbol of the function we’re deriving with `symbols()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We calculate the derivative with `diff()` specifying the function and the symbol
    we’re calculating the derivative (this is an absolute derivative, but we could
    perform even partial derivatives in the case of functions that have `x` and `y`
    variables).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And if we test it, we’ll see that the result arrives in a matter of 2 or 3 seconds.
    So, it’s also pretty fast.
  prefs: []
  type: TYPE_NORMAL
- en: '**FEATURE THREE: CALCULATING INTEGRATIONS**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, if SymPy can calculate derivatives, it can also calculate integrations.
    Let’s do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So, here we use the method `integrate()`, specifying the function to integrate
    and the variable of integration.
  prefs: []
  type: TYPE_NORMAL
- en: Couldn’t it be easier?!
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Xarray
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introducing Xarray
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Xarray is a Python library that extends the features and functionalities of
    NumPy, giving us the possibility to work with labeled arrays and datasets.
  prefs: []
  type: TYPE_NORMAL
- en: 'As they say [on their website](https://docs.xarray.dev/en/stable/), in fact:'
  prefs: []
  type: TYPE_NORMAL
- en: Xarray makes working with labeled multi-dimensional arrays in Python simple,
    efficient, and fun!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'And [also](https://docs.xarray.dev/en/stable/getting-started-guide/why-xarray.html):'
  prefs: []
  type: TYPE_NORMAL
- en: Xarray introduces labels in the form of dimensions, coordinates and attributes
    on top of raw NumPy-like multidimensional arrays, which allows for a more intuitive,
    more concise, and less error-prone developer experience.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In other words, it extends the functionality of NumPy arrays by adding labels
    or coordinates to the array dimensions. These labels provide metadata and enable
    more advanced analysis and manipulation of multi-dimensional data.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in NumPy, arrays are accessed using integer-based indexing.
  prefs: []
  type: TYPE_NORMAL
- en: In Xarray, instead, each dimension can have a label associated with it, making
    it easier to understand and manipulate the data based on meaningful names.
  prefs: []
  type: TYPE_NORMAL
- en: For example, instead of accessing data with `arr[0, 1, 2]`, we can use `arr.sel(x=0,
    y=1, z=2)` in Xarray, where `x`, `y`, and `z` are dimension labels.
  prefs: []
  type: TYPE_NORMAL
- en: This makes the code much more readable!
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s see some features of Xarray.
  prefs: []
  type: TYPE_NORMAL
- en: Some features of Xarray in action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As usual, to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**FEATURE ONE: WORKING WITH LABELED COORDINATES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want to create some data related to temperature and we want to label
    these with coordinates like latitude and longitude. We can do it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And if we print them we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'So, let’s see the process step-by-step:'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve created the temperature values as a NumPy array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ve defined the latitudes and longitueas values as NumPy arrays.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ve stored all the data in an Xarray array with the method `DataArray()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ve selected a subset of the latitudes and longitudes with the method `sel()`
    that selects the values we want for our subset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The result is also easily readable, so labeling is really helpful in a lot of
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: '**FEATURE TWO: HANDLING MISSING DATA**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we’re collecting data related to temperatures during the year. We want
    to know if we have some null values in our array. Here''s how we can do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: And so we obtain that we have 10 null values.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if we take a look closely at the code, we can see that we can apply Pandas’
    methods to an Xarray like `isnull.sum()`, as in this case, that counts the total
    number of missing values.
  prefs: []
  type: TYPE_NORMAL
- en: '**FEATURE ONE: HANDLING AND ANALYZING MULTI-DIMENSIONAL DATA**'
  prefs: []
  type: TYPE_NORMAL
- en: The temptation to handle and analyze multi-dimensional data is high when we
    have the possibility to label our arrays. So, why not try it?
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose we’re still collecting data related to temperatures at
    certain latitudes and longitudes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We may want to calculate the mean, the max, and the median temperatures. We
    can do it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: And we obtained what we wanted, also in a clearly readable way.
  prefs: []
  type: TYPE_NORMAL
- en: And again, as before, to calculate the max, min, and mean values of temperatures
    we’ve used Pandas’ functions applied to an array.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this article, we’ve shown three libraries for scientific calculation and
    computation.
  prefs: []
  type: TYPE_NORMAL
- en: While SymPy can be the substitute for other tools and software, giving us the
    possibility to use Python code to compute mathematical calculations, Dask and
    Xarray extend the functionalities of other libraries, helping us in situations
    where we may have difficulties with other most known Python libraries for data
    analysis and manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5079e3af9eda458328cb258c452fb935.png)'
  prefs: []
  type: TYPE_IMG
- en: Federico Trotta
  prefs: []
  type: TYPE_NORMAL
- en: Hi, I’m Federico Trotta and I’m a freelance Technical Writer.
  prefs: []
  type: TYPE_NORMAL
- en: Want to collaborate with me? [Contact me](https://bio.link/federicotrotta).
  prefs: []
  type: TYPE_NORMAL
