- en: Looking through the Window— Calculating customer lifetime value with new DAX
    functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/looking-through-the-window-calculating-customer-lifetime-value-with-new-dax-functions-9cce2d0699d](https://towardsdatascience.com/looking-through-the-window-calculating-customer-lifetime-value-with-new-dax-functions-9cce2d0699d)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: New window functions are one of the most important enhancements to the DAX language
    ever! Learn how to leverage them to calculate a customer lifetime value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://datamozart.medium.com/?source=post_page-----9cce2d0699d--------------------------------)[![Nikola
    Ilic](../Images/9fab894b9696c0dfd80c5173188b720b.png)](https://datamozart.medium.com/?source=post_page-----9cce2d0699d--------------------------------)[](https://towardsdatascience.com/?source=post_page-----9cce2d0699d--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----9cce2d0699d--------------------------------)
    [Nikola Ilic](https://datamozart.medium.com/?source=post_page-----9cce2d0699d--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----9cce2d0699d--------------------------------)
    ·7 min read·Jan 3, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6190e47157c687068627731da77f3602.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by Pixabay on Pexels
  prefs: []
  type: TYPE_NORMAL
- en: In my previous “life” as a SQL professional, I’ve been using T-SQL window functions
    extensively for various analytic tasks. I’ve described one of the possible use
    cases in [this article](https://data-mozart.com/island-adventures-with-t-sql-window-functions/),
    but there are literally dozen of scenarios that can be quickly and intuitively
    solved by using window functions.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, when I transitioned to Power BI, I was quite surprised (not to say
    disappointed) that there is no DAX equivalent to SQL window functions. Ok, we
    could have solved these challenges of performing different calculations over a
    certain set of rows, by writing more complex DAX — but, honestly, that was very
    often a really painful experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, I was beyond excited when Power BI Desktop December 2022 update announced
    a brand new set of DAX functions — collectively called window functions — that
    should achieve the same goal as SQL window functions. At this moment, there are
    three DAX window functions: ***OFFSET***, ***INDEX***, and ***WINDOW***.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn more about these functions and how they work behind the
    scenes, I strongly recommend reading [this article from Jeffrey Wang](https://pbidax.wordpress.com/2022/12/15/introducing-dax-window-functions-part-1/)
    — this is the best starting point for diving deeper into DAX window functions.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re specifically interested in the OFFSET function, I encourage you to
    read [this great article](https://www.minceddata.info/2022/12/14/unlock-an-ample-new-world-by-seeing-through-a-window/)
    written by my friend Tom Martens, or [this one](https://www.linkedin.com/pulse/offset-its-usage-calculation-groups-%C5%A1t%C4%9Bp%C3%A1n-re%C5%A1l/)
    by Štěpán Rešl.
  prefs: []
  type: TYPE_NORMAL
- en: In this article, I’ll not spend too much time explaining the ins and outs of
    the window functions, as I want to focus on explaining how you can leverage these
    functions to satisfy a very common business request — calculate the lifetime value
    of the customer.
  prefs: []
  type: TYPE_NORMAL
- en: Customer lifetime value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s start with understanding what is a customer lifetime value. Well, it’s
    a broad term and may be interpreted in many possible ways. In our case, we want
    to provide a deep insight into the behavior of a single customer — for example,
    how many orders they placed, what is the total amount they spent on our products,
    how many days passed between their orders, and how this compares to the average
    of all customers. Finally, we want to know how loyal are our customers — meaning,
    how many days passed between their first and last order.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s begin with a very basic scenario. I’m analyzing two customers from
    the Adventure Works dataset: Adam Young and Alexandra Jenkins. Here is the summary
    of their orders and total sales amount:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ebf024c6f0e4fc61a16def9414c437d8.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: 'The first concept to understand here is that we want to treat each customer
    as a separate “entity” — meaning, we want to create a “window” for each customer
    and analyze figures for that specific set of rows. In our case, we will have two
    “windows” here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6673de0e94e2a712aea076f31b4dcbfd.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Window functions in DAX can work in two different ways — either by operating
    on a relative (REL) value, based on the current row (again, read Jeffrey’s article
    to understand how the current row is determined), or by operating on an absolute
    (ABS) value. In my case, I always want my window to start at the first row of
    the partition (each customer represents a separate partition), and finish on the
    last row of the partition.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s create a measure that will calculate a running total of order quantity
    and sales for every partition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let’s stop for a moment and explain this measure definition. As a CALCULATE
    filter modifier, we’re going to use a new window DAX function WINDOW. The first
    argument (1) determines where the window starts. Because the second argument is
    ABS (absolute), this means that the window starts at the beginning of the partition.
    Next, we define where the window ends.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are using a negative value (-1) and ABS, this means that the window
    ends in the last row of the partition. After that, we are defining a table expression
    from which the output row will be returned. Finally, data will be sorted by date
    within the window (starting with the earliest date), and partitioning will be
    performed on a customer (each customer is a separate “window”).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1df0f364a0adbec4c8e86b7b2546beba.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have a running total for each customer! So, we can for example now
    calculate a percentage of each individual purchase within the whole:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/4a25ae0d6db928847c497106b013ed16.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, so good! Let’s do some more cool stuff. First, I’ll calculate how many
    days passed between two consecutive orders. For that task, another DAX window
    function comes to the rescue: OFFSET. Essentially, I want to grab the date of
    the previous row and calculate the difference in days between the current row
    date and the previous row date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/15c96a092407974bb49f6dbefdc9cc79.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: 'And, here is the measure to calculate the number of days between the orders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/592a24a8d758dc3682c66cb1bf59985b.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: 'Ok, now, let’s calculate the average number of days between the orders for
    every customer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/351daacb32b3bf88156edd4faa5d3449.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: So, what can we conclude at this point? Alexandra orders on average every 22
    days, while Adam needs 89 days on average to make a new order. How does that compare
    to a whole? Are 89 days way too long between the orders, or not?
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s put these numbers into the context of the whole dataset.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1d44c0b1526e11d7f82c52b01252c3ea.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Although 89 days may look bad compared to 22 days for Alexandra Jenkins, we
    may conclude that these 89 days are not bad at all compared to the average for
    all the customers, which is 287 days! Great insight indeed!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s wrap it up by calculating the total customer lifetime. This is the number
    of days between the first and the last order for each customer. So, let’s calculate
    the first and the last order date within our “windows”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/5ba9401851bae76554eb7e7154903178.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the calculation for the number of customer lifetime days:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And, once I drag it into the table, I can see that it’s being calculated within
    each window (for each customer separately):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/fd085451b63d3f1b9ce9894a41ce9ecd.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this was just a basic example of what is possible by using DAX window
    functions. Honestly, there is an indefinite number of use cases to think of —
    for example, I could have also ranked individual rows within the window (and quickly
    identified the highest sales amount for each customer).
  prefs: []
  type: TYPE_NORMAL
- en: 'I could have also partitioned by multiple attributes — for example, by customer
    AND month. Then, we would have a “window” containing all the rows for a customer
    within a single month. Think of it: Adam Young — July, Adam Young — August, Alexandra
    Jenkins — July, Alexandra Jenkins — August, and so on. Depending on your specific
    business request, your “window” can be defined differently.'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Window functions are one of the most important enhancements to the DAX language,
    there is no doubt about that! Some of the business use cases that previously required
    writing complex and verbose DAX, now may be fulfilled in a more elegant and optimal
    way. Same as in SQL language, where window functions are one of the most powerful
    analytical tools, DAX window functions will definitely make many of the Power
    BI development tasks easier to implement.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks for reading!
  prefs: []
  type: TYPE_NORMAL
