["```py\nfrom multiprocessing import Process\nimport time\n\nMAX_COUNT = 100000000\nNUM_PROCESSES = 4\n\ndef count(max_count: int) -> int:\n    counter = 0\n    for _ in range(max_count):\n        counter += 1\n    print(\"Finished\")\n\nif __name__ == \"__main__\":\n    start_time = time.time()\n\n    processes = [Process(target=count, args=(MAX_COUNT,)) for _ in range(NUM_PROCESSES)]\n\n    for process in processes:\n        process.start()\n\n    for process in processes:\n        process.join()\n\n    print(f\"Time elapsed: {time.time() - start_time}\")\n```", "```py\nimport threading\nimport time\n\nMAX_COUNT = 100000000\nNUM_PROCESSES = 4\n\ndef count(max_count):\n    counter = 0\n    for _ in range(max_count):\n        counter += 1\n    print(\"Finished\")\n\nif __name__ == \"__main__\":\n    start_time = time.time()\n\n    threads = [\n        threading.Thread(target=count, args=(MAX_COUNT,)) for _ in range(NUM_PROCESSES)\n    ]\n\n    for thread in threads:\n        thread.start()\n\n    for thread in threads:\n        thread.join()\n\n    print(f\"Time elapsed: {time.time() - start_time}\")\n```", "```py\nfrom multiprocessing import Pool\n\nMAX_COUNT = 100000000\nNUM_PROCESSES = 4\n\ndef count(max_count: int) -> int:\n    counter = 0\n    for _ in range(max_count):\n        counter += 1\n    print(\"Finished\")\n    return counter\n\nif __name__ == \"__main__\":\n    results = Pool(NUM_PROCESSES).map(count, [MAX_COUNT] * 5)\n    print(results)\n```", "```py\nresults = Pool(NUM_PROCESSES).imap(count, [MAX_COUNT] * 5)\nfor result in results:\n    print(result)\n```", "```py\nimport threading\nimport time\n\nNUM_CONSUMERS = 2\n\ncondition_satisfied = False\n\nlock = threading.Lock()\n\ndef producer() -> None:\n    global condition_satisfied\n\n    while True:\n        user_input = input(\"Enter a comamnd:\")\n        if user_input == \"Start\":\n            # Signal the producers to start\n            lock.acquire()\n            condition_satisfied = True\n            lock.release()\n            break\n        else:\n            print(f\"Unknown command {user_input}\")\n        lock.release()\n        time.sleep(1)\n\ndef consumer(consumer_idx: int) -> None:\n    while True:\n        lock.acquire()\n        condition_satisfied_read = condition_satisfied\n        lock.release()\n        if condition_satisfied_read:\n            for i in range(10):\n                print(f\"{i} from consumer {consumer_idx}\")\n                time.sleep(1)\n            break\n        time.sleep(1)\n\nif __name__ == \"__main__\":\n    threads = [threading.Thread(target=producer)] + [\n        threading.Thread(target=consumer, args=(consumer_idx,))\n        for consumer_idx in range(NUM_CONSUMERS)\n    ]\n\n    for thread in threads:\n        thread.start()\n\n    for thread in threads:\n        thread.join()\n```", "```py\nimport asyncio\n\nNUM_CONSUMERS = 2\n\ncondition_satisfied = False\nshould_terminate = False\n\nasync def producer():\n    global condition_satisfied\n\n    while True:\n        user_input = input(\"Enter a comamnd:\")\n        if user_input == \"Start\":\n            # Signal the producers to start\n            condition_satisfied = True\n            break\n        else:\n            print(f\"Unknown command {user_input}\")\n        await asyncio.sleep(1)\n\nasync def consumer(consumer_idx):\n    global condition_satisfied\n\n    while True:\n        if condition_satisfied:\n            for i in range(10):\n                print(f\"{i} from consumer {consumer_idx}\")\n                await asyncio.sleep(1)\n            break\n        await asyncio.sleep(1)\n\nasync def main():\n    await asyncio.gather(producer(), consumer(0), consumer(1))\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```"]