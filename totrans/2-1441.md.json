["```py\nimport copy\nimport logging\nimport math\nimport numpy as np\nimport random\nimport time\n\nfrom problems.knapsack import Knapsack\nfrom problems.rastrigin import Rastrigin\nfrom problems.tsp import TravelingSalesman\n\nclass SimulatedAnnealing():\n    def __init__(self, problem):\n        self.problem = problem\n\n    def run_sa(self, max_iterations: int=100000, update_iterations: int=10000, time_limit: int=60, cooling_schedule: str='lin'):\n        start = time.time()\n        best_solution = self.problem.baseline_solution()\n        best_obj = self.problem.score_solution(best_solution)\n        logging.info(f\"First solution.        Objective: {round(best_obj, 2)} Solution: {best_solution}\")\n        initial_temp = best_obj\n        prev_solution = copy.deepcopy(best_solution)\n        prev_obj = best_obj\n\n        iteration = 0\n        last_update = 0\n        while time.time() - start < time_limit:\n            iteration += 1\n            last_update += 1\n            accept = False\n\n            curr_solution = self.problem.select_neighbor(copy.deepcopy(prev_solution))\n            curr_obj = self.problem.score_solution(curr_solution)\n\n            temperature = self._calculate_temperature(initial_temp, iteration, max_iterations, cooling_schedule)\n            acceptance_value = self._acceptance_criterion(curr_obj, prev_obj, temperature)\n\n            if (curr_obj <= prev_obj) or (temperature > 0 and random.random() < acceptance_value):\n                accept = True\n\n            if curr_obj < best_obj:\n                best_solution = copy.deepcopy(curr_solution)\n                best_obj = curr_obj\n                prev_solution = copy.deepcopy(curr_solution)\n                prev_obj = curr_obj\n                last_update = 0\n                logging.info(f\"Better solution found. Objective: {round(best_obj, 2)} Solution: {curr_solution}\")\n            else:\n                if accept:\n                    prev_obj = curr_obj\n                    prev_solution = copy.deepcopy(curr_solution)\n                    last_update = 0\n\n            if last_update >= update_iterations:\n                break\n\n        logging.info(f\"Final solution: {best_solution} Objective: {round(best_obj, 2)}\")\n        return best_solution\n\n    @staticmethod\n    def _acceptance_criterion(obj_new, obj_curr, temperature, mod=1):\n        \"\"\"\n        Determine the acceptance criterion (threshold for accepting a solution that is worse than the current one)\n        \"\"\"\n        diff = obj_new - obj_curr\n        try:\n            acc = math.exp(-diff / temperature)\n        except OverflowError:\n            acc = -1\n        return acc\n\n    @staticmethod\n    def _calculate_temperature(initial_temp: int, iteration: int, max_iterations: int, how: str = None) -> float:\n        \"\"\"\n        Decrease the temperature to zero based on total number of iterations.\n        \"\"\"\n        if iteration >= max_iterations:\n            return -1\n        if how == \"exp\":\n            cooling_rate = 0.95\n            return initial_temp * (cooling_rate**iteration)\n        elif how == \"quadratic\":\n            cooling_rate = 0.01\n            return initial_temp / (1 + cooling_rate * iteration**2)\n        elif how == \"log\":\n            cooling_rate = 1.44\n            return initial_temp / (1 + cooling_rate * np.log(1 + iteration))\n        elif how == \"lin mult\":\n            cooling_rate = 0.1\n            return initial_temp / (1 + cooling_rate * iteration)\n        else:\n            return initial_temp * (1 - iteration / max_iterations)\n\nif __name__ == '__main__':\n    problem = 'rastrigin'  # choose one of knapsack, tsp, rastrigin\n    logging.basicConfig(filename=f'{problem}.log', encoding='utf-8', level=logging.INFO)\n    if problem == 'tsp':\n        problem = TravelingSalesman(n_locations=10, height=100, width=100)\n        sa = SimulatedAnnealing(problem)\n        final_solution = sa.run_sa()\n        problem._plot_solution(final_solution, title='final')\n    elif problem == 'knapsack':\n        problem = Knapsack(knapsack_capacity=100, n_items=10)\n        sa = SimulatedAnnealing(problem)\n        final_solution = sa.run_sa()\n    elif problem == 'rastrigin':\n        problem = Rastrigin(n_dims=2) \n        sa = SimulatedAnnealing(problem)\n        final_solution = sa.run_sa()\n```", "```py\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport random\nfrom typing import List\n\nclass TravelingSalesman():\n    def __init__(self, n_locations: int = 10, locations: List[tuple] = None, height: int = 100, width: int = 100, starting_point: int=0):\n        self.name = 'traveling salesman'\n        self.starting_point = starting_point\n        self.height = height\n        self.width = width\n        if locations is None:\n            locations = self._create_sample_data(n_locations)\n        self.locations = locations\n        self.n_locations = len(locations)\n        self.distances = self._create_distances()\n\n    def baseline_solution(self) -> list:\n        # route that follows the locations list\n        # start and end in start location\n        baseline = [self.starting_point] + [i for i in range(self.n_locations) if i != self.starting_point] + [self.starting_point]\n        self._plot_solution(baseline, title='baseline')\n        self._plot_solution(baseline, title='dots', only_dots=True)\n        return baseline\n\n    def score_solution(self, solution: list) -> float:\n        # add all distances\n        return sum([self.distances[node, solution[i+1]] for i, node in enumerate(solution[:-1])])\n\n    def select_neighbor(self, solution: list) -> list:\n        # swap two locations (don't swap start and end)\n        indici = random.sample(range(1, self.n_locations), 2)\n        idx1, idx2 = indici[0], indici[1]\n        value1, value2 = solution[idx1], solution[idx2]\n        solution[idx1] = value2\n        solution[idx2] = value1\n        return solution\n\n    def _create_sample_data(self, n_locations: int) -> List[tuple]:\n        return [(random.random() * self.height, random.random() * self.width) for _ in range(n_locations)]\n\n    def _plot_solution(self, solution: list, title: str = 'tsp', only_dots: bool = False):\n        plt.clf()\n        plt.rcParams[\"figure.figsize\"] = [5, 5]\n        plt.rcParams[\"figure.autolayout\"] = True\n        for n, location_id1 in enumerate(solution[:-1]):\n            location_id2 = solution[n+1]\n            x_values = [self.locations[location_id1][0], self.locations[location_id2][0]]\n            y_values = [self.locations[location_id1][1], self.locations[location_id2][1]]\n            if not only_dots:\n                plt.plot(x_values, y_values, 'bo', linestyle=\"-\")\n            else:\n                plt.plot(x_values, y_values, 'bo')\n            plt.text(x_values[0]-2, y_values[0]+2, str(location_id1))\n        plt.savefig(f'{title}')\n\n    def _create_distances(self) -> np.array:\n        distances = np.zeros(shape=(self.n_locations, self.n_locations))\n        for ni, i in enumerate(self.locations):\n            for nj, j in enumerate(self.locations):\n                distances[ni, nj] = self._distance(i[0], i[1], j[0], j[1])\n        return distances\n\n    @staticmethod\n    def _distance(x1: float, y1: float, x2: float, y2: float) -> float:\n        return np.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n```", "```py\nimport copy\nimport random\nimport numpy as np\nfrom typing import List\n\nclass Knapsack():\n    def __init__(self, knapsack_capacity: int, n_items: int = 20, item_values: list = None, item_capacities: list = None):\n        self.name = 'knapsack'\n        self.knapsack_capacity = knapsack_capacity\n        if item_values is None and item_capacities is None:\n            item_values, item_capacities = self._create_sample_data(n_items)\n        self.item_values = item_values\n        self.item_capacities = item_capacities\n        self.n_items = len(item_values)\n\n    def baseline_solution(self) -> list:\n        # select random items until the knapsack is full\n        capacity = 0\n        solution = []\n        while True:\n            selected = random.choice([i for i in range(self.n_items) if i not in solution])\n            if capacity + self.item_capacities[selected] > self.knapsack_capacity:\n                break\n            else:\n                solution.append(selected)\n                capacity += self.item_capacities[selected]\n        return solution\n\n    def score_solution(self, solution: list) -> int:\n        # count the total value of this solution\n        return -1 * sum([self.item_values[i] for i in solution])\n\n    def select_neighbor(self, solution: list) -> list:\n        # local move: remove / add / swap items\n        solution_capacity = sum([self.item_capacities[i] for i in solution])\n        possible_to_add = [i for i in range(self.n_items) if self.item_capacities[i] <= self.knapsack_capacity - solution_capacity and i not in solution]\n        if len(solution) == 0:\n            move = 'add'\n        elif len(possible_to_add) > 0:\n            move = np.random.choice(['remove', 'add', 'swap'], p=[0.1, 0.6, 0.3])\n        else:\n            move = np.random.choice(['remove', 'swap'], p=[0.4, 0.6])\n        while True:\n            if move == 'remove':\n                solution.pop(random.randrange(len(solution)))\n                return solution\n            elif move == 'add':\n                new_solution = copy.deepcopy(solution)\n                new_item = random.choice(possible_to_add)\n                new_solution.append(new_item)\n                return new_solution\n            elif move == 'swap':\n                n = 0\n                while n < 50:\n                    new_solution = copy.deepcopy(solution)\n                    in_item = random.choice([i for i in range(self.n_items) if i not in solution])\n                    out_item = random.choice(range(len(solution)))\n                    new_solution.pop(out_item)\n                    new_solution.append(in_item)\n                    n += 1\n                    if self._is_feasible(new_solution):\n                        return new_solution\n                move = 'remove'\n\n    def _create_sample_data(self, n_items: int) -> List[list]:\n        item_values = random.sample(range(2, 1000), n_items)\n        item_capacities = random.sample(range(1, self.knapsack_capacity), n_items)\n        return item_values, item_capacities\n\n    def _is_feasible(self, solution: list) -> bool:\n        return sum([self.item_capacities[i] for i in solution]) <= self.knapsack_capacity\n```", "```py\nfrom collections import Counter\nimport numpy as np\nimport random\nfrom typing import List\n\nclass Rastrigin():\n    def __init__(self, n_dims: int = 2):\n        self.name = 'rastrigin'\n        self.n_dims = n_dims\n\n    def baseline_solution(self) -> list:\n        solution = [random.uniform(-5.12, 5.12) for _ in range(self.n_dims)]\n        return solution\n\n    def score_solution(self, solution: list) -> float:\n        score = self.n_dims * 10 + sum([(x**2 - 10*np.cos(2*np.pi*x)) for x in solution])\n        return score\n\n    def select_neighbor(self, solution: list, step_size: float = 0.1) -> list:\n        perturbation = step_size * np.random.randn(self.n_dims)\n        neighbor = solution + perturbation\n        while not self._is_feasible(neighbor):\n            perturbation = step_size * np.random.randn(self.n_dims)\n            neighbor = solution + perturbation    \n        return neighbor\n\n    def _is_feasible(self, solution: list) -> bool:\n        return bool([x >= -5.12 and x <= 5.12 for x in solution])\n```"]