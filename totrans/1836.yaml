- en: 'Setting up Python Projects: Part V'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://towardsdatascience.com/setting-up-python-projects-part-v-206df3c1e3d3](https://towardsdatascience.com/setting-up-python-projects-part-v-206df3c1e3d3)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Mastering the Art of Python Project Setup: A Step-by-Step Guide'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://johschmidt42.medium.com/?source=post_page-----206df3c1e3d3--------------------------------)[![Johannes
    Schmidt](../Images/e0cacf7ff37f339a9bf8bd33c7c83a4d.png)](https://johschmidt42.medium.com/?source=post_page-----206df3c1e3d3--------------------------------)[](https://towardsdatascience.com/?source=post_page-----206df3c1e3d3--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----206df3c1e3d3--------------------------------)
    [Johannes Schmidt](https://johschmidt42.medium.com/?source=post_page-----206df3c1e3d3--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ¬∑Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----206df3c1e3d3--------------------------------)
    ¬∑20 min read¬∑Jan 14, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c80bbfc10240ac4b4126a69759a6a36e.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Zoya Loonohod](https://unsplash.com/@loonohod?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Whether you‚Äôre a seasoned developer or just getting started with üêç **Python**,
    it‚Äôs important to know how to build robust and maintainable projects. This tutorial
    will guide you through the process of setting up a Python project using some of
    the most popular and effective tools in the industry. You will learn how to use
    [GitHub](https://github.com/) and [GitHub Actions](https://github.com/features/actions)
    for version control and continuous integration, as well as other tools for testing,
    documentation, packaging and distribution. The tutorial is inspired by resources
    such as [Hypermodern Python](https://medium.com/@cjolowicz/hypermodern-python-d44485d9d769)
    and [Best Practices for a new Python project](https://mitelman.engineering/blog/python-best-practice/automating-python-best-practices-for-a-new-project/).
    However, this is not the only way to do things and you might have different preferences
    or opinions. The tutorial is intended to be beginner-friendly but also cover some
    advanced topics. In each section, you will automate some tasks and add badges
    to your project to show your progress and achievements.
  prefs: []
  type: TYPE_NORMAL
- en: The repository for this series can be found at [github.com/johschmidt42/python-project-johannes](https://github.com/johschmidt42/python-project-johannes)
  prefs: []
  type: TYPE_NORMAL
- en: 'This part was inspired by this blog post:'
  prefs: []
  type: TYPE_NORMAL
- en: '[**Semantic release with Python, Poetry & GitHub Actions üöÄ**'
  prefs: []
  type: TYPE_NORMAL
- en: '*I‚Äôm planning to add a few features to Dr. Sven thanks to some interest from
    my colleagues. Before doing so, I needed to‚Ä¶*](https://mestrak.com/blog/semantic-release-with-python-poetry-github-actions-20nn)'
  prefs: []
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**OS**: Linux, Unix, macOS, Windows (WSL2 with e.g. Ubuntu 20.04 LTS)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tools**: python3.10, bash, git, tree'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version Control System (VCS) Host**: [GitHub](https://github.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous Integration (CI) Tool**: [GitHub Actions](https://github.com/features/actions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is expected that you are familiar with the versioning control system (VCS)
    [git](https://git-scm.com/). If not, here‚Äôs a refresher for you: [Introduction
    to Git](https://realpython.com/python-git-github-intro/)'
  prefs: []
  type: TYPE_NORMAL
- en: Commits will be based on [best practices for git commits](https://deepsource.io/blog/git-best-practices/)
    & [Conventional commits](https://www.conventionalcommits.org/en/v1.0.0/). There
    is the [conventional commit plugin](https://plugins.jetbrains.com/plugin/13389-conventional-commit)
    for PyCharm or a [VSCode Extension](https://github.com/vivaxy/vscode-conventional-commits)
    that help you to write commits in this format.
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Part I (GitHub, IDE)](https://johschmidt42.medium.com/setting-up-python-projects-part-i-408603868c08)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Part II (Formatting, Linting, CI)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Part III (Testing, CI)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Part IV (Documentation, CI/CD)](https://johschmidt42.medium.com/setting-up-python-projects-part-iv-82059eba4ca4)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part V (Versioning & Releases, CI/CD)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Part VI (Containerisation, Docker, CI/CD)](https://johschmidt42.medium.com/setting-up-python-projects-part-vi-cbdbf28eff53)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Git Branching Strategy (*GitHub flow*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a release? (*zip, tar.gz*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Semantic Versioning (*v0.1.0*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a release manually (*git tag, GitHub*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a release automatically (*conventional commits, semantic releases*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CI/CD (*release.yml*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a Personal Access Token (PAT)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub Actions Flow (*Orchestrating workflows*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Badge (*Release*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bonus (*Enforce conventional commits*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Releasing software is an important step in the software development process
    as it makes new features and bugfixes available to users. One key aspect of releasing
    software is versioning, which helps to track and communicate the changes made
    in each release. Semantic versioning is a widely used standard for versioning
    software, which uses a version number in the format of Major.Minor.Patch (e.g.
    1.2.3) to indicate the level of changes made in a release.
  prefs: []
  type: TYPE_NORMAL
- en: Conventional commits is a specification for adding human and machine readable
    meaning to commit messages. It‚Äôs a way to format commit messages in a consistent
    manner, which make it easy to determine the type of change made. Conventional
    commits are commonly used in conjunction with semantic versioning, as the commit
    messages can be used to automatically determine the version number of a release.
    Together, semantic versioning and conventional commits provide a clear and consistent
    way to track and communicate the changes made in each release of a software project.
  prefs: []
  type: TYPE_NORMAL
- en: Git Branching Strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many different branching strategies out there for git. Many people
    gravitate towards [GitFlow](http://datasift.github.io/gitflow/IntroducingGitFlow.html)
    (or variants), [Three Flow](https://www.nomachetejuggling.com/2017/04/09/a-different-branching-strategy/),
    or [Trunk based Flows](https://trunkbaseddevelopment.com/). Some do strategies
    in between these, such as this [one](https://brightinventions.pl/blog/how-do-we-use-git/).
    I‚Äôm using the very simple [GitHub flow](https://guides.github.com/introduction/flow/)
    branching strategy, where all bug fixes and features have their own separate branch,
    and when complete, each branch is merged to main and deployed. Simple, nice and
    easy.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9ac6ed499d8cab343bc75482579e1bed.png)'
  prefs: []
  type: TYPE_IMG
- en: GitHub Flow branching strategy
  prefs: []
  type: TYPE_NORMAL
- en: Whatever your strategy might be, in the end you merge a pull request and (probably)
    create a release.
  prefs: []
  type: TYPE_NORMAL
- en: What is a release?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In short, a release is packing up code of a version (e.g. zip) and pushing it
    to production (whatever this might be for you).
  prefs: []
  type: TYPE_NORMAL
- en: Release management can be messy. Therefore there needs to be a concise way that
    you follow (and others), that defines what a release means and what changes between
    one release and the next. If you don‚Äôt track the changes between the releases,
    then you probably won‚Äôt understand what has been changed in each release and you
    can‚Äôt identify any problems that might have been introduced with new code. Without
    a changelog, it can be difficult to understand how the software has evolved over
    time. It can also make it difficult to roll back changes if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic Versioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Semantic Versioning](https://semver.org/) is just a number schema and standard
    practice in the industry for software development. It indicates the level of changes
    between this version and the previous one. There are three parts to a semantic
    version number, such as **1.8.42**, that follow the pattern of :'
  prefs: []
  type: TYPE_NORMAL
- en: '*MAJOR.MINOR.PATCH*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each one of them means a different degree of change. A PATCH release indicates
    bug fixes or trivial changes (e.g. from 1.0.0 to 1.0.1). A MINOR release indicates
    adding/removing functionality or backwards compatible changes of functionality
    (e.g. from 1.0.0 to 1.1.0). A MAJOR release indicates adding/removing functionality
    and potentially backwards in-compatible changes such as breaking changes (e.g.
    from 1.0.0 to 2.0.0).
  prefs: []
  type: TYPE_NORMAL
- en: I recommend a [talk](https://www.youtube.com/watch?v=4wPjo5C-v8Y) of Mike Miles,
    if you want a visual introduction into releases with semantic versioning. It‚Äôs
    a summary of what releases are and how semantic versioning with [git tags](https://git-scm.com/book/en/v2/Git-Basics-Tagging)
    allows us to create releases.
  prefs: []
  type: TYPE_NORMAL
- en: 'About **git tags**: There are lightweight and annotated tags in git. A *lightweight*
    tag is just a pointer to a specific commit whereas an *annotated* tag is a full
    object in git.'
  prefs: []
  type: TYPE_NORMAL
- en: Create a release manually
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let‚Äôs create a release manually first and then automate it.
  prefs: []
  type: TYPE_NORMAL
- en: If you remember, our example_app‚Äôs `__init__.py` file contains the version
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: as well as the `pyproject.toml` file
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'So the first thing we must do is to create an annotated git tag `v0.1.0` and
    add it to the latest commit in main:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Please note that if no commit hash is specified at the end of the command, then
    git will use the current commit you are on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get a list of tags with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'and if we want delete it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'and get more information about the tag with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We can push the newly created tag to origin with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'so that this git tag is now available on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b8daad7af39ff3448a87465c2b3a98b9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let‚Äôs manually create a new release in GitHub with this git tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a3bb26a8179a416567385bbe324da5f9.png)'
  prefs: []
  type: TYPE_IMG
- en: We click on `Create a new release` , select our existing tag (that is already
    bound to a commit) and then generate release notes automatically by clicking on
    the `Generate release notes` button before we finally publish the release with
    the `Publish release` button.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b49c9e26d316c7dab46743f61fb54f6c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'GitHub will automatically create a `tar` and a `zip` (assets) for the source
    code, but will not build the application! The result will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/cdb1cd2658a5eac059aefc07ca7c1579.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To summarise, the steps for a release are:'
  prefs: []
  type: TYPE_NORMAL
- en: create a new branch from your default branch (e.g. feature or fix branch)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: make changes and increase the version (e.g. *pyproject.toml* and *__init__.py*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: commit the feature/bug fix to the default branch (probably through a Pull Request)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: add an *annotated* git tag (semantic version) to the commit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: publish the release on GitHub with some additional information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a release automatically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As programmers, we don‚Äôt like to repeat ourselves. So there are plenty of tools
    that make these steps super easy for us. Here, I will introduce [Semantic Releases](https://python-semantic-release.readthedocs.io/en/latest/),
    a tool specifically for Python Projects.
  prefs: []
  type: TYPE_NORMAL
- en: It‚Äôs a tool which automatically sets a version number in your repo, tags the
    code with the version number and creates a release! And this is all done using
    the contents of **Conventional Commit** style messages.
  prefs: []
  type: TYPE_NORMAL
- en: Conventional Commits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is the connection between semantic versioning and [conventional-commits](https://www.conventionalcommits.org/en/v1.0.0/)?
  prefs: []
  type: TYPE_NORMAL
- en: Certain commit types can be used to automatically determine a semantic version
    bump!
  prefs: []
  type: TYPE_NORMAL
- en: A `fix` commit is a PATCH.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `feat` commit is a MINOR.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A commit with `BREAKING CHANGE` or `!` is a MAJOR.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other types, e.g. `build`, `chore`, `ci`, `docs`, `style`, `refactor`, `perf`,
    `test` generally don‚Äôt increase the version.
  prefs: []
  type: TYPE_NORMAL
- en: Check out the bonus section at the end to find out how to enforce conventional
    commits in your project!
  prefs: []
  type: TYPE_NORMAL
- en: Automatic semantic releases (locally)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can add the library with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let‚Äôs go through the configuration settings that allow us to automatically
    generate change-logs and releases. In the `pyproject.toml`, we can add *semantic_release*
    as a tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`branch`: specifies the branch that the release should be based on, in this
    case the "main" branch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`version_variable`: specifies the file path and variable name of the version
    number in the source code. In this case, the version number is stored in the `__version__`
    variable in the file `src/example_app/__init__.py`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`version_toml`: specifies the file path and variable name of the version number
    in the `pyproject.toml` file. In this case, the version number is stored in the
    `tool.poetry.version` variable of the `pyproject.toml` file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`version_source`: Specifies the source of the version number. In this case,
    the version number is obtained from the tag (instead of commit)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`commit_version_number`: This parameter is required when `version_source =
    "tag"`. It specifies whether the version number should be committed to the repository
    or not. In this case, it is set to true, which means that version number will
    be committed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tag_commit`: Specifies whether a new tag should be created for the release
    commit. In this case, it is set to true, which means that a new tag will be created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`upload_to_pypi`: Specifies whether the package should be uploaded to the PyPI
    package repository. In this case, it is set to false, which means that the package
    will not be uploaded to PyPI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`upload_to_release`: Specifies whether the package should be uploaded to the
    GitHub release page. In this case, it is set to false, which means that the package
    will not be uploaded to GitHub releases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hvcs`: Specifies the hosting version control system of the project. In this
    case, it is set to "github", which means that the project is hosted on GitHub.
    "gitlab" is also supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can update the files where we have defined the version of the project/module.
    For this we use the variable `version_variable` for normal files and `version_toml`
    for *.toml* files. The `version_source` defines the source of truth for the version.
    Because the version in these two files is tightly coupled with the git annotated
    tags, for example we create a git tag with every release automatically (flag `tag_commit`
    is set to true), we can use the source `tag` instead of the default value `commit`
    that looks for the last version in the commit messages. To be able to update the
    files and commit the changes, we [need to set the](https://github.com/relekang/python-semantic-release/issues/104)
    `[commit_version_number](https://github.com/relekang/python-semantic-release/issues/104)`
    [flag to true](https://github.com/relekang/python-semantic-release/issues/104).
    Because we don‚Äôt want to upload anything to the Python index [PyPi](https://pypi.org/),
    the flag `upload_to_pypi` is set to false. And for now we don‚Äôt want to upload
    anything to our releases. The `hvcs` is set to `github` (default), other values
    can be: `gitlab`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test this locally by running a few commands, that I will add directly
    to our Makefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With the command *current-version* we get the version from the last git tag
    in the git tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If we add a few commits in conventional commit style, e.g. `feat: new cool
    feature` or `fix: nasty bug`, then the command **next-version** will compute the
    version bump for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Right now, we don‚Äôt have a CHANGELOG file in our project, so that when we run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'the output will be empty. But based on the commits we can create the upcoming
    changelog with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If we push new commits (directly to main or through a PR) we could now publish
    a new release with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The publish command will do a sequence of things:'
  prefs: []
  type: TYPE_NORMAL
- en: Update or create the changelog file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run [semantic-release version](https://python-semantic-release.readthedocs.io/en/latest/index.html#cmd-version).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push changes to git.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run [build_command](https://python-semantic-release.readthedocs.io/en/latest/configuration.html#config-build-command)
    and upload the distribution file to your repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run [semantic-release changelog](https://python-semantic-release.readthedocs.io/en/latest/index.html#cmd-changelog)
    and post to your vcs provider.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach the files created by [build_command](https://python-semantic-release.readthedocs.io/en/latest/configuration.html#config-build-command)
    to GitHub releases.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every step can be of course configured or deactivated!
  prefs: []
  type: TYPE_NORMAL
- en: CI/CD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let‚Äôs build a CI pipeline with GitHub Actions that runs the publish command
    of semantic-release with every commit to the main branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the overall structure remains the same as in *lint.yml*, *test.yml* or
    *pages.yml*, there are a few changes that need to be mentioned. In the step `Checkout
    repository`, we add a new token that is used to checkout the branch. That is because
    the default value `GITHUB_TOKEN` does not have the required permissions to operate
    on protected branches. Therefore, we must use a secret (**GH_TOKEN**) that contains
    a [Personal Access Token](https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line)
    with permissions. I will show later how the Personal Access Token can be generated.
    We also define `fetch-depth: 0` to fetch all history for all branches and tags.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We install only the dependencies that are required for the semantic-release
    tool with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the last step, we change some git configurations and run the publish command
    of semantic-release:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: By changing the git config, the user that commits will be ‚Äúgithub-actions‚Äù.
    We run the publish command with DEBUG logs (stdout) and set the `commit_author`
    to ‚Äúgithub-actions‚Äù explicitly. Alternatively to this command, we could use the
    GitHub action from semantic-release directly, but the set up steps of running
    the publish command are [very few](https://github.com/relekang/python-semantic-release/blob/master/action.sh)
    and the action uses a docker container that needs to be pulled every time. Because
    of that I prefer to make a simple run step instead.
  prefs: []
  type: TYPE_NORMAL
- en: Because the publish command will make a commit, you might be worried that we
    could end up in an endless loop of workflows being triggered. But do not worry,
    the resulting commit will not trigger another GitHub Actions Workflow run. This
    is due to [limitations set by GitHub](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#using-the-github_token-in-a-workflow).
  prefs: []
  type: TYPE_NORMAL
- en: Create a Personal Access Token (PAT)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Personal access token are an alternative to using passwords for authentication
    to GitHub Enterprise Server when using the [GitHub API](https://docs.github.com/en/enterprise-server@3.4/rest/overview/other-authentication-methods#via-oauth-and-personal-access-tokens)
    or the [command line](https://docs.github.com/en/enterprise-server@3.4/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token#using-a-token-on-the-command-line).
    Personal access tokens are intended to access GitHub resources on behalf of yourself.
    To access resources on behalf of an organization, or for long-lived integrations,
    you should use a GitHub App. For more information, see ‚Äú[About apps](https://docs.github.com/en/enterprise-server@3.4/developers/apps/getting-started-with-apps/about-apps).‚Äù
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In other words: We can create an **P**ersonal **A**ccess **T**oken and have
    GitHub actions store and use that **secret** to perform certain operations on
    our behalf. Keep in mind, if the PAT is compromised, it could be used to perform
    malicious actions on your GitHub repositories. It is therefore recommended to
    use GitHub OAuth Apps & GitHub Apps in organisations. For the purposes of this
    tutorial, we will be using a PAT to allow the GitHub actions pipeline to operate
    on our behalf.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a new access token by navigating to the `Settings` section of
    your GitHub user and following the instructions summarised in [Creating a Personal
    Access Token](https://docs.github.com/en/enterprise-server@3.4/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token).
    This will give us a window that will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ebb37e91c7cf7a89d51bca5eedaadd3a.png)'
  prefs: []
  type: TYPE_IMG
- en: Personal Access Token of an admin account with push access to the repos.
  prefs: []
  type: TYPE_NORMAL
- en: By selecting the scopes, we define what permissions the token will have. For
    our use case, we need **push access** to the repositories which why the new PAT
    `GH_TOKEN` should have the `repo` permissions scope. That scope would authorise
    pushes to protected branches, given you don't have *Include administrators* set
    in the protected branch's settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to the repository overview, in the **Settings** menu, we can either
    add an environment setting or a repository setting under the **Secrets** section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/456cd350112cf1c5a3e7c5a198412418.png)'
  prefs: []
  type: TYPE_IMG
- en: Repository secrets are specific to a single repository (and all environments
    used in there), while environment secrets are specific to an environment. The
    GitHub runner can be configured to run in a specific environment which allows
    it to access the environment‚Äôs secrets. This makes sense when thinking of different
    stages (e.g. DEV vs PROD) but for this tutorial I‚Äôm fine with a **repository secret**.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Actions Flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we a have a few pipelines (linting, testing, releasing, documentation),
    we should think about the flow of actions with a commit to main! There are a few
    things we should be aware of, some of them specific to GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, we want that a commit to main creates a push event that trigger the
    Testing and the Linting workflow. If these are successful, we run the release
    workflow which is responsible to detect if there should be a version bump based
    on conventional commits. If so, the release workflow will directly push to main,
    bumping the versions, adding a git tag and create a release. A published release
    should then, for example, update the documentation by running the documentation
    workflow.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d4523a1b24aa2afa5655c7adc014ffbf.png)'
  prefs: []
  type: TYPE_IMG
- en: Expected flow of actions
  prefs: []
  type: TYPE_NORMAL
- en: Problems & considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you read the last paragraph carefully or looked at the FlowChart above, you
    might have noticed that there are two commits to main. One initial (i.e. from
    a PR) and a second one for the release. Because our *lint.yml* and *test.yml*
    react on push events on the main branch, they would run twice! We should avoid
    running it twice to save resources. To achieve this, we can add the `[skip ci]`
    string to our version commit message. A custom commit message can be defined in
    the *pyproject.toml* file for the tool *semantic_release*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '2\. The workflow *pages.yml* currently runs on a push event to main. Updating
    the documentation could be something that we only want to do if there is a new
    release (We might be referencing the version in the documentation). We can change
    the trigger in the *pages.yml* file accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Building the documentation will now require a **published release**.
  prefs: []
  type: TYPE_NORMAL
- en: '3\. The Release workflow should depend on the success of the Linting & Testing
    workflow. Currently we don‚Äôt have defined dependencies in our workflow files.
    We could have these workflows depend on the completion of defined workflow runs
    in a specific branch with the `[workflow_run](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_run)`
    event. However, if we specify multiple `workflows` for the `workflow_run` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: only one of the workflows needs to completed! This is not what we want. We expect
    that all **workflows** must be completed (and successful). Only then the release
    workflow should run. This is in contrast to what we get when we define dependencies
    between **jobs** in a single workflow. Read more about this inconsistency and
    shortcoming [here](https://github.com/community/community/discussions/16059).
  prefs: []
  type: TYPE_NORMAL
- en: 'As an alternative, we could use a sequential execution of pipelines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/88bfe140d76fef3bfe6c8622c2cd4e07.png)'
  prefs: []
  type: TYPE_IMG
- en: The big downside with this idea is that it **a)** does not allow parallel execution
    and **b)** we won‚Äôt be able to see the dependency graph in GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Currently, the only way I see to deal with the above mentioned problems is to
    orchestrate the workflows in an orchestrator workflow.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/591405e03e0593cd5fde44296b4d6f2b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let‚Äôs create this workflow file:'
  prefs: []
  type: TYPE_NORMAL
- en: The orchestrator is triggered when we push to the branch `main` .
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/958201b9b29998674fbb7a9c2a87526c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Only if both workflows: Testing & Linting are successful, the release workflow
    is called. This is defined in with the `needs` keyword. If we want to have more
    granular control over job executions (workflows), consider using the `if` keyword
    as well. But be aware of the *confusing* behaviour as explained in this [article](https://samanpavel.medium.com/github-actions-conditional-job-execution-e6aa363d2867).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our workflows `lint.yml` , `test.yml` & `release.yml` callable by another
    workflow, we need to update the triggers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now the new workflow (Release) should only run if the workflows for quality
    checking, in this case the linting and testing, succeed.
  prefs: []
  type: TYPE_NORMAL
- en: Badge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create a badge, this time, I will use the platform [shields.io](https://shields.io/).
  prefs: []
  type: TYPE_NORMAL
- en: It‚Äôs a website that generates badges for projects, which display information
    such as version, build status, and code coverage. It offers a wide range of templates
    and allows customization of appearance and creation of custom badges. The badges
    are updated automatically, providing real-time information about the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a release badge, I selected `GitHub release (latest SemVer)` :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/530966bfab9ec5c4435c88aaebcce731.png)'
  prefs: []
  type: TYPE_IMG
- en: The badge markdown can be copied and added to the *README.md:*
  prefs: []
  type: TYPE_NORMAL
- en: 'Our landing page of the GitHub now looks like this ‚ù§ (I‚Äôve cleaned up a little
    and provided a description):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/03ce33d4b73c88fa3a45a80fa85f104d.png)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! You have completed the main part of this tutorial! You have
    learned the essential steps for managing **software releases**. We began by manually
    creating a release, and then leveraged the power of **Conventional Commits** to
    automate our release process through a **CI pipeline**, which handles versioning
    on our behalf. To finalize, we added a **badge** in our README.md file, providing
    a clear and concise display of the latest version of our project for our users.
    With these techniques in hand, you‚Äôll be able to efficiently and effectively manage
    your software releases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next part will be the last part, which covers: **Containerisation**!'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://johschmidt42.medium.com/membership?source=post_page-----206df3c1e3d3--------------------------------)
    [## Join Medium with my referral link - Johannes Schmidt'
  prefs: []
  type: TYPE_NORMAL
- en: Read every story from Johannes Schmidt (and thousands of other writers on Medium).
    Your membership fee directly‚Ä¶
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: johschmidt42.medium.com](https://johschmidt42.medium.com/membership?source=post_page-----206df3c1e3d3--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Bonus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ensure Conventional Commits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have seen that commits in a defined format can help us with versioning.
    In a collaborative project, we probably want to enforce this format for all commits
    to the default branch. Two popular tools can help developers follow the conventional
    commits format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[commitizen](https://github.com/commitizen/cz-cli)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[commitlint](https://github.com/conventional-changelog/commitlint)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, some developers feel that these tools are a little restrictive and
    and avoid using them*. So it‚Äôs probably a bad idea to just hope that there will
    always be conventional commits. Therefore, it makes sense to enforce rules, such
    as the conventional commit format, on the server side!
  prefs: []
  type: TYPE_NORMAL
- en: '**The same applies to* [*pre-commit*](https://pre-commit.com/) *hooks, which
    is why I excluded them in this series.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, it is currently not possible (May 2023) to block commits based
    on rules on GitHub as the [feature for this is still open](https://github.com/github/roadmap/issues/476).
    But we can try to get as close as possible via **branch protection rules** and
    a **CI workflow**. So here are the things that we require for such a strategy
    in our repo:'
  prefs: []
  type: TYPE_NORMAL
- en: Commits to the protected default branch (e.g. main) should be restricted to
    **pull request** (PR) commits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only [squashed commits](https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/configuring-pull-request-merges/configuring-commit-squashing-for-pull-requests)
    should be allowed*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **default commit message** presented when merging a pull request with squash
    should be the **pull request** **title**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the only way to commit to the **protected** default branch (e.g. main) is
    via a pull request ([squashed commites](https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/configuring-pull-request-merges/configuring-commit-squashing-for-pull-requests)
    only), we can use a GitHub Action, such as [amannn/action-semantic-pull-request](https://github.com/amannn/action-semantic-pull-request),
    that ensures that the pull request‚Äôs title matches the [Conventional Commits spec](https://www.conventionalcommits.org/).
    So when we `squash and merge` the PR branch (assuming all required pipelines succeed),
    the suggested commit message is the PR title which was previously checked the
    by GitHub action run.
  prefs: []
  type: TYPE_NORMAL
- en: '**The squash and merge strategy is a popular method for merging code changes
    from a feature branch into the main branch, which involves condensing multiple
    commits in a feature branch into a single commit. This creates a linear and consistent
    git history, where each commit represents a specific change. However, this method
    does have its downsides, as it discards granular commit history, which can be
    valuable for understanding the development process. While it is possible to use
    rebase merging to retain this information, it can introduce complexity to the
    workflow. In this sense, the squash and merge strategy is favoured for its simplicity.*'
  prefs: []
  type: TYPE_NORMAL
- en: Workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let‚Äôs create the GitHub Actions workflow for this strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: The **trigger event** `pull_request_target` is explained [here](https://github.com/amannn/action-semantic-pull-request#event-triggers).
    I use the suggested types `opened` , `edited` , `synchronize` . The `GITHUB_TOKEN`
    is passed as `env` to the action. So, whenever the title is changed in a PR, the
    pipeline is triggered. It only succeeds if the PR‚Äôs title is in the conventional
    commit format.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that
  prefs: []
  type: TYPE_NORMAL
- en: you need to have this configuration in the main branch for the action to run
    at all (e.g. it won‚Äôt run within a PR that adds the action initially). Also if
    you change the configuration in a PR, the changes will not be reflected for the
    current PR ‚Äî only subsequent ones after the changes are in the main branch.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So we must have this workflow in our default branch `main` first, only then
    we can see it in action.
  prefs: []
  type: TYPE_NORMAL
- en: Branch protection rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, in the *Settings* section of the GitHub repository we can create a **branch
    protection rule** for the *main* branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e0aa5515ece7b094d0198da1bbe2a40d.png)'
  prefs: []
  type: TYPE_IMG
- en: Branch Protection Rule for the main branch ‚Äî Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Now a commit requires a PR with passing status checks (required workflow) before
    merging*.
  prefs: []
  type: TYPE_NORMAL
- en: A [required workflow](https://docs.github.com/en/actions/using-workflows/required-workflows)
    is triggered by pull request events and appears as a required status check, which
    blocks the ability to merge the pull request until the required workflow succeeds.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/5ca948e901b844e9bae4e91b52018506.png)'
  prefs: []
  type: TYPE_IMG
- en: Required workflows ‚Äî Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Organization owners have the ability to enforce specific workflows within their
    organisation, such as requiring a status check on pull requests. Unfortunately,
    this feature is only available for organisations and cannot be activated for individual
    accounts, therefore it is not possible to block merging.
  prefs: []
  type: TYPE_NORMAL
- en: '**Please note that the rules won‚Äôt be enforced on a private repository until
    it is* [*moved to a GitHub Team or Enterprise organization account*](https://github.com/move_work/new)*!*'
  prefs: []
  type: TYPE_NORMAL
- en: Squash & merge strategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, we can configure the PR options to use the PR‚Äôs title as the default
    commit message when we select the squash and merge button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3017b59691e8c5f4d4327784972535c0.png)'
  prefs: []
  type: TYPE_IMG
- en: Default commit message when squash and merge ‚Äî Image by author
  prefs: []
  type: TYPE_NORMAL
- en: 'This way, we see a window like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/fe2a3f501d7814b92691932795f1f9a9.png)'
  prefs: []
  type: TYPE_IMG
- en: Sqash & merge dialog in a PR ‚Äî Image by author
  prefs: []
  type: TYPE_NORMAL
- en: '*Be aware that a developer might alter the title‚Äôs name during the merge, which
    would bypass the strategy!*'
  prefs: []
  type: TYPE_NORMAL
- en: Even though we can‚Äôt completely ensure conventional commits on GitHub yet, we
    should try to get as close as we can.
  prefs: []
  type: TYPE_NORMAL
