- en: Why You (Almost) Can’t Calculate Pi to a Billion Digits in Python at Home
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/why-you-almost-cant-calculate-pi-to-a-billion-digits-in-python-at-home-4262a4de9f80](https://towardsdatascience.com/why-you-almost-cant-calculate-pi-to-a-billion-digits-in-python-at-home-4262a4de9f80)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is harder than you think
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://ibexorigin.medium.com/?source=post_page-----4262a4de9f80--------------------------------)[![Bex
    T.](../Images/516496f32596e8ad56bf07f178a643c6.png)](https://ibexorigin.medium.com/?source=post_page-----4262a4de9f80--------------------------------)[](https://towardsdatascience.com/?source=post_page-----4262a4de9f80--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----4262a4de9f80--------------------------------)
    [Bex T.](https://ibexorigin.medium.com/?source=post_page-----4262a4de9f80--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----4262a4de9f80--------------------------------)
    ·9 min read·Oct 9, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/470ca271edba8912cae6b51f3a61c164.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by me with Midjourney.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In June 9, 2022 Google set a new world record for calculating the most number
    of digits of Pi — 100 TRILLION! This monumental achievement was possible using
    the y-cruncher program running on Google Cloud. It crunched numbers for a whopping
    157 days, 23 hours, 31 minutes and 7.651 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: If one billion is 100 thousand times smaller than 100 trillion, would the runtime
    decrease accordingly? In other words, would it take only 136 seconds?
  prefs: []
  type: TYPE_NORMAL
- en: But 136 seconds is too ambitious. Home PCs are much less powerful than Google
    Cloud’s most formidable environments. So, how about a more reasonable runtime
    like 24 hours?
  prefs: []
  type: TYPE_NORMAL
- en: Turns out, calculating even a billion digits of Pi within 24 hours is a giant
    pipe dream. This article explains why with evidence in Python.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, what is wrong with `math.pi`?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`math.pi` has a precision of 15 digits. While it is not much, it is enough
    for the highest accuracy calculations in science.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, NASA’s Jet Propulsion Lab (JPL) uses 15 digits of Pi to navigate
    between planets. To give you an idea, this level of precision is enough to calculate
    the circumference of a circle with a radius of 15 billion miles. The resulting
    94 billion miles circumference would be off by no more than the width of your
    little finger. Think about that!
  prefs: []
  type: TYPE_NORMAL
- en: So, why even bother with a billion digits, let alone a 100 trillion?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, to give you the geek’s answer: “Because it would be so freaking cool!”.'
  prefs: []
  type: TYPE_NORMAL
- en: What if we increase the decimal precision?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we take out the big guns (the algorithms!), what if we increase decimal
    precision in Python when approximating π? That would be much simpler.
  prefs: []
  type: TYPE_NORMAL
- en: For the approximation, we will use Ramanujan’s formula for π. Mathematicians
    all over the world use it to approximate π to an insurmountable extent.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5b27cd95f3b1ba6f38f65ac53d447247.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by me
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve got a precision of 16 using simple arithmetic. Let’s increase it to 1000
    digits and measure the runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It took only a fraction of a second to get a 1000-point precision! Let’s boldly
    increase the runtime to 1 million:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Only three milliseconds — what’s going on? Looks like we can calculate the
    billion digits in no time. Let’s try that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Not even 10 seconds! `approximation` now holds a billion digits of Pi, calculated
    in only... waaaaait a second! We didn't compare the first few dozen digits to
    the verified digits of Pi to make sure the approximation is precise.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Well, looks like our approximation is only accurate till the 7th digit. What
    a disappointment!
  prefs: []
  type: TYPE_NORMAL
- en: So, what just went wrong?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Why did we get a horrible result? Is Ramanujan’s formula incorrect? Of course
    not! G.H. Hardy himself thought finding Ramanujan’s talent was his greatest math
    contribution.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is with the way modern computers store floating point numbers and
    represent them. I won’t go deep into this but refer you to [this Wikipedia page](https://en.wikipedia.org/wiki/Floating-point_arithmetic)
    and [this excellent StackOverflow thread](https://stackoverflow.com/questions/588004/is-floating-point-math-broken).
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, we are facing a more complex version of the following conundrum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Due to limits in precision, errors like above can accumulate, especially for
    irrationals like Pi. Even a small rounding error can compound over multiple operations,
    completely changing the end result.
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings us to a realization: formulas with ratios and simple math won’t
    accurately calculate Pi’s digits quickly.'
  prefs: []
  type: TYPE_NORMAL
- en: The big guns or short history of computing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Archimedes approximated Pi by adding more sides to polygons inscribed and circumscribed
    around a circle. But the world has come a long way since then. The two millennia
    old method was simple but it wasn’t built for computers. Sorry, Archimedes.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/31020d747b9c265eacbd07be7004463a.png)'
  prefs: []
  type: TYPE_IMG
- en: GIF by me using Wolfram.
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://demonstrations.wolfram.com/ArchimedesApproximationOfPi/?source=post_page-----4262a4de9f80--------------------------------)
    [## Archimedes'' Approximation of Pi - Wolfram Demonstrations Project'
  prefs: []
  type: TYPE_NORMAL
- en: A unit circle is displayed. A regular polygon of sides is circumscribed. Another
    regular polygon of sides is…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: demonstrations.wolfram.com](https://demonstrations.wolfram.com/ArchimedesApproximationOfPi/?source=post_page-----4262a4de9f80--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Of course, Newton had something to say in his time and contributed his converging
    series to approximate Pi as well. But he was able to calculate only 14 digits.
    To do more, he needed to live longer becuase each successive digit required many
    more terms in the series.
  prefs: []
  type: TYPE_NORMAL
- en: Then came Ramanujan with his formulas that rapidly converged to spit out Pi.
    The ratio we have used earlier was a simplification. For the computers of the
    mid-20th century, the efficiency of his methods was near light-speed.
  prefs: []
  type: TYPE_NORMAL
- en: Till the end of the 20th century, scientists used more algorithms based on fast
    converging series. For example, different variations of Gauss-Legendre algorithm
    broke six different world records from just 16500 digits in 1982 to 24 billion
    in 2002\. But such algorithms were for the rich scientists — they required massive
    compute resources, especially memory.
  prefs: []
  type: TYPE_NORMAL
- en: So, the early 21st century saw the rise of Spigot algorithms. These things could
    calculate digits of [transcendental numbers](https://en.wikipedia.org/wiki/Transcendental_number)
    like Pi sequentially from left to right. This meant they required significantly
    smaller memory as they didn’t need to remember the previous digits to calculate
    the next. But they have the disadvantage of being slower than converging series.
  prefs: []
  type: TYPE_NORMAL
- en: So, what did Google use?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since Google could throw (waste?) as much resources as they wanted to set a
    world record, they chose [the Chudnovsky algorithm](https://en.wikipedia.org/wiki/Chudnovsky_algorithm).
    This series is based on Ramanujan’s formulas. It has set **seven world records**
    for calculating Pi. The records were set from 2009 to 2022, with all records in
    the trillions.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b5ca1e20c5e6e3f7cfe669c2ea1515e7.png)'
  prefs: []
  type: TYPE_IMG
- en: The Chudnovsk algorithm. Image from Wikipedia. Wikimedia commons.
  prefs: []
  type: TYPE_NORMAL
- en: In the introduction, I mentioned that Google used a special program called y-cruncher.
    This program can calculate numbers like Pi with trillions of digits. Its ideal
    environments are multi-core systems as it is a multi-threaded software.
  prefs: []
  type: TYPE_NORMAL
- en: And what an ideal environment Google provided!
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the 100 trillion digit experiment, the Compute Engine had these insane
    specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/be230a3d243d117009401529da8b46d1.png)'
  prefs: []
  type: TYPE_IMG
- en: Image from the Google’s announcement of the record.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, hardware wasn’t the only factor behind the success of the achievement.
    To learn more about software architecture and little details, visit [the Google
    Cloud](https://cloud.google.com/blog/products/compute/calculating-100-trillion-digits-of-pi-on-google-cloud)
    page.
  prefs: []
  type: TYPE_NORMAL
- en: Trying out Chudnovsky
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get a feel for the algorithm, let’s try Chudnovsky on my PC to calculate
    the first 10k digits. I am running a modest AMD Ryzen 9 3200x 12-core CPU with
    a 32GB of RAM.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s write a timer decorator we can add to any Pi-calculator function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s put Chudnovsky into a function. You don’t have to read it as it is
    pretty hairy function (I don’t understand it myself). The only thing it does is
    approximate digits of Pi up to `n_digits` and write them to a text file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s try it for the first 1000 digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Even though the function ran under two seconds, it is only accurate up to 13
    decimal points. Why?
  prefs: []
  type: TYPE_NORMAL
- en: First of all, the function is severely underoptimized. `chudnovsky_to_file`
    is a bare-bones Chudnovsky, with no fancy tricks and spices added in. Adding them
    here would break the Medium interface.
  prefs: []
  type: TYPE_NORMAL
- en: Also, native Python isn’t well-equipped to handle certain operations on massive
    integers or long-precision floats. For example, what’s ruining the above function
    is the square root function in the second line of the function body.
  prefs: []
  type: TYPE_NORMAL
- en: To make Chudnovsky faster in Python, read [this excellent (but painfully detailed)
    article](https://www.craig-wood.com/nick/articles/pi-chudnovsky/). It actually
    calculates 1 billion digits in under 10 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: As for us, let’s try an algorithm that’s more or less understandable and doesn’t
    need much alterations.
  prefs: []
  type: TYPE_NORMAL
- en: Trying a Spigot algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apart from requiring low memory resources, Spigot algorithms have the unique
    advantage to run indefinitely. This means, as long as you’ve got the time, you
    can calculate transcendental constants to any reasonable digit.
  prefs: []
  type: TYPE_NORMAL
- en: 'This [excellent article](https://www.gavalas.dev/blog/spigot-algorithms-for-pi-in-python/)
    lists many Spigot algorithms in Python, listing them in the order of efficiency.
    For this article, we will choose Gosper’s proven series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`gospers_pi` is a generator, so we will wrap it inside another function that
    runs it up to `n_digits` and then, writes the digits into a text file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s try it on the first 1000:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: It took a fraction of a second and upon comparing the last few digits to the
    verified 1000 digits of Pi, we can see that the algorithm is both fast and correct.
  prefs: []
  type: TYPE_NORMAL
- en: And now, I will let the function run for 1 million digits and do some editing
    on this article in the meantime.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I came to a massive realization when I started the 1-million-digit experiment
    — I should have put milestone checks every 10k or so digits!
  prefs: []
  type: TYPE_NORMAL
- en: It has been hours. The article is edited and done. But the function doesn’t
    seem to stop any time soon. The only thing I know is that my RAM usage went up
    by 1 GB since the start. I will update the results once the function finishes
    (if ever).
  prefs: []
  type: TYPE_NORMAL
- en: 'This just shows it: calculating digits of Pi requires great patience and perseverance.
    From scouring the internet for a suitable algorithm to waiting dazedly for the
    program to exit (and hoping the last digits match verified results from the Internet).'
  prefs: []
  type: TYPE_NORMAL
- en: This article also discusses some clear problems with Python. It has limited
    support for high-precision math and has turtle-like speed. But if you endure enough,
    like the article on calculating 1 billion digits in 10 minutes, you’ll be rewarded.
  prefs: []
  type: TYPE_NORMAL
- en: Thank you for reading!
  prefs: []
  type: TYPE_NORMAL
- en: Well, it is finally finished overnight.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 20k seconds or almost 6 hours. I checked the last four digits against the verified
    million digits of Pi over at piday.org and the results were spot on!
  prefs: []
  type: TYPE_NORMAL
- en: You can download my million digits from [here](https://raw.githubusercontent.com/BexTuychiev/medium_stories/master/2023/10_october/1_calculating_pi/pi_million_digits.txt)
    (the file is under 1 MB on GitHub).
  prefs: []
  type: TYPE_NORMAL
- en: Thank you for sticking to the end!
  prefs: []
  type: TYPE_NORMAL
