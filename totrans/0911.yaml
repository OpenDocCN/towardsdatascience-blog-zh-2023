- en: 'Flapjax: Data Visualization on the Web with Plotly and Flask'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/flapjax-data-visualization-on-the-web-with-plotly-and-flask-465090fa3fba](https://towardsdatascience.com/flapjax-data-visualization-on-the-web-with-plotly-and-flask-465090fa3fba)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Build a data visualisation web page with Plotly and Flask, and make it interactive
    with some UI components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@alan-jones?source=post_page-----465090fa3fba--------------------------------)[![Alan
    Jones](../Images/359379fab1d6685ff08080b98173e67c.png)](https://medium.com/@alan-jones?source=post_page-----465090fa3fba--------------------------------)[](https://towardsdatascience.com/?source=post_page-----465090fa3fba--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----465090fa3fba--------------------------------)
    [Alan Jones](https://medium.com/@alan-jones?source=post_page-----465090fa3fba--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----465090fa3fba--------------------------------)
    ·17 min read·Nov 17, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d6e1e3b1af74219738061df64cef799c.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Mae Mu](https://unsplash.com/@picoftasty?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: What is the best framework for building Data visualisation apps? Is it [Streamlit](https://medium.com/towards-data-science/streamlit-from-scratch-getting-started-f4baa7dd6493)
    or Dash, perhaps? Or maybe you could convert a Jupyter Notebook into a web app
    with [Mercury](https://medium.com/towards-data-science/build-a-web-app-with-jupyter-and-mercury-9d59661441b7),
    or [Voilá](https://medium.com/towards-data-science/how-to-share-your-jupyter-notebook-with-mercury-or-voil%C3%A0-2177110d2f6e)?
  prefs: []
  type: TYPE_NORMAL
- en: All these are great ways of creating applications and are fairly easy to get
    started with. But what is easy to start with can often become a little more complex
    as you become a little more adventurous. So, I am going to try and persuade you
    that going back to basics and using Python server code alongside an HTML page
    for the user interface is not as daunting as it might seem.
  prefs: []
  type: TYPE_NORMAL
- en: We can build compelling interactive applications using a fair amount of boilerplate
    code and templates, and this means that you can still concentrate on your Python
    code and exposure to HTML and Javascript is minimal. I’m calling this approach
    *Flapjax* — I’ll explain why later.
  prefs: []
  type: TYPE_NORMAL
- en: One of the simplest ways of creating a web application in Python is to use Flask,
    so that is what we will do and we’ll create an app that looks like the one in
    the image below
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/bf5e22fe0b4b24eb267590c0eb842f85.png)'
  prefs: []
  type: TYPE_IMG
- en: An example interactive app
  prefs: []
  type: TYPE_NORMAL
- en: The Flask framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flask is a minimalist framework for developing Web applications. In a Flask
    app, the web page typically is built from a template and data supplied by the
    Python code — this data can be text or graphics that form the content of the webpage.
    The result is sent to the user for display in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: The diagram below shows the basic structure of an interactive app. When the
    app is running, the Python part executes on the server and passes data to the
    HTML which is running in the browser. The user input from the web page is passed
    back to the Python code which may then send more data to update the HTML with
    new content — a new chart that has been selected by the user, for example.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/44e68bc2cef4a95a663df7c843984269.png)'
  prefs: []
  type: TYPE_IMG
- en: Is it the easiest method for creating a web application?
  prefs: []
  type: TYPE_NORMAL
- en: To my mind separating the user interface design from the program logic does,
    indeed, make life easier. But, if you are used to building your apps in Streamlit
    or Jupyter Notebooks, then you might find that there is a bit of a learning curve.
    However, once you have adopted a pattern for a basic application, creating a new
    one is very much easier.
  prefs: []
  type: TYPE_NORMAL
- en: So, we’ll develop a data visualisation application using Flask and we’ll also
    use Jinja templates that will define our HTML pages — although the actual data
    that appears in those pages will be defined in our Python code.
  prefs: []
  type: TYPE_NORMAL
- en: To make an interactive user interface, we’ll need some UI components and a little
    Javascript but we’ll see that this is pretty much boilerplate code that can be
    reused in future applications.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use Bootstrap 5 UI components because why would you be satisfied
    with a web page that looks like the one on the left when with a bit more effort
    you could make it like the one on the right?
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/604849608ee775264c998086fd66c9ee.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This tutorial is in two parts: first, we create a static webpage and get our
    heads around the way Flask and HTML work together and next we’ll deal with callbacks
    to create an interactive page.'
  prefs: []
  type: TYPE_NORMAL
- en: All of the code for this article will be in my GitHub repository. I’ll link
    to this at the end shortly after publication.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It doesn’t take a lot of effort to create attractive web pages with Bootstrap.
    Including the Bootstrap 5 files and adding some attributes to the HTML elements
    makes it easy to improve basic HTML.
  prefs: []
  type: TYPE_NORMAL
- en: This is not a Bootstrap tutorial but let me quickly show you the difference
    between the basic HTML code that makes the header in the two webpages, above.
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic HTML**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**With added Bootstrap attributes**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that the header consists of two elements an `<h1>,` a top-level
    heading, and a paragraph `<p>`. In the Bootstrap version, those elements have
    added attributes: the header itself has a *primary* background colour with white
    text, the text is centred and padding at the top and bottom is set to 2 pixels;
    the heading tag uses the `display-4` font and the font for the paragraph is set
    to `lead`— these fonts are defined in Bootstrap with the `display` fonts being
    large and bold and the `lead` is for normal text that needs to stand out.'
  prefs: []
  type: TYPE_NORMAL
- en: These characteristics are set in an HTML `class` attribute. We’ll see more of
    these in the code that follows and they should be fairly easy to understand. I
    won’t be describing them in any detail but you can find the Bootstrap documentation
    on [their website](https://getbootstrap.com/) — this will tell you everything
    you need to know.
  prefs: []
  type: TYPE_NORMAL
- en: A Flask project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Flask framework makes it easy to create web-based applications. A Flask
    application will normally consist of at least two files: a Python app and an HTML
    template.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python part contains the application logic: for example, in a data visualisation
    app, it might load the data into a Pandas dataframe, do some analysis and create
    a chart in Plotly. The HTML template defines the layout of the webpage and is
    supplied with the data to display by the Python program.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The directory structure for a simple app, like the one we are going to create,
    should look like the diagram above. The main Python app is in the project folder
    and the template(s) are in a sub-folder called *templates*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you will also need to install Flask:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: And you might want to create a virtual environment before doing so.
  prefs: []
  type: TYPE_NORMAL
- en: The Python part of a Flask app defines one or more routes that the app will
    respond to. Typically one of those routes is ‘/’ the project’s root.
  prefs: []
  type: TYPE_NORMAL
- en: Below is a minimal Python app that uses a template. The template is called *index.html*
    and must be in the *templates* folder and it is rendered as a webpage by Flask
    using the `render_template()` library function. Notice that we create a value
    for the title of the webpage and pass this to the function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Below is the *index.html* template that expects the value `title` to be incorporated
    into it. You can see that the identifier `title` is enclosed in double curly brackets
    in the `<h1>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Flask uses the Jinja templating engine to substitute the placeholders in the
    HTML template with the values that are passed to `render_template()`.
  prefs: []
  type: TYPE_NORMAL
- en: You run the application by typing `flask run` in a terminal and you should get
    a response similar to the one below. (This assumes that you’ve called your application
    *app.py —* if you’ve called it something else you need to type `flask --app app_name
    run`. Change `app_name` to the name of your app without the `.py` extension.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Point your browser at *http://127.0.0.1:5000* or *localhost:5000* and you will
    see a simple web page that displays the text that was defined in the Python code.
  prefs: []
  type: TYPE_NORMAL
- en: To find out more about Flask, you could start by looking at their [Quickstart](https://flask.palletsprojects.com/en/3.0.x/quickstart/)
    tutorial but, I hope I’ll cover everything you need to know to get started, here.
  prefs: []
  type: TYPE_NORMAL
- en: A static data visualisation application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our first application will build on what we have seen so far to produce a website
    that contains a Plotly chart and some supporting text. Later, we’ll go on to add
    some interactivity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the Python side of things. The listing is below but for
    the moment, concentrate on the section that begins with the comment `#### Simple
    template ####`. Here you can see that we have defined a route called `/simple`
    which means that we invoke the app by pointing our browser at *localhost:5000/simple*,
    and the function below the decorator, `simpleindex(),` will be executed.'
  prefs: []
  type: TYPE_NORMAL
- en: In this function, we set up some text and a graph we want to display on the
    webpage. We first set some variables and then use these to create a dictionary
    of parameters that the HTML template will use. The names of the variables make
    it plain how they will be used.
  prefs: []
  type: TYPE_NORMAL
- en: The graph parameter is set using the function `get_graph()`. This first of all
    loads the data which are global temperature anomalies from 1881 to 2022 and tracks
    the way climate change is affecting temperatures over that time (for a detailed
    view on this please see [New Data Demonstrates that 2023 was the Hottest Summer
    Ever](/new-data-demonstrates-that-2023-was-the-hottest-summer-ever-d92d500a8f01)).
    The data is shown in the table below (it’ll look better in the graph!).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/560ca8eb44fd84bfdd8efac6f29c0470.png)'
  prefs: []
  type: TYPE_IMG
- en: Global temperature anomalies
  prefs: []
  type: TYPE_NORMAL
- en: For the static app, we will use a single column `JJA` which refers to the temperatures
    in June, July and August. The interactive app will use some of the others, too,
    so we have a default value for the `period` parameter for our current app which
    can then be changed by the interactive app, later.
  prefs: []
  type: TYPE_NORMAL
- en: The data is used to create a Plotly bar chart and the figure generated is converted
    to JSON which will be used by the webpage. So, it is this JSON data that is returned
    to set the `graph` entry in the dictionary of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to the previous function, we now need to call `render_template` with
    the parameters that we have set. To save typing, I’ve created a helper function
    called `template` that extracts the template parameter and passes all the data
    to the webpage.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now for the HTML template. The listing is below and the good news is that you
    can ignore everything except the code within the `<body>...</body>` tags. All
    of the rest is boilerplate code that you need for a webpage that uses Bootstrap
    and Plotly, and this can be cut-and-pasted into any similar webpage. The final
    `<script>` tag is also boilerplate code that includes the Bootstrap Javascript
    code and can be safely ignored.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If we also ignore the Bootstrap attributes that make the page look nice, we
    end up with the code below, which is much less daunting and this is what I will
    refer to from here on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We’ve seen the use of Jinja parameters before, the only difference this time
    is that we’ve bundled a few parameters into a dictionary called `params`. So,
    we refer to them by prefixing their names with the name of the dictionary. So,
    `<h1>{{params.title}}</h1>` is simply putting the `title` parameter into a pair
    of heading tags. The other three tags for the text parameters are similar.
  prefs: []
  type: TYPE_NORMAL
- en: To draw the graph we need an element in which to put it and that element must
    have an *id* attribute(`<div id='chart'></div>`). This element is positioned below
    the headings and above the description.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script element below this is again boilerplate code that invokes the Plotly
    Javascript to draw the chart. The only thing to notice here is that when we include
    the `graph` parameter, we use the keyword `safe`. This instructs Jinja not to
    try and interpret any special characters in `graph` but to treat them literally
    as they are. Hence the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, remember that the template must be in the templates folder in the project
    directory and for this code to work, the data file must be in the project directory
    itself (you can move it, of course, but you will have to change the path when
    opening it in your Python program).
  prefs: []
  type: TYPE_NORMAL
- en: So run the app and point your browser at *localhost:5000/simple*, and you should
    see a webpage like the one below.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/026a7f8a007aa2461ecefee20a00d8f3.png)'
  prefs: []
  type: TYPE_IMG
- en: A static app
  prefs: []
  type: TYPE_NORMAL
- en: And that is the static version of the web app.
  prefs: []
  type: TYPE_NORMAL
- en: An interactive data visualisation application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'But why restrict ourselves to Summer? Wouldn’t it be nice if we were to be
    able to choose a period other than *JJA*? The data also contains columns for the
    whole year, *J-D*, and the three-month periods: *DJF*, *MAM*, *JJA* and *SON*.
    (The letters represent the month names in English: December, January, February;
    March, April, May; and so on.)'
  prefs: []
  type: TYPE_NORMAL
- en: To do this we need to incorporate a user control that can be used to select
    the appropriate period. I’ve chosen a drop-down menu that will display the various
    periods. It will look pretty similar to the previous webpage (see the image below).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/bf5e22fe0b4b24eb267590c0eb842f85.png)'
  prefs: []
  type: TYPE_IMG
- en: An interactive app
  prefs: []
  type: TYPE_NORMAL
- en: The code is initially quite similar, too. The major difference comes when dealing
    with the selection of a new graph.
  prefs: []
  type: TYPE_NORMAL
- en: When a new value is selected, this will call a Javascript function that will
    send the value to a callback function on the server and wait for a response. This
    callback function will return a new chart which will then be displayed by the
    calling Javascript.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s deal with the familiar stuff first. Below is the function that implements
    the new endpoint */ddsimple*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see it is very similar to the /*simple* endpoint. The difference
    (apart from the names) is that there are extra parameters: a label for the menu
    and a dictionary that represents a list of entries for the menu, first a value
    that corresponds to a column in the dataframe and second a textual description
    of that value which will be displayed in the menu.'
  prefs: []
  type: TYPE_NORMAL
- en: The HTML is a little different as it demonstrates a more sophisticated use of
    Jinja. The code is below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here we construct a form with a drop-down menu. The form also contains a label
    for the menu which is included in the double curly brackets that we have seen
    before.
  prefs: []
  type: TYPE_NORMAL
- en: The major difference from the previous example is the way the menu is constructed.
    Within the element `<select>` we need to place a list of `<option>` tags that
    represent the options given in the menu. The option tag has a value and a description
    which are what we have defined in the `params.options` dictionary. We include
    those values and descriptions by executing a Jinja loop like this `{% for opt
    in param.options %}` which iterates over the dictionary putting each element into
    a local variable `opt`. We then use this to insert the values and descriptions
    into an `<option>` tag using the values `opt.code` and `opt.desc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find simple examples and explanations of Jinja templates and the way
    they are used in [Flask Tutorial: Templates on the Pythonbasics.org website](https://pythonbasics.org/flask-tutorial-templates/).'
  prefs: []
  type: TYPE_NORMAL
- en: There is another part of the form tag that is essential to our purposes here.
    Within the form tag is an attribute called `onChange` this takes a value of some
    sort of action, in this case, it is a Javascript function that is called whenever
    a value with the form changes — in this case when one of the options in the menu
    is chosen.
  prefs: []
  type: TYPE_NORMAL
- en: And that is where the fun begins.
  prefs: []
  type: TYPE_NORMAL
- en: Callbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to update a web page with a new chart we use a callback mechanism and
    the chart below shows the transactions between the browser and the server. Note
    that the response to requesting a new chart is *not* to reload the page but to
    update it — this is quicker and avoids the momentary blank screen that accompanies
    a reload giving a much nicer user experience.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/017940485c124abb31584f388fec0575.png)'
  prefs: []
  type: TYPE_IMG
- en: Using a callback to update a webpage
  prefs: []
  type: TYPE_NORMAL
- en: The callback is invoked by a change in the form on the web page, as we mentioned
    before. The mechanism for this is a Javascript function that is identified in
    the `onChange` attribute in the form.
  prefs: []
  type: TYPE_NORMAL
- en: I’m going to explain how the Javascript function works in detail shortly but
    essentially, it grabs the values from the form and sends them to a callback endpoint
    in the Flask app.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if the thought of writing Javascript gives you the heebie-jeebies, don’t
    worry, you don’t really need to know how this stuff works, you can just copy it
    and it will work for any form that you might want to include on your web page.
    So, for the adventurous the explanation follows, for the rest — just skip to the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are actually two functions: the one that grabs the values from the form
    is shown below.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'All the code uses built-in Javascript functions: the first line gets the form
    from the document (i.e. the web page); the second line retrieves a data structure
    that contains the form data; and the third line extracts all of the values from
    that structure.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, those values are passed to another function `postJson`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This function is an asynchronous function which means that after it is called,
    program execution returns immediately to the calling code and the asynchronous
    function continues in a separate execution thread. That is to say, it carries
    on doing whatever it needs to do in parallel with the execution of the web page.
  prefs: []
  type: TYPE_NORMAL
- en: '`postJSON` is given the data that needs to be sent to the Python callback code
    and it sends it using the asynchronous `fetch` function. `fetch` is given the
    endpoint to which the data should be passed and the data itself as parameters
    — we use the HTTP POST mechanism to send the data. `postJSON` waits for the fetch
    to finish, i.e. for some data to be returned from the server. That data is then
    passed to the `drawGraph` function which updates the graph on the webpage.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the code is contained in a `try... catch...` block. This is pretty
    much the same as you would find in a Python program: if the code in the `try`
    block fails — there is no response or some other communications failure — then
    that failure is logged in the console.'
  prefs: []
  type: TYPE_NORMAL
- en: The Python callback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For all this to work, we need a callback function in the Flask code which will
    receive the data, do something with it (i.e. create a new graph) and send back
    a result. Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to do is to define the endpoint for the callback and you can
    see that we also specify that the endpoint expects data to be sent using the POST
    method.
  prefs: []
  type: TYPE_NORMAL
- en: We also expect the data to be in JSON format and if it isn’t we return an error.
  prefs: []
  type: TYPE_NORMAL
- en: If the data *is* JSON then we extract the value from the dropdown menu and pass
    it to the `get_graph` function which draws a graph and returns it in the JSON
    format that Plotly expects. This graph data is received by the Javascript function
    on the webpage and the page is updated.
  prefs: []
  type: TYPE_NORMAL
- en: This code will give you the interactive webpage above.
  prefs: []
  type: TYPE_NORMAL
- en: Flapjax — what’s in a name
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Admittedly, it is a fairly contrived name: it stands for **Fla**sk, **P**ython,
    **J**avascript and **ax** which represents the asynchronous communication that
    enables this technique.'
  prefs: []
  type: TYPE_NORMAL
- en: I hope that you can see that by using pre-written templates and a chunk of boilerplate
    code, you can create useful interactive web pages whilst concentrating mostly
    on the logic of your Python code.
  prefs: []
  type: TYPE_NORMAL
- en: This app incorporates only a single graph that is updated when the user selects
    a new option but any number of values can be collected from an HTML form in this
    way which can then be processed by the Flask app before updating the webpage with
    new information (maybe we’ll explore this in a future article).
  prefs: []
  type: TYPE_NORMAL
- en: All of the code and data illustrated here can be downloaded from my [GitHub
    repo](https://github.com/alanjones2/flapjax_public) (look in the folder *jinja-article*).
  prefs: []
  type: TYPE_NORMAL
- en: '*UPDATE: I’ve written a new app in the* reuse *folder of the GitHub repo that
    creates a new app with a new set of data — the HTML and Javascript remain the
    same and only the Python code and the data are changed:* [**Reusing Flapjax Templates
    and Code**](https://medium.com/codefile/reusing-flapjax-templates-and-code-0ee6db58ffc8)'
  prefs: []
  type: TYPE_NORMAL
- en: 'I hope you have found this useful. If you want to see more of my work, please
    visit my [website](http://alanjones2.github.io) and you can get updates when I
    publish by subscribing to my free newsletter, here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://technofile.substack.com/?source=post_page-----465090fa3fba--------------------------------)
    [## Data Visualization, Data Science and Python | Alan Jones | Substack'
  prefs: []
  type: TYPE_NORMAL
- en: Tutorials and other articles about Data Science, Data Visualization with hands-on
    coding mostly in Python. Click to…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: technofile.substack.com](https://technofile.substack.com/?source=post_page-----465090fa3fba--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: And if Flask isn’t your thing, I’ve written an eBook [*Streamlit from Scratch*](https://alanjones.gumroad.com/l/streamlitfromscratch)based
    on my articles from Medium.
  prefs: []
  type: TYPE_NORMAL
- en: Notes and references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The data used in this article and the app is derived from that described in
    notes 1 and 2 below.
  prefs: []
  type: TYPE_NORMAL
- en: 'GISTEMP Team, 2023: GISS Surface Temperature Analysis (GISTEMP), version 4\.
    NASA Goddard Institute for Space Studies. Dataset accessed 2023–09–19 at data.giss.nasa.gov/gistemp/.
    *Note that there is no specific license for the use of NASA’s data sets. They
    are made freely available by NASA for non-commercial purposes but attribution
    (as above) should be given.*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lenssen, N., G. Schmidt, J. Hansen, M. Menne, A. Persin, R. Ruedy, and D. Zyss,
    2019: Improvements in the GISTEMP uncertainty model. J. Geophys. Res. Atmos.,
    124, no. 12, 6307–6326, doi:10.1029/2018JD029522.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All images, diagrams, screenshots and code were created by the author unless
    otherwise noted.
  prefs: []
  type: TYPE_NORMAL
