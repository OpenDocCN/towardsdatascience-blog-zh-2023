["```py\nselect\n   VendorID,\n   tpep_dropoff_datetime as dropdate,\n   passenger_count,\n sum(passenger_count) over (\n     partition by date(tpep_dropoff_datetime)\n     order by tpep_dropoff_datetime\n     rows between unbounded preceding and current row\n ) as day_running_sum\nfrom trip_data td \n```", "```py\nimport pandas\nimport sqlite3\n\ndata = pd.read_parquet('yellow_tripdata_2023-01.parquet')\n\ncon = sqlite3.connect('taxi.db')  # creates a database \"taxi.db\"\ndata.to_sql('trip_data', con)     # name of the table\n```", "```py\nSELECT  \n       SUM(fare_amount) AS total_fare,\n       AVG(fare_amount) AS average_fare\nFROM trip_data td;\n```", "```py\nSELECT\n VendorID,\n date(tpep_dropoff_datetime) as dropdate,\n SUM(fare_amount) AS total_fare,\n    AVG(fare_amount) AS average_fare\nFROM trip_data td\ngroup by VendorID, dropdate\n```", "```py\nselect\n   VendorID,\n   date(tpep_dropoff_datetime) as dropdate,\n   fare_amount,\n   sum(fare_amount) over (\n      partition by date(tpep_dropoff_datetime), VendorID \n      order by tpep_dropoff_datetime\n      rows between unbounded preceding and current row\n   ) as rolling_sum,\n   avg(fare_amount) over (\n      partition by date(tpep_dropoff_datetime), VendorID \n      order by tpep_dropoff_datetime\n      rows between unbounded preceding and current row\n ) as rolling_mean\nfrom trip_data td;\n```", "```py\nselect\n VendorID,\n date(tpep_dropoff_datetime) as dropdate,\n fare_amount,\n round(sum(fare_amount) over (\n  partition by date(tpep_dropoff_datetime), VendorID \n  order by tpep_dropoff_datetime\n  rows between 1 preceding and current row --> NOW 1 Preceding row only\n ),2) as rolling_sum,\n round(avg(fare_amount) over (\n  partition by date(tpep_dropoff_datetime), VendorID \n  order by tpep_dropoff_datetime\n  rows between 1 preceding and current row --> NOW 1 Preceding row only\n ),2) as rolling_mean\nfrom trip_data td \n```", "```py\nwith aggregated as (\n select\n    VendorID,\n    date(tpep_dropoff_datetime) as dropdate,\n    round(sum(fare_amount),2) as total\n from trip_data td \n where dropdate like '2023%' -- this to remove wrong 2020 data in the dataset\n group by VendorID, dropdate\n order by dropdate asc\n) -- here our \"aggregated\" data subset is created\nselect \n  VendorID,\n  dropdate,\n  total,\n  rank() over (\n      partition by VendorID\n      order by total desc\n  ) as best_days\nfrom aggregated -- we rank() based on \"aggregated\"\n```"]