["```py\nrequested_usernames = [\"John123\", \"Delilah42\"]\ntaken_usernames = []\nfor username in requested_usernames:\n  if username not in taken_usernames:\n    taken_usernames.append(username)\n  else:\n    print(f\"Username '{username}' is already taken!\")\n```", "```py\nrequested_usernams = [\"John123\", \"Delilah42\"] \ntaken_usernames = set()\nfor username in requested_usernames:\n  if username not in taken_usernames:\n    taken_usernames.add(username)\n  else:\n    print(f\"Username '{username}' is already taken!\")\n```", "```py\n# more junior example\nweekdays = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"]\n\nfor day in weekdays:\n  ...\n\n--------------------------------------------------------------------------\n# more senior example\nWEEKDAYS = (\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\")\n\nfor day in WEEKDAYS:\n  ...\n```", "```py\n2nd_name = \"John\"\n\n# output \nSyntaxError: invalid syntax\n\n---------------------------\n\nsecond-name = \"John\"\n\n# output \nSyntaxError: invalid syntax\n```", "```py\n# circle.py\n\nPI = 3.14 # Value won't change, so it's a constant\n\nclass Circle:\n    def __init__(self, radius: float):\n        self.radius = radius\n\n    @property\n    def area(self):\n        return (self.radius **2) * PI\n\n    @property\n    def perimeter(self):\n        return 2 * self.radius * PI\n\nsmall_circle = Circle(1)\nbig_circle = Circle(5)\n\nprint(f\"Area of small circle = {small_circle.area}\")\nprint(f\"Perimeter of small circle = {small_circle.perimeter}\")\n\nprint(f\"Area of big circle = {big_circle.area}\")\nprint(f\"Perimeter of big circle = {big_circle.perimeter}\")\n```", "```py\n# CIRCLE.py\n\nPi = 3.14\n\nclass CIRCLE:\n    def __init__(Self, RADIUS: float):\n        Self.Radius = RADIUS\n\n    @property\n    def AREA(Self):\n        return (Self.Radius **2) * Pi\n\n    @property\n    def PERIMETER(Self):\n        return 2 * Self.Radius * Pi\n\nSmallCIRCLE = CIRCLE(1)\nBigCIRCLE = CIRCLE(5)\n\nprint(f\"Area of small circle = {SmallCIRCLE.AREA}\")\nprint(f\"Perimeter of small circle = {SmallCIRCLE.PERIMETER}\")\n\nprint(f\"Area of big circle = {BigCIRCLE.AREA}\")\nprint(f\"Perimeter of big circle = {BigCIRCLE.PERIMETER}\")\n```", "```py\ndef is_even(x):\n  return True if x % 2 == 0 else False\n\nx = 10\n\n# different comparison statements which result in the same result:\nif is_even(x) == True:\n  print(f\"{x} is an even number!\")\n\nif is_even(x) is True:\n  print(f\"{x} is an even number!\")\n\nif is_even(x):\n  print(f\"{x} is an even number!\")\n```", "```py\ndef print_each_item(items):\n  if items != []:\n    for item in items:\n      print(item)\n  else:\n    raise ValueError(\"'items' is an empty list, nothing to print!\")\n```", "```py\ndef print_each_item(items):\n  if items:\n    for item in items:\n      print(item)\n  else:\n    raise ValueError(\"No items to print inside 'items'\")\n```", "```py\n# more junior example\nif is_even(number) == True:\n\n# more senior example\nif is_even is True:\n\n-------------------\n\n# more junior example\nif value == None:\n\n# more senior example\nif value is None:\n```", "```py\ndef print_each_item(items):\n  for item in items:\n    print(item)\n```", "```py\ndef print_each_item(items):\n\n  # check whether items is iterable\n  try:\n    iter(items)\n  except TypeError as error:\n    raise (\n      TypeError(f\"items should be iterable but is of type: {type(items)}\")\n      .with_traceback(error.__traceback__)  \n    )\n```", "```py\ndef print_each_item(items):\n\n  # check whether items is an Iterable\n  try:\n    iter(items)\n  except TypeError as e:\n    raise (\n      TypeError(f\"'items' should be iterable but is of type: {type(items)}\")\n      .with_traceback(e.__traceback__)  \n    )\n\n  # if items is iterable, check whether it contains items\n  else:\n    if items:\n      for item in items:\n        print(item)\n\n    # if items doesn't contain any items, raise a ValueError\n    else:\n      raise ValueError(\"'items' should not be empty\")\n```", "```py\ndef add_exclamation_mark(sentence: str) -> str:\n  return f\"{sentence}!\"\n```", "```py\nfrom collections.abc import Iterable\n\ndef print_each_item(items: Iterable) -> None:\n  ...\n```", "```py\nfrom collections.abc import Iterable\n\ndef print_each_item(items: Iterable) -> None:\n  \"\"\"\n  Prints each item of an iterable.\n\n  Parameters:\n  -----------\n  items : Iterable\n      An iterable containing items to be printed.\n\n  Raises:\n  -------\n  TypeError: If the input is not an iterable.\n  ValueError: If the input iterable is empty.\n\n  Returns:\n  --------\n  None\n\n  Examples:\n  ---------\n  >>> print_each_item([1,2,3])\n  1\n  2\n  3\n\n  >>> print_each_item(items=[])\n  ValueError: 'items' should not be empty\n  \"\"\"\n  ...\n```", "```py\nimport logging\n\nlogger = logging.getLogger(__name__)\n```", "```py\nimport logging\nfrom collections.abc import Iterable\n\nlogger = logging.getLogger(__name__)\n\ndef print_each_item(items: Iterable) -> None:\n  \"\"\"\n  <docstring>\n  \"\"\"\n  logger.debug(\n    f\"Printing each item of an object that contains {len(items)} items.\"\n  )\n  ... \n```", "```py\nimport logging\nfrom collections.abc import Iterable\n\nlogger = logging.getLogger(__name__)\n\ndef print_each_item(items: Iterable) -> None:\n  \"\"\"\n  <docstring>\n  \"\"\"\n\n  logger.debug(\n      f\"Printing each item of an object that contains {len(items)} items.\"\n    )\n\n  # check whether items is iterable\n  try:\n    iter(items)\n  except TypeError as e:\n    error_msg = f\"'items' should be iterable but is of type: {type(items)}\"\n    logger.error(error_msg)\n    raise TypeError(error_msg).with_traceback(e.__traceback__)\n\n  # if items is iterable, check whether it contains items\n  else:\n    if items:\n      for item in items:\n        print(item)\n\n    # if items doesn't contain any items, raise a ValueError\n    else:\n      error_msg = \"'items' should not be empty\"\n      logger.error(error_msg)\n      raise ValueError(error_msg)\n```"]