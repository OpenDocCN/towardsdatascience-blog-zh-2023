- en: 'Data Mastery with Python and SQL: Unleashing Efficiency and Security through
    4 Strategic Use Cases'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/data-mastery-with-python-and-sql-unleashing-efficiency-and-security-through-4-strategic-use-cases-eb8afb5019a0](https://towardsdatascience.com/data-mastery-with-python-and-sql-unleashing-efficiency-and-security-through-4-strategic-use-cases-eb8afb5019a0)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Leverage techniques to extract hashtags, suppress warnings, and utilize parameterized
    queries for powerful data analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://mg-subha.medium.com/?source=post_page-----eb8afb5019a0--------------------------------)[![Subha
    Ganapathi](../Images/d346759d5990b79aae7ef2c3a5ab7cf3.png)](https://mg-subha.medium.com/?source=post_page-----eb8afb5019a0--------------------------------)[](https://towardsdatascience.com/?source=post_page-----eb8afb5019a0--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----eb8afb5019a0--------------------------------)
    [Subha Ganapathi](https://mg-subha.medium.com/?source=post_page-----eb8afb5019a0--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----eb8afb5019a0--------------------------------)
    ·9 min read·May 23, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a8b97bf986c302ad322092d021f198d6.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Kevin Canlas](https://unsplash.com/@kvncnls?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
    on [Unsplash](https://unsplash.com/photos/BHPGjYd4fp8?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data analysis and management are essential components of any modern enterprise’s
    operations. To effectively harness the power of data, professionals rely on a
    combination of programming languages and tools that enable efficient data processing,
    manipulation, and analysis. In this article, we explore the incredible capabilities
    of Python and SQL, two fundamental languages widely utilized by data analysts
    and scientists for effective decision-making.
  prefs: []
  type: TYPE_NORMAL
- en: It is a known fact that Python provides a plethora of libraries and frameworks
    to tackle diverse data-related challenges. Together, Python and SQL form a powerful
    duo that enables data professionals to unlock the full potential of their data
    and mine their databases more effectively.
  prefs: []
  type: TYPE_NORMAL
- en: In this article, we look into four distinct use cases that demonstrate the effectiveness
    and synergy of Python and SQL in addressing various data challenges. Each use
    case represents a unique scenario where the combined prowess of Python’s flexibility
    and SQL’s querying capabilities shines through.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dive in!
  prefs: []
  type: TYPE_NORMAL
- en: Use Cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Use Case 1: Enhance the readability of SQL Queries written in Python**'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you’re using a Web API to connect to a cloud database, such as GridDB,
    and retrieve data by executing SQL queries. When constructing an HTTP request
    body, specifically for an API endpoint that accepts JSON payloads, the SQL query
    needs to be incorporated in the request body. But the challenge lies with real-world
    queries.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world SQL queries tend to become more intricate and can often become challenging
    to maintain proper indentation, incorporate line breaks, and format the code for
    readability. Additionally, when constrained to writing queries in a single line
    in a Python notebook such as VScode or Jupyter, it becomes impossible to add helpful
    comment lines to explain the code’s functionality. Notebooks with such queries
    become difficult to maintain and debug in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: The below solution allows you to write SQL queries in multiple lines, which
    improves code readability and maintainability. By using proper line breaks and
    indentation, you can easily organize and understand complex queries without sacrificing
    clarity.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a better way to write SQL queries in Python.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This can then passed to the request body using the JSON library in Python as
    shown below -
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It creates a JSON object with a single item, which contains the type of operation
    (“sql-select”) and the SQL query statement (sql_query1). The json.dumps() function
    is used to convert the Python dictionary into a JSON string representation.
  prefs: []
  type: TYPE_NORMAL
- en: You can then proceed to posting your request using the requests library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Use Case **2: Extract hashtags from a text column**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When conducting social media analysis of platforms like TikTok and Instagram,
    it is common to extract data through APIs and store it in databases like Azure
    or Redshift. However, the API response often includes the content as a string,
    with hashtags scattered throughout the video titles. To address this, the following
    query can be used to extract hashtags from a a text column such as a video title.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The subquery performs the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: It splits the “title” column of the “social_media_video_info” table using the
    ‘#’ character as the delimiter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function SPLIT_PART(title, ‘#’, num) extracts the portion of the “title”
    column delimited by ‘#’ at the specified “num” position.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The TRIM() function removes any leading or trailing spaces from the extracted
    portion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DISTINCT keyword ensures that only unique hashtags are selected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CROSS JOIN with the subquery “nums” generates a temporary result set with
    numbers from 1 to 10.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The condition num <= LENGTH(title) — LENGTH(REPLACE(title, ‘#’, ‘’)) + 1 ensures
    that the splitting is done up to the maximum number of hashtags in the “title”
    column.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The condition TRIM(SPLIT_PART(title, ‘#’, num)) <> ‘’ filters out any empty
    hashtags.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, the query extracts hashtags from the “title” column of the “social_media_video_info”
    table by splitting the column values using ‘#’ as the delimiter. It ensures that
    only unique non-empty hashtags are selected, and any hashtags containing spaces
    are excluded from the result. Note that this query only considers **upto 10 hashtags
    per title.**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use Case 3: Suppressing Future and Deprecation Warnings in Python'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The purpose of these lines is to suppress future warnings and deprecation warnings
    during the execution of the program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This can be useful in situations where you are confident that the code you are
    using is compatible with the current version of the library and you don’t want
    to be alerted about potential issues or deprecated features.
  prefs: []
  type: TYPE_NORMAL
- en: Warnings often provide valuable information about potential problems or changes
    in future versions of libraries. It’s generally recommended to address and resolve
    the underlying issues causing the warnings rather than ignoring them outright.
    The ‘warnings’ module also provides a simplefilter() option which can be used
    to control how warnings are handled in your Python code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use Case 4: Use parameterized queries where possible'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When executing SQL queries using Python, it is recommended to use parameterized
    queries or prepared statements instead of directly embedding values in the SQL
    statement. This helps prevent SQL injection attacks and ensures proper handling
    of data types.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say that your application or script uses the below select query -
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If an attacker wants to insert a malicious value in your database, they can
    use this query as a loophole to do so. Below is a basic example of how the attacker
    can add an insert statement to a ‘select query’ and inject unnecessary values
    to the database. The grey portion below is the malicious input that the attacker
    provided which results in 2 queries being executed instead of one — 1\. select
    and 2\. insert.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/545f8b650e83cd3f35635e06f60b8256.png)'
  prefs: []
  type: TYPE_IMG
- en: '**SQL Injection Attack — Scenario Highlighted (Image by author)**'
  prefs: []
  type: TYPE_NORMAL
- en: Note that this is not limited to an Insert table. An attacker can run another
    select or update or delete or even do a drop table. Imagine how disastrous a ‘DROP
    TABLE’ would be!
  prefs: []
  type: TYPE_NORMAL
- en: SQL injection can be prevented by sanitizing the input as well as by parameterization.
    Let’s see each of them in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Parameterization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Parameterization can be done manually or through packages available in Python.
    Imagine that you use a survey application from which you send surveys for users
    to fill out. Users are asked to type-in details in two text boxes provided. Let’s
    suppose that every time the user inputs the detail in both text boxes, an Insert
    SQL query runs in the background such as the one below -
  prefs: []
  type: TYPE_NORMAL
- en: theVal1 = comes from survey textbox1
  prefs: []
  type: TYPE_NORMAL
- en: theVal2 = comes from survey textbox2
  prefs: []
  type: TYPE_NORMAL
- en: Below is the application code that runs in the background -
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Let’s say the 1st user enters **A3 in textbox1** and enters **A4 in the textbox2**.
    The query that runs in the backend will be as below -
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let’s say the second user is a hacky user. This user understands your table
    structure and backend query. If they are onto some mischief, they can try to maliciously
    insert an additional record using this.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s suppose that the user types in **the value A1 in textbox 1** and the **below
    value in textbox2** -
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: What essentially happens is that the value gets appended to the backend query
    to become the below -
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Thus, 2 records will be inserted by this hacky user.
  prefs: []
  type: TYPE_NORMAL
- en: Your table will have three values, 1 inserted by the first user, and 2 inserted
    by the second user -
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/03962e3f43854c5d6eef89bed4491669.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Backend Table (Image by author)**'
  prefs: []
  type: TYPE_NORMAL
- en: Input Sanitization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sanitization can be done by escaping special characters in the input. This involves
    replacing or encoding characters that have a special meaning in the target context
    (e.g., SQL queries) with their escaped counterparts. For example, in SQL, the
    single quote character (‘) is commonly escaped by doubling it (‘’) i.e., **replacing
    the single quote in the string with 2 single quotes.** In other words, we can
    manually escape the input values before putting it into the query. We can use
    str.replace to do this.
  prefs: []
  type: TYPE_NORMAL
- en: While the application code remains the same, we add a couple of string replace
    statements as shown below -
  prefs: []
  type: TYPE_NORMAL
- en: theVal1 = comes from survey textbox1
  prefs: []
  type: TYPE_NORMAL
- en: theVal2 = comes from survey textbox2
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: What happens as a result is that, when the hacky user tries to insert a malicious
    record, it will get inserted along with the user’s insert statement. It’ll look
    like the one below -
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The values inserted in your table would be as below -
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/94f48d4de185feb9b21d9bec8b2be6ca.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Backend Tables after escaping quotes (Image by author)**'
  prefs: []
  type: TYPE_NORMAL
- en: Thereby, you’ll see in your backend table that one of the users tried to run
    an insert statement. **You have effectively stopped a SQL injection from happening
    by merely escaping your input variables.**
  prefs: []
  type: TYPE_NORMAL
- en: A more optimal way would be to use python libraries such as psycopg2, pyodbc,
    sqlite3 or SQLAlchemy. These are SQL adapters that have inbuilt support for parameterized
    queries among other features.
  prefs: []
  type: TYPE_NORMAL
- en: Concluding Remarks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this article, we explored four practical use cases to enhance your Python
    programming skills when working with SQL queries. We started with Use Case 1,
    where we focused on improving the readability of SQL queries written in Python.
    By utilizing techniques such as query formatting and indentation, we can make
    our code more organized and easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on to Use Case 2, we delved into the extraction of hashtags from a text
    column. By leveraging SQL and its string manipulation functions, we learnt how
    to effectively extract relevant hashtags and enhance the data analysis process.
  prefs: []
  type: TYPE_NORMAL
- en: In Use Case 3, we addressed the importance of suppressing future and deprecation
    warnings in Python. By utilizing the `warnings` module, we can ensure a cleaner
    Python output and an error-free code execution, avoiding unnecessary distractions
    and potential compatibility issues.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, in Use Case 4, we emphasized the significance of using sanitized code
    and parameterized queries to enhance security, improve performance, and prevent
    SQL injection attacks.
  prefs: []
  type: TYPE_NORMAL
- en: By understanding and implementing these use cases, Python developers and Data
    Analysts can elevate their SQL query execution and optimization skills, leading
    to more robust and efficient code. I believe that incorporating these techniques
    in real-world scenarios will help create cleaner workflows and will empower you
    to derive actionable insights efficiently and securely.
  prefs: []
  type: TYPE_NORMAL
