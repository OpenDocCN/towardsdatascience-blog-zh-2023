["```py\nStep 1\\. Environment Setup\nStep 2\\. 3D Data Preparation\nStep 3\\. Data Pre-Processing\nStep 4\\. Parameter Setting\nStep 5\\. RANSAC Planar Detection\nStep 6\\. Multi-Order RANSAC\nStep 7\\. Euclidean Clustering Refinement\nStep 8\\. Voxelization Labelling\nStep 9\\. Indoor Spatial Modelling\nStep 10\\. 3D Workflow Export\n```", "```py\nconda install numpy\nconda install matplotlib\npip install open3d==0.16.0\n```", "```py\n#%% 1\\. Library setup\nimport numpy as np\nimport open3d as o3d\nimport matplotlib.pyplot as plt\n```", "```py\nDATANAME = \"ITC_groundfloor.ply\"\npcd = o3d.io.read_point_cloud(\"../DATA/\" + DATANAME)\n```", "```py\npcd_center = pcd.get_center()\npcd.translate(-pcd_center)\n```", "```py\no3d.visualization.draw_geometries([pcd])\n```", "```py\nretained_ratio = 0.2\nsampled_pcd = pcd.random_down_sample(retained_ratio)\n```", "```py\no3d.visualization.draw_geometries([sampled_pcd], window_name = \"Random Sampling\")\n```", "```py\nnn = 16\nstd_multiplier = 10\n\nfiltered_pcd, filtered_idx = pcd.remove_statistical_outlier(nn, std_multiplier)\n```", "```py\noutliers = pcd.select_by_index(filtered_idx, invert=True)\noutliers.paint_uniform_color([1, 0, 0])\no3d.visualization.draw_geometries([filtered_pcd, outliers])\n```", "```py\nvoxel_size = 0.05\npcd_downsampled = filtered_pcd.voxel_down_sample(voxel_size = voxel_size)\n```", "```py\no3d.visualization.draw_geometries([pcd_downsampled])\n```", "```py\nnn_distance = 0.05\n```", "```py\nradius_normals=nn_distance*4\npcd_downsampled.estimate_normals(search_param=o3d.geometry.KDTreeSearchParamHybrid(radius=radius_normals, max_nn=16), fast_normal_computation=True)\n```", "```py\npcd_downsampled.paint_uniform_color([0.6, 0.6, 0.6])\no3d.visualization.draw_geometries([pcd_downsampled,outliers])\n```", "```py\nnn_distance = np.mean(pcd.compute_nearest_neighbor_distance())\n```", "```py\ndistance_threshold = 0.1\nransac_n = 3\nnum_iterations = 1000\n```", "```py\nplane_model, inliers = pcd.segment_plane(distance_threshold=distance_threshold,ransac_n=3,num_iterations=1000)\n[a, b, c, d] = plane_model\nprint(f”Plane equation: {a:.2f}x + {b:.2f}y + {c:.2f}z + {d:.2f} = 0\")\n```", "```py\ninlier_cloud = pcd.select_by_index(inliers)\noutlier_cloud = pcd.select_by_index(inliers, invert=True)\n\n#Paint the clouds\ninlier_cloud.paint_uniform_color([1.0, 0, 0])\noutlier_cloud.paint_uniform_color([0.6, 0.6, 0.6])\n\n#Visualize the inliers and outliers\no3d.visualization.draw_geometries([inlier_cloud, outlier_cloud]) \n```", "```py\nsegment_models={}\nsegments={}\n```", "```py\nmax_plane_idx=10\n```", "```py\nrest=pcd\nfor i in range(max_plane_idx):\n    colors = plt.get_cmap(\"tab20\")(i)\n    segment_models[i], inliers = rest.segment_plane(\n    distance_threshold=0.1,ransac_n=3,num_iterations=1000)\n    segments[i]=rest.select_by_index(inliers)\n    segments[i].paint_uniform_color(list(colors[:3]))\n    rest = rest.select_by_index(inliers, invert=True)\n    print(\"pass\",i,\"/\",max_plane_idx,\"done.\")\n```", "```py\no3d.visualization.draw_geometries([segments[i] for i in range(max_plane_idx)]+[rest])\n```", "```py\nepsilon = 0.15\nmin_cluster_points = 5\n```", "```py\nlabels = np.array(segments[i].cluster_dbscan(eps=epsilon, min_points=min_cluster_points))\n```", "```py\ncandidates=[len(np.where(labels==j)[0]) for j in np.unique(labels)]\n```", "```py\nbest_candidate=int(np.unique(labels)[np.where(candidates== np.max(candidates))[0]])\n```", "```py\nrest = rest.select_by_index(inliers, invert=True) + segments[i].select_by_index(list(np.where(labels!=best_candidate)[0]))\nsegments[i]=segments[i].select_by_index(list(np.where(labels== best_candidate)[0]))\n```", "```py\ncolors = plt.get_cmap(\"tab20\")(i)\nsegments[i].paint_uniform_color(list(colors[:3]))\n```", "```py\no3d.visualization.draw_geometries([rest])\n```", "```py\nlabels = np.array(pcd.cluster_dbscan(eps=0.1, min_points=10))\n```", "```py\nmax_label = labels.max()\ncolors = plt.get_cmap(\"tab20\")(labels / (max_label \nif max_label > 0 else 1))\ncolors[labels < 0] = 0\nrest.colors = o3d.utility.Vector3dVector(colors[:, :3])\no3d.visualization.draw_geometries([rest])\n```", "```py\nvoxel_size=0.5\n```", "```py\nmin_bound = pcd.get_min_bound()\nmax_bound = pcd.get_max_bound()\n```", "```py\npcd_ransac=o3d.geometry.PointCloud()\nfor i in segments:\n pcd_ransac += segments[i]\n```", "```py\nvoxel_grid_structural = o3d.geometry.VoxelGrid.create_from_point_cloud(pcd_ransac, voxel_size=voxel_size)\n```", "```py\nrest.paint_uniform_color([0.1, 0.1, 0.8])\nvoxel_grid_clutter = o3d.geometry.VoxelGrid.create_from_point_cloud(rest, voxel_size=voxel_size)\n```", "```py\no3d.visualization.draw_geometries([voxel_grid_clutter,voxel_grid_structural])\n```", "```py\ndef fit_voxel_grid(point_cloud, voxel_size, min_b=False, max_b=False):\n# This is where we write what we want our function to do.\nreturn voxel_grid, indices\n```", "```py\n# Determine the minimum and maximum coordinates of the point cloud\n if type(min_b) == bool or type(max_b) == bool:\n   min_coords = np.min(point_cloud, axis=0)\n   max_coords = np.max(point_cloud, axis=0)\n else:\n   min_coords = min_b\n   max_coords = max_b\n # Calculate the dimensions of the voxel grid\n grid_dims = np.ceil((max_coords - min_coords) / voxel_size).astype(int)\n # Create an empty voxel grid\n voxel_grid = np.zeros(grid_dims, dtype=bool)\n # Calculate the indices of the occupied voxels\n indices = ((point_cloud - min_coords) / voxel_size).astype(int)\n # Mark occupied voxels as True\n voxel_grid[indices[:, 0], indices[:, 1], indices[:, 2]] = True\n```", "```py\nvoxel_size = 0.3\n\n#get the bounds of the original point cloud\nmin_bound = pcd.get_min_bound()\nmax_bound = pcd.get_max_bound()\n\nransac_voxels, idx_ransac = fit_voxel_grid(pcd_ransac.points, voxel_size, min_bound, max_bound)\nrest_voxels, idx_rest = fit_voxel_grid(rest.points, voxel_size, min_bound, max_bound)\n\n#Gather the filled voxels from RANSAC Segmentation\nfilled_ransac = np.transpose(np.nonzero(ransac_voxels))\n\n#Gather the filled remaining voxels (not belonging to any segments)\nfilled_rest = np.transpose(np.nonzero(rest_voxels))\n\n#Compute and gather the remaining empty voxels\ntotal = pcd_ransac + rest\ntotal_voxels, idx_total = fit_voxel_grid(total.points, voxel_size, min_bound, max_bound)\nempty_indices = np.transpose(np.nonzero(~total_voxels))\n```", "```py\nxyz_segments=[]\nfor idx in segments:\n print(idx,segments[idx])\n a = np.asarray(segments[idx].points)\n N = len(a)\n b = idx*np.ones((N,3+1))\n b[:,:-1] = a\n xyz_segments.append(b)\n```", "```py\nrest_w_segments=np.hstack((np.asarray(rest.points),(labels+max_plane_idx).reshape(-1, 1)))\n```", "```py\n xyz_segments.append(rest_w_segments)\n```", "```py\nnp.savetxt(\"../RESULTS/\" + DATANAME.split(\".\")[0] + \".xyz\", np.concatenate(xyz_segments), delimiter=\";\", fmt=\"%1.9f\")\n```", "```py\ndef voxel_modelling(filename, indices, voxel_size):\n    voxel_assembly=[]\n    with open(filename, \"a\") as f:\n        cpt = 0\n        for idx in indices:\n            voxel = cube(idx,voxel_size,cpt)\n            f.write(f\"o {idx}  \\n\")\n            np.savetxt(f, voxel,fmt='%s')\n            cpt += 1\n            voxel_assembly.append(voxel)\n    return voxel_assembly\n```", "```py\nvrsac = voxel_modelling(\"../RESULTS/ransac_vox.obj\", filled_ransac, 1)\nvrest = voxel_modelling(\"../RESULTS/rest_vox.obj\", filled_rest, 1)\nvempty = voxel_modelling(\"../RESULTS/empty_vox.obj\", empty_indices, 1)\n```"]