["```py\ndef func():\n    x = 10\n    print(x)\n\nfunc() # 10\nprint(x) # Raises NameError, x is only defined within the scope of func()\n```", "```py\ndef outer_func():\n    x = 20\n    def inner_func():\n        print(x)\n    inner_func()\n\nouter_func() # 20\n```", "```py\nx = 30\n\ndef func():\n    print(x)\n\nfunc() # 30\n```", "```py\ndef func2():\n    global x\n    x = 40\n    print(x)\n\nfunc2() # 40\nprint(x) # 40\n```", "```py\ndef func(x):\n    return x ** 2\n\nfunc(3)\n```", "```py\n9\n```", "```py\nprint(x) # NameError\n```", "```py\ndef counter():\n    count = 0\n    def inner():\n        nonlocal count\n        count += 1\n        return count\n    return inner\n\n# Return the inner function\ncounter = counter()\nprint(counter()) # 1\nprint(counter()) # 2\nprint(counter()) # 3\n```", "```py\n1\n2\n3\n```", "```py\ncounter.__closure__[0].cell_contents\n```", "```py\n3\n```", "```py\ndef stateful_function(func):\n    cache = {}\n    def inner(*args, **kwargs):\n        key = str(args) + str(kwargs)\n        if key not in cache:\n            cache[key] = func(*args, **kwargs)\n        return cache[key]\n    return inner\n```", "```py\n%%time\n\n@stateful_function\ndef fibonacci(n):\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)\n\nfibonacci(1000)\n```", "```py\nCPU times: user 1.53 ms, sys: 88 Âµs, total: 1.62 ms\nWall time: 1.62 ms\n\n[OUT]:\n\n43466557686937456435688527675040625802564660517371780402481729089536555417949051890403879840079255169295922593080322634775209689623239873322471161642996440906533187938298969649928516003704476137795166849228875\n```", "```py\n%%time\n\ndef fibonacci(n):\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)\n\nfibonacci(40)\n```", "```py\nCPU times: user 21 s, sys: 0 ns, total: 21 s\nWall time: 21 s\n\n[OUT]:\n\n102334155\n```", "```py\nwith open(\"logs.txt\", \"r\") as f:\n    contents = f.read()\n\n    print(contents)\n```", "```py\ndef read_large_file(filename):\n    with open(filename) as f:\n        while True:\n            chunk = f.read(1024)\n            if not chunk:\n                break\n            yield chunk # Generators are defined with `yield` instead of `return`\n\nfor chunk in read_large_file(\"logs.txt\"):\n    process(chunk)    # Process the chunk\n```", "```py\ndef fibonacci():\n    a, b = 0, 1\n    while True:\n        yield a\n        a, b = b, a + b\n\nfib = fibonacci()\n\ntype(fib)\n```", "```py\ngenerator\n```", "```py\nprint(next(fib)) # 0\nprint(next(fib)) # 1\nprint(next(fib)) # 1\nprint(next(fib)) # 2\nprint(next(fib)) # 3\n```", "```py\nimport time\n\nclass TimerContextManager:\n    \"\"\"\n    Measure the time it takes to run\n    a block of code.\n    \"\"\"\n    def __enter__(self):\n        self.start = time.time()\n\n    def __exit__(self, type, value, traceback):\n        end = time.time()\n        print(f\"The code took {end - self.start:.2f} seconds to execute.\")\n```", "```py\nwith TimerContextManager():\n    # This code is timed\n    time.sleep(1)\n```", "```py\nThe code took 1.00 seconds to execute.\n```", "```py\nimport threading\n\nlock = threading.Lock()\n\nclass LockContextManager:\n    def __enter__(self):\n        lock.acquire()\n\n    def __exit__(self, type, value, traceback):\n        lock.release()\n\nwith LockContextManager():\n    # This code is executed with the lock acquired\n    # Only one process can be inside this block at a time\n\n# The lock is automatically released when the with block ends, even if an error occurs\n```"]