- en: Unlock the Full Potential of Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://towardsdatascience.com/unlock-the-full-potential-of-python-bc78a980168b](https://towardsdatascience.com/unlock-the-full-potential-of-python-bc78a980168b)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Tips and Tricks for Readable and Efficient Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://tinztwinspro.medium.com/?source=post_page-----bc78a980168b--------------------------------)[![Janik
    and Patrick Tinz](../Images/a08aa54f553f606ef5df86f9411c36ac.png)](https://tinztwinspro.medium.com/?source=post_page-----bc78a980168b--------------------------------)[](https://towardsdatascience.com/?source=post_page-----bc78a980168b--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----bc78a980168b--------------------------------)
    [Janik and Patrick Tinz](https://tinztwinspro.medium.com/?source=post_page-----bc78a980168b--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ¬∑Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----bc78a980168b--------------------------------)
    ¬∑9 min read¬∑May 10, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f2a8e5fcd50cccc27e31966429fead88.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Maxwell Nelson](https://unsplash.com/@maxcodes?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: '**Python** is one of the most popular programming languages among developers
    and Data Scientists. Developers use the language for backend and frontend development.
    Data Scientists and Analysts use Python to analyse data. The main machine-learning
    libraries are available in Python. For this reason, Python is very popular among
    Data Scientists.'
  prefs: []
  type: TYPE_NORMAL
- en: In this article, we show some Python tips and tricks. The tips and tricks will
    help you to make your Python code more efficient and readable. You can use these
    tips directly in your next Python project. We structured the tips in such a way
    that you can read all the tips independently of each other. Read the headline
    and decide which tip or trick interests you! **Let‚Äôs start right now!**
  prefs: []
  type: TYPE_NORMAL
- en: Use enumerate()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Python, you usually write a `for()` loop over an iterable object. So you
    don‚Äôt need a count variable to access elements. However, sometimes it is necessary
    to have a counter variable. There are several ways to implement such a `for()`
    loop. We will show you two variants today. The following example code shows variant
    A.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create a counter variable `i`. We increment this counter
    variable at each iteration. This implementation is error-prone. You have to remember
    to update `i` at each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can avoid this error by using `enumerate()` in the loop. Instead of inserting
    the iterable directly into the `for()` loop, you put the iterable into the brackets
    of `enumerate()`. The following example shows how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `enumerate()` function also gives you the option to set the start value
    of the counter. The function improves your code in terms of maintainability, readability
    and efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Use zip()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python‚Äôs `zip()` function creates an iterator that combines elements from two
    or more iterables. With the resulting iterator, you can solve common programming
    problems. We show you how to use the Python function `zip()` with practical examples.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of the `zip()` function as a physical zip. The analogy will help
    you understand the `zip()` function. The `zip()` function has iterables as arguments
    and returns an iterator. This iterator creates a series of tuples. The tuples
    contain the elements from each iterable. The `zip()` function accepts any type
    of iterable (e.g., files, lists, tuples, dictionaries, etc.). The following code
    block shows how it works with two lists as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `zip()` function returns an iterator. We need to use `list()`
    to call the list object. In the above example, the length of the iterables is
    the same. However, it is also possible that the iterables do not have the same
    length. We will now take a closer look at this case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We see in the code example above that the length of the shortest iterable is
    used. The `zip()` function ignores the remaining elements in longer iterables.
    Since Python 3.10, `zip()` has a new optional argument called strict. The key
    purpose of this argument is to provide a safe way to handle unequal-length iterables.
    Look at the code example below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We get a ValueError because the length does not match. The argument `strict`
    is useful when you need to make sure that the function only accepts iterables
    of equal length.
  prefs: []
  type: TYPE_NORMAL
- en: A loop over multiple iterables is one of the most common use cases for Python‚Äôs
    `zip()` function. The `zip()` function is useful for iterating over sequences
    (e.g. list, dictionary). We show you how to use `zip()` to run multiple iterables
    at the same time. We also compare the classical procedure with the `zip()` method.
    The following code example shows the classic way to iterate through two lists.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we iterate through the two lists `list_a` and `list_b`. In
    the `for()` loop, we must access individual list elements manually. This process
    increases the runtime of the code. Now let‚Äôs look at how we can improve the code
    with the `zip()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we again iterate over the lists `list_a` and `list_b`. Now
    we can access the individual elements of the lists directly in the `for()` loop.
    The advantages are shorter code and improved runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Don‚Äôt be surprised at the `_` in the numbers. The solution is in the last tip.
  prefs: []
  type: TYPE_NORMAL
- en: Unpacking and Packing function arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We look at an add function that receives two arguments. In the following, you
    see the classic implementation as you know it from other programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we add 5 and 2\. The result is 7\. In Python we can also pass
    a list of arguments to the function. This is really cool!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use * to unpack the list so that all elements of it can
    be passed. In addition, we use ** to unpack the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: We can also pass any number of arguments. That is called packing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `add_function()` above packs all the arguments into a single variable. With
    the packed variable we can do everything as with a normal tuple. args[0] and args[1]
    give you the first and second argument.
  prefs: []
  type: TYPE_NORMAL
- en: Unpacking and Packing make your code less error-prone and cleaner. It is so
    simple that you can use it directly in your next project.
  prefs: []
  type: TYPE_NORMAL
- en: Inplace value exchange
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many developers use a temporary variable for caching. There is an **easier and
    faster way** without creating an additional variable. Take a look at the following
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You see it isvery simple. However, this approach is not limited to variables.
    You can also apply it to lists. The following code shows an example with the first
    Fibonacci numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we rearrange the order of the elements of the list. Often it‚Äôs
    the simple things that make your code cleaner. Remember this tip for your next
    Python project.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid exception with Dictionary Get() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a Python developer, you have seen the KeyError exception many times. The
    goal is to prevent unexpected KeyError exceptions from occurring. The following
    code shows the exception with a small example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: A solution to stop this error is to use `.get()` function. Let‚Äôs use `.get()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, we don‚Äôt get a KeyError exception because we use the safer `.get()` method.
    If the key is not found, the return value is None (default). You can also specify
    the default value yourself by passing a second argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we change the default return value to 0\. The `.get()` function
    makes your code safer.
  prefs: []
  type: TYPE_NORMAL
- en: Use context managers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python context managers are a powerful feature of the language for managing
    resources, network and database connections. Resources such as files, network
    or database connections are automatically set up and taken down when needed or
    not needed. Context managers are useful in projects where resources are scarce
    or when dealing with multiple connections. In addition, context managers can help
    with error handling. In Python, the `with` statement implements a context manager.
    Let‚Äôs look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: First, we look at the syntax. After the `with` statement stands the context
    manager expression. This expression is responsible for the setup of the context
    manager object. Examples of a context manager expression are connections to databases
    or opening a file (as in our example). After the `as` is an optional variable
    that receives the result of the `__enter__()` method of the context manager. In
    our example, this is the JSON file. Then we come to the body. In the body, we
    execute the code within the context. In our example, we load the JSON file and
    save the content in a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the code in the body has been executed, the `with` statement calls the
    `__exit__()` method of the context manager. The `__exit__()` method performs the
    cleanup (for example: closing the file or freeing resources). In practice, the
    `with` statement is essential, especially when working with database connections.
    The use of context managers ensures that database connections are closed automatically.
    **Efficient resource management becomes possible.**'
  prefs: []
  type: TYPE_NORMAL
- en: When using context manager, a lot of manual work is taken away from the developer
    by doing a lot automatically. That leads to the fact that not all steps are visible
    in the code. So it is hard to understand the code when you look at it for the
    first time.
  prefs: []
  type: TYPE_NORMAL
- en: Context managers should be used for memory optimisation and clean resource management,
    because they take a lot of work off your hands.
  prefs: []
  type: TYPE_NORMAL
- en: Working with large numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you ever worked with large numbers in Python? Which number is more readable
    1000000 or 1,000,000? The second one, right? Unfortunately, the second notation
    does not work in Python. In Python, however, you can use a `_` instead of a `,`.
    Let‚Äôs look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Both methods give the same result. The only difference is the representation
    of large numbers. The second method is easier to read and avoids errors.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this article, we have learned how to write cleaner and safer code. The key
    findings are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use the enumerate() function in a loop: You get a count of the current iteration
    and the value of the item at the current iteration.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use zip() in a loop to iterate over multiple iterables.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use Unpacking and Packing for less error-prone and cleaner code.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoid temporary variables with in-place value exchange.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoid the KeyError exception with the dictionary .get() method.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use context managers for your resource management.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use _ for large numbers to make your code readable.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: üëâüèΩ [**Join our free weekly Magic AI newsletter for the latest AI updates!**](https://magicai.tinztwins.de)
  prefs: []
  type: TYPE_NORMAL
- en: üëâüèΩ [**You can find all our Freebies on our digital products page!**](https://shop.tinztwins.de/)
  prefs: []
  type: TYPE_NORMAL
- en: '[**Subscribe for free**](https://tinztwinspro.medium.com/subscribe) **to get
    notified when we publish a new story:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://tinztwinspro.medium.com/subscribe?source=post_page-----bc78a980168b--------------------------------)
    [## Get an email whenever Janik and Patrick Tinz publishes.'
  prefs: []
  type: TYPE_NORMAL
- en: Get an email whenever Janik and Patrick Tinz publishes. By signing up, you will
    create a Medium account if you don‚Äôt‚Ä¶
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: tinztwinspro.medium.com](https://tinztwinspro.medium.com/subscribe?source=post_page-----bc78a980168b--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Learn more about us on our [About page](https://medium.com/@tinztwinspro/about).
    Don‚Äôt forget to follow us on [X](https://twitter.com/tinztwins). Thanks so much
    for reading. If you liked this article, feel free to share it. **Have a great
    day!**
  prefs: []
  type: TYPE_NORMAL
- en: Sign up for a Medium membership using [our link](https://tinztwinspro.medium.com/membership)
    to read unlimited Medium stories.
  prefs: []
  type: TYPE_NORMAL
