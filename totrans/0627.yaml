- en: 'Data Aggregation in Python with Pandas: Analysing Geological Lithology Data'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/data-aggregation-in-python-with-pandas-analysing-geological-lithology-data-94192f5631c0](https://towardsdatascience.com/data-aggregation-in-python-with-pandas-analysing-geological-lithology-data-94192f5631c0)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exploring lithology variations within the Zechstein Group of the Norwegian Continental
    Shelf
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://andymcdonaldgeo.medium.com/?source=post_page-----94192f5631c0--------------------------------)[![Andy
    McDonald](../Images/df11d647be032aeb3d31852affb33a64.png)](https://andymcdonaldgeo.medium.com/?source=post_page-----94192f5631c0--------------------------------)[](https://towardsdatascience.com/?source=post_page-----94192f5631c0--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----94192f5631c0--------------------------------)
    [Andy McDonald](https://andymcdonaldgeo.medium.com/?source=post_page-----94192f5631c0--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----94192f5631c0--------------------------------)
    ·6 min read·Jun 29, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d088a32dac22c1b514824f1a9acdc8f6.png)'
  prefs: []
  type: TYPE_IMG
- en: Image generated by the author using Midjourney (Paid subscription plan).
  prefs: []
  type: TYPE_NORMAL
- en: Using data aggregation techniques can help us transform an overwhelming and
    almost incomprehensible numeric dataset into something that is easily digestible
    and much more reader-friendly. The process of data aggregation involves summarising
    multiple data points into single metrics that can be used to provide a high-level
    overview of the data.
  prefs: []
  type: TYPE_NORMAL
- en: One way we can apply this process within petrophysics and geoscience is to summarise
    the lithological composition of geological formations that have been interpreted
    from well log measurements.
  prefs: []
  type: TYPE_NORMAL
- en: Within this short tutorial, we will see how we can take a large dataset consisting
    of 90 plus wells from the Norwegian Continental Shelf, and extract the lithology
    composition of the Zechstein Group.
  prefs: []
  type: TYPE_NORMAL
- en: Importing Libraries and Loading Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin, we first need to import the [**pandas**](https://pandas.pydata.org)
    library, which will be used to load our datafile from CSV and carry out the aggregations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once the pandas library has been imported, we can then read the CSV file using
    `pd.read_csv()`.
  prefs: []
  type: TYPE_NORMAL
- en: The data we are going to be using is from the combined [**XEEK and Force 2020
    Machine Learning competition**](https://xeek.ai/challenges/force-well-logs) which
    aimed to predict lithology from well log measurements. The dataset we are using
    represents all of the available training data. Further details of this dataset
    can be found at the end of the article.
  prefs: []
  type: TYPE_NORMAL
- en: As this CSV file contains data that is separated by a semi-colon rather than
    by a comma, we need to pass in a colon to the `sep` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We can then run this code to begin the loading process. As we have a large dataset
    (11 million + rows), this may take several seconds. But, once it has finished
    loading, we can view our dataframe by calling upon the `df` object. This will
    return our dataframe and show the first five and last five rows from it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/319373d0bba633c6b6147e410779575f.png)'
  prefs: []
  type: TYPE_IMG
- en: Dataframe containing well log data from the Norwegian Continental Shelf. Image
    by the author.
  prefs: []
  type: TYPE_NORMAL
- en: Using pandas .map() to Convert Numeric Codes to Lithology Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within this dataset, the lithology data is stored within the `FORCE_2020_LITHOFACIES_LITHOLOGY`
    column. However, when we look closely at our data, we will see that the lithology
    values are encoded numerically. Unless you know the key, it will be hard to decipher
    what number represents what lithology.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily for this dataset, we have the key and can create a dictionary with the
    key and lithology pairs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To apply this to our dataset, we can use the pandas `map()` function, which
    will perform a lookup using our dictionary and then assign the correct lithology
    label to the numeric value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Once this has run, we can view the dataframe again to make sure the mapping
    has been successful and a new LITH column has been added to the end of the dataframe.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e68e6e4d1bbeb11a678e6589f21bd8d1.png)'
  prefs: []
  type: TYPE_IMG
- en: Dataframe containing well log data from the Norwegian Continental Shelf. Image
    by the author.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering the Dataframe for a Specific Geological Group
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have a rather large dataset with 11,705,511 rows, it would be good to
    focus on a particular geological group for our lithology compositional analysis.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we will subset the data and look at the Zechstein Group.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this by using the `query()` method and passing in a simple string:
    `GROUP == "ZECHSTEIN GP."`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We can check how many wells we have in the subset by calling upon `df_zechstein.WELL.unique()`,
    which returns the following array containing 8 wells.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As we are only interested in the lithologies, we can simply extract the Well
    name and the lithology columns. This will also make it easier to carry out the
    aggregation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/d36052cce552ce69e671c133ab538299.png)'
  prefs: []
  type: TYPE_IMG
- en: Well names and associated lithologies. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregating the Data Using Chained Pandas Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the data in a format that can be worked with we can begin the
    aggregation process. For this, we are going to chain multiple pandas methods together
    in a single.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will group the data by the WELL column using the `groupby` function.
    This essentially makes subsets of the dataframe for each unique well name within
    the WELL column
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will count the occurrences of each lithology type within each group.
    The `normalize=True` part means it will give a proportion (between 0 and 1) rather
    than absolute counts. For example, if in one well (group), 'Sandstone' occurs
    5 times and 'Shale' occurs 15 times, the function will return 0.25 for 'Sandstone'
    and 0.75 for 'Shale' instead of 5 and 15.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to rearrange our resulting dataframe so that the row index
    contains the well names and the columns contain the lithology names. If a well
    did not have any instances of a certain lithology then they are filled with zero,
    due to `fill_value=0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: What we get back is the following dataframe with the decimal proportions of
    each lithology within each of the wells.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/de1a20c35a3742ebddf37251361fe791.png)'
  prefs: []
  type: TYPE_IMG
- en: Lithology composition of the Zechstein Group in decimal form. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to view these as percentages, we can change how they are displayed
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When we run the code, we get back the following dataframe which provides a more
    readable table and can be incorporated into a report.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ee515a22ee1d934f6d526053afe2da57.png)'
  prefs: []
  type: TYPE_IMG
- en: Lithology composition of the Zechstein Group after aggregation and changing
    the numbers to display as percentages. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: Applying this styling does not change the actual values. They will still be
    stored as their decimal equivalents.
  prefs: []
  type: TYPE_NORMAL
- en: If we do want to change the values permanently to percentages, we can do so
    by multiplying the dataframe by 100.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/c2e3454b59949c293d66f9ccef16bf52.png)'
  prefs: []
  type: TYPE_IMG
- en: Lithology composition of the Zechstein Group after aggregation and converting
    to percentages. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: Once the data is in this format, we can use it to create something similar to
    the infographic below, which shows the percentages for the lithologies for each
    of the wells.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9c6c88b42a6a79564abfc124d56ec981.png)'
  prefs: []
  type: TYPE_IMG
- en: An infographic showing the percentage variation for each lithology within each
    well. Created with matplotlib by the author.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within this short tutorial, we have seen how we can take a large collection
    of well log data (from 90 plus wells) and extract and summarise a particular geological
    group. This allows us to understand the lithological composition of the geological
    group in an easy-to-read and understandable format that can be incorporated into
    a report or presentation.
  prefs: []
  type: TYPE_NORMAL
- en: Dataset Used in this Tutorial
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Training dataset used as part of a Machine Learning competition run by Xeek
    and FORCE 2020 *(Bormann et al., 2020)*. This dataset is licensed under Creative
    Commons Attribution 4.0 International.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full dataset can be accessed at the following link: [https://doi.org/10.5281/zenodo.4351155](https://doi.org/10.5281/zenodo.4351155).'
  prefs: []
  type: TYPE_NORMAL
- en: '*Thanks for reading. Before you go, you should definitely subscribe to my content
    and get my articles in your inbox.* [***You can do that here!***](https://andymcdonaldgeo.medium.com/subscribe)'
  prefs: []
  type: TYPE_NORMAL
- en: '*Secondly, you can get the full Medium experience and support thousands of
    other writers and me by signing up for a membership. It only costs you $5 a month,
    and you have full access to all of the fantastic Medium articles, as well as the
    chance to make money with your writing.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you sign up using* [***my link***](https://andymcdonaldgeo.medium.com/membership)***,***
    *you will support me directly with a portion of your fee, and it won’t cost you
    more. If you do so, thank you so much for your support.*'
  prefs: []
  type: TYPE_NORMAL
