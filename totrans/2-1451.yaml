- en: Lucene Inside Out â€” Dealing With Integer Encoding and Compression
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: åŸæ–‡ï¼š[https://towardsdatascience.com/lucene-inside-out-dealing-with-integer-encoding-and-compression-fe28f9dd265d](https://towardsdatascience.com/lucene-inside-out-dealing-with-integer-encoding-and-compression-fe28f9dd265d)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Delve into PackedInts, VInt, FixedBitSet, and **RoaringDocIdSet (**Roaring Bitmaps)
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://peggy1502.medium.com/?source=post_page-----fe28f9dd265d--------------------------------)[![Peggy
    Chang](../Images/f59e8d3b97ea7db59fc8cb33f05e835b.png)](https://peggy1502.medium.com/?source=post_page-----fe28f9dd265d--------------------------------)[](https://towardsdatascience.com/?source=post_page-----fe28f9dd265d--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----fe28f9dd265d--------------------------------)
    [Peggy Chang](https://peggy1502.medium.com/?source=post_page-----fe28f9dd265d--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Â·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----fe28f9dd265d--------------------------------)
    Â·13 min readÂ·Jun 28, 2023
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3e285f99edf68c33f97c132920235b8a.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
- en: Image by [Gerd Altmann](https://pixabay.com/users/geralt-9301/?utm_source=link-attribution&amp%3Butm_medium=referral&amp%3Butm_campaign=image&amp%3Butm_content=1536589)
    from [Pixabay](https://pixabay.com//?utm_source=link-attribution&amp%3Butm_medium=referral&amp%3Butm_campaign=image&amp%3Butm_content=1536589)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Earlier on, we learned about vector compression using [product quantization](https://medium.com/towards-data-science/product-quantization-for-similarity-search-2f1f67c5fddd)
    for similarity search.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[](/product-quantization-for-similarity-search-2f1f67c5fddd?source=post_page-----fe28f9dd265d--------------------------------)
    [## Product Quantization for Similarity Search'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: How to compress and fit a humongous set of vectors in memory for similarity
    search with asymmetric distance computationâ€¦
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/product-quantization-for-similarity-search-2f1f67c5fddd?source=post_page-----fe28f9dd265d--------------------------------)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: In this article, we will explore and gain insight into how integers are encoded
    and compressed in Lucene, the world where the inverted index takes center stage.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Lucene â€” Brief Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Lucene](https://lucene.apache.org/) is an open-source search engine library
    written in Java. Created by Doug Cutting in 1999, it is well-known for full-text
    search and indexing.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: This open-source software project under [The Apache Software Foundation](https://www.apache.org/)
    is still in active development after more than two decades. Over the years, it
    has evolved and grown to become a powerful, fully featured high-performance search
    engine library.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Undeniably, Lucene's success is highly attributed to its strong community and
    the incredible work contributed by committers. Their participation and collaboration
    brought Lucene to where it is today. Many popular enterprise search platforms
    and solutions such as [Solr](https://solr.apache.org/) and [Elasticsearch](https://www.elastic.co/elasticsearch/)
    are built on top of Lucene.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: æ¯«æ— ç–‘é—®ï¼ŒLucene çš„æˆåŠŸåœ¨å¾ˆå¤§ç¨‹åº¦ä¸Šå½’åŠŸäºå…¶å¼ºå¤§çš„ç¤¾åŒºä»¥åŠè´¡çŒ®è€…ä»¬çš„å“è¶Šå·¥ä½œã€‚ä»–ä»¬çš„å‚ä¸å’Œåˆä½œä½¿å¾— Lucene è¾¾åˆ°äº†ä»Šå¤©çš„æ°´å¹³ã€‚è®¸å¤šæµè¡Œçš„ä¼ä¸šæœç´¢å¹³å°å’Œè§£å†³æ–¹æ¡ˆï¼Œå¦‚
    [Solr](https://solr.apache.org/) å’Œ [Elasticsearch](https://www.elastic.co/elasticsearch/)ï¼Œéƒ½æ˜¯å»ºç«‹åœ¨
    Lucene ä¹‹ä¸Šçš„ã€‚
- en: â€œFor an open source project, 20 years is a long time. Without a doubt, Luceneâ€™s
    longevity is a testament to the strength and diversity of its communityâ€ â€” [Celebrating
    20 years of Apache Lucene](https://www.elastic.co/celebrating-lucene)
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: â€œå¯¹äºä¸€ä¸ªå¼€æºé¡¹ç›®æ¥è¯´ï¼Œ20 å¹´æ˜¯å¾ˆé•¿çš„æ—¶é—´ã€‚æ¯«æ— ç–‘é—®ï¼ŒLucene çš„é•¿æœŸå­˜åœ¨è¯æ˜äº†å…¶ç¤¾åŒºçš„åŠ›é‡å’Œå¤šæ ·æ€§â€ â€” [åº†ç¥ Apache Lucene 20
    å¹´](https://www.elastic.co/celebrating-lucene)
- en: Inverted Index
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: åå‘ç´¢å¼•
- en: The inverted index lies in the heart of Lucene. The inverted index comprises
    two parts â€” on the left, we have the terms dictionary, and on the right, we have
    the postings for each term.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: åå‘ç´¢å¼•æ˜¯ Lucene çš„æ ¸å¿ƒã€‚åå‘ç´¢å¼•åŒ…æ‹¬ä¸¤éƒ¨åˆ† â€”â€” å·¦è¾¹æ˜¯æœ¯è¯­å­—å…¸ï¼Œå³è¾¹æ˜¯æ¯ä¸ªæœ¯è¯­çš„ postingsã€‚
- en: '![](../Images/544e0b0228ea263bff10e7b80847f9f0.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/544e0b0228ea263bff10e7b80847f9f0.png)'
- en: 'Figure 1: Terms dictionary and postings lists form the inverted index in Lucene.
    All images are by the author unless otherwise specified.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 'å›¾ 1: æœ¯è¯­å­—å…¸å’Œ postings åˆ—è¡¨å½¢æˆ Lucene ä¸­çš„åå‘ç´¢å¼•ã€‚æ‰€æœ‰å›¾ç‰‡å‡ç”±ä½œè€…æä¾›ï¼Œé™¤éå¦æœ‰è¯´æ˜ã€‚'
- en: Postings are information about the occurrence of a term in a document. The postings
    list contains Doc IDs of documents in which the term occurs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Postings æ˜¯å…³äºæœ¯è¯­åœ¨æ–‡æ¡£ä¸­å‡ºç°çš„ä¿¡æ¯ã€‚Postings åˆ—è¡¨åŒ…å«æœ¯è¯­å‡ºç°çš„æ–‡æ¡£çš„ Doc IDã€‚
- en: If defined, it may also include information such as the frequency of the term
    within the document, and perhaps the positions, character offsets, and payloads.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœå®šä¹‰äº†ï¼Œå®ƒä¹Ÿå¯èƒ½åŒ…æ‹¬è¯¸å¦‚æœ¯è¯­åœ¨æ–‡æ¡£ä¸­çš„é¢‘ç‡ï¼Œç”šè‡³ä½ç½®ã€å­—ç¬¦åç§»é‡å’Œæœ‰æ•ˆè´Ÿè½½ç­‰ä¿¡æ¯ã€‚
- en: 'Yes, all these are integers, and there are indeed a huge amount of integers
    to handle in Lucene. As quoted by Adrien Grand [1], a Lucene committer at The
    Apache Software Foundation:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: æ˜¯çš„ï¼Œè¿™äº›éƒ½æ˜¯æ•´æ•°ï¼Œç¡®å®æœ‰å¤§é‡çš„æ•´æ•°éœ€è¦åœ¨ Lucene ä¸­å¤„ç†ã€‚æ­£å¦‚ Apache è½¯ä»¶åŸºé‡‘ä¼šçš„ Lucene è´¡çŒ®è€… Adrien Grand [1]
    æ‰€å¼•è¿°çš„ï¼š
- en: â€œOne of the most important building blocks of a search engine is the ability
    to efficiently compress and quickly decode sorted lists of integersâ€
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: â€œæœç´¢å¼•æ“æœ€é‡è¦çš„æ„å»ºå—ä¹‹ä¸€æ˜¯èƒ½å¤Ÿé«˜æ•ˆåœ°å‹ç¼©å’Œå¿«é€Ÿè§£ç æ’åºçš„æ•´æ•°åˆ—è¡¨â€
- en: In the following sections, we will look into techniques used by Lucene to encode
    and compress integers, particularly integers from the postings list â€” Doc IDs
    and term frequencies.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ¥ä¸‹æ¥çš„éƒ¨åˆ†ä¸­ï¼Œæˆ‘ä»¬å°†æ·±å…¥æ¢è®¨ Lucene ç”¨äºç¼–ç å’Œå‹ç¼©æ•´æ•°çš„æŠ€æœ¯ï¼Œç‰¹åˆ«æ˜¯æ¥è‡ª postings åˆ—è¡¨çš„æ•´æ•° â€”â€” Doc ID å’Œæœ¯è¯­é¢‘ç‡ã€‚
- en: Delta Encoding
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Delta ç¼–ç 
- en: Letâ€™s start by looking at how Lucene encodes and stores postings data on disk.
    The list of documents that contain each term is saved in the .doc file. Skip data
    is also saved in the same file, but it will not be discussed in this article.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬é¦–å…ˆçœ‹çœ‹ Lucene å¦‚ä½•åœ¨ç£ç›˜ä¸Šç¼–ç å’Œå­˜å‚¨ postings æ•°æ®ã€‚åŒ…å«æ¯ä¸ªæœ¯è¯­çš„æ–‡æ¡£åˆ—è¡¨ä¿å­˜åœ¨ .doc æ–‡ä»¶ä¸­ã€‚è·³è¿‡æ•°æ®ä¹Ÿä¿å­˜åœ¨åŒä¸€ä¸ªæ–‡ä»¶ä¸­ï¼Œä½†åœ¨æœ¬æ–‡ä¸­ä¸ä½œè®¨è®ºã€‚
- en: First and foremost, as seen in *Figure 1*, the Doc IDs that each term is pointing
    to are basically a sorted list of integers. For each term, we begin by transforming
    the list of sorted Doc IDs into Doc Deltas.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œæ­£å¦‚ *å›¾ 1* æ‰€ç¤ºï¼Œæ¯ä¸ªæœ¯è¯­æ‰€æŒ‡å‘çš„ Doc ID åŸºæœ¬ä¸Šæ˜¯ä¸€ä¸ªæ’åºå¥½çš„æ•´æ•°åˆ—è¡¨ã€‚å¯¹äºæ¯ä¸ªæœ¯è¯­ï¼Œæˆ‘ä»¬é¦–å…ˆå°†æ’åºå¥½çš„ Doc ID åˆ—è¡¨è½¬æ¢ä¸º
    Doc Deltasã€‚
- en: Through [**delta encoding**](https://en.wikipedia.org/wiki/Delta_encoding),
    Doc Deltas are obtained by getting the difference between each Doc ID and the
    previous one, except for the first Doc ID.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡ [**delta ç¼–ç **](https://en.wikipedia.org/wiki/Delta_encoding)ï¼ŒDoc Deltas æ˜¯é€šè¿‡è®¡ç®—æ¯ä¸ª
    Doc ID å’Œå‰ä¸€ä¸ª Doc ID ä¹‹é—´çš„å·®å¼‚å¾—åˆ°çš„ï¼Œé™¤äº†ç¬¬ä¸€ä¸ª Doc IDã€‚
- en: Next, Doc Deltas are split into fixed blocks of 128 integers. These are referred
    to as *PackedDocDeltaBlock.* Each of these blocks is then encoded with **PackedInts**,
    a Lucene implementation of bit packing. The remaining Doc Deltas are encoded with
    **VInt**.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: æ¥ä¸‹æ¥ï¼Œå°† Doc Deltas åˆ‡åˆ†ä¸ºå›ºå®šçš„ 128 ä¸ªæ•´æ•°å—ã€‚è¿™äº›å—è¢«ç§°ä¸º *PackedDocDeltaBlock*ã€‚æ¯ä¸ªå—éšåä½¿ç”¨ **PackedInts**
    è¿›è¡Œç¼–ç ï¼Œè¿™æ˜¯ä¸€ç§ Lucene å®ç°çš„ä½æ‰“åŒ…æ–¹å¼ã€‚å‰©ä½™çš„ Doc Deltas åˆ™ç”¨ **VInt** ç¼–ç ã€‚
- en: The following diagram is a simplified illustration where the block size of a
    PackedDocDeltaBlock is 4 instead of the actual 128.
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹å›¾æ˜¯ä¸€ä¸ªç®€åŒ–çš„ç¤ºæ„å›¾ï¼Œå…¶ä¸­ PackedDocDeltaBlock çš„å—å¤§å°ä¸º 4ï¼Œè€Œä¸æ˜¯å®é™…çš„ 128ã€‚
- en: '![](../Images/8855a0d77d2bd48b3bc61b331bfec123.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8855a0d77d2bd48b3bc61b331bfec123.png)'
- en: 'Figure 2: The encoding process for Doc IDs'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 'å›¾ 2: Doc ID çš„ç¼–ç è¿‡ç¨‹'
- en: Have you noticed that most of the integers have become smaller after going through
    delta-encoding?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ æ˜¯å¦æ³¨æ„åˆ°ï¼Œå¤§å¤šæ•°æ•´æ•°åœ¨ç»è¿‡ delta ç¼–ç åå˜å¾—æ›´å°äº†ï¼Ÿ
- en: Smaller integers require fewer bits to represent them, and this is crucial for
    the next step of encoding with **PackedInts** and **VInt**.
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¾ƒå°çš„æ•´æ•°éœ€è¦æ›´å°‘çš„ä½æ¥è¡¨ç¤ºï¼Œè¿™å¯¹äºä½¿ç”¨ **PackedInts** å’Œ **VInt** è¿›è¡Œç¼–ç çš„ä¸‹ä¸€æ­¥è‡³å…³é‡è¦ã€‚
- en: PackedInts
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PackedInts
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In general, bit packing combines multiple values at the bit level into one or
    more bytes (or one or more long integers*)*. For example, four 2-bit values can
    be packed into one byte, and eight 16-bit values can be packed into two long integers.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: é€šå¸¸ï¼Œä½æ‰“åŒ…å°†å¤šä¸ªå€¼åœ¨ä½çº§åˆ«ç»„åˆæˆä¸€ä¸ªæˆ–å¤šä¸ªå­—èŠ‚ï¼ˆæˆ–ä¸€ä¸ªæˆ–å¤šä¸ªé•¿æ•´å‹*ï¼‰ã€‚ä¾‹å¦‚ï¼Œå››ä¸ª 2 ä½çš„å€¼å¯ä»¥æ‰“åŒ…æˆä¸€ä¸ªå­—èŠ‚ï¼Œå…«ä¸ª 16 ä½çš„å€¼å¯ä»¥æ‰“åŒ…æˆä¸¤ä¸ªé•¿æ•´å‹ã€‚
- en: With bit packing, the amount of space required to store integers can be reduced
    significantly.
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: é€šè¿‡ä½æ‰“åŒ…ï¼Œå­˜å‚¨æ•´æ•°æ‰€éœ€çš„ç©ºé—´å¯ä»¥æ˜¾è‘—å‡å°‘ã€‚
- en: This is possible because a typical 32-bit `*int*` (the most commonly used integer
    type) almost always contains leading zeros at the bit level, and bit packing discards
    them.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯å¯èƒ½çš„ï¼Œå› ä¸ºå…¸å‹çš„ 32 ä½ `*int*`ï¼ˆæœ€å¸¸ç”¨çš„æ•´æ•°ç±»å‹ï¼‰å‡ ä¹æ€»æ˜¯åŒ…å«ä½çº§åˆ«çš„å‰å¯¼é›¶ï¼Œä½æ‰“åŒ…ä¼šä¸¢å¼ƒè¿™äº›é›¶ã€‚
- en: '![](../Images/c2777515ba2d86ea51b905136824143d.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c2777515ba2d86ea51b905136824143d.png)'
- en: 'Figure 3: An example of packing 4 integers into 1 byte, with each value occupying
    2 bits. Storage space is reduced from 16 bytes to 1 byte.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 'å›¾ 3: å°† 4 ä¸ªæ•´æ•°æ‰“åŒ…åˆ° 1 ä¸ªå­—èŠ‚ä¸­çš„ç¤ºä¾‹ï¼Œæ¯ä¸ªå€¼å ç”¨ 2 ä½ã€‚å­˜å‚¨ç©ºé—´ä» 16 å­—èŠ‚å‡å°‘åˆ° 1 å­—èŠ‚ã€‚'
- en: In [**PackedInts**](https://lucene.apache.org/core/9_6_0/core/org/apache/lucene/util/packed/PackedInts.html),
    data is stored in a way that each value consumes a fixed number of bits between
    1 and 64, called `bitsPerValue`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ [**PackedInts**](https://lucene.apache.org/core/9_6_0/core/org/apache/lucene/util/packed/PackedInts.html)
    ä¸­ï¼Œæ•°æ®ä»¥æ¯ä¸ªå€¼æ¶ˆè€—å›ºå®šæ•°é‡ä½æ•°çš„æ–¹å¼å­˜å‚¨ï¼Œè¿™ä¸ªä½æ•°åœ¨ 1 åˆ° 64 ä¹‹é—´ï¼Œè¢«ç§°ä¸º`bitsPerValue`ã€‚
- en: Following on from the encoding process for Doc IDs, if a data field is defined
    to include term frequencies (i.e. the fieldâ€™s index option is set to `IndexOptions.DOCS_AND_FREQS`),
    then every *PackedDocDeltaBlock* is immediately accompanied by a *PackedFreqBlock*.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Doc IDs çš„ç¼–ç è¿‡ç¨‹ä¹‹åï¼Œå¦‚æœä¸€ä¸ªæ•°æ®å­—æ®µå®šä¹‰ä¸ºåŒ…å«æœ¯è¯­é¢‘ç‡ï¼ˆå³è¯¥å­—æ®µçš„ç´¢å¼•é€‰é¡¹è®¾ç½®ä¸º `IndexOptions.DOCS_AND_FREQS`ï¼‰ï¼Œé‚£ä¹ˆæ¯ä¸ª
    *PackedDocDeltaBlock* éƒ½ä¼šç´§éšå…¶åä¸€ä¸ª *PackedFreqBlock*ã€‚
- en: '![](../Images/8272872c17748dea0e2e4bb4bdfd5b98.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8272872c17748dea0e2e4bb4bdfd5b98.png)'
- en: 'Figure 4: *PackedDocDeltaBlock* and *PackedFreqBlock*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 'å›¾ 4: *PackedDocDeltaBlock* å’Œ *PackedFreqBlock*'
- en: As the name suggests, *PackedFreqBlock* contains the corresponding frequency
    of terms occurring in documents in the preceding *PackedDocDeltaBlock*. Unlike
    Doc IDs, term frequencies do not go through delta encoding.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚å…¶åï¼Œ*PackedFreqBlock* åŒ…å«åœ¨å‰ä¸€ä¸ª *PackedDocDeltaBlock* ä¸­å‡ºç°çš„æœ¯è¯­çš„å¯¹åº”é¢‘ç‡ã€‚ä¸æ–‡æ¡£ ID ä¸åŒï¼Œæœ¯è¯­é¢‘ç‡æ²¡æœ‰ç»è¿‡
    delta ç¼–ç ã€‚
- en: Each *PackedDocDeltaBlock* and *PackedFreqBlock* is independently encoded with
    **PackedInts**. `bitsPerValue` is derived from the number of bits required to
    represent the largest integer in the block. Despite that, the number of bits per
    value consumed could end up more than expected. Why and how does this happen?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: æ¯ä¸ª *PackedDocDeltaBlock* å’Œ *PackedFreqBlock* éƒ½ä½¿ç”¨ **PackedInts** ç‹¬ç«‹ç¼–ç ã€‚`bitsPerValue`
    æ˜¯æ ¹æ®å—ä¸­è¡¨ç¤ºæœ€å¤§æ•´æ•°æ‰€éœ€çš„ä½æ•°å¾—å‡ºçš„ã€‚å°½ç®¡å¦‚æ­¤ï¼Œæ¯ä¸ªå€¼æ‰€æ¶ˆè€—çš„ä½æ•°å¯èƒ½ä¼šæ¯”é¢„æœŸçš„æ›´å¤šã€‚è¿™æ˜¯ä¸ºä»€ä¹ˆï¼Œå¦‚ä½•å‘ç”Ÿçš„ï¼Ÿ
- en: Well, it turns out that Lucene may adjust the `bitsPerValue` to obtain compression
    with the best read-write performance based on a parameter called `acceptableOverheadRatio`.
    This is the amount of overhead that one is willing to take to trade memory efficiency
    for fast random reads.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: å®é™…ä¸Šï¼ŒLucene å¯èƒ½ä¼šè°ƒæ•´ `bitsPerValue` ä»¥åŸºäºä¸€ä¸ªç§°ä¸º `acceptableOverheadRatio` çš„å‚æ•°æ¥è·å¾—æœ€ä½³çš„è¯»å†™æ€§èƒ½ã€‚è¿™ä¸ªå‚æ•°æ˜¯ä¸ºäº†åœ¨å†…å­˜æ•ˆç‡ä¸å¿«é€Ÿéšæœºè¯»å–ä¹‹é—´è¿›è¡Œæƒè¡¡æ‰€æ„¿æ„æ¥å—çš„å¼€é”€ã€‚
- en: '![](../Images/e7b1bc788312f1df2a0cf0b24ce52565.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e7b1bc788312f1df2a0cf0b24ce52565.png)'
- en: 'Figure 5: The compression modes in **PackedInts**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 'å›¾ 5: **PackedInts** ä¸­çš„å‹ç¼©æ¨¡å¼'
- en: In Lucene, the [adjustments](https://docs.google.com/spreadsheets/d/1QobWCwUWU51Zv9fe5VQZ-hcrC-Q49xmS/edit?usp=sharing&ouid=106781124935005693725&rtpof=true&sd=true)
    for `bitsPerValue` are done in a way that the resulting overhead will not exceed
    the `acceptableOverheadRatio` when `bitsPerValue` is increased to 8, 16, 32, or
    64\. But why 8, 16, 32, 64, and not other numbers?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Lucene ä¸­ï¼Œ`bitsPerValue` çš„ [è°ƒæ•´](https://docs.google.com/spreadsheets/d/1QobWCwUWU51Zv9fe5VQZ-hcrC-Q49xmS/edit?usp=sharing&ouid=106781124935005693725&rtpof=true&sd=true)
    æ˜¯ä»¥è¿™æ ·ä¸€ç§æ–¹å¼è¿›è¡Œçš„ï¼šå½“ `bitsPerValue` å¢åŠ åˆ° 8ã€16ã€32 æˆ– 64 æ—¶ï¼Œç»“æœå¼€é”€ä¸ä¼šè¶…è¿‡ `acceptableOverheadRatio`ã€‚ä½†ä¸ºä»€ä¹ˆæ˜¯
    8ã€16ã€32ã€64ï¼Œè€Œä¸æ˜¯å…¶ä»–æ•°å­—ï¼Ÿ
- en: Most of the time, the best read-write performance is realized when the number
    of bits representing a value is byte-aligned or in multiples of eight (i.e. 8,
    16, 32, 64). Reading and writing are simplified since there is no co-occupancy
    of values within a byte.
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œå½“è¡¨ç¤ºä¸€ä¸ªå€¼çš„ä½æ•°æ˜¯å­—èŠ‚å¯¹é½æˆ–æ˜¯ 8 çš„å€æ•°ï¼ˆå³ 8ã€16ã€32ã€64ï¼‰æ—¶ï¼Œè¯»å†™æ€§èƒ½æœ€ä½³ã€‚å› ä¸ºæ²¡æœ‰å€¼åœ¨ä¸€ä¸ªå­—èŠ‚å†…å…±åŒå­˜åœ¨ï¼Œè¯»å†™æ“ä½œå¾—ä»¥ç®€åŒ–ã€‚
- en: ''
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In other words, the space of one byte, two bytes, four bytes, or eight bytes
    is dedicated entirely to only one value.
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ¢å¥è¯è¯´ï¼Œ1 å­—èŠ‚ã€2 å­—èŠ‚ã€4 å­—èŠ‚æˆ– 8 å­—èŠ‚çš„ç©ºé—´å®Œå…¨ç”¨äºè¡¨ç¤ºä¸€ä¸ªå€¼ã€‚
- en: In the worst case pertaining to memory efficiency, `bitsPerValue` of 1 is adjusted
    to 8\. For every legitimate bit that is present, 7 other unused bits are consumed.
    This produced a memory overhead of 700%. Effectively, 8 bits are consumed per
    value even when only 1 bit is of use.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å†…å­˜æ•ˆç‡æœ€å·®çš„æƒ…å†µä¸‹ï¼Œ`bitsPerValue` ä» 1 è°ƒæ•´åˆ° 8ã€‚å¯¹äºæ¯ä¸€ä¸ªå­˜åœ¨çš„æœ‰æ•ˆä½ï¼Œæ¶ˆè€— 7 ä¸ªå…¶ä»–æœªä½¿ç”¨çš„ä½ã€‚è¿™å¯¼è‡´äº† 700% çš„å†…å­˜å¼€é”€ã€‚å®é™…ä¸Šï¼Œå³ä½¿åªæœ‰
    1 ä½åœ¨ä½¿ç”¨ï¼Œæ¯ä¸ªå€¼ä¹Ÿä¼šæ¶ˆè€— 8 ä½ã€‚
- en: An `acceptableOverheadRatio` of 7 tends to have the fastest random read access.
    This is the result when `bitsPerValue` from 1 to 7 is adjusted to 8, `bitsPerValue`
    from 9 to 15 is adjusted to 16, and so on. The implementation has a varying degree
    of memory overhead, the highest of which is 700%.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`acceptableOverheadRatio` ä¸º 7 æ—¶ï¼Œéšæœºè¯»å–è®¿é—®é€Ÿåº¦å¾€å¾€æœ€å¿«ã€‚è¿™æ˜¯å½“`bitsPerValue`ä» 1 åˆ° 7 è°ƒæ•´ä¸º 8ï¼Œ`bitsPerValue`ä»
    9 åˆ° 15 è°ƒæ•´ä¸º 16ï¼Œä»¥æ­¤ç±»æ¨æ—¶çš„ç»“æœã€‚å®ç°çš„å†…å­˜å¼€é”€æœ‰ä¸åŒç¨‹åº¦ï¼Œæœ€é«˜è¾¾åˆ° 700%ã€‚'
- en: '![](../Images/c2b91d603cfd1e6d181f95198bd302b4.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c2b91d603cfd1e6d181f95198bd302b4.png)'
- en: 'Figure 6: Memory overheads when bits per value are adjusted to 8'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ 6ï¼šå½“æ¯ä¸ªå€¼çš„ä½æ•°è°ƒæ•´ä¸º 8 æ—¶çš„å†…å­˜å¼€é”€
- en: On the other hand, when `acceptableOverheadRatio` is 0, the `bitsPerValue` is
    kept as is without adjustment. Data is tightly packed to achieve the best memory
    efficiency, but random reads may be slow. There is a higher chance that more than
    one value occupies the space of a byte. Because of this, the bits representing
    a value could spill over to the next byte.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: å¦ä¸€æ–¹é¢ï¼Œå½“`acceptableOverheadRatio`ä¸º 0 æ—¶ï¼Œ`bitsPerValue`ä¿æŒä¸å˜ï¼Œä¸è¿›è¡Œè°ƒæ•´ã€‚æ•°æ®è¢«ç´§å¯†æ‰“åŒ…ä»¥å®ç°æœ€ä½³å†…å­˜æ•ˆç‡ï¼Œä½†éšæœºè¯»å–å¯èƒ½è¾ƒæ…¢ã€‚å¯èƒ½ä¼šæœ‰å¤šä¸ªå€¼å æ®ä¸€ä¸ªå­—èŠ‚çš„ç©ºé—´ã€‚å› æ­¤ï¼Œè¡¨ç¤ºä¸€ä¸ªå€¼çš„ä½å¯èƒ½ä¼šæº¢å‡ºåˆ°ä¸‹ä¸€ä¸ªå­—èŠ‚ã€‚
- en: '![](../Images/d3a86207a2056509ac19233b4e460d1e.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d3a86207a2056509ac19233b4e460d1e.png)'
- en: 'Figure 7: Example of tightly packed data with 6 bits per value. The number
    of bytes is reduced from 4 to 3.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ 7ï¼šå…·æœ‰æ¯å€¼ 6 ä½çš„ç´§å‡‘æ•°æ®ç¤ºä¾‹ã€‚å­—èŠ‚æ•°ä» 4 å‡å°‘åˆ° 3ã€‚
- en: With all that said, the default compression mode that Lucene uses for **PackedInts**
    has an `acceptableOverheadRatio` of 0.25\. This setting ensures that any memory
    overhead induced will never exceed 25%.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ç»¼ä¸Šæ‰€è¿°ï¼ŒLucene é»˜è®¤ä½¿ç”¨çš„**PackedInts**å‹ç¼©æ¨¡å¼çš„`acceptableOverheadRatio`ä¸º 0.25ã€‚æ­¤è®¾ç½®ç¡®ä¿ä»»ä½•äº§ç”Ÿçš„å†…å­˜å¼€é”€æ°¸è¿œä¸ä¼šè¶…è¿‡
    25%ã€‚
- en: VInt
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VInt
- en: '[**VInt**](https://lucene.apache.org/core/9_6_0/core/org/apache/lucene/store/DataOutput.html#writeVInt(int))
    is a type of base-128 compression that generates [variable-length integers](https://en.wikipedia.org/wiki/Variable-length_quantity).
    Each integer is individually encoded as 1 to 5 bytes.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[**VInt**](https://lucene.apache.org/core/9_6_0/core/org/apache/lucene/store/DataOutput.html#writeVInt(int))
    æ˜¯ä¸€ç§åŸºç¡€ 128 å‹ç¼©ç±»å‹ï¼Œç”Ÿæˆ[å¯å˜é•¿åº¦æ•´æ•°](https://en.wikipedia.org/wiki/Variable-length_quantity)ã€‚æ¯ä¸ªæ•´æ•°å•ç‹¬ç¼–ç ä¸º
    1 åˆ° 5 å­—èŠ‚ã€‚'
- en: '![](../Images/86c8f20d6eee3505d02b442b4315dfe0.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/86c8f20d6eee3505d02b442b4315dfe0.png)'
- en: 'Figure 8: An example of converting 17000 to **VInt**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ 8ï¼šå°† 17000 è½¬æ¢ä¸º**VInt**çš„ç¤ºä¾‹
- en: To generate **VInt**, the bits are split into chunks of 7, starting from the
    less significant bits on the right.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ç”Ÿæˆ**VInt**æ—¶ï¼Œä½è¢«åˆ†æˆ 7 ä½ä¸€ç»„ï¼Œä»å³ä¾§çš„ä½ä½å¼€å§‹ã€‚
- en: For each chunk of 7 bits going from right to left, another bit is added to form
    a byte. This bit acts as a continuation flag and constitutes the most significant
    bit of the byte. The value of this bit is `1` if there is more byte to follow,
    else it is `0`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºæ¯ä¸ªä»å³åˆ°å·¦çš„ 7 ä½å—ï¼Œå¦ä¸€ä¸ªä½è¢«æ·»åŠ ä»¥å½¢æˆä¸€ä¸ªå­—èŠ‚ã€‚è¿™ä¸ªä½ä½œä¸ºç»­æ¥æ ‡å¿—ï¼Œæ„æˆå­—èŠ‚çš„æœ€é«˜æœ‰æ•ˆä½ã€‚å¦‚æœåé¢è¿˜æœ‰æ›´å¤šå­—èŠ‚ï¼Œè¿™ä¸ªä½çš„å€¼ä¸º`1`ï¼Œå¦åˆ™ä¸º`0`ã€‚
- en: With this representation, 1 byte is sufficient for small integers ranging from
    0 to 127\. Most integers would require 3 bytes or less, as 3 bytes in **VInt**
    is able to represent values between 16,384 and 2,097,151.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿™ç§è¡¨ç¤ºæ–¹å¼ï¼Œ1 å­—èŠ‚è¶³ä»¥è¡¨ç¤ºä» 0 åˆ° 127 çš„å°æ•´æ•°ã€‚å¤§å¤šæ•°æ•´æ•°éœ€è¦ 3 å­—èŠ‚æˆ–æ›´å°‘ï¼Œå› ä¸º 3 å­—èŠ‚çš„**VInt**èƒ½å¤Ÿè¡¨ç¤º 16,384
    åˆ° 2,097,151 ä¹‹é—´çš„å€¼ã€‚
- en: Earlier, referring to *Figure 2*, we mentioned that the remaining Doc Deltas
    are encoded with **VInt**. What happens when term frequencies are indexed?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹‹å‰ï¼Œå‚è§*å›¾ 2*ï¼Œæˆ‘ä»¬æåˆ°å‰©ä½™çš„æ–‡æ¡£å¢é‡æ˜¯ç”¨**VInt**ç¼–ç çš„ã€‚å½“æœ¯è¯­é¢‘ç‡è¢«ç´¢å¼•æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆå‘¢ï¼Ÿ
- en: In that case, Doc Delta now defines both the document number and the frequency.
    The bits that represent Doc Delta would be shifted one step to the left, such
    that the least significant bit is now used to mark if the frequency is one or
    not. If the frequency is one, the least significant bit is `1`, else it is `0`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ–‡æ¡£å¢é‡ç°åœ¨å®šä¹‰äº†æ–‡æ¡£ç¼–å·å’Œé¢‘ç‡ã€‚è¡¨ç¤ºæ–‡æ¡£å¢é‡çš„ä½å°†å‘å·¦ç§»åŠ¨ä¸€æ­¥ï¼Œè¿™æ ·æœ€ä¸é‡è¦çš„ä½ç°åœ¨ç”¨äºæ ‡è®°é¢‘ç‡æ˜¯å¦ä¸º1ã€‚å¦‚æœé¢‘ç‡ä¸º1ï¼Œåˆ™æœ€ä¸é‡è¦çš„ä½ä¸º`1`ï¼Œå¦åˆ™ä¸º`0`ã€‚
- en: As documented in the [Lucene90PostingsFormat](https://lucene.apache.org/core/9_6_0/core/org/apache/lucene/codecs/lucene90/Lucene90PostingsFormat.html),
    when Doc Delta is odd, the frequency is one. When Doc Delta is even, the frequency
    is read as another **VInt**.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚åœ¨[Lucene90PostingsFormat](https://lucene.apache.org/core/9_6_0/core/org/apache/lucene/codecs/lucene90/Lucene90PostingsFormat.html)ä¸­æ‰€è®°å½•ï¼Œå½“æ–‡æ¡£å¢é‡ä¸ºå¥‡æ•°æ—¶ï¼Œé¢‘ç‡ä¸º1ã€‚å½“æ–‡æ¡£å¢é‡ä¸ºå¶æ•°æ—¶ï¼Œé¢‘ç‡è¢«è¯»å–ä¸ºå¦ä¸€ä¸ª**VInt**ã€‚
- en: The illustration below shows how Doc Deltas `7, 10` (for which a term occurs
    once and three times respectively) are encoded with the sequence `15, 20, 3` in
    **VInt** when term frequencies are indexed.
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸‹å›¾æ˜¾ç¤ºäº†å¦‚ä½•åœ¨**VInt**ä¸­å¯¹æ–‡æ¡£å¢é‡`7, 10`ï¼ˆå…¶ä¸­è¯è¯­åˆ†åˆ«å‡ºç°ä¸€æ¬¡å’Œä¸‰æ¬¡ï¼‰è¿›è¡Œç¼–ç ï¼Œåºåˆ—ä¸º`15, 20, 3`ï¼Œå½“è¯é¢‘è¢«ç´¢å¼•æ—¶ã€‚
- en: '![](../Images/53bce2fc2af732bdf71904546f774a4d.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/53bce2fc2af732bdf71904546f774a4d.png)'
- en: 'Figure 9: **VInt** encoding with and without term frequencies'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 'å›¾ 9: **VInt** ç¼–ç ä¸ä¸ç¼–ç è¯é¢‘çš„å¯¹æ¯”'
- en: FixedBitSet
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FixedBitSet
- en: In Lucene, [**FixedBitSet**](https://lucene.apache.org/core/9_6_0/core/org/apache/lucene/util/FixedBitSet.html)
    is a bitmap implementation of fixed length to store Doc IDs in memory.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨Luceneä¸­ï¼Œ[**FixedBitSet**](https://lucene.apache.org/core/9_6_0/core/org/apache/lucene/util/FixedBitSet.html)æ˜¯ä¸€ä¸ªå›ºå®šé•¿åº¦çš„ä½å›¾å®ç°ï¼Œç”¨äºåœ¨å†…å­˜ä¸­å­˜å‚¨æ–‡æ¡£IDã€‚
- en: A bitmap is a collection of bits that map to a list of integers. A bit that
    is set to `1` represents an integer whose value is the index of the bit.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ä½å›¾æ˜¯ä¸€ç»„æ˜ å°„åˆ°æ•´æ•°åˆ—è¡¨çš„ä½ã€‚ä¸€ä¸ªè¢«è®¾ç½®ä¸º`1`çš„ä½è¡¨ç¤ºä¸€ä¸ªæ•´æ•°ï¼Œå…¶å€¼æ˜¯è¯¥ä½çš„ç´¢å¼•ã€‚
- en: '**FixedBitSet** is internally implemented as a `*long[]*` integer array in
    Lucene, and as such each integer holds 64 bits. The length of this array (or the
    number of integers in this array) is determined based on the number of bits that
    one needs for the bitmap.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**FixedBitSet**åœ¨Luceneä¸­å†…éƒ¨å®ç°ä¸º`*long[]*`æ•´æ•°æ•°ç»„ï¼Œå› æ­¤æ¯ä¸ªæ•´æ•°å 64ä¸ªä½ã€‚è¯¥æ•°ç»„çš„é•¿åº¦ï¼ˆæˆ–æ•°ç»„ä¸­çš„æ•´æ•°æ•°é‡ï¼‰åŸºäºä½å›¾æ‰€éœ€çš„ä½æ•°æ¥ç¡®å®šã€‚'
- en: For example, to encode a list of Doc IDs whose largest value is 190, a bitmap
    comprising at least 191 bits is required to represent bitmap indices from 0 to
    190\. As a result, an array of length 3 will be allocated, and this array is capable
    of holding `3*64=192` bits.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œè¦ç¼–ç ä¸€ä¸ªæœ€å¤§å€¼ä¸º190çš„æ–‡æ¡£IDåˆ—è¡¨ï¼Œéœ€è¦è‡³å°‘191ä¸ªä½æ¥è¡¨ç¤ºä»0åˆ°190çš„ä½å›¾ç´¢å¼•ã€‚å› æ­¤ï¼Œå°†åˆ†é…ä¸€ä¸ªé•¿åº¦ä¸º3çš„æ•°ç»„ï¼Œè¯¥æ•°ç»„èƒ½å¤Ÿå®¹çº³`3*64=192`ä½ã€‚
- en: '![](../Images/e434a6faf6b00b5402d39af6f27a27af.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e434a6faf6b00b5402d39af6f27a27af.png)'
- en: 'Figure 10: An example of **FixedBitSet** â€” The `bitset[]` array contains 3
    long integers of 64 bits each'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 'å›¾ 10: **FixedBitSet** ç¤ºä¾‹ â€” `bitset[]` æ•°ç»„åŒ…å«3ä¸ª64ä½çš„é•¿æ•´æ•°'
- en: In the above example, **FixedBitSet** uses 24 bytes to encode a list of 6 integers
    whose largest value is 190\. This is an example of sparse data, whereby only 6
    out of 192 bits are set to `1` in the bitset.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸Šè¿°ç¤ºä¾‹ä¸­ï¼Œ**FixedBitSet**ä½¿ç”¨24ä¸ªå­—èŠ‚æ¥ç¼–ç ä¸€ä¸ªæœ€å¤§å€¼ä¸º190çš„6ä¸ªæ•´æ•°çš„åˆ—è¡¨ã€‚è¿™æ˜¯ç¨€ç–æ•°æ®çš„ä¸€ä¸ªä¾‹å­ï¼Œå…¶ä¸­åœ¨ä½é›†ä¸­çš„192ä¸ªä½ä¸­ä»…æœ‰6ä¸ªä½è¢«è®¾ç½®ä¸º`1`ã€‚
- en: Here, there is no saving in memory and the same number of bytes is used if these
    integers were to be stored using `*int*` type.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œï¼Œå¦‚æœè¿™äº›æ•´æ•°ä½¿ç”¨`*int*`ç±»å‹å­˜å‚¨ï¼Œåˆ™å†…å­˜æ²¡æœ‰èŠ‚çœï¼Œæ‰€ç”¨çš„å­—èŠ‚æ•°ç›¸åŒã€‚
- en: It shows that **FixedBitSet**, or bitmap in general, is less efficient when
    the data it is representing is sparse.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™è¡¨æ˜ï¼Œå½“å…¶è¡¨ç¤ºçš„æ•°æ®æ˜¯ç¨€ç–æ—¶ï¼Œ**FixedBitSet**æˆ–ä¸€èˆ¬ä½å›¾çš„æ•ˆç‡è¾ƒä½ã€‚
- en: RoaringDocIdSet (Roaring Bitmaps)
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RoaringDocIdSetï¼ˆRoaring ä½å›¾ï¼‰
- en: '![](../Images/66f4ea57bd23080f42d2cda2878ee589.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/66f4ea57bd23080f42d2cda2878ee589.png)'
- en: Photo by [Glen Carrie](https://unsplash.com/fr/@glencarrie?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡ç”±[Glen Carrie](https://unsplash.com/fr/@glencarrie?utm_source=medium&utm_medium=referral)æ‹æ‘„ï¼Œæ¥æºäº[Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: In Lucene, queries are cached with LRU, a caching scheme that evicts the least
    recently used item to make room for new ones when the cache is full. Caching allows
    fast access to data that is frequently queried.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨Luceneä¸­ï¼ŒæŸ¥è¯¢é€šè¿‡LRUç¼“å­˜ï¼ŒLRUæ˜¯ä¸€ç§ç¼“å­˜æ–¹æ¡ˆï¼Œå½“ç¼“å­˜æ»¡æ—¶ä¼šé©±é€æœ€å°‘ä½¿ç”¨çš„é¡¹ä»¥ä¸ºæ–°çš„é¡¹è…¾å‡ºç©ºé—´ã€‚ç¼“å­˜å…è®¸å¿«é€Ÿè®¿é—®ç»å¸¸æŸ¥è¯¢çš„æ•°æ®ã€‚
- en: Not all queries are cached in Lucene though. But for those that are, the cached
    content contains the Doc ID result set.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: å¹¶éæ‰€æœ‰æŸ¥è¯¢åœ¨Luceneä¸­éƒ½è¢«ç¼“å­˜ã€‚ä½†æ˜¯ï¼Œå¯¹äºé‚£äº›è¢«ç¼“å­˜çš„å†…å®¹ï¼Œç¼“å­˜çš„å†…å®¹åŒ…å«æ–‡æ¡£IDç»“æœé›†ã€‚
- en: The [LRU query cache](https://lucene.apache.org/core/9_6_0/core/org/apache/lucene/search/LRUQueryCache.html)
    in Lucene uses **RoaringDocIdSet** for sets that have a density that is less than
    1%. Otherwise, **FixedBitSet** is used.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Lucene ä¸­çš„[LRU æŸ¥è¯¢ç¼“å­˜](https://lucene.apache.org/core/9_6_0/core/org/apache/lucene/search/LRUQueryCache.html)å¯¹å¯†åº¦å°äº
    1% çš„é›†åˆä½¿ç”¨**RoaringDocIdSet**ã€‚å¦åˆ™ï¼Œä½¿ç”¨**FixedBitSet**ã€‚
- en: '[**RoaringDocIdSet**](https://lucene.apache.org/core/9_6_0/core/org/apache/lucene/util/RoaringDocIdSet.html)
    is an implementation inspired by the ideas and design structure from **Roaring
    Bitmaps.** So what are **Roaring Bitmaps**? As described by [*roaringbitmap.org*](http://roaringbitmap.org/about/),'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[**RoaringDocIdSet**](https://lucene.apache.org/core/9_6_0/core/org/apache/lucene/util/RoaringDocIdSet.html)
    æ˜¯å—**Roaring Bitmaps**çš„æ€æƒ³å’Œè®¾è®¡ç»“æ„å¯å‘çš„å®ç°ã€‚é‚£ä¹ˆ**Roaring Bitmaps**æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿæ­£å¦‚ [*roaringbitmap.org*](http://roaringbitmap.org/about/)æ‰€æè¿°çš„é‚£æ ·ï¼Œ'
- en: Roaring bitmaps are compressed bitmaps which tend to outperform conventional
    compressed bitmaps such as WAH, EWAH or Concise. In some instances, they can be
    hundreds of times faster and they often offer significantly better compression.
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Roaring ä½å›¾æ˜¯å‹ç¼©ä½å›¾ï¼Œå…¶æ€§èƒ½é€šå¸¸ä¼˜äºä¼ ç»Ÿçš„å‹ç¼©ä½å›¾ï¼Œå¦‚ WAHã€EWAH æˆ– Conciseã€‚åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå®ƒä»¬çš„é€Ÿåº¦å¯ä»¥å¿«å‡ ç™¾å€ï¼Œè€Œä¸”é€šå¸¸æä¾›æ˜¾è‘—æ›´å¥½çš„å‹ç¼©æ•ˆæœã€‚
- en: '**Roaring Bitmaps** works by partitioning data and storing them into different
    containers. Sparse and dense data containers in **Roaring Bitmaps** are stored
    differently based on the containerâ€™s cardinality. In Luceneâ€™s literature, these
    containers are known as blocks.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**Roaring Bitmaps**é€šè¿‡å°†æ•°æ®åˆ†åŒºå¹¶å­˜å‚¨åˆ°ä¸åŒçš„å®¹å™¨ä¸­æ¥å·¥ä½œã€‚**Roaring Bitmaps**ä¸­çš„ç¨€ç–å’Œå¯†é›†æ•°æ®å®¹å™¨æ ¹æ®å®¹å™¨çš„åŸºæ•°ä»¥ä¸åŒçš„æ–¹å¼å­˜å‚¨ã€‚åœ¨
    Lucene çš„æ–‡çŒ®ä¸­ï¼Œè¿™äº›å®¹å™¨è¢«ç§°ä¸ºå—ã€‚'
- en: In **RoaringDocIdSet,** the block number is identified by the 16 most significant
    bits. The remaining 16 least significant bits are the value that would be stored
    in the block.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨**RoaringDocIdSet**ä¸­ï¼Œå—å·ç”± 16 ä¸ªæœ€é‡è¦çš„ä½æ ‡è¯†ã€‚å‰©ä½™çš„ 16 ä¸ªæœ€ä½æœ‰æ•ˆä½æ˜¯å°†å­˜å‚¨åœ¨å—ä¸­çš„å€¼ã€‚
- en: '![](../Images/19fe15269ccb81531662b81c6b3199f8.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/19fe15269ccb81531662b81c6b3199f8.png)'
- en: 'Figure 11: Examples of Doc IDs in binary format'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ 11ï¼šæ–‡æ¡£ ID çš„äºŒè¿›åˆ¶æ ¼å¼ç¤ºä¾‹
- en: From the above example, this would result in the first four Doc IDs being stored
    in *Block 0\.* The next two Doc IDs would be stored in *Block 1*, and the last
    three Doc IDs would be stored in *Block 4*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ä»ä¸Šè¿°ç¤ºä¾‹å¯ä»¥çœ‹å‡ºï¼Œå‰å››ä¸ªæ–‡æ¡£ ID ä¼šè¢«å­˜å‚¨åœ¨*Block 0*ä¸­ã€‚æ¥ä¸‹æ¥çš„ä¸¤ä¸ªæ–‡æ¡£ ID å°†å­˜å‚¨åœ¨*Block 1*ä¸­ï¼Œè€Œæœ€åä¸‰ä¸ªæ–‡æ¡£ ID åˆ™å­˜å‚¨åœ¨*Block
    4*ä¸­ã€‚
- en: '![](../Images/f89d4a2460849fc706f8134135baed02.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f89d4a2460849fc706f8134135baed02.png)'
- en: 'Figure 12: The data partitioned into blocks in **RoaringDocIdSet**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ 12ï¼š**RoaringDocIdSet**ä¸­æ•°æ®çš„å—åˆ†åŒº
- en: This way, **RoaringDocIdSet** can accommodate up to `2Â¹â¶ = 65536` blocks, and
    each block can store a maximum of 65536 records.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ ·ï¼Œ**RoaringDocIdSet** å¯ä»¥å®¹çº³æœ€å¤š`2Â¹â¶ = 65536`ä¸ªå—ï¼Œæ¯ä¸ªå—å¯ä»¥å­˜å‚¨æœ€å¤š 65536 æ¡è®°å½•ã€‚
- en: But how exactly are data in these blocks stored?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: é‚£ä¹ˆè¿™äº›å—ä¸­çš„æ•°æ®ç©¶ç«Ÿæ˜¯å¦‚ä½•å­˜å‚¨çš„å‘¢ï¼Ÿ
- en: With 16 bits (or 2 bytes) per record, a `*short[]*` integer array takes up 128
    kB for 65536 records. The space required by the array grows linearly with the
    number of records.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: æ¯æ¡è®°å½• 16 ä½ï¼ˆæˆ– 2 å­—èŠ‚ï¼‰ï¼Œä¸€ä¸ª`*short[]*`æ•´å‹æ•°ç»„å ç”¨ 128 kB å­˜å‚¨ 65536 æ¡è®°å½•ã€‚æ•°ç»„æ‰€éœ€çš„ç©ºé—´éšç€è®°å½•æ•°é‡çº¿æ€§å¢é•¿ã€‚
- en: Conversely, a bitmap that can hold 65536 bits takes up only 8 kB. Compared to
    128 kB, that is a huge difference, a 16 times reduction in space. As a result,
    one would be inclined to think that using a bitmap is more efficient.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸åï¼Œä¸€ä¸ªå¯ä»¥å®¹çº³ 65536 ä½çš„ä½å›¾ä»…å ç”¨ 8 kBã€‚ä¸ 128 kB ç›¸æ¯”ï¼Œè¿™æ˜¯ä¸€ç§å·¨å¤§çš„å·®å¼‚ï¼Œç©ºé—´å‡å°‘äº† 16 å€ã€‚å› æ­¤ï¼Œäººä»¬å€¾å‘äºè®¤ä¸ºä½¿ç”¨ä½å›¾æ›´ä¸ºé«˜æ•ˆã€‚
- en: '![](../Images/bf1919f9d8b800ec6cef04ea8a0f59c4.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/bf1919f9d8b800ec6cef04ea8a0f59c4.png)'
- en: 'Figure 13: Using `short[]` integer array versus bitmap'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ 13ï¼šä½¿ç”¨`short[]`æ•´å‹æ•°ç»„ä¸ä½å›¾
- en: But wait, letâ€™s do some analysis and look carefully at the graph again. It can
    be observed that when the total count of records is under 4096, storing them with
    a `*short[]*` integer array actually consumes less than 8 kB of space.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†ç¨ç­‰ï¼Œæˆ‘ä»¬æ¥åšäº›åˆ†æï¼Œä»”ç»†æŸ¥çœ‹å›¾è¡¨ã€‚å¯ä»¥è§‚å¯Ÿåˆ°ï¼Œå½“è®°å½•æ€»æ•°ä½äº 4096 æ—¶ï¼Œä½¿ç”¨`*short[]*`æ•´å‹æ•°ç»„å®é™…ä¸Šå ç”¨çš„ç©ºé—´ä¸åˆ° 8 kBã€‚
- en: And that is what led to how the storage method is determined for each block.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°±æ˜¯å†³å®šæ¯ä¸ªå—å­˜å‚¨æ–¹æ³•çš„åŸå› ã€‚
- en: Using a hybrid data structure, a sparse block containing less than 4096 records
    is stored using a `*short[]*` integer array, while a dense block with 4096 or
    more records is stored using a bitmap.
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½¿ç”¨æ··åˆæ•°æ®ç»“æ„ï¼ŒåŒ…å«å°‘äº 4096 æ¡è®°å½•çš„ç¨€ç–å—ä½¿ç”¨`*short[]*`æ•´å‹æ•°ç»„å­˜å‚¨ï¼Œè€ŒåŒ…å« 4096 æ¡æˆ–æ›´å¤šè®°å½•çš„å¯†é›†å—åˆ™ä½¿ç”¨ä½å›¾å­˜å‚¨ã€‚
- en: ''
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Lucene even improves this further by storing the inverse of the set using a
    `*short[]*` integer array for superdense blocks.
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Lucene è¿›ä¸€æ­¥æ”¹è¿›äº†è¿™ä¸€ç‚¹ï¼Œé€šè¿‡ä½¿ç”¨`*short[]*`æ•´å‹æ•°ç»„å­˜å‚¨è¶…å¯†é›†å—çš„é›†åˆçš„åå‘æ•°æ®ã€‚
- en: What this means is when the number of records is more than 61440, the inverse
    of the set, which has less than 4096 values, is stored instead. How brilliant
    is that!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ„å‘³ç€å½“è®°å½•æ•°è¶…è¿‡61440æ—¶ï¼Œå­˜å‚¨çš„æ˜¯å…·æœ‰ä¸åˆ°4096ä¸ªå€¼çš„é›†åˆçš„é€†ã€‚è¿™æ˜¯å¤šä¹ˆèªæ˜çš„åšæ³•ï¼
- en: '![](../Images/42073f4aa2cf37f8d8f4a0d8b8a0211a.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/42073f4aa2cf37f8d8f4a0d8b8a0211a.png)'
- en: 'Figure 14: For superdense blocks, Lucene stores the inverse of the set using
    a `*short[]*` integer array.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾14ï¼šå¯¹äºè¶…å¯†é›†å—ï¼ŒLuceneä½¿ç”¨`*short[]*`æ•´æ•°æ•°ç»„å­˜å‚¨é›†åˆçš„é€†ã€‚
- en: It is interesting to see how **RoaringDocIdSet** performed when benchmarked
    against **FixedBitSet** in this [patch](https://issues.apache.org/jira/browse/LUCENE-7339).
    From the [graph](http://people.apache.org/~jpountz/doc_id_sets6.html), it can
    be observed that when the density of the Doc ID set is less than 1%,
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æœ‰è¶£çš„æ˜¯ï¼Œ**RoaringDocIdSet**åœ¨ä¸**FixedBitSet**è¿›è¡ŒåŸºå‡†æµ‹è¯•æ—¶çš„è¡¨ç°ã€‚æ ¹æ®è¿™ä¸ª[è¡¥ä¸](https://issues.apache.org/jira/browse/LUCENE-7339)ï¼Œä»[å›¾è¡¨](http://people.apache.org/~jpountz/doc_id_sets6.html)å¯ä»¥è§‚å¯Ÿåˆ°ï¼Œå½“Doc
    IDé›†çš„å¯†åº¦ä½äº1%æ—¶ï¼Œ
- en: ''
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '- the memory footprint of **RoaringDocIdSet** can go down to more than 128
    times smaller than **FixedBitSet**.'
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '- **RoaringDocIdSet**çš„å†…å­˜å ç”¨å¯æ¯”**FixedBitSet**å°è¶…è¿‡128å€ã€‚'
- en: ''
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '- the build time of **RoaringDocIdSet** can go up to approximately 64 times
    faster than **FixedBitSet**.'
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '- **RoaringDocIdSet**çš„æ„å»ºæ—¶é—´å¯å¿«çº¦64å€äº**FixedBitSet**ã€‚'
- en: ''
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '- the iteration performance and skip performance of **RoaringDocIdSet** (using
    `*nextDoc()*`and `*advance()*`) can go up to approximately 90 times faster than
    **FixedBitSet**.'
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '- **RoaringDocIdSet**çš„è¿­ä»£æ€§èƒ½å’Œè·³è¿‡æ€§èƒ½ï¼ˆä½¿ç”¨`*nextDoc()*`å’Œ`*advance()*`ï¼‰å¯å¿«çº¦90å€äº**FixedBitSet**ã€‚'
- en: ''
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: On the contrary, **FixedBitSet** performed better than **RoaringDocIdSet** when
    the density of the Doc ID set is above 1%.
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç›¸åï¼Œå½“Doc IDé›†çš„å¯†åº¦é«˜äº1%æ—¶ï¼Œ**FixedBitSet**çš„è¡¨ç°ä¼˜äº**RoaringDocIdSet**ã€‚
- en: Key Takeaways
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å…³é”®è¦ç‚¹
- en: When it comes to compression, thereâ€™s no one-size-fits-all method. To approach
    integer compression, Lucene uses a combination of techniques and strategies in
    order to obtain the best possible result.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨å‹ç¼©æ–¹é¢ï¼Œæ²¡æœ‰ä¸€ç§é€šç”¨çš„æ–¹æ³•ã€‚ä¸ºäº†å®ç°æœ€ä½³ç»“æœï¼ŒLuceneä½¿ç”¨äº†å¤šç§æŠ€æœ¯å’Œç­–ç•¥æ¥å¤„ç†æ•´æ•°å‹ç¼©ã€‚
- en: '**Delta encoding** plays an important role in effectively reducing integer
    size before moving on to compression with **PackedInts** or **VInt**.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Deltaç¼–ç **åœ¨æœ‰æ•ˆå‡å°‘æ•´æ•°å¤§å°åï¼Œå†è¿›è¡Œ**PackedInts**æˆ–**VInt**çš„å‹ç¼©ä¸­èµ·ç€é‡è¦ä½œç”¨ã€‚'
- en: What if there is a presence of large values? Data compression quality is compromised
    since the largest integer in the block determines the number of bits per value
    to use for **PackedInts**. Splitting Doc Deltas and term frequencies into fixed-size
    blocks is a smart way to mitigate this issue. The impact is confined only to data
    within the block, and others stay unaffected.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœå­˜åœ¨å¤§å€¼ä¼šæ€æ ·ï¼Ÿæ•°æ®å‹ç¼©è´¨é‡ä¼šå—åˆ°å½±å“ï¼Œå› ä¸ºå—ä¸­çš„æœ€å¤§æ•´æ•°å†³å®šäº†ç”¨äº**PackedInts**çš„æ¯ä¸ªå€¼çš„ä½æ•°ã€‚å°†Doc Deltaså’Œæœ¯è¯­é¢‘ç‡æ‹†åˆ†æˆå›ºå®šå¤§å°çš„å—æ˜¯ç¼“è§£æ­¤é—®é¢˜çš„æ˜æ™ºæ–¹æ³•ã€‚å…¶å½±å“ä»…é™äºå—å†…çš„æ•°æ®ï¼Œè€Œå…¶ä»–æ•°æ®ä¿æŒä¸å˜ã€‚
- en: While bitmaps are ideal for dense integer sets, it is fascinating to see how
    **RoaringDocIdSet (**an adaptation of **Roaring Bitmaps**) approaches dense and
    sparse sets in an ingenious way.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å°½ç®¡ä½å›¾éå¸¸é€‚åˆäºå¯†é›†æ•´æ•°é›†åˆï¼Œä½†çœ‹åˆ°**RoaringDocIdSet**ï¼ˆ**Roaring Bitmaps**çš„ä¸€ç§å˜ä½“ï¼‰ä»¥å·§å¦™çš„æ–¹å¼å¤„ç†å¯†é›†å’Œç¨€ç–é›†åˆï¼Œç¡®å®ä»¤äººç€è¿·ã€‚
- en: Conclusion
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç»“è®º
- en: A big part of Lucene deals with integers. Hence, integer compression is of utmost
    importance in reducing storage and memory footprint, as well as shortening transmission
    time when data is fetched from or written to disk or memory.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Luceneçš„å¤§éƒ¨åˆ†å·¥ä½œæ¶‰åŠæ•´æ•°ã€‚å› æ­¤ï¼Œæ•´æ•°å‹ç¼©åœ¨å‡å°‘å­˜å‚¨å’Œå†…å­˜å ç”¨ï¼Œä»¥åŠç¼©çŸ­ä»ç£ç›˜æˆ–å†…å­˜è¯»å–æˆ–å†™å…¥æ•°æ®çš„ä¼ è¾“æ—¶é—´æ–¹é¢è‡³å…³é‡è¦ã€‚
- en: As demonstrated by Lucene, adopting the right strategy for the right use case
    and thinking outside the box to optimize efficiency with fast access is one of
    many success factors leading to continuous growth and evolution in the search
    engine arena.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚Luceneæ‰€ç¤ºï¼Œé‡‡ç”¨æ­£ç¡®çš„ç­–ç•¥æ¥åŒ¹é…ç”¨ä¾‹ï¼Œå¹¶é€šè¿‡åˆ›æ–°æ–¹å¼ä¼˜åŒ–é«˜æ•ˆè®¿é—®ï¼Œæ˜¯ä¿ƒæˆæœç´¢å¼•æ“é¢†åŸŸæŒç»­å¢é•¿å’Œå‘å±•çš„æˆåŠŸå› ç´ ä¹‹ä¸€ã€‚
- en: These implementations can bring significant cost savings on storage, memory,
    and network bandwidth, along with improvement in performance.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›å®ç°å¯ä»¥åœ¨å­˜å‚¨ã€å†…å­˜å’Œç½‘ç»œå¸¦å®½æ–¹é¢å¸¦æ¥æ˜¾è‘—çš„æˆæœ¬èŠ‚çº¦ï¼ŒåŒæ—¶æå‡æ€§èƒ½ã€‚
- en: Reference
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å‚è€ƒ
- en: '[1] A. Grand, [Frame of Reference and Roaring Bitmaps](https://www.elastic.co/blog/frame-of-reference-and-roaring-bitmaps)
    (2015)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] A. Grand, [å‚è€ƒæ¡†æ¶ä¸Roaringä½å›¾](https://www.elastic.co/blog/frame-of-reference-and-roaring-bitmaps)ï¼ˆ2015ï¼‰'
- en: '[2] [Celebrating 20 years of Apache Lucene](https://www.elastic.co/celebrating-lucene)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[2] [åº†ç¥Apache Luceneæˆç«‹20å‘¨å¹´](https://www.elastic.co/celebrating-lucene)'
- en: '[3] [Roaring bitmaps: A better compressed bitset](https://roaringbitmap.org/)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[3] [å’†å“®ä½å›¾ï¼šæ›´å¥½çš„å‹ç¼©ä½é›†](https://roaringbitmap.org/)'
- en: '[4] S. Chambi, D. Lemire, O. Kaser, and R. Godin, [Better bitmap performance
    with Roaring bitmaps](https://arxiv.org/pdf/1402.6407.pdf) (2016)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[4] S. Chambi, D. Lemire, O. Kaser å’Œ R. Godin, [ä½¿ç”¨å’†å“®ä½å›¾æé«˜ä½å›¾æ€§èƒ½](https://arxiv.org/pdf/1402.6407.pdf)
    (2016)'
- en: '[5] D. Lemire, G. Ssi-Yan-Kai, and O. Kaser, [Consistently faster and smaller
    compressed bitmaps with Roaring](https://arxiv.org/pdf/1603.06549.pdf) (2018)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[5] D. Lemire, G. Ssi-Yan-Kai å’Œ O. Kaser, [ä½¿ç”¨å’†å“®ä½å›¾å®ç°ä¸€è‡´æ›´å¿«ä¸”æ›´å°çš„å‹ç¼©ä½å›¾](https://arxiv.org/pdf/1603.06549.pdf)
    (2018)'
- en: '[6] D. Lemire, O. Kaser, N. Kurz, L. Deri, C. Oâ€™Hara, F. Saint-Jacques, and
    G. Ssi-Yan-Kai, [Roaring Bitmaps: Implementation of an Optimized Software Library](https://arxiv.org/pdf/1709.07821.pdf)
    (2022)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[6] D. Lemire, O. Kaser, N. Kurz, L. Deri, C. Oâ€™Hara, F. Saint-Jacques å’Œ G.
    Ssi-Yan-Kai, [å’†å“®ä½å›¾ï¼šä¼˜åŒ–è½¯ä»¶åº“çš„å®ç°](https://arxiv.org/pdf/1709.07821.pdf) (2022)'
- en: '[7] V. Oberoi, [A primer on Roaring bitmaps: what they are and how they work](https://vikramoberoi.com/a-primer-on-roaring-bitmaps-what-they-are-and-how-they-work/)
    (2022)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[7] V. Oberoi, [å’†å“®ä½å›¾ç®€ä»‹ï¼šå®ƒä»¬æ˜¯ä»€ä¹ˆä»¥åŠå¦‚ä½•å·¥ä½œ](https://vikramoberoi.com/a-primer-on-roaring-bitmaps-what-they-are-and-how-they-work/)
    (2022)'
- en: '[8] D. Lemire and L. Boytsov, [Decoding billions of integers per second through
    vectorization](https://arxiv.org/pdf/1209.2137.pdf) (2021)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[8] D. Lemire å’Œ L. Boytsov, [é€šè¿‡å‘é‡åŒ–æ¯ç§’è§£ç æ•°åäº¿ä¸ªæ•´æ•°](https://arxiv.org/pdf/1209.2137.pdf)
    (2021)'
- en: '**Before You Goâ€¦**'
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**åœ¨ä½ ç¦»å¼€ä¹‹å‰â€¦**'
- en: ''
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*ğŸ™* Thank you for reading this post, and I hope youâ€™ve enjoyed learning about
    integer encoding and compression in Lucene.'
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*ğŸ™* æ„Ÿè°¢ä½ é˜…è¯»è¿™ç¯‡å¸–å­ï¼Œå¸Œæœ›ä½ å–œæ¬¢äº†è§£ Lucene ä¸­çš„æ•´æ•°ç¼–ç å’Œå‹ç¼©ã€‚'
- en: ''
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*ğŸ‘‰* If you like my post, donâ€™t forget to hit [**Follow**](https://peggy1502.medium.com/)
    and [**Subscribe**](https://peggy1502.medium.com/subscribe) to get notified via
    email when I publish.'
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*ğŸ‘‰* å¦‚æœä½ å–œæ¬¢æˆ‘çš„å¸–å­ï¼Œä¸è¦å¿˜è®°ç‚¹å‡» [**å…³æ³¨**](https://peggy1502.medium.com/) å’Œ [**è®¢é˜…**](https://peggy1502.medium.com/subscribe)ï¼Œä»¥ä¾¿åœ¨æˆ‘å‘å¸ƒæ–°å†…å®¹æ—¶é€šè¿‡ç”µå­é‚®ä»¶æ”¶åˆ°é€šçŸ¥ã€‚'
- en: ''
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*ğŸ˜ƒ* Optionally, you may also [**sign up**](https://peggy1502.medium.com/membership)
    for a Medium membership to get full access to every story on Medium.'
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*ğŸ˜ƒ* å¯é€‰åœ°ï¼Œä½ ä¹Ÿå¯ä»¥ [**æ³¨å†Œ**](https://peggy1502.medium.com/membership) æˆä¸º Medium ä¼šå‘˜ï¼Œä»¥è·å¾—å¯¹
    Medium ä¸Šæ¯ä¸ªæ•…äº‹çš„å®Œå…¨è®¿é—®æƒé™ã€‚'
- en: ''
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*ğŸ“‘* Visit this [GitHub repository](https://github.com/peggy1502/Data-Science-Articles/blob/main/README.md)
    for all the codes and notebooks that I shared in my posts.'
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*ğŸ“‘* è®¿é—®è¿™ä¸ª [GitHub ä»“åº“](https://github.com/peggy1502/Data-Science-Articles/blob/main/README.md)ï¼Œè·å–æˆ‘åœ¨å¸–å­ä¸­åˆ†äº«çš„æ‰€æœ‰ä»£ç å’Œç¬”è®°æœ¬ã€‚'
- en: ''
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Â© 2023 All rights reserved.*'
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Â© 2023 ä¿ç•™æ‰€æœ‰æƒåˆ©ã€‚*'
