- en: The New Best Python Package for Visualising Network Graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/the-new-best-python-package-for-visualising-network-graphs-e220d59e054e](https://towardsdatascience.com/the-new-best-python-package-for-visualising-network-graphs-e220d59e054e)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A guide on who should use it, when to use it, how to use it, and why I was wrong
    before…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@bl3e967?source=post_page-----e220d59e054e--------------------------------)[![Benjamin
    Lee](../Images/a369931c73019143609812354c773151.png)](https://medium.com/@bl3e967?source=post_page-----e220d59e054e--------------------------------)[](https://towardsdatascience.com/?source=post_page-----e220d59e054e--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----e220d59e054e--------------------------------)
    [Benjamin Lee](https://medium.com/@bl3e967?source=post_page-----e220d59e054e--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----e220d59e054e--------------------------------)
    ·10 min read·Nov 23, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/777d06e439c1fcdd3bf93623df5bf919.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Chris Ried](https://unsplash.com/@cdr6934?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this article, I will introduce to you a Python package I stumbled upon that
    is, in my humble opinion, the *BEST* tool I have seen so far for visualising network
    graphs.
  prefs: []
  type: TYPE_NORMAL
- en: Readers who are data scientists in need of a compact yet powerful visualisation
    package for quick prototyping, exploratory data analysis or debugging their network
    models are best suited for the contents below.
  prefs: []
  type: TYPE_NORMAL
- en: 'The package that we will be inspecting is called: `[gravis](https://robert-haas.github.io/gravis-docs/)`'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://robert-haas.github.io/gravis-docs/?source=post_page-----e220d59e054e--------------------------------)
    [## gravis — gravis 0.1.0 documentation'
  prefs: []
  type: TYPE_NORMAL
- en: Edit description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: robert-haas.github.io](https://robert-haas.github.io/gravis-docs/?source=post_page-----e220d59e054e--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 'I personally use graph neural networks a lot in my day-to-day job, and quite
    frankly, I am annoyed that I didn’t know about this package earlier as it would
    have saved me a lot of time and energy trying to work around the shortcomings
    of the packages (`ipysigma` and `pyvis`) that I wrote about here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/@bl3e967/the-two-best-tools-for-plotting-interactive-network-graphs-8d352aa894d4?source=post_page-----e220d59e054e--------------------------------)
    [## The Two Best Tools for Plotting Interactive Network Graphs'
  prefs: []
  type: TYPE_NORMAL
- en: A guide on how to use them, when to use them, and who should use them.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/@bl3e967/the-two-best-tools-for-plotting-interactive-network-graphs-8d352aa894d4?source=post_page-----e220d59e054e--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: '**What makes a network visualisation package the best?**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A visualisation package needs to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a fully interactive visualisation, where I can click on nodes and edges
    and view its attributes, plus drag and drop them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convenient to implement — doesn’t require too much code (like Dash), but powerful
    and flexible enough for most use cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moderately good scalability to the number of nodes and edges — we’re not making
    something for prod, but we need it to handle hundreds of nodes at least.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compatible with commonly used network packages in Python such as `networkx`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What will we be testing the package on?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Broadly speaking, we can qualify graphs according to whether they are homogenous
    or heterogeneous, or have directed or undirected edges.
  prefs: []
  type: TYPE_NORMAL
- en: We will therefore test the package on two types of graphs that we will generate
    using `networkx`,
  prefs: []
  type: TYPE_NORMAL
- en: (1) A homogenous, undirected graph
  prefs: []
  type: TYPE_NORMAL
- en: (2) A heterogeneous, directed multigraph
  prefs: []
  type: TYPE_NORMAL
- en: as these are the two extremes of what one might encounter. If you are unfamiliar
    with the terminology, I suggest you visit [my previous article](https://medium.com/@bl3e967/the-two-best-tools-for-plotting-interactive-network-graphs-8d352aa894d4)
    and have a quick read of the introduction.
  prefs: []
  type: TYPE_NORMAL
- en: TL;DR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Homogenous = 1 type of node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heterogeneous = multiple types of nodes and/or edges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Undirected = Edges have no direction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directed = Edges have a direction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-graph = Two nodes can have multiple edges between them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set Up and Installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The package can be simply installed via pip:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We also need to install the below packages in order to generate our test graphs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can also find all the code I use below in this repository.
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://github.com/bl3e967/medium-articles?tab=readme-ov-file&source=post_page-----e220d59e054e--------------------------------)
    [## GitHub - bl3e967/medium-articles: The accompanying code to my medium articles.'
  prefs: []
  type: TYPE_NORMAL
- en: The accompanying code to my medium articles. . Contribute to bl3e967/medium-articles
    development by creating an account…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: github.com](https://github.com/bl3e967/medium-articles?tab=readme-ov-file&source=post_page-----e220d59e054e--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Homogenous Undirected Network Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, to start us off, we need a graph to plot. We will write a simple graph generator
    function which will return a `networkx.Graph` object. We will add attributes to
    its node and edges to simulate data a data scientist might see in their work.
  prefs: []
  type: TYPE_NORMAL
- en: Graph Generator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use a random graph generator, for which I have selected the `networkx.dual_barabasi_albert_graph`
    method to simulate a scale-free network.
  prefs: []
  type: TYPE_NORMAL
- en: We add node level attributes such as `degree`, `betweenness_centrality`, and
    some made up features with random numbers which we imaginatively call `feature1`,
    `feature2`, `feature3`.
  prefs: []
  type: TYPE_NORMAL
- en: We do the same for the edges as well, and add features `feature1` and `feature2`.
  prefs: []
  type: TYPE_NORMAL
- en: We finally label each node with a `uuid` (**U**niversally **U**nique **ID**entifier)
    to make things look more like real data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When we plot the graph using `networkx` we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/a5f139c6566c84740ddb4996cf956faa.png)'
  prefs: []
  type: TYPE_IMG
- en: Test Graph of 50 nodes, homogenous and undirected.
  prefs: []
  type: TYPE_NORMAL
- en: Plotting with gravis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now move on to plotting this graph using `gravis`. It is very simple to get
    going with this package and in full, it looks like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Let’s break this down into chunks.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume we want to scale our node sizes according to their `betweenness_centrality`
    values and our edge thicknesses by their `feature1` values.
  prefs: []
  type: TYPE_NORMAL
- en: We set `use_node_size_normalization=True` such that the node sizes are set according
    to normalised values of the `betweenness_centrality`, and we define `node_size_normalization_min`
    and `node_size_normalisation_max` to set the min and max node sizes we want.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We use equivalent arguments for edges to control their thickness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Finally, I set the `many_body_force_strength` parameter to `-500` to make the
    edges longer than it is by default, to make the graph clearer to see.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting plot is shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/cae6b306007fd88f20ca289b6e741468.png)'
  prefs: []
  type: TYPE_IMG
- en: Our homogenous, undirected graph visualised using gravis
  prefs: []
  type: TYPE_NORMAL
- en: Adding Colour
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to scaling the node sizes by `betweenness_centrality`, I also want
    to colour them according to this as well.
  prefs: []
  type: TYPE_NORMAL
- en: We can achieve this simply by adding a `color` attribute to the nodes. I can
    use named colours such as ‘red’, ‘blue’, ‘green’, and I won’t bother trying to
    do that here as that is too trivial. Let’s try and use a colour scale instead.
  prefs: []
  type: TYPE_NORMAL
- en: I want to scale the values according to the `winter` colourmap found in `matplotlib`
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2ccfb1b61fd659882bd03742eeceacbd.png)'
  prefs: []
  type: TYPE_IMG
- en: Low centrality values will be mapped to blue, high values will be mapped to
    green.
  prefs: []
  type: TYPE_NORMAL
- en: I have this very helpful `MplColorHelper` class that I have used many times
    in my projects, that will convert a numeric value into an `RGB` string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: All I need to specify is the min-max values we want to scale the colormap over.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to colour nodes according to `betweenness_centrality` we do the below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: and for edges, let’s colour them according to `feature1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And voila, let there be colour:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5dfc4643e5b0559891b1200af1223150.png)'
  prefs: []
  type: TYPE_IMG
- en: Homogenous undirected network with node and edge colours
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `gravis` allows us to display any kind of free text stored on each
    node or edge using an information bar on the bottom of the visualisation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use this to display our feature values — we format some text with the
    feature values, and save it to an attribute named `click`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: And now we are able to display our feature values very nicely using a panel
    on the bottom of the screen (I’ve made the graphs extra large here so you can
    see it as you would on screen).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7256d3596a423315c06e017782d58000.png)'
  prefs: []
  type: TYPE_IMG
- en: Visualisation with node feature details displayed in the bottom panel.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/41aabc3b407209bffbd2126b562de312.png)'
  prefs: []
  type: TYPE_IMG
- en: Visualisation with edge feature details displayed in the bottom panel
  prefs: []
  type: TYPE_NORMAL
- en: We have a fully interactive visualisation that allows us to drag nodes, and
    a side-bar to change the settings for the node and edge visualisation, labels,
    and the layout algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'It also allows you to export the visualisation to an image using the settings
    bar — no extra code required! Finally, if you wished to share this interactive
    graph with anyone, you can export it as a self-contained HTML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Heterogeneous Directed Network Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now try and visualise a heterogeneous directed network using `gravis`.
  prefs: []
  type: TYPE_NORMAL
- en: Graph Generator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Again, we need a function to return such a graph for us. We will use the same
    function as before, but now using the `nx.scale_free_graph` function.
  prefs: []
  type: TYPE_NORMAL
- en: We also add in a `node_type` attribute to simulate a heterogeneous graph. The
    first 25 nodes will be `node_type = 0` and the remaining will be `node_type =
    1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Plotting this using `nx.draw` gives us this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a4eb5437f34ca8dec20b075ca199fc21.png)'
  prefs: []
  type: TYPE_IMG
- en: Heterogeneous directed multigraph, numbered to display which nodes are of which
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Plotting with gravis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'How we plot for heterogeneous graphs is exactly the same as above. We can use
    the same methods to:'
  prefs: []
  type: TYPE_NORMAL
- en: generate a test multi-digraph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: add feature values for nodes and edges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: add colour to nodes and edges according to an attribute value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All we need to do now is specify the shape of each node, as now we deal with
    multiple different node types.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our graph generator function `get_new_test_digraph`, we just need to add
    this line of code in our `for` loop over nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: where for our purposes of simulating real-life data, we set the first 25 nodes
    in our graphs to be of `node_type = 0`, else `node_type = 1`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we can use the `shape` attribute in gravis to specify the node shapes
    we want to use for each node.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will set `node_type = 0` to be circles, and rectangles for `node_type
    = 1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to plot our network in `gravis`. Notice we added the `edge_curvature`
    argument to be non-zero. This is necessary to prevent edges between two nodes
    from overlapping when there are many of them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/1383de024fac4f931caec612ca6fef5d.png)'
  prefs: []
  type: TYPE_IMG
- en: MultiDiGraph plotted on gravis with edge curvature and shapes set depending
    on the node type.
  prefs: []
  type: TYPE_NORMAL
- en: Voila! Simple and easy. You can see the multiple connections between some of
    the nodes on the left and the top of the graph.
  prefs: []
  type: TYPE_NORMAL
- en: Summary — Why I think Gravis is the best
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have already mentioned that I wrote about two other packages where I insisted
    they were the best — `pyvis` and `ipysigma`. I was convinced of this at the time
    as I had been using them myself for my day-to-day work.
  prefs: []
  type: TYPE_NORMAL
- en: However, they have their unique issues which, in hindsight, made them suboptimal
    and this was why I covered both of them in the same blog! Depending on the use
    case, one of them was better than the other and I recommended users on which one
    to use when.
  prefs: []
  type: TYPE_NORMAL
- en: This is why I was SHOCKED when I found `gravis`, as it seemed like someone had
    thought the exact same thing and developed this package to *combine* the pros
    of `pyvis` and `ipysigma` to make a perfect tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, `gravis` provides both a *fully* interactive UI as you can:'
  prefs: []
  type: TYPE_NORMAL
- en: Not only click on nodes and edges to display information but also allows the
    user to drag and drop nodes, very useful for complicated networks where the physics
    engine may need manual tweaking (and lacking in `ipysigma`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The node or edge information is displayed through a bar on the screen that neatly
    houses the information and also allows one to copy information from it (*a small
    but huge functionality that was lacking in* `pyvis` *that gave me a lot of headaches
    at my work*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides a different side-bar through which you can tune the physics engine
    parameters, change the settings for node and edge visualisation, and buttons through
    which you can export the graph as images.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plus it can display multiple edges between nodes (again, something `ipysigma`
    was incapable of doing).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, `gravis` removes the need to pick and choose between `pyvis` and
    `ipysigma` as it has morphed the two packages together into one, whilst maintaining
    all of their advantages.
  prefs: []
  type: TYPE_NORMAL
- en: In short, it ticks all the boxes and does its job well.
  prefs: []
  type: TYPE_NORMAL
- en: I highly recommend this package.
  prefs: []
  type: TYPE_NORMAL
- en: Let me know what you think of it in the comments section, and if you like my
    article please give a clap or share with anyone who might be interested.
  prefs: []
  type: TYPE_NORMAL
