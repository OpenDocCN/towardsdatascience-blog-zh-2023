- en: 'Python Tuple, The Whole Truth and Only the Truth: Let’s Dig Deep'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/python-tuple-the-whole-truth-and-only-truth-lets-dig-deep-24d2bf02971b](https://towardsdatascience.com/python-tuple-the-whole-truth-and-only-truth-lets-dig-deep-24d2bf02971b)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: PYTHON PROGRAMMING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Learn the intricacies of tuples.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@nyggus?source=post_page-----24d2bf02971b--------------------------------)[![Marcin
    Kozak](../Images/d7faf62e48ed81dab5d8ad92819fff54.png)](https://medium.com/@nyggus?source=post_page-----24d2bf02971b--------------------------------)[](https://towardsdatascience.com/?source=post_page-----24d2bf02971b--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----24d2bf02971b--------------------------------)
    [Marcin Kozak](https://medium.com/@nyggus?source=post_page-----24d2bf02971b--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----24d2bf02971b--------------------------------)
    ·24 min read·Jan 27, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e10e34210758fdd1c9b2276ce2c67e81.png)'
  prefs: []
  type: TYPE_IMG
- en: Tuples’ immutability can be confusing and headache-inducing. Photo by [Aarón
    Blanco Tejedor](https://unsplash.com/@innernature?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous article, we discussed the basics of tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/python-tuple-the-whole-truth-and-only-the-truth-hello-tuple-12a7ab9dbd0d?source=post_page-----24d2bf02971b--------------------------------)
    [## Python Tuple, the Whole Truth, and Only the Truth: Hello, Tuple!'
  prefs: []
  type: TYPE_NORMAL
- en: Learn the basics of tuples and of using them
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/python-tuple-the-whole-truth-and-only-the-truth-hello-tuple-12a7ab9dbd0d?source=post_page-----24d2bf02971b--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 'I showed you what a tuple is, what methods it offers, and most importantly,
    we discussed tuples immutability. But there is far more into tuples than that,
    and this articles offers continuation of the previous one. You will learn here
    the following aspects of the tuple type:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The intricacies of the tuple: the effect of immutability on copying tuples,
    and tuple type hinting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheriting from tuple.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tuple performance: execution time and memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The advantages of tuples over lists (?): clarity, performance, and tuples as
    dictionary keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuple comprehensions (?)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Named tuples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The intricacies of the tuple
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Likely the most important intricacy of the tuple is its immutability. But since
    it creates the essence of this type, even beginners should know how this immutability
    works and what it means in both theory and practice; thus, we’ve discussed it
    in the above-mentioned previous article. Here, we will discuss other important
    intricacies of tuples.
  prefs: []
  type: TYPE_NORMAL
- en: The effect of immutability on copying tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This will be fun!
  prefs: []
  type: TYPE_NORMAL
- en: 'A theorist would likely scream at me that there is only one immutability of
    tuples, the one we discussed in the previous article. Well, that’s true, but…
    but Python itself makes a distinction between two different types of immutability!
    And Python *must* make this distinction. This is because only a truly immutable
    object is hashable. In the below code, you will see that the first tuple is hashable
    but the second one is not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Whether or not an object is hashable affects various things — and this is why
    Python differentiates hashable and non-hashable tuples; the former are what I
    call truly immutable tuples. I will show you how Python treats both in how copying
    of tuples works, and in using tuples as dictionary keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s see how it works in tuple copying. For this. let us create a fully
    immutable tuple and copy it using all the available methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `a` is a fully immutable tuple, the original tuple (`a`) and all its
    copies should point to the very same object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As expected — and as should be the case for a truly immutable type — all these
    names point to the very same object; their `id`s are the same. This is what I
    call true or full immutability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s do the same with a tuple of the second type; that is, a tuple with
    one or more mutable elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The copies from `b` to `e` are shallow, so they will refer to the same object
    as the original name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is why we have deep copying. A deep copy should cover all the objects,
    including those nested inside. And since we have a mutable object inside the `a`
    tuple, then unlike before, the deep copy `f` this time will *not* point to the
    same object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The first element (at index `0`) of the tuple is `[1]`, so it’s mutable. When
    we created the shallow copies of `a`, the first elements of the tuples `a` to
    `e` pointed to the same list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'but creating a deep copy meant creating a new list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s see how these two types of immutability work differ in terms of using
    tuples as dictionary keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: So, if you want to use a tuple as a dictionary key, it must be hashable — so
    it must be truly immutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if anyone tells you that there is only one type of immutability of Python
    tuples, you will know that’s not entirely true — as there are two sorts of tuples
    in terms of immutability:'
  prefs: []
  type: TYPE_NORMAL
- en: fully immutable tuples, containing only immutable elements; this is immutability
    in terms of both references and values;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: immutable tuples in terms of references but not values, that is, tuples containing
    mutable element(s).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Failing to distinguish them would disable you to understand how copying of tuples
    works.
  prefs: []
  type: TYPE_NORMAL
- en: Tuple type hinting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Type hints have been becoming more and more important in Python. Some say that
    there’s no modern Python code without type hints. As I wrote what I think in another
    article, I will not repeat myself here. If you’re interested, feel invited to
    read it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://betterprogramming.pub/pythons-type-hinting-friend-foe-or-just-a-headache-73c7849039c7?source=post_page-----24d2bf02971b--------------------------------)
    [## Python’s Type Hinting: Friend, Foe, or Just a Headache?'
  prefs: []
  type: TYPE_NORMAL
- en: Type hinting’s popularity is increasing in the Python community. Where will
    this lead us? What can we do to use it…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: betterprogramming.pub](https://betterprogramming.pub/pythons-type-hinting-friend-foe-or-just-a-headache-73c7849039c7?source=post_page-----24d2bf02971b--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Here, let’s shortly discuss how to deal with type hints for tuples. I will show
    the modern version to type hinting tuples, meaning Python 3.11\. As type hinting
    has been dynamically changing, however, be aware that not everything worked the
    same way in older Python versions.
  prefs: []
  type: TYPE_NORMAL
- en: As of Python 3.9, things got simpler, as you can use built-in `tuple` type with
    fields indicated in square brackets `[]`. Below are several examples of what you
    can do.
  prefs: []
  type: TYPE_NORMAL
- en: '`tuple[int, ...]`, `tuple[str, ...]` and the like'
  prefs: []
  type: TYPE_NORMAL
- en: This means the object is a tuple of `int` / `str` / and the like elements, of
    any length. The ellipsis, `...`, informs that the tuple can have any length; there
    is no way to fix it.
  prefs: []
  type: TYPE_NORMAL
- en: '`tuple[int | float, ...]` Like above, but the tuple may contain both `int`
    and `float` items.'
  prefs: []
  type: TYPE_NORMAL
- en: '`tuple[int, int]` Unlike above, this tuple is a record of two items, both being
    integers.'
  prefs: []
  type: TYPE_NORMAL
- en: '`tuple[str, int|float]` Again, a record of two items, the first being a string
    and the second an integer or a floating-point number.'
  prefs: []
  type: TYPE_NORMAL
- en: '`tuple[str, str, tuple[int, float]]` A record with three items, the first two
    being strings and the third one being a two-element tuple of an integer and a
    floating-point number.'
  prefs: []
  type: TYPE_NORMAL
- en: '`tuple[Population, Area, Coordinates]`'
  prefs: []
  type: TYPE_NORMAL
- en: This is a specific record, one that contains three elements of specific types.
    These types, `Population`, `Area`, `Coordinates` are either named tuples or data
    types defined earlier, or type aliases. As I explained in the above-mentioned
    article, using such type aliases can be much more readable than using the built-in
    types such as `int`, `float`, and the like.
  prefs: []
  type: TYPE_NORMAL
- en: These were just several examples, but I hope they will help you see what you
    can do with type hinting for tuples. I have only mentioned *named tuples*, as
    I will discuss this type in another section below. Do remember, however, that
    named tuples are of much help also in the context of type hinting, as thanks to
    a named tuple you can get a custom type alias that is also a data container —
    a powerful combination.
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting from `tuple`
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can inherit from `list`, though sometimes it’s better to inherit from `collections.UserList`.
    So, maybe we can do the same with the tuple? Can we inherit from the `tuple` class?
  prefs: []
  type: TYPE_NORMAL
- en: Basically, forget the idea of creating a tuple-like general type. The `tuple`
    does not have its own `.__init__()` method, so you cannot do what you can when
    inheriting from the list, that is, you cannot call `super().__init__()`. And without
    that, you’re left with almost nothing as the `tuple` class inherits `object.__init__()`
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, this does not mean you cannot inherit from `tuple` at all. You
    can, but not to create a general type, but a specific one. Do you remember the
    `City` class? We can do something similar with a tuple — but be aware that this
    will be no fun.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a tuple-like `City` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This class takes *exactly* four arguments, not fewer and not more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in the current version, we can use argument names but do not have
    to, as they are positional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'But we cannot access the values by names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can change that in two ways. One is by using a named tuple from the `collections`
    or `typing` module; we will discuss them soon. But we can achieve the same effect
    using our `City` class, thank to the `operator` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And now we can access `lat` and `long` attributes by name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'However, since we did the above only for `lat` and `long`, we will not be able
    to access `population` and `area` by name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can of course change that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: I’ve never done anything like this, however. If you want to have such a functionality,
    you should definitely use a named tuple instead.
  prefs: []
  type: TYPE_NORMAL
- en: Tuple performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Execution time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To benchmark various operations using tuples and, for comparison, lists, I used
    the script presented in Appendix close to the end of the article. You will also
    find there the results of running the code. I present the code not only for the
    record, but to enable you to extend the experiment.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, the list was *always* faster, irrespective of its size and the operation
    being performed. I’ve often heard that one of the reasons behind creating tuples
    was their smaller memory consumption. Our little experiment is far from confirming
    this idea. While indeed sometimes tuples used a little less memory, usually they
    used a little more. Hence I conducted the experiment for really long lists and
    tuples, of 5 mln and 10 mln integer items. And again, lists usually consumed less
    memory…
  prefs: []
  type: TYPE_NORMAL
- en: 'So, where is this small memory consumption of tuples? Perhaps it’s related
    to how much disk space a tuple and the corresponding list take? Let’s check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Only in the case of small tuples and their corresponding lists, the difference
    in memory use is noticeable — like, for instance, `152` against `168`. But I think
    you’ll agree with me that `400_000_032` is not really that much smaller than `400_000_048`,
    won’t you?
  prefs: []
  type: TYPE_NORMAL
- en: There’s one more thing I observed in my past experiments (code not presented).
    Tuple literals are treated in an exceptional way by the Python compiler, as it
    keeps them in the static memory — so they are created at compile time. Neither
    lists nor tuples created in any other way can be kept in static memory — they
    always use dynamic memory, which means they are created at run time. This topic
    is complex enough to deserve a separate article, so let’s stop here.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll leave you here with these benchmarks. If you want to extend them, go ahead.
    If you learn something new and unexpected, please share this in the comments.
  prefs: []
  type: TYPE_NORMAL
- en: What I have learned is that tuples should almost never be used only because
    of their performance. But indeed, tuples can be an interesting choice if we need
    a simple type to store really small records, like consisting of two or three elements.
    If field names would help, however, and for more fields, I’d rather use something
    else, a named tuple being one of the choices and a `dataclasses.dataclass` another.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/af48b3b5aa071084f4966cb0336dd90b.png)'
  prefs: []
  type: TYPE_IMG
- en: A list and a tuple. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of tuples over lists (?)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In *Fluent Python*, L. Ramalho mentions two advantages of a tuple over a list:
    clarity and performance. Honestly, I cannot find any other advantage, but these
    two can be enough. So, let’s discuss them one by one and decide if they indeed
    make tuples better than lists, at least in some aspects.'
  prefs: []
  type: TYPE_NORMAL
- en: Clarity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As L. Ramalho writes, when you’re using a tuple, you know its length will never
    change — and this increases the clarity of code. We have already discussed what
    can happen with a tuple’s length. Indeed, clarity due to immutability is a great
    thing, and we do know that the length of any tuple will *never* change, but…
  prefs: []
  type: TYPE_NORMAL
- en: As L. Ramalho warns himself, a tuple with mutable items can be a source of bugs
    that are difficult to find. Do you remember what I mentioned above in relation
    to in-place operations? On the one hand, we may be sure that a tuple, say `x`,
    will never change its length. It’s a valuable piece of information in terms of
    clarity, I agree. However, when we perform in-place operation(s) on `x`, this
    tuple will *stop* being the same tuple, even though it will remain a tuple named
    `x` — but, let me repeat, a different tuple named `x`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, we should revise the above clarity advantage as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*We can be sure that a tuple of a particular* `id` *will never change its length*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '*We can be sure that if we define a tuple of a particular length, it will not
    change its length, but we should remember that if we use any in-place operation,
    then this tuple is not the same tuple we meant before*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sounds a little crazy? I fully agree: this is crazy. For me, this is no clarity;
    this is the opposite of clarity. Does anyone think that way? Imagine you have
    a function in which you define a tuple `x`. You then perform in-place concatenation,
    e.g., `x += y`, so it looks as though `y` remained untouched but `x` changed.
    We know it’s not true — as this original `x` does not exist anymore and we have
    a brand new `x` — but this is what it *looks like*, especially because we still
    have a tuple `x` whose first elements are the very same ones that constituted
    the original `x` tuple.'
  prefs: []
  type: TYPE_NORMAL
- en: Sure, I know all this makes sense from a Python point of view. But when I’m
    coding, I do not want my thoughts to be occupied that way. For code to be clear,
    I prefer it to be clear without the necessity of making such assumptions. And
    this is the very reason why for me tuples do not mean clarity; they mean less
    clarity than I see in lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not all in the context of the tuple’s clarity. In terms of code, there
    is one thing I particularly like in lists but do not like in tuples. Square brackets
    `[]` used to create lists allow them to stand out in the code, as there is no
    other container that would use square brackets. Look at dictionaries: they use
    curly brackets `{}`, and these can be used by sets, too. Tuples use round parentheses
    `()`, and these are used not only in generator expressions but in many various
    places in code, as Python code uses round parentheses for many different purposes.
    Therefore, I like how lists stand out in code — and I don’t like how tuples do
    *not*.'
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: L. Ramalho, writes that a tuple uses less memory than the corresponding list,
    and Python can do the same optimizations for both. We have already analyzed memory
    performance as we know that it’s not always the case — and that the disk memory
    a tuple uses is indeed smaller than that the corresponding list uses, but the
    difference can be negligible.
  prefs: []
  type: TYPE_NORMAL
- en: This knowledge, combined with the better performance of lists in terms of execution
    time, makes me think that performance does *not* make tuples a better choice.
    In terms of performance in terms of execution time, lists are better. In terms
    of memory usage, tuples can be better indeed — but these days, with the modern
    computers, differences are really small. Besides, when I need a truly memory-efficient
    container to collect a lot of data, I’d choose neither list nor tuple — but a
    generator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing: tuples as dictionary keys'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to these two aspects, there is a third one that’s worth consideration,
    one we have already mentioned — you cannot use lists as keys in dictionaries,
    but you can use tuples. Or rather, you can use truly immutable (that is, hashable)
    tuples. The reason is the former’s mutability and the latter’s immutability.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the previous two, this advantage can be significant in particular situations,
    even if rather rare ones.
  prefs: []
  type: TYPE_NORMAL
- en: Tuple comprehensions (?)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you hope to learn from this section that there are tuple comprehensions in
    Python, or if you hope to learn something amazing that will blew minds of your
    fellow Pythonistas — I am so sorry! I did not want to create false hopes. No tuple
    comprehensions today; no mind-blowing syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may remember that in my article on Python comprehensions, I did not mention
    tuple comprehensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/a-guide-to-python-comprehensions-4d16af68c97e?source=post_page-----24d2bf02971b--------------------------------)
    [## A Guide to Python Comprehensions'
  prefs: []
  type: TYPE_NORMAL
- en: Learn the intricacies of list comprehensions (listcomps), set comprehensions
    (setcomps), dictionary comprehensions…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/a-guide-to-python-comprehensions-4d16af68c97e?source=post_page-----24d2bf02971b--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: This is because there are no tuple comprehensions. But as I do not want to leave
    you with nothing, I do have a consolation gift for you. I’ll show you some substitutes
    for tuple comprehensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, do remember that a generator expression is *not* a tuple comprehension.
    I think many Python beginners make a mistake of confusing the two. I specifically
    remember seeing my first generator expression after learning list comprehensions.
    My first thought was, “Yup, here it is. A tuple comprehension.” I quickly learned
    that while the first from these two was indeed a list comprehension, the second
    was *not* a tuple comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: I spent some time — if not *wasted* it — only to learn that there are list comprehensions,
    and set comprehensions, and dict comprehensions, and generator expressions — but
    no tuple comprehensions. Don’t repeat my mistake. Don’t spend hours on looking
    for tuple comprehensions. They don’t exist in Python.
  prefs: []
  type: TYPE_NORMAL
- en: But here it is, my consolation gift for you — two substitutes for tuple comprehensions.
  prefs: []
  type: TYPE_NORMAL
- en: '*Substitute 1*: `tuple()` + `genexp`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Have you noticed that you do not need to create a list comprehension first and
    the tuple then? Indeed, here we create a generator expression and use the `tuple()`
    class to it. This, of course, gives us a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: '*Substitute 2*: `genexp` + generator unpacking'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'A nice hack, isn’t it? It uses [the extended unpacking of iterables](https://peps.python.org/pep-3132/),
    which returns a tuple. You can use it for any iterable, and since a generator
    is one, it works! Let’s check if it works also for a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can do the same without assigning to `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'It will work for any iterable — but don’t forget the comma at the line end;
    without it, the trick will not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s check for sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'It works! And note that generally, unpacking provides a tuple. This is why
    the extended iterable unpacking looks a little bit like a tuple comprehension.
    Although it does look like a nice little hack, it’s not: it’s one of the tools
    that Python offers, although it’s an edge case indeed.'
  prefs: []
  type: TYPE_NORMAL
- en: But I would *not* use *substitute 2*. I’d definitely go for *substitute 1*,
    which uses `tuple()`. Most of us love tricks like the second substitute, but they
    are seldom clear — and *substitute 2*, unlike *substitute 1*, is far from being
    clear. Nevertheless, any Pythonista will see what’s going on in *substitute 1*,
    even if they do not see that there’s a generator expression hidden in an in-between
    step.
  prefs: []
  type: TYPE_NORMAL
- en: Named tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tuples are unnamed — but this does not mean there are no named tuples in Python.
    On the contrary, there are — and, unsurprisingly, they are called…named tuples.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have two possibilities to use named tuples: `collections.namedtuple` and
    `typing.NamedTuple`. Named tuples are what their named suggest: tuples whose elements
    (called fields) have names. You can see the former in action in Appendix, in the
    benchmarking script.'
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I consider them extremely helpful in many various situations. They
    do not offer any improvement in performance; they can even decrease it. But when
    it comes to clarity, they can be much clearer, both to the developer and to the
    code’s user.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, although I often go for a regular tuple, sometimes I decide to choose
    a named tuple — and this is exactly because of its clarity.
  prefs: []
  type: TYPE_NORMAL
- en: Named tuples offer so rich possibilities that they deserve their own article.
    Therefore, that’s all I’m going to tell you about them here — but I plan to write
    an article dedicated to this powerful type.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3d0766b50bbdc25cfa5ecbb9dde984d7.png)'
  prefs: []
  type: TYPE_IMG
- en: Word “tuple” in various languages. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This article, along with [the previous one](/python-tuple-the-whole-truth-and-only-the-truth-hello-tuple-12a7ab9dbd0d),
    aimed to provide you with deep information about tuples, their use cases, pros
    and cons, and intricacies. Although tuples are used quite often, they are not
    that well known among developers, particularly those with shorter experience in
    Python development. That’s why I wanted to collect rich information about this
    interesting type in one place — and I hope you’ve learned something from reading
    it, maybe even as much as I learned myself from writing it.
  prefs: []
  type: TYPE_NORMAL
- en: To be honest, when starting to write about tuples, I thought that I’d find more
    advantages of them. I’ve been using them from the first day I started using Python.
    Although I used lists far more often, I somehow liked tuples, even though I did
    not know too much about them — so some of the information I included in this article
    was new to me.
  prefs: []
  type: TYPE_NORMAL
- en: After writing this article, however, I am not that great a fan of tuples anymore.
    I still consider them a valuable type for small records, though quite often their
    extension — named tuples — or data classes seem a better approach. What’s more,
    tuples do not seem to be too effective. They are slower than lists, and use only
    a little less memory. So, why should I use them?
  prefs: []
  type: TYPE_NORMAL
- en: Maybe because of their immutability? Maybe. If you like functional programming,
    which is based upon the concept of immutability, you will definitely prefer tuples
    over lists. I used this argument not once and not twice to convince myself that
    I should prefer a tuple over a list in this or another situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'But the immutability that the tuple offers is, as we discussed, not that *clear.*
    Imagine `x`, a tuple of items of immutable types. We know this tuple is trule
    immutable, right? If so, I do not like the following code, which is fully correct
    in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'I know this is correct Python, and I know this is even Pythonic code — but
    I don’t like it. I don’t like that I can do something like this with Python tuples.
    It just does not have the vibe of the tuple’s immutability. The way I see it,
    if you have an immutable type, you should be able to copy it, you should be able
    to concatenate two instances, and the like — but you *should* *not* be able to
    assign a new tuple to an old name using an in-place operation. You want this name
    to be the same? Your choice. So, I am fine with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: as it means assigning `x + y` to `x`, which basically means overwriting this
    name. If you choose to overwrite the previous value of `x`, it’s your choice.
    But in-place operations, at least in my eyes, do not have the feeling of immutability.
    I’d prefer to *not* be able to do this in Python.
  prefs: []
  type: TYPE_NORMAL
- en: If not immutability, then maybe something else should convince me to use tuples
    more often? But what? Performance? Tuples’ performance is poor, so this does not
    convince me. In terms of execution time, there is no discussion; they are definitely
    slower than the corresponding lists. You may say that in terms of memory. Indeed,
    they do take less disk space, but the difference is subtle, and for long containers
    — totally negligible. RAM memory use? This argument also turned out to not be
    too successful, because generally, lists turned out to be as efficient as tuples
    — and sometimes even more efficient. And if we have a huge collection, a generator
    will do better in terms of memory.
  prefs: []
  type: TYPE_NORMAL
- en: Despite all that, tuples do have their place in Python. They are very frequently
    used to return two or three items from a function or method — so, as small unnamed
    records. They are used as the output of iterable unpacking. And they constitute
    the base of named tuples — `collections.namedtuple` and `typing.NamedTuple` —
    the tuple’s powerful siblings that can be used as records with named fields.
  prefs: []
  type: TYPE_NORMAL
- en: All in all, I do not like tuples as much as I did before writing this article.
    I treated them as an important Python type; now it’s not as important in my eyes
    as it was — but I accept their various use cases in Python, and I even like some
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: Am I unfair for tuples? Maybe. If you think so, please let me know in the comments.
    I always enjoy fruitful discussions with my readers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thank you for reading. If you enjoyed this article, you may also enjoy other
    articles I wrote; you will see them [here](https://medium.com/@nyggus). If you
    want to join Medium, please use my referral link below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/@nyggus/membership?source=post_page-----24d2bf02971b--------------------------------)
    [## Join Medium with my referral link — Marcin Kozak'
  prefs: []
  type: TYPE_NORMAL
- en: Read every story from Marcin Kozak (and thousands of other writers on Medium).
    Your membership fee directly supports…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/@nyggus/membership?source=post_page-----24d2bf02971b--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[](/a-guide-to-python-comprehensions-4d16af68c97e?source=post_page-----24d2bf02971b--------------------------------)
    [## A Guide to Python Comprehensions'
  prefs: []
  type: TYPE_NORMAL
- en: Learn the intricacies of list comprehensions (listcomps), set comprehensions
    (setcomps), dictionary comprehensions…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/a-guide-to-python-comprehensions-4d16af68c97e?source=post_page-----24d2bf02971b--------------------------------)  [##
    PEP 3132 — Extended Iterable Unpacking
  prefs: []
  type: TYPE_NORMAL
- en: This PEP proposes a change to iterable unpacking syntax, allowing to specify
    a “catch-all” name which will be assigned…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: peps.python.org](https://peps.python.org/pep-3132/?source=post_page-----24d2bf02971b--------------------------------)
    [](https://www.oreilly.com/library/view/fluent-python-2nd/9781492056348/?source=post_page-----24d2bf02971b--------------------------------)
    [## Fluent Python, 2nd Edition
  prefs: []
  type: TYPE_NORMAL
- en: Python's simplicity lets you become productive quickly, but often this means
    you aren't using everything it has to…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: www.oreilly.com](https://www.oreilly.com/library/view/fluent-python-2nd/9781492056348/?source=post_page-----24d2bf02971b--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Appendix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this Appendix, you will find the script I used for benchmarking tuples against
    lists. I used the `perftester` package, about which you can read in this article:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/benchmarking-python-functions-the-easy-way-perftester-77f75596bc81?source=post_page-----24d2bf02971b--------------------------------)
    [## Benchmarking Python Functions the Easy Way: perftester'
  prefs: []
  type: TYPE_NORMAL
- en: You can use perftester to benchmark Python functions the easy way
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/benchmarking-python-functions-the-easy-way-perftester-77f75596bc81?source=post_page-----24d2bf02971b--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'And here are the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: I decided to run memory-usage benchmarks for much bigger `n`, that is, of 5
    and 10 million. I will not present the code here, and if you have some time to
    spare, you may consider it a nice exercise to write it, based on the above script.
  prefs: []
  type: TYPE_NORMAL
- en: If you just want to see the code, however, you will find it [here](https://gist.github.com/nyggus/3dc967d5e88593b624e2acb3e675a62d).
    Note that I could make the code better, as I could join the code for the two experiments.
    I decided not to do that, in order to keep the two scripts rather simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you see, for the operations we study, tuples take either the same or more
    memory — sometimes even significantly more (compare, for instance, `554.8` vs
    `478.5` or `783.7` vs `707.4`).
  prefs: []
  type: TYPE_NORMAL
