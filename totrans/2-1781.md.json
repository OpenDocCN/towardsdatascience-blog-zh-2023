["```py\nimport tifffile as tiff\nimport numpy as np\n\ndef get_RGB(ID):\n\n    # Load Blue (B2), Green (B3) and Red (B4) bands\n    B2 = tiff.imread('./data/{}/{}_SR_B2.TIF'.format(ID, ID))\n    B3 = tiff.imread('./data/{}/{}_SR_B3.TIF'.format(ID, ID))\n    B4 = tiff.imread('./data/{}/{}_SR_B4.TIF'.format(ID, ID))\n\n    # Stack and scale bands\n    RGB = np.dstack((B4, B3, B2))\n    RGB = np.clip(RGB*0.0000275-0.2, 0, 1)\n\n    # Clip to enhance contrast\n    RGB = np.clip(RGB,0,0.3)/0.3\n\n    return RGB\n```", "```py\nimport matplotlib.pyplot as plt\n\nID = 'LC09_L2SP_175083_20230410_20230412_02_T1'\nRGB = get_RGB(ID)\n\n# Plot the RGB image\nfig, ax = plt.subplots(figsize=(20, 10))\nax.imshow(RGB)\n```", "```py\ndef get_mask(val,type='cloud'):\n\n    \"\"\"Get mask for a specific cover type\"\"\"\n\n    # convert to binary\n    bin_ = '{0:016b}'.format(val)\n\n    # reverse string\n    str_bin = str(bin_)[::-1]\n\n    # get bit for cover type\n    bits = {'cloud':3,'shadow':4,'dilated_cloud':1,'cirrus':2}\n    bit = str_bin[bits[type]]\n\n    if bit == '1':\n        return 0 # cover\n    else:\n        return 1 # no cover\n```", "```py\n# QA band\nQA = tiff.imread('./data/{}/{}_QA_PIXEL.TIF'.format(ID, ID))\nQA = np.array(QA)\n\n# Get masks\ncloud_mask = np.vectorize(get_mask)(QA,type='cloud')\nshadow_mask = np.vectorize(get_mask)(QA,type='shadow')\ndilated_cloud_mask = np.vectorize(get_mask)(QA,type='dilated_cloud')\ncirrus_mask = np.vectorize(get_mask)(QA,type='cirrus')\n```", "```py\nimport cv2\nimport matplotlib as mpl\n\n# segmentation image\nseg = RGB.copy()\n\n# color for each cover type\ncolors = np.array([[247, 2, 7],\n                    [201, 116, 247],\n                    [0, 234, 255],\n                    [3, 252, 53]])/255\n\nmasks = [cloud_mask, shadow_mask, dilated_cloud_mask, cirrus_mask]\n\nfor i,mask in enumerate(masks):\n\n    # color for cover type\n    temp = seg.copy()\n    temp[mask == 0] = colors[i]\n\n    # add to segmentation\n    seg = cv2.addWeighted(seg, 0.5, temp, 0.5, 0)\n\nfig, ax = plt.subplots(1,2,figsize=(20, 10))\n\nax[0].imshow(seg)\n\n# add legend with colors for each cover type\nlegend_elements = [mpl.patches.Patch(facecolor=colors[0], label='Cloud'),\n                     mpl.patches.Patch(facecolor=colors[1], label='Shadow'),\n                        mpl.patches.Patch(facecolor=colors[2], label='Dilated Cloud'),\n                        mpl.patches.Patch(facecolor=colors[3], label='Cirrus')]\n\nax[0].legend(handles=legend_elements, loc='upper right')\n\n# draw white rectangle around area of interest\nh = 300\nx,y = 4500,4500\nrect = mpl.patches.Rectangle((x-h,y-h),h*2,h*2,linewidth=2,edgecolor='w',facecolor='none')\nax[0].add_patch(rect)\n\n# crop area of interest\ncrop_seg =  seg[y-h:y+h,x-h:x+h,:]\n\nax[1].imshow(crop_seg)\n\nax[0].set_axis_off()\nax[1].set_axis_off()\n```", "```py\n# crop area of interest\ncloud_aoi = cloud_mask[y-h:y+h,x-h:x+h]\n\n# calculate percentage of cloud cover\nper_cloud = np.average(1-cloud_aoi)*100\nprint('Percentage of clouds: {:.2f}%'.format(per_cloud))\n```", "```py\n# Remove clouds\nrm_clouds = RGB*cloud_mask[:, :, np.newaxis]\n```", "```py\ndef cloud_pred(B1,B4,B7):\n    \"\"\"Cloud prediction model\"\"\"\n\n    pred = 2.16246741593412 -0.796409165054949*B4 + \\\n    0.971776520302587*np.sqrt(abs(0.028702220187686*B7*B1 + \\\n    0.971297779812314*np.sin(B1))) + \\\n    0.0235599298084993*np.floor(0.995223926146334*np.sqrt(abs(0.028702220187686*B7*B1 + 0.971297779812314*np.sin(B1)))+ \\\n    0.00477607385366598*abs(0.028702220187686*B7*B1 + \\\n    0.971297779812314*np.sin(B1))) - 0.180030905136552*np.cos(B4) + \\\n    0.0046635498889134*abs(0.028702220187686*B7*B1 + 0.971297779812314*np.sin(B1))\n\n    cloud = np.where(pred > B7,0,1)\n\n    return cloud\n```", "```py\nID = \"LC09_L2SP_175083_20230410_20230412_02_T1\"\n\n# Get Coastal Aerosol (B1), Red (B4) and Shortwave Infrared 2 (B7) bands\nB1 = tiff.imread('./data/{}/{}_SR_B1.TIF'.format(ID, ID))\nB4 = tiff.imread('./data/{}/{}_SR_B4.TIF'.format(ID, ID))\nB7 = tiff.imread('./data/{}/{}_SR_B7.TIF'.format(ID, ID))\n\n# Get cloud mask\ncloud_mask_2 = cloud_pred(B1,B4,B7)\n\n# Remove clouds\nrm_clouds = RGB*cloud_mask_2[:, :, np.newaxis]\n```", "```py\n# IDs for cloudy and non-cloudy images\nIDs = ['LC09_L2SP_175083_20230410_20230412_02_T1',\n       'LC08_L2SP_175083_20230418_20230429_02_T1']\n\n# Get RGB\ncloudy = get_RGB(IDs[0])\nclear = get_RGB(IDs[1])\n```", "```py\n# get mask for cloudy image\nmask = cloud_mask*shadow_mask*dilated_cloud_mask*cirrus_mask\n\n# remove cloudy pixels and fill with adjusted clear pixels\nrm_mask = cloudy*mask[:, :, np.newaxis]\n\n#crop area of interest\nx,y,h = 4500,4500,300\ncrop_rm_mask = rm_mask[y-h:y+h,x-h:x+h]\n```", "```py\nimport rasterio as rio\n\n# Open red band with rasterio for geolocation\ngeo_cloudy = rio.open('./data/{}/{}_SR_B4.TIF'.format(IDs[0], IDs[0]))\ngeo_clear = rio.open('./data/{}/{}_SR_B4.TIF'.format(IDs[1], IDs[1]))\n```", "```py\n# get UTM coordinates from cloudy image\nutmx, utmy = geo_cloudy.xy(y,x)\n\n# get pixels from clear image\ny_,x_ = geo_clear.index(utmx, utmy)\nprint(x_,y_)\n```", "```py\n# crop clear image \ncrop_clear = clear[y_-h:y_+h,x_-h:x_+h]\n\n#get fill from clear image\ncrop_mask = mask[y-h:y+h,x-h:x+h]\nfill = crop_clear*(1-crop_mask[:, :, np.newaxis])\n\n#inpaint area of interest \ninpaint = crop_rm_mask + fill\n```", "```py\n# get pixel coordinates of clear image corners\ny,x = geo_clear.read(1).shape\nclear_ul = (0,0) # upper left\nclear_lr = (y,x) # lower right\n```", "```py\n# get pixel coordinates of cloudy image corners\ncloudy_bounds = geo_cloudy.bounds\nnew_clear_ul = geo_clear.index(cloudy_bounds.left,cloudy_bounds.top)\nnew_clear_lr = geo_clear.index(cloudy_bounds.right,cloudy_bounds.bottom)\n```", "```py\n# calculate pixel adjustment \ntop_adj = clear_ul[0] - new_clear_ul[0]\nbottom_adj = new_clear_lr[0] - clear_lr[0]\n\nleft_adj = clear_ul[1] -  new_clear_ul[1]\nright_adj = new_clear_lr[1] - clear_lr[1]\n\nprint(top_adj, bottom_adj, left_adj, right_adj)\n```", "```py\ndef adjust_rgb(rgb,top_adj, bottom_adj, left_adj, right_adj):\n\n    adj_rgb = rgb.copy()\n\n    #Adding black pixels \n    if top_adj > 0:\n        add_top = np.zeros((top_adj,rgb.shape[1],3))\n        adj_rgb = np.vstack((add_top,adj_rgb))\n    if bottom_adj > 0:\n        add_bottom = np.zeros((bottom_adj,rgb.shape[1],3))\n        adj_rgb = np.vstack((adj_rgb,add_bottom))\n    if left_adj > 0:\n        add_left = np.zeros((rgb.shape[0],left_adj,3))\n        adj_rgb = np.hstack((add_left,adj_rgb))\n    if right_adj > 0:\n        add_right = np.zeros((rgb.shape[0],right_adj,3))\n        adj_rgb = np.hstack((adj_rgb,add_right))\n\n    #Removing pixels\n    if top_adj < 0:\n        adj_rgb = adj_rgb[-top_adj:,:,:]\n    if bottom_adj < 0:\n        adj_rgb = adj_rgb[:bottom_adj,:,:]\n    if left_adj < 0:\n        adj_rgb = adj_rgb[:,-left_adj:,:]\n    if right_adj < 0:\n        adj_rgb = adj_rgb[:,:right_adj,:]\n\n    return adj_rgb\n```", "```py\n# Get RGB images\ncloudy_RGB = get_RGB(IDs[0])\nclear_RGB = get_RGB(IDs[1])\n\n# Adjust clear RGB image\nclear_RGB_adj = adjust_rgb(clear_RGB,top_adj, bottom_adj, left_adj, right_adj)\n\n# get mask for cloudy image\nmask = cloud_mask*shadow_mask*dilated_cloud_mask*cirrus_mask\n\n# remove cloudy pixels and fill with adjusted clear pixels\nrm_mask = cloudy_RGB*mask[:, :, np.newaxis]\nfill_mask = clear_RGB_adj*(1-mask[:, :, np.newaxis])\ninpaint = rm_mask+fill_mask\n```"]