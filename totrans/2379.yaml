- en: Why Taskgroup and Timeout Are so Crucial in Python 3.11 Asyncio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/why-taskgroup-and-timeout-are-so-crucial-in-python-3-11-asyncio-c424bcc88b89](https://towardsdatascience.com/why-taskgroup-and-timeout-are-so-crucial-in-python-3-11-asyncio-c424bcc88b89)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PYTHON CONCURRENCY](https://medium.com/@qtalen/list/python-concurrency-2c979347da3b)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Embracing Structured Concurrency in Python 3.11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://qtalen.medium.com/?source=post_page-----c424bcc88b89--------------------------------)[![Peng
    Qian](../Images/9ce9aeb381ec6b017c1ee5d4714937e2.png)](https://qtalen.medium.com/?source=post_page-----c424bcc88b89--------------------------------)[](https://towardsdatascience.com/?source=post_page-----c424bcc88b89--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----c424bcc88b89--------------------------------)
    [Peng Qian](https://qtalen.medium.com/?source=post_page-----c424bcc88b89--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----c424bcc88b89--------------------------------)
    ·6 min read·Apr 12, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d2c98fe735728660298181954df9a9cc.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Brett Jordan](https://unsplash.com/@brett_jordan?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: '**New features of the Python 3.11 asyncio package**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**1\. Introduction**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In last year’s Python 3.11 release, the asyncio package added the`TaskGroup`
    and `timeout`APIs. These two APIs introduced the official Structured Concurrency
    feature to help us better manage the life cycle of concurrent tasks. Today, I’ll
    introduce you to using these two APIs and the significant improvements Python
    has brought to our concurrent programming with the introduction of Structured
    Concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: '**2\. TaskGroup**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`TaskGroup` is created using an asynchronous context manager, and concurrent
    tasks can be added to the group by the method `create_task`, with the following
    code example:'
  prefs: []
  type: TYPE_NORMAL
- en: When the context manager exits, it waits for all tasks in the group to complete.
    While waiting, we can still add new tasks to `TaskGroup`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that assuming that a task in the group throws an exception other than `asyncio.CancelledError`
    while waiting, all other tasks in the group will be canceled.
  prefs: []
  type: TYPE_NORMAL
- en: Also, all exceptions were thrown except for `asyncio.CanceledError` will be
    combined and thrown in the `ExceptionGroup`.
  prefs: []
  type: TYPE_NORMAL
- en: '**3\. timeout**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`asyncio.timeout` is also created using the asynchronous context manager. It
    limits the execution time of concurrent code in a context.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume that if we need to set a timeout to a single function call, it
    is sufficient to call `asyncio.wait_for`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'But when it is necessary to set a uniform timeout for multiple concurrent calls,
    things will become problematic. Let’s assume we have two concurrent tasks and
    want them to run to completion in 8 seconds. Let’s try to assign an average timeout
    of 4 seconds to each task, with code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that although we set an average timeout for each concurrent method,
    such a setting may cause uncontrollable situations since each call to the IO-bound
    task is not guaranteed to return simultaneously, and we still got a `TimeoutError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we use the `asyncio.timeout` block to ensure that we set an
    overall timeout for all concurrent tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**4\. What is Structured Concurrency**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`TaskGroup` and `asyncio.timeout` above uses the `async with` feature. Just
    like `with` struct block can manage the life cycle of resources uniformly like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'But calling concurrent tasks inside `with` block does not work because the
    concurrent task will continue executing in the background while the `with` block
    has already exited, which will lead to improper closure of the resource:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we introduced the `async with` feature here. As *with*, *async with*
    and `TaskGroup` Is used to manage the life cycle of concurrent code uniformly,
    thus making the code clear and saving development time. We call this feature our
    main character today: [**Structured Concurrency**](https://en.wikipedia.org/wiki/Structured_concurrency).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Why Structured Concurrency is so important**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**1\. History of concurrent programming**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before the advent of concurrent programming, we executed our code serially.
    Code would perform for_loop loops, if_else conditional branches, and function
    calls sequentially, depending on the order in the call stack.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1871340581c375c70538ef047d70da77.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: However, as the speed of code execution became more and more demanding in terms
    of computational efficiency and as computer hardware developed significantly,
    parallel programming (CPU bound) and concurrent programming (IO bound) gradually
    emerged.
  prefs: []
  type: TYPE_NORMAL
- en: Before coroutine emerged, Python programmers used threading to implement concurrent
    programming. But Python’s threads have a problem, that is, [GIL (Global Interpreter
    Lock)](/python-gil-e63f18a08c65), the existence of GIL makes the thread-based
    Concurrency unable to achieve the desired performance.
  prefs: []
  type: TYPE_NORMAL
- en: So asyncio coroutine emerged. Without GIL and inter-thread switching, concurrent
    execution is much more efficient. If threads are time-slice-based task switching
    controlled by the CPU, then coroutine is the creation and switching of subtasks
    back into the hands of the programmer himself. While programmers enjoy convenience,
    they also encounter a new set of problems.
  prefs: []
  type: TYPE_NORMAL
- en: '**2\. Problems with the Concurrent Programming Model**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As detailed in [this article](https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/),
    concurrent programming raises several issues regarding control flow.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent programming is opening up multiple branch processes in our main thread.
    These branch tasks silently perform network requests, file accesses, database
    queries, and other duties in the background.
  prefs: []
  type: TYPE_NORMAL
- en: 'Concurrent programming will change the flow of our code from this to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d66c37d510f68fee01260c977cc09fc5.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the “low coupling, high cohesion” rule of programming, we all
    want to join all the background tasks in a module together after execution like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/425650679fc46f1854b7b3df3d86ff8f.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: But the fact is that since multiple members develop our application or call
    numerous third-party components, we need to know which tasks are still executing
    in the background and which tasks are finished. It’s more likely that one background
    task will branch into several other branch tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ultimately, these branching tasks need to be found by the caller and wait for
    their execution to complete, so it becomes like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/29a36d0bbb40296e8665cdd65afd5521.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Although this is not [Marvel’s multiverse](https://en.wikipedia.org/wiki/Multiverse_(Marvel_Comics)),
    the situation is now just like the multiverse, bringing absolute chaos to our
    natural world.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some readers say that `asyncio.gather` could be responsible for joining all
    the background tasks. But `asyncio.gather` it has its problems:'
  prefs: []
  type: TYPE_NORMAL
- en: It cannot centrally manage backend tasks in a unified way. Often creating backend
    tasks in one place and calling `asyncio.gather` in another.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The argument `aws` received by `asyncio.gather` is a fixed list, which means
    that we have set the number of background tasks when `asyncio.gather` is called,
    and they cannot be added randomly on the way to waiting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a task is waiting in `asyncio.gather` throws an exception, it cannot cancel
    other tasks that are executing, which may cause some tasks to run indefinitely
    in the background and the program to die falsely.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, the Structured Concurrency feature introduced in Python 3.11 is an
    excellent solution to our concurrency problems. It allows the related asynchronous
    code to all finish executing in the same place, and at the same time, it will
    enable `tg` instances to be passed as arguments to background tasks, so that new
    background tasks created in the background tasks will not jump out of the current
    life cycle management of the asynchronous context.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, Structured Concurrency is a revolutionary improvement to Python asyncio.
  prefs: []
  type: TYPE_NORMAL
- en: '**Comparison with other libraries that implement Structured Concurrency**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Structured Concurrency is not the first of its kind in Python 3.11; we had several
    concurrency-based packages that implemented this feature nicely before 3.11.
  prefs: []
  type: TYPE_NORMAL
- en: '**1\. Nurseries in Trio**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Trio](https://trio.readthedocs.io/en/stable/) was the first library to propose
    Structure Concurrency in the Python world, and in Trio, the API `open_nursery`
    is used to achieve the goal:'
  prefs: []
  type: TYPE_NORMAL
- en: '**2\.** `**create_task_group**` **in Anyio**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: But with the advent of the official Python asyncio package, more and more third-party
    packages are using asyncio to implement concurrent programming. At this point,
    using Trio will inevitably run into compatibility problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, [Anyio](https://anyio.readthedocs.io/en/stable/index.html),
    which claims to be compatible with both asyncio and Trio, emerged. It can also
    implement Structured Concurrency through the `create_task_group` API:'
  prefs: []
  type: TYPE_NORMAL
- en: '**3\. Using quattro in low Python versions**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to keep your code native to Python to easily enjoy the convenience
    of Python 3.11 asyncio in the future, there is a good alternative, [quattro](https://github.com/Tinche/quattro),
    which has fewer stars and is risk-averse.
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The TaskGroup and timeout APIs introduced in Python 3.11 bring us the official
    Structured Concurrency feature.
  prefs: []
  type: TYPE_NORMAL
- en: With Structured Concurrency, we can make concurrent programming code better
    abstracted, and programmers can more easily control the life cycle of background
    tasks, thus improving programming efficiency and avoiding errors.
  prefs: []
  type: TYPE_NORMAL
- en: Because of limited experience, if there are any omissions in this article about
    concurrent programming or Structured Concurrency, or if you have better suggestions,
    please comment. I will be grateful to answer you.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next article, we will discuss best practices for concurrent programming
    in asyncio using different APIs. You can read it here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/use-these-methods-to-make-your-python-concurrent-tasks-perform-better-b693b7a633e1?source=post_page-----c424bcc88b89--------------------------------)
    [## Use These Methods to Make Your Python Concurrent Tasks Perform Better'
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for asyncio.gather, asyncio.as_completed, and asyncio.wait
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/use-these-methods-to-make-your-python-concurrent-tasks-perform-better-b693b7a633e1?source=post_page-----c424bcc88b89--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: By [joining Medium](https://medium.com/@qtalen/membership), you’ll have unlimited
    access to all of my posts and those of thousands of other authors. It only costs
    you the price of a cup of coffee, but it’s a great encouragement to me.
  prefs: []
  type: TYPE_NORMAL
- en: 'This article was originally published on: [https://www.dataleadsfuture.com/why-taskgroup-and-timeout-are-so-crucial-in-python-3-11-asyncio/](https://www.dataleadsfuture.com/why-taskgroup-and-timeout-are-so-crucial-in-python-3-11-asyncio/)'
  prefs: []
  type: TYPE_NORMAL
