- en: Introduction to Data Manipulation in R with {dplyr}
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/introduction-to-data-manipulation-in-r-with-dplyr-ae13383af3d7](https://towardsdatascience.com/introduction-to-data-manipulation-in-r-with-dplyr-ae13383af3d7)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Learn to use the {dplyr} package in R which helps you to solve the most common
    data manipulation challenges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://antoinesoetewey.medium.com/?source=post_page-----ae13383af3d7--------------------------------)[![Antoine
    Soetewey](../Images/51d7837d18ff15a62cac2343a485e35d.png)](https://antoinesoetewey.medium.com/?source=post_page-----ae13383af3d7--------------------------------)[](https://towardsdatascience.com/?source=post_page-----ae13383af3d7--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----ae13383af3d7--------------------------------)
    [Antoine Soetewey](https://antoinesoetewey.medium.com/?source=post_page-----ae13383af3d7--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----ae13383af3d7--------------------------------)
    ·27 min read·Nov 27, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/34f6144f88eb797315f364b70afbc1de.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Claudio Schwarz](https://unsplash.com/@purzlbaum?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a previous post, we showed how to [manipulate data in R](https://statsandr.com/blog/data-manipulation-in-r/).
    In particular, we illustrated how to create and manipulate vectors, factors, lists
    and data frames. This served as an introduction to R and was aimed at beginners.
    Moreover, as long as it was possible, all manipulations were made in base R, that
    is, without having to load any package.
  prefs: []
  type: TYPE_NORMAL
- en: In this post, we would like to show again how to manipulate data in R, but this
    time using the `{dplyr}` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `{dplyr}` package, developed by Hadley Wickham and colleagues at posit,
    provides a complete set of functions that help you solve the most common data
    manipulation challenges such as:'
  prefs: []
  type: TYPE_NORMAL
- en: filtering observations based on their values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: extracting observations based on their values or positions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: sampling observations based on a specific number or fraction of rows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: sorting observations based on one or several variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: selecting variables based on their names or positions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: renaming variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: adding new variables based on existing ones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: summarizing observations or variables to a single descriptive measure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: performing any operation by group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: categorizing observations into two or more groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about the package can be found at [dplyr.tidyverse.org](https://dplyr.tidyverse.org/).
  prefs: []
  type: TYPE_NORMAL
- en: In this post, we will present the most common functions for data manipulation
    and data management using the `{dplyr}` package (illustrated on a data frame).
    This is however not an exhaustive list! It is likely that you will need other
    functions that the ones presented here. For the interested readers, see the end
    of this post for further resources.
  prefs: []
  type: TYPE_NORMAL
- en: A question I am often asked is whether it is best to first learn data manipulation
    with base R and *then* with `{dplyr}`, or directly learn `{dplyr}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Everyone may not agree, but here is what I tend to answer. The interest in
    terms of efficiency and clarity/readability of the code that `{dplyr}` brings
    is obvious. So even when I give a [training](https://datanalyze.be/trainings/)
    targeted to statisticians, I present the `{dplyr}` package. However, I still do
    believe that learning data manipulation with base R is important for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Everyone will, at some point, be confronted with code written in base R (either
    from collaboration with other R users, or from code found in textbooks or online).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Through the feedback I receive from my students, I notice that `{dplyr}` is
    relatively easy to learn when you are familiar with base R (which is quite rewarding
    for those who struggled at the beginning).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For these reasons, I tend to teach data manipulation with base R first and
    then slowly switch to `{dplyr}` (up to the point that for some advanced training
    courses, I hardly use base R at all by the end of the course). As a side note,
    this is the approach I follow for data visualization in R as well: I teach first
    how to plot data with base R, then I gradually teach them [how to use](https://statsandr.com/blog/graphics-in-r-with-ggplot2/)
    `[{ggplot2}](https://statsandr.com/blog/graphics-in-r-with-ggplot2/)`.'
  prefs: []
  type: TYPE_NORMAL
- en: With this approach, some students may have the impression that they wasted their
    time learning base R. At least, some may have this impression during the training.
    However, as soon as the training is done and they have to learn R by themselves
    or work on real projects, they are grateful of having learned both.
  prefs: []
  type: TYPE_NORMAL
- en: I am curious to hear from other teachers regarding their approach, so feel free
    to share your opinion.
  prefs: []
  type: TYPE_NORMAL
- en: Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To present the different functions, we will use the data frame `penguins`,
    available within the `{palmerpenguins}` package (Horst, Hill, and Gorman 2020).
    Data are available by [CC-0](https://creativecommons.org/public-domain/cc0/) license
    and can be downloaded from CRAN:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Before going further, we rename the data frame as `dat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'I like to call data frames I am working on with a generic name such as `dat`
    for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Every time I need to write the name of the data frame, it is usually shorter
    to write `dat` than to write the name of the data frame (which is in this case
    `penguins`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If I need to do similar analyses or plots on different data frames, the code
    I wrote in the past can be reused with only a few modifications. With this very
    simple trick, most of the time I only have to edit the names of the variables,
    but the name of the data frame does not need to be changed (which saves me a lot
    of time).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The data frame contains data for 344 penguins and 8 variables describing the
    species, the island, some measurements of the size of the bill, flipper and body
    mass, the sex and the study year. More information about the data frame can be
    found by running `?penguins` (after loading the `{palmerpenguins}` package).
  prefs: []
  type: TYPE_NORMAL
- en: For this post, we will focus only on the variables `species`, `body_mass_g`,
    `sex` and `year`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before proceeding with the different data manipulation techniques, let’s first
    inspect the data by displaying its structure, the first 6 rows and a summary of
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '{dplyr} package'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Without further ado, let’s illustrate the different functions for data manipulation
    available in the `{dplyr}` package in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for any package, we first need to install and load it before using it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that all functions presented below requires tidy data, which means that:'
  prefs: []
  type: TYPE_NORMAL
- en: each variable is in its own column,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: each observation, or case, is in its own row, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: each value is in its own cell.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filter observations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Filtering observations based on their values can be done with the `filter()`
    function. This function works on both [quantitative](https://statsandr.com/blog/variable-types-and-examples/#quantitative)
    and [qualitative](https://statsandr.com/blog/variable-types-and-examples/#qualitative)
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can combine several conditions with `&` (if the conditions must be cumulative)
    or `|` (if the conditions are alternatives), for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice that variable names do *not* have to be written inside single nor double
    quotation marks (`''` or `""`). This is the case for all functions presented below.
  prefs: []
  type: TYPE_NORMAL
- en: The pipe operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see from the code above, the `filter()` functions requires the name
    of the data frame as first argument, then the condition (with the usual logical
    operators `>`, `<`, `>=`, `<=`, `==`, `!=`, `%in%`, etc.) as second argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifying the name of the data frame as first argument is required for all
    functions presented in this list. However, there is a workaround to specifying
    the data frame’s name inside the functions: the pipe operator (`|>` or `%>%`).'
  prefs: []
  type: TYPE_NORMAL
- en: The pipe operator allows to perform a sequence of several operations, that is,
    chain a sequence of calculations together. It is particularly useful when you
    are performing several operations on a data frame, and you do not want to save
    the output at each intermediate step. We will see below how to use the pipe operator
    with several operations, but for now I would like to introduce it with only one
    operation at a time.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see with the `filter()` function, the pipe operator is not compulsory.
    However, I recommend it so much (even to beginners) for its easy of use, convenience,
    code readability and popularity that from now on functions available in `{dplyr}`
    will be presented together with the pipe operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'So with the pipe operator, the code above becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The pipe operator simply takes the results of one operation into the next operation
    below it, making the code extremely easy to write and read.
  prefs: []
  type: TYPE_NORMAL
- en: This way, instead of specifying the data frame’s name as first argument in the
    `filter()` function (or any other function within the `{dplyr}` package), we simply
    specify the data frame’s name and then the desired function, combined together
    thanks to the pipe operator.
  prefs: []
  type: TYPE_NORMAL
- en: Extract observations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is possible to extract observations based on:'
  prefs: []
  type: TYPE_NORMAL
- en: their positions, or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: their values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on their positions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Extracting observations based on their positions can be done with the `slice()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, extracting the first or last rows can be done with `slice_head()`
    and `slice_tail()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Based on their values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To extract observations based on values of a variable, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`slice_min()` to select rows with the **lowest** values (with a defined proportion),
    and'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`slice_max()` to select rows with the **highest** values (with a defined proportion).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Sample observations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sampling observations can be done in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Random sample of a **number** of rows with `sample_n()`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Random sample of a **fraction** of rows with `sample_frac()`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note that, as with the `sample()` function within base R, `size` can be greater
    than the size of the data frame. In this case, some rows will be duplicated, and
    you will need to specify the argument `replace = TRUE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, it is possible to obtain a random sample of a number of rows
    or fraction or rows with `slice_sample()`. For this, use:'
  prefs: []
  type: TYPE_NORMAL
- en: the argument `n` to select a number of rows, or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the argument `prop` to select a fraction of rows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Sort observations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sorting observations can be done with the `arrange()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, `arrange()` uses the **ascending** order. To sort in **descending**
    order, use `desc()` inside `arrange()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'As with `filter()`, `arrange()` can be used for several variables and works
    both on quantitative and qualitative variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The code above sorts the observations first based on the sex (in alphabetical
    order) and then based on the body mass (in ascending order, so from lowest to
    highest).
  prefs: []
  type: TYPE_NORMAL
- en: Note that if the qualitative variable is defined as an ordered [factor](https://statsandr.com/blog/data-types-in-r/#factor),
    the sorting is based on level order, not alphabetical order!
  prefs: []
  type: TYPE_NORMAL
- en: Select variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Selecting variables can be done with the `select()` function, based on:'
  prefs: []
  type: TYPE_NORMAL
- en: the position of the variable(s), or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the name(s) of the variable(s).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that it is also possible to remove variables. For this, use the `-` sign
    in front of their positions or names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to select variables with a sequence of names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Last but not least, `select()` can also be used as an easy way to rearrange
    columns in the desired order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Rename variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To rename variables, use the `rename()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This might not be intuitive (at least it was not for me at the time of learning
    this package), so bear in mind that you always need to write first the new name
    and then the old name (separated with the `=` sign).
  prefs: []
  type: TYPE_NORMAL
- en: Create or modify variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can create or modify certain variables of the data frame with `mutate()`,
    based on:'
  prefs: []
  type: TYPE_NORMAL
- en: another variable, or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a vector of your choice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Note that if you create a variable with a name which already exists in the data
    frame, the old variable will be erased and replaced by the new one.
  prefs: []
  type: TYPE_NORMAL
- en: Like `rename()`, `mutate()` requires the argument to be written as `name = expression`,
    where `name` is name of the column created or modified and `expression` is the
    formula for calculating the values.
  prefs: []
  type: TYPE_NORMAL
- en: Summarize observations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Often, you will want to summarize the data with some [descriptive statistics](https://statsandr.com/blog/descriptive-statistics-in-r/).
    This can be done with the `summarize()` function, in addition to most functions
    used for descriptive statistics (`mean()`, `median()`, `min()`, `max()`, `sd()`,
    `var()`, etc.):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that:'
  prefs: []
  type: TYPE_NORMAL
- en: The `na.rm = TRUE` argument is used to omit missing values in the computation
    of the summary statistics.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`summarize()` and `summarise()` give the exact same results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify distinct values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Identifying distinct values of a variable can be done with `distinct()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Identifying distinct values is mostly done on qualitative or quantitative discrete
    variables, but it can be done on any type of variable and with several variables
    at the same time. If more than one variables is specified, it returns all the
    combinations of values of the variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, with species and study year:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Connected operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another advantage of using the `{dplyr}` package is that several operations
    can be connected all at once, with great readability of the code. This can easily
    be done with the pipe operator (`|>` or `%>%`) introduced earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Until now, we have always seen the same structure: we call a data frame, and
    then we apply an operation on that data frame. From now on, we will see how to
    combine more operations into one single chain of operations.'
  prefs: []
  type: TYPE_NORMAL
- en: Group by
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`group_by()` allows to modify the way the basic functions are performed. Instead
    of covering all the rows of the data frame, the operations will cover each of
    the groups of rows defined by the grouping command. In this way, aggregation operations,
    using `summarize()`, will produce statistics for each group rather than for all
    observations.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, we might be interested in computing some descriptive statistics
    of a quantitative variable, for each level of a qualitative variable (so by group).
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, suppose we would like to compute the mean and standard deviation
    of the body mass, but this time separately for each species:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Applied to the example above, here is how the pipe operator works:'
  prefs: []
  type: TYPE_NORMAL
- en: The first operation (`group_by()`) groups observations by species.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then the output of the first operation is used as the input for the second
    operation (`summarize()`): mean and standard deviation are computed on body mass.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a result, we have the mean and standard deviation of body mass by group.
    As you can imagine, all previous operations can be connected to match your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also note that `group_by()` can be used for several grouping variables at the
    same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: (Note that, as for all connected operations, the name of the data frame needs
    to be specified only in the first operation.)
  prefs: []
  type: TYPE_NORMAL
- en: Number of observations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some operations can only be performed inside other operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the case with the number of observations `n()`, which can only be used
    inside `summarize()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'To refer with the previous connected operation `group_by()`, we can compute
    the number of observations by group using the two operations `n()` and `group_by()`
    separated by the pipe operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Note that `n()` accepts no parameters and is therefore always written with empty
    parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, note also that the `count()` function is equivalent to `summarize(n
    = n())`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Number of distinct values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`n_distinct()`, which can also be used only inside `summarize()`, computes
    the number of different values/levels of a variable or combination of variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you do not have to specify a name for the output. In that case, the
    name of the operation will be used. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: First, last or nth value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Also only available inside `summarize()`, the first, last or nth value can
    be found with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Several interesting arguments exist within this function to deal with missing
    values. For the interested reader, see more information in the documentation of
    the function (run `?nth()`).
  prefs: []
  type: TYPE_NORMAL
- en: If else
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A very common data transformation is the well known “if else” technique. This
    technique is usually used to create, from an existing variable, another variable
    which can take **two levels**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we want to create a new variable called `body_mass_cat`, which
    takes the value “High” when `body_mass_g` is equal or greater than a certain threshold,
    “Low” otherwise. This transformation can be performed with the combination of
    `mutate()` and `if_else()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The `if_else()` function works with 3 arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The condition (in our case: `body_mass_g >= 4000`)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The output value when the condition is true (`High` in our case).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The output value when the conditions is false (`Low` in our case).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see from the table above, when body mass is missing, `if_else()`
    also returns a missing value, which is often a good thing to prevent observations
    being classified erroneously.
  prefs: []
  type: TYPE_NORMAL
- en: Case when
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to categorize a variable into **more than two levels**, an if else
    is not the most appropriate tool. In these cases, a “case when” is more appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: For your information, when I learned R, I used to write nested if else functions,
    that is, a secondary if else inside a primary if else. Most of the time it worked
    (with very often a waste of time trying to debug my code), but it is very easy
    to make a mistake. And even if you managed to make it work, the code is not easy
    to read at all!
  prefs: []
  type: TYPE_NORMAL
- en: So I highly recommend using this case when technique instead of several if else
    functions nested within each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want to classify body mass into 3 categories: low, medium and high.
    For this illustration, we arbitrarily decide that body mass is low when it is
    strictly lower than 3500, high when it is strictly higher than 4750 and medium
    otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With nested if else functions, here is the code we would need to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'This code works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It evaluates the first condition `body_mass_g < 3500`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it is true, `body_mass_cat` is `Low`. On the contrary, if it is false, it
    evaluates the second condition `body_mass_g > 4750`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If this second condition is true, `body_mass_cat` is `High`, otherwise it is
    `Medium`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see from the results above, it works. However, you will concede that
    it is easy to make coding mistakes, and that the code is not easy to write nor
    to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'To improve this workflow, we now use the case when technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: This workflow is much simpler to code and read!
  prefs: []
  type: TYPE_NORMAL
- en: 'If there are no missing values in the variable(s) used for the condition(s),
    it can even be simplified to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, a default output can be specified with `.default` for observations
    that do not match any of the conditions.
  prefs: []
  type: TYPE_NORMAL
- en: However, be careful if there are missing values! Indeed, if there is at least
    one missing value (as in our case), the code above is not correct because observations
    with missing `body_mass_g` will be misclassified as `Medium`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, if you really want to specify a default output, I recommend using
    the code below which keeps missing values as `NA`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: I personally prefer to write all categories and not write a default option for
    improved code readability and robustness of my code, but it is more a personal
    opinion.
  prefs: []
  type: TYPE_NORMAL
- en: In all cases, no matter if you used an if else or a case when, it is a good
    practice to check the variable you just created to make sure that you obtain the
    intended results.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion and other resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thanks for reading.
  prefs: []
  type: TYPE_NORMAL
- en: This article introduced and illustrated the most common data manipulation and
    data management tools in R, using the `{dplyr}` package. We also introduced the
    pipe operator, well known to users of modern R packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `{dplyr}` package offers many more functions for data manipulation (in
    particular to merge data frames with the family of `join()` functions). If you
    would like to learn more about this package, I recommend starting with the following
    resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[dplyr.tidyverse.org](https://dplyr.tidyverse.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter “Data transformation”](https://r4ds.hadley.nz/data-transform.html)
    in the book “R for Data Science”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Cheatsheet](https://github.com/rstudio/cheatsheets/blob/main/data-transformation.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Vignette](https://dplyr.tidyverse.org/articles/dplyr.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For those who are used to base R, a [vignette](https://cran.r-project.org/web/packages/dplyr/vignettes/base.html)
    comparing `{dplyr}` functions to their base R equivalents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As always, if you have a question or a suggestion related to the topic covered
    in this article, please add it as a comment so other readers can benefit from
    the discussion.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Horst, Allison Marie, Alison Presmanes Hill, and Kristen B Gorman. 2020\. *Palmerpenguins:
    Palmer Archipelago (Antarctica) Penguin Data*. [https://doi.org/10.5281/zenodo.3960218](https://doi.org/10.5281/zenodo.3960218).'
  prefs: []
  type: TYPE_NORMAL
- en: The keyboard shortcut for the pipe operator is `ctrl + shift + m` (Windows)
    or `cmd + shift + m` (Mac). It will print `%>%`, unless you specified to use the
    native pipe operator `|>` in the settings of RStudio.[↩︎](https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/#fnref1)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Related articles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Top 10 errors in R and how to fix them](https://statsandr.com/blog/top-10-errors-in-r/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[One-sample Wilcoxon test in R](https://statsandr.com/blog/one-sample-wilcoxon-test-in-r/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Hypothesis test by hand](https://statsandr.com/blog/hypothesis-test-by-hand/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ANOVA in R](https://statsandr.com/blog/anova-in-r/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Correlation coefficient and correlation test in R](https://statsandr.com/blog/correlation-coefficient-and-correlation-test-in-r/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Originally published at* [*https://statsandr.com*](https://statsandr.com/blog/introduction-to-data-manipulation-in-r-with-dplyr/)
    *on November 27, 2023.*'
  prefs: []
  type: TYPE_NORMAL
