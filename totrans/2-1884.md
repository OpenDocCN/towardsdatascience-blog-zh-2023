# 编写可维护机器学习代码的软件工程最佳实践

> 原文：[https://towardsdatascience.com/software-engineering-best-practices-for-writing-maintainable-ml-code-717934bd5590](https://towardsdatascience.com/software-engineering-best-practices-for-writing-maintainable-ml-code-717934bd5590)

![](../Images/1d59ed9c7fdba6ad95f054d4357d2f46.png)

一位迷失在代码森林中的数据科学家。与第二个和最后一个建议相关。图片由作者通过[Midjourney](https://www.midjourney.com)创建。

## 针对数据科学家的高级编码建议

[](https://hennie-de-harder.medium.com/?source=post_page-----717934bd5590--------------------------------)[![Hennie de Harder](../Images/3e4f2cccd6cb976ca3f8bf15597daea8.png)](https://hennie-de-harder.medium.com/?source=post_page-----717934bd5590--------------------------------)[](https://towardsdatascience.com/?source=post_page-----717934bd5590--------------------------------)[![Towards Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----717934bd5590--------------------------------) [Hennie de Harder](https://hennie-de-harder.medium.com/?source=post_page-----717934bd5590--------------------------------)

·发表于[Towards Data Science](https://towardsdatascience.com/?source=post_page-----717934bd5590--------------------------------) ·阅读时间11分钟·2023年8月6日

--

**与传统的软件工程项目不同，机器学习代码库由于其复杂和不断发展的特性，往往在代码质量上滞后，导致技术债务增加和协作困难。优先考虑可维护性对于创建稳健的机器学习解决方案至关重要，这些解决方案能够适应、扩展并随着时间的推移提供价值。**

近年来，机器学习在全球掀起了热潮，从医疗到金融等各个行业都发生了变革。随着越来越多的组织加入机器学习的行列，探索新的可能性和洞察力，编写可维护和稳健的机器学习代码变得至关重要。通过编写易于处理且经得起时间考验的机器学习代码，团队可以更好地协作，并在模型和项目成长和适应的过程中确保成功。以下部分将展示机器学习代码库中的常见示例，并解释如何妥善处理这些问题。

# 不要创建大型单体结构

这个建议可能与你无关，但它是为那些尚未意识到这一点的个体（直到现在）编写的！

单体脚本，即一个脚本处理整个项目，可能会在你将实验代码复用到生产环境时出现。复制、粘贴、完成！创建一个单独的脚本来处理整个项目总是一个糟糕的主意。这种脚本难以阅读（即使是编写者也难以阅读）、难以调试且效率低下。你无法轻松添加新功能或修改代码，因为每次都需要运行整个脚本。添加单元测试也是不可能的，因为这个单体就是“整个单元”。

单个脚本的另一个问题是可重用性。你不能在其他项目中重用这些代码，因为它很难阅读。

写单体应用只有一个理由；那就是如果你不喜欢接手你工作的同事。如果你想让这个人感到沮丧，这是一个简单的方法。

那么应该怎么做呢？编写模块和类。创建具有单一特定用途的不同代码文件。每个文件应包含函数或类和方法。这样，代码会更容易阅读、调试、重用和测试。在下一个提示中，你可以找到一个常用的目录结构。

# 不要过度设计仓库结构

这可能看起来有些违反直觉，但这是非常重要的。过度设计仓库结构指的是为代码和项目文件创建复杂且不必要的复杂组织。这涉及引入抽象层、过度的文件夹结构和复杂的命名约定，这些可能在可维护性、可扩展性或协作方面没有显著好处。相反，它增加了不必要的复杂性，使团队成员更难理解、导航和贡献项目。

可能出现的一些问题包括：由于开发者的认知负担增加，开发速度变慢。新团队成员的学习曲线变得更加复杂，而仓库的复杂性可能导致代码重复和碎片化。

如何维持一个健康的仓库结构？以下是一些可能有帮助的提示：

+   遵循在机器学习社区中广泛接受的标准目录布局和命名约定（见下文）。

+   将相关文件和模块分组放在适当的目录中。例如，将数据预处理代码与模型训练代码分开。

+   提供清晰简洁的文档，以指导团队成员如何浏览和贡献项目。

+   定期与团队审查仓库结构，以识别可以简化或改进的区域。

+   最后但同样重要的是：保持简单！避免添加不必要的抽象层或复杂的文件夹层级，除非它们确实能改善组织和可读性。

这里是一个标准目录结构的例子：

[PRE0]

![](../Images/71f64ba97af91ce6f51f4061a0293b52.png)

许多嵌套的文件夹可能使仓库过于复杂。照片由[Didssph](https://unsplash.com/@didsss?utm_source=medium&utm_medium=referral)拍摄，来源于[Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)

# 了解你的编程语言行为

在某些情况下，编程语言的行为可能与预期不同。这可能会导致挫折和大量的调试时间。为了防止这种情况，如果你了解编程语言的奇怪行为，会大有帮助。

如果我们看看Python，以下是一些你应该注意的例子。

作为程序员，你可能会遇到的第一个例子是以下情况。你想要对数字进行四舍五入，然后你发现了这个问题：

[PRE1]

发生了什么？在 Python 3 中，决定使用银行家舍入，这意味着0.5会四舍五入为偶数。为什么这样做有意义？我喜欢[这个解释](https://stackoverflow.com/questions/45223778/is-bankers-rounding-really-more-numerically-stable)在 Stack Overflow 上。

另一个 Python 中奇怪行为的例子：

[PRE2]

在上面的例子中，列表的默认参数是一个空列表。但是如果你第二次运行该函数，第二次运行的输出会令人惊讶。它返回的是之前的列表加上新的项！原因是，在 Python 中存在*可变默认参数*，这意味着对默认对象的更改会在函数调用之间持续存在。为避免这种情况，将默认值设置为`None`，并在函数调用中创建一个新的可变对象实例。

另一个例子是*浮点运算精度*：

[PRE3]

在比较浮点值时，最好接受小的容差。如果你在测试期间比较浮点值，并且使用了[pytest](https://docs.pytest.org/en/7.4.x/contents.html)，你可以使用`approx`解决这个问题：

[PRE4]

如果你使用的是 Python 2.7，以下示例可能会让人困惑。列表推导式中使用的变量可能会“泄漏”到外部作用域：

[PRE5]

对`None`进行排序会引发`TypeError`：

[PRE6]

你还可以将属性分配给一个类中不存在的实例：

[PRE7]

另一个令人困惑的例子是*不一致的闭包*。闭包是一个函数，它捕获并记住它创建时的环境，包括来自外部作用域的任何变量。虽然闭包是一个强大的特性，但它们在循环中的行为可能会导致令人惊讶的结果：

[PRE8]

所有函数都返回循环中`i`的最后一个值（即4）与`x`的乘积。这是因为 Python 中的闭包闭合的是变量，而不是它们的值，这意味着它们保留对变量`i`的引用。当闭包稍后被调用（在循环外部时），它会查找其封闭作用域中`i`的当前值，现在是4（循环中的最后一个值）。

解决这个问题的一个简单方法是使用默认参数：

[PRE9]

除了这些示例，还有许多其他例子。意识到这一点将使你的代码更加健壮和可靠，并避免所有那些意外的惊喜！

# 处理多个返回值

在函数的返回语句中添加越来越多的参数可能会使 Python 代码变得混乱且更难维护，特别是当参数数量增加时。每次你更改某些内容时，你需要更新所有调用代码，这会导致维护上的噩梦。开发人员可能会错误地按错误的顺序传递参数，从而导致逻辑错误。

Python提供了一种优雅的解决方案：Python的`collections`模块中的`[namedtuple](https://docs.python.org/3/library/collections.html#collections.namedtuple)`。

以下是如何使用namedtuples来提高代码的清晰度和可维护性：

[PRE10]

简单，对吧？使用`namedtuple`有许多好处，比如提高代码的可读性，保持不变性，并且更节省内存（用C实现）。对于你作为程序员来说，最大的好处也许是：在向返回语句添加另一个参数后，你不需要更新所有调用代码。

> 注意：[namedtuples](https://docs.python.org/3/library/collections.html#collections.namedtuple)在Python中类似于Scala中的[case classes](https://docs.scala-lang.org/tour/case-classes.html)。

# 异常处理注意事项

处理异常的最糟糕方法是发生异常时盲目继续：

[PRE11]

永远不要这样做。如果发生了某些事情且未能获得结果，脚本会像一切正常一样继续。异常被默默忽略。这可能导致隐藏的错误和意外的行为。

在一些代码库中，你会发现许多`try` `except`块。避免使用try-except块进行正常流程控制。异常应该用于处理异常情况，而不是常规流程。

另一种不良实践是捕获泛型异常：

[PRE12]

这可能会隐藏特定错误，使调试变得困难。还要避免裸`except`块。你将对发生了什么一无所知。

你应该如何处理异常？以下是一些有用的提示。

尽量具体，只捕获泛型异常用于调试。在某些情况下，添加`finally`块可能会很有用。`finally`块中的代码将始终运行。

[PRE13]

你还可以创建自定义异常类。通过自定义异常，你可以提供更具体的错误消息，并帮助区分不同类型的错误。可以像这样简单：

[PRE14]

# 适当地处理大型条件逻辑树

（业务）逻辑的复杂性可以迅速升级。它从一个简单的if-else语句开始，但随着扩展，变成一个庞大的条件结构，变得难以管理，导致挫败感。幸运的是，存在多种方法来解决这一挑战并提高可维护性。

一种解决方案是将逻辑与处理分开，例如在字典中。让我们来看一下下面的if-else树：

[PRE15]

我们可以使用字典对其进行重构：

[PRE16]

最好在函数外部定义映射，在单独的设置或配置文件中。这种方法是可以的，但如果不小心，它仍然可能变成一个相当大的字典。

处理这种情况的另一种方法是使用*多态*。创建一个带有通用接口的基类，然后为每个特定情况实现子类。每个子类将处理其独特的逻辑。

假设我们想根据输入`op`执行不同的数学操作，并将它们应用于`x`和`y`：

[PRE17]

最后一个警告：要小心代码重复。如果你有多个模型并且希望使用它们的输出得到最终得分，不要创建嵌套的条件逻辑树。相反，你可以使用多个小函数来得到最终得分。

让我们来看一个学校里的玩具示例。你的数学最终成绩将根据你的出勤率和考试百分比分数来计算。

首先看看这个：

[PRE18]

看起来复杂对吧？如果计算成绩时涉及更多因素怎么办？每增加一个参数，树形结构将呈指数增长。

幸运的是，对于这种情况，存在一种更简洁高效的解决方案：

[PRE19]

这个解决方案扩展性很好！你可以将一个参数及其对应的分数添加到列表中，它将被包括在结果中。

> 注意：你可能希望在添加更多参数时对最终解决方案进行四舍五入。确保正确执行（参见有关编程语言行为的提示）。

未来你可以用这些示例作为灵感，编写更智能的代码，避免冗长的条件逻辑树。

# 结论

恭喜你读完了这篇文章！提供的建议对于保持代码库结构化和可维护性非常有帮助。在混乱的单体文件和过于复杂的嵌套目录之间取得平衡是获得良好开发体验的关键。

通过理解编程语言的行为、采用命名元组处理多个返回值、有效处理错误和简化条件逻辑，开发者和团队可以减少维护时间，更多地投入到添加有用功能或探索新项目中。记得用[测试](https://docs.pytest.org/en/7.4.x/)、[代码检查](https://flake8.pycqa.org/en/latest/)、[代码格式化](https://github.com/psf/black)和[文档](https://www.sphinx-doc.org/en/master/)来加强代码库，以确保长期健康和生产力。

编程愉快，下次再见！

## 相关

[## 简化你的机器学习项目](https://towardsdatascience.com/simplify-your-machine-learning-projects-ab171d19c9ef?source=post_page-----717934bd5590--------------------------------)

### 为什么花费大量时间和精力在复杂模型上是一个不好的主意，以及应该怎么做

[## 如何简化你的机器学习项目](https://towardsdatascience.com/simplify-your-machine-learning-projects-ab171d19c9ef?source=post_page-----717934bd5590--------------------------------) [## 如何有效比较机器学习解决方案](https://towardsdatascience.com/how-to-compare-ml-solutions-effectively-28384e2cbca1?source=post_page-----717934bd5590--------------------------------)

### 增加将模型投入生产的机会

[## 如何有效比较机器学习解决方案](https://towardsdatascience.com/how-to-compare-ml-solutions-effectively-28384e2cbca1?source=post_page-----717934bd5590--------------------------------) [## 使用机器学习检测数据漂移](https://medium.com/bigdatarepublic/detecting-data-drift-with-machine-learning-adb177544312?source=post_page-----717934bd5590--------------------------------)

### 通过一个简单的自动化过程，了解你的机器学习模型性能下降的情况。

[medium.com](https://medium.com/bigdatarepublic/detecting-data-drift-with-machine-learning-adb177544312?source=post_page-----717934bd5590--------------------------------)
