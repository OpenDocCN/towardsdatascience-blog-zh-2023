["```py\n#We install the 5 libraries with the package manager 'pip', one line at a time\npip install numpy\npip install pandas\npip install open3d==0.16.0\npip install matplotlib\npip install shapely\n```", "```py\nimport numpy as np\npoint_cloud = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\n#To print the \"point_cloud\" variable as [Out] from the cell\nprint(point_cloud) \n```", "```py\nimport pandas as pd\n\n# create a DataFrame with X, Y, and Z columns\npoints_df = pd.DataFrame({ 'X': [1, 4, 7], 'Y': [2, 5, 8], 'Z': [3, 6, 9]})\n\n# save the DataFrame as a CSV file at the same place as your script\npoints_df.to_csv('point_cloud.csv', index=False)\n```", "```py\nimport open3d as o3d\n\n# create an empty point cloud object\npoint_cloud = o3d.geometry.PointCloud()\n\n# add points to the point cloud\npoints = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\npoint_cloud.points = o3d.utility.Vector3dVector(points)\n```", "```py\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\nimport numpy as np\n\n# create a point cloud with 1000 random points\npoints = np.random.rand(1000, 3)\n\n# create a 3D plot and add the points as a scatter plot\nfig = plt.figure()\nax = fig.add_subplot(111, projection=’3d’)\nax.scatter(points[:,0], points[:,1], points[:,2])\n\n# show the plot\nplt.show()\n```", "```py\nfrom shapely.geometry import Point, Polygon\n\n# create a polygon with four vertices\npolygon = Polygon([(0, 0), (0, 1), (1, 1), (1, 0)])\n\n# create a point\npoint = Point(0.5, 0.5)\n\n# check if the point is within the polygon\nif polygon.contains(point):\n print(‘The point is within the polygon.’)\nelse:\n print(‘The point is outside the polygon.’)\n```", "```py\nimport numpy as np\nimport pandas as pd\nimport open3d as o3d\nimport matplotlib.pyplot as plt\nfrom shapely.geometry import Polygon\n\nprint(f\"Open 3D Version: {o3d.__version__}\")\n```", "```py\ndata_folder=\"../DATA/\"\npc_dataset=\"30HZ1_18_sampled.xyz\"\nmesh_dataset=\"NL.IMBAG.Pand.0637100000139735.obj\"\nresult_folder=\"../DATA/RESULTS/\"\n```", "```py\npcd_df= pd.read_csv(data_folder+pc_dataset, delimiter=\";\")\nprint(pcd_df.columns)\n```", "```py\npcd_o3d=o3d.geometry.PointCloud(o3d.utility.Vector3dVector(np.array(pcd_df[['X','Y','Z']])))\n```", "```py\npcd_o3d.colors = o3d.utility.Vector3dVector( np.array( pcd_df[[‘R’,’G’,’B’]]) / 255 )\n```", "```py\nmesh=o3d.io.read_triangle_mesh(data_folder+mesh_dataset)\nmesh.paint_uniform_color([0.9,0.9,0.9])\n```", "```py\no3d.visualization.draw_geometries([pcd_o3d,mesh])\n```", "```py\n# 1=unclassified, 2=Ground, 6=building, 9=water, 26=rest\npcd_df['Classification'].unique()\ncolors=np.zeros((len(pcd_df), 3))\ncolors[pcd_df['Classification'] == 2] = [0,0,0]\ncolors[pcd_df['Classification'] == 6] = [1,0,0]\ncolors[pcd_df['Classification'] == 9] = [0,0,0]\ncolors[pcd_df['Classification'] == 26] = [0,0,0]\npcd_o3d.colors = o3d.utility.Vector3dVector(colors)\n```", "```py\n# Creating a KD-Tree Data Structure\npcd_tree = o3d.geometry.KDTreeFlann(pcd_o3d)\n```", "```py\n# Selecting points by distance from POI (your house) using the KD-Tree \n[k, idx, _] = pcd_tree.search_radius_vector_3d(POI, dist_POI)\npcd_selection=pcd_o3d.select_by_index(idx)\n```", "```py\no3d.visualization.draw_geometries([pcd_selection,mesh])\n```", "```py\no3d.visualization.draw_geometries_with_vertex_selection([pcd_selection])\n```", "```py\no3d_parcel_corners=pcd_selection.select_by_index([34335 ,979 ,21544 ,19666 ,5924 ,21816 ,38008 ])\n```", "```py\no3d_parcel_corners=np.array(o3d_parcel_corners.points)[:,:2]\n```", "```py\nPolygon(o3d_parcel_corners)\n```", "```py\npgon = Polygon(o3d_parcel_corners)\nprint(f\"This is the obtained parcel area: {pgon.area} m²\")\n```", "```py\ndef sort_coordinates(XY):\n    cx, cy = XY.mean(0)\n    x, y = XY.T\n    angles = np.arctan2(x-cx, y-cy)\n    indices = np.argsort(-angles)\n    return XY[indices]\n```", "```py\nnp_sorted_2D_corners=sort_coordinates(o3d_parcel_corners)\npgon = Polygon(np_sorted_2D_corners)\nPolygon(np_sorted_2D_corners)\nprint(f\"This is the parcel area: {pgon.area} m²\")\n```", "```py\npcd_selection.get_max_bound()\npcd_selection.get_min_bound()\n```", "```py\nnp_pcd_selection=np.array(pcd_selection.points)\nlowest_point_index=np.argmin(np_pcd_selection[:,2])\nhighest_point_index=np.argmax(np_pcd_selection[:,2])\n```", "```py\n# We create 3D Spheres to add them to our visual scene\nlp=o3d.geometry.TriangleMesh.create_sphere()\nhp=o3d.geometry.TriangleMesh.create_sphere()\n\n# We translate the 3D Spheres to the correct position\nlp.translate(np_pcd_selection[lowest_point_index])\nhp.translate(np_pcd_selection[highest_point_index]))\n\n# We compute some normals and give color to each 3D Sphere\nlp.compute_vertex_normals()\nlp.paint_uniform_color([0.8,0.1,0.1])\nhp.compute_vertex_normals()\nhp.paint_uniform_color([0.1,0.1,0.8])\n\n# We generate the scene\no3d.visualization.draw_geometries([pcd_selection,lp,hp])\n```", "```py\nvoxel_grid = o3d.geometry.VoxelGrid.create_from_point_cloud(pcd_selection, voxel_size=2)\no3d.visualization.draw_geometries([voxel_grid])\n```", "```py\ncolors=np.zeros((len(pcd_df), 3))\ncolors[pcd_df['Classification'] == 6] = [1, 0, 0]\npcd_o3d.colors = o3d.utility.Vector3dVector(colors)\n```", "```py\n# Defining the POI and the center of study\ndist_POI=50\nPOI=mesh.get_center()\n\n# Querying all the points that fall within based on a KD-Tree\npcd_tree = o3d.geometry.KDTreeFlann(pcd_o3d)\n[k, idx, _] = pcd_tree.search_radius_vector_3d(POI, dist_POI)\npcd_selection=pcd_o3d.select_by_index(idx)\n\n#Computing the voxel grid and visualizing the results\nvoxel_grid = o3d.geometry.VoxelGrid.create_from_point_cloud(pcd_selection, voxel_size=2)\no3d.visualization.draw_geometries([voxel_grid])\n```", "```py\nidx_voxels=[v.grid_index for v in voxel_grid.get_voxels()]\ncolor_voxels=[v.color for v in voxel_grid.get_voxels()]\nbounds_voxels=[np.min(idx_voxels, axis=0),np.max(idx_voxels, axis=0)]\n```", "```py\nmax_voxel={}\nmax_color={}\n```", "```py\nfor idx, v in enumerate(idx_voxels):\n    if (v[0],v[1]) in max_voxel.keys():\n        if v[2]>max_voxel[(v[0],v[1])]:\n            max_voxel[(v[0],v[1])]=v[2]\n            max_color[(v[0],v[1])]=color_voxels[idx]\n    else:\n        max_voxel[(v[0],v[1])]=v[2]\n        max_color[(v[0],v[1])]=color_voxels[idx] \n```", "```py\ncount_building_coverage,count_non_building=0,0\nfor col in list(max_color.values()):\n    if np.all(col==0):\n        count_non_building+=1\n    else:\n        count_building_coverage+=1\n```", "```py\nprint(f\"Coverage of Buildings: {count_building_coverage*4} m²\")   \nprint(f\"Coverage of the Rest: {count_non_building*4} m²\")\nprint(f\"Built Ratio: {(count_building_coverage*4)/(count_building_coverage*2+count_non_building*2)} m²\") \n```"]