["```py\nimport random\nimport matplotlib.pyplot as plt\n\n%matplotlib inline\nplt.style.use('seaborn-v0_8-whitegrid')\nrandom.seed(5)\n\ndef generate_points(n: int=6) -> list[tuple]:\n    points = []\n    for i in range(n):\n        points.append((random.randint(0, 100), random.randint(0, 100)))\n    return points\n```", "```py\ndef calc_dist(points: list[tuple]) -> list[list]:\n    result = []\n    for i, left in enumerate(points):\n        row = [left]\n        for j, right in enumerate(points):\n            dist = (left[0] - right[0])**2 + (left[1] - right[1])**2\n            row.append(dist)\n        result.append(row)\n    return result\n```", "```py\ndef find_sorted_index(with_dist: list[list]) -> list[list]:\n    results = []\n    for row in with_dist:\n        dists = row[1:]\n        sorted_dists = sorted(dists)\n        indices = [dists.index(i) for i in sorted_dists]\n        row[1:] = indices\n        results.append(row)\n    return results\n```", "```py\ndef find_k_nearest(points: list[tuple], with_indices: list[list], k: int) -> list[tuple]:\n    results = []\n    for row in with_indices:\n        # Since the closest point to the current point is itself, we can get the point itself directly, so here is +2\n        k_indices = row[1:k+2]\n        the_points = [points[i] for i in k_indices]\n        results.append(the_points)\n    return results\n```", "```py\ndef draw_points(points: list[tuple]):\n    x, y = [], []\n    for point in points:\n        x.append(point[0])\n        y.append(point[1])\n    plt.scatter(x, y, s=100)\n\ndef draw_lines(nearest: list[list]):\n    for row in nearest:\n        start = row[0]\n        for end in row[1:]:\n            plt.plot([start[0], end[0]], [start[1], end[1]], color='black')\n\ndef orig_main(count: int = 6):\n    k = 2\n    points = generate_points(count)\n    with_dist = calc_dist(points)\n    sorted_index = find_sorted_index(with_dist)\n    nearest = find_k_nearest(points, sorted_index, k)\n    return points, nearest\n\npoints, nearest =  orig_main(6)\ndraw_points(points)\ndraw_lines(nearest)\n```", "```py\nIn:    a = np.arange(6).reshape(1, 6)\n       b = np.arange(6).reshape(6, 1)\n       a + b\nOut:   [[ 0  1  2  3  4  5]\n        [ 1  2  3  4  5  6]\n        [ 2  3  4  5  6  7]\n        [ 3  4  5  6  7  8]\n        [ 4  5  6  7  8  9]\n        [ 5  6  7  8  9 10]]\n```", "```py\nIn:  x = np.array([2, 1, 4, 3, 5])\n     i = np.argsort(x)\n     print(i)\nOut: [1 0 3 2 4]\n```", "```py\nIn:  x = np.array([8, 2, 4, 5, 3, 7, 1, 6])\n     ind = [0, 3, 7]\n     print(x[ind])\nOut: [8 5 6]\n```", "```py\nimport numpy as np\nfrom numpy import ndarray\n\nrandom.seed(5)\n\ndef structured_array(points: list[tuple]) -> ndarray:\n    dt = np.dtype([('x', 'int'), ('y', 'int')])\n    return np.array(points, dtype=dt)\n```", "```py\ndef np_find_dist(s_array: ndarray) -> ndarray:\n    a = s_array.reshape(6, 1)\n    b = s_array.reshape(1, 6)\n    dist = (a['x'] - b['x'])**2 + (a['y'] - b['y'])**2\n    return dist\n```", "```py\ndef np_k_nearest(dist: ndarray, k: int) -> ndarray:\n    k_indices = np.argpartition(dist, k+1, axis=1)[:, :k+1]\n    return k_indices\n```", "```py\ndef np_draw_points(s_array: ndarray):\n    plt.scatter(s_array['x'], s_array['y'], s=100)\n\ndef np_draw_lines(s_array: ndarray, k_indices: ndarray, k: int):\n    for i in range(s_array.shape[0]):\n        for j in k_indices[i, :k+1]:\n            plt.plot([s_array[i]['x'], s_array[j]['x']],\n                     [s_array[i]['y'], s_array[j]['y']],\n                     color='black')\n```", "```py\ndef np_main(count: int = 6):\n    k = 2\n    points = generate_points(count)\n    s_array = structured_array(points)\n    np_dist = np_find_dist(s_array)\n    k_indices = np_k_nearest(np_dist, k)\n\n    results = [s_array[k_indices[i, :k+1]] \n               for i in range(s_array.shape[0])]\n    return results, s_array, k_indices, k\n\nresults, s_array, k_indices, k = np_main(6)\nnp_draw_points(s_array)\nnp_draw_lines(s_array, k_indices, k)\n```"]