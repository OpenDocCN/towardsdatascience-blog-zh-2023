- en: Deploy Your Time Series Forecasting Model with Streamlit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/deploy-your-time-series-forecasting-model-with-streamlit-c3ce5a7edf19](https://towardsdatascience.com/deploy-your-time-series-forecasting-model-with-streamlit-c3ce5a7edf19)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A hands-on guide on building a web application to deploy your forecasting model
    using Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@marcopeixeiro?source=post_page-----c3ce5a7edf19--------------------------------)[![Marco
    Peixeiro](../Images/7cf0a81d87281d35ff47f51e3026a3e9.png)](https://medium.com/@marcopeixeiro?source=post_page-----c3ce5a7edf19--------------------------------)[](https://towardsdatascience.com/?source=post_page-----c3ce5a7edf19--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----c3ce5a7edf19--------------------------------)
    [Marco Peixeiro](https://medium.com/@marcopeixeiro?source=post_page-----c3ce5a7edf19--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----c3ce5a7edf19--------------------------------)
    ·13 min read·Apr 25, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/597cc6da68b8a31e827f4f2607f94c3d.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [SpaceX](https://unsplash.com/@spacex?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: As data scientists, we often work in the experimentation phase. We work in notebooks
    and develop scripts to evaluate models, and it stops there.
  prefs: []
  type: TYPE_NORMAL
- en: However, our work is never really done until the model is deployed. This crucial
    step brings us new challenges, as we have to think about error handling, and building
    an interface to interact with the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where [Streamlit](https://streamlit.io/) comes in: it is a Python library
    that allows us to build data applications rapidly, since we only Python for both
    the modelling portion and building the user interface.'
  prefs: []
  type: TYPE_NORMAL
- en: While Streamlit is a great prototyping tool to quickly deploy models, it will
    probably not power high-traffic, full-fledged data applications. You should think
    of it as a way to add interactivity to your models and share your data science
    work with others.
  prefs: []
  type: TYPE_NORMAL
- en: In this article, we will go through the portion of deploying a time series model
    using Streamlit. The full project is a multi-page application where we can both
    explore and forecast the data, but for this article, we focus only on the forecasting
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: You can visit the [finished application](https://marcopeix-streamlit-population-canada-main-4rr347.streamlit.app/)
    and play around with it. Also, the full source code is available on [GitHub](https://github.com/marcopeix/streamlit-population-canada).
  prefs: []
  type: TYPE_NORMAL
- en: '**Learn the latest time series analysis techniques with my** [**free time series
    cheat sheet**](https://www.datasciencewithmarco.com/pl/2147608294) **in Python!
    Get the implementation of statistical and deep learning techniques, all in Python
    and TensorFlow!**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: Objective
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The objective of this application is to forecast the quarterly population in
    Canada. The dataset is taken from Statistics Canada, and spans Q3 of 1991 to Q1
    of 2023\. The original data can be found [here](https://www150.statcan.gc.ca/t1/tbl1/en/cv.action?pid=1710000901).
  prefs: []
  type: TYPE_NORMAL
- en: Below is a sample of the dataset.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/70810e8af538acae05a808a43e422385.png)'
  prefs: []
  type: TYPE_IMG
- en: Sample of the dataset used in the application. For each location, we have the
    quarterly population estimate. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: With this dataset, we have information on the population of the entire country,
    but also for each province and territory. This means that we can choose between
    multiple targets, which we must keep in mind when building the application.
  prefs: []
  type: TYPE_NORMAL
- en: Project structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we are building an application that will deployed into production, the
    structure of the project matters greatly. Below is the structure that we use for
    this project.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In our project folder, we have a data folder that contains the CSV file with
    the quarterly population estimates. Note that we will read the data from the GitHub
    URL, to avoid dealing with relative and absolute file paths.
  prefs: []
  type: TYPE_NORMAL
- en: Then, because we are building a multi-page application, we have a `pages` folder
    that will contain the script to build the interface and output the forecast, which
    is `forecast.py`.
  prefs: []
  type: TYPE_NORMAL
- en: The main entry point to the application is controlled by the file `main.py`,
    but we will not cover it as it is not related to forecasting.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the file `requirements.txt` lists all the dependencies of the application
    to work properly.
  prefs: []
  type: TYPE_NORMAL
- en: Application diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into the code, we must first determine how the application will
    work at a high-level to understand where each functionality comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1cf19fa265ad7d24358115777189f097.png)'
  prefs: []
  type: TYPE_IMG
- en: Application diagram. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: From the figure above, we see that the data has to be read and made available
    in the script.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we add an option for the user to select a target and a horizon. We send
    that information to a function that will test different models and generate predictions
    using the best model only.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the predictions are returned so that we can plot the forecast. Also, we
    return the evaluation metric, so that we can visualize it and identify what model
    was used.
  prefs: []
  type: TYPE_NORMAL
- en: With the right project structure and an overall idea of what to build, we can
    now dive into the code and start building out our application.
  prefs: []
  type: TYPE_NORMAL
- en: Read the data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first natural step is of course to read the data. Now, because this is part
    of a multi-page application we actually read the data in `main.py` and make it
    available in `pages/forecast.py`.
  prefs: []
  type: TYPE_NORMAL
- en: We start off by defining a function that will read the data. Notice how we read
    from a URL, which avoids having problems with file paths when deploying our application.
    For now, this is all standard code of how we would read a data in a notebook.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice also the use of the decorator `@st.cache_data`. This tells Streamlit
    to cache the result of this function if the parameters do not change. That way,
    we do not have to rerun the function every time the user changes an input. This
    makes the application run much faster.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we store the data in the session state. This is a way to store and persist
    data across multiple pages in Streamlit. That way, we can read the data in `main.py`
    and have access to it in `pages/forecast.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It essentially works as a dictionary in which we can store important values
    that we want to access from different pages.
  prefs: []
  type: TYPE_NORMAL
- en: That way, in `pages/forecast.py`we can then access the data with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Even though we are in another file, we do not have to repeat the function to
    read the data, we can simply access it through the session state.
  prefs: []
  type: TYPE_NORMAL
- en: Build the interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have access to our data, let’s build out the interface to allow
    the user to select a target and a forecast horizon.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s allow the user to select a target. In our dataset, the target corresponds
    to a location, whether it is the entire country, a province or a territory. If
    you recall the dataset sample shown above, the list of possible targets is simply
    the name of the columns in the dataset.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s create 2 columns, so the user can select the target and the horizon
    on the same line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Then, in the first column, we will create a dropdown list that has all the possible
    targets in the dataset.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the code block above, the first parameter is a label for the input, and then
    we pass the list of possible values. By default, the first value of the list will
    be selected.
  prefs: []
  type: TYPE_NORMAL
- en: Then, to set the forecast horizon, let’s use a slider. Here, I will restrict
    the horizon from 1 to 16 quarters into the future, but feel free to play around
    with those numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the code above is pretty self-explanatory: we pass in a label
    for the input element, specify the minimum value, the maximum value, the default
    value, and of course the increment step.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, the interface looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/aa22b4acfb8795612313838fb2e8b8e6.png)'
  prefs: []
  type: TYPE_IMG
- en: Application interface up until now. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: Great!
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s add a button so that we only run the function to return the predictions
    once the user has set both the target and the horizon. Otherwise, Streamlit runs
    the entire script as soon as a change is registered.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And we get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7a518fec3ff9f314b7173c642113718b.png)'
  prefs: []
  type: TYPE_IMG
- en: Same as before, but with a button. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: Alright, the interface is in place, now let’s code the logic to select the best
    model and generate predictions.
  prefs: []
  type: TYPE_NORMAL
- en: Generate predictions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the user has set the target and horizon, we want to test different models
    so that we get the best forecasts possible according to the target and horizon.
  prefs: []
  type: TYPE_NORMAL
- en: Then, it would be useful to plot the predictions and also display the evaluation
    metrics that justify the choice of the model. This is what we implement in this
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Procedure for model selection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this application, we will test three different models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Autoregressive model](https://www.datasciencewithmarco.com/blog/time-series-forecasting-with-autoregressive-processes)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Double exponential smoothing](/the-complete-guide-to-time-series-analysis-and-forecasting-70d476bfe775)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Theta model](https://www.datasciencewithmarco.com/blog/theta-model-for-time-series-forecasting)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Detailing each model would be too long, so I have linked to other articles if
    you would like to explore each one of them in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Now, for each model, we will train it on a training set and evaluate it on a
    test set. The test set will contain the last 32 timesteps of the data, and the
    rest will be for training.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we will make rolling predictions, such as to simulate the process of updating
    the model with new data and making new predictions. This means that if the horizon
    is set to 2 timesteps, then the model will forecast 2 future timesteps at a time,
    until it has predicted the entire test set, as shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d687c88ae4bd1e3ec07f2d1da57dc83d.png)'
  prefs: []
  type: TYPE_IMG
- en: Visualizing rolling forecasts. The model is trained on an initial training set
    and makes predictions. Then, the training is updated and the model makes another
    of set predictions until the entire test set is covered. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: All of this logic is translated into the code block below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the code block above, we simply take each model, train it on the initial
    training set, and complete the loop by updating the training set and making predictions
    until we have predictions for the entire test set.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluation metric
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To select the best model, we use the symmetric mean absolute percentage error
    or sMAPE. The reason for that is that the MAPE tends to favor models that *under-forecast*.
    The sMAPE fixes that problem and is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/26ad5e44c6937dc76a6f0ff215f170fe.png)'
  prefs: []
  type: TYPE_IMG
- en: Formula for the sMAPE. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s define a function to calculate the sMAPE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Select the best model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s get started on the function that will run the model selection procedure.
    It takes in the dataset, the target and horizon, and we start off by defining
    the training and test sets.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Then, we use our `rolling_predictions` function to generate the predictions
    over the test set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have all the predictions for the entire test set, we can evaluate
    each model using the sMAPE.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Then, the best model is simply the one that achieves the lowest sMAPE.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Then, we can simply use the best model to get the predictions.
  prefs: []
  type: TYPE_NORMAL
- en: Make predictions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Depending on which model achieved the lowest sMAPE, we will train it on the
    entire dataset to generate out-of-sample predictions and actually predict the
    future.
  prefs: []
  type: TYPE_NORMAL
- en: This can be done with simple if statements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Then, our `test_and_predict` function will return the predictions and the sMAPE
    for each model. That way, we can visualize both the predictions and the evaluation
    metric for each model.
  prefs: []
  type: TYPE_NORMAL
- en: The full function is shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Get predictions when the button is clicked
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have the interface and we have all the logic to test and generate predictions.
    Now, we only have to connect them.
  prefs: []
  type: TYPE_NORMAL
- en: We can detect if the button was clicked with an if statement, as Streamlit return
    `True` when the button is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note that in the code block above,`target`, and `horizon` are variables defined
    earlier in this article that capture the information set by the user using a dropdown
    menu and a slider respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, inside the if statement, we generate two plots: one for the forecast
    and the other for the evaluation metric.'
  prefs: []
  type: TYPE_NORMAL
- en: Plotting in Streamlit is just like using `matplotlib` in a Jupyter notebook.
    We simply render the plot using the `pyplot` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the code block above is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2b121c44ff8cf4dce0d6d07bcfa4ea7d.png)'
  prefs: []
  type: TYPE_IMG
- en: Showing the predictions from the best model. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the user selected Canada as the target and a horizon of 16 quarters.
    After clicking the button, the plot is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Then, let’s plot a bar plot to see which model performed best during the testing
    procedure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/75e3b12ffd894e2b300b40f29b46daef.png)'
  prefs: []
  type: TYPE_IMG
- en: Showing the sMAPE of each model. Here, the AR model achieved the lowest sMAPE
    when tested for predicting the population of Canada on a horizon of 16 quarters.
    Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: From the figure above, we see that the AR model is the best model, as it achieved
    the lowest sMAPE, specifically for predicting the quarterly population of Canada
    over the next 16 quarters. Therefore, the AR model was used to make the out-of-sample
    predictions that we see in the line plot above.
  prefs: []
  type: TYPE_NORMAL
- en: Awesome, everything works great on our local machine, so let’s actually deploy
    this and share it with the world!
  prefs: []
  type: TYPE_NORMAL
- en: Deploy to production
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The easiest (and free) way of deploying a Streamlit application is by using
    the [Streamlit Community Cloud](https://streamlit.io/cloud).
  prefs: []
  type: TYPE_NORMAL
- en: 'To deploy an application, you need:'
  prefs: []
  type: TYPE_NORMAL
- en: A GitHub account to host the source code of your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Streamlit Community Cloud account (free)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `requirements.txt` file to list the dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List the dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The hardest of deploying a Streamlit application is actually listing the dependencies,
    especially if your work on a Windows machine with Anaconda (like I do).
  prefs: []
  type: TYPE_NORMAL
- en: If you are on Linux, then it is as simple as `pip freeze > requirements.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, the documentation of Streamlit states that they support
    the `environment.yml` file that you can generate with Anaconda, but I found that
    it breaks the deployment process. So, you need to resort to the .txt file.
  prefs: []
  type: TYPE_NORMAL
- en: With Anaconda, run `conda list -e > requirements.txt`. However, your file will
    not be formatted correctly and it will have a lot of mistakes, that you need to
    fix by hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple way of fixing it is to get rid of everything but the packages that
    you actually import at the beginning of the your script. In our case, that would
    be:'
  prefs: []
  type: TYPE_NORMAL
- en: pandas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: numpy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: matplotlib
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: statsmodels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everything else in your file can be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Also, it is very important to delete `streamlit` from your dependencies, as
    this will break the deployment process. You can see what your file should look
    like [here](https://github.com/marcopeix/streamlit-population-canada/blob/master/requirements.txt).
  prefs: []
  type: TYPE_NORMAL
- en: Launch to production
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have the dependencies listed, make sure that all the code is in a GitHub
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: Then, in your Streamlit Community Cloud account, click “New app”.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0dc0db43b8784199b3e0f2be618219ec.png)'
  prefs: []
  type: TYPE_IMG
- en: Streamlit Community Cloud interace. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: Then, simply specify the URL for the repository, the branch (should be master)
    and the main file path. Usually, you have a main Python script at the root of
    your project.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a9f2307f350fad8bce09e501a7cbf55c.png)'
  prefs: []
  type: TYPE_IMG
- en: Form to deploy a Streamlit application. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: Then, simply click “Deploy” and that’s it! You will then have a link that you
    can use to share your application with everyone!
  prefs: []
  type: TYPE_NORMAL
- en: Again, if you want to see the full final result, you check the application [here](https://marcopeix-streamlit-population-canada-main-4rr347.streamlit.app/)!
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying a model using Streamlit is intuitive and straightforward. Using only
    Python, we managed to create an interactive web interface that can cache data,
    read user input, run a model and generate predictions for the future!
  prefs: []
  type: TYPE_NORMAL
- en: I hope that this article inspires you to dig further into Streamlit and make
    a little application of your own!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to master time series forecasting, then checkout my course: [Applied
    Time Series Forecasting in Python](https://www.datasciencewithmarco.com/offers/zTAs2hi6/checkout?coupon_code=ATSFP10).
    This is the only course that implements statistical, deep learning, and state-of-the-art
    models in 15 guided hands-on projects.'
  prefs: []
  type: TYPE_NORMAL
- en: Cheers 🍻
  prefs: []
  type: TYPE_NORMAL
- en: Support me
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enjoying my work? Show your support with [Buy me a coffee](http://buymeacoffee.com/dswm),
    a simple way for you to encourage me, and I get to enjoy a cup of coffee! If you
    feel like it, just click the button below 👇
  prefs: []
  type: TYPE_NORMAL
- en: '[![](../Images/7ad9438bd50b1698fdd722fa6661b16c.png)](http://buymeacoffee.com/dswm)'
  prefs: []
  type: TYPE_NORMAL
