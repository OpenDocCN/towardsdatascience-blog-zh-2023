- en: 'Python Classes Made Easy: The Definitive Guide to Object-Oriented Programming'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/python-classes-made-easy-the-definitive-guide-to-object-oriented-programming-881ed609fb6](https://towardsdatascience.com/python-classes-made-easy-the-definitive-guide-to-object-oriented-programming-881ed609fb6)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Boost your Python skills with this comprehensive class reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://federicotrotta.medium.com/?source=post_page-----881ed609fb6--------------------------------)[![Federico
    Trotta](../Images/e997e3a96940c16ab5071629016d82fd.png)](https://federicotrotta.medium.com/?source=post_page-----881ed609fb6--------------------------------)[](https://towardsdatascience.com/?source=post_page-----881ed609fb6--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----881ed609fb6--------------------------------)
    [Federico Trotta](https://federicotrotta.medium.com/?source=post_page-----881ed609fb6--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----881ed609fb6--------------------------------)
    ·18 min read·Mar 13, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/243dd67262bbc8d50ada6050e9cb8725.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by [Lukas Bieri](https://pixabay.com/it/users/lukasbieri-4664461/?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=2838945)
    on [Pixabay](https://pixabay.com/it//?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=2838945)
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to classes, many Python developers struggle, for a lot of reasons.
    Firstly — in my opinion — because the concept of Object Oriented Programming is
    not always clear. Secondly, because the ideas behind classes and Object Oriented
    Programming (OOP) are a lot and the explanations we may find here and there (mainly,
    online) may be superficial.
  prefs: []
  type: TYPE_NORMAL
- en: In this article, I want to cover the most important concepts behind Python classes,
    and how to use them (with coding examples).
  prefs: []
  type: TYPE_NORMAL
- en: But, firstly, we’ll start this article by discussing Object Oriented Programming.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Object Oriented Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Quoting and paraphrasing reference [1], we can say that, as Humans, we are
    perfectly aware of what objects are: they are everything tangible that can be
    felt with our senses and that can be manipulated. During our growth, we learn
    the power of abstraction and objects become models. In other words, we use our
    imagination, developed in years of experience, to simplify complex problems using
    simple concepts: this is the process of abstraction using models.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, we may model the Earth as a sphere (even if it is not a sphere!)
    to perform some calculations (for example, to determine its orbit).
  prefs: []
  type: TYPE_NORMAL
- en: This is not so much different from what we do in software development. In fact,
    for us developers, an object is not something that we can touch or feel, but it
    is a model of something that performs some software tasks.
  prefs: []
  type: TYPE_NORMAL
- en: More precisely, for us, we can say that an “**object is a collection of data
    with associated behaviors”**. [1]
  prefs: []
  type: TYPE_NORMAL
- en: Let’s make an example to clarify the concept (we paraphrase reference [1] for
    the following example).
  prefs: []
  type: TYPE_NORMAL
- en: We want to create an object called “Apple”. In this case, the data associated
    with it can be the color (for example, red). The behavior associated with it can
    be the fact that we want to put the apple in a basket.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e2889484a0f35e62ba4d355c627d85c1.png)'
  prefs: []
  type: TYPE_IMG
- en: An object in software development. Image by Author.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, what if we encounter a green apple? It is still an apple, but with a different
    color: can we use this concept? Here’s where classes come into help!'
  prefs: []
  type: TYPE_NORMAL
- en: A class is a “template” that defines the structure of an object. This means
    that an object has its own particular set of attributes, regarding a certain class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the example of the apple, we can say that the class Apple can have:'
  prefs: []
  type: TYPE_NORMAL
- en: Data → the color
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behavior → where to put the apple
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this template, we can create how many objects we want. For example, we
    can create the object `Apple_green`that uses the class apple with `color=green`
    as data, and that puts the apples in the basket on the table.
  prefs: []
  type: TYPE_NORMAL
- en: We can also have an object called `Apple_red` that uses the class apple with
    `color=red` as data and that puts the apples back on the shelf.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/207782f109e88953cecbec06ec522b17.png)'
  prefs: []
  type: TYPE_IMG
- en: The difference between an object and a class. Image by Author.
  prefs: []
  type: TYPE_NORMAL
- en: So, as we can understand with the example of the apples, we can say that data
    represent a specific characteristic of a certain object.
  prefs: []
  type: TYPE_NORMAL
- en: Behaviors, on the other hand, represent actions; these actions are expressed
    as methods of the class, in Python. And, as we’ll see later, a method of a class
    is defined the same way we define a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'So: what is Object Oriented Programming?'
  prefs: []
  type: TYPE_NORMAL
- en: OOP is “the practice of writing code towards modeling object” [1].
  prefs: []
  type: TYPE_NORMAL
- en: In other words, it means creating a series of interacting objects through their
    data and behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'This does not mean that we’ll always have to create classes when we program
    in Python. Here we have to understand a simple concept: the power of Python relies
    on the fact that **everything** in this programming language **is an object**.
    In fact, even if we can’t see it, we are working with objects and classes under
    the hood in Python.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s say we define a variable`a = 3`. If we want to see its type
    we can write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We have used the built-in function `type()` to determine the properties of the
    variable `a` and it told us that this is an `int` (that is to say, an integer).
    But `int` is a Python built-in class; this means that in Python we can define
    an integer variable, as we have seen above, without creating an actual class because
    Python does so for us (in other programming languages, we’d actually have to create
    a class for such a simple example).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s remember: whenever we program in Python, we always have to deal with
    objects and classes even if we don''t explicitly declare them because Python,
    under the hood, does the work to invoke built-in classes.'
  prefs: []
  type: TYPE_NORMAL
- en: Classes in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Python, classes must be defined with a capital letter. Here’s how we can
    define a simple class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We have created a simple class that sets `a=15`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s make a class that actually does something more useful by adding
    a method (note: the class `Point` we’ll use throughout this article is taken from
    reference [1], and is modified as per my taste and needs):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we’ve created a class called `Point`with a method, called `origin`, that
    does a simple thing: it gets a point in 2D to `x=0`and `y=0` (the origin).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, as we can see, the method passes one argument called `self`. This can
    be called as we want but, as a standard, the community of Python developers calls
    it `self`: we’ll explain more details later on how it works.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we want to invoke the class, we can define a point `p` and do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can access the method defined in the class by writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'So, now our point has gone to the origin. To be sure, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The “self” Parameter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let’s explain what the previously introduced `self` argument is, and how
    to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `self` argument serves to invoke the method. This is why we call it `self`
    as a standard: because we are invoking the method. It’s like we are telling Python:
    “Ehy! This method is self-invoked”.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we need to pass multiple arguments to a method, `self` must be the first
    one: otherwise, another parameter will invoke the method (as we said, there is
    no need to call it `self`: this name is just a convention between developers).'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see an example where we use `self` and compare it to another where we
    don’t use it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we’ve created a simple class that, when we invoke the method `printing`,
    prints “this is a test”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s see the example without `self`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'So, in this case, Python returns an error that is telling us a simple thing:
    the method can’t be invoked because it has no arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: This is why we need `self`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s create a function with multiple arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We have created a class that:'
  prefs: []
  type: TYPE_NORMAL
- en: moves two coordinates (`x`and `y`). As we can see, `self` invokes the method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: gets the coordinates to the origin. When we invoke the `origin` method, in fact,
    it will move both the coordinates (its only argument is `self`) to the origin
    ( `self.move(0, 0)`), and returns the coordinates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, we can invoke the class and move the coordinates to the origin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: And the coordinates have gone to the origin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s read some lines back: we said that the `move`method moves the coordinates,
    but this is not true. The actual movement is done by the method `origin`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, the `move` method does just a simple thing: it invokes the needed
    values. This is why the first method of a class has a special nomenclature.'
  prefs: []
  type: TYPE_NORMAL
- en: The “__init__” Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have created a class that moves the coordinates of a point (`x` and
    `y`) to the origin. But what if we want to move the point to any particular position
    we may want?
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we have to create another class. For our first try, let’s create
    it with the same logic used before. It can be something like that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s invoke the class and the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: And…we’ve got an error! And it tells us that the class `Point`takes no argument.
    How is that possible? We have specified to pass `self`, `x`, and `y`; so, apart
    from `self` that invokes the method, the class should accept two values!
  prefs: []
  type: TYPE_NORMAL
- en: 'The error is in the first method. As we’ve said in the previous paragraph,
    the first method does only one thing: it invokes the needed values. It doesn’t
    move the point to a specific location.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the reason why the first method of a class must be a specific method
    called `__init__`. So, to properly invoke the needed values, we have to create
    the `Point`class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s invoke it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: And here we are!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If __name__ == ”__main__”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, at the end of some classes, we may have found `if __name__ == "__main__"`.
    If you don’t know what it is, here is a wide explanation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quoting and paraphrasing from [2]:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__name__` is a special built-in variable we have to use when we create interactable
    modules because it allows us to make a distinction between the modules we import
    and the modules we don’t.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: By module, in Python, we intend packages and libraries, but even any piece of
    code that is separable from other code and that can work on its own. Given that
    classes (but even functions, or even any Python file) can work on their own, they
    can be considered modules.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`__main__`, on the other hand, is a special module that represents the name
    of the top-level code in a script or program.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So, basically, if we execute `if __name__ = "__main__"` we are checking if the
    code we are executing is top-level or not.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So, what is top-level code?
  prefs: []
  type: TYPE_NORMAL
- en: 'We take a very explanatory example from [this thread](https://stackoverflow.com/questions/18138166/what-is-a-top-level-statement-in-python)
    in StackOverflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Well, as we can see, the problem is related to the Python interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: Let me explain.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a module is been executed on its own, then there is no problem. The problems
    arrive **when a module is imported into another Python file**. Suppose that the
    above script is imported in another file: when we import it, it immediately executes
    all the top-level code and all the code that is part of an `if`or a class statement,
    as the comments in the above snippet of code tell us.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see it in more detail, with an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a Python file called `package_1.py` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute it via terminal, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/12f52336e1c663c6204b14da38236b55.png)'
  prefs: []
  type: TYPE_IMG
- en: The execution of the package_1.py file. Image by Author.
  prefs: []
  type: TYPE_NORMAL
- en: So, it perfectly works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s create a Python file called `main.py` and import into it the `package_1.py`
    file, then run `main.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6c622d96b060618fda2c0d990cb0e78a.png)'
  prefs: []
  type: TYPE_IMG
- en: The execution of the main.py file. Image by Author.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, when `main.py`is run, the module `package_1.py`is immediately
    executed! This is something we don’t want for a simple reason: we want to use
    the code we import from a module when we actually call the code. In other words:
    if a whole module executes the code immediately after it is imported, it’s not
    useful at all.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid that, we use `if __name__ = "__main__"` in our `package_1.py` and,
    after it, we invoke the `print_hello()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d58134082df75c4f8647567414572901.png)'
  prefs: []
  type: TYPE_IMG
- en: The execution of the main.py file using ‘if __name__ == “__main__”’. Image by
    Author.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, as [2] tells us:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if __name__ = "__main__"` prevents the automatic execution of the top-level
    code when a module is executed.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Also, previously we invoked the `print_hello()` function in the `package_1.py`
    file because we wanted the function to actually work when we run the program on
    its own. Now, invoking `print_hello()` after `if __name__ = "__main__"` will invoke
    the function when `package_1.py` is run on its own.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to recap and clarify using this example, if we invoke `print_hello()`after
    `if __name__ = "__main__"` in `package_1.py` :'
  prefs: []
  type: TYPE_NORMAL
- en: '`print_hello()` will be executed when `package_1.py` is run on its own (i.e.,
    via terminal).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print_hello()` will not be executed when we run `main.py`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Type Hints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting from Python 3, “[PEP 484 — Type Hints](https://peps.python.org/pep-0484/)”
    has introduced type hints in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Hitting a type means suggesting the type to pass to a function (or to a method,
    in the case of classes). We all know that comments and docstrings must do their
    work, but typing hints really help us understand what to expect in functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s make a simple example. Let’s create a function that returns a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we have created a function that takes one argument (called `variable`)
    and the type hints tell us that:'
  prefs: []
  type: TYPE_NORMAL
- en: the type of variable can be any. A string, an integer, etc…
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the function returns any type (and, in fact, it returns `variable`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t you find it useful? Well, I discovered it some weeks ago and find it amazing!
    Especially, this becomes interesting with more complicated examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s say we want a function that gets a list as an argument and
    returns the count of how many elements are in the list. The function can be like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: So, here our function takes `element` as the only argument, and we know that
    it must be a list of any type, thanks to type hints. Then, the function returns
    an integer as type; in fact, it counts the number of elements in the list.
  prefs: []
  type: TYPE_NORMAL
- en: So, we believe the point is clear. This is a very good implementation for improving
    the readability of our code.
  prefs: []
  type: TYPE_NORMAL
- en: Docstrings (and how to invoke them)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Documentation is the most important part of every software project for a simple
    reason: in the next two months we’ll barely remember what we have done, and why.'
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, writing notes and explanations of our code is very important.
    Unfortunately, comments are not enough because they have to be very short (but
    explanative).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what we can do is use docstrings. [PEP 257](https://peps.python.org/pep-0257/)
    specifies that:'
  prefs: []
  type: TYPE_NORMAL
- en: A docstring is a string literal that occurs as the first statement in a module,
    function, class, or method definition. Such a docstring becomes the `__doc__`
    special attribute of that object.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: All modules should normally have docstrings, and all functions and classes exported
    by a module should also have docstrings. Public methods (including the `__init__`
    constructor) should also have docstrings. A package may be documented in the module
    docstring of the `__init__.py` file in the package directory.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In other words, in software development, a docstring is a string type in the
    code that documents the code itself. As reference [1] tells us, “unlike comments,
    docstrings are available at runtime, simplifying code inspection and providing
    help or metadata during execution”.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how to use docstrings in a Python class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To access the documentation (aka, the docstrings) we type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: So, this is how we can access the docstrings related to a class. What if we
    want to access the docstring of a particular method of a class?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'And to access the documentation of the `position` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: And here we are.
  prefs: []
  type: TYPE_NORMAL
- en: 'But we actually can (and should!) do better. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This may seem redundant since we have used type hints, but it is not because:'
  prefs: []
  type: TYPE_NORMAL
- en: we may need, in a first attempt, to just invoke the documentation of our class
    (maybe because we have imported it as a module in another file).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: we may use tools (like [Sphinx](https://www.sphinx-doc.org/en/master/), for
    example) to create the documentation in HTML; these tools use directly the docstrings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is why using very explanatory docstrings is very important.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here we want to talk about a Python magic: **inheritance**.'
  prefs: []
  type: TYPE_NORMAL
- en: As we’ve said before, OOP is the methodology to develop code with objects interacting
    between them. This means that when we create classes in Python we often have to
    make them interact.
  prefs: []
  type: TYPE_NORMAL
- en: When interacting, classes inherit the properties and functionalities of other
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes: it’s like your old aunt decides to leave you her 21 billion $ (who hasn’t
    such an aunt?!).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, firstly we have to say that every class we create uses inheritance. This
    happens because, as we’ve said before, Python uses built-in classes. So, when
    we invoke built-in classes, our code is inheriting the properties of the invoked
    built-in class or object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s see inheritance in action, with a practical example (note: I have
    taken the following classes from reference [1], and modified them as per my taste
    and needs).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to create a class that stores the name and the surname of some contacts,
    populating an empty list. We can create something like that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s try it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, suppose we want to collect the email of the contacts but, for any reason,
    we want to create a separate class. We can create a class like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s add an email like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we invoke `Contact.all_contacts` we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: So, since our class `Email` has the class `Contact` as an argument, **it inherits
    its properties**. For example, the arguments passed to the `Email` class are appended
    to the list in the class `Contact`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, this class inherits the fact that the `__init()__` method requires two
    arguments. In fact, this is what we get with just one argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: But, hey, wait!!! We haven’t used the `__init()__` method in the class `Email`,
    so what happened?
  prefs: []
  type: TYPE_NORMAL
- en: It happened that the class `Email` inherited the `__init()__` method, so there
    is no need to use it again!
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to use another `__init()__` method in the child class (`Email` is
    a child class), we must make some adjustments like the following ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'And it works exactly like the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: So, the classes `Email` and `General` work exactly the same way and give us
    exactly the same results, but the power of inheritance shows us that without using
    the `__init()__`, method as we did with `Email`, the code is simplified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, as we can see, in the case of the `General` class, we have used the `super.__init()__`
    method: we must use it in the case of a child class, because it initializes the
    inherited attributes of the parent class (`Contact`).'
  prefs: []
  type: TYPE_NORMAL
- en: Pro tip on how to use Python classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you came across this article because you struggle understanding classes,
    chances are that you don’t have a clear idea of why you should use them. If it
    is so, welcome to the club: I had the same struggle.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I mean: I understood that classes (and, of course, functions) help us automatize
    our code, but the fact that we have to invoke them created some difficulties for
    me.'
  prefs: []
  type: TYPE_NORMAL
- en: This happened to me because I’ve started studying Python for Data Science (and
    here’re are my tips on how to properly do so) and, saying the truth, in many cases,
    there is no reason to use classes when we use Python for Data Science.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, my advice to properly understand the need to use classes is to treat them
    as modules. This means that, when you want to start a new Python project, a piece
    of very good advice is to create a `main.py` file where you invoke all the classes
    you need; anyway, these classes shouldn''t be created in the `main.py`: they should
    be created in separate Python files (usually, we create one Python file for each
    class) and imported in the `main.py` where we use them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, so far we’ve talked about modules. Here’s an article I’ve written to
    cover this topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/mastering-modular-programming-how-to-take-your-python-skills-to-the-next-level-ba14339e8429?source=post_page-----881ed609fb6--------------------------------)
    [## Mastering Modular Programming: How to Take Your Python Skills to the Next
    Level'
  prefs: []
  type: TYPE_NORMAL
- en: Best Practices for Writing Modular Python Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/mastering-modular-programming-how-to-take-your-python-skills-to-the-next-level-ba14339e8429?source=post_page-----881ed609fb6--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Conclusions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this article, we’ve seen a comprehensive guide on classes, hoping it clarifies
    the main topics on it.
  prefs: []
  type: TYPE_NORMAL
- en: The only thing that you have to do now is to practice a lot with classes, hoping
    this guide will help you when you need it.
  prefs: []
  type: TYPE_NORMAL
- en: '**FREE PYTHON EBOOK:**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Started learning Python Data Science but struggling with it? [***Subscribe
    to my newsletter and get my free ebook: this will give you the right learning
    path to follow to learn Python for Data Science with hands-on experience.***](https://federico-trotta.ck.page/a3970f33f4)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enjoyed the story? Become a Medium member for 5$/month [through my referral
    link](https://medium.com/@federicotrotta/membership): I’ll earn a small commission
    to no additional fee to you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/@federicotrotta/membership?source=post_page-----881ed609fb6--------------------------------)
    [## Join Medium with my referral link — Federico Trotta'
  prefs: []
  type: TYPE_NORMAL
- en: Read every story from Federico Trotta (and thousands of other writers on Medium).
    Your membership fee directly supports…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/@federicotrotta/membership?source=post_page-----881ed609fb6--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: '*Bibliography and videography:*'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] Python Object-Oriented Programming — S.F. Lott, D. Phillips'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] If __name__ == “__main__” for Python Developers ([video](https://www.youtube.com/watch?v=NB5LGzmSiCs))'
  prefs: []
  type: TYPE_NORMAL
