- en: 4 Pandas One-Liners That Solve Particular Tasks Efficiently
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/4-pandas-one-liners-that-surprised-me-in-a-good-way-b67955211f81](https://towardsdatascience.com/4-pandas-one-liners-that-surprised-me-in-a-good-way-b67955211f81)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Complex tasks completed in a quick and simple way
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://sonery.medium.com/?source=post_page-----b67955211f81--------------------------------)[![Soner
    Yıldırım](../Images/c589572e9d1ee176cd4f5a0008173f1b.png)](https://sonery.medium.com/?source=post_page-----b67955211f81--------------------------------)[](https://towardsdatascience.com/?source=post_page-----b67955211f81--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----b67955211f81--------------------------------)
    [Soner Yıldırım](https://sonery.medium.com/?source=post_page-----b67955211f81--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----b67955211f81--------------------------------)
    ·5 min read·Nov 23, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5569fc0f11be8364c66846bfb0609968.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Tom Bradley](https://unsplash.com/@tomrootstudio?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash)
    on [Unsplash](https://unsplash.com/photos/brown-squirrel-on-green-grass-during-daytime-Z-ns9qAcvl4?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash)
  prefs: []
  type: TYPE_NORMAL
- en: Third-party libraries are created and developed in response to a need. No one
    sits down and says “I’m gonna create a tool and wait for circumstances to arise
    in which others need it”. Instead, they realize a problem and think of a solution
    to help solve it. That’s how tools are created.
  prefs: []
  type: TYPE_NORMAL
- en: The same goes for adding new features to existing tools. How well and quickly
    new features are added depends on the popularity of the tool and the team behind
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Pandas, for sure, has a highly active community that keeps Pandas as one of
    the most popular data analysis and cleaning libraries in the data science ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Pandas has functions to solve very specific issues and use cases. These must
    have been demanded from the community who are actively using it.
  prefs: []
  type: TYPE_NORMAL
- en: In this article, I’ll share 4 operations that you can do in one line of code
    with Pandas. These helped me solve particular tasks efficiently and surprised
    me in a good way.
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Create a dictionary from a list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I have a list of items and I want to see the distribution of them. To be more
    specific, I want to see the unique values along with their number of occurrences
    in the list.
  prefs: []
  type: TYPE_NORMAL
- en: A Python dictionary is a great way to store data in this format. The items would
    be the dictionary keys and number of occurrences would be the values.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the `value_counts` and `to_dict` functions, this task can be completed
    in one line of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example to demonstrate this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We first convert the list to a Pandas Series, which is the one-dimensional data
    structure of Pandas. Then, we apply the `value_counts` function to get the unique
    values with their frequency in the Series. Finally, we convert the output to a
    dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Create a DataFrame from a JSON file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSON is a frequently used file format for storing and delivering data. For instance,
    when you request data from an API, it’s highly likely to be delivered in JSON.
  prefs: []
  type: TYPE_NORMAL
- en: When we clean, process, or analyze data, we usually prefer it to be in tabular
    format (i.e. in a table-like data structure). We can create a Pandas DataFrame
    from a JSON-formatted object with a single operation thanks to the `json_normalize`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say the data is stored in a JSON file called `data.json` . We first read
    it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If we pass this variable to the DataFrame constructor, it’ll create a DataFrame
    as follows, which is definitely not a usable format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/2ac39c06795fa69c508251ff2fba93f3.png)'
  prefs: []
  type: TYPE_IMG
- en: df (image by author)
  prefs: []
  type: TYPE_NORMAL
- en: 'But if we use the `json_normalize` function and provide the record path, we’ll
    get a DataFrame in nice and clean format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/f54adad98e37b03455dd5e31b8f388fc.png)'
  prefs: []
  type: TYPE_IMG
- en: df (image by author)
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Explode function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consider a case where you have a list of items that match a particular record.
    You need to reformat it in a way that there is a separate row for each item in
    that list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following drawing illustrates what I tried to explain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/347fc5df4fa22374320ceff798e524a4.png)'
  prefs: []
  type: TYPE_IMG
- en: (image by author)
  prefs: []
  type: TYPE_NORMAL
- en: You can think of many different ways of solving this task. One of the simplest
    (may be the simplest) is the `explode` function. Let’s see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the following DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ae95d917871c615a345df60e29aed647.png)'
  prefs: []
  type: TYPE_IMG
- en: df (image by author)
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use the `explode` function and specify the column name to be exploded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/017148d21da9f19eea24b9e72176fb88.png)'
  prefs: []
  type: TYPE_IMG
- en: df_new (image by author)
  prefs: []
  type: TYPE_NORMAL
- en: The `reset_index` assigns a new integer index to the resulting DataFrame. Otherwise,
    the index before exploding would be preserved (i.e. all the rows with a key value
    of A would have an index of 0).
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Combine first
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `combine_first` function serves for a specific purpose but simplifies that
    specific task greatly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The specific case where you’d want to use the `combine_first` function:'
  prefs: []
  type: TYPE_NORMAL
- en: You want to extract a column from a DataFrame. If there are missing values in
    the column, you want to replace those missing values with a value from another
    column.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this regard, it does the same thing as the `COALESCE` function in SQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a sample DataFrame with some missing values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/f0ad46e4f43caf9569dc6a1ab205f110.png)'
  prefs: []
  type: TYPE_IMG
- en: df (image by author)
  prefs: []
  type: TYPE_NORMAL
- en: We need the data in column A. If there is a row with a missing value (i.e. NaN),
    we want it to be filled with the value of the same row in column B.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As we see in the output, the first and last rows of column A are taken from
    column B.
  prefs: []
  type: TYPE_NORMAL
- en: If there are 3 columns that we want to use, we can chain `combine_first` functions.
    The following line of code first checks column A. If there is a missing value,
    it takes it from column B. If the corresponding row in column B is also NaN, then
    it takes the value from column C.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can also use the `combine_first` function on the DataFrame level. In that
    case, all the missing values are filled from the corresponding value (i.e. same
    row, same column) from the second DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: Final words
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pandas is one of the most versatile tools I’ve ever used. From calculating simple
    statistics to highly complex data cleaning processes, Pandas always helped me
    get a quick solution for the tasks I had. The only issue I had was when working
    with very large datasets, which seemed to be the only shortcoming of Pandas. However,
    there have been some developments recently to make Pandas operate more efficiently
    with large datasets. This is I believe good news for everyone who loves to work
    with this great tool.
  prefs: []
  type: TYPE_NORMAL
- en: Thank you for reading. Please let me know if you have any feedback.
  prefs: []
  type: TYPE_NORMAL
