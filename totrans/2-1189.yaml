- en: How to Generate and Evaluate the Performance of Knowledge Graph Embeddings?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/how-to-generate-and-evaluate-the-performance-of-knowledge-graph-embeddings-95789abcb0c1](https://towardsdatascience.com/how-to-generate-and-evaluate-the-performance-of-knowledge-graph-embeddings-95789abcb0c1)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A detailed guide to knowledge graph embedding training and evaluation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@rohithtejam?source=post_page-----95789abcb0c1--------------------------------)[![Rohith
    Teja](../Images/3b83438350f3eb69309b9abf715d6ee7.png)](https://medium.com/@rohithtejam?source=post_page-----95789abcb0c1--------------------------------)[](https://towardsdatascience.com/?source=post_page-----95789abcb0c1--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----95789abcb0c1--------------------------------)
    [Rohith Teja](https://medium.com/@rohithtejam?source=post_page-----95789abcb0c1--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----95789abcb0c1--------------------------------)
    ·7 min read·Apr 10, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d8b56187761abee2d42e0d8a1cba1a51.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Alina Grubnyak](https://unsplash.com/it/@alinnnaaaa?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
    on [Unsplash](https://unsplash.com/s/photos/network?orientation=landscape&utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you start with this article, I assume you have some brief idea about
    knowledge graph embeddings. If not, I suggest you check the following article,
    which gives you a good idea about the concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/knowledge-graph-embedding-a-simplified-version-e6b0a03d373d?source=post_page-----95789abcb0c1--------------------------------)
    [## Knowledge Graph Embedding — A Simplified Version!'
  prefs: []
  type: TYPE_NORMAL
- en: An explanation of what knowledge graph embeddings actually are and how to calculate
    them.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/knowledge-graph-embedding-a-simplified-version-e6b0a03d373d?source=post_page-----95789abcb0c1--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Now with this out of the way, in this article, I will show how you can generate
    knowledge graph embeddings, interpret them and also evaluate their performance
    on graph-based tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consider a knowledge graph of [countries](https://pykeen.readthedocs.io/en/stable/api/pykeen.datasets.Countries.html#pykeen.datasets.Countries).
    In this graph, we have the names of countries and regions as entities. The relations
    are represented by two properties, namely, “neighbor” and “locatedin”.
  prefs: []
  type: TYPE_NORMAL
- en: The graph is a built-in dataset of the PyKEEN Python library.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Check the following screenshot of the knowledge graph triples shown as a data
    frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/12d448b0ee72d590bb322777899be0ea.png)'
  prefs: []
  type: TYPE_IMG
- en: Knowledge graph triples (Image by Author)
  prefs: []
  type: TYPE_NORMAL
- en: 'The triples are in the form `(croatia, neighbor, serbia)` and `(denmark, locatedin,
    europe).` Below is a full visualization of the graph using the NetworkX Python
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/fa9ed7f4cbe1960153c09337113668b4.png)'
  prefs: []
  type: TYPE_IMG
- en: “Countries” knowledge graph (Image by Author)
  prefs: []
  type: TYPE_NORMAL
- en: The graph is big, so the visualization is not too clear. Let’s check a subgraph
    of this knowledge graph.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/22417ad004036e70d0a154465ec55f33.png)'
  prefs: []
  type: TYPE_IMG
- en: Subgraph of “Countries” knowledge graph (Image by Author)
  prefs: []
  type: TYPE_NORMAL
- en: The subgraph above clearly illustrates the triples, showing both the entities
    and relations.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have a knowledge graph. Let’s understand how to generate the knowledge
    graph embeddings using the [PyKEEN](https://pykeen.readthedocs.io/en/stable/)
    Python library.
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge graph embeddings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../Images/0ccc85fb032d94ca6f7da2a51dd69c24.png)'
  prefs: []
  type: TYPE_IMG
- en: Embedding visualization using PCA (Image by Author)
  prefs: []
  type: TYPE_NORMAL
- en: The above shown is a visualization of the knowledge graph embeddings trained
    using `TransR` algorithm. Observe how countries are bunched together. On the top
    of the visualization, we see Bosnia, Montenegro, and Albania close to each other.
    This indicates the embedding algorithm was able to club the countries with similar
    properties together.
  prefs: []
  type: TYPE_NORMAL
- en: The visualization is made using PCA, where the embedding size of 128 is reduced
    to a size of 2 dimensions. This might impact the accuracy of grouping the countries.
    Also, the embedding algorithm can be tuned to improve the performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code to generate the embeddings:'
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Read the data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Generate the embeddings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the code above, the `TriplesFactory` class provides a standardized representation
    of the triples in the knowledge graph. PyKEEN has different methods to read and
    manipulate triples. Also, to split the data into training, validation, and test
    sets. Here, I just split the data into train and test sets, as I am not performing
    any hyperparameter tuning.
  prefs: []
  type: TYPE_NORMAL
- en: I selected the `TransR` model and set the embedding dimension to 128 and epochs
    to 200.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Loss vs. Epochs plot looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1e1f03c7aca43c1562679bbf864a989e.png)'
  prefs: []
  type: TYPE_IMG
- en: Loss vs. Epochs (Image by Author)
  prefs: []
  type: TYPE_NORMAL
- en: The loss decreases until 100 epochs and then remains almost constant. 100 epochs
    would have been fine for this training process. Oh well!
  prefs: []
  type: TYPE_NORMAL
- en: Retrieve the embeddings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The training process is done, and now, we can retrieve the embeddings from the
    `result` object of PyKEEN’s `pipeline()` function. We learn embeddings for both
    entities and relations. These embeddings can be visualized using any dimensionality
    reduction methods like PCA or t-SNE (same as the visualization shown in the section
    above).
  prefs: []
  type: TYPE_NORMAL
- en: 'Below is the code to get embeddings after the training process is done:'
  prefs: []
  type: TYPE_NORMAL
- en: Entity embeddings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Relation embeddings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Evaluation of embeddings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen the generation of embeddings and also how to retrieve them. Now
    let’s check their performance on link prediction. Link prediction is a graph-based
    task that involves predicting missing or future links between nodes in a graph.
  prefs: []
  type: TYPE_NORMAL
- en: Check my [article](https://medium.com/towards-data-science/a-quick-note-on-graphs-and-the-formulation-of-their-downstream-tasks-d8a8c808c93f)
    that details graph-based tasks like link prediction and node classification.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: PyKEEN provides an easy way to perform the evaluation of a link prediction task.
  prefs: []
  type: TYPE_NORMAL
- en: I will create a data frame for train and test sets so that it is easier to understand
    the evaluation process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: I will use the scoring-based evaluation to perform the task of tail prediction
    (a variant of link prediction). The model has to predict the tail entity from
    the test set. I consider 3 cases to showcase the working of this evaluation process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Case 1: Mexico'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/32e5201edfc2c35f99f5405761d45482.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Tail prediction: Mexico (Image by Author)'
  prefs: []
  type: TYPE_NORMAL
- en: In the above image, we see that the model is trained on three triples involving
    `Mexico` as a head entity. The test set has one instance with the relation `neighbor.`
    Our objective is to correctly predict the tail entity of the test set, i.e., predict
    `united_states` from the triple `(mexico, neighbor, united_states).`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The above code block performs the tail prediction for the “missing” triple `(mexico,
    neighbor, **?**).`
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3a3e577611b2219fb8b7e333812f7a47.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Tail prediction: Mexico (Image by Author)'
  prefs: []
  type: TYPE_NORMAL
- en: In the output above, we see that the model ranks `belize`, `guatemala` and `united_states`
    as the top predictions based on a scoring-based method. `belize` and `guatemala`
    were already present in the training set, and the model correctly predicted `united_states`.
    Observe how the top-ranked predictions have a better score.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the use cases of the link prediction task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Case 2: Senegal'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/3b18abe745068325bd986e75be0feb5e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Tail prediction: Senegal (Image by Author)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we predict the tail of the test triple `(senegal, locatedin, **?**).`
    There is only one instance in the test set. The prediction is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8b34e617994ac585e146505d6076252e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Tail prediction: Senegal (Image by Author)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Case 3: Bhutan'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/071778591c3eca6a14e5f81bc6211f1b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Tail prediction: Bhutan (Image by Author)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, there are two instances in the test set. Let’s see the predictions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3d7507f495180f8a5b187fb35f652c58.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Tail prediction: Bhutan (Image by Author)'
  prefs: []
  type: TYPE_NORMAL
- en: The model correctly scores the first instance of tail prediction (`india`) but
    fails to score the second instance (`china`) in the top ranks. It successfully
    predicts the tail label but with low confidence.
  prefs: []
  type: TYPE_NORMAL
- en: This is because the model failed to perfectly capture the network relationship
    in the embeddings. Remember that I did not perform the hyperparameter optimization
    when training the model, which might have hampered the performance.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluation metrics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the above section, I showed a basic evaluation process. We have [rank-based
    evaluation](https://pykeen.readthedocs.io/en/stable/tutorial/understanding_evaluation.html)
    methods that quantify the model performance. The rank-based methods have several
    metrics, and one of the important metrics is mean rank.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mean rank is the average rank of the correct prediction across all test triples.
    In the above 3 cases, the mean rank can be calculated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Case 1: Rank = 4'
  prefs: []
  type: TYPE_NORMAL
- en: 'Case 2: Rank = 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'Case 3: Rank = 2 (first instance)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Case 3: Rank = 13 (second instance)'
  prefs: []
  type: TYPE_NORMAL
- en: Hence, the mean rank is `(4+2+2+13)/4` = 5.25
  prefs: []
  type: TYPE_NORMAL
- en: 'The mean rank for the entire test set is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/ed4e11b0886102dd1e16e2b66cc1f43a.png)'
  prefs: []
  type: TYPE_IMG
- en: Mean rank (Image by Author)
  prefs: []
  type: TYPE_NORMAL
- en: We performed a tail prediction in the above 3 cases. For the entire test set,
    the mean rank for tail prediction is around 7.2, which is not too shabby.
  prefs: []
  type: TYPE_NORMAL
- en: We have trained a decent knowledge graph embedding model!
  prefs: []
  type: TYPE_NORMAL
- en: Thanks for reading, and cheers!
  prefs: []
  type: TYPE_NORMAL
- en: '**Want to Connect?**'
  prefs: []
  type: TYPE_NORMAL
- en: Reach me at [LinkedIn](https://www.linkedin.com/in/rohithteja/), [Twitter](https://twitter.com/rohithtejam),
    [GitHub](https://github.com/rohithteja), or [Website](https://rohithteja.github.io/)!
  prefs: []
  type: TYPE_NORMAL
