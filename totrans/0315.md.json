["```py\nimport itertools\nimport math\nimport random\nfrom typing import Tuple\n\nimport networkx as nx\nimport networkx.algorithms.shortest_paths.dense as nxalg\n\nclass TSP:\n    \"\"\"\n    Creates a TSP problem with a certain number of nodes\n    \"\"\"\n    def __init__(self, nodes: int = 30, dimensions: Tuple[int, int] = (1000, 1000), seed: int = 5):\n        if seed:\n            random.seed(seed)\n\n        graph = nx.Graph()\n        nodes_dict = dict()\n\n        for i in range(nodes):\n            nodes_dict[i] = (random.randint(0, dimensions[0]), random.randint(0, dimensions[1]))\n            graph.add_node(i)\n\n        for i, j in itertools.permutations(range(nodes), 2):\n            graph.add_edge(i, j, weight=self.calculate_distance(nodes_dict[i], nodes_dict[j]))\n\n        self.graph = graph\n        self.nodes = nodes_dict\n        self.distance_matrix = nxalg.floyd_warshall_numpy(graph)\n\n    @staticmethod\n    def calculate_distance(i, j):\n        \"\"\"\n        Calculate the Euclidian distance between two nodes\n        \"\"\"\n        return int(math.sqrt((i[0] - j[0])**2 + (i[1] - j[1])**2))\n```", "```py\nimport datetime\nimport json\nimport logging\nimport random \nimport time\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom problem import TSP\n\nclass AntColonyOptimization:\n    \"\"\"\n    Ant colony optimization algorithm for finding the shortest route in a graph.\n\n    Parameters:\n        m = number of ants\n        k_max = number of iterations\n        alpha = pheromone importance\n        beta = distance importance\n        rho = pheromone evaporation rate\n        Q = pheromone deposit\n        tau = pheromone\n        eta = distance\n    \"\"\"\n    def __init__(self, problem, **kwargs):\n        self.graph = problem.graph\n        self.nodes = list(problem.nodes)\n        self.coordinates = list(problem.nodes.values())\n        self.n = len(self.nodes)\n        self.distance_matrix = problem.distance_matrix\n\n        self.m = kwargs.get(\"m\", 100)\n        self.k_max = kwargs.get(\"k_max\", 50)\n        self.alpha = kwargs.get(\"alpha\", 1)\n        self.beta = kwargs.get(\"beta\", 5)\n        self.rho = kwargs.get(\"rho\", 0.9)\n        self.Q = kwargs.get(\"Q\", 1)\n        self.time_limit = kwargs.get(\"time_limit\", 5)\n\n        # initialization of tau and eta\n        self.tau = np.full(self.distance_matrix.shape, 0.1)\n        self.eta = 1 / (self.distance_matrix + 1e-10)\n\n        self.history = []\n\n    def ant_colony_optimization(self):\n        \"\"\"\n        Ant colony optimization algorithm\n        \"\"\"\n        start_time = time.time()\n        x_best, y_best = [], float(\"inf\")\n        for _ in range(self.k_max):\n            self.edge_attractiveness()\n            self.tau *= (1-self.rho)\n            for _ in range(self.m):\n                x_best, y_best = self.ant_walk(x_best, y_best)\n                if time.time() - start_time > self.time_limit:\n                    logging.info(\"Time limit reached. Stopping ACO.\")\n                    return x_best, y_best\n        return x_best, y_best\n\n    def edge_attractiveness(self, plot: bool = False):\n        \"\"\"\n        Calculate edge attractiveness\n        tau = pheromone\n        eta = distance\n        alpha = pheromone importance\n        beta = distance importance\n        \"\"\"\n        self.A = (self.tau ** self.alpha) * (self.eta ** self.beta)\n\n    def ant_walk(self, x_best, y_best, plot: bool = True):\n        \"\"\"\n        Ant walk\n        \"\"\"\n        x = [0]  # Start at first node\n        while len(x) < self.n:\n            i = x[-1]\n            neighbors = [j for j in range(self.n) if j not in x and self.distance_matrix[i][j] > 0]\n            if len(neighbors) == 0:\n                return x_best, y_best\n            p = [self.A[(i, j)] for j in neighbors]\n            sampled_neighbor = random.choices(neighbors, weights=p)[0]\n            x.append(sampled_neighbor)\n        x.append(0)\n        y = self.score(x)\n        self.history.append(y)\n        for i in range(1, self.n):\n            self.tau[(x[i-1], x[i])] += self.Q / y\n        if y < y_best:\n            logging.info(\"Better ACO solution found. Score: %.2f\", y)\n            return x, y\n        return x_best, y_best\n\n    def score(self, x):\n        \"\"\"\n        Score a solution\n        \"\"\"\n        y = 0\n        for i in range(len(x) - 1):\n            y += self.distance_matrix[x[i]][x[i + 1]]\n        return y\n```", "```py\nproblem = TSP()\naco = AntColonyOptimization(problem)\nbest_solution, best_score = aco.ant_colony_optimization()\n```"]