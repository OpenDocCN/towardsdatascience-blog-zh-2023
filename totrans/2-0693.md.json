["```py\nimport osmnx as ox # version: 1.0.1\nimport matplotlib.pyplot as plt # version: 3.7.1\n\ncity = 'Budapest'\nadmin = ox.geocode_to_gdf(city)\nadmin.plot()\n```", "```py\nfrom sentinelsat import SentinelAPI, read_geojson, geojson_to_wkt # version 0.14\n\n# to get an account, sign up here: https://apihub.copernicus.eu/apihub\nuser = <add your user name \npassword = < add your password >\napi = SentinelAPI(user, password, 'https://apihub.copernicus.eu/apihub') \n```", "```py\n# to simplify the query, I extract the convex hull of the input polygon\nadmin_polygon = admin.convex_hull.geometry.to_list()[0]\nadmin_polygon\n```", "```py\n# here we can specifcy the location (based on a polygon)\n# the time frame\n# the space probe\n# and the level of cloud-coverage accepted \n\nproducts = api.query(admin_polygon,\n                     date=('20150623', '20231006'),\n                     platformname='Sentinel-2',\n                     cloudcoverpercentage=(0, 100))\n\nlen(products)\n```", "```py\nimport pandas as pd # version: 1.4.2\n\nproducts_gdf = api.to_geodataframe(products)\nproducts_gdf = products_gdf.sort_values(['beginposition'], ascending=[True])\nprint(products_gdf.keys())\nprint(len(products_gdf.keys()))\nproducts_gdf.head(3)\n```", "```py\nimport folium\nimport geopandas as gpd\n\nx, y = admin_polygon.centroid.xy\nm = folium.Map(location=[y[0], x[0]], zoom_start=8, tiles='CartoDB Dark_Matter')\n\n# visualize a set of random tiles\npolygon_style = { 'fillColor': '#39FF14', 'color': 'black',  'weight': 3, 'opacity': 0}\ngeojson_data = products_gdf[['geometry']].sample(10).to_json()\nfolium.GeoJson(\n    geojson_data,\n    style_function=lambda feature: polygon_style\n).add_to(m)\n\n# add the admin boundaries on top\nadmin_style = {'fillColor': '#00FFFF',  'color': 'black','weight': 3, 'opacity': 100.0  }\nadmin_geojson_data = admin[['geometry']].to_json()\nfolium.GeoJson(\n    admin_geojson_data,\n    style_function=lambda feature: admin_style\n).add_to(m)\n\n# show the map\nm\n```", "```py\ndef compute_overlapping_area(tile, admin):\n    return tile.intersection(admin_polygon).area / admin_polygon.area\n\nproducts_gdf['overlapping_area_fraction'] = products_gdf.geometry.apply(lambda x: compute_overlapping_area(x, admin_polygon))\nproducts_gdf_f = products_gdf[products_gdf.overlapping_area_fraction==1]\nprint(len(products_gdf))\nprint(len(products_gdf_f))\nproducts_gdf_f.head(3)\n```", "```py\nimport folium\nimport geopandas as gpd\n\nx, y = admin_polygon.centroid.xy\nm = folium.Map(location=[y[0], x[0]], zoom_start=8, tiles='CartoDB Dark_Matter')\n\n# visualize a set of random tiles\npolygon_style = { 'fillColor': '#39FF14', 'color': 'black',  'weight': 3, 'opacity': 0}\ngeojson_data = products_gdf_f[['geometry']].sample(10).to_json()\nfolium.GeoJson(\n    geojson_data,\n    style_function=lambda feature: polygon_style\n).add_to(m)\n\n# add the admin boundaries on top\nadmin_style = {'fillColor': '#00FFFF',  'color': 'black','weight': 3, 'opacity': 100.0  }\nadmin_geojson_data = admin[['geometry']].to_json()\nfolium.GeoJson(\n    admin_geojson_data,\n    style_function=lambda feature: admin_style\n).add_to(m)\n\n# show the map\nm\n```", "```py\n# Assuming 'beginposition' is a Timestamp column in your GeoDataFrame\n# You can convert it to a DateTime index\nproducts_gdf_f_cntr = products_gdf_f.copy()\nproducts_gdf_f_cntr['beginposition'] = pd.to_datetime(products_gdf_f_cntr['beginposition'])\nproducts_gdf_f_cntr.set_index('beginposition', inplace=True)\n\n# Resample the data to count rows per day, week, and month\ndaily_counts = products_gdf_f_cntr.resample('D').count()\nweekly_counts = products_gdf_f_cntr.resample('W').count()\nmonthly_counts = products_gdf_f_cntr.resample('M').count()\n\nfig, ax = plt.subplots(1, 3, figsize=(15, 5))\nfor idx, (count_name, count_val) in enumerate([('Daily Counts', daily_counts), ('Weekly Counts', weekly_counts), ('Monthly Counts', monthly_counts), ]): \n\n    ax[idx].plot(count_val.index[0:250], count_val['geometry'].to_list()[0:250])\n    ax[idx].set_xlabel('Date')\n    ax[idx].set_ylabel('Count')\n    ax[idx].set_title(count_name)\n\nplt.tight_layout()\nplt.suptitle('Number of satellite images taken in various time-frames', fontsize = 20, y = 1.15)\nplt.show()\n```", "```py\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Assuming 'beginposition' is a Timestamp column in your GeoDataFrame\n# You can convert it to a DateTime index\nproducts_gdf_f_cntr = products_gdf_f.copy()\nproducts_gdf_f_cntr['beginposition'] = pd.to_datetime(products_gdf_f_cntr['beginposition'])\nproducts_gdf_f_cntr.set_index('beginposition', inplace=True)\n\n# Resample the data to calculate weekly averages\nweekly_averages = products_gdf_f_cntr[['vegetationpercentage', 'waterpercentage', 'snowicepercentage', 'cloudcoverpercentage']].resample('W').mean()\n\n# Create a multi-plot figure with four subplots\nfig, (ax1, ax2, ax3, ax4) = plt.subplots(4, 1, figsize=(10, 15))\n\n# Plot 'vegetationpercentage' with a green line\nax1.plot(weekly_averages.index, weekly_averages['vegetationpercentage'], color='green', label='Weekly Average Vegetation Percentage')\nax1.set_xlabel('Date')\nax1.set_ylabel('Percentage')\nax1.set_title('Weekly Average Vegetation Percentage')\nax1.legend()\n\n# Plot 'waterpercentage' with a blue line\nax2.plot(weekly_averages.index, weekly_averages['waterpercentage'], color='blue', label='Weekly Average Water Percentage')\nax2.set_xlabel('Date')\nax2.set_ylabel('Percentage')\nax2.set_title('Weekly Average Water Percentage')\nax2.legend()\n\n# Plot 'snowicepercentage' with a cyan line\nax3.plot(weekly_averages.index, weekly_averages['snowicepercentage'], color='cyan', label='Weekly Average Snow/Ice Percentage')\nax3.set_xlabel('Date')\nax3.set_ylabel('Percentage')\nax3.set_title('Weekly Average Snow/Ice Percentage')\nax3.legend()\n\n# Plot 'cloudcoverpercentage' with a gray line\nax4.plot(weekly_averages.index, weekly_averages['cloudcoverpercentage'], color='gray', label='Weekly Average Cloud Cover Percentage')\nax4.set_xlabel('Date')\nax4.set_ylabel('Percentage')\nax4.set_title('Weekly Average Cloud Cover Percentage')\nax4.legend()\n\nplt.tight_layout()\nplt.show() \n```", "```py\nproducts_gdf_f_cntr[['vegetationpercentage', 'waterpercentage', 'snowicepercentage', 'cloudcoverpercentage']].corr()\n```", "```py\n# query tile product ids\nproducts_sent = api.query(admin_polygon, date=('20230806', '20230813'), platformname='Sentinel-2', cloudcoverpercentage=(0, 1))\nproducts_sent = api.to_geodataframe(products_sent)\n\nf, ax = plt.subplots(1,1,figsize=(6,4))\nadmin.plot(ax=ax, color = 'none', edgecolor = 'k')\nax.set_title('Sentinel-2, number of tiles = ' + str(len(products_sent)))\nproducts_sent.plot(ax=ax, alpha = 0.3)\n\n# filter out the tiles not fully overlapping with Budapest\nproducts_sent['overlapping_area_fraction'] = products_sent.geometry.apply(lambda x: compute_overlapping_area(x, admin_polygon))\nproducts_sent = products_sent[products_sent.overlapping_area_fraction==1]\n\nf, ax = plt.subplots(1,1,figsize=(6,4))\nadmin.plot(ax=ax, color = 'none', edgecolor = 'k')\nax.set_title('Sentinel-2, number of tiles = ' + str(len(products_sent)))\nproducts_sent.plot(ax=ax, alpha = 0.3)\n\nlen(products_sent)\n```", "```py\n# download the first tiles as sat images\nproduct_ids = products_sent.index.to_list()\n\nfor prod in product_ids:\n    api.download(prod)\n```", "```py\nProduct a3c61497-d77d-48da-9a4d-394986d2fe1d is not online. Triggering retrieval from long term archive.\n```", "```py\n# after unzipping the downloaded folder:\nimport os\nimage_path = 'S2B_MSIL1C_20230810T094549_N0509_R079_T34TCT_20230810T124346.SAFE/GRANULE/L1C_T34TCT_A033567_20230810T095651/IMG_DATA'\nsorted(os.listdir(image_path))\n```", "```py\nimport rasterio\nfrom rasterio.plot import show\n\nimage_file = 'T34TCT_20230810T094549_B04.jp2'\n\nwith rasterio.open(image_path + '/' + image_file) as src:\n\n    image = src.read(1)  # Change the band index as needed\n    plt.figure(figsize=(10, 10))\n    plt.imshow(image, cmap='Reds')  # You can change the colormap\n    plt.title(image_file)\n    plt.colorbar()\n    plt.show()\n```", "```py\nfrom rasterio import mask\n\nf, ax = plt.subplots(1,3,figsize=(15,5))\n\nfor idx, (band_name, band_num, color_map) in enumerate([('Blue', 'B02', 'Blues'), ('Green', 'B03', 'Greens'), ('Red', 'B04', 'Reds')]):\n\n    raster_path = image_path + '/T34TCT_20230810T094549_' + band_num + '.jp2'\n\n    with rasterio.open(raster_path) as src:\n        polygons = admin.copy().to_crs(src.crs)\n        geom = polygons.geometry.iloc[0]\n        masked_image, _ = mask.mask(src, [geom], crop=True)\n\n    ax[idx].imshow(masked_image[0], cmap=color_map)\n    ax[idx].set_title('Budapest Sentinel 2 - ' + band_name + ' band')\n```", "```py\n# Get the band locations\nband_blue = '/T34TCT_20230810T094549_B02.jp2'\nband_green = '/T34TCT_20230810T094549_B03.jp2'\nband_red = '/T34TCT_20230810T094549_B04.jp2'\n\n# Read in the bands and create the full RGB tile\nb2   = rasterio.open(image_path + '/' + band_blue)\nb3   = rasterio.open(image_path + '/' + band_green)\nb4   = rasterio.open(image_path + '/' + band_red)\n\n# export the full tile as a tif file\nmeta = b4.meta\nmeta.update({\"count\": 3})\nprefire_rgb_path = 'budapest_rgb.tif'\nwith rasterio.open(prefire_rgb_path, 'w', **meta) as dest:\n    dest.write(b2.read(1),1)\n    dest.write(b3.read(1),2)\n    dest.write(b4.read(1),3)\n\n# crop and save it to the admin boundaries of budapest\nwith rasterio.open('budapest_rgb.tif') as src:\n    polygons = admin.copy().to_crs(src.crs)\n    geom = polygons.geometry.iloc[0]\n    out_image, out_transform  = mask.mask(src, [geom], crop=True)\n    out_meta = src.meta.copy()\n    out_meta.update({\"driver\": \"GTiff\",\n                     \"height\": out_image.shape[1],\n                     \"width\" : out_image.shape[2],\n                     \"transform\": out_transform})\n\nwith rasterio.open('budapest_rgb_cropped.tif', \"w\", **out_meta) as dest:\n    dest.write(out_image)\n\n# read and show the cropped version\nimport numpy as np\nfrom skimage import exposure\n\nimg = rasterio.open('budapest_rgb_cropped.tif')\nimage = np.array([img.read(3), img.read(2), img.read(1)])\nimage = image.transpose(1,2,0)\n\n# do the histogram equalization\np2, p98 = np.percentile(image, (2,98))\nimage = exposure.rescale_intensity(image, in_range=(p2, p98)) / 100000\n\nf, ax = plt.subplots(1,1,figsize=(15,15))\nrasterio.plot.show(image.transpose(2,0,1), transform=img.transform, ax = ax)\nax.axis('off')\nplt.savefig('budapest_rgb_cropped_2.png', dpi = 100, bbox_inches = 'tight')\n```"]