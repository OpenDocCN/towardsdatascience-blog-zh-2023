- en: 'Rock Paper Scissors: A Quantum Computing Twist'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/rock-paper-scissors-a-quantum-computing-twist-bcf66b88d781](https://towardsdatascience.com/rock-paper-scissors-a-quantum-computing-twist-bcf66b88d781)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: TUTORIAL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A New Way to Play with Advanced Computing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@KoryBecker?source=post_page-----bcf66b88d781--------------------------------)[![Kory
    Becker](../Images/53a2493fe53f215d3e715d456b36c553.png)](https://medium.com/@KoryBecker?source=post_page-----bcf66b88d781--------------------------------)[](https://towardsdatascience.com/?source=post_page-----bcf66b88d781--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----bcf66b88d781--------------------------------)
    [Kory Becker](https://medium.com/@KoryBecker?source=post_page-----bcf66b88d781--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----bcf66b88d781--------------------------------)
    ·14 min read·May 16, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1857887a77872c72506f163d82e4cd04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Source: [Stable Diffusion](https://stablediffusionweb.com).'
  prefs: []
  type: TYPE_NORMAL
- en: Having fun with quantum computing games
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I love demonstrating the effects of quantum computing. Especially, through games
    that use quantum superposition and entanglement.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum computing is an incredibly exciting technology that will impact virtually
    every industry and science. Learning about how quantum computing works, and specifically
    how it differs from classical computing, can make you a better programmer and
    a more logical thinker!
  prefs: []
  type: TYPE_NORMAL
- en: So, I thought it would be fun to come up with a game that could be implemented
    on a quantum computer in order to further demonstrate the differences between
    quantum and traditional computing.
  prefs: []
  type: TYPE_NORMAL
- en: No shortage of amazing quantum feats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many surprisingly powerful (and even confusing!) properties that quantum
    computers can perform compared to their classical counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: Increased performance from [exponential](https://medium.com/towards-data-science/ghostly-images-and-qubits-a-new-way-to-visualize-quantum-superposition-94b582889549)
    processing power, evaluating multiple scenarios [simultaneously](/programming-in-3d-my-first-steps-into-quantum-computing-566b9b93929d),
    and even something as simple as generating advanced [random numbers](/the-magic-of-quantum-computing-a-beginners-guide-to-writing-a-magic-number-guessing-game-c1cdb384f457)
    can all be achieved on a quantum level.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll focus on superposition — the technique that allows a quantum computer
    to evaluate many different scenarios simultaneously. To make it fun — we’ll use
    a game!
  prefs: []
  type: TYPE_NORMAL
- en: Ideas for quantum games
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I searched far and wide for ideas of a game that would be simple enough to use,
    easy enough to play, and yet that can take advantage of quantum processing.
  prefs: []
  type: TYPE_NORMAL
- en: '*It would also help if this has never been done before!*'
  prefs: []
  type: TYPE_NORMAL
- en: This led me to the idea of classical games such as [tic tac toe](https://quantumfrontiers.com/2019/07/15/tiqtaqtoe),
    [poker](https://link.springer.com/article/10.1140/epjp/s13360-020-00360-5), and
    [other](https://arxiv.org/abs/2202.07756) games.
  prefs: []
  type: TYPE_NORMAL
- en: While many research papers that combine quantum computing with games often focus
    on various algorithmic approaches and mathematical complexity, I wanted to create
    something more easily understandable.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a quantum computing program doesn’t have to be difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have an understanding of the various gates and behaviors of qubits,
    you can create a vast array of quantum applications.
  prefs: []
  type: TYPE_NORMAL
- en: What better way to demonstrate this than with a game of rock, paper, scissors!
  prefs: []
  type: TYPE_NORMAL
- en: Rock, paper, scissors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rock, Paper, Scissors is a game for two players. The game involves each player
    secretly choosing an item of rock, paper, or scissors. The players typically count
    to three and then reveal their hand at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: The rules of the game state that rock defeats scissors, scissors defeats paper,
    and paper defeats rock.
  prefs: []
  type: TYPE_NORMAL
- en: Simple enough! Or is it?
  prefs: []
  type: TYPE_NORMAL
- en: A mathematical paradox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The underlying principle of rock, paper, scissors is really a measure of weights
    and values.
  prefs: []
  type: TYPE_NORMAL
- en: We can consider that rock is valued greater than scissors. Likewise, scissors
    is valued greater than paper. So far, so good.
  prefs: []
  type: TYPE_NORMAL
- en: Rock > Scissors > Paper
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now, if rock is greater than scissors, and scissors is greater that paper, then
    surely rock is greater than paper as well. However, according to the game rules,
    paper is valued *greater* than rock!
  prefs: []
  type: TYPE_NORMAL
- en: Rock > Scissors > Paper > Rock?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It’s quite the paradox!
  prefs: []
  type: TYPE_NORMAL
- en: Thinking about this mathematically for a moment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s take a step back to consider the paradox that makes the game rock, paper,
    scissors so unique.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider that we have three variables: A, B, and C (representing rock, paper,
    and scissors respectively). Each variable is assigned a weight such that A > B
    and B > C. The [transitive property of inequality](https://www.mathsisfun.com/algebra/inequality-properties.html)
    states that according to this arrangement, A > C.'
  prefs: []
  type: TYPE_NORMAL
- en: This would lead us to believe that if rock > scissors, and scissors > paper,
    then rock > paper. Clearly, this is not how the game is played!
  prefs: []
  type: TYPE_NORMAL
- en: In fact, this is the premise behind Hardy’s Paradox.
  prefs: []
  type: TYPE_NORMAL
- en: The Hardy Paradox of rock, paper, and scissors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The [Hardy Paradox](https://en.wikipedia.org/wiki/Hardy%27s_paradox), developed
    by [Lucien Hardy](https://en.wikipedia.org/wiki/Lucien_Hardy) in 1992, examines
    the situation where three variables that are seemingly aligned in weights of each
    being greater than the next, can still create a situation where the last variable
    ends up being greater than the first — violating the transitive property of inequality.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, this type of violation is [distinctly possible](https://www.sciencedaily.com/releases/2023/04/230419095535.htm)
    in the quantum world where particles may become entangled and, in fact, can be
    found in the game rock, paper, scissors!
  prefs: []
  type: TYPE_NORMAL
- en: I think we’ve just found the perfect game to demonstrate some of the power behind
    quantum computing.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing the rules of the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’re going to create a quantum computing program that can find all winning
    hands in a game of rock, paper, scissors.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll create both a classical and quantum version of the program in order to
    demonstrate the difference in complexity.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing that we need to do is to encode the items in the game so that
    we can utilize them in an algorithm. Since each player can choose one of three
    items (rock, paper, or scissors) during each round of the game, we can have nine
    different possibilities for game hands.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use the first letter for each item to represent possible choices from
    each player in a round of the game. Therefore, the possible hands that can be
    played are shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The above list shows all possible hands, beginning with rock versus rock (RR),
    rock versus paper (RP), rock versus scissors (RS), etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of the above nine possible hands, only three of these are winning choices:
    rock versus scissors (RS), scissors versus paper (SP), and paper versus rock (PR).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Moving to the digital world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve defined our game choices, we need to convert these choices from
    letters (R, S, P) into binary digits of zero or one. This is needed so that we
    can eventually represent the choices as qubits.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have three items, we’ll represent them from the values zero to two
    (00, 01, 10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It’s important to note the binary values that we assign to each item, as we
    will be referring back to these when looking at the input and output to our programs.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s define the rules of the game from the perspective of player one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve defined a simple digital definition for each possible game hand,
    let’s start writing some code.
  prefs: []
  type: TYPE_NORMAL
- en: Encoding the game as bits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our game items defined as binary values, we can now store these values
    within qubits. Let’s create a Python object that defines each item with a corresponding
    value as listed in the prior section above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s see if we can find all possible winning moves that can be made.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a logical expression for the win
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve already defined a representation for each choice (rock 00, paper 01, scissors
    10). Since we have two players, there would be four bits per round.
  prefs: []
  type: TYPE_NORMAL
- en: A single round of the game might appear as shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '*Player 1 chooses Rock.'
  prefs: []
  type: TYPE_NORMAL
- en: Player 2 chooses Paper.
  prefs: []
  type: TYPE_NORMAL
- en: Rock = 00 and Paper = 01*
  prefs: []
  type: TYPE_NORMAL
- en: '*The input would be 0001.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In order to determine if this is a winning move for player one, we need to check
    some logic that dictates the rules of the game.
  prefs: []
  type: TYPE_NORMAL
- en: The game rules state that rock defeats scissors, scissors defeats paper, and
    paper defeats rock.
  prefs: []
  type: TYPE_NORMAL
- en: We can encode these rules using Boolean logic.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The slow way to find all winning hands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s begin by writing a classical computer program to find all winning hands.
  prefs: []
  type: TYPE_NORMAL
- en: We can create a method called *check_all_games()* that loops through a list
    of all possible combinations of items and returns only those that are winning
    hands for player one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: ([(0, 0, 1, 0), (0, 1, 0, 0), (1, 0, 0, 1)], 16)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The method returns the list of winning hands including rock versus scissors,
    paper versus rock, and scissors versus paper. It also returns the number of iterations
    that it took to search through all combinations.
  prefs: []
  type: TYPE_NORMAL
- en: (0, 0, 1, 0) = rock (0, 0) vs. scissors (1, 0)
  prefs: []
  type: TYPE_NORMAL
- en: (0, 1, 0, 0) = paper (0, 1) vs. rock (0, 0)
  prefs: []
  type: TYPE_NORMAL
- en: (1, 0, 0, 1) = scissors (1, 0) versus paper (0, 1)
  prefs: []
  type: TYPE_NORMAL
- en: Did you notice that this required **16** iterations to find all winning games?
    Not to mention, the iterations include invalid bit combinations, such as [1, 1,
    1, 1] — which do not even correspond to a valid item!
  prefs: []
  type: TYPE_NORMAL
- en: Can quantum do better?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s try this again. However, this time we’re going to create a quantum computing
    program to find all winning hands.
  prefs: []
  type: TYPE_NORMAL
- en: In the same manner as the classical program, we’ll define a function *isWin()*
    that encodes the rules of the game.
  prefs: []
  type: TYPE_NORMAL
- en: A black box quantum circuit that encodes some specific set of logical rules
    (such as the rules for winning in our game), is called an **oracle**.
  prefs: []
  type: TYPE_NORMAL
- en: Since our oracle will work with binary values of 0 and 1, rather than variable
    names, let’s just rewrite our logical expression using these values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Also, since we will be using the quantum computing library [Qiskit](https://qiskit.org/),
    we will need to represent the qubits in reverse order. Therefore, we’ll arrange
    our logic accordingly by swapping the positions of the right and left bits.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The first row is our result of winning hands, as returned from our classical
    program. We’re just representing each bit with a qubit (indicated as q0, q1, q2,
    q3). The qubits are arranged in reverse order so that the first two bits are player
    one, and the last two bits are player two. Each player’s qubits are arranged with
    the least-significant bit to the right and the most-significant bit to the left
    (corresponding to [q1, q0] and [q3, q2]). We repeat this for all three of the
    winning hand combinations.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an oracle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s create the oracle for our quantum computing solution.
  prefs: []
  type: TYPE_NORMAL
- en: Just as we did with the classical program, we will encode the rules of the game
    using Boolean logic. The difference this time, however, is that we’re referring
    to q0, q1, q2, q3 to represent rock, paper, scissors.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the first type of winning hand encoded within our oracle is for
    rock versus scissors. We can encode this as shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '***Rock versus scissors***'
  prefs: []
  type: TYPE_NORMAL
- en: (0, 0, 1, 0)
  prefs: []
  type: TYPE_NORMAL
- en: (q1 q0 q3 q2)
  prefs: []
  type: TYPE_NORMAL
- en: '***First winning hand condition***'
  prefs: []
  type: TYPE_NORMAL
- en: (not q0 and not q1 and not q2 and q3)
  prefs: []
  type: TYPE_NORMAL
- en: '***Reversing the qubit order***'
  prefs: []
  type: TYPE_NORMAL
- en: (not q1 and not q0 and q3 and not q2)
  prefs: []
  type: TYPE_NORMAL
- en: '***Converting to binary***'
  prefs: []
  type: TYPE_NORMAL
- en: (00 versus 10)
  prefs: []
  type: TYPE_NORMAL
- en: '***Converting to a game round***'
  prefs: []
  type: TYPE_NORMAL
- en: (rock versus scissors)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: All winning hands are encoded in the oracle with one line of Boolean logic.
    This creates a quantum computing circuit that can be used within our program to
    find all winning hands!
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/31c68d47dd6555627bad7c59a34d90c0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A quantum computing oracle for all winning hands in the game rock, paper, scissors.
    Source: Author.'
  prefs: []
  type: TYPE_NORMAL
- en: Putting this all together, we can create a quantum computing program using this
    oracle.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we’re playing a single round of the game with paper versus
    rock. In the resulting quantum computing program, notice that the first qubit
    (q0) is inverted using the X-Gate to a value of one, and the second qubit (q1)
    is left with a value of zero. This corresponds to (01) which represents paper.
    Similarly, qubits three and four (q2 and q3) are left as zero (00), corresponding
    to rock.
  prefs: []
  type: TYPE_NORMAL
- en: This is a game of paper versus rock.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d63466251637410d49d7aa0c78d1a945.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A quantum computing circuit for paper versus rock, where player one selects
    paper (01), and player two selects rock (00). Source: Author.'
  prefs: []
  type: TYPE_NORMAL
- en: The result of our quantum computing program returns an output indicating if
    this is a winning hand. Since the output of qubits are in reverse order (*remember,
    we’re reading from right to left!*), I’ve highlighted an example along with notation
    that explains each qubit value below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Running the quantum computing program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s run the program and see the result. Since paper always defeats rock, we
    would expect our program to output a value of one across all measurements of the
    quantum program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '{‘1’: 1024}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/65b5e7b070005fb5556314895abfb991.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A winning hand of rock, paper, scissors for player one. Source: Author.'
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, we can see that all measurements result in a strong value of one. This
    indicates that paper versus rock is a win for player one!
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we can run the same oracle against a game round of paper versus scissors.
    In this round, we would expect the result to be zero, since paper is always defeated
    by scissors.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '{‘0’: 1024}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Once again, we’ve obtained a correct answer, indicating that this is a loss
    for player one.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/64d26f6de55e5f4c55a29983bca1005c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A losing hand for player one. Source: Author.'
  prefs: []
  type: TYPE_NORMAL
- en: Well, so far, we’re only determining if a single round of the game is a win
    for player one. That’s not very impressive. After all, our classical program found
    all winning hands (*albeit it took 16 iterations to calculate this!*).
  prefs: []
  type: TYPE_NORMAL
- en: Can we find *all* winning hands?
  prefs: []
  type: TYPE_NORMAL
- en: The power of quantum processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As it turns out, since we’ve created a quantum oracle that encodes the winning
    hands of our game, we can in fact calculate all winning hands. Even better, we
    can do this in just one single CPU cycle!
  prefs: []
  type: TYPE_NORMAL
- en: Instead of hard-coding our qubits with a specific value of zero or one, which
    corresponded to a particular item choice of rock, paper, scissors for each player,
    we will place the qubits into superposition. This changes the qubits from a value
    of 0 ***or*** 1 to a value of 0 ***and*** 1 at the same time!
  prefs: []
  type: TYPE_NORMAL
- en: By using superposition, we can evaluate ***all*** possible game hands in one
    single execution and only return those winning hands that satisfy the oracle Boolean
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an example for how this is done.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we’ve omitted hard coding a specific item for player one and player
    two. Instead, we’re using the [Hadamard Gate](https://www.quantum-inspire.com/kbase/hadamard/)
    to place all four qubits into superposition so that they hold a value of both
    0 and 1 simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/786bc869d5c6d01c2eef13e19a1fcc15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finding all possible winning hands in rock, paper, scissors by placing player
    one and two’s qubits into superposition. Source: Author.'
  prefs: []
  type: TYPE_NORMAL
- en: This results in a quantum computing circuit as shown above. If we run this program
    we should expect to see an indication of all winning hands that satisfy the oracle
    Boolean logic.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b04a0bc460e4ec6e61198629677926c6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Execution of a quantum circuit using an oracle without amplification. Source:
    Author.'
  prefs: []
  type: TYPE_NORMAL
- en: In the results, the most significant qubit (the left-most or downward-most)
    is a value of 0 (loss) or 1 (win). So, we’re concerned with the 3 wins at the
    far right of the graph.
  prefs: []
  type: TYPE_NORMAL
- en: However, this doesn’t appear quite right!
  prefs: []
  type: TYPE_NORMAL
- en: In fact, all possible combinations of qubit values appear to be completely random.
  prefs: []
  type: TYPE_NORMAL
- en: Grover search to the rescue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As it turns out, when search across a space of qubits in superposition with
    an oracle, we need to amplify the measurement results for winning hands that satisfy
    the oracle, while minimizing losing hands that do not satisfy the oracle.
  prefs: []
  type: TYPE_NORMAL
- en: We can do this using the [Grover search](https://en.wikipedia.org/wiki/Grover%27s_algorithm)
    quantum algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Grover’s search algorithm utilizes a diffuser and amplification process that
    allows correct results to “float” higher, while incorrect results remain low.
    It can be used for searching for a key within a database of unordered items and
    searches [quadratically](https://www.primaryobjects.com/2022/01/22/quantum-computing-hello-world/)
    faster than any classical algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a821a4353ab666195c1994e8611f870a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finding all possible winning moves in rock, paper, scissors by using the Grover
    search algorithm. Source: Author.'
  prefs: []
  type: TYPE_NORMAL
- en: After running this new circuit using the Grover search algorithm, along with
    our same oracle for rock, paper, scissors, we can see the following change in
    output.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/da516e68f1240ecfb05c4f1d643ac855.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The winning hands in rock, paper and scissors. From left to right: paper (01)
    vs. rock (00), scissors (10) vs. paper (01), rock (00) vs. scissors (10). Source:
    Author.'
  prefs: []
  type: TYPE_NORMAL
- en: Examining the above results, we indeed have three results that are far higher
    than the rest of the combinations. In fact, these correspond directly to the winning
    moves in the game!
  prefs: []
  type: TYPE_NORMAL
- en: If we decode each result, beginning from the left-most in the chart, and reversing
    the bits that Qiskit returned as output, we can determine the winning hands. *Recall,
    the top-most bit is the least-significant bit and corresponds to Player One.*
  prefs: []
  type: TYPE_NORMAL
- en: 0001 = paper (01) vs rock (00) = *WIN*
  prefs: []
  type: TYPE_NORMAL
- en: 0110 = scissors (10) vs paper (01) = *WIN*
  prefs: []
  type: TYPE_NORMAL
- en: 1000 = rock (00) vs scissors (10) = *WIN*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The most amazing part about this is that the classical program took **16** iterations
    to find these three winning combinations. **The quantum computing program took
    just one!**
  prefs: []
  type: TYPE_NORMAL
- en: One more bit of fun
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve just examined how a quantum computing program can find all winning moves
    in the game rock, paper, scissors with just a single execution on the CPU. We
    did this by placing the qubits into superposition.
  prefs: []
  type: TYPE_NORMAL
- en: However, by playing with which qubits are in and out of superposition, we can
    actually create different behaviors of our program.
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose that we want to find the best move for player one when
    given a specific choice by player two. We can do this by setting player one’s
    qubits into superposition and leaving player two's qubits hard-coded to a specific
    value.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/38fd2fca173c6d6b3fd3c9253f92a218.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finding a winning move for player one when player two chooses rock. Source:
    Author.'
  prefs: []
  type: TYPE_NORMAL
- en: If we now run the quantum program, instead of seeing three results with high
    measurements (corresponding to all winning hands), we should expect to see just
    one high measurement, which will correspond to the winning hand that player one
    should choose in order to defeat player two.
  prefs: []
  type: TYPE_NORMAL
- en: In the above scenario, we’re assigning player two the choice of rock (00). Let’s
    see what the quantum program selects as its move!
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/39d62c41da5c7e4e46480e40245ae908.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The winning move for player one is paper (01) when player two chooses rock
    (00). Source: Author.'
  prefs: []
  type: TYPE_NORMAL
- en: The result indicates (0001). Reading from least to most significant bits, this
    evaluates to player one choosing paper (01) whenever player two chooses rock (00).
    Making this move is, indeed, a winning play for player one!
  prefs: []
  type: TYPE_NORMAL
- en: '*Paper defeats rock!*'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the complete code example for the rock, paper, scissors program
    [here](https://gist.github.com/primaryobjects/f58e5528e3b183b6bfcb8d7a9dc34934).
  prefs: []
  type: TYPE_NORMAL
- en: It’s your turn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve completed a quantum computing program to find all winning moves
    in the game Rock, Paper, Scissors, let’s think for a moment what we’ve achieved.
  prefs: []
  type: TYPE_NORMAL
- en: A classical program took 16 iterations to find all winning hands. By contrast,
    a quantum version using Grover’s search executed in just 1 single iteration. This
    is just one of the fantastic differences between how classical and quantum computers
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Grover’s search can be applied to many different searchability problems, including
    algorithms, file systems, and databases, just to name a few. Additionally, since
    the field of quantum computing is still so young, you have the real opportunity
    to make an impact.
  prefs: []
  type: TYPE_NORMAL
- en: I hope that your excitement is piqued into learning more about this amazing
    technology. Now it’s your turn!
  prefs: []
  type: TYPE_NORMAL
- en: About the Author
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’ve enjoyed this article, please consider following me on [Medium](https://medium.com/@KoryBecker),
    [Twitter](https://twitter.com/PrimaryObjects), and my [web site](https://primaryobjects.com/)
    to be notified of my future posts and research work.
  prefs: []
  type: TYPE_NORMAL
