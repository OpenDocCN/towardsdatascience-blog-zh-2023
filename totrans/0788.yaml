- en: 'Efficient Coding in Data Science: Easy Debugging of Pandas Chained Operations'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/efficient-coding-in-data-science-easy-debugging-of-pandas-chained-operations-0089f6de920f](https://towardsdatascience.com/efficient-coding-in-data-science-easy-debugging-of-pandas-chained-operations-0089f6de920f)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: PYTHON PROGRAMMING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How to inspect Pandas data frames in chained operations without breaking the
    chain into separate statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@nyggus?source=post_page-----0089f6de920f--------------------------------)[![Marcin
    Kozak](../Images/d7faf62e48ed81dab5d8ad92819fff54.png)](https://medium.com/@nyggus?source=post_page-----0089f6de920f--------------------------------)[](https://towardsdatascience.com/?source=post_page-----0089f6de920f--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----0089f6de920f--------------------------------)
    [Marcin Kozak](https://medium.com/@nyggus?source=post_page-----0089f6de920f--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----0089f6de920f--------------------------------)
    ·9 min read·Nov 15, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a4416aaa0e5cbb71ac3371cb86b01eae.png)'
  prefs: []
  type: TYPE_IMG
- en: Debugging chained Pandas operations without breaking the chain is possible.
    Photo by [Miltiadis Fragkidis](https://unsplash.com/@_miltiadis_?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: 'Debugging lies in the heart of programming. I wrote about this in the following
    article:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/bugs-in-python-pdb-to-the-rescue-d88a56a2ca71?source=post_page-----0089f6de920f--------------------------------)
    [## Bugs in Python? Pdb To the Rescue!'
  prefs: []
  type: TYPE_NORMAL
- en: Is the Pdb debugger worth learning and using?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/bugs-in-python-pdb-to-the-rescue-d88a56a2ca71?source=post_page-----0089f6de920f--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: This statement is quite general and language- and framework-independent. When
    you use Python for data analysis, you need to debug code irrespective of whether
    you’re conducting complex data analysis, writing an ML software product, or creating
    a Streamlit or Django app.
  prefs: []
  type: TYPE_NORMAL
- en: This article discusses debugging Pandas code, or rather a specific scenario
    of debugging Pandas code in which operations are chained into a pipe. Such debugging
    poses a challenging issue. When you don’t know how to do it, chained Pandas operations
    seem to be far more difficult to debug than regular Pandas code, that is, individual
    Pandas operations using typical assignment with square brackets.
  prefs: []
  type: TYPE_NORMAL
- en: 'To debug regular Pandas code using typical assignment with square brackets,
    it’s enough to add a Python breakpoint — and use the `pdb` interactive debugger.
    This would be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, you can’t do that when the code consists of chained operations,
    like here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'or, depending on your preference, here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this case, there is no place to stop and look at the code — you can only
    do so before or after the chain. Thus, one of the solutions is to break the main
    chain into two sub-chains (two pipes) in a place where you want to debug the code,
    and debug it from there. Most likely, after debugging you will want to return
    to one chain instead of two, so I personally have never liked using such debugging.
  prefs: []
  type: TYPE_NORMAL
- en: And this is why I came up with the method I’d like to present in this article.
    I am going to show you a solution for debugging chained Pandas operations that
    does not require you to break the chain. Instead, you can add something similar
    to a typical Python `breakpoint`. Adding and removing this breakpoint is easy,
    making debugging chained Pandas operations simple.
  prefs: []
  type: TYPE_NORMAL
- en: I will propose three different functions that will help you debug code inside
    chains of Pandas operations. Once you will see the idea behind them, you will
    be able to implement your own debugging functions.
  prefs: []
  type: TYPE_NORMAL
- en: Functions for debugging Pandas chains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the functions I’m going to present below utilize the `pd.pipe()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[## pandas.DataFrame.pipe - pandas 2.1.2 documentation'
  prefs: []
  type: TYPE_NORMAL
- en: Function to apply to the Series/DataFrame. , and are passed into . Alternatively
    a tuple where data_keyword is a string…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: pandas.pydata.org](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.pipe.html?source=post_page-----0089f6de920f--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use `pd.pip()` to call — and use to a dataframe — any function that
    expects a Pandas dataframe or series. This opens us a range of possibilities:
    any such function can be added inside a chain of Pandas operations. And this is
    how we structure the functions below.'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging via breakpoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let me start with the most important function, and at the same time the simplest
    one. It that adds a typical `breakpoint` to a chain of Pandas operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Simple, isn’t it?
  prefs: []
  type: TYPE_NORMAL
- en: You deserve the explanation why we’re creating a deep copy of the dataframe.
    If we didn’t done this, we would’ve risk that the original data frame would be
    returned. In our function, everything you do on the `df` dataframe does not affect
    the original dataframe, `d`. Hence, you can make changes to `df` and all will
    be fine. But you must *not* do any changes to `d`, since they will be reflected
    in the returned dataframe — and so the dataframe passed to further operations
    in the pipe would be done using this changed dataframe during debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `pdbreakpoint()` function for the following Pandas pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Certainly, it’s an overly simplistic example, but we don’t need a complicated
    pipe, as it could distract us from what interests us today: debugging. I used
    the `d` name for the dataframe for a reason; I wanted to use a different name
    from `df`, which I used inside the `pdbreakpoint()` function.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that if you typically use `df` as a name for your temporary dataframes,
    you may consider using a name like `d` inside `pdbreakpoint()`. The choice is
    yours, but the only requirement is to use a name for the dataframe inside `pdbreakpoint()`
    that is not used in the outer scope.
  prefs: []
  type: TYPE_NORMAL
- en: Use a name for the dataframe inside `pdbreakpoint()` that is not used in the
    outer scope.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Now, suppose you want to inspect the `d` DataFrame after using the `assign()`
    function but before using the `query()` function. As mentioned earlier, you can
    achieve this by splitting the chain into two operations. Above, I demonstrated
    how to do this for Pandas code based on square brackets, and below, I illustrate
    how to do it for Pandas code based on chained operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'But this is something I have never liked doing. That’s why I came up with the
    `pdbreakpoint()` function. You can use it in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The screenshot below shows what will happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/75588db195947f76d21735470734660e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Screenshot from Python 3.11: Entering the pdb debugger using the pdbreaking
    function. Image by author.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’re inside the `pdbreakpoint()` function, and when you look at it once more,
    you will see that you will have access to a `df` data frame — which is the dataframe
    *after* running `assign()` and *before* running `query()` on it. Look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0ea3d2a1a18544facdda8a9be71e0487.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Screenshot from Python 3.11: Using the pdb debugger after using the pdbreaking
    function. Image by author.'
  prefs: []
  type: TYPE_NORMAL
- en: So, we inspected `df` inside the breakpoint; when doing so, we ran `df.query("group
    == 'b'")`. However, after hitting `c` (for `continue`), we returned to the regular
    session and obtained the final result, which is the data frame after running `query("group
    == 'a'")`, that is, after running the whole chain of operations on the `d` dataframe.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! This is a very simple way of inspecting Pandas data frames using
    the `pdb` built-in Python debugger.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to implement such functions, we can use this knowledge
    to implement other functions, ones that can help us debug Pandas chained operations.
  prefs: []
  type: TYPE_NORMAL
- en: Printing the head of a data frame
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our next function will not use the `pdb` interactive debugger. Instead, it
    will simply print the head of a data frame, with the possibility of selecting
    a subset of columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/41625535101558916e473f90ed68eafb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Screenshot from Python 3.11: Using the pdhead function. Image by author.'
  prefs: []
  type: TYPE_NORMAL
- en: To show how `pdhead()` works, we used it twice — although in real life, you
    would never use this function twice in a row. The first time, we used it without
    `n` (so, with the default `n` value of `2`), and the second time with `n` of `3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the function works as expected. The screenshot below shows how
    `pdhead()` works with the `cols` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/eb0b7286ff0fb290322f7a6ca545e5f8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Screenshot from Python 3.11: Using the pdhead function. Image by author.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, `cols` comes as handy when you want to see the dataframe with only selected
    columns. Here, we used both arguments, `n` and `cols`, and we saw the first three
    rows of a copy of the `d` data frame, with two columns: `xy` and `group`.'
  prefs: []
  type: TYPE_NORMAL
- en: As you may have noticed, `xy` was created within this very chain of operations,
    which does not pose any problems, as the temporary version of the dataframe for
    which we used `pdhead()` already contained this column.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily reimplement the function to show the tail of a dataframe, or
    to show the selected part of the dataframe: a subset of columns and/or a subset
    of rows. I’ll leave this to you as an exercise.'
  prefs: []
  type: TYPE_NORMAL
- en: Do something inside a chain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This time, I will present a general function that will enable you to do whatever
    you want inside a chain of Pandas operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This function is slightly more complex than the previous ones. It has two different
    use cases. Regardless of your intended action for the inspected dataframe, it
    must be reflected in the callable `func()`. You can use both positional and keyword
    arguments for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: '*Use case 1: Do not use the data frame*. In that case, set `usedf` to `False`.
    For example, you can print a flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6ddac4aa2de11e7a5f5685456c6740ef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Screenshot from Python 3.11: Using the pddo function to print a flag. Image
    by author.'
  prefs: []
  type: TYPE_NORMAL
- en: 'or the current date and time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ca18d09fb28d3434c03480931f1e47ba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Screenshot from Python 3.11: Using the pddo function to print date and time.
    Image by author.'
  prefs: []
  type: TYPE_NORMAL
- en: You can also log information— but remember that with `usedf` set to `False`
    you don’t have access to the data frame. If you require access, you’ll need to
    set this argument to `True`, and the next use case is all about it.
  prefs: []
  type: TYPE_NORMAL
- en: '*Use case 2: Use the data frame*. More interesting use cases involve accessing
    the dataframe. Let’s start with some simple examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/173115334f5dae56ea1053ae105a4281.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Screenshot from Python 3.11: Using the pddo function to print the shape of
    a dataframe. Image by author.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can use, when `usedf` is `True` (which is the default value of `pddo()`),
    you can use the dataframe. It’s used as the first argument to `func()` — and you
    can’t change that as otherwise `pipe()` would break down.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can, in fact, perform quite advanced operations using `pddo()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6082ee12d9c3135a0ba5e1f50cd475a3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Screenshot from Python 3.11: Using the pddo function to print the result of
    a complex pipe of Pandas operations. Image by author.'
  prefs: []
  type: TYPE_NORMAL
- en: The `foo()` function performs quite a complex chain of operations and prints
    the result. Still, once `pipe()` calling `pddo()` (which calls `foo()`) returns,
    the original chain returns to the state before the `pipe()` function was called.
  prefs: []
  type: TYPE_NORMAL
- en: What you need to remember that if you want something to be printed, you need
    to directly call the `print()` method. Actually, you can implement your own function
    in which you don’t need to call `print()` — I will leave you this as an exercise.
    However, such a version could be used only for printing while the current version
    of `pddo()` is more general, because you can, for example, log the dataframe to
    a logger.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have explored debugging chained operations using self-defined functions.
    The most crucial function is `pdbreakpoint()`, as it enables you do use `pdb`,
    the built-in interactive Python debugger. The other functions employed static
    debugging, but some of them could be used also for other purposes, such as logging.
  prefs: []
  type: TYPE_NORMAL
- en: You can expand this set of functions for debugging Pandas operations. They can
    be helpful for debugging pipes of these operations when you need to inspect the
    state of a dataframe at a specific point, without breaking the chain into separate
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know the concept, you should not have problems with implementing
    your own functions. Nevertheless, my suggestion is not to overdo with them. We’re
    talking about debugging, and I’d consider having to choose from a dozen or so
    functions to debug Pandas code a distraction rather than help.
  prefs: []
  type: TYPE_NORMAL
- en: To be honest, I myself use only the `pdbreakpoint()` function, but I wanted
    to share you with idea concept rather than just one function— so that you can
    choose your own approach to debugging. As I discussed in [my previous *Towards
    Data Science* article on debugging in Python](https://medium.com/towards-data-science/bugs-in-python-pdb-to-the-rescue-d88a56a2ca71),
    I’m a great fan of the `pdb` interactive debugger, and I rarely need to use anything
    else. But this doesn’t mean that other approaches are not equally useful, at least
    in certain situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks for reading. If you enjoyed this article, you may also enjoy other articles
    I wrote; you will see them [here](https://medium.com/@nyggus). And if you want
    to join Medium, please use my referral link below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/@nyggus/membership?source=post_page-----0089f6de920f--------------------------------)
    [## Join Medium with my referral link - Marcin Kozak'
  prefs: []
  type: TYPE_NORMAL
- en: As a Medium member, a portion of your membership fee goes to writers you read,
    and you get full access to every story…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/@nyggus/membership?source=post_page-----0089f6de920f--------------------------------)
  prefs: []
  type: TYPE_NORMAL
