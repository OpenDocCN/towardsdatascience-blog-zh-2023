- en: Unsupervised Learning Series — Exploring DBScan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/unsupervised-learning-series-exploring-dbscan-624c820290ce](https://towardsdatascience.com/unsupervised-learning-series-exploring-dbscan-624c820290ce)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Learn the theory behind the famous density-based clustering algorithm while
    using Python’s sklearn
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://ivopbernardo.medium.com/?source=post_page-----624c820290ce--------------------------------)[![Ivo
    Bernardo](../Images/39887b6f3e63a67c0545e87962ad5df0.png)](https://ivopbernardo.medium.com/?source=post_page-----624c820290ce--------------------------------)[](https://towardsdatascience.com/?source=post_page-----624c820290ce--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----624c820290ce--------------------------------)
    [Ivo Bernardo](https://ivopbernardo.medium.com/?source=post_page-----624c820290ce--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----624c820290ce--------------------------------)
    ·11 min read·Nov 21, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/74b7d631749ea7e4f95f5041fd619497.png)'
  prefs: []
  type: TYPE_IMG
- en: Image from [Kier in Sight Archives](https://unsplash.com/pt-br/@kierinsightarchives)
    @Unsplash.com
  prefs: []
  type: TYPE_NORMAL
- en: Clustering algorithms are one of the most widely used solutions in the data
    science world, with the most popular ones being grouped into distance-based and
    density-based approaches. Although often overlooked, density based-clustering
    methods are interesting alternatives to the ubiquitous [*k-means*](/unsupervised-learning-method-series-exploring-k-means-clustering-d129fff3ab6a?sk=0618fadb196a71ce4b9f378f9ee83107)
    and [*hierarchical*](/unsupervised-learning-series-exploring-hierarchical-clustering-15d992467aa8?sk=87714b0d7aa252330dd7a8d3b1c620f4)approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the famous density-based clustering techniques include *DBSCan* (Density-based
    spatial clustering of applications with noise) or Mean-Shift, two algorithms that
    use data points’ center of mass to group observations together.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this blog post, we’ll explore DBScan, a clustering algorithms that is particularly
    be useful when your data contains some of the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Clusters have an irregular shape. For example, a non spherical shape.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compared with other methods, DBScan doesn’t assume any prior about the underlying
    distribution of the data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your dataset contains some relevant outliers that shouldn’t influence how the
    clusters’ centroids are mapped.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If these three sentences were confusing to you, don’t worry! In this post, we’re
    going to see a step-by-step implementation of the *DBScan* method, while discussing
    the topics above. Also,we’ll check the famous `sklearn` Python implementation!
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, if you would like to drop by others posts of my Unsupervised Learning
    series, you can check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[K-means](/unsupervised-learning-method-series-exploring-k-means-clustering-d129fff3ab6a?sk=0618fadb196a71ce4b9f378f9ee83107)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Hierarchical Clustering](/unsupervised-learning-series-exploring-hierarchical-clustering-15d992467aa8?sk=87714b0d7aa252330dd7a8d3b1c620f4)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Self-Organizing Maps](/unsupervised-learning-series-exploring-self-organizing-maps-fe2efde9f7a1?sk=0a2649f9b411c236c2682729a5e616b4)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s then dive deep and understand how DBScan works!
  prefs: []
  type: TYPE_NORMAL
- en: Fitting Distance-Based Clustering Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this step-by-step playbook, we’ll use a toy dataset with information about
    customers. In this example, we’ll use a two variable clustering to make it easier
    to grasp.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s imagine that we run a shop and we have demographic information about our
    customers. **We would like to do some campaigns based on their annual income and
    age and we only want to run 3 or 4 distinct marketing campaigns.**
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we start by plotting these two variables in a scatter plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/87e8e912f5bf6b5d23eb6a55d97b9b66.png)'
  prefs: []
  type: TYPE_IMG
- en: Customer Age vs. Annual Income — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: For now, imagine that it is reasonable that someone makes 120$ per year (we’re
    just using this scale to have similar values between Age and Income, as that will
    make the explanation more intuitive).
  prefs: []
  type: TYPE_NORMAL
- en: '**If you look at the data, how many differents groups of customers do you see
    here?** 2? 3? 4? This is an open question that we can’t really answer because
    there is no label or correct answer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can argue that we have three different groups, by the way that the customers
    are scattered throughout the plot:'
  prefs: []
  type: TYPE_NORMAL
- en: One scattered cluster on the left side of the plot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A group of 5 to 6 customers on the center.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A third group of clusters on the right side of the plot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But, this is just a guess. Maybe *k-means* can help us! Let’s fit a k-means
    algorithm with 3 clusters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f01722e075bf4d0d4b7b22285aa56396.png)'
  prefs: []
  type: TYPE_IMG
- en: K-Means solution with 3 centroids — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: Although an interesting solution, it seems that our clustering is no picking
    up some patterns, being drawn away by outliers. What’s the result if we fit a
    solution with 4 centroids?
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d98f996a3b0ae052c8b12d7d62fba16b.png)'
  prefs: []
  type: TYPE_IMG
- en: K-means Solution with 4 centroids
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, the *k-means* solution is being driven away by outliers. Will Hierarchical
    Clustering help? Let’s see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/07fa692e3dd592fbc6b448c291a22b56.png)'
  prefs: []
  type: TYPE_IMG
- en: Ward Hierarchical Clustering — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the Ward method, our result is similar to *K-means* clustering (with
    3 centroids). Let’s change the linkage of the Hierarchical Clustering solution
    and see the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6e14f9c75c61c3ef45f3eccbca39ed29.png)'
  prefs: []
  type: TYPE_IMG
- en: Complete Hierarchical Clustering — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: Uh-oh, even worse! Changing the linkage method was also a bad option.
  prefs: []
  type: TYPE_NORMAL
- en: The crux of this exercise is that certain datasets are not a fit for distance-based
    clustering. Normally, people rush to use these types of clustering models as they
    are very interpretable but these solutions work better when our clusters are spherical
    and well defined.
  prefs: []
  type: TYPE_NORMAL
- en: Demystifying DBScan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve seen how distance-based clusters may not be a fit for certain
    types of data, let’s explore why *DBScan* is different.
  prefs: []
  type: TYPE_NORMAL
- en: 'DBScan starts by selecting a random point in our dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/af84aa0cc11a16d885c842fa5b9b28ae.png)'
  prefs: []
  type: TYPE_IMG
- en: DBScan Step 1— Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: After picking the data point, we draw a circle around this data point with a
    certain radius.
  prefs: []
  type: TYPE_NORMAL
- en: The radius of the circle built around the data point is a hyperparameter of
    the DBScan algorithm.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'For our example, we’ll draw a circle with a radius of 9 units:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/24b06bdba0da5bec514b262e3498ae70.png)'
  prefs: []
  type: TYPE_IMG
- en: DBScan Step 2— Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'How many datapoints points do the radius touch? In this case, our radius touches
    9 data points (including the data point itself). **This number is related to another
    hyperparameter of the DBScan algorithm: the *min_samples***.'
  prefs: []
  type: TYPE_NORMAL
- en: If the radius touches mo*re* or equal to what’s stated on *min_samples*, we
    consider the chosen data point as a core point!
  prefs: []
  type: TYPE_NORMAL
- en: Min_samples is another hyperparameter of the DBScan algorithm
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Being considered a core point gives significant power to the data point:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The data point belongs to a cluster.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The data point is able to call other data points from within the radius into
    the cluster.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After testing if the data point is a core point, we move to another point within
    the boundary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/85da5b6e60c64dde31b480c1513a66f2.png)'
  prefs: []
  type: TYPE_IMG
- en: Moving to Another Point on the DBScan Boundary — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: We’ve just moved to the data point right above our first data point. The next
    question is, naturally, if this is a core point?
  prefs: []
  type: TYPE_NORMAL
- en: 'You know how to do this test! Let’s start by drawing a boundary around the
    new data point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/27283b888b731af6532bfbe4c8f220f6.png)'
  prefs: []
  type: TYPE_IMG
- en: Drawing another Boundary on the second data point — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: '*Note: This circle has the exact same radius as the one we’ve seen before.*'
  prefs: []
  type: TYPE_NORMAL
- en: So.. is this a core point? No! Because this data points’ radius only touches
    8 data points, less than the *min_samples* hyperparameter we’ve defined.
  prefs: []
  type: TYPE_NORMAL
- en: '**We call this a satellite data point.** Although it belongs to the cluster
    (because it has been “summoned” by another data point), it will not have the right
    to call other data points within its boundary to the cluster. **This is the main
    difference between core and satellite points.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we’ve known two types of data points in the DBScan solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Core points:** Belong to a cluster and have the power to bring other points
    into it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Satellite points:** Belong to a cluster but don’t have the power to being
    other data points into it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**We consider that a cluster is defined when we touch satellite points that
    make a frontier.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our solution, all the data points below are considered satellite points
    (using our hyperparameters) and everything within their boundary belongs to a
    cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/245fdafcfd981c3233e9c70ff05cc358.png)'
  prefs: []
  type: TYPE_IMG
- en: Satellite points Frontier — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: But there’s still a group of data points that we haven’t spoke of — What about
    data points that are not called by other data points? Those points are definitely
    core points. They also cannot be considered satellite data points as they aren’t
    touched by any core point.
  prefs: []
  type: TYPE_NORMAL
- en: Those are called outliers! This is useful feature of the *dbscan* algorithm
    that incorporates the identification of outliers in the solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, take this data point right here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/75da58c7bf16e65209a70bf8b999d869.png)'
  prefs: []
  type: TYPE_IMG
- en: Outlier Identification — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'We can draw a radius around this data point as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c049d49da4f77408e20f0953b23421f6.png)'
  prefs: []
  type: TYPE_IMG
- en: Radius around Outlier — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: Notice that this data point is completely isolated from the other data points.
    Additionally, it does not have enough data points in its boundary to be considered
    a core data point.
  prefs: []
  type: TYPE_NORMAL
- en: 'This makes it an ***Outlier****.* Data points can be outliers in DBScan for
    two main reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: It doesn’t have enough data points in its boundary and is not a satellite point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only boundaries of *satellite points* are able to reach them. Remember that
    satellite points are not able to bring data points into their own cluster. Only
    core points share that responsability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data points in the DBScan algorithm are categorized into Core, Satellite and
    Outlier
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After cataloging all data points as either Core, Satellite or Outlier, the algorithm
    is complete!
  prefs: []
  type: TYPE_NORMAL
- en: What clusters will a DBScan solution find in our Age vs. Annual Income data?
    Let’s fit a dbscan solution with the following *hyperparameters* (do you still
    remember them?)
  prefs: []
  type: TYPE_NORMAL
- en: '**Epsilon = 9**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Min_Samples = 5**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/b5f3c5ae3dda4213d42dc8050de467e6.png)'
  prefs: []
  type: TYPE_IMG
- en: First DBScan Solution — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: '**The purple points are not a “cluster”. They are considered outliers by the
    solution.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have one upside and downside in this solution:'
  prefs: []
  type: TYPE_NORMAL
- en: Our 3 clusters have been created according to the density of points, which may
    be a good solution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unfortunately, these hyperparameters are also too strict in this solution, producing
    too many outliers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DbScan is sensitive to changes in the hyperparameters
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: One common trick is to do a *DBSCan* clustering that produces alot of outliers
    and thenrun a distance minimizing algorithm afterwards to allocate the leftover
    points (minimum euclidean distance to each cluster centroid, as an example).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another alternative is to tweak our *hyperparameters.* Here, we can raise *EPS*
    or minimize the *min_samples*, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**EPS** = 12'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Min Samples** = 4'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/a01644cfcd71fcd91356282e4ff4dfe2.png)'
  prefs: []
  type: TYPE_IMG
- en: Second DBScan Solution — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: This result is a bit different and we are able to consider less points as outliers.
    Although there’s no correct solution, analyzing the clusters with different hyperparameters
    will give you different solutions as this algorithm is quite sensitive to the
    *eps* and *min_samples* parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Given that we have acquired new knowledge on *DBScan,* let’s use it on a practical
    use case next!
  prefs: []
  type: TYPE_NORMAL
- en: Practical Use Case — Taxi Stations in the US
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The dataset we will be using for this practical case is based on the Taxi Trip
    Duration dataset available on [Kaggle](https://www.kaggle.com/competitions/nyc-taxi-trip-duration/data)
    and made available on Google BigQuery DataSets. For simplicity, we will just use
    a sample of the dataset to be able to plot it in a map.
  prefs: []
  type: TYPE_NORMAL
- en: The dataset contains a lot of information but what will interest us is the *pickup_longitude*
    and *pickup_latitude*. These two columns contain the GPS coordinates where the
    passenger joined the ride.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is to let the taxi company know where they should build their taxi
    stations. Knowing that it would be interesting to have cars readily available
    for passengers, their goal is to build stations in the most appropriate locations,
    trying to maximize the number of potential rides they can serve from the stations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, let’s start by loading the data using `pandas` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We have some data points that have their GPS coordinates wrongly stated. We
    need to remove those outliers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After removing these rows, let’s plot our pickup coordinates in a 2-D map.
    For the following code to work, you need to install and load `cartopy`and `contextily`-
    `cartopy` may have some issues when you install them on local environments (for
    example, using `conda` ) — if you are having trouble, install the library in a
    Google Colab environment using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After installing the dependencies, we can plot our data points on New York
    using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/7b0aba407e2684b08a2bbfded57d3562.png)'
  prefs: []
  type: TYPE_IMG
- en: New York Taxi Pickups — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'Before fitting our algorithm, we know that `dbscan` is based on distances.
    What should we do? Standardize! Let’s standardize `latitude` and `longitude` to
    the same scale. Although the lack of standardization would not cause too many
    issues for this data, it’s still a good practice to do it, particularly if you
    want to apply this use case to other datasets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Imagining we would like each of our taxi stations to serve at least 100 trips,
    how does this fit with our `dbscan` parameters?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can tweak the `min_samples` parameter! Let’s fit our first clustering solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve chosen `eps=0.25` . Let’s see our solution on a map! … but which coordinates
    should we plot? One interesting solution is to calculate the average value of
    the coordinates for each cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, `DBScan` represents outliers with the value `-1` . Let’s exclude these
    values as they are not considered a “cluster”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/c95c979713c4b4da83561b24e5a24521.png)'
  prefs: []
  type: TYPE_IMG
- en: New York Taxi Pickups Clustering — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'Very cool! We would setup 3 stations:'
  prefs: []
  type: TYPE_NORMAL
- en: One in Manhattan.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One in the JFK Airport.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One in La Guardia Airport.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Want to check which trips are “theoretically” served by which station?
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d5fea4715d5b0c21c125ed05d0e96f53.png)'
  prefs: []
  type: TYPE_IMG
- en: New York Taxi Pickups Clustering — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'Cool! Purple points are considered outliers of the `dbscan` solution. It seems
    that we are being a bit strict on our definition of clusters in the `DBScan`solution.
    Remember how to adjust this? Lowering `eps` or the `min_samples` arguments! Let’s
    try both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Checking the centroids of our new solution and plotting it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/8c551a499237c52b2cfa2e49afac596d.png)'
  prefs: []
  type: TYPE_IMG
- en: New York Taxi Pickups Clustering — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how we would setup more stations with these new parameters. By adjusting
    our `eps` and `min_samples` we were able to create smaller clusters in our data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6476e68db2d3f2a489cd13f5ab76bcb2.png)'
  prefs: []
  type: TYPE_IMG
- en: New York Taxi Pickups Clustering — Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: Keep adjusting the `eps` and `min_samples` parameters and see for yourself the
    impact on the clustering elements!
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DBScan is a widely used algorithm that can be very cool to use in certain scenarios,
    particularly when your clusters are not spherical and contain irregular patterns.
  prefs: []
  type: TYPE_NORMAL
- en: DBScan has been used in applications as different as gene expression clustering,
    customer analytics or in some instances of image segmentation. Although *k-means*
    and *hierarchical clustering* are more famous, density based clustering methods
    are very cool options you can consider for your unsupervised learning projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a nutshell, here’s what you should remember about DBScan:'
  prefs: []
  type: TYPE_NORMAL
- en: It is able to identify outliers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It divides points into core, satellite and outlier points.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It uses a radius (eps) around the data point to create the density cluster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It uses a minimum number samples (min_samples argument) to catalog the datapoint
    according to its function (core, satellite, other).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you enjoyed this post, make sure to read my other posts on the Unsupervised
    Learning series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[K-Means](/unsupervised-learning-method-series-exploring-k-means-clustering-d129fff3ab6a?sk=0618fadb196a71ce4b9f378f9ee83107)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Hierarchical Clustering](/unsupervised-learning-series-exploring-hierarchical-clustering-15d992467aa8?sk=87714b0d7aa252330dd7a8d3b1c620f4)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Self-Organizing Maps](/unsupervised-learning-series-exploring-self-organizing-maps-fe2efde9f7a1?sk=0a2649f9b411c236c2682729a5e616b4)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feel free to check the** [**Youtube**](https://youtu.be/um3_oEHBBTo) **video
    where I explain DBScan in my channel The Data Journey.**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you would like to drop by my Python courses, feel free to join my* [*Complete
    Python Bootcamp for Beginners*](https://www.udemy.com/course/the-python-for-absolute-beginners-bootcamp/?couponCode=APR2023)*.
    My Python courses are suitable for beginners/mid-level developers and I would
    love to have you on my class!*'
  prefs: []
  type: TYPE_NORMAL
- en: '*[The dataset used in this post is under Public Domain License]*'
  prefs: []
  type: TYPE_NORMAL
