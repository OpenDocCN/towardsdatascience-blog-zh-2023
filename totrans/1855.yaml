- en: Simple way to Deploy ML Models as Flask APIs on Amazon ECS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://towardsdatascience.com/simple-way-to-deploy-ml-models-as-flask-apis-on-amazon-ecs-7be11f9dc4d9](https://towardsdatascience.com/simple-way-to-deploy-ml-models-as-flask-apis-on-amazon-ecs-7be11f9dc4d9)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Deploy Flask APIs on Amazon ECS in 4 minutes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@nikola.kuzmic945?source=post_page-----7be11f9dc4d9--------------------------------)[![Nikola
    Kuzmic](../Images/b6be2a8e377bc450ced5260a79a1f4bb.png)](https://medium.com/@nikola.kuzmic945?source=post_page-----7be11f9dc4d9--------------------------------)[](https://towardsdatascience.com/?source=post_page-----7be11f9dc4d9--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----7be11f9dc4d9--------------------------------)
    [Nikola Kuzmic](https://medium.com/@nikola.kuzmic945?source=post_page-----7be11f9dc4d9--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ¬∑Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----7be11f9dc4d9--------------------------------)
    ¬∑6 min read¬∑Mar 10, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e65f1c65818c31933d75bdf5d19ede50.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Arjan van den Berg](https://unsplash.com/@arjan71?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: In this post we‚Äôll cover how to deploy a linear regression XGBoost model which
    predicts a developer‚Äôs salary based on their years of experience.
  prefs: []
  type: TYPE_NORMAL
- en: üëâ Game Plan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Train an XGBoost model
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a simple Flask API to serve model predictions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a Docker Image for the Flask API
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy the Docker Container on Amazon ECS
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Entire Source Code Github Repo: [link](https://github.com/kuzmicni/flask-on-ecs/tree/simple)üßë‚Äçüíª'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Why we need APIs to deploy ML models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are reading this post, likely you have reached the stage in your Data
    Science project where you want to make your awesome ML models available for everyone
    on the internet. People refer to this step as deploying them to production.
  prefs: []
  type: TYPE_NORMAL
- en: Here we won‚Äôt make things too complex and examine what a proper production-grade
    deployment should look like, rather we‚Äôre simply going to leverage the default
    Flask development server to demonstrate the process end-to-end what it takes to
    take the trained/pickled XGBoost ML model, dockerize it, and deploy it as a real-time
    API on Amazon ECS.
  prefs: []
  type: TYPE_NORMAL
- en: 'üëâ Step 1: Train an XGBoost model'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Train an XGBoost model to predict the developer salary based on their years
    of experience and save the model as a pickle file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run it inside VS Code, let‚Äôs create a separate Python 3.8 environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Then Restart VS Code and in Jupyter Notebook -> Select ‚Äò**py38demo**‚Äô as the
    Kernel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Train & pickle the XGBoost model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2723cb7fac45c5d3298592071ff9c2e7.png)'
  prefs: []
  type: TYPE_IMG
- en: Time to create an API which can serve these recommendations!
  prefs: []
  type: TYPE_NORMAL
- en: 'üëâ Step 2: Flask API'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our API will load the XGBoost model, accept POST requests, and produce a response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs first run our API locally. Then in a separate terminal we can test it
    by sending a payload POST request to see what a developer with 2.5 years of experience
    would make:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/25839f9865edaa4a0c8f48fc538e5b5e.png)'
  prefs: []
  type: TYPE_IMG
- en: $260k after 2.5 years, and $750k after 12.5 years. Not bad! ü§ë
  prefs: []
  type: TYPE_NORMAL
- en: 'üëâ Step 3: Docker Image'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To run our application inside the Docker Container, we need a ‚Äúblueprint‚Äù with
    instructions on what environment to use, which local files to copy, and how to
    run the application. All of this is referred to as a Docker Image and by convention
    it is specified in a **Dockerfile**
  prefs: []
  type: TYPE_NORMAL
- en: We can now run our API inside the Docker container and test locally as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: since I am building the image on a Mac, I need to specify'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '- - platform linux/amd64'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: for it to be compatible with the ECS Fargate Linux environment.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Here‚Äôs how we build & run the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: we bind our host (i.e. laptop‚Äôs) port 80 to docker container‚Äôs port 80:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Let‚Äôs test our API which is now running inside the Docker Container! üì¶
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/713eeda0fea59338e8683225bd070861.png)'
  prefs: []
  type: TYPE_IMG
- en: Time to deploy this on AWS! üöÄ
  prefs: []
  type: TYPE_NORMAL
- en: 'üëâ Step 4: Run the container on Amazon ECS'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section may look overwhelming at first, but actually it‚Äôs quite simple
    if we break the process into 6 simple steps.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d1fd7ac870f7b51f76e2bb1fbde293c0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Chrome Logo: [1], Flask Logo: [2]'
  prefs: []
  type: TYPE_NORMAL
- en: '**i) Push the Docker image to ECR**'
  prefs: []
  type: TYPE_NORMAL
- en: Let‚Äôs create an ECR repo called **demo** where we can push the Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/052bc48fc29df4f521e507c1ce4522c1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then we can use the Push Commands provided by ECR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Assumption: you have configured AWS CLI on your local machine and setup an
    IAM user with the right permission to interact with the ECR. You can find more
    info at this [link](https://docs.aws.amazon.com/AmazonECR/latest/userguide/getting-started-cli.html).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After running the above 3 commands, we can see our image is there on ECR! üéâ
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ef09ad855af44d36c11bf523fc372e78.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Copy & Paste the Image URI** somewhere as we‚Äôll need it in the next couple
    of steps.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**ii) Create an IAM Execution Role**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create an Execution Role so that our ECS task which will run the
    container has the access to pull images from the ECR. We‚Äôll name it: **simpleRole**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/baa3344183dc1d1c70b2124b4fd2f84e.png)'
  prefs: []
  type: TYPE_IMG
- en: '**iii) Create a Security Group**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Security Group is needed to allow anyone on the internet to send requests to
    our application. In the real world you may want to constrain this to a specific
    set of IPs but here we‚Äôll open it for everyone and call it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**simpleSG**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b03a4f6fdaa10334799b8dd0fc1e057b.png)'
  prefs: []
  type: TYPE_IMG
- en: '**iv) Create an ECS Cluster**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This step is straightforward and only takes couple seconds. We‚Äôll call it:
    **flaskCluster**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7e86f7cfaede8933a5bacb1fb73dbbc1.png)'
  prefs: []
  type: TYPE_IMG
- en: while our cluster is being provisioned, let‚Äôs create a Task Definition.
  prefs: []
  type: TYPE_NORMAL
- en: '**v) Create a Task Definition**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Task Definition, as the name implies is a set of instructions related to which
    image to run, port to open, and how much virtual CPU and memory we want to allocate.
    We‚Äôll call it: **demoTask**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/713bffc8c5e6f1cd4fdd219169bb96af.png)'
  prefs: []
  type: TYPE_IMG
- en: '**vi) Run the Task**'
  prefs: []
  type: TYPE_NORMAL
- en: Let‚Äôs run our **demoTask** on our **flaskCluster,** with the **simpleSG** we
    created in ***step iii)***.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f46cd2d6ea10f104037ae766e2a28ad7.png)'
  prefs: []
  type: TYPE_IMG
- en: Time to test out the deployed API from the **Public IP** address! ü•Å
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/e6b6a8e4fe5ebf0fa9d349352a483afc.png)'
  prefs: []
  type: TYPE_IMG
- en: It‚Äôs working! ü•≥
  prefs: []
  type: TYPE_NORMAL
- en: As you can see we are able to get the salary predictions by sending POST requests
    to the **Public IP** provided by ECS. üî•
  prefs: []
  type: TYPE_NORMAL
- en: Final Words
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This was just a simple demonstration of how we can dockerize our XGBoost models
    and deploy them on Amazon ECS for real-time inference. However, we used the default
    development server provided by Flask and instead should use a production-grade
    application server like Gunicorn which we‚Äôll cover in the next post.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks for reading and I hope you found this useful for getting started with
    Flask, Docker and Amazon ECS!
  prefs: []
  type: TYPE_NORMAL
- en: Want more useful articles on ML Engineering?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[*Subscribe for free*](https://medium.com/@nikola.kuzmic945/subscribe) *to
    get notified when I publish a new story.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Become a Medium member to read more stories from me and thousands of other
    writers. You can support me by using my* [*referral link*](https://medium.com/@nikola.kuzmic945/membership)
    *when you sign up. I‚Äôll receive a commission at no extra cost to you.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**References**'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] Chrome Logo: [Link](https://logos-world.net/chrome-logo/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] Flask Logo: [Link](https://flask.palletsprojects.com/en/2.2.x/)'
  prefs: []
  type: TYPE_NORMAL
