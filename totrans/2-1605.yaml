- en: 'Optimizing Connections: Mathematical Optimization within Graphs'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/optimizing-connections-mathematical-optimization-within-graphs-7364e082a984](https://towardsdatascience.com/optimizing-connections-mathematical-optimization-within-graphs-7364e082a984)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/9b3b31ccdb700cdf4e096983187caa65.png)'
  prefs: []
  type: TYPE_IMG
- en: Disconnected graphs. Image created with Dall-E 2 by the author.
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to graph theory and its applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://hennie-de-harder.medium.com/?source=post_page-----7364e082a984--------------------------------)[![Hennie
    de Harder](../Images/3e4f2cccd6cb976ca3f8bf15597daea8.png)](https://hennie-de-harder.medium.com/?source=post_page-----7364e082a984--------------------------------)[](https://towardsdatascience.com/?source=post_page-----7364e082a984--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----7364e082a984--------------------------------)
    [Hennie de Harder](https://hennie-de-harder.medium.com/?source=post_page-----7364e082a984--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----7364e082a984--------------------------------)
    ·13 min read·Jul 28, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '**In this post, we delve into the world of mathematical optimization within
    graphs, exploring key concepts, algorithms, and practical applications. Graph
    problems can be found in many places. Obvious ones are in logistics or social
    network analysis, like finding the optimal route for a delivery company or the
    lowest amount of connections between two people. But did you know that graphs
    are also applicable in urban planning, disease transmission modeling, fraud detection,
    recommendation engines, and cybersecurity? By leveraging optimization algorithms
    specifically designed for graphs, data scientists can uncover optimal solutions,
    allocate resources efficiently, and make data-driven decisions.**'
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll start with an introduction section, to explain the basics of graphs.
    Then we dive into common graph problems and algorithms trying to solve these problems.
  prefs: []
  type: TYPE_NORMAL
- en: Graph Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a recap, below the basics on graph theory.
  prefs: []
  type: TYPE_NORMAL
- en: What is a graph?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A graph consists of vertices (or nodes) and edges. If the vertices are related
    in a certain way, they are connected with an edge. To define a graph, you need
    the names of all the vertices and you need to know which vertices are connected.
  prefs: []
  type: TYPE_NORMAL
- en: Below a graph that has vertices {A, B, C, D, E} and edges {{A, D}, {A, E}, {B,
    C}, {B, D}, {C, D}}.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/26104cd30f3e3328155310a42c084ce1.png)'
  prefs: []
  type: TYPE_IMG
- en: Simple graph. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, graphs can contain *loops*. A loop is an edge that has the same start
    and end node (a node is connected with itself).
  prefs: []
  type: TYPE_NORMAL
- en: 'Other terms that are nice to know in graph theory:'
  prefs: []
  type: TYPE_NORMAL
- en: The *order* of a graph is equal to its number of vertices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *size* of a graph is the number of edges (sometimes plus the number of vertices).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *degree* of a vertex is the amount of edges it has (a loop is counted twice
    for the beginning and end point).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common variations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous graph example is also called a *simple graph*, because it only
    contains vertices and (undirected) edges. But you can easily make it a bit more
    complex, and often more interesting, by providing additional information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Below an example of a *directed graph* (a.k.a digraph), where the edges are
    pointed in a certain direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f61afead3a89631492b8c04b1199d3b4.png)'
  prefs: []
  type: TYPE_IMG
- en: Directed graph. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another graph that is a fit in many situations is a *weighted graph*. In a
    weighted graph, the edges are associated with a weight: this can be anything,
    e.g. length or costs.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/cceedb61743fb27e3c6375419b43f869.png)'
  prefs: []
  type: TYPE_IMG
- en: Weighted graph. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last interesting graph variation discussed here is a *multigraph*. In a
    multigraph, the same edge can occur more than once:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/bbd106886fe6eaac4a2e48ab35ef10e7.png)'
  prefs: []
  type: TYPE_IMG
- en: Multigraph. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: There are many special types of graphs with their own properties. E.g.
    a graph in which each pair of vertices is connected with an edge is called a complete
    graph.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: From Problem to Graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How to create a graph out of a problem? Let’s go through some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Locations and Distances**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A classic problem is a problem for which you have locations and distances between
    the locations. In the *adjacency* matrix below, the distances between the locations
    are provided (if there is a distance greater than 0, there is an edge). From this
    matrix, you can easily create a graph.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/d02837525b3e90fe7f3d360b1afb12a0.png)'
  prefs: []
  type: TYPE_IMG
- en: Graph created from the matrix. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create matrices from a graph, common ones are the *incidence* and
    the *degree* matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s replace the weights by the name of the edge:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6474a10598f2a4eef6fa8e8a8946ccdf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'No we can create the incidence matrix, it has a row for each node and a column
    for each edge. It shows which nodes are connected by an edge:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For a weighted graph, we can replace the ones by the weights of the corresponding
    edge.
  prefs: []
  type: TYPE_NORMAL
- en: 'The degree matrix is a diagonal matrix and counts the number of edges attached
    to each node. A loop is counted twice. For the previous graph, the degree matrix
    would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: Official matrix form is without index row and index column. For clarity
    they are added.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Flows**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Directed graphs often deal with network flows. E.g. in networks where data
    is transmitted, in transportation, or in pipelines. If you know how much the maximum
    capacity is between two nodes, you can create a network flow graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9d9ea1db92b424f260bf655ea772e076.png)'
  prefs: []
  type: TYPE_IMG
- en: Digraph with Source (S) and Sink (T). Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: The source (s) and the sink (t) are the starting and ending point of the flow.
    The edges are directed, they show the direction of the flow between nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tree graphs**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A special type of graph is a tree graph. You can find them in many different
    places: competition schedules, family trees, organizational charts and evolutionary
    trees. A tree is *undirected*, *acyclic* and *connected*. It should not contain
    a cycle or directed edges, and all nodes are connected to the tree.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c52ee54b9ad721f05328968bf6bb1af1.png)'
  prefs: []
  type: TYPE_IMG
- en: Three tree graphs. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: 'A tree has interesting properties:'
  prefs: []
  type: TYPE_NORMAL
- en: It always has `n-1` edges (where `n` is the number of nodes).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a unique path between any pair of nodes in a tree.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing a single edge will disconnect the graph (split the graph in two).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Social Network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Connections between people are nice to visualize in a graph. By analyzing relationships
    and visualizing them, you can extract valuable insights. Here is an example of
    7 people, if they are connected on social media, they are connected with an edge:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0ee53fe6222b84dbdda98c857e8eed8a.png)'
  prefs: []
  type: TYPE_IMG
- en: Network of people. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: 'Questions that can arise by looking at this graph are:'
  prefs: []
  type: TYPE_NORMAL
- en: Who are the most important people?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which persons are most similar to each other?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can we predict missing links?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we cluster these people in the best way?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common algorithms applied to graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After modeling a situation as graph, you can solve the problem at hand. For
    the different examples in the previous paragraph, we will apply algorithms to
    find the shortest path, calculate the maximum flow and minimum cut, determine
    the minimum spanning tree and touch upon topics in graph analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Shortest Path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first problem to solve is the shortest path problem: how should we go from
    A to B while keeping the route as short as possible?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/94b7bbb0ece4b97fc359d5795d50456e.png)'
  prefs: []
  type: TYPE_IMG
- en: Graph. How to find the shortest route from A to I? Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: 'An algorithm that is used often for solving this problem is Dijkstra’s algorithm.
    It works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1.** The starting node has distance 0\. Set the rest of the nodes at
    distance infinity, this is their provisional distance. There are three types of
    nodes: *visited*, *unvisited* and the *current* node. For the first run the current
    node is the starting node.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c4021a0b7797c05874d7a395cc11549d.png)'
  prefs: []
  type: TYPE_IMG
- en: Starting node is the yellow node with distance 0\. All other distances are set
    to infinity. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 2.** Look at the direct neighbors of the current node and calculate
    the distance to them (via the current node). If this distance is smaller than
    the smallest distance so far, replace the old distance with the new distance.
    To discover the fastest route, mark the new route if the distance is accepted
    (and remove previous marked route if that exists).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e0f8b81e59126d0bb0e9d3196ae17289.png)'
  prefs: []
  type: TYPE_IMG
- en: Look at all the neighbors of the current node and replace the provisional distance
    with the new distance if the new distance is smaller. Mark the ‘accepted’ routes
    (routes with a shorter distance) green. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 3.** Now the first node can be marked as visited (green), and the new
    current node will be the unvisited node with the lowest provisional distance (yellow
    node in the image below has distance 1). Continue with step 2 for this node, and
    repeat step 2 and 3 until the end node is reached.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/823498aaa7c22a5ac0844eb55194f0d3.png)'
  prefs: []
  type: TYPE_IMG
- en: New current node marked yellow. Previous yellow node marked as visited. Image
    by author.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2e25af4b8a0f986e6302e3e44971eedd.png)'
  prefs: []
  type: TYPE_IMG
- en: Step 2 applied for the second node. The upper node gets a new distance of 2,
    1+1 (because that is shorter than its provisional distance of 3). We can choose
    between the two yellow nodes for applying step 2 again. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we repeat these steps, in the end the solved graph looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3329717be2d40e6232ee892f116da381.png)'
  prefs: []
  type: TYPE_IMG
- en: Finding the shortest path with Dijkstra’s algorithm. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: Now we found the shortest distance from the start node to every other node,
    together with the corresponding routes (green edges)! Dijkstra’s algorithm is
    applied widely and popular because it is efficient and avoids unnecessary computations.
  prefs: []
  type: TYPE_NORMAL
- en: There are many more fun shortest path problems, like the [Chinese postman problem](https://en.wikipedia.org/wiki/Chinese_postman_problem),
    where you have to discover the shortest route while visiting all edges, or the
    traveling salesman problem where you have to visit all the nodes. The traveling
    salesman problem can be solved in many different ways, for example with [mixed
    integer programming](/how-to-handle-optimization-problems-daf97b3c248c) (example
    2) or with [simulated annealing](/local-search-with-simulated-annealing-from-scratch-9f8dcb6c2e06)
    (example 1).
  prefs: []
  type: TYPE_NORMAL
- en: Maximum Flow & Minimum Cut
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An important question in flow graphs is: How much flow can be send from the
    source to the sink? The weights at the edges correspond to the capacity of an
    edge and those capacities can never be exceeded. The incoming flow for every node
    should be equal to the outgoing flow (except for the source and the sink).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Below an example of a maximum flow problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9d9ea1db92b424f260bf655ea772e076.png)'
  prefs: []
  type: TYPE_IMG
- en: Digraph with Source (S) and Sink (T). Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: How can we solve this problem and discover how much flow can reach the sink?
    There are several different algorithms for this. Let’s solve this using the Ford-Fulkerson
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1\.** Set the initial capacity to 0 on all edges.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f1fceb180090220f6a7f0025ac9a2119.png)'
  prefs: []
  type: TYPE_IMG
- en: Initial capacity set to 0 for all edges. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 2\.** Find an *augmenting path* from source to sink. This is a path
    that has unused capacity greater than 0 on all edges and starts at the source
    and ends at the sink. You can find augmenting paths with e.g. breadth first search
    or depth first search.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d9d66ca94bf472638b9736c05d70586e.png)'
  prefs: []
  type: TYPE_IMG
- en: An augmenting path from source to sink. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 3.** For the augmenting path from step 2, we can find the *bottleneck*,
    this is the edge with the smallest remaining capacity. We increase the capacity
    on all edges for the augmenting path with this value.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/cf46b69723e15b812a677a219b029fca.png)'
  prefs: []
  type: TYPE_IMG
- en: Capacity increased with 3 (value of the bottleneck edge). Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 4\.** Continue with step 2 and 3 until there is no augmenting path left.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d698ad0a957a8d8556bd033706c36f7c.png)'
  prefs: []
  type: TYPE_IMG
- en: Another augmented path with updated capacity of 5\. 5 was the lowest remaining
    capacity for the edges, so the capacities are updated with 5\. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: 'After continuing doing this, in the end there are no more augmenting paths
    possible. The end result can look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/13c978dc1ef11bcae776d9e1f67cb001.png)'
  prefs: []
  type: TYPE_IMG
- en: Solved! There are more solutions possible that will yield the same result. Image
    by author.
  prefs: []
  type: TYPE_NORMAL
- en: The maximum flow is easily found by adding 11 + 1 + 4 = 16\. These are the flows
    of the edges directed to the sink. This problem can also be solved with [linear
    programming](/a-beginners-guide-to-linear-programming-and-the-simplex-algorithm-87db017e92b4).
  prefs: []
  type: TYPE_NORMAL
- en: Related to maximum flow is *minimum cut*. The minimum cut is finding the lowest
    sum of weight of connections you need to disconnect to split the network into
    two separate parts. It is closely related to maximum flow, because when you found
    the solution of maximum flow, you can derive the minimum cut as well. They are
    equal to each other.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/df848de2f4b4c6ca7175b6b5e72552ea.png)'
  prefs: []
  type: TYPE_IMG
- en: Minimum cut. Divide the graph in two pieces while trying to minimize the sum
    of the weight of the removed edges. The weight of the edges removed in this image
    is the minimum cut, which is the same as the value of the maximum flow, 16 in
    this example. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: Minimum cut is used in image segmentation, for example to separate an object
    from the background. Another critical application of minimum cut is analyzing
    the reliability of complex networks, such as power grids or communication networks,
    by identifying critical edges whose failure can lead to network disconnection
    or reduced performance.
  prefs: []
  type: TYPE_NORMAL
- en: Minimum Spanning Tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine you are the boss of a railway company and you want to discover how
    to connect seven cities with the lowest amount of railway possible. What you are
    looking for in this case is the *minimum spanning tree*. If we visualize this
    problem it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c9902afe0c0ec93db5e37f751ca29b5b.png)'
  prefs: []
  type: TYPE_IMG
- en: Connected cities. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: How can we calculate the minimum spanning tree in this graph? We can use Prim’s
    algorithm, which is a greedy algorithm and quite easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1\.** Choose one node of the graph to start with, arbitrarily. This
    node is the first part of the tree.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a13040379c843fc6f9db996c36aee509.png)'
  prefs: []
  type: TYPE_IMG
- en: Red house chosen to start with.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 2.** Grow the tree by one edge. Select the edge that has the minimum
    weight of all edges connected to the tree.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/379936dde32d3e3bbe9fd4eb817760ff.png)'
  prefs: []
  type: TYPE_IMG
- en: Selected edge. Smallest edge from the city in the center. The house on the top
    right is also in the tree. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 3.** Repeat step 2 until all nodes are in the tree.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next edge we select is the one with weight 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/77c8c84da675c5ee12991d1887929e22.png)'
  prefs: []
  type: TYPE_IMG
- en: Tree is growing… Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, we found the minimum spanning tree with a total length of 17.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3a50165122e0cc6d8c67f56272c7d2be.png)'
  prefs: []
  type: TYPE_IMG
- en: Final tree in red. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: The minimum spanning tree has many different applications. The most straightforward
    one is network design, when a network has to be fully connected with the lowest
    weight. Examples of such networks are telecommunication networks, computer networks,
    electrical power distribution systems and transportation networks. Did you know
    that minimum spanning trees are also used in taxonomy, cluster analysis, feature
    extraction for computer vision and in handwriting recognition? If you dive into
    the applications of minimum spanning trees, you discover there are quite a lot!
  prefs: []
  type: TYPE_NORMAL
- en: Centrality & Similarity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Graph analysis leverages the tools and techniques developed in graph theory
    to gain insights and make informed decisions in different domains, such as social
    networks, transportation networks, computer networks, biology, and many others.
  prefs: []
  type: TYPE_NORMAL
- en: Centrality and similarity are two core concepts in graph analysis. You might
    have heard of the [PageRank algorithm](https://en.wikipedia.org/wiki/PageRank)
    used by Google Search. PageRank is a centrality algorithm used to measure the
    importance or influence of nodes in a network, particularly in web page ranking
    and hyperlink analysis. It assigns a numerical score to each node based on the
    number and quality of incoming links, helping identify key nodes in a network.
  prefs: []
  type: TYPE_NORMAL
- en: '*Betweenness centrality* is another measure of centrality. The node with the
    highest betweenness centrality acts as the most important bridge among all the
    other nodes. To find the betweenness centrality of a node, we need to look at
    all the pairs of nodes and see how many times each node appears on the shortest
    path between two other nodes. The node who appears on the most shortest paths
    is the one with the highest betweenness centrality.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4de586827c31eed4ca3c1a77152da603.png)'
  prefs: []
  type: TYPE_IMG
- en: Graph with nodes and betweenness centrality for every node. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: In social networks or real-world systems, nodes (e.g. people, places, or entities)
    with high betweenness centrality play a crucial role in maintaining communication
    and connections between different parts of the network. They act as important
    mediators, ensuring efficient communication and keeping the network connected.
  prefs: []
  type: TYPE_NORMAL
- en: It can also be useful to find out how similar certain nodes are. This can be
    done by calculating *node similarity*. Jaccard Similarity is often used for unweighted
    graphs. It calculates the similarity between two nodes based on the number of
    common neighbors they share, divided by the total number of unique neighbors they
    have.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s calculate the Jaccard Similarity for node 2 and 4 in the graph. They share
    2 neighbors (node 3 and 5), and the total number of unique neighbors is 5 (node
    1, 2, 3, 4 and 5). 2 divided by 5 gives a Jaccard Similarity of 0.4.
  prefs: []
  type: TYPE_NORMAL
- en: Node similarity is used in collaborative filtering techniques to recommend items
    to users based on the similarity of their preferences with other users. It can
    also be used to predict missing or future links in a network or for detecting
    clusters and communities.
  prefs: []
  type: TYPE_NORMAL
- en: What’s next?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was just a glimpse into the world of graph theory and graph analysis. Beyond
    what we’ve explored here, there are many more exciting problems and applications
    waiting to be discovered. The beauty of graph theory lies in its versatility;
    it offers a way to tackle real-world challenges by transforming them into graph-based
    puzzles solvable with clever algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: From social networks to logistics, countless real-world problems find their
    perfect match in the realm of graphs. Unraveling communities, uncovering hidden
    connections, and exploring the unique properties of different graph types are
    interesting aspects of graph theory.
  prefs: []
  type: TYPE_NORMAL
- en: In the realm of data science, graphs become allies, enabling the creation of
    features that can have a huge impact on model performance. Graph embeddings hold
    the key to unlocking new dimensions of understanding within vast datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, this post made you curious to dive deeper into the wonders of graph
    theory!
  prefs: []
  type: TYPE_NORMAL
- en: Related
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](/four-ways-to-combine-mathematical-optimization-and-machine-learning-8cb874276254?source=post_page-----7364e082a984--------------------------------)
    [## Five ways to combine Mathematical Optimization and Machine Learning'
  prefs: []
  type: TYPE_NORMAL
- en: Practical examples of combining two forces.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/four-ways-to-combine-mathematical-optimization-and-machine-learning-8cb874276254?source=post_page-----7364e082a984--------------------------------)
    [](/constraint-programming-explained-2882dc3ad9df?source=post_page-----7364e082a984--------------------------------)
    [## Constraint Programming Explained
  prefs: []
  type: TYPE_NORMAL
- en: The core of a constraint programming solver and the relationship with mixed
    integer programming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'towardsdatascience.com](/constraint-programming-explained-2882dc3ad9df?source=post_page-----7364e082a984--------------------------------)
    [](/an-introduction-to-a-powerful-optimization-technique-simulated-annealing-87fd1e3676dd?source=post_page-----7364e082a984--------------------------------)
    [## An Introduction to a Powerful Optimization Technique: Simulated Annealing'
  prefs: []
  type: TYPE_NORMAL
- en: Explanation, parameters, strengths, weaknesses and use cases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/an-introduction-to-a-powerful-optimization-technique-simulated-annealing-87fd1e3676dd?source=post_page-----7364e082a984--------------------------------)
  prefs: []
  type: TYPE_NORMAL
