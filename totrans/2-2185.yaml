- en: Understanding Histograms and Kernel Density Estimation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解直方图和核密度估计
- en: 原文：[https://towardsdatascience.com/understanding-histograms-and-kernel-density-estimation-6f9a1f09f960](https://towardsdatascience.com/understanding-histograms-and-kernel-density-estimation-6f9a1f09f960)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/understanding-histograms-and-kernel-density-estimation-6f9a1f09f960](https://towardsdatascience.com/understanding-histograms-and-kernel-density-estimation-6f9a1f09f960)
- en: An in-depth exploration of histograms and KDE
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对直方图和 KDE 的深入探索
- en: '[](https://reza-bagheri79.medium.com/?source=post_page-----6f9a1f09f960--------------------------------)[![Reza
    Bagheri](../Images/7c5a7dc9e6e31048ce31c8d49055987c.png)](https://reza-bagheri79.medium.com/?source=post_page-----6f9a1f09f960--------------------------------)[](https://towardsdatascience.com/?source=post_page-----6f9a1f09f960--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----6f9a1f09f960--------------------------------)
    [Reza Bagheri](https://reza-bagheri79.medium.com/?source=post_page-----6f9a1f09f960--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://reza-bagheri79.medium.com/?source=post_page-----6f9a1f09f960--------------------------------)[![Reza
    Bagheri](../Images/7c5a7dc9e6e31048ce31c8d49055987c.png)](https://reza-bagheri79.medium.com/?source=post_page-----6f9a1f09f960--------------------------------)[](https://towardsdatascience.com/?source=post_page-----6f9a1f09f960--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----6f9a1f09f960--------------------------------)
    [Reza Bagheri](https://reza-bagheri79.medium.com/?source=post_page-----6f9a1f09f960--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----6f9a1f09f960--------------------------------)
    ·26 min read·Dec 18, 2023
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·发表于 [Towards Data Science](https://towardsdatascience.com/?source=post_page-----6f9a1f09f960--------------------------------)
    ·26 分钟阅读·2023年12月18日
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/56ccb5112d3a3de4f81b576c14a5bf05.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/56ccb5112d3a3de4f81b576c14a5bf05.png)'
- en: A histogram is a graph that visualizes the frequency of numerical data. It is
    commonly used in data science and statistics to have a raw estimate of the distribution
    of a dataset. Kernel density estimation (KDE) is a method for estimating the probability
    density function (PDF) of a random variable with an unknown distribution using
    a random sample drawn from that distribution. Hence, it allows us to infer the
    probability density of a population, based on a finite dataset sampled from it.
    KDE is often used in signal processing and data science, as an essential tool
    to estimate the probability density. This article discusses the math and intuition
    behind histograms and KDE and their advantages and limitations. It also demonstrates
    how KDE can be implemented in Python from scratch. *All figures in this article
    were created by the author.*
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图是可视化数值数据频率的图形。它通常用于数据科学和统计学中，以对数据集的分布进行初步估计。核密度估计（KDE）是一种通过从未知分布中抽取的随机样本来估计随机变量的概率密度函数（PDF）的方法。因此，它允许我们基于从中抽样的有限数据集推断总体的概率密度。KDE
    常用于信号处理和数据科学，是估计概率密度的一个重要工具。本文讨论了直方图和 KDE 背后的数学和直觉，以及它们的优缺点。它还演示了如何从头开始在 Python
    中实现 KDE。*本文中的所有图形均由作者创建。*
- en: '**Probability density function**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**概率密度函数**'
- en: Let *X* be a continuous random variable. The probability that *X* takes a value
    in the interval [a, b] can be written as
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 设 *X* 为连续随机变量。*X* 在区间 [a, b] 内取值的概率可以写作
- en: '![](../Images/bf374bc061fff3dd976a7ab701ffbcd0.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/bf374bc061fff3dd976a7ab701ffbcd0.png)'
- en: 'where *f(x)* is *X*''s probability density function (PDF). The *cumulative
    density function* (CDF) of *X* is defined as:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *f(x)* 是 *X* 的概率密度函数（PDF）。*X* 的*累积分布函数*（CDF）定义为：
- en: '![](../Images/7dc86dc593def60ca610dfc98cf02530.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7dc86dc593def60ca610dfc98cf02530.png)'
- en: 'Hence the CDF of *X*, evaluated at *x*, is the probability that *X* will take
    a value less than or equal to *x*. Using Equation 1, we can write:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*X* 的累积分布函数（CDF），在 *x* 处的值是 *X* 取小于或等于 *x* 的值的概率。使用方程 1，我们可以写道：
- en: '![](../Images/0bf17bada42795f6728f44201799ae22.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0bf17bada42795f6728f44201799ae22.png)'
- en: Using the fundamental theorem of calculus, we can show that
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微积分基本定理，我们可以证明
- en: '![](../Images/65e8f11be5d3e6fc5e0860e7a68000c4.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/65e8f11be5d3e6fc5e0860e7a68000c4.png)'
- en: which means that the PDF of *X* can be determined by taking the derivative of
    its CDF with respect to *x*. A histogram is the simplest approach to estimate
    the PDF of a dataset, and as we show in the next section it uses Equation 1 for
    this purpose.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 *X* 的概率密度函数（PDF）可以通过对其累积分布函数（CDF）关于 *x* 的导数来确定。直方图是估计数据集 PDF 的最简单方法，如我们在下一节所示，它利用方程
    1 达到这一目的。
- en: '**Histograms**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**直方图**'
- en: 'In Listing 1, we create a bimodal distribution as a mixture of two normal distributions
    and draw a random sample of size 1000 from this distribution. Here we mix two
    normal distributions:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表1中，我们创建了一个双峰分布，作为两个正态分布的混合，并从该分布中抽取了大小为1000的随机样本。这里我们混合了两个正态分布：
- en: '![](../Images/5699c23a9452e463032a65f8fae65723.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5699c23a9452e463032a65f8fae65723.png)'
- en: 'Hence, the mean of the normal distributions is 0 and 4 respectively and their
    variance is 1 and 0.8 respectively. The mixing coefficients are 0.7 and 0.3, so
    the PDF of the mixture of these distributions is:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正态分布的均值分别是0和4，方差分别是1和0.8。混合系数为0.7和0.3，因此这些分布的混合PDF为：
- en: '![](../Images/ddd8ba262d782e1f8e94d1c406e8133b.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ddd8ba262d782e1f8e94d1c406e8133b.png)'
- en: Listing 1 plots this PDF and sample in Figure 1.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1绘制了图1中的PDF和样本。
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![](../Images/4af127bc95b9f252673748c4012612ef.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4af127bc95b9f252673748c4012612ef.png)'
- en: Figure 1
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图1
- en: Now suppose that we only had the sample dataset, and the bimodal distribution
    was unknown, how could we estimate the PDF of this distribution from the dataset?
    The simplest thing we can do is draw this dataset's histogram. Listing 2 plots
    a histogram of the random sample that we generated in Listing 1 along with the
    PDF of the distribution. Even though it does not have a smooth surface, it mimics
    the shape of the PDF of the distribution.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们只有样本数据集，而双峰分布是未知的，我们如何从数据集中估计该分布的PDF？我们可以做的最简单的事情是绘制这个数据集的直方图。列表2绘制了在列表1中生成的随机样本的直方图，并附上了该分布的PDF。尽管它没有平滑的表面，但它模仿了分布的PDF的形状。
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![](../Images/061b2ef5a1ac5cbf6f34cf944c1c2216.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/061b2ef5a1ac5cbf6f34cf944c1c2216.png)'
- en: Figure 2
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图2
- en: 'Let’s see how a histogram is generally constructed. Using the definition of
    derivative and Equations 2 and 3 we can write:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下直方图的基本构造。利用导数定义和方程2及方程3，我们可以写出：
- en: '![](../Images/3c5645d4d93643319223d57669e5a37c.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3c5645d4d93643319223d57669e5a37c.png)'
- en: Hence, the PDF of *X* at point *x* can be estimated using this equation. A histogram
    uses the same concept to estimate the PDF of a random variable based on a random
    sample. Suppose that *X* is a random variable with an unknown distribution, and
    the random variables *X*₁, *X*₂, … *X_n* generally represent a random sample that
    can be drawn from that distribution (so *X*₁, *X*₂, … *X_n* are independent and
    identically distributed). After drawing a random sample, we denote the observations
    in that by *x*₁, *x*₂, … *x_n*. Hence, *x*₁, *x*₂, … *x_n* form the dataset for
    which we want to generate a histogram, and each *xᵢ* is an observation in this
    dataset.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*X*在点*x*的PDF可以通过此方程估计。直方图使用相同的概念来估计基于随机样本的随机变量的PDF。假设*X*是一个未知分布的随机变量，而随机变量*X*₁、*X*₂、…
    *X_n*通常表示可以从该分布中抽取的随机样本（即*X*₁、*X*₂、… *X_n*是独立同分布的）。在抽取随机样本后，我们用*x*₁、*x*₂、… *x_n*来表示样本中的观察值。因此，*x*₁、*x*₂、…
    *x_n*形成了我们想要生成直方图的数据集，每个*xᵢ*是这个数据集中的一个观察值。
- en: 'We first need to define the interval [*a*, *b*] on which the histogram is calculated.
    We divide this interval into *k* equal-length subintervals of length *h*=(*b*−*a*)/*k*.
    These constant-length subintervals are also called *bins*. So, we will have the
    following subintervals:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要定义计算直方图的区间[*a*, *b*]。我们将此区间划分为长度为*h*=(*b*−*a*)/*k*的*k*个等长子区间。这些定长子区间也称为*bins*。因此，我们将有以下子区间：
- en: '![](../Images/313b783b995b484596d65f106ccb2fce.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/313b783b995b484596d65f106ccb2fce.png)'
- en: 'Please note that the first *k*-1 subintervals are half-open and only include
    their left endpoints since we don’t want them to overlap at the endpoints. Now
    we can use Equation 4 to estimate the PDF of the test point *x* which belongs
    to the subinterval *Bᵢ*:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前*k*-1个子区间是半开区间，只包括其左端点，因为我们不希望它们在端点处重叠。现在我们可以使用方程4来估计属于子区间*Bᵢ*的测试点*x*的PDF：
- en: '![](../Images/4dd0adb7716a2ca7513deb53a442f25d.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4dd0adb7716a2ca7513deb53a442f25d.png)'
- en: This is an approximation since we are not taking the limit anymore. But how
    can we calculate
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种近似，因为我们不再取极限。但是我们如何计算
- en: '![](../Images/b05ab441da54b41cd8891431c273ef7b.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b05ab441da54b41cd8891431c273ef7b.png)'
- en: We can simply use our random sample for this purpose. We know that our dataset
    has *n* observations. Then
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简单地使用我们的随机样本。我们知道我们的数据集有*n*个观察值。那么
- en: '![](../Images/9256d822bc3863bd0f0a700edd9f2ec2.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9256d822bc3863bd0f0a700edd9f2ec2.png)'
- en: 'If we denote the number of the observations of the random sample within *Bᵢ*
    by *nᵢ*, then we have:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用*nᵢ*表示随机样本在*Bᵢ*中的观察次数，那么我们有：
- en: '![](../Images/72669a86f09e01b31f02d918e97925c0.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/72669a86f09e01b31f02d918e97925c0.png)'
- en: 'We denote this estimation of the PDF by *f^*(*x*), so we can write the previous
    equation as:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 PDF 的这种估计称为 *f^*(*x*)，所以我们可以将之前的方程写成：
- en: '![](../Images/8bd185eee30926114f3279468212c48c.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8bd185eee30926114f3279468212c48c.png)'
- en: To plot a histogram, we need to know the values of *a*, *b*, and *h*. We first
    calculate the endpoints of the bins, and for each bin *Bᵢ­* we draw a rectangular
    bar of width *h* and height equal to *nᵢ­*/(*nh*) over the midpoint of that bin
    (Figure 3).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制直方图，我们需要知道 *a*、*b* 和 *h* 的值。我们首先计算箱子的端点，对于每个箱子 *Bᵢ*，我们在该箱子的中点上绘制一个宽度为 *h*
    且高度等于 *nᵢ* / (*nh*) 的矩形条（图 3）。
- en: '![](../Images/c837e34b3a201b3a3314d78adf77d98a.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c837e34b3a201b3a3314d78adf77d98a.png)'
- en: Figure 3
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3
- en: We know that
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道
- en: '![](../Images/60207606cca238577e54f1f479efea47.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/60207606cca238577e54f1f479efea47.png)'
- en: So, the integral of a PDF over the entire space must be equal to 1
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，PDF 在整个空间上的积分必须等于 1。
- en: '![](../Images/79d92402f9d87f0781051cdcdac27e8e.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/79d92402f9d87f0781051cdcdac27e8e.png)'
- en: 'which means that a PDF is normalized, and the area behind the PDF curve is
    equal to 1\. The area of the histogram is equal to the sum of the area of the
    rectangles in Figure 2:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 PDF 是标准化的，PDF 曲线下的面积等于 1。直方图的面积等于图 2 中矩形的面积之和：
- en: '![](../Images/eaa2504fcbf082a448142cf481068409.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/eaa2504fcbf082a448142cf481068409.png)'
- en: where *k* is the number of bins. This makes sense since a histogram is an estimator
    for the PDF of a distribution.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *k* 是箱子的数量。这是有意义的，因为直方图是分布 PDF 的一种估计器。
- en: 'To plot a histogram in `matplotlib`, we use the function `hist()`. Please note
    that we should set the parameter `density` to `True` to get an estimate of PDF.
    Otherwise, we will get a *frequency histogram*. In a frequency histogram, the
    height of each bin is equal to:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `matplotlib` 中绘制直方图时，我们使用 `hist()` 函数。请注意，我们应将参数 `density` 设置为 `True` 来获得
    PDF 的估计值。否则，我们将得到一个 *频率直方图*。在频率直方图中，每个箱子的高度等于：
- en: '![](../Images/2bd9ef2f2d49498744bb3829180eaea3.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2bd9ef2f2d49498744bb3829180eaea3.png)'
- en: The histogram plotted using Equation 6 is also called a *density histogram*.
    In this article by a histogram, we mean a density histogram.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方程 6 绘制的直方图也称为 *密度直方图*。在本文中，直方图指的是密度直方图。
- en: 'Looking at Listing 2, we only set the number of bins and did not provide a
    value for *a* and *b*:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从清单 2 中可以看出，我们只设置了箱子的数量，并未提供 *a* 和 *b* 的值。
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'That is because the minimum and maximum values of `sample` are automatically
    used as a and b respectively. We could plot the same histogram by this code snippet:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `sample` 的最小值和最大值分别自动用作 *a* 和 *b*。我们可以通过以下代码片段绘制相同的直方图：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Based on Equation 6, the value of *f^*(*x*) depends on *n* and *h*. But it also
    depends on the starting point of the beans (*a* in Equation 5). So, if we change
    the value of *a*, it will change the shape of the histogram. Listing 3 plots the
    histogram of the sample defined in Listing 1 with *a*=1.8 and *b*=12 and compares
    it with the histogram of Figure 2 in which *a* and *b* were set to the minimum
    and maximum values of the sample. Both histograms have the same *h*. The result
    is shown in Figure 4.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 基于方程 6，*f^*(*x*) 的值依赖于 *n* 和 *h*。但它也依赖于箱子的起始点（方程 5 中的 *a*）。所以，如果我们改变 *a* 的值，它将改变直方图的形状。清单
    3 绘制了清单 1 中定义的样本的直方图，其中 *a*=1.8 和 *b*=12，并将其与图 2 中 *a* 和 *b* 设置为样本的最小值和最大值的直方图进行了比较。两个直方图具有相同的
    *h*。结果见图 4。
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![](../Images/7b2f3e153c67c93d20a192f1880cd24d.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7b2f3e153c67c93d20a192f1880cd24d.png)'
- en: Figure 4
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4
- en: As you see by changing the values of *a*, the shape of the histogram changes.
    So, the shape of the histogram depends on the random sample used to generate it.
    We don’t know the maximum and minimum values of the population from which a random
    sample is drawn. So, if we draw a histogram based on the minimum and maximum values
    of a random sample, the sample will affect the shape of the histogram. However,
    the histogram is supposed to mimic the shape of the PDF of the population which
    is the same for all the random samples.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，通过改变 *a* 的值，直方图的形状会发生变化。因此，直方图的形状依赖于用于生成它的随机样本。我们不知道从中抽取随机样本的总体的最大值和最小值。因此，如果我们基于随机样本的最小值和最大值绘制直方图，则样本将影响直方图的形状。然而，直方图应模仿总体的
    PDF 形状，而总体的 PDF 对所有随机样本都是相同的。
- en: '**Histogram as a machine learning model**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**直方图作为机器学习模型**'
- en: Remember that the histogram of a sample is supposed to mimic the shape of the
    PDF of the population from which the sample is drawn. In fact, we can think of
    a histogram as a machine learning model that learns the PDF of the population
    based on the sample that we have drawn from that population. This is a very simple
    model since it only has one hyperparameter which is the bin width (*h*). This
    hyperparameter controls the complexity of this model. (A hyperparameter is a parameter
    whose value is used to configure a machine learning model and is determined by
    the user before the start of the training process. By contrast, the values of
    other parameters of the model are determined via training).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，样本的直方图应该模仿从样本中提取的总体的概率密度函数（PDF）的形状。事实上，我们可以将直方图视为一种机器学习模型，它基于我们从总体中提取的样本来学习总体的PDF。这是一个非常简单的模型，因为它只有一个超参数，即箱宽（*h*）。这个超参数控制了模型的复杂性。（超参数是用来配置机器学习模型的参数，其值由用户在训练过程开始前确定。相比之下，模型的其他参数值是通过训练确定的。）
- en: 'Like any other machine learning model, we can calculate the bias and variance
    of a histogram. Suppose that *X* is a random variable with an unknown distribution,
    and the random variables *X*₁, *X*₂, … *X_n* generally represent a random sample
    that can be drawn from that distribution. After drawing a random sample, we denote
    the observations in that by *x*₁, *x*₂, … *x_n* (here each *xᵢ* is a specific
    value of *Xᵢ*) and these form the dataset for which is used to generate a histogram.
    Now we want to create a histogram that learns the PDF of the distribution of *X*.
    Remember that from Equation 6, we had:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 像其他任何机器学习模型一样，我们可以计算直方图的偏差和方差。假设 *X* 是一个具有未知分布的随机变量，而随机变量 *X*₁、*X*₂、… *X_n*
    通常表示可以从该分布中抽取的随机样本。抽取随机样本后，我们将其中的观测值记为 *x*₁、*x*₂、… *x_n*（这里每个 *xᵢ* 是 *Xᵢ* 的一个具体值），这些观测值形成用于生成直方图的数据集。现在我们想创建一个学习
    *X* 分布的PDF的直方图。记住，从方程6中，我们有：
- en: '![](../Images/339d1e0c359b33c9f49e69e339c34be2.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/339d1e0c359b33c9f49e69e339c34be2.png)'
- en: But this equation is for one specific dataset. If we want to apply it to the
    random sample *X*₁, *X*₂, … *X_n*, we need to replace *nᵢ* with the random variable
    *Nᵢ*. That is because the actual value of *nᵢ* depends on the values that *X*₁,
    *X*₂, … *X_n* take. So, it follows that
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个方程式适用于一个特定的数据集。如果我们想将其应用于随机样本 *X*₁、*X*₂、… *X_n*，我们需要用随机变量 *Nᵢ* 替换 *nᵢ*。这是因为
    *nᵢ* 的实际值取决于 *X*₁、*X*₂、… *X_n* 的值。因此，得出：
- en: '![](../Images/0dc783f7dfb13c106e0f641979a90f40.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0dc783f7dfb13c106e0f641979a90f40.png)'
- en: Please note that though the values of *X*₁, *X*₂, … *X_n* can change in each
    sample that we draw, the sample size (*n*), the bin size (*h*), and the subinterval
    *Bᵢ* remain the same. So, they are random variables. Now if *Nᵢ* is a random variable,
    what is its distribution? To answer this question, we first need to calculate
    the probability that each *Xₖ* lies in the interval *Bᵢ*. Assume that
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虽然 *X*₁、*X*₂、… *X_n* 的值在每次我们抽取的样本中可能会变化，但样本大小（*n*）、箱宽（*h*）和子区间 *Bᵢ* 保持不变。所以，它们是随机变量。现在如果
    *Nᵢ* 是一个随机变量，它的分布是什么？要回答这个问题，我们首先需要计算每个 *Xₖ* 位于区间 *Bᵢ* 的概率。假设
- en: '![](../Images/a7d004985a7d791d4bc62a85c976a591.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a7d004985a7d791d4bc62a85c976a591.png)'
- en: 'where *a* is a constant endpoint and doesn’t change with the samples. Since
    each *Xₖ* is sampled from the same distribution of *X*, the probability that *Xₖ*
    belongs to *Bᵢ* can be written as:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *a* 是一个常数端点，并且不随样本的变化而改变。由于每个 *Xₖ* 都是从相同的 *X* 分布中抽样的，所以 *Xₖ* 属于 *Bᵢ* 的概率可以写成：
- en: '![](../Images/535a047f74e01551b085ba510246bf27.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/535a047f74e01551b085ba510246bf27.png)'
- en: 'Now we have *n* random variables, and the probability that each of them lies
    in *Bᵢ* is *pᵢ*, and we want to know the distribution of *Nᵢ* which denotes the
    total number of these random variables that lie in *Bᵢ*. This is similar to the
    problem of finding the total number of heads in *n* tosses of a coin where the
    probability of getting heads is *pᵢ*. We already know that if we denote the total
    number of heads by a random variable, it has a binomial distribution with parameters
    *n* and *pᵢ*. So we conclude that *Nᵢ* should have a binomial distribution with
    parameters *n* and *pᵢ*:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有 *n* 个随机变量，每个随机变量位于 *Bᵢ* 的概率是 *pᵢ*，我们想知道 *Nᵢ* 的分布，其中 *Nᵢ* 表示这些随机变量中位于 *Bᵢ*
    的总数。这类似于在 *n* 次掷硬币中找出正面总数的问题，其中出现正面的概率是 *pᵢ*。我们已经知道，如果我们用一个随机变量表示正面总数，它具有参数为 *n*
    和 *pᵢ* 的二项分布。因此我们得出结论，*Nᵢ* 应该具有参数为 *n* 和 *pᵢ* 的二项分布：
- en: '![](../Images/be8f82c9595098bd6219a6c34ba7fa84.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/be8f82c9595098bd6219a6c34ba7fa84.png)'
- en: 'Now we can calculate the mean and variance of *Nᵢ* by knowing its distribution:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过知道 *Nᵢ* 的分布来计算它的均值和方差：
- en: '![](../Images/4e7f4e1094e4dc8abc9d2aae51395cac.png)![](../Images/151b4486916be393ff35526744040fc3.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4e7f4e1094e4dc8abc9d2aae51395cac.png)![](../Images/151b4486916be393ff35526744040fc3.png)'
- en: 'And we can also calculate the mean and variance *f*^(*x*) at a test point *x_t*::'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以计算在测试点 *x_t* 上 *f*^(* x *) 的均值和方差：
- en: '![](../Images/dbb597442e54a8b6559bd2574f23dd9b.png)![](../Images/c306d1aaf74ffafe4a5cda7a382a6ef9.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/dbb597442e54a8b6559bd2574f23dd9b.png)![](../Images/c306d1aaf74ffafe4a5cda7a382a6ef9.png)'
- en: 'Hence, the bias of *f*^(*x_t*) will be:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，* f *^(* x_t *) 的偏差为：
- en: '![](../Images/4c58ff9e358e5515dafa2636e2320daa.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4c58ff9e358e5515dafa2636e2320daa.png)'
- en: Based on the mean value theorem for integrals, we know that if *f* is continuous
    over the interval *Bᵢ*, then there exists a point *εᵢ* in *Bᵢ* such that
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 基于积分的均值定理，我们知道如果 *f* 在区间 *Bᵢ* 上是连续的，则在 *Bᵢ* 中存在一个点 *εᵢ* 使得
- en: '![](../Images/3fc76a61976e7f33a3e5bc1448d79f2a.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3fc76a61976e7f33a3e5bc1448d79f2a.png)'
- en: 'Where *d*₁ and *d*₂ are the endpoints of *Bᵢ* in Equation 7:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *d*₁ 和 *d*₂ 是方程 7 中 *Bᵢ* 的端点：
- en: '![](../Images/21856c77b6ba7d0bf7208b3ee846f80d.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/21856c77b6ba7d0bf7208b3ee846f80d.png)'
- en: 'By using this equation, *pᵢ* can be simplified:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个方程，* pᵢ *可以简化为：
- en: '![](../Images/d094527e823b28dd9e66f29ffa6d6532.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d094527e823b28dd9e66f29ffa6d6532.png)'
- en: So, it follows that
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，得出结论
- en: '![](../Images/73c12d1cbb94458443cdf334f9ee8baa.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/73c12d1cbb94458443cdf334f9ee8baa.png)'
- en: So, by decreasing *h*, variance increases. We need to make an assumption before
    further simplifying the bias term. Here, we assume that *f*(*x*) is *Lipschitz
    continuous* over the bin *Bᵢ*. A function is Lipschitz continuous over an interval
    *Bi* if there exists a positive constant *γᵢ* such that
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过减小 *h*，方差会增加。在进一步简化偏差项之前，我们需要做一个假设。这里我们假设 *f*(*x*) 在区间 *Bᵢ* 上是*Lipschitz连续*的。如果一个函数在区间
    *Bi* 上是Lipschitz连续的，那么存在一个正的常数 *γᵢ* 使得
- en: '![](../Images/eefca86ab928399b4e8ebf6f742b4ea1.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/eefca86ab928399b4e8ebf6f742b4ea1.png)'
- en: 'Now using this equation, we can simplify the bias:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用这个方程，我们可以简化偏差：
- en: '![](../Images/57b55b3a9eefefdebded03333fa57994.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/57b55b3a9eefefdebded03333fa57994.png)'
- en: Here we used the fact that both *x* and *εᵢ* are in the interval *Bᵢ* whose
    width is *h*, so their distance cannot be greater than *h*. You see that by decreasing
    *h*, the absolute value of bias decreases.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们利用了* x *和* εᵢ *都在宽度为 *h* 的区间 *Bᵢ* 内的事实，因此它们的距离不能大于 *h*。你会发现通过减小 *h*，偏差的绝对值会减少。
- en: 'By having the bias and variance, we can easily calculate the Mean squared error
    (MSE) at *x*_*t*:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过有了偏差和方差，我们可以很容易地计算在 *x*_*t* 上的均方误差 (MSE)：
- en: '![](../Images/57b55b3a9eefefdebded03333fa57994.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/57b55b3a9eefefdebded03333fa57994.png)'
- en: If we think of a histogram as a model, the bin width *h* is the only hyperparameter
    of this model and is like a measure of the model complexity. As *h* goes to zero,
    the model becomes more complicated. Hence the absolute value of bias decreases
    and the variance increases (overfitting). On the other hand, when *h* increases,
    the model becomes simpler, so the variance decreases, but the absolute value of
    bias increases (underfitting).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将直方图视为模型，区间宽度 *h* 是这个模型唯一的超参数，它类似于模型复杂性的度量。随着 *h* 趋近于零，模型变得更加复杂。因此偏差的绝对值减少而方差增加（过拟合）。另一方面，当
    *h* 增加时，模型变得更简单，因此方差减少，但偏差的绝对值增加（欠拟合）。
- en: 'So, we conclude that there is a tradeoff between the absolute value of bias
    and variance: increasing one will decrease the other. This is a manifestation
    of the bias-variance tradeoff in mechanic learning which describes the relationship
    between the model complexity and the accuracy of its predictions.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们得出结论，偏差的绝对值和方差之间存在权衡：增加一个会减少另一个。这是机械学习中偏差-方差权衡的表现，它描述了模型复杂性与预测准确性之间的关系。
- en: Listing 5 shows a demonstration of the bias-variance tradeoff. Here we start
    with 100 random samples of size 80 from a normal distribution with mean of 5 and
    variance of 1\. We also try a range of values for *h* from 0.15 to 2.7\. Next,
    we pick a test point (*x*_*t*) and calculate the PDF of the normal distribution
    at this point (*f(x_t*)). For each value of *h*, we calculate the histograms of
    all 100 random samples. Then we calculate *f*^(*x_t*) for these histograms. Finally,
    using *f*(*x*_*t*) and the values of *f*^(*x_t*) for all the random samples, we
    can calculate the bias², variance and MSE at the test point *x*_*t* for each value
    of *h*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5展示了偏差-方差权衡的演示。这里我们从均值为5、方差为1的正态分布中获取100个大小为80的随机样本。我们还尝试了从0.15到2.7的一系列 *h*
    值。接着，我们选择一个测试点 (*x*_*t*)，并计算该点的正态分布PDF (*f(x_t*) )。对于每个 *h* 值，我们计算所有100个随机样本的直方图。然后，我们计算这些直方图的
    *f*^(*x_t*)。最后，使用 *f*(*x*_*t*) 和所有随机样本的 *f*^(*x_t*) 值，我们可以计算每个 *h* 值在测试点 *x*_*t*
    的偏差²、方差和MSE。
- en: However, we don’t want to minimize the prediction error of the histogram for
    only one test point (*x*_*t*). Hence, we pick a range of test points from the
    array `xt_list` and for each value of *h*, calculate the average bias², variance
    and MSE for all the test points. Listing 5 creates a plot of the average bias²,
    variance, and MSE for different values of *h* that is shown in Figure 5.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们并不想仅仅最小化一个测试点 (*x*_*t*) 的直方图预测误差。因此，我们从数组 `xt_list` 中选择一个测试点范围，并计算每个 *h*
    值在所有测试点上的平均偏差²、方差和MSE。列表5创建了不同 *h* 值的平均偏差²、方差和MSE的图示，如图5所示。
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](../Images/9241ae2f13992be04f0ba4a2507d3c92.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9241ae2f13992be04f0ba4a2507d3c92.png)'
- en: Figure 5
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图5
- en: By decreasing the value of *h*, the model complexity and average variance increase,
    but the average bias² decreases. A model that is too complex ends up with overfitting.
    On the other hand, increasing the value of *h* results in a simpler model that
    decreases the average variance and increases the average bias². A model that is
    too simple results in underfitting. As mentioned before MSE is the sum of variance
    and the square of bias, so in both cases (underfitting and overfitting), we have
    a large average MSE for all the test points. As this figure shows *h*=0.8 gives
    the lowest average MSE for all the test points since there is a balance between
    the average bias² and average variance at this point. This point represents a
    model which is neither too simple nor too complex, so it minimizes the average
    MSE.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过减少 *h* 的值，模型复杂度和平均方差增加，但平均偏差²减少。过于复杂的模型会导致过拟合。另一方面，增加 *h* 的值会导致模型更简单，从而减少平均方差并增加平均偏差²。过于简单的模型会导致欠拟合。如前所述，MSE是方差和偏差平方的总和，因此在欠拟合和过拟合的情况下，我们对所有测试点的平均MSE都很大。正如图中所示，*h*=0.8
    为所有测试点提供了最低的平均MSE，因为此时平均偏差²和平均方差之间存在平衡。这个点代表了一个既不简单也不复杂的模型，因此最小化了平均MSE。
- en: Listing 6 plots the histograms for three values of *h* (Figure 6) The histogram
    is underfitting at *h*=2.3 and overfitting at *h*=0.15, and in both cases, it
    doesn’t estimate the PDF very well. Based on the results of Figure 5, the right
    fit happens at *h*=0.8\. The histogram with this value of *h* gives the best estimation
    of the PDF.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6绘制了三种 *h* 值的直方图（图6）。在 *h*=2.3 时直方图欠拟合，在 *h*=0.15 时直方图过拟合，两种情况均无法很好地估计PDF。根据图5的结果，最佳拟合发生在
    *h*=0.8。此值的直方图提供了对PDF的最佳估计。
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![](../Images/5651941c1886742c264574d3f2c0f512.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5651941c1886742c264574d3f2c0f512.png)'
- en: Figure 6
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图6
- en: 'As you see, we can find the best value of *h*, if we have so many training
    datasets, but in reality, we only have one. In that case, we can use Scott’s rule
    to find the best value of *h*:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，如果我们有足够多的训练数据集，我们可以找到 *h* 的最佳值，但实际上我们只有一个。在这种情况下，我们可以使用Scott规则来找到 *h* 的最佳值：
- en: '![](../Images/250ebe0d207f01c6e0493120962bc3cf.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/250ebe0d207f01c6e0493120962bc3cf.png)'
- en: 'where *σ^* isthe sample standard deviation and *n* is the sample size. This
    rule assumes that the sample has a normal distribution. If we use this rule for
    all the samples in Listing 5, we see that the average of *h** is very close to
    the optimal value of *h* found in Listing 5:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *σ^* 是样本标准差，*n* 是样本大小。此规则假设样本服从正态分布。如果我们对列表5中的所有样本使用此规则，我们会发现 *h* 的平均值非常接近列表5中找到的
    *h* 的最佳值：
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Please note that in reality, we only have one sample to estimate *h**, so the
    estimation error can be larger.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，实际上我们只有一个样本来估计 *h*，因此估计误差可能较大。
- en: '**Kernel density estimation**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**核密度估计**'
- en: 'To avoid the dependence of the histogram on its endpoints, we can use a different
    formula to approximate the derivative of the CDF. This formula is known as the
    symmetric difference quotient:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免直方图对其端点的依赖，我们可以使用不同的公式来近似 CDF 的导数。这个公式被称为对称差商：
- en: '![](../Images/a7b2521f5720fb1c1f04b2a0235b240d.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a7b2521f5720fb1c1f04b2a0235b240d.png)'
- en: 'As you see unlike Equation 5, this equation does not depend on *a*. Next, we
    can write:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，与方程5不同，这个方程不依赖于 *a*。接下来，我们可以写作：
- en: '![](../Images/e912c2033952aaf6cb297459ded2078b.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e912c2033952aaf6cb297459ded2078b.png)'
- en: 'We can also use the indicator function to calculate this probability. Let *A*
    be a set*.* The indicator function of *A* at *x* is defined as:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用指示函数来计算这个概率。设 *A* 为集合。*A* 在 *x* 处的指示函数定义为：
- en: '![](../Images/8168605bb6d04c9b579bcc3b0104c379.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8168605bb6d04c9b579bcc3b0104c379.png)'
- en: 'Hence, it is equal to 1 for all points in its domain which belong to *A,* and
    is equal to 0 for all the other points. Now, we can use the indicator function
    to count the number of observations that belong to [*x*-*h*, *x*+*h*). Remember
    that the *x*₁, *x*₂, … *x_n* represent the dataset for which we want to generate
    a histogram. So, for each *xᵢ*:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它在其域内的所有属于 *A* 的点上等于1，而在所有其他点上等于0。现在，我们可以使用指示函数来计算属于 [*x*-*h*, *x*+*h*) 的观察值的数量。记住，*x*₁，*x*₂，…
    *x_n* 代表我们想要生成直方图的数据集。因此，对于每个 *xᵢ*：
- en: '![](../Images/075fe9f67a502fddadc0a55e5adabc6c.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/075fe9f67a502fddadc0a55e5adabc6c.png)'
- en: 'is 1 if *x*-*h*≤*xᵢ*<*x*+*h*. Otherwise, it is zero. Hence, we can write:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *x*-*h*≤*xᵢ*<*x*+*h* 时，为1。否则，为零。因此，我们可以写作：
- en: '![](../Images/c735f4b092aa5128a771d13ef282336f.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c735f4b092aa5128a771d13ef282336f.png)'
- en: 'And it follows that:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 并且得出：
- en: '![](../Images/006da1e5ec0ace8d3dddba845f07752a.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/006da1e5ec0ace8d3dddba845f07752a.png)'
- en: 'If we denote this estimation of the PDF by *f^*(*x*), we can write the previous
    equation as:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用 *f^*(*x*) 表示这个 PDF 的估计，我们可以将前面的方程写作：
- en: '![](../Images/02ad70a6c37903d3ef5e4e30bc2df11d.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/02ad70a6c37903d3ef5e4e30bc2df11d.png)'
- en: 'Next, we can write:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以写作：
- en: '![](../Images/1c08e4287c3edad0ce22fe8ca63e928c.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1c08e4287c3edad0ce22fe8ca63e928c.png)'
- en: 'So, we can write our estimation of PDF as:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以写出我们的 PDF 估计为：
- en: '![](../Images/69a2929a71fd43753e6667bb86f32508.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/69a2929a71fd43753e6667bb86f32508.png)'
- en: 'Now let’s look at the expression inside the sum and examine the different values
    that it can take:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下总和内的表达式，检查它可以取的不同值：
- en: '![](../Images/1252d260ae1c77025af6e1c9d35af076.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1252d260ae1c77025af6e1c9d35af076.png)'
- en: 'Comparing it with the PDF of a continuous uniform distribution:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与连续均匀分布的 PDF 比较：
- en: '![](../Images/47612392a4409734c29dc6d2fd1c95c2.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/47612392a4409734c29dc6d2fd1c95c2.png)'
- en: We can observe that *K*((*x*-*xᵢ*)/*h*) is the PDF of a uniform distribution
    on the interval [-1, 1].
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以观察到 *K*((*x*-*xᵢ*)/*h*) 是区间 [-1, 1] 上均匀分布的 PDF。
- en: Listing 7 uses this method to estimate the PDF of the sample generated in Listing
    1\. The result is shown in Figure 7 and it has been compared with the PDF of the
    distribution from which the sample was drawn.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7 使用这种方法来估计在列表1中生成的样本的 PDF。结果如图7所示，并与样本来源分布的 PDF 进行了比较。
- en: '[PRE9]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![](../Images/62b896127e7fea2059dc65e637b62c1e.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/62b896127e7fea2059dc65e637b62c1e.png)'
- en: Figure 7
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图7
- en: 'We can generalize Equation 8 and replace *K* with a different PDF. We generally
    define a kernel density estimator *f*^(*x*) as:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将方程8进行概括，并用不同的 PDF 替代 *K*。我们通常将核密度估计器 *f*^(*x*) 定义为：
- en: '![](../Images/619911cc1cc16ae22555d90c73aa9575.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/619911cc1cc16ae22555d90c73aa9575.png)'
- en: 'In this equation, *K*(*x*) is called a *kernel function* and *h* is called
    the *bandwidth*. We can also write the previous equation as:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方程中，*K*(*x*) 称为 *核函数*，*h* 称为 *带宽*。我们也可以将前面的方程写作：
- en: '![](../Images/6ec925c78d09360abd8b29be8b794896.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6ec925c78d09360abd8b29be8b794896.png)'
- en: 'Where *K_h* is called the *scaled kernel* and is defined as:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *K_h* 称为 *缩放核*，其定义为：
- en: '![](../Images/b00598897c6e97506a481c7c942b3df9.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b00598897c6e97506a481c7c942b3df9.png)'
- en: 'The kernel function should satisfy the following conditions:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 核函数应满足以下条件：
- en: '![](../Images/e062d6715ecc5b4e050074d558c44cd2.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e062d6715ecc5b4e050074d558c44cd2.png)'
- en: 'Based on the first two conditions, the kernel function should be non-negative
    and normalized to guarantee that the kernel function is a probability density
    function (PDF). Based on the third condition, it should be a symmetric PDF. This
    condition implies that:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 基于前两个条件，核函数应为非负且归一化，以保证核函数是一个概率密度函数（PDF）。根据第三个条件，它应为对称的 PDF。这个条件意味着：
- en: '![](../Images/4a3a318d8958530878a8a721fc70d0c6.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4a3a318d8958530878a8a721fc70d0c6.png)'
- en: 'Looking at Figure 7, you see that the estimator curve is not smooth because
    the uniform density does not have a smooth shape. We can use the PDF of the standard
    normal distribution as the kernel function which has a smooth shape:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 观察图7，你会发现估计器曲线不平滑，因为均匀密度没有平滑的形状。我们可以使用标准正态分布的PDF作为核函数，因为它具有平滑的形状：
- en: '![](../Images/29777a3abcf26ff58e0cebb80b6f6f96.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/29777a3abcf26ff58e0cebb80b6f6f96.png)'
- en: 'By plugging this kernel into Equation 9, we have:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个核代入公式9，我们得到：
- en: '![](../Images/24e1e8bb7352f10b2def98edc4a813c0.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/24e1e8bb7352f10b2def98edc4a813c0.png)'
- en: Hence the estimator is the average of the PDF of *n* normal distributions with
    mean *xᵢ*, and the bandwidth *h* can be considered the standard deviation of these
    distributions.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，估计器是 *n* 个均值为 *xᵢ* 的正态分布的PDF的平均值，而带宽 *h* 可以被视为这些分布的标准差。
- en: Listing 8 uses an estimator with the standard normal kernel to estimate the
    PDF of the sample generated in Listing 1\. The result is shown in Figure 8 and
    it has been compared with the PDF of the distribution from which the sample was
    drawn. The *n* scaled kernels (*K*_*h*) are also plotted in this figure Each scaled
    kernel is a normal distribution with a mean of *xᵢ* and a standard deviation of
    *h*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8使用了带有标准正态核的估计器来估计列表1中生成的样本的PDF。结果如图8所示，并且与样本抽取来源的分布的PDF进行了比较。*n* 个缩放的核 (*K*_*h*)
    也在该图中绘制，每个缩放核都是均值为 *xᵢ* 和标准差为 *h* 的正态分布。
- en: '[PRE10]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![](../Images/9a6a29db61ecf3171f45f9211d3e9421.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9a6a29db61ecf3171f45f9211d3e9421.png)'
- en: Figure 8
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图8
- en: '**Kernel density estimator as a machine learning model**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**作为机器学习模型的核密度估计器**'
- en: Similar to a histogram, a kernel density estimator can be considered a machine
    learning model that learns the PDF of the population based on the sample we have
    drawn from that population. The hyperparameters of this model are the bandwidth
    (*h*), the kernel type, and its corresponding parameters. These hyperparameters
    make a kernel density estimator more flexible compared to a histogram.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于直方图，核密度估计器可以被视为一种机器学习模型，它根据我们从总体中抽取的样本来学习总体的概率密度函数（PDF）。该模型的超参数包括带宽 (*h*)、核类型及其对应的参数。这些超参数使得核密度估计器相比于直方图更加灵活。
- en: 'Suppose that we have the kernel estimator given in Equation 9\. To calculate
    the bias and variance of this estimator, we need to use all the possible samples
    that we can draw from a population, so we use the i.i.d. random sample *X*₁, *X*₂,
    … *X_n* to create the density estimator:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有公式9中的核估计器。为了计算这个估计器的偏差和方差，我们需要使用从总体中抽取的所有可能样本，因此我们使用独立同分布的随机样本 *X*₁、*X*₂、…
    *X_n* 来创建密度估计器：
- en: '![](../Images/4679d11b8d5d12cafb9e9f41bfcf90ee.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4679d11b8d5d12cafb9e9f41bfcf90ee.png)'
- en: 'Now it can be shown that for a test point *x*_*t*, the bias of *f*^(*x_t*)
    is:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以证明，对于测试点 *x*_*t*，*f*^(*x_t*) 的偏差为：
- en: '![](../Images/b6e8ecda845ff7cf7640d335c02e47f1.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b6e8ecda845ff7cf7640d335c02e47f1.png)'
- en: 'where *σ_K* is defined as:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *σ_K* 定义为：
- en: '![](../Images/79c2819880dff958a47f1d1f9d60cfbf.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/79c2819880dff958a47f1d1f9d60cfbf.png)'
- en: 'We can also show that the variance of *f*^(*x_t*) is as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以证明 *f*^(*x_t*) 的方差如下：
- en: '![](../Images/637ebe77e6419254ed0f8162856f525f.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/637ebe77e6419254ed0f8162856f525f.png)'
- en: 'Where *R*(*K*) is defined as:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*R*(*K*) 被定义为：'
- en: '![](../Images/c52627f2ef48c49d6d7a297fb8138e0b.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c52627f2ef48c49d6d7a297fb8138e0b.png)'
- en: The bandwidth (*h*) controls the complexity of this model. As *h* goes to zero,
    the model becomes more complicated, so the absolute value of bias decreases and
    the variance increases (overfitting). Conversely, as *h* increases, the model
    becomes simpler, hence the variance decreases, but the absolute value of bias
    increases (underfitting).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 带宽 (*h*) 控制了模型的复杂性。当 *h* 趋近于零时，模型变得更复杂，因此偏差的绝对值减少而方差增加（过拟合）。相反，当 *h* 增加时，模型变得更简单，因此方差减少，但偏差的绝对值增加（欠拟合）。
- en: 'The details of calculating the bias and variance are given in the appendix.
    Now, we can calculate the MSE:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 计算偏差和方差的详细信息见附录。现在，我们可以计算MSE：
- en: '![](../Images/d941662778bd8385a9fac07104859c60.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d941662778bd8385a9fac07104859c60.png)'
- en: 'So far, we only considered a single test point *x_t*. However, generally, we
    want to control the overall MSE of the density estimator. So, we need to calculate
    the mean integrated squared error (MISE):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只考虑了一个测试点 *x_t*。然而，通常我们希望控制密度估计器的总体均方误差（MSE）。因此，我们需要计算均值积分平方误差（MISE）：
- en: '![](../Images/c4f403ddcd650ac8638becffc0c1a874.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c4f403ddcd650ac8638becffc0c1a874.png)'
- en: 'Now by plugging Equation 13 into this equation, we have:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将方程 13 代入此方程，我们得到：
- en: '![](../Images/b37e41f5788fac74c9d0aae8901e60a5.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b37e41f5788fac74c9d0aae8901e60a5.png)'
- en: 'This Equation can be simplified using Equation 7 and Equation 12:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方程可以使用方程 7 和方程 12 简化：
- en: '![](../Images/b8d88e6a0167ca6ece4df13430fbeae5.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b8d88e6a0167ca6ece4df13430fbeae5.png)'
- en: 'The two dominating terms in this equation are called the asymptotical mean
    integrated squared error (AMISE):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此方程中的两个主导项称为渐近均方积分误差 (AMISE)：
- en: '![](../Images/7cf80d5d6124bae299870353fd078c50.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7cf80d5d6124bae299870353fd078c50.png)'
- en: 'By setting the derivative of AMISE to zero, we can find the optimum value of
    *h* that minimizes it:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 AMISE 的导数设置为零，我们可以找到使其最小化的 *h* 的最佳值：
- en: '![](../Images/fe22b5e153e5ed0e281edb096e78de82.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/fe22b5e153e5ed0e281edb096e78de82.png)'
- en: 'Solving this equation gives us the optimum value of *h*:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 解此方程可以得出 *h* 的最佳值：
- en: '![](../Images/32a6192dea23d5cd7a6216e7f67cfde8.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/32a6192dea23d5cd7a6216e7f67cfde8.png)'
- en: 'Please note that we cannot use the above formula involves the second derivative
    of the unknown PDF that we want to estimate (*f’’*), so we cannot use it directly.
    However, we can make an assumption about the PDF type. If we assume that we want
    to estimate the PDF of a normal distribution with the mean *µ* and variance *σ*²
    then:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不能直接使用上述涉及未知 PDF 二阶导数 (*f’’*) 的公式。因此，我们不能直接使用它。然而，我们可以对 PDF 类型做出假设。如果我们假设要估计一个均值为
    *µ* 和方差为 *σ*² 的正态分布的 PDF，则：
- en: '![](../Images/482b3575beb7ff214a0c3506c79a224b.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/482b3575beb7ff214a0c3506c79a224b.png)'
- en: It follows that
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 由此得到
- en: '![](../Images/ab0b6659342c314130f8ac5a2a94f7ca.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ab0b6659342c314130f8ac5a2a94f7ca.png)'
- en: 'Then we have:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们得到：
- en: '![](../Images/d74897b0e9d27f21e5140478e031c134.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d74897b0e9d27f21e5140478e031c134.png)'
- en: 'And if use the PDF of the standard normal distribution as the kernel function:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用标准正态分布的 PDF 作为核函数：
- en: '![](../Images/957f1747771d26676f327c238a1c60fd.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/957f1747771d26676f327c238a1c60fd.png)'
- en: Then it follows that
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后得到
- en: '![](../Images/b86329b426a2cdb5590ac06740b9f025.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b86329b426a2cdb5590ac06740b9f025.png)'
- en: And
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '![](../Images/f04b28df8125a0c8b4f6336286d1d21e.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f04b28df8125a0c8b4f6336286d1d21e.png)'
- en: 'By plugging these equations into Equation 14 we get:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些方程代入方程 14，我们得到：
- en: '![](../Images/7e4fb3cad47de94567b67e4d2be60406.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7e4fb3cad47de94567b67e4d2be60406.png)'
- en: 'Since we usually don’t know the standard deviation of the population (*σ*),
    we can use the sample standard deviation (*σ^*) instead:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们通常不知道总体的标准差 (*σ*)，我们可以使用样本标准差 (*σ^*) 来代替：
- en: '![](../Images/a5d3ec63fbdb1892d36c2aeb22ad0c12.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a5d3ec63fbdb1892d36c2aeb22ad0c12.png)'
- en: This is the Scott’s rule for estimating the bandwidth of a KDE. Listing 9 shows
    the bias-variance tradeoff for a kernel density estimator. We have 100 random
    samples of size 100 from a normal distribution with a mean of 5 and a variance
    of 1\. We try a range of values for *h* from 0.14 to 0.52\. We pick a range of
    test points from the array `xt_list`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这是估计 KDE 带宽的 Scott 规则。列表 9 显示了核密度估计器的偏差-方差权衡。我们从均值为 5 和方差为 1 的正态分布中获取了 100 个样本，每个样本大小为
    100。我们尝试了从 0.14 到 0.52 的 *h* 范围。我们从数组 `xt_list` 中挑选了一系列测试点。
- en: For each test point (*x*_*t*) in `xt_list`, the PDF of the normal distribution
    at this point (*f(x_t*)) is calculated. Then the KDE of all 100 random samples
    and *f*^(*x_t*) for these samples is calculated. Finally, using *f*(*x*_*t*) and
    the values of *f*^(*x_t*) for all the random samples, the bias², variance, and
    MSE at the *x*_*t* is calculated. Finally, for each value of *h*, we calculate
    the average bias², variance, and MSE for all the test points in `xt_list`. Listing
    9 creates a plot of the average bias², variance, and MSE for different values
    of *h* that is shown in Figure 9.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `xt_list` 中的每个测试点 (*x*_*t*)，计算该点的正态分布的 PDF (*f(x_t*))。然后计算所有 100 个随机样本的 KDE
    和这些样本的 *f*^(*x_t*)。最后，使用 *f*(*x*_*t*) 和所有随机样本的 *f*^(*x_t*) 值，计算 *x*_*t* 处的偏差²、方差和
    MSE。最后，对于每个 *h* 的值，我们计算 `xt_list` 中所有测试点的平均偏差²、方差和 MSE。列表 9 创建了不同 *h* 值的平均偏差²、方差和
    MSE 的图示，如图 9 所示。
- en: '[PRE11]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![](../Images/b1d8f81cd2264dfc4720ff9e5259fbc7.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b1d8f81cd2264dfc4720ff9e5259fbc7.png)'
- en: Figure 9
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9
- en: As *h* goes to zero, the model becomes more complicated, and the result is a
    decrease in the average bias² and an increase in the average variance (overfitting).
    On the other hand, as *h* increases, the model becomes simpler and results in
    underfitting. Hence the average variance decreases, but the average bias² increases.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *h* 趋近于零时，模型变得更加复杂，结果是平均偏差²减少，平均方差增加（过拟合）。另一方面，当 *h* 增加时，模型变得更简单，导致欠拟合。因此，平均方差减少，但平均偏差²增加。
- en: 'We can also use Equation 15 to estimate the optimal value of *h*. Here we calculate
    the average value of *h* for all the samples in listing 9:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用方程15来估计 *h* 的最佳值。在这里，我们计算了列表9中所有样本的 *h* 的平均值：
- en: '[PRE12]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We see that the average of *h** is very close to the optimal value of *h* found
    in Listing 9\. Please note that in reality, we only have one sample to estimate
    *h**. Listing 10 plots the KDEs for three values of *h* (Figure 10). The KDE is
    underfitting at *h*=1 and overfitting at *h*=0.1, and in both cases, it doesn’t
    estimate the PDF very well. The right fit happens at *h*=0.8\. The KDE with this
    value of *h* gives the best estimation of the PDF.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到 *h* 的平均值非常接近于列表9中找到的 *h* 的最佳值。请注意，实际上我们只有一个样本来估计 *h*。列表10绘制了三个 *h* 值的KDE（图10）。在
    *h*=1 时，KDE 欠拟合；在 *h*=0.1 时，KDE 过拟合，这两种情况下KDE都没有很好地估计PDF。正确的拟合发生在 *h*=0.8。这个 *h*
    值的KDE 给出了对PDF的最佳估计。
- en: '[PRE14]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![](../Images/225a78efe6f9832f70872e221d1c8e7e.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/225a78efe6f9832f70872e221d1c8e7e.png)'
- en: Figure 10
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10
- en: 'The function `gaussian_kde()` in the `SciPy` library can be used to calculate
    KDE. Other libraries like `seaborn` and `matplotlib` use this function to plot
    the KDE of a dataset. This function uses the standard normal kernel to estimate
    the PDF. The documentation mentions that it uses the Scotts’ rule to estimate
    *h**, however, the formula is a little different:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`SciPy`库中的函数 `gaussian_kde()` 可以用来计算KDE。其他库如 `seaborn` 和 `matplotlib` 使用此函数来绘制数据集的KDE。该函数使用标准正态核来估计PDF。文档提到它使用Scott规则来估计
    *h*，然而，公式略有不同：'
- en: '![](../Images/cea65377ef5c90d62cdb853de959de5a.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/cea65377ef5c90d62cdb853de959de5a.png)'
- en: Listing 11 plots the KDE of the sample defined in Listing 1\. It compares Equation
    15 and the SciPy’s rule. The plot is shown in Figure 11.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11绘制了列表1中定义的样本的KDE。它比较了方程15和SciPy的规则。图11展示了该图。
- en: '[PRE15]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![](../Images/6a126d00524975d34970bdf513a4413c.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6a126d00524975d34970bdf513a4413c.png)'
- en: Figure 11
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11
- en: In this article, we discussed histograms and kernel density estimation. Both
    methods are used to estimate the PDF of the probability distribution of a dataset.
    Hence, both of them can be thought of as machine learning models that learn the
    PDF of a dataset. We showed how we can calculate the bias and variance of these
    models. The MSE is the sum of variance and the square of bias, and we want to
    minimize it on all possible test points by finding the optimal bin width of a
    histogram or the optimal bandwidth of a kernel density estimator. The article
    shows how Scott’s rules can be used to estimate these optimal values.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们讨论了直方图和核密度估计。这两种方法都用于估计数据集的概率分布的PDF。因此，它们都可以被视为学习数据集PDF的机器学习模型。我们展示了如何计算这些模型的偏差和方差。均方误差（MSE）是方差和偏差的平方之和，我们希望通过找到直方图的最佳箱宽或核密度估计器的最佳带宽来最小化它在所有可能的测试点上的值。文章展示了如何使用Scott规则来估计这些最佳值。
- en: 'I hope that you enjoyed reading this post. All the Code Listings in this article
    are available for download as a Jupyter Notebook from GitHub at:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你喜欢阅读这篇文章。本文中的所有代码列表都可以从GitHub上的Jupyter Notebook中下载：
- en: '[https://github.com/reza-bagheri/histograms_kde/blob/main/KDE.ipynb](https://github.com/reza-bagheri/histograms_kde/blob/main/KDE.ipynb)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/reza-bagheri/histograms_kde/blob/main/KDE.ipynb](https://github.com/reza-bagheri/histograms_kde/blob/main/KDE.ipynb)'
- en: '**Appendix:**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**附录：**'
- en: Remember that the random sample *X*₁, *X*₂, … *X_n* are independent and identically
    distributed and represent a random sample drawn from the distribution of the random
    variable *X* (that we want to estimate its PDF), so each of them alone has the
    same distribution of *X*. Hence the random variables
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，随机样本 *X*₁，*X*₂，… *X_n* 是独立且同分布的，表示从随机变量 *X* 的分布中抽取的随机样本（我们想估计其PDF），因此它们每一个单独的分布与
    *X* 相同。因此，随机变量
- en: '![](../Images/f9a90ade00d33e09b873c369de54ee80.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f9a90ade00d33e09b873c369de54ee80.png)'
- en: 'are independent and identically distributed, and each of them has the same
    distribution of:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 是独立且同分布的，每一个都具有相同的分布：
- en: '![](../Images/89738b9041e15873f6419cec97f83a49.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/89738b9041e15873f6419cec97f83a49.png)'
- en: The kernel estimator
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 核估计器
- en: '![](../Images/4679d11b8d5d12cafb9e9f41bfcf90ee.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4679d11b8d5d12cafb9e9f41bfcf90ee.png)'
- en: 'is the mean of these independent and identically distributed random variables,
    so we have:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 是这些独立同分布随机变量的均值，因此我们有：
- en: '![](../Images/8db74fdf003e85c77fe98a83ca5bc3e4.png)![](../Images/88205806cecde3f1bcfc9ebf79f4e6f7.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8db74fdf003e85c77fe98a83ca5bc3e4.png)![](../Images/88205806cecde3f1bcfc9ebf79f4e6f7.png)'
- en: 'Now we can calculate the mean and variance of the kernel estimator at a test
    point *x_t*:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以计算在测试点 *x_t* 处核估计器的均值和方差：
- en: '![](../Images/b1a359166a9f29b1067894792728933f.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b1a359166a9f29b1067894792728933f.png)'
- en: 'Next, we do a change of variable *y*=(*x_t*-*x*)/*h*. So, the previous equation
    can be written as:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们进行变量变换 *y*=(*x_t*-*x*)/*h*。因此，之前的方程可以写作：
- en: '![](../Images/4eff369d36df25006137ed2323eaaf09.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4eff369d36df25006137ed2323eaaf09.png)'
- en: 'Now we can use the Taylor series to estimate *f*(*x_t*-*yh*):'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用泰勒级数来估计 *f*(*x_t*-*yh*)：
- en: '![](../Images/960a960a71f6fff137926ae9b4b2f8e6.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/960a960a71f6fff137926ae9b4b2f8e6.png)'
- en: 'where o(*h*²) means that it is a smaller order term compared to *h*² when *h*
    goes to zero. By plugging this equation into the previous one we get:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 o(*h*²) 表示这是一个相比于 *h*² 的更小的阶项，当 *h* 趋近于零时。将此方程代入前一个方程，我们得到：
- en: '![](../Images/c6d18ef7b700e8824e27f29b6090c755.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c6d18ef7b700e8824e27f29b6090c755.png)'
- en: 'Now using Equation 11 (*I*) and (*II*), we can simplify this equation and write
    it as:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用方程 11 (*I*) 和 (*II*)，我们可以简化此方程并将其写作：
- en: '![](../Images/0bc45a5e51f89cb6218889c48146dfe7.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0bc45a5e51f89cb6218889c48146dfe7.png)'
- en: 'Where *σ_K* is defined as:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '*σ_K* 被定义为：'
- en: '![](../Images/79c2819880dff958a47f1d1f9d60cfbf.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/79c2819880dff958a47f1d1f9d60cfbf.png)'
- en: 'The bias at *x_t* is defined as:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '*x_t* 的偏差定义为：'
- en: '![](../Images/b9811d98fcdc121a366cb132364cd2ff.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b9811d98fcdc121a366cb132364cd2ff.png)'
- en: 'So, it follows that:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，得出：
- en: '![](../Images/d6ee1e17ff42f723578eaa550631d95c.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d6ee1e17ff42f723578eaa550631d95c.png)'
- en: 'Please note that we needed the condition in Equation 11 (*II*) to get this
    equation for bias. Next, we calculate the variance at point *x_t*:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们需要方程 11 (*II*) 中的条件来得到这个偏差方程。接下来，我们计算点 *x_t* 处的方差：
- en: '![](../Images/5436f880c0a1dbedb35b8376d23fadeb.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5436f880c0a1dbedb35b8376d23fadeb.png)'
- en: 'Using the definition of variance can write:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方差的定义可以写作：
- en: '![](../Images/a1fc088d2ceb052f050c83137e451a41.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a1fc088d2ceb052f050c83137e451a41.png)'
- en: 'To calculate the first term on the right-hand side of this equation we can
    write:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算此方程右侧的第一项，我们可以写作：
- en: '![](../Images/27868ec27b0022f5a4503cd7f11fa5db.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/27868ec27b0022f5a4503cd7f11fa5db.png)'
- en: 'where we used a change of variable *y*=(*x_t*-*x*)/*h*. Again, we use the Taylor
    series to estimate *f*(*x_t*-*yh*):'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了变量变换 *y*=(*x_t*-*x*)/*h*。再次，我们使用泰勒级数来估计 *f*(*x_t*-*yh*)：
- en: '![](../Images/51a11f348d1eaf6478b6387a06d26c4c.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/51a11f348d1eaf6478b6387a06d26c4c.png)'
- en: 'By plugging this equation into the previous one we get:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 将此方程代入前一个方程，我们得到：
- en: '![](../Images/2a2300c67e225e5685857112ad7d7c33.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2a2300c67e225e5685857112ad7d7c33.png)'
- en: 'Where *R*(*K*) is defined as:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '*R*(*K*) 被定义为：'
- en: '![](../Images/37c7cf205f382d51735c2f4929f27106.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/37c7cf205f382d51735c2f4929f27106.png)'
- en: 'The second on the right-hand side of this equation term can be calculated using
    Equation *A*.1:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 此方程右侧的第二项可以使用方程 *A*.1 进行计算：
- en: '![](../Images/2a18d5c0527a04965c21eb651923c7e6.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2a18d5c0527a04965c21eb651923c7e6.png)'
- en: 'Here if we ignore all the terms and approximate it with zero, we get:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果我们忽略所有的项并将其近似为零，我们得到：
- en: '![](../Images/fb87c569ab2d4b4efba6ea7a425dd6c2.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/fb87c569ab2d4b4efba6ea7a425dd6c2.png)'
- en: 'Finally, we have:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们得到：
- en: '![](../Images/40684a7e25472b006a7ac042ac2c30cc.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/40684a7e25472b006a7ac042ac2c30cc.png)'
- en: Here we used the fact that as *h* goes to zero 1/*h*>>1, So
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们利用了当 *h* 趋近于零时 1/*h*>>1 的事实。所以
- en: '![](../Images/9d708caa19b97edf341fd73ef2525bc2.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9d708caa19b97edf341fd73ef2525bc2.png)'
