# 费曼-蒂尔福德算法解析及演示

> 原文：[https://towardsdatascience.com/reingold-tilford-algorithm-explained-with-walkthrough-be5810e8ed93](https://towardsdatascience.com/reingold-tilford-algorithm-explained-with-walkthrough-be5810e8ed93)

## 用数值示例和Python代码绘制树节点的算法

[](https://kayjanwong.medium.com/?source=post_page-----be5810e8ed93--------------------------------)[![Kay Jan Wong](../Images/28e803eca6327d97b6aa97ee4095d7bd.png)](https://kayjanwong.medium.com/?source=post_page-----be5810e8ed93--------------------------------)[](https://towardsdatascience.com/?source=post_page-----be5810e8ed93--------------------------------)[![Towards Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----be5810e8ed93--------------------------------) [Kay Jan Wong](https://kayjanwong.medium.com/?source=post_page-----be5810e8ed93--------------------------------)

·发表于[Towards Data Science](https://towardsdatascience.com/?source=post_page-----be5810e8ed93--------------------------------) ·阅读时长9分钟·2023年9月12日

--

![](../Images/4962af380309f59d5a1af978e2bb8265.png)

由[Sergiu Vălenaș](https://unsplash.com/@svalenas?utm_source=medium&utm_medium=referral)拍摄，来源于[Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)

# 介绍

1981年的费曼-蒂尔福德算法通过将节点安排在树结构中以最大化可读性，从而创建了一个视觉上令人愉悦的层级数据表示。换句话说，它是一个用于检索树中每个节点的`(x, y)`坐标的算法。

根据[论文](https://reingold.co/tidier-drawings.pdf)，一个好的树状图应遵循一些美学规则，

> 同一深度的节点应排列在一条直线上，并且定义深度的直线应当平行。
> 
> 左子节点应位于其父节点的左侧，右子节点应位于右侧（仅适用于二叉树）
> 
> 父节点应当居中于其子节点上方
> 
> 树及其镜像应产生互为反射的图形，子树的绘制方式应与其在树中的位置无关

确定节点的`y`坐标是简单的，而`x`坐标稍微复杂一些。本文将尝试用数值示例解释算法，树的复杂度略高于我所读过的其他论文和文章，以便涵盖更多场景。我还将介绍一些原论文中没有使用的额外术语，以更好地区分不同的术语。

> 对于算法的一个重要直觉是，它将从左到右绘制树。你可以将最左侧的节点视为`(0, 0)`坐标，各个子树将相应地向右移动。
> 
> **有趣的事实**: `scikit-learn` Python 库也使用这个算法来绘制决策树！

# 术语

在确定每个节点的最终坐标之前，有 3 个术语是至关重要的。原始论文引用了 `x` 和 `mod` 这两个术语，但在我的解释中，为了更清晰，我将使用一个额外的 `shift` 术语。

+   `**x**` 指的是节点的初始 `x` 坐标，纯粹是基于节点的位置（这不是最终的 `x` 坐标）

+   `**mod**` 指的是节点子孙（但不是节点本身）的移动量，以使子节点相对于节点居中。

+   `**shift**` 指的是节点子孙（包括节点本身）的移动量，以避免与节点左侧的子树重叠。

现在可能还不太清楚为什么需要这 3 个术语来确定每个节点的最终 `x` 坐标——希望在浏览数值示例后会更清楚。在接下来的部分，将使用以下树结构来解释算法。

![](../Images/acc0260e9d3353479bff28c6cb09ccca.png)

图 1: 树示例——作者提供的图像

# 第一次遍历

> 后序遍历树以计算 `x`、`mod` 和 `shift` 属性

在后序遍历中，树示例将按字母顺序遍历。有两个部分——第 1 部分计算 `x` 和 `mod` 属性，而第 2 部分计算 `shift` 属性。

## 第一次遍历的第 1 部分

![](../Images/98fe452458940dfe54510755001ec120.png)

图 2: 添加了 x 属性（黑色）和 mod 属性（蓝色）的树示例——作者提供的图像

如前所述，`x` 指的是节点的初始位置，纯粹是基于节点的位置。

+   如果节点是最左侧的孩子，`x` 将为 0。

+   对于每个其他节点，它将参考左侧兄弟节点的 `x` 值，并将一个 *兄弟距离* 加到该值上。

+   这一点有一个例外，如果节点是最左侧的孩子但有子节点，它会尝试相对于子节点进行居中，并将其 `x` 值设置为子节点 `x` 值的中点。

在这个示例中，我们将假设兄弟距离为 `1`，并注意每个兄弟的 `x` 属性与其左侧兄弟的距离正好是兄弟距离。例外情况由图 2 中的黄色节点示例。

对于那些不是最左侧孩子但有子节点的节点——它们也需要相对于子节点进行居中，并将使用 `mod` 属性来实现。其思想是将子孙居中，移动量将是父节点的 `x` 值减去子节点 `x` 值的中点。这些示例由图 2 中的红色节点示例。比如，对于节点 `e`，将其子节点 `c` 和 `d` 向右移动 `1.5` 的值，将使子节点相对于其自身居中。

“最终”`x`-坐标可以通过将节点的`x`属性与祖先的`mod`属性之和相加轻松计算。但我们很快意识到子树中存在重叠。例如，在第三层级，节点`f`和`k`的`x`-坐标分别为`3`和`2.5`，它们会发生重叠。这将在第二部分中解决，此时将计算`shift`属性。

## 第一轮的第二部分

在第二部分，对于每个遍历的节点，我们将检查与*所有*左兄弟的子树的重叠情况。这也是为什么执行后序遍历，因为可以保证所有左兄弟（及其子树）和当前节点的子树已经遍历完毕，并且它们的`x`、`mod`和`shift`值已知（仅需计算当前节点的`shift`值）。

为检测重叠，在每一层中，将左子树的最右侧后代与右子树的最左侧后代进行比较。在文中，这被称为*右轮廓*和*左轮廓*。

![](../Images/07d741487f6e08730be6302aae273a06.png)

图3：添加了`shift`属性（红色）的树示例，n和g的子树 — 作者提供的图像

例如，在遍历树时，比较以下子树，

+   节点`b`与节点`a`对比（无重叠）

+   节点`e`与节点`b`和`a`对比（无重叠）

+   节点`f`与节点`e`、`b`和`a`对比（无重叠）

+   依此类推…

当节点`n`的子树与节点`g`的子树比较时，发生重叠。在图3中，左子树的右轮廓是红色的，而右子树的左轮廓是绿色的。右子树将被移动，以使两个子树之间的*子树距离*相等。

在这个例子中，我们将假设子树距离为`1`并比较每个深度的重叠情况。

+   在第二层级，`f`和`k`的坐标分别为`3`和`2.5`（需要将`k`向右移动`1.5`，以使其与`f`的子树距离相等）。

+   在第三层级，`d`和`i`的坐标分别为`2.5`和`2`（需要将`i`向右移动`1.5`，以使其与`d`的子树距离相等）。

这导致节点`n`需要向右移动`1.5`（第二和第三深度的最大移动量）。`shift`属性非常特殊，因为这将导致节点及其后代（节点`n`及其后代向右移动`1.5`）的移动，同时左邻和右邻节点也会受到影响。由于节点`n`是从最左侧兄弟节点起的第二个节点，节点`h`及其后代需要移动`1.5 * (1 / 2) = 0.75`，而节点`q`及其后代需要移动`1.5 * (3 / 2) = 2.25`，以确保所有兄弟节点在其父节点下仍然居中。

![](../Images/3ebaf9b8ad23b7fb985919bc1dbbfbe5.png)

图4：添加了`shift`属性（红色）的树示例，q和n的子树 — 作者提供的图像

当比较节点 `q` 的子树与节点 `n` 的子树时，会发生另一次重叠。这里的计算将在文章的相对移位部分详细说明。现在，我们可以得出结论，节点 `q` 及其后代需要向右移位 `2.25`。参考图 4，由于节点 `q` 是从最左边的兄弟节点开始的第三个节点，节点 `h` 及其后代必须移位 `2.25 * (1 / 3) = 0.75`，节点 `n` 及其后代必须移位 `2.25 * (2 / 3) = 1.5`，以确保所有兄弟节点相对于其父节点仍然居中。

# 第二遍

> 对树进行前序遍历，计算最终的 `x` 和 `y` 值

![](../Images/e6ef2c3591dfd2e21a0ab1ea55426f2a.png)

图 5：带有最终 `x` 和 `y` 坐标的树示例 — 图片由作者提供

由于所有的 `x`、`mod` 和 `shift` 属性都在第一次遍历中计算得到，这些属性可以通过自上而下的前序遍历来求和，从而得出最终的 `x` 坐标。请注意，`mod` 属性仅移位后代，而 `shift` 属性则移位当前节点及其后代。

# 第三遍

> 对树进行前序遍历，调整任何负值的 `x` 值（如果有的话）

在执行第二遍时，任何由于父节点的负 `mod` 而导致的负 `x` 坐标可以记作调整值，并在第三遍中通过将此调整值加到每个节点来处理。

# 额外考虑

## 相对移位

在第一遍的第二部分中，通过比较节点 `n` 和 `g` 的子树计算了 `shift` 值。还提到 `shift` 将影响兄弟节点 `h` 和 `q`，因为所有子节点必须相对于父节点保持居中。我们可以称这种影响兄弟节点的移位为 *相对移位*，因为这种移位是右子树直接移位的结果。

由于这种相对移位，在计算左右子树之间的 `shift` 值时需要额外考虑，因为左子树将在稍后 *相对* 移位。

参考图 4，注意节点 `q` 是第三个节点，而节点 `n` 是从最左边的兄弟节点开始的第二个节点。在第二层深度，

+   节点 `m` 的中间 `x` 坐标为 6（`Node n's mod 2 + Node n's shift 1.5 + Node m's x 2.5`）。

+   节点 `o` 的中间 `x` 坐标为 6.25（`Node q's mod 4 + Node q's shift 2.25`）。

+   设移位值为 `x`，子树距离为 `1`。将会有一个相对移位，其中节点 `m` 将按 `(2 / 3) * x` 移位，如果节点 `q` 按 `x` 移位。

+   方程式如下：`(6.25 + x) — (6 + (2 / 3) * x) >= 1`。

+   解决这个方程，移位值 `x >= 2.25`。

# 额外参数

## 子树分离

在上面的例子中，兄弟节点分离和子树分离设置为相同的值。兄弟节点分离与子树分离的区别如下：

+   兄弟节点分隔在第一遍的第1部分中使用，用于确定`x`属性。

+   子树分隔在第一遍的第2部分中使用，用于确定`shift`属性。

## 层级分隔

层级分隔可以作为一个额外的参数来确定不同层级之间的距离，这将用于确定第二遍中的`y`坐标。

## 偏移（x-offset，y-offset）

可以引入偏移参数来通过`x-offset`和`y-offset`的常量值来移动整个树，这可以在第二遍中引入，当计算最终的`x`和`y`坐标时。

# Python代码实现

我已实现了一个Python代码示例的Reingold Tilford算法，[这里](https://github.com/kayjan/bigtree/blob/master/bigtree/utils/plot.py)跟随本文 closely，包括第一、第二和第三遍，并引用了`x`、`mod`和`shift`属性。

# 相关链接

+   [1] 官方论文（6页，Pascal代码）：[https://reingold.co/tidier-drawings.pdf](https://reingold.co/tidier-drawings.pdf)

+   说明（最易读，C+伪代码）：[https://rachel53461.wordpress.com/2014/04/20/algorithm-for-drawing-trees/](https://rachel53461.wordpress.com/2014/04/20/algorithm-for-drawing-trees/)

+   说明（推荐阅读）：[https://www.drdobbs.com/positioning-nodes-for-general-trees/184402320?pgno=4](https://www.drdobbs.com/positioning-nodes-for-general-trees/184402320?pgno=4)

+   说明（带有轮廓和偏移动画）：[https://williamyaoh.com/posts/2023-04-22-drawing-trees-functionally.html](https://williamyaoh.com/posts/2023-04-22-drawing-trees-functionally.html)
