["```py\nimport torch\n```", "```py\nimport tensorflow as tf\nfrom tensorflow import keras\n```", "```py\nprint('PyTorch version:', torch.__version__)\n\nprint('TensorFlow version:', tf.__version__)\nprint('Keras version:', keras.__version__)\n```", "```py\n# Define your model\nmodel = ...\noptimizer = ...\ncriterion = ...\n\n# Train the model\nfor epoch in range(num_epochs):\n    # Train the model for one epoch\n    ...\n\n    # Save a checkpoint after each epoch\n    PATH = f'checkpoint_{epoch}.pt'\n    torch.save({\n                'epoch': epoch,\n                'model_state_dict': model.state_dict(),\n                'optimizer_state_dict': optimizer.state_dict(),\n                'train_loss': train_loss,\n                }, \n                PATH)\n```", "```py\n# Define your model\nmodel = ...\noptimizer = ...\ncriterion = ...\n\n# Load a saved checkpoint\ncheckpoint = torch.load('checkpoint_3.pt')\nepoch = checkpoint['epoch']\nmodel.load_state_dict(checkpoint['model_state_dict'])\noptimizer.load_state_dict(checkpoint['optimizer_state_dict'])\n\n# Set dropout and batch normalization layers to train mode\nmodel.train()\n\n# Resume training the model for the remaining epochs\nfor epoch in range(epoch + 1, num_epochs):\n    ...\n```", "```py\n# Define and compile your model\nmodel = ...\n...\nmodel.compile(...)\n\n# Define the checkpoint callback that saves the model's weights at every epoch\nPATH = f'checkpoint_{epoch}.ckpt'\n\ncp_callback = tf.keras.callbacks.ModelCheckpoint(\n                             filepath = PATH, \n                             save_weights_only = True, # If False, saves the full model\n                             save_freq = 'epoch')\n\n# Train the model with the checkpoint callback\nmodel.fit(X_train,\n          y_train, \n          epochs = num_epochs,\n          validation_data = (X_val, y_val),\n          callbacks = [cp_callback])\n```", "```py\n# Define and compile your model\nmodel = ...\n...\nmodel.compile(...)\n\n# Load a saved checkpoint\nepoch = 3\nmodel = model.load_weights(PATH = f'checkpoint_{epoch}.ckpt')\n\n# Define the checkpoint callback that saves the model's weights at every epoch\n...\n\n# Resume training the model\nmodel.fit(X_train,\n          y_train, \n          epochs = (num_epochs-epoch),\n          validation_data = (X_val, y_val),\n          callbacks = [cp_callback])\n```", "```py\nPATH = \"model.pt\"\n\n# Define your model\nmodel = ...\n\n# Train the model\n...\n\n# Save the model\ntorch.save(model.state_dict(), PATH)\n```", "```py\n# Define your model architecture\nmodel = ...\n\n# Load the saved model parameters into your model\nmodel.load_state_dict(torch.load(PATH))\n\n# Set dropout and batch normalization layers to evaluation mode before running inference\nmodel.eval()\n\n# Use the model for inference\n# ...\n```", "```py\nPATH = \"model.pt\"\n\n# Define your model\nmodel = ...\n\n# Train the model\n...\n\n# Save the model\ntorch.save(model, PATH)\n```", "```py\n# Load the saved model parameters into your model\nmodel = torch.load(PATH)\n\n# Set dropout and batch normalization layers to evaluation mode before running inference\nmodel.eval()\n\n# Use the model for inference\n# ...\n```", "```py\nPATH = \"model\" # Will save the model in TensorFlow SavedModel format\n\n# Define and compile your model\nmodel = ...\n...\n\n# Train the model\n...\n\n# Save the model\nmodel.save(PATH)\n```", "```py\n# Load the saved model\nmodel = keras.models.load_model(PATH)\n\n# Use the model for inference\n# ...\n```", "```py\n# Define your model\nmodel = ...\noptimizer = ...\ncriterion = ...\n\n# Train the model\nfor epoch in range(num_epochs):\n    # Train the model for one epoch\n    ...\n\n    if (best_metric < current_metric):\n      best_metric = current_metric\n\n      # Save a checkpoint after each epoch\n      PATH = f'checkpoint_{epoch}.pt'\n\n      # Save the model\n      torch.save(model.state_dict(), PATH)\n```", "```py\n# Define and compile your model\nmodel = ...\n...\nmodel.compile(...)\n\n# Define the checkpoint callback that saves the model's weights at every epoch\nPATH = f'./checkpoints/checkpoint_{epoch}' # Remove .ckpt to save as SavedModel format\ncp_callback = tf.keras.callbacks.ModelCheckpoint(\n                              filepath = PATH, \n                              monitor = \"val_acc\", # Metric to monitor for best checkpoint picking\n                              save_best_only = True,                             \n                              save_weights_only = True, \n                              save_freq = 'epoch')\n\n# Train the model with the checkpoint callback\nmodel.fit(X_train,\n          y_train, \n          epochs = num_epochs,\n          validation_data = (X_val, y_val),\n          callbacks = [cp_callback])\n```"]