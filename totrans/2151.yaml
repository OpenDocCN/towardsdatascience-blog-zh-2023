- en: Turbocharge your data manipulation skills
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/turbocharge-your-data-manipulation-skills-3a26897ad6a](https://towardsdatascience.com/turbocharge-your-data-manipulation-skills-3a26897ad6a)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Unlock the power of pandas groupby, apply and transform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://bradley-stephen-shaw.medium.com/?source=post_page-----3a26897ad6a--------------------------------)[![Bradley
    Stephen Shaw](../Images/b3ef5e6e292083ff0f8523ec5ffe89f0.png)](https://bradley-stephen-shaw.medium.com/?source=post_page-----3a26897ad6a--------------------------------)[](https://towardsdatascience.com/?source=post_page-----3a26897ad6a--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----3a26897ad6a--------------------------------)
    [Bradley Stephen Shaw](https://bradley-stephen-shaw.medium.com/?source=post_page-----3a26897ad6a--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----3a26897ad6a--------------------------------)
    ·11 min read·Feb 21, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4f99de58d30f656f07cc060f24d46e5e.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Kier in Sight](https://unsplash.com/@kierinsight?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: In a competitive and data-rich world, understanding segmental behaviour is key
    to providing tailored insights and product offerings.
  prefs: []
  type: TYPE_NORMAL
- en: Whether that’s achieved through understanding segmental trends through descriptive
    statistics or via more nuanced approaches like including segmental features in
    machine learning models, some data manipulation is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily for us, pandas provides highly versatile functionality which allows
    us to cut through the majority of heavy manipulation required for segmenting data
    in various ways. Using some examples, we’ll demonstrate:'
  prefs: []
  type: TYPE_NORMAL
- en: The `groupby` operation — what it is, how it works, and what it returns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to use `apply` with `groupby` in order to apply more complex and exotic
    transformations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using `groupby` and `transform` to map the magic of `groupby` and `apply` back
    to the original data shape.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some tips and tricks that I’ve picked up over time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s get cracking — first up, getting some data to play around with.
  prefs: []
  type: TYPE_NORMAL
- en: The data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This time round we’ll be using information collected from a portfolio of consumer
    credit cards¹.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from column name changes and some format changes I’ve applied, the data
    is almost intact — a sneak peak:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b65ed0b084d87e1b1e4f88808ee1424c.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: We have various categorical features (e.g. education level) mixed in with numeric
    features (e.g. customer age). The data set is wider than the snapshot above implies,
    so don’t be surprised if you see new and interesting features being used below.
  prefs: []
  type: TYPE_NORMAL
- en: Groupby
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First things first — the `groupby`.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the documentation²:'
  prefs: []
  type: TYPE_NORMAL
- en: A groupby operation involves some combination of splitting the object, applying
    a function, and combining the results. This can be used to group large amounts
    of data and compute operations on these groups.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'That’s quite a good explanation. I also find it helpful to think of a `groupby`
    as a sort of for loop:'
  prefs: []
  type: TYPE_NORMAL
- en: Segment the data into various groups. Or, **group** the data **by** referring
    to the given segmentation “rules”.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each of the groups, apply a specified function. This could be a simple calculation
    like an average, or more exotic and complex calculations (more on that later).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Collate the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This might be a little vague at the moment, so let’s work through a couple of
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'A starter — determining the average credit limit for each type of customer,
    across the gender groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/ad3d1c75cd76fc360f9f82d65615c4b5.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Easy peasy, lemon `groupby`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s ignore the massive gender discrepancy in credit limits for now and focus
    on the underlying code. What `pandas` has done for us is divide the DataFrame
    into `attrition_flag x gender` groups, calculated the average `credit_limit` for
    each group, and collated the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we wanted to extend the segmentation to include education level, and
    also calculate the average credit utilisation rate? That’s not too complex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/f7cc81ad89d8110e53234c5118c98e2b.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing the calculation being applied to each group is also straightforward.
    For instance, if we wanted to count the number of observations in each segment,
    we could use `size` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/7edc60af09634ebad6307230d18a97d7.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads us to a more general recipe for `groupby` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/89e831c6bd3c4675e088939b20e72440.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: … where we can tailor `segments` , `features` , and `function` to individual
    use cases. I’ve been purposefully vague on what `function` actually is — we’ll
    see why in a minute — but the general idea holds true in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s talk about a few things.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve performed very basic calculations using two built-in `pandas`
    functions — `mean` and `size` . There are of course many other useful functions
    available for use, like median and standard deviation. In a minute, we’ll see
    how we can use more complex functions, custom functions and functions from other
    packages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `groupby` statement the way we have returns an object which has the
    same column names as the original DataFrame. It’s quite plausible that you end
    up with data sets which look similar but consistent of very different information
    — don’t be caught out. Sensible naming conventions or code structure can help
    with this, as well as renaming columns appropriately.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, we’ve used the same function on multiple columns. If you’d like to apply
    different functions to different columns, or different functions to the same column
    in the same groupby statement, I’d check out the `agg` functionality³. It also
    has a neat way of letting the user define the names of calculation results through
    tuples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have a basic grasp of `groupby`, we can apply ourselves as we move
    on to see how we can start using more exotic functions.
  prefs: []
  type: TYPE_NORMAL
- en: See what I did there? So funny.
  prefs: []
  type: TYPE_NORMAL
- en: '*Pro tip: using a single feature in a groupby statement will return a Series,
    which Jupyter will present like a jumble of numbers.* `to_frame` *converts the
    Series into a DataFrame, which Jupyter outputs in a more aesthetically pleasing
    way.*'
  prefs: []
  type: TYPE_NORMAL
- en: Apply
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The “standard” functions that we’ve seen above will only take us so far — that’s
    really the point of standard functions really.
  prefs: []
  type: TYPE_NORMAL
- en: If we need to do anything or advanced or bespoke, or rely on functionality in
    other packages, we need to combine `groupby` with `apply` .
  prefs: []
  type: TYPE_NORMAL
- en: 'The `apply` statement is quite self-explanatory, and described succinctly in
    the documentation⁴:'
  prefs: []
  type: TYPE_NORMAL
- en: Apply a function along an axis of the DataFrame.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Objects passed to the function are Series objects whose index is either the
    DataFrame’s index (`axis=0`) or the DataFrame’s columns (`axis=1`).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let’s do some examples of using bespoke functions on groupings.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start by doing a bit of a different calculation: scaling the group median
    by the ratio of the group maximum to the group minimum; we’ll do this for each
    type of customer split by gender.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/4f30d3fe0667104f362fbff353ac604a.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re feeling especially Pythonic, you can use lambda functions in the
    `apply` statement. That would look something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, what about applying a custom function to multiple features (columns)? It
    takes a bit more thought — let’s use an example to demonstrate.
  prefs: []
  type: TYPE_NORMAL
- en: The organisation has a heuristic which indicates the likely receptiveness of
    a customer to a credit offer. This heuristic — let’s call it the “appetite score”
    — is based on marital status, gender, number of dependents, and the average credit
    utilisation. We would like to understand the average appetite score for each customer
    type and gender.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code-wise, this could look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '… which gives:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/200bca61e535b7047c2cdbf38bdba787.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: A few things to notice here.
  prefs: []
  type: TYPE_NORMAL
- en: We use dictionaries and `map` to convert marital status and gender to numeric
    values for calculation in the heuristic, remembering to convert the data type
    appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: We don’t explicitly select the features we need for the heuristic. This is actually
    a nifty trick which I haven’t really touched on — we can feed both Series and
    DataFrames into the `apply` . In this case, since we don’t specify which features
    to use, we are effectively passing the resulting grouped DataFrame to the `cohort_score`
    function, which in turn filters out necessary columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'The calculation of the mean is baked into the function. Now arguably, this
    is cheating a bit — in real life, we may want to build a heuristic which calculates
    the appetite score on an individual level, and then create group statistics from
    the result. This actually ties in well with two other concepts : using functions
    from other packages and using a lambda function.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s do exactly that now — define a heuristic which doesn’t return an average,
    use `numpy` to calculate the group average, and wrap it in a lambda function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'which gives:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/15b09d5439da4993d28fe9bca3016aad.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Look familiar? It should do, as it’s exactly the same result as the calculation
    above.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to notice is how easy it is to use a function from another package.
    In this case, we’ve used the mean calculation from `numpy` , but the concept is
    the same — feed the function into `apply` , making reference to the package it
    comes from (remembering of course to import the package!).
  prefs: []
  type: TYPE_NORMAL
- en: Transform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ll by now have noticed that `groupby` returns group statistics, presented
    at a *group* level. Perfect if that’s what you’re after — for instance, for visualisation
    or summation — but there are cases where we need to “map" the group result back
    to individual observations.
  prefs: []
  type: TYPE_NORMAL
- en: I’m sure there are many other applications for this, but this approach can be
    extremely useful in feature engineering. Imagine for a moment that you’re predicting
    house prices — wouldn’t it be good to know how big an individual house is compared
    to the “average" house in the same neighborhood?
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily for us, pandas provides easy functionality which allows us to do just
    that, without the need for any joining or merging. This is the magic of transform,
    though the documentation undersells it a bit⁵:'
  prefs: []
  type: TYPE_NORMAL
- en: Call `func` on self producing a DataFrame with the same axis shape as self
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Maybe an example would be useful! Let’s see how we could apply the scaled median
    function again, but this time using transform to create a new column in the data
    with the group results mapped back to each individual observation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'which gives:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7f7b06317df8e3efc0beb9701fa3307a.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Here we see how the same group values are produced, but are also mapped back
    to size and included in the DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: Tips and tricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a grounding in `groupby` , `apply`, and `transform`, let’s
    take a look at some tips and tricks that might be useful.
  prefs: []
  type: TYPE_NORMAL
- en: The versatility of apply
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `apply` function is very versatile. We’ve seen how we can apply it with
    a `groupby` operation, but that’s not always necessary — i.e. you can use `apply`
    on a DataFrame directly.
  prefs: []
  type: TYPE_NORMAL
- en: Axes and apply
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When I started using `apply` in anger, I encountered (probably more than) my
    fair share of error messages. More often than not, it was down to me not completely
    understanding the axis that the function was being applied along — i.e. I was
    incorrectly specifying whether or not to apply the function to rows or columns.
  prefs: []
  type: TYPE_NORMAL
- en: So, if you’re certain that your function works but `pandas` is still being disagreeable,
    I’d recommend taking a look at the `axis` argument in `apply`.
  prefs: []
  type: TYPE_NORMAL
- en: Using built-in functions with apply
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we’ve seen above, we can use built-in `pandas` functions directly on grouped
    DataFrames.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the same built-in functions in an `apply` , though we have
    to refer to the function by its name. For instance, using the built-in standard
    deviation function would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: So as it is with most things Python, there’s more than one way of doing things.
    However, using built-in functions in an `apply` statement like this can actually
    be *slower* than using them directly.
  prefs: []
  type: TYPE_NORMAL
- en: Missing data imputation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We earlier touched on how `apply` and `transform` are useful techniques when
    doing feature engineering. Well, they’re also great for data cleansing, particularly
    if you want to impute missing values using segmental statistics.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example where we see how we can use median customer age for customer
    type and marital status to impute missing customer age values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/d34af0df3babd9d26ac965a9ac931a9e.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: This is obviously quite a contrived example but the logic transfers well to
    other use cases, especially if the groups are fairly homogeneous.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll leave it here for now, and do a quick recap.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve covered a fair bit of ground here.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we had a look at the `groupby` operation — what it is, how it works,
    and what it returns.
  prefs: []
  type: TYPE_NORMAL
- en: Once we found our feet using basic function with `groupby` , we pushed the boat
    out a bit and moved on to using bespoke functions by combining `apply` with `groupby`.
  prefs: []
  type: TYPE_NORMAL
- en: While having statistics at the group level is useful, we discussed why we might
    want to map those group statistics back to each individual observation. We saw
    how we can use `groupby` and `transform` to do exactly that.
  prefs: []
  type: TYPE_NORMAL
- en: I also shared a few “tips and tricks” that I’ve learned over time — hopefully
    they make your journey with `groupby`, `apply`, and `transform` a little smoother.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen a few examples, I’d encourage you to have a go yourself
    — practice makes perfect and all that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, there are extra bits we can do to take our analysis and presentation
    to the next level. The first is to appropriately format DataFrames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/make-your-tables-look-glorious-2a5ddbfcc0e5?source=post_page-----3a26897ad6a--------------------------------)
    [## Make Your Tables Look Glorious'
  prefs: []
  type: TYPE_NORMAL
- en: Simple formatting tricks to make your pandas DataFrames presentation-ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/make-your-tables-look-glorious-2a5ddbfcc0e5?source=post_page-----3a26897ad6a--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: '… and the second is to produce presentation-ready charts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/make-your-charts-look-glorious-9ce3fa310b70?source=post_page-----3a26897ad6a--------------------------------)
    [## Make your charts look glorious'
  prefs: []
  type: TYPE_NORMAL
- en: Simple tricks to make matplotplib charts presentation-ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/make-your-charts-look-glorious-9ce3fa310b70?source=post_page-----3a26897ad6a--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: As always, I hope you’ve enjoyed reading this as much as I have enjoyed writing
    it. As always, I’d love to learn about new tips and tricks, so please feel free
    to share in the comments!
  prefs: []
  type: TYPE_NORMAL
- en: References and resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[zhyli. (2020). Prediction of Churning Credit Card Customers [Data set]. Zenodo.](https://doi.org/10.5281/zenodo.4322341),
    provided under the [Creative Comons — Attribution 4.0 International](https://creativecommons.org/licenses/by/4.0/legalcode)
    licence.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[pandas.DataFrame.groupby — pandas 1.5.3 documentation (pydata.org)](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.groupby.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[pandas.DataFrame.agg — pandas 1.5.3 documentation (pydata.org)](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.agg.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[pandas.DataFrame.apply — pandas 1.5.3 documentation (pydata.org)](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.apply.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[pandas.DataFrame.transform — pandas 1.5.3 documentation (pydata.org)](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.transform.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
