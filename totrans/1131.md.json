["```py\nsudo curl -o /usr/local/bin/cloud-sql-proxy \\\n  https://storage.googleapis.com/cloud-sql-connectors/cloud-sql-proxy/v2.0.0/cloud-sql-proxy.linux.amd64\n\nsudo chmod +x /usr/local/bin/cloud-sql-proxy\n```", "```py\n# 1\\. Find the instance name to be used.\n#    It should have a format of myproject:myregion:myinstance.\ngcloud sql instances describe <INSTANCE_NAME> --format='value(connectionName)'\n\n# 2\\. Use the long instance connection name returned by 1 for cloud-sql-proxy.\ncloud-sql-proxy --port 13306 INSTANCE_CONNECTION_NAME &\n# Note that a high port is used to avoid potential port conflicts.\n# It may not be needed for your use case.\n\n# 3\\. When not running on GCP resources and GOOGLE_APPLICATION_CREDENTIALS is\n#    not set locally, we need to specify the key file directly.\ncloud-sql-proxy --port 13306 INSTANCE_CONNECTION_NAME \\\n    --credentials-file /local/path/to/service-account-key.json &\n\n# 4\\. On GCP compute engine, you can connect by a private IP if the compute\n#    engine and SQL instance are in the same VPC network.\ncloud-sql-proxy --port 13306 INSTANCE_CONNECTION_NAME --private-ip &\n\n# 5\\. You can connect to multiple Cloud SQL instances at same time, which can\n#    be handy for local development as you may need to access multiple\n#    databases at the same time.\ncloud-sql-proxy \"INSTANCE_CONNECTION_NAME_1?port=13306\" \\\n    \"INSTANCE_CONNECTION_NAME_2?port=13307\" &\n# Remember to specify differnt ports for different instances.\n```", "```py\nThe proxy has started successfully and is ready for new connections!\n```", "```py\nmysql -h 127.0.0.1 -P 13306 -u DB_USERNAME -p\n```", "```py\ndocker pull gcr.io/cloud-sql-connectors/cloud-sql-proxy:2.0.0\n\ndocker run -d \\\n  -v /local/path/to/service-account-key.json:/container/path/to/service-account-key.json \\\n  -p 127.0.0.1:3306:3306 \\\n  gcr.io/cloud-sql-connectors/cloud-sql-proxy:2.0.0 \\\n  --address 0.0.0.0 --port 3306 \\\n  --credentials-file /container/path/to/service-account-key.json INSTANCE_CONNECTION_NAME\n```", "```py\nversion: \"3.9\"\n\nservices:\n  cloudsql:\n    image: gcr.io/cloud-sql-connectors/cloud-sql-proxy:2.0.0\n    volumes:\n      - type: bind\n        source: ./service-account-key.json\n        target: /service-account-key.json\n        read_only: true\n    ports:\n      - target: 3306\n        published: 13306\n    command: --address 0.0.0.0 --port 3306 --credentials-file /service-account-key.json glass-core-xxxxxx:europe-west1:gs-mysql\n```", "```py\ndocker-compose up -d\n```", "```py\nversion: \"3.9\"\n\nservices:\n  cloudsql:\n    image: gcr.io/cloud-sql-connectors/cloud-sql-proxy:2.0.0\n    volumes:\n      - type: bind\n        source: ~/.config/gcloud\n        target: /home/nonroot/.config/gcloud\n        read_only: true\n    ports:\n      - target: 3306\n        published: 13306\n    command: --address 0.0.0.0 --port 3306 glass-core-xxxxxx:europe-west1:gs-mysql\n```", "```py\nopen /home/nonroot/.config/gcloud/application_default_credentials.json: permission denied\n```", "```py\nfind ~/.config/gcloud/ -type d | xargs -I {} chmod 755 {}\nfind ~/.config/gcloud/ -type f | xargs -I {} chmod 644 {}\n```", "```py\nversion: \"3.9\"\n\nservices:\n  my-app:\n    build:\n      context: ./app\n    image: my-app:latest\n    ports:\n      - target: 80\n        published: 8080\n    networks:\n      - my-app\n    volumes:\n      - type: bind\n        source: ./app\n        target: /app\n    env_file:\n      - ./secrets.env\n    environment:\n      - PYTHONPATH=/app:.:..\n      - DB_NAME=app\n      - DB_HOST=cloudsql\n      - DB_PORT=3306\n    depends_on:\n      - cloudsql\n\n  cloudsql:\n    image: gcr.io/cloud-sql-connectors/cloud-sql-proxy:2.0.0\n    volumes:\n      - type: bind\n        source: ~/.config/gcloud\n        target: /home/nonroot/.config/gcloud\n        read_only: true\n    ports:\n      - target: 3306\n        published: 13306\n    networks:\n      - my-app\n    command: --address 0.0.0.0 --port 3306 glass-core-xxsxxx:europe-west1:gs-mysql\n\nnetworks:\n  my-app:\n    name: my-app\n    driver: bridge\n```", "```py\n# app/db/db.py\nfrom pydantic import BaseSettings, Field, SecretStr\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import scoped_session, sessionmaker, Session\nfrom sqlalchemy.schema import MetaData\n\n# Create a base for SQLAlchemy mappers.\nBase = declarative_base(metadata=MetaData(schema=\"app\"))\nmetadata = Base.metadata\n\n# A Pydantic model to get environment variables.\nclass DbSettings(BaseSettings):\n    \"\"\"Settings for SQL.\"\"\"\n\n    host: str = Field(..., env=\"DB_HOST\")\n    user: str = Field(..., env=\"DB_USERNAME\")\n    password: SecretStr = Field(..., env=\"DB_PASSWORD\")\n    port: int = Field(env=\"DB_PORT\", default=3306)\n    db_name: str = Field(env=\"DB_NAME\", default=\"app\")\n\n# We need to create an instance of the Pydantic model to access the\n# environment variables.\ndb_settings = DbSettings()\n\ndb_conn_url = (\n    \"mysql+pymysql://\"\n    f\"{db_settings.user}:{db_settings.password.get_secret_value()}\"\n    f\"@{db_settings.host}:{db_settings.port}/{db_settings.db_name}\"\n)\n\n# Create SQLAlchemy SQL engine and session factory.\nengine = create_engine(db_conn_url)\nsession_factory = sessionmaker(bind=engine)\nscoped_session_factory = scoped_session(session_factory)\n\ndef get_db_sess():\n    \"\"\"Get a SQLAlchemy ORM Session instance.\n\n    Yields:\n        A SQLAlchemy ORM Session instance.\n    \"\"\"\n    db_session: Session = scoped_session_factory()\n    try:\n        yield db_session\n    except Exception as exc:\n        db_session.rollback()\n        raise exc\n    finally:\n        db_session.close()\n```", "```py\n# app/main.py\nfrom fastapi import Depends, FastAPI\nfrom sqlalchemy.orm import Session\n\nfrom app.db.db import get_db_sess\nfrom app.db.models.users import User as UserModel\nfrom app.schema.users import User as UserSchema\n\napp = FastAPI()\n\n@app.get(\"/users\")\nasync def get_users(\n    db_sess: Session = Depends(get_db_sess),\n) -> list[UserSchema]:\n    users = db_sess.query(UserModel).all()\n\n    return users\n```"]