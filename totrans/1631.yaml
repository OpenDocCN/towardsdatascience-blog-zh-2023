- en: 'Pandas: Work on Your dtypes!'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/pandas-work-on-your-dtypes-20d9d32d2e42](https://towardsdatascience.com/pandas-work-on-your-dtypes-20d9d32d2e42)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Having the right dtypes in pandas is a must for clean data-analysis. Here’s
    how and why.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://mocquin.medium.com/?source=post_page-----20d9d32d2e42--------------------------------)[![Yoann
    Mocquin](../Images/b30a0f70c56972aabd2bc0a74baa90bb.png)](https://mocquin.medium.com/?source=post_page-----20d9d32d2e42--------------------------------)[](https://towardsdatascience.com/?source=post_page-----20d9d32d2e42--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----20d9d32d2e42--------------------------------)
    [Yoann Mocquin](https://mocquin.medium.com/?source=post_page-----20d9d32d2e42--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----20d9d32d2e42--------------------------------)
    ·8 min read·Sep 26, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '**Having appropriate dtypes for your Series and DataFrame is very important
    for many reasons:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory management**: using the right dtype for a particular *series* can
    dramatically reduce its memory usage, and by extension this also applies to *dataframes*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interpretation**: anyone else (human or computer) will make assumptions on
    your data based on its dtype: if a column full of integers is stored as a string,
    they will treat it as strings, not integers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It enforces you to have clean data**, like dealing with missing values or
    mis-recorded values. This will ease the data-crunching down the road a lot'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And there are probably many more reasons, can you name a few? If so please write
    it in a comment.
  prefs: []
  type: TYPE_NORMAL
- en: '**In this first post of my pandas series, I want to review the basics of pandas
    datatypes — or dtypes.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/30c0a25974ae9b6e906206459f18ef8f.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Chris Curry](https://unsplash.com/@chriscurry92?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: We will first review the available dtypes *pandas* offers, then I’ll focus on
    4 useful dtypes that will fulfill 95% of your needs, namely **numerical dtypes,
    boolean dtype, string dtype, and categorical dtypes**.
  prefs: []
  type: TYPE_NORMAL
- en: '**The end goal of this first post is to make you more comfortable with the
    various data types availables in pandas and what are their differences.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**If you’re interested in pandas and time-series, make sure to check out my
    Fourier-transform for time-serie posts:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Review how the convolution relate to the Fourier transform and how fast it
    is**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[](/fourier-transform-for-time-series-fast-convolution-explained-with-numpy-5a16834a2b99?source=post_page-----20d9d32d2e42--------------------------------)
    [## Fourier transform for time-series: fast convolution explained with numpy'
  prefs: []
  type: TYPE_NORMAL
- en: 10000-times faster convolution using Fourier transform
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/fourier-transform-for-time-series-fast-convolution-explained-with-numpy-5a16834a2b99?source=post_page-----20d9d32d2e42--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: '**Deepen your understanding of convolution using image examples:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[](/fourier-transform-for-time-series-about-image-convolution-and-scipy-5e8fa1279603?source=post_page-----20d9d32d2e42--------------------------------)
    [## Fourier-Transform for Time Series: About Image Convolution and SciPy'
  prefs: []
  type: TYPE_NORMAL
- en: Fourier-transform convolution also applies to images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/fourier-transform-for-time-series-about-image-convolution-and-scipy-5e8fa1279603?source=post_page-----20d9d32d2e42--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: '**Understand how the Fourier-transform can be visualy understood using a vector-visual
    approach:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[](/fourier-transform-for-time-series-plotting-complex-numbers-9743ffe8a8bb?source=post_page-----20d9d32d2e42--------------------------------)
    [## Fourier-transform for time-series : plotting complex numbers'
  prefs: []
  type: TYPE_NORMAL
- en: Plot the Fourier-transform algorithm to understand it.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/fourier-transform-for-time-series-plotting-complex-numbers-9743ffe8a8bb?source=post_page-----20d9d32d2e42--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: '**See how detrending techniques can improve greatly the output of the Fourier-transform:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[](/fourier-transform-for-time-series-detrending-f0f470f4bf14?source=post_page-----20d9d32d2e42--------------------------------)
    [## Fourier-transform for time-series : detrending'
  prefs: []
  type: TYPE_NORMAL
- en: Detrending your time-series might be a game-changer.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/fourier-transform-for-time-series-detrending-f0f470f4bf14?source=post_page-----20d9d32d2e42--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: '**Review of the available dtypes**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s take a minute to review the dtypes pandas offers. Since *pandas* is based
    on *numpy*, they can be splitted in 2 categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**numpy-based dtypes**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pandas-specific dtypes**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Under the hood, *pandas* stores your data in *numpy* arrays, hence uses numpy’s
    dtypes. We can consider those the ultimate low-level dtypes. But for convenience,
    *pandas* also exposes higher-level dtypes that were specifically created by the
    *pandas* team.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is that from your point of view, the end-user, all dtypes (numpy-based
    or pandas-specific) are equally considered as valid dtypes for your *series* and
    *dataframe*s.
  prefs: []
  type: TYPE_NORMAL
- en: '**The *numpy*-based dtypes are the following:**'
  prefs: []
  type: TYPE_NORMAL
- en: '`**float**`: to store floating-point numbers (0.0245)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**int**`: to store integer numbers (1, -6)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**bool**`: to store booleans (True/False)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**datetime64[ns]**`: to store an instant of our timeline (date and time of
    day)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**timedelta64[ns]**`: to store a relative duration (this complements the datettime
    dtype)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**object**`: can store literally any python object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The actual complete list of numpy dtypes](https://numpy.org/doc/stable/user/basics.types.html)
    is bigger than that, but we’ll stick to those above.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Then *pandas* comes into play and exposes many new dtypes, including :**'
  prefs: []
  type: TYPE_NORMAL
- en: '`**string**`: another way to store strings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**Nullable-int**` and `**Nullable-float**` that are better at handling missing
    values than *numpy*’s `**int**` and `**float**`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**boolean**`: boolean that is better at handling missing values than *numpy*’s
    `**bool**`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**categorical**`: a dtype that is appropriate for data than can only have
    specific values and can handle missing entries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, [other dtypes are defined in pandas,](https://pandas.pydata.org/docs/user_guide/basics.html#dtypes)
    but I want to focus on these 4 because I found that there are the most useful.
  prefs: []
  type: TYPE_NORMAL
- en: '**How dtypes are set**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In practice, the dtype of your data can have 2 origins:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Either you didn’t specify the dtype**, and *pandas* made an assumption when
    the series/dataframe were created (whether it’s from loading a csv or creating
    object like *`s = pd.Series([1, 2, 3])`*). This will work well about 50% to 80%
    of the time, depending on how well the input data is formatted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Either you specify the dtype**, by explicitly telling pandas what dtype to
    use for each column/series'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the first case:'
  prefs: []
  type: TYPE_NORMAL
- en: '- **PROS**: simpler and faster'
  prefs: []
  type: TYPE_NORMAL
- en: '- **CONS**: you don’t know what happened unless you review each dtype afterward,
    you might not have the most-appropriate dtype (like `object` because pandas did
    not figure what the column was about), and even worse you might very ill-appropriate
    dtype for some columns'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the second case:'
  prefs: []
  type: TYPE_NORMAL
- en: '- **PROS**: you know exactly what happened to your data, you know exactly what
    dtypes the columns have, you know exactly how you treated missing and ill-conditionned
    values. In other words, your data is ready for actual processing'
  prefs: []
  type: TYPE_NORMAL
- en: '- **CONS**: it takes more time, more code'
  prefs: []
  type: TYPE_NORMAL
- en: '**In the end, I’d recommend the following: first, let pandas infer dtypes and
    do its best. Then review each columns and manually set the dtypes you think should
    be changed.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**We’ll see in the next post how to do all this, but for now I want to review
    the available dtypes and why they exist.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Since most of the time I end up using only a subset of all the dtypes available,
    I’ll focus on those:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**numerical dtypes, mostly float and int**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**boolean dtypes**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**string-like (including string and object) dtypes**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**categorical dtype**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Numerical-like dtypes**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Regarding numerical dtypes, *numpy* provides a solid base: integers and floating-point
    numbers dtypes, that also handle `*np.nan*`. Note also that by default, numerical
    dtypes used will be `int64` and `float64`. This might not be ideal for your data
    regarding memory usage and explicit allowed values for a given Series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that as soon as `***np.nan***` is used, the dtypes is converted to float.
    For this reason, and some more, *pandas* also exposes dtypes that can handle missing
    values using the pandas-specific `***pd.NA***` and still keep the explicit underlying
    numerical dtype, like `***Int64Dtype***` ([rationale here](https://pandas.pydata.org/docs/user_guide/integer_na.html#nullable-integer-data-type)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, we can have the best of both worlds: an explicit underlying numerical
    dtype (int64, float32, etc), and handle missing values with `***pd.NA***`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Boolean-like dtypes**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are basically 2 dtypes that act like booleans, namely ‘***bool***’ and
    ‘***boolean***’.
  prefs: []
  type: TYPE_NORMAL
- en: ‘*bool*’ corresponds to standard *numpy*-based boolean, and hence cannot contain
    ‘***NA***’ since only ***True*** and ***False*** can be stored in a boolean-numpy
    array.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle ‘not-available’ entries — or ‘NA’- pandas exposes the dtype ‘***boolean***’,
    that can contain ‘NA’. See the example below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**String-like dtypes**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Natively, strings can be stored in *numpy* arrays since we can use the ***`object***`
    dtype, which exists to handle “any python object”.
  prefs: []
  type: TYPE_NORMAL
- en: Strings differ from most other dtypes in that one cannot know the length of
    a string in advance, hence the necessary memory to allocate. That’s also the case
    for any custom python object, that be very simple or really complicated, and need
    various amounts of memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'So we can use the ‘***object***’ dtype in pandas since it is available in *numpy*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, *pandas* created a dtype that make the fact that the data is
    a string explicit: the `***StringDtype***` that can be specified as `***string***`,
    which is better since “explicit is better than implicit”, and interface better
    with the rest of pandas’ ecosystem ([rationale here](https://pandas.pydata.org/docs/user_guide/text.html#text-data-types)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that most of the time, you’ll need to challenge yourself in asking: do
    I really need that series to be stored as a string ? Are those strings just representation
    of other data, like numerical data or categorical data ? If so, you’ll want to
    convert those series dtypes. Subscribe to see my next post on how to do that!'
  prefs: []
  type: TYPE_NORMAL
- en: '**The joker dtype: Categorical**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I’d suggest trying this: open up one of your datasets in pandas, review the
    columns one by one, and ask yourself: *could this feature be stored as a Categorical
    dtype* ?'
  prefs: []
  type: TYPE_NORMAL
- en: I’m willing to bet that you’ll say yes to that question more than you expected.
  prefs: []
  type: TYPE_NORMAL
- en: This dtypes is especially useful and suitable for things you usually stored
    as integer-like numbers (0, 1, 2, etc) and/or strings (*‘Male’/’Female’, ‘Dog’/’Cat’/’Other’*).
  prefs: []
  type: TYPE_NORMAL
- en: This dtypes can greatly improve speed and memory usage in some case. It also,
    again, makes it explicit to others (humans and computers) that this particular
    data represents a category and should be treated as such.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Wrap up**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Other dtypes are implemented in *pandas*, but I found that they are not used
    as much the ones above.
  prefs: []
  type: TYPE_NORMAL
- en: '**So remember:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good dtypes are critical to your processing, reviewing and setting the right
    ones as soon as possible will make your work down the road a lot easier for everyone.
    Also, it might save a lot of memory and processing complexity**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Before using `object` or `string` dtype, consider using `categorical` dtype**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**If dealing with missing values or NaN, consider using pandas dtypes like
    `boolean` as opposed to numpy’s `bool`**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Only use `object` dtype if your data is complex and/or does not fit in any
    other dtype**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next post, we’ll see how to inspect the dtypes of existing Series/DataFrame,
    and how to change them to convert to other dtypes.
  prefs: []
  type: TYPE_NORMAL
- en: If **you’re considering joining Medium and get unlimited acces to all of my
    and others posts, use this link to quickly subscribe and become one of my refered
    member:**
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[](https://medium.com/@mocquin/membership?source=post_page-----20d9d32d2e42--------------------------------)
    [## Join Medium with my referral link - Yoann Mocquin'
  prefs: []
  type: TYPE_NORMAL
- en: As a Medium member, a portion of your membership fee goes to writers you read,
    and you get full access to every story…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/@mocquin/membership?source=post_page-----20d9d32d2e42--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: '**and then subscribe to get notified for futur posts:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://mocquin.medium.com/subscribe?source=post_page-----20d9d32d2e42--------------------------------)
    [## Get an email whenever I publish !'
  prefs: []
  type: TYPE_NORMAL
- en: Get an email whenever I publish ! New publication will include data transformation,
    advanced plotting and simulation…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: mocquin.medium.com](https://mocquin.medium.com/subscribe?source=post_page-----20d9d32d2e42--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: '**Finaly, check out some of my other posts:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/300-times-faster-resolution-of-finite-difference-method-using-numpy-de28cdade4e1?source=post_page-----20d9d32d2e42--------------------------------)
    [## 300-times faster resolution of Finite-Difference Method using numpy'
  prefs: []
  type: TYPE_NORMAL
- en: Finite-difference method is a powerfull technique to solve complex problems,
    and numpy makes it fast !
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'towardsdatascience.com](/300-times-faster-resolution-of-finite-difference-method-using-numpy-de28cdade4e1?source=post_page-----20d9d32d2e42--------------------------------)
    [](/pca-lda-ica-a-components-analysis-algorithms-comparison-c5762c4148ff?source=post_page-----20d9d32d2e42--------------------------------)
    [## PCA/LDA/ICA : a components analysis algorithms comparison'
  prefs: []
  type: TYPE_NORMAL
- en: Review the concepts and differences between these famous algorithms.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/pca-lda-ica-a-components-analysis-algorithms-comparison-c5762c4148ff?source=post_page-----20d9d32d2e42--------------------------------)
    [](https://mocquin.medium.com/one-sample-t-test-visually-explained-415c31744e14?source=post_page-----20d9d32d2e42--------------------------------)
    [## One-sample t-test, visually explained
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to one of the most famous statistical tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: mocquin.medium.com](https://mocquin.medium.com/one-sample-t-test-visually-explained-415c31744e14?source=post_page-----20d9d32d2e42--------------------------------)
    [](/wrapping-numpys-arrays-971e015e14bb?source=post_page-----20d9d32d2e42--------------------------------)
    [## Wrapping numpy’s arrays
  prefs: []
  type: TYPE_NORMAL
- en: The container approach.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/wrapping-numpys-arrays-971e015e14bb?source=post_page-----20d9d32d2e42--------------------------------)
  prefs: []
  type: TYPE_NORMAL
