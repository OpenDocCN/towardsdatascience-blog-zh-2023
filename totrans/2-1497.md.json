["```py\nimport pandas as pd\n```", "```py\nclass TimeSeriesAnalysis:\n    def __init__(self, data):\n        self.df = pd.read_csv(data)\n```", "```py\nclass TimeSeriesAnalysis:\n    ...\n    def get_time_series(self, target):\n        self.df['date'] = pd.to_datetime(self.df['date'])\n        self.df.set_index('date', inplace=True)\n        self.ts_df = self.df[target]\n```", "```py\nclass TimeSeriesAnalysis:\n    ...\n    def get_summary_stats(self):\n        print(f\"Mean {self.target}: \", self.ts_df.mean())\n        print(f\"Standard Dev. {self.target}: \", self.ts_df.std())\n```", "```py\nimport seaborn as sns \nimport matplotlib.pyplot as plt \nimport statsmodels.api as sm\n```", "```py\nclass TimeSeriesAnalysis:\n    ...\n    def visualize(self, line_plot, histogram, decompose):\n        sns.set()\n        if line_plot:\n            plt.plot(self.ts_df)\n            plt.title(f\"Daily {self.target}\")\n            plt.xticks(rotation=45)\n            plt.show()\n        if histogram:\n            self.ts_df.hist(bins=100)\n            plt.title(f\"Histogram of {self.target}\")\n            plt.show()\n        if decompose:\n            decomposition = sm.tsa.seasonal_decompose(self.ts_df, model='additive', period =180)\n            fig = decomposition.plot()\n            plt.show()\n```", "```py\nclass TimeSeriesAnalysis:\n    ...\n    def stationarity_test(self):\n        adft = adfuller(self.ts_df,autolag=\"AIC\")\n        output_df = pd.DataFrame({\"Values\":[adft[0],adft[1],adft[2],adft[3], adft[4]['1%'], adft[4]['5%'], adft[4]['10%']] , \"Metric\":[\"Test Statistics\",\"p-value\",\"No. of lags used\",\"Number of observations used\",\n\"critical value (1%)\", \"critical value (5%)\", \"critical value (10%)\"]})\n        self.adf_results = output_df \n```", "```py\nfrom statsmodels.tsa.stattools import adfuller\n```", "```py\nfrom statsmodels.tsa.stattools import adfuller, kpss\n```", "```py\nclass TimeSeriesAnalysis:\n    ...\n    def stationarity_test(self):\n        adft = adfuller(self.ts_df,autolag=\"AIC\")\n        kpsst = kpss(self.ts_df,autolag=\"AIC\")\n\n        adf_results = pd.DataFrame({\"Values\":[adft[0],adft[1],adft[2],adft[3], adft[4]['1%'], adft[4]['5%'], adft[4]['10%']] , \"Metric\":[\"Test Statistics\",\"p-value\",\"No. of lags used\",\"Number of observations used\",\n\"critical value (1%)\", \"critical value (5%)\", \"critical value (10%)\"]})\n\n        kpss_results = pd.DataFrame({\"Values\":[kpsst[0],kpsst[1],kpsst[2], kpsst[3]['1%'], kpsst[3]['5%'], kpsst[3]['10%']] , \"Metric\":[\"Test Statistics\",\"p-value\",\"No. of lags used\",\n    \"critical value (1%)\", \"critical value (5%)\", \"critical value (10%)\"]})\n\n        self.adf_results = adf_results\n        self.kpss_resulta = kpss_results \n```", "```py\nclass TimeSeriesAnalysis:\n    ...\n    def stationarity_test(self):\n            adft = adfuller(self.ts_df,autolag=\"AIC\")\n            kpsst = kpss(self.ts_df)\n\n            adf_results = pd.DataFrame({\"Values\":[adft[0],adft[1],adft[2],adft[3], adft[4]['1%'], adft[4]['5%'], adft[4]['10%']] , \"Metric\":[\"Test Statistics\",\"p-value\",\"No. of lags used\",\"Number of observations used\",\n    \"critical value (1%)\", \"critical value (5%)\", \"critical value (10%)\"]})\n\n            kpss_results = pd.DataFrame({\"Values\":[kpsst[0],kpsst[1],kpsst[2], kpsst[3]['1%'], kpsst[3]['5%'], kpsst[3]['10%']] , \"Metric\":[\"Test Statistics\",\"p-value\",\"No. of lags used\",\n    \"critical value (1%)\", \"critical value (5%)\", \"critical value (10%)\"]})\n\n            self.adf_results = adf_results\n            self.kpss_results = kpss_results\n            print(self.adf_results)\n            print(self.kpss_results)\n            self.adf_status = adf_results['Values'].iloc[1] > adf_results['Values'].iloc[4]\n            self.kpss_status = kpss_results['Values'].iloc[1] < kpss_results['Values'].iloc[3]\n\n            print(\"ADF Results: \", self.adf_status)\n            print(\"KPSS Results: \" ,self.kpss_status) \n```", "```py\ndef train_test_split(self):\n        self.y_train = self.ts_df[self.ts_df.index <= pd.to_datetime('2016-07')]\n        self.y_test = self.ts_df[self.ts_df.index > pd.to_datetime('2016-07')]\n```", "```py\n!pip install pmdarima\n```", "```py\nfrom pmdarima.arima import auto_arima\n```", "```py\ndef fit(self):\n        self.y_train.fillna(0,inplace=True)\n        model = auto_arima(self.y_train, trace=True,  error_action='ignore', suppress_warnings=True, stationary=True)\n        model.fit(self.y_train)\n        forecast = model.predict(n_periods=len(self.ts_df))\n        self.forecast = pd.DataFrame(forecast,index = self.ts_df.index,columns=['Prediction'])\n\n        self.ts_df = pd.DataFrame(self.ts_df, index = self.forecast.index)\n\n        self.y_train = self.ts_df[self.ts_df.index < pd.to_datetime('2016-07')]\n\n        self.y_test = self.ts_df[self.ts_df.index > pd.to_datetime('2016-07')]\n\n        self.forecast = self.forecast[self.forecast.index > pd.to_datetime('2016-07')]\n```", "```py\ndef validate(self):\n    plt.plot(self.y_train, label='Train')\n    plt.plot(self.y_test, label='Test')\n    plt.plot(self.forecast, label='Prediction')\n    mae = np.round(mean_absolute_error(self.y_test, self.forecast), 2)\n    plt.title(f'{self.target} Prediction; MAE: {mae}')\n    plt.xlabel('Date')\n    plt.ylabel(f'{self.target}')\n    plt.xticks(rotation=45)\n    plt.legend(loc='upper left', fontsize=8)\n    plt.show()\n```"]