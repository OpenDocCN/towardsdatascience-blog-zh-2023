["```py\npip install --upgrade scalecast\n```", "```py\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom scalecast.Forecaster import Forecaster\nfrom scalecast.SeriesTransformer import SeriesTransformer\n\ndata = pd.read_csv('AirPassengers.csv')\n```", "```py\nf = Forecaster(\n    current_dates = data['Month'],\n    y = data['#Passengers'],\n    future_dates = 24,\n)\n```", "```py\ntransformer = SeriesTransformer(f)\n```", "```py\nf = transformer.DiffTransform(12) # 12 periods is one seasonal difference for monthly data\nf = transformer.DetrendTransform()\n\n# plot results\nf.plot();\n```", "```py\nf.set_estimator('xgboost')\nf.add_ar_terms(12)\nf.manual_forecast(n_estimators=100,gamma=2)\nf.plot();\n```", "```py\nf = transformer.DetrendRevert()\nf = transformer.DiffRevert(12)\nf.plot();\n```", "```py\nfrom scalecast.util import find_optimal_transformation\n# default args below\ntransformer, reverter = find_optimal_transformation(\n    f, # Forecaster object to try the transformations on\n    estimator=None, # model used to evaluate each transformation, default mlr\n    monitor='rmse', # out-of-sample metric to monitor\n    test_length = None, # default is the fcst horizon in the Forecaster object\n    train_length = None, # default is the max available\n    num_test_sets = 1, # number of test sets to iterate through, final transformation based on best avg. metric\n    space_between_sets = 1, # space between consectutive train sets\n    lags='auto', # uses the length of the inferred seasonality\n    try_order = ['detrend','seasonal_adj','boxcox','first_diff','first_seasonal_diff','scale'], # order of transformations to try\n    boxcox_lambdas = [-0.5,0,0.5], # box-cox lambas\n    detrend_kwargs = [{'loess': True},{'poly_order':1},{'poly_order':2}], # detrender transform kwargs (tries as many detrenders as the length of this list)\n    scale_type = ['Scale','MinMax','RobustScale'], # scale transformers to try\n    m = 'auto', # the seasonal length to try for the seasonal adjusters, accepts multiple\n    model = 'add', # the model to use when seasonally adjusting\n    # specific model kwargs also accepted\n)\n# see what it chose\nreverter\n```", "```py\nReverter(\n  reverters = [\n    ('DiffRevert', 12),\n    ('DiffRevert', 1),\n    ('Revert', <function find_optimal_transformation.<locals>.boxcox_re at 0x0000029FA6900EE0>, {'lmbda': -0.5})\n  ],\n  base_transformer = Transformer(\n  transformers = [\n    ('Transform', <function find_optimal_transformation.<locals>.boxcox_tr at 0x0000029FA6E579D0>, {'lmbda': -0.5}),\n    ('DiffTransform', 1),\n    ('DiffTransform', 12)\n  ]\n)\n)\n```", "```py\nfrom scalecast.Pipeline import Pipeline\nfrom scalecast import GridGenerator\n\nGridGenerator.get_example_grids()\n\ntransformer, reverter = find_optimal_transformation(f)\ndef forecaster(f):\n    f.auto_Xvar_select()\n    f.tune_test_forecast(\n        ['elasticnet','xgboost'],\n        cross_validate=True,\n        limit_grid_size = .2,\n    )\n\npipeline = Pipeline(\n    steps = [\n        ('Transform',transformer),\n        ('Forecast',forecaster),\n        ('Revert',reverter),\n    ],\n)\n\nf = pipeline.fit_predict(f)\nf.plot()\nplt.title('Automated Forecasting with Transformations');\n```"]