- en: Playing with Apple Health Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/playing-with-apple-health-data-be426bcff85e](https://towardsdatascience.com/playing-with-apple-health-data-be426bcff85e)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Data Science Projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Classification and time-series forecasting on blood glucose data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@ednalyn.dedios?source=post_page-----be426bcff85e--------------------------------)[![Ednalyn
    C. De Dios](../Images/b47f52d0c1f05fcf4bc7a7df05275c93.png)](https://medium.com/@ednalyn.dedios?source=post_page-----be426bcff85e--------------------------------)[](https://towardsdatascience.com/?source=post_page-----be426bcff85e--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----be426bcff85e--------------------------------)
    [Ednalyn C. De Dios](https://medium.com/@ednalyn.dedios?source=post_page-----be426bcff85e--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----be426bcff85e--------------------------------)
    ·12 min read·Feb 27, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a211c1f0d5bf63634e544c80fad268be.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Laesa D](https://unsplash.com/@proudestpuff21?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Today, we’re going to foray into the world of Apple.
  prefs: []
  type: TYPE_NORMAL
- en: I am a diabetic and wear a continuous glucose monitor, or CGM for short. It
    records my blood sugar every few minutes and communicates the results to my phone.
    Conveniently, I can share my data with my doctor, and together, we discuss specific
    trends and patterns and make truly data-driven decisions.
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, I am interested in the data collected by the app. Since Dexcom G6
    (my CGM brand) doesn’t have a csv export function, I worked around that limitation
    by syncing the data with Apple Health. The problem is Apple Health does not allow
    the user to filter what data is exported. Consequently, the export file that is
    generated is a monolith. If you’ve had your phone for at least a year, the export
    file is so large that it’s almost impossible to open. Almost!
  prefs: []
  type: TYPE_NORMAL
- en: 'I accepted the challenge: find a way to read the file and play with it.'
  prefs: []
  type: TYPE_NORMAL
- en: Python, to the rescue!
  prefs: []
  type: TYPE_NORMAL
- en: Planning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will approach this challenge like a good ol’ data science project. First,
    we will use the [PAPEM-DM](/papem-dm-7-steps-towards-a-data-science-win-f8cac4f8e02f)
    framework to produce insightful graphics and a clean csv file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the two major obstacles:'
  prefs: []
  type: TYPE_NORMAL
- en: The file is in XML format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The file is so large that XML readers and converters online can’t even open
    it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We do not know what the schema is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And here’s our approach:'
  prefs: []
  type: TYPE_NORMAL
- en: Read the XML file into a dataframe
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Whittle down the data into just Dexcom G6 data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clean up the dataframe a little bit
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Export the dataframe into a csv
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Conduct feature engineering
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Conduct Exploratory Data Analysis (make pretty graphs)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Predict whether blood sugar is high, normal, or low
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do some time-series forecasting
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Acquisition of Apple Health Data from XML to CSV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s time to fire up a Jupyter notebook and get our data!
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s import some Python packages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Second, let’s create the element tree object [1].
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Third, let’s convert the element tree object into a dataframe. [1]
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Below, we can see the odd names on the type column.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/758fd7cc598224491fff892f7d8bf95f.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot by the Ednalyn C. De Dios
  prefs: []
  type: TYPE_NORMAL
- en: Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we go:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/84136e99240c335966449943e93c8a81.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot by the Ednalyn C. De Dios
  prefs: []
  type: TYPE_NORMAL
- en: Our dataframe is big!
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/97a26b03b92cd1be96e47fedc30d25c7.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot by the Ednalyn C. De Dios
  prefs: []
  type: TYPE_NORMAL
- en: Let’s search for what we’re after.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/40b567e639f6621352380fcfaf18b525.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot by the Ednalyn C. De Dios
  prefs: []
  type: TYPE_NORMAL
- en: Let’s filter for it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Then, let’s further whittle down the size of our dataframe by keeping only the
    necessary columns and rows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Good!
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6e56716495de8a87b79b83f6c1e85f37.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot by the Ednalyn C. De Dios
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s do a little bit of cleaning. Below, we change the data type of the
    startDate column to datetime and force the value column to be of the numeric datatype.
    Lastly, we fill the blank fields with 1 for those records that do not necessarily
    measure anything.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Finally, it’s time to export our dataframe into a csv file. Let’s name it “blood_glucose.csv.”
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Preparation of Apple Health Data from Dexcom G6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let’s get ready to do some wrangling.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s rename ‘startDate’ with ‘timestamp’ for clarity. Then, we’ll extract
    the time components and attributes from the timestamp column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We will also extract the weekday characteristic from the day of the week column
    and derive the part of the day based on the hour column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will categorize whether a record’s blood glucose is high, normal, or
    low.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the value counts, we can see a massive imbalance between the status
    categories.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/db8dae87634d36217607fd18eda4fa74.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot by the Ednalyn C. De Dios
  prefs: []
  type: TYPE_NORMAL
- en: I’ve decided to forgo the low status and create another column indicating whether
    a reading is high or not.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: And now, we’re ready to drop timestamp and status columns because we no longer
    need them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Let’s look at our dataframe now.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/45b56df0a701768b16ef933c0d7f5977.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot by the Ednalyn C. De Dios
  prefs: []
  type: TYPE_NORMAL
- en: Exploratory Data Analysis of Apple Health Data from Dexcom G6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’re about to do some visualizations, so let’s set up our figure size and layout.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Before we get too deep in the weeds, let’s check out the years we’re working
    with. Let’s do a value_counts().
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We can see, though, that the years are out of order, so let’s just manually
    create a list of the years in the correct chronological order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next comes the exciting part. Let’s make some violin plots! Below we’re defining
    a function that will create some violin plots for us based on what part of the
    day it is, the blood glucose value, and whether or not it is a weekend. Here’s
    the code to do all that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And the snippet that will make create individual violin plots based on the
    year:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/901b68082efc1a01c50590c16aa62c28.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot by the Ednalyn C. De Dios
  prefs: []
  type: TYPE_NORMAL
- en: Beautiful!
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if we want to compare all the years together? Let’s do the same thing
    again, except lay the graphs on top of each other and see what they look like.
    In the code, it translates into omitting the plt.show() line in the function.
    Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ad97819e68e6120d251b0e2b9a93b1ee.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot by the Ednalyn C. De Dios
  prefs: []
  type: TYPE_NORMAL
- en: Perfect!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s pat ourselves on the back. We managed to pack a lot of dimensions into
    one pretty graph!
  prefs: []
  type: TYPE_NORMAL
- en: Exploratory Data Analysis is a process with no one correct way to do it. So
    we’ll leave the rest of the usual suspects (distribution, average over time graphs,
    et cetera) and move on to modeling.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling — Logistic Regression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let’s drop the value column since we will use the high column as the
    target variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Since we will be doing a classification task to predict whether a reading will
    be high, let’s create dummy variables for our categorical variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s check our dataframe for class imbalance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As the above shows, there are a lot more non-highs than highs. This could lead
    to some inaccuracy with our model so we will fix that with SMOTE. A technique
    used in machine learning to address the problem of imbalanced datasets, SMOTE
    (Synthetic Minority Over-sampling Technique) works by creating synthetic data
    points for the minority class by interpolating between existing minority class
    data points. It does this by randomly selecting a minority class data point and
    finding its k-nearest neighbors. It then randomly chooses one of those neighbors
    and creates a new data point by interpolating between them.
  prefs: []
  type: TYPE_NORMAL
- en: The new data point is created by selecting a random point on the line segment
    that connects the minority data point and its chosen neighbor. This process is
    repeated until the minority class is balanced with the majority class.
  prefs: []
  type: TYPE_NORMAL
- en: The result is a balanced dataset, which allows machine learning algorithms to
    be trained more effectively. Furthermore, by creating synthetic data points, SMOTE
    ensures that the classifier is not biased towards the majority class, which can
    improve its performance on the minority class.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s the implementation of SMOTE borrowed from Susan Li’s article on Logistic
    Regression. [2]
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Next, we’ll conduct feature selection by practicing common sense and relying
    on intuition to select which columns to use to predict high blood glucose.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Then, we’ll divide our dataframe into independent and dependent variables, X
    and y.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Afterward, we’ll do a train-test-split and create a Logistic Regression object,
    which we will then fit with our data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: At long last, we’re ready to predict!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We’ll even add the confusion matrix and other metrics to evaluate the model’s
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a9a66c0646eae5f77e185e25f5e4e72b.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot by the Ednalyn C. De Dios
  prefs: []
  type: TYPE_NORMAL
- en: And since we’re doing binary classification, we will examine the ROC (Receiver
    Operating Characteristic) and AUC (Area Under the Curve).
  prefs: []
  type: TYPE_NORMAL
- en: An ROC curve is a graph that shows the trade-off between the true positive rate
    (sensitivity) and the false positive rate (1 — specificity) of a binary classifier
    as the classification threshold is varied. In other words, it shows how well the
    classifier can distinguish between positive and negative examples at different
    levels of certainty.
  prefs: []
  type: TYPE_NORMAL
- en: The ROC curve is created by plotting the true positive rate against the false
    positive rate for each possible threshold value. The AUC is the area under the
    ROC curve, which ranges from 0 to 1\. An AUC of 1 means that the classifier can
    perfectly distinguish between positive and negative examples, while an AUC of
    0.5 means that it is no better than random guessing.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/45d2e76a52c3a3222c7503cb534148e2.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot by the Ednalyn C. De Dios
  prefs: []
  type: TYPE_NORMAL
- en: In plain English, ROC AUC provides a way to measure how well a binary classifier
    can correctly distinguish between positive and negative examples, regardless of
    the threshold used. A high AUC score indicates the good performance of the classifier,
    while a low score indicates poor performance. It is a valuable tool for evaluating
    and comparing the performance of different classifiers, especially when the dataset
    is imbalanced or the cost of false positives and false negatives is different.
  prefs: []
  type: TYPE_NORMAL
- en: Time-Series Forecasting — Prophet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For our last stint, we will use Prophet for time-series forecasting. Prophet
    is a time-series forecasting tool developed by Facebook that is designed to be
    user-friendly and flexible. When using Prophet for time-series forecasting, there
    are several things to keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The data should be in a specific format: Prophet requires time-series data
    in a particular format, with a column named ‘ds’ for dates/times and a column
    named ‘y’ for the values to be predicted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Outliers should be handled: Outliers can significantly impact the accuracy
    of forecasts, so it’s essential to identify and handle them appropriately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Seasonality and trend components should be accounted for: Prophet is designed
    to capture seasonality and trend components in time-series data, so it’s essential
    to include them in the model if they exist in the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Holidays and events should be included: Prophet allows you to include holidays
    and events that may affect the time-series data, such as national holidays or
    marketing campaigns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multiple time-series can be included: Prophet can handle multiple time-series
    with different seasonalities and trends, allowing you to model and forecast them
    simultaneously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Forecast uncertainty should be considered: Prophet provides uncertainty intervals
    for its forecasts, which should be considered when making decisions based on the
    forecasts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hyperparameters should be tuned: Prophet has several hyperparameters that can
    be adjusted to improve the accuracy of forecasts, such as the number of Fourier
    terms used to capture seasonality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, Prophet can be a powerful tool for time-series forecasting, but it’s
    essential to carefully consider the data and model settings to ensure accurate
    and useful predictions. As such, we will import the csv file we saved earlier
    to focus on our dataframe before all the transformations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Next, we’ll rename the columns to ‘ds’ and ‘y’ as Prophet needs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We’ll also ensure that the ‘ds’ columns are in a datetime format. With tx_localize(None),
    we’re also removing the timezone part of the timestamp since Prophet doesn’t like
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Then, we will resample our data to account for the average of the daily readings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And we’re ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/ff189ae1f9f84abff76af831b5e956e3.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot by the Ednalyn C. De Dios
  prefs: []
  type: TYPE_NORMAL
- en: 'And for the components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/e960c3b98f1586e7e9d92ec8c557a6f4.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot by the Ednalyn C. De Dios
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve come a long way from importing Apple Health data to transforming it to
    discover insights, predict high blood sugar, and forecast blood glucose.
  prefs: []
  type: TYPE_NORMAL
- en: Along the way, we learned how to use the datetime object, make violin plots,
    balance an imbalance dataset with SMOTE, classify with logistic regression, and
    forecast with Prophet.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll play with the cleaned data and use Power BI to create a dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Stay tuned!
  prefs: []
  type: TYPE_NORMAL
- en: Thanks for stopping by and reading my post. I hope this step-by-step walkthrough
    helps you!
  prefs: []
  type: TYPE_NORMAL
- en: '*If you want to learn more about my journey from slacker to data scientist,
    check out the article below:*'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/from-slacker-to-data-scientist-b4f34aa10ea1?source=post_page-----be426bcff85e--------------------------------)
    [## From Slacker to Data Scientist'
  prefs: []
  type: TYPE_NORMAL
- en: My journey into data science without a degree.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/from-slacker-to-data-scientist-b4f34aa10ea1?source=post_page-----be426bcff85e--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: You can reach me on [Twitter](https://twitter.com/ecdedios) or [LinkedIn](https://www.linkedin.com/in/ednalyn-de-dios/).
  prefs: []
  type: TYPE_NORMAL
- en: 'References:'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] [https://www.python-engineer.com/posts/apple-health-data-python/](https://www.python-engineer.com/posts/apple-health-data-python/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[2] [https://towardsdatascience.com/building-a-logistic-regression-in-python-step-by-step-becd4d56c9c8](/building-a-logistic-regression-in-python-step-by-step-becd4d56c9c8)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
