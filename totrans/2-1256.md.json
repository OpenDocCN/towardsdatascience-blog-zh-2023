["```py\nimport pandas as pd\n\n# https://github.com/vcerqueira/blog/tree/main/data\ndata = pd.read_csv('data/wine_sales.csv', parse_dates=['date'])\ndata.set_index('date', inplace=True)\n\nseries = data['Sparkling']\n```", "```py\n# src module here: https://github.com/vcerqueira/blog/tree/main/src\nfrom src.tde import time_delay_embedding\n\n# using 3 lags as explanatory variables\nN_LAGS = 3\n# forecasting the next 2 values\nHORIZON = 2\n\n# using a sliding window method called time delay embedding\nX, Y = time_delay_embedding(series, n_lags=N_LAGS, horizon=HORIZON, return_Xy=True)\n```", "```py\nfrom sklearn.linear_model import RidgeCV\n\n# training a ridge regression model\nmodel = RidgeCV()\nmodel.fit(X, Y)\n```", "```py\nimport re\nimport pandas as pd\nimport numpy as np\n\ndef from_matrix_to_3d(df: pd.DataFrame) -> np.ndarray:\n    \"\"\"\n    Transforming a time series from matrix into 3-d structure for deep learning\n\n    :param df: (pd.DataFrame) Time series in the matrix format after embedding\n\n    :return: Reshaped time series into 3-d structure \n    \"\"\"    \n\n    cols = df.columns\n\n    # getting unique variables in the time series\n    # this list has a single element for univariate time series\n    var_names = np.unique([re.sub(r'\\([^)]*\\)', '', c) for c in cols]).tolist()\n\n    # getting observation for each variable\n    arr_by_var = [df.loc[:, cols.str.contains(v)].values for v in var_names]\n    # reshaping the data of each variable into a 3-d format\n    arr_by_var = [x.reshape(x.shape[0], x.shape[1], 1) for x in arr_by_var]\n\n    # concatenating the arrays of each variable into a single array\n    ts_arr = np.concatenate(arr_by_var, axis=2)\n\n    return ts_arr\n\n# transforming the matrices\nX_3d = from_matrix_to_3d(X)\nY_3d = from_matrix_to_3d(Y)\n```", "```py\nfrom sklearn.model_selection import train_test_split\n\nfrom keras.models import Sequential\nfrom keras.layers import (Dense,\n                          LSTM,\n                          TimeDistributed,\n                          RepeatVector)\n\n# number of variables in the time series\n# 1 because the series is univariate\nN_FEATURES = 1\n\n# creating a simple stacked LSTM\nmodel = Sequential()\nmodel.add(LSTM(8, activation='relu', input_shape=(N_LAGS, N_FEATURES)))\nmodel.add(RepeatVector(HORIZON))\nmodel.add(LSTM(4, activation='relu', return_sequences=True))\nmodel.add(TimeDistributed(Dense(N_FEATURES)))\n\nmodel.compile(optimizer='adam', loss='mse')\n\n# compiling the model\nmodel.compile(optimizer='adam', loss='mse')\n\n# basic train/validation split \nX_train, X_valid, Y_train, Y_valid = train_test_split(X_3d, Y_3d, test_size=.2, shuffle=False)\n\n# training the model\nmodel.fit(X_train, Y_train, epochs=100, validation_data=(X_valid, Y_valid))\n\n# making predictions\npreds = model.predict_on_batch(X_valid)\n```", "```py\n# transforming each variable into a matrix format\nmat_by_variable = []\nfor col in data:\n    col_df = time_delay_embedding(data[col], n_lags=N_LAGS, horizon=HORIZON)\n    mat_by_variable.append(col_df)\n\n# concatenating all variables\nmat_df = pd.concat(mat_by_variable, axis=1).dropna()\n\n# defining target (Y) and explanatory variables (X)\npredictor_variables = mat_df.columns.str.contains('\\(t\\-|\\(t\\)')\ntarget_variables = mat_df.columns.str.contains('\\(t\\+')\nX = mat_df.iloc[:, predictor_variables]\nY = mat_df.iloc[:, target_variables]\n```", "```py\nX_3d = from_matrix_to_3d(X)\nY_3d = from_matrix_to_3d(Y)\n```", "```py\nmodel = Sequential()\nmodel.add(LSTM(8, activation='relu', input_shape=(N_LAGS, N_FEATURES)))\nmodel.add(Dropout(.2))\nmodel.add(RepeatVector(HORIZON))\nmodel.add(LSTM(4, activation='relu', return_sequences=True))\nmodel.add(Dropout(.2))\nmodel.add(TimeDistributed(Dense(N_FEATURES)))\n\nmodel.compile(optimizer='adam', loss='mse')\n\nX_train, X_valid, Y_train, Y_valid = train_test_split(X_3d, Y_3d, test_size=.2, shuffle=False)\n\nmodel.fit(X_train, Y_train, epochs=500, validation_data=(X_valid, Y_valid))\n\npreds = model.predict_on_batch(X_valid)\n```"]