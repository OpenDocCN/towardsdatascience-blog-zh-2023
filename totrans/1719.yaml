- en: 5 Python Decorators I Use in Almost All My Data Science Projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/python-decorators-for-data-science-6913f717669a](https://towardsdatascience.com/python-decorators-for-data-science-6913f717669a)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Decorators provide a new and convenient way for everything from caching to sending
    notifications.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://thuwarakesh.medium.com/?source=post_page-----6913f717669a--------------------------------)[![Thuwarakesh
    Murallie](../Images/44f1a14a899426592bbd8c7f73ce169d.png)](https://thuwarakesh.medium.com/?source=post_page-----6913f717669a--------------------------------)[](https://towardsdatascience.com/?source=post_page-----6913f717669a--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----6913f717669a--------------------------------)
    [Thuwarakesh Murallie](https://thuwarakesh.medium.com/?source=post_page-----6913f717669a--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----6913f717669a--------------------------------)
    ·6 min read·Mar 13, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/fc0bc39e9f13f04a39005e4e7610a8fe.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Elena Mozhvilo](https://unsplash.com/@miracleday?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: At first, every developer’s goal is to get things working. Slowly, we worry
    about readability and scalability. This is when we first start thinking about
    decorators.
  prefs: []
  type: TYPE_NORMAL
- en: Decorators are an excellent way to give additional behavior to a function. And
    there are little things we data scientists often need to inject into a function
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: With decorators, you’d be surprised to see how much you can reduce code repetition
    and improve readability. I certainly did.
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://levelup.gitconnected.com/streamlit-openai-gpt3-example-app-b333da955ceb?source=post_page-----6913f717669a--------------------------------)
    [## Create GPT3 Powered Apps in Minutes With Streamlit'
  prefs: []
  type: TYPE_NORMAL
- en: Learn to build intelligent apps without worrying too much about software development.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: levelup.gitconnected.com](https://levelup.gitconnected.com/streamlit-openai-gpt3-example-app-b333da955ceb?source=post_page-----6913f717669a--------------------------------)
    [](/etl-github-actions-cron-383f618704b6?source=post_page-----6913f717669a--------------------------------)
    [## How to Build Simple ETL Pipelines With GitHub Actions
  prefs: []
  type: TYPE_NORMAL
- en: ETLs don’t have to be complex. If that’s the case, use GitHub Actions.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/etl-github-actions-cron-383f618704b6?source=post_page-----6913f717669a--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Here are the five most common ones I use in almost every data-intensive project.
  prefs: []
  type: TYPE_NORMAL
- en: 1\. The retry decorator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In data science projects and software development projects, there are so many
    instances where we depend on external systems. Things are not in our control all
    the time.
  prefs: []
  type: TYPE_NORMAL
- en: '[](/3-important-sql-optimization-technique-d6da3e9c8442?source=post_page-----6913f717669a--------------------------------)
    [## 3 SQL Optimization Techniques That Can Instantly Boost Query Speed'
  prefs: []
  type: TYPE_NORMAL
- en: Simple hacks to try before moving to a different data model altogether
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/3-important-sql-optimization-technique-d6da3e9c8442?source=post_page-----6913f717669a--------------------------------)
    [](https://levelup.gitconnected.com/3-ways-of-web-scraping-in-python-e953c4a96ec2?source=post_page-----6913f717669a--------------------------------)
    [## The Serene Symphony of Python Web Scraping — in 3 Movements
  prefs: []
  type: TYPE_NORMAL
- en: The easiest, the most flexible, and the most comprehensive ways to do web scraping
    in Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: levelup.gitconnected.com](https://levelup.gitconnected.com/3-ways-of-web-scraping-in-python-e953c4a96ec2?source=post_page-----6913f717669a--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: When an unexpected event occurs, we might want our code to wait a while, allowing
    the external system to correct itself and rerun.
  prefs: []
  type: TYPE_NORMAL
- en: I prefer to implement this retry logic inside a python decorator so that I can
    annotate any function to apply the retry behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s the code for a retry decorator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, we try to get an API response. If it fails, we retry the
    same task 5 times. Between each retry, we wait for 2 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Caching function results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some parts of our codebase rarely change their behaviors. Yet, it may take a
    big chunk of our computation power. In such situations, we can use a decorator
    to cache function calls.
  prefs: []
  type: TYPE_NORMAL
- en: '[](/poetry-to-complement-virtualenv-44088cc78fd1?source=post_page-----6913f717669a--------------------------------)
    [## You Are Not Still Using Virtualenv, Are You?'
  prefs: []
  type: TYPE_NORMAL
- en: There is a better way to manage dependencies, package, and publish Python projects.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/poetry-to-complement-virtualenv-44088cc78fd1?source=post_page-----6913f717669a--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: The function will run only once if the inputs are the same. In every subsequent
    run, the results will be pulled from the cache. Hence, we don’t have to perform
    expensive computations all the time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The decorator uses a dictionary, stores the function args, and returns values.
    When we execute this function, the decorated will check the dictionary for prior
    results. The actual function is called only when there’s no stored value before.
  prefs: []
  type: TYPE_NORMAL
- en: The following is a Fibonacci number calculating a function. Since this is a
    recurrent function, the same function called is performed multiple times. But
    with caching, we can speed up this process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here are the execution times for this function with and without caching. Note
    that the cached version only takes a faction of a millisecond to run, whereas
    the non-cached version almost took a minute.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Using a dictionary to hold previous execution data is a straightforward approach.
    However, there is a more sophisticated way to store caching data. You can use
    an in-memory database, such as Redis.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Timing functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This one is no surprise. When working with data-intensive functions, we’re eager
    to learn how long it takes to run.
  prefs: []
  type: TYPE_NORMAL
- en: The usual way of doing this is by collecting two timestamps, one at the beginning
    and another at the end of the function. We can then compute the duration and print
    it along with the return values.
  prefs: []
  type: TYPE_NORMAL
- en: But doing this again and again for multiple functions is a hassle.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we can have a decorator do it. We can annotate any function that needs
    a duration printed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example Python decorator that prints the running time of a function
    when it’s called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use this decorator to time the execution of a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Calling the function would print the time it takes to run.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 4\. Logging function calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This one is very much an extension of the previous decorator. But it has some
    particular uses.
  prefs: []
  type: TYPE_NORMAL
- en: If you follow software design principles, you’d appreciate the single responsibility
    principle. This essentially means each function will have its one and only one
    responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: '[](/plotly-dashboards-in-python-28a3bb83702c?source=post_page-----6913f717669a--------------------------------)
    [## This is How I Create Dazzling Dashboards Purely in Python.'
  prefs: []
  type: TYPE_NORMAL
- en: Plotly dash apps are the fastest way to build production-grade dashboards in
    python.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/plotly-dashboards-in-python-28a3bb83702c?source=post_page-----6913f717669a--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: When you design your code in such a way, you’d also want to log the execution
    information of your functions. This is where logging decorators come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: The following example illustrates this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The above code is a simplified version of an ETL pipeline. We have three separate
    functions to handle each extract, transform, and load. We have wrapped each of
    them using our `log_execution` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, whenever the code is executed, you’d see an output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We could also have the execution time printed inside this decorator. But I’d
    love to have them both in separate decorators. That way, I can choose which one
    (or both) to use for a function.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s how to use multiple decorators on a single function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 5\. Notification decorator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, a very useful decorator in production systems is the notification decorator.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, even with several retries, even a well-tested codebase fails. And
    when that happens, we need to inform someone about it to take quick action.
  prefs: []
  type: TYPE_NORMAL
- en: This isn’t new if you’ve ever built a data pipeline and hoped it would work
    fine forever.
  prefs: []
  type: TYPE_NORMAL
- en: The following decorator sends an email whenever the execution of the inner function
    fails. It doesn’t have to be an email notification in your case. You can configure
    it to send a Teams/slack notification.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Decorators are a very convenient way to apply new behavior to our functions.
    Without them, there will be a lot of code repetition.
  prefs: []
  type: TYPE_NORMAL
- en: In this post, I’ve discussed my most frequently used decorators. You can extend
    these for your specific needs. For instance, you can use a Redis server to store
    cache responses instead of dictionaries. This will give you more control over
    the data, such as persistence. Or you could tweak the code to increase the waiting
    time in the retry decorator progressively.
  prefs: []
  type: TYPE_NORMAL
- en: In all of my projects, I use some version of these decorators. Though their
    behavior differs slightly, these are the common goals I frequently use decorators
    for.
  prefs: []
  type: TYPE_NORMAL
- en: I hope this post helps you.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks for reading, friend! If you enjoyed my article, let’s keep in touch on
    [**LinkedIn**](https://www.linkedin.com/in/thuwarakesh/), [**Twitter**](https://twitter.com/Thuwarakesh),
    and [**Medium**](https://thuwarakesh.medium.com/).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Not a Medium member yet? Please use this link to [**become a member**](https://thuwarakesh.medium.com/membership)
    because, at no extra cost for you, I earn a small commission for referring you.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
