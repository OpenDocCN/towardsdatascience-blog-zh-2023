["```py\n# Convert to DateTime\ndf['date'] = pd.to_datetime(df['date'])\n\n# Make some features from date\ndf['day'] = df['date'].dt.day\ndf['week'] = df['date'].dt.week\ndf['month'] = df['date'].dt.month\ndf['year'] = df['date'].dt.year\n# etc.\n```", "```py\ndf['dayofweek'] = df['date'].dt.dayofweek\ndf['weekend'] = (df['dayofweek']>=5)\n# etc.\n```", "```py\nFEATURE = 'price'\nLEVEL_1 = 'store_id'\nLEVEL_N = 'item_id'\n\n# Basic aggregations\ndf[f'{FEATURE}_max'] = df.groupby([LEVEL_1, LEVEL_N])[FEATURE].transform('max')\ndf[f'{FEATURE}_min'] = df.groupby([LEVEL_1, LEVEL_N])[FEATURE].transform('min')\ndf[f'{FEATURE}_std'] = df.groupby([LEVEL_1, LEVEL_N])[FEATURE].transform('std')\ndf[f'{FEATURE}_mean'] = df.groupby([LEVEL_1, LEVEL_N])[FEATURE].transform('mean')\n\n# Normalization (min/max scaling)\ndf[f'{FEATURE}_norm'] = df[FEATURE]/df[f'{FEATURE}_max']\n\n# Some items are can be inflation dependent and some items are very \"stable\"\ndf[f'{FEATURE}_nunique'] = df.groupby([LEVEL_1, LEVEL_N])[FEATURE].transform('nunique')\n\n# Feature \"momentum\" \ndf[f'{FEATURE}_momentum'] = df[FEATURE]/df.groupby([LEVEL_1, LEVEL_N])[FEATURE].transform(lambda x: x.shift(1))\n```", "```py\nLEVEL = 'store_id'\nTARGET = 'sales'\nlag = 7\n\ndf[f\"lag_{lag}\"] = df.groupby(LEVEL)[TARGET].shift(lag).fillna(0)\n```", "```py\nwindow = 28\n\ndf[f\"rolling_mean_{window}\"] = df.groupby(LEVEL)[FEATURE].transform(lambda x : x.rolling(window).mean()).fillna(0)\n```", "```py\nfrom datetime import datetime, timedelta\nimport lightgbm as lgb\n\nN_FOLDS = 4\nVALIDATION_PERIOD = 7\n\nfor store_id in STORES_IDS:\n  for fold in range(N_FOLDS):\n      training_date = train_df['timestamp'].max() - timedelta(VALIDATION_PERIOD) * (N_FOLDS-fold)\n      valid_date = training_date + timedelta(VALIDATION_PERIOD)\n      print(f\"\\nFold {fold}: \\ntraining data from {train_df['timestamp'].min()} to {training_date}\\nvalidation data from {training_date + timedelta(1)} to {valid_date}\")\n      train = train_df[train_df['timestamp'] <= training_date]\n      val  = train_df[(train_df['timestamp'] > training_date) & (train_df['timestamp'] <= valid_date) ]\n\n      X_train = train[features]\n      y_train = train[target]\n\n      X_val = val[features]\n      y_val = val[target]\n\n      train_data = lgb.Dataset(X_train, label = y_train)\n      valid_data = lgb.Dataset(X_val, label = y_val)\n\n      estimator = lgb.train(lgb_params,\n                                train_data,\n                                valid_sets = [valid_data],\n                                verbose_eval = 100,\n                                )Mo\n```"]