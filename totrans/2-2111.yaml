- en: Time Series Transformations (and Reverting) Made Easy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/time-series-transformations-and-reverting-made-easy-f4f768c18f63](https://towardsdatascience.com/time-series-transformations-and-reverting-made-easy-f4f768c18f63)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exploring transformations for time series and how to revert them with scalecast
    in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://mikekeith52.medium.com/?source=post_page-----f4f768c18f63--------------------------------)[![Michael
    Keith](../Images/4ebd39b25a1faae3586eb25ec83d3e91.png)](https://mikekeith52.medium.com/?source=post_page-----f4f768c18f63--------------------------------)[](https://towardsdatascience.com/?source=post_page-----f4f768c18f63--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----f4f768c18f63--------------------------------)
    [Michael Keith](https://mikekeith52.medium.com/?source=post_page-----f4f768c18f63--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----f4f768c18f63--------------------------------)
    ·5 min read·Jan 26, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6ce1d41146609f8ca174df859a6cde91.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: When forecasting time series data, stationarity is an important factor to consider.
    Some models — ARIMA, Holt-Winters, Exponential Smoothing, and others — are specialized
    for time series and do not necessarily require stationary data. A series’ stationarity
    refers to its tendency to return to its mean value over time. A non-stationary
    series introduces a trend into a dataset that can lead to functions that rely
    on that trend too heavily, leading to spurious results (results that appear deceptively
    good).
  prefs: []
  type: TYPE_NORMAL
- en: Exponential smoothing models smooth out recent trends to account for non-stationarity
    and ARIMA will difference data when the factor for integration (the middle term
    in a standard ARIMA order) is set to above 0\. Other time-series models deal with
    stationarity in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: However, a popular machine learning model like XGBoost has no regards for a
    series’ stationarity because it was not developed to consider the quirks of time
    series data. That doesn’t necessarily mean you shouldn’t forecast with it, but
    before doing so, it is a good idea to deal with potential non-stationarity. This
    usually means applying a transformation — manipulating the raw values in some
    way — to strip out trends and to otherwise make it more ideal for the model to
    predict on. Some are hesitant to take transformations because it adds another
    step to data preparation and makes reverting results, so that the forecasts produce
    usable information, difficult. But that doesn’t have to be the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Today I will overview how transforming, forecasting, and reverting a time series
    can easily be performed in Python. The following installation is necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Basic Syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The syntax for applying transformations using the scalecast package is simple.
    First, we import the necessary packages and extract the time series data. I’m
    using the airlines dataset, available on [Kaggle](https://www.kaggle.com/rakannimer/air-passengers)
    with an Open Database license.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we create a Forecaster object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the Forecaster object to feed a SeriesTransformer object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s it. Now, many different transformations, including custom transformations,
    are available for you. These include first differencing, second differencing and
    beyond, seasonal differencing, linear detrending, polynomial detrending, logarithmic
    detrending, scaling, boxcox transformations, and more. All transformations are
    stackable and fully revertible. For instance, if I want to apply a seasonal difference
    and then detrend my series, I can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/85473e41c82b55e1c674b2a2fceb758c.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll then call a forecast model using XGBoost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/27f705adb8533953294b6c60fbafcdf4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To revert the applied transformations, I call the revert functions in the opposite
    order as their transforming counterparts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/d7f3742153c3de24c748b816823e70aa.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Auto-Transforming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With so many transformation options, wouldn’t it be nice to get a custom recommendation
    based on what might maximize forecast accuracy for a given series? That is also
    possible with scalecast ([doc](https://scalecast.readthedocs.io/en/latest/Forecaster/Util.html#find-optimal-transformation)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This function loops through many possible transformations in a given order
    and returns the set of transformations it believes creates the best chance for
    accurate forecasts, monitoring an out-of-sample metric to make that determination.
    We can see from the output that it chose a boxcox transformation followed by a
    first difference and a first seasonal difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The returned objects can then be fed into a pipeline where other auto-ML methods
    are applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/672bc6e8d6e4adf694dd74dc72910715.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: The resulting code is easy-to-read and easy-to-maintain. Much more customization
    is available or the automatic approach can be used with normally good results.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today, I overviewed transformations for time series in Python using scalecast.
    The approach was extended to incorporate auto-ML techniques and the transformations,
    as well as the corresponding revert functions, were placed in a pipeline for a
    streamlined application. Thank you for following along! Be sure to give [scalecast](https://github.com/mikekeith52/scalecast)
    a star on GitHub. Here is the complete [code](https://github.com/mikekeith52/scalecast-examples/blob/main/transforming/medium_code.ipynb)
    used in this publication.
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://github.com/mikekeith52/scalecast?source=post_page-----f4f768c18f63--------------------------------)
    [## GitHub - mikekeith52/scalecast: The practitioner''s forecasting library'
  prefs: []
  type: TYPE_NORMAL
- en: Scalecast is a light-weight time-series forecasting procedure, wrapper, and
    results container built by and for applied…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: github.com](https://github.com/mikekeith52/scalecast?source=post_page-----f4f768c18f63--------------------------------)
  prefs: []
  type: TYPE_NORMAL
