["```py\nimport numpy\nimport pandas\n\nopen_rate_df = pd.read_csv(\"open_rate.csv\").set_index(\"Customer_ID\")\nclick_rate_df = pd.read_csv(\"click_rate.csv\").set_index(\"Customer_ID\")\nfatigue_rate_df = pd.read_csv(\"fatigue_rate.csv\").set_index(\"Customer_ID\")\n```", "```py\nK = 1000\nw0 = 1\nwc = 1\nT = 0.1\nE = 2\n```", "```py\ndef initialize_population(num_candidates):\n    all_candidates = []\n    for i in range(num_candidates):\n\n        # Create random decision variables such that only 1 email is delivered to a person per day\n        base = np.random.choice([-1,0,1,2], size=(K,5), p=[0.95, 0.05/3, 0.05/3, 0.05/3]).tolist()\n        data = []\n        for k in range(K):\n            vals = []\n            for t in base[k]:\n                if t == -1:\n                    vals.extend([0,0,0])\n                elif t == 0:\n                    vals.extend([1,0,0])\n                elif t == 1:\n                    vals.extend([0,1,0])\n                elif t == 2:\n                    vals.extend([0,0,1])\n\n            data.append(vals)\n\n        all_candidates.append(\n            pd.DataFrame(\n                data = np.array(data),\n                index = customer_ids,\n                columns = timeslots\n            )\n        )\n    return all_candidates\n```", "```py\ndef fitness_function(candidate_df):\n    obj = ((w0 * open_rate_df + wc * click_rate_df) * candidate_df).values.sum()\n    const1 = ((fatigue_rate_df * candidate_df).sum(axis=1) > T).sum() == 0\n    const2 = (candidate_df.sum(axis=1) > E).sum() == 0\n    return obj, const1, const2\n\ndef evaluate_fitness(x):\n    score, const1, const2 = fitness_function(x)\n    if const1 and const2: return score\n    else: return -1\n```", "```py\ndef print_candidate_metrics(candidate):\n    open_rates = (open_rate_df * candidate).values.flatten()\n    open_rate = round(open_rates[open_rates > 0].mean() * 100, 1)\n    expected_opens = round(open_rates[open_rates > 0].sum(), 1)\n    print(f\"Open Rate = {open_rate}%\")\n    print(f\"Expected number of opens = {expected_opens}\")\n\n    click_rates = (click_rate_df * candidate).values.flatten()\n    click_rate = round(click_rates[click_rates > 0].mean() * 100, 1)\n    expected_clicks = round(click_rates[click_rates > 0].sum(), 1)\n    print(f\"Click Rate = {click_rate}%\")\n    print(f\"Expected number of clicks = {expected_clicks}\")\n\n    fatigue_rates = (fatigue_rate_df * candidate).values.flatten()\n    fatigue_rate = round(fatigue_rates[fatigue_rates > 0].mean() * 100, 1)\n    print(f\"Fatigue Rate = {fatigue_rate}%\")\n```", "```py\ninitial_candidates = initialize_population(3)\nfor i in initial_candidates:\n    print_candidate_metrics(i)\n    print()\n```", "```py\ndef crossover(candidate1, candidate2):\n    crossover_point = random.randint(1,K-1)\n    child1 = pd.concat([candidate1.iloc[:crossover_point,:], candidate2.iloc[crossover_point:,:]])\n    child2 = pd.concat([candidate1.iloc[:crossover_point], candidate2.iloc[crossover_point:]])\n    return child1, child2\n```", "```py\ndef mutate(candidate):\n    mutation_point = random.randint(0,14)\n    new_candidate = candidate.copy()\n    new_candidate.iloc[:,mutation_point] = np.random.choice([0, 1], size=K, p=[.99, .01])\n    return new_candidate\n```", "```py\ngenerations = 100\npopulation_size = 50\ncrossover_rate = 0.8\nmutation_rate = 0.2\nelitism_size = 2\n```", "```py\ndef optimal_schedule():\n\n    # Create initial candidates\n    population = initialize_population(population_size)\n\n    for generation in range(generations):\n        new_population = []\n\n        # Elitism\n        population.sort(key=lambda x: evaluate_fitness(x), reverse=True)\n        new_population.extend(population[:elitism_size])\n\n        while len(new_population) < population_size:\n            parent1, parent2 = random.choices(population, k=2)\n            if random.random() < crossover_rate:\n                child1, child2 = crossover(parent1, parent2)\n            else:\n                child1, child2 = parent1.copy(), parent2.copy()\n\n            if random.random() < mutation_rate:\n                child1 = mutate(child1)\n            if random.random() < mutation_rate:\n                child2 = mutate(child2)\n\n            new_population.extend([child1, child2])\n\n        population = new_population\n\n    return population[0]\n```", "```py\nresult = optimal_schedule()\nprint_candidate_metrics(result)\n```"]