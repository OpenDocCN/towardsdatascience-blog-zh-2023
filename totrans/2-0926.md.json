["```py\n%matplotlib qt\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# We start by defininf helper functions\n# one to pretify an axes\ndef pretty_ax(ax, b: float=8):\n    \"\"\"Prettify an Axes for plotting complex numbers: \n        - Add labels\n        - Set aspect to 'equal'\n        - Add grid\n        - Add unit circle with canonical vectors\n        - Set custom value for boundaries of axes\n    \"\"\"\n    ax.set_aspect('equal')\n    ax.set_xlabel(\"Real\", color=\"gray\")\n    ax.set_ylabel(\"Imag\", color=\"gray\")\n    ax.xaxis.set_label_coords(0.5,0.05)\n    ax.yaxis.set_label_coords(0.05,0.5)\n\n    ax.grid(ls='--')\n    c = plt.Circle((0,0), 1, ls='--', facecolor=None, edgecolor=\"gray\", fill=False)\n    ax.add_patch(c)\n    ax.set_xlim(-b, b)\n    ax.set_ylim(-b, b)\n    plot_vector(1, ax, color=\"gray\")\n    plot_vector(1j, ax, color=\"gray\")\n\n# one to plot complex numbers to a 2D ax\ndef plot_vector(\n        Z, ax, \n        color=None, decomp=False, txt=False, \n        orig=0+0J, ls=None, alpha=1, \n        arrowstyle=None, width=None, \n        headwidth=None, frac=None\n    ):\n    \"\"\"Plot a complex number as vector.\n\n    \"\"\"\n    x = Z.real\n    y = Z.imag\n\n    arrow_props = dict(\n        color=color,\n        ls=ls,\n        edgecolor=None,\n        alpha=alpha,\n    )\n    if arrowstyle is None:\n        if width is not None:\n            arrow_props[\"width\"] = width   # width of the arrow in points\n        if headwidth is not None:\n            arrow_props[\"headwidth\"] = headwidth   #  width of the base of the arrow head in points\n        arrow_props['shrink'] = 0.0 # move the tip and base some percent away from the annotated point and text\n        if frac is not None:\n            arrow_props['frac'] = frac  # fraction of the arrow length occupied by the head\n    else:\n        arrow_props['arrowstyle'] = arrowstyle\n\n    ann = ax.annotate(\"\", \n                    xy=((Z+orig).real, (Z+orig).imag),\n                    xytext=(orig.real, orig.imag),\n                    arrowprops=arrow_props,\n                    annotation_clip=False)\n    ann.arrow_patch.set_clip_box(ax.bbox)\n    if decomp:\n        ann = ax.annotate('', xy=(x, 0), xytext=(orig.real, orig.imag), arrowprops=dict(arrowstyle=\"->\", color=color), annotation_clip=False)\n        ann.arrow_patch.set_clip_box(ax.bbox)\n        ann = ax.annotate('', xy=(x, y), xytext=(x,0), arrowprops=dict(arrowstyle=\"->\", color=color), annotation_clip=False)\n        ann.arrow_patch.set_clip_box(ax.bbox)\n    if txt:\n        ax.text(x/2, y/2, f'Z={Z}', ha='center', va='bottom', rotation=np.angle(Z)*180/np.pi, color=color)\n\nfig, ax = plt.subplots()\n# prettify the ax for plotting complex numbers\npretty_ax(ax)\n\n# define 2 complex numbers\nZ1 = 5 + 3J\nZ2 = 1 + 6J\n\nplot_vector(Z1, ax, color=\"red\", txt=True)  # plot Z1\nplot_vector(Z2, ax, color=\"blue\", txt=True) # plot Z2\nplot_vector(Z2, ax, orig=Z1, color=\"blue\")  # plot Z2 at the end of Z1\nplot_vector(Z1+Z2, ax, txt=True, color=\"green\") # plot Z1+Z2\n```", "```py\nZ = 1+3J\n\nreal = Z.real\nimag = Z.imag\nmod = np.abs(Z)\nangle = np.angle(Z)\n\nprint(Z.real, Z.imag, mod, angle)\n# check that both representation are equivalent\nprint(real+imag*1J == mod * np.exp(1J*angle))\n```", "```py\n1.0 3.0 3.1622776601683795 1.2490457723982544\nTrue\n```", "```py\nfig, axes = plt.subplots(1, 2, sharex=True, sharey=True)\npretty_ax(axes[0])\npretty_ax(axes[1])\n\n# define 2 complex numbers\nZ1 = 2.5 + 2J\nZ2 = 0.5 + 1.5J\n\n# compute their sum\nZ_sum = Z1 + Z2\nplot_vector(Z1, axes[0], color=\"red\")            # plot Z1 alone\nplot_vector(Z2, axes[0], orig=Z1, color=\"blue\")   # plot Z2 after Z1\nplot_vector(Z_sum, axes[0], color=\"green\")         # plot their sum\naxes[0].set_title('Sum of 2 complex numbers')\n\n# same for the mean\nZ_mean = np.mean([Z1, Z2])\nplot_vector(Z1, axes[1], color=\"red\")    # plot Z1 alone\nplot_vector(Z2, axes[1], color=\"blue\")    # plot Z2 alone\nplot_vector(Z_mean, axes[1], color=\"green\")# plot their mean\naxes[1].set_title('Mean of 2 complex numbers')\n```", "```py\nfrom matplotlib.cm import viridis\n\nN = 10\ncolors = viridis(np.linspace(0, 1, N))\n\nx_n = np.sin(np.linspace(0, 3, N)) +0.2\nns = np.arange(0, N)\n\nk = 1\nZ_ks = x_n * np.exp(-2*1J*np.pi*k*ns/N)\n\nfig, axes = plt.subplots(1, 2)\naxes[0].scatter(ns, x_n, marker='o', c=colors)\naxes[0].set_title('Input sequence, \\neach sample has a specific color')\nfor i, x in enumerate(x_n):\n    _Zx = 1J * x\n    plot_vector(_Zx, axes[0], arrowstyle=\"->\", ls='--', color=colors[i], orig=i)\n\npretty_ax(axes[1], b=2)\n\ndef plot_sum_vector(Z_ks, ax, colors=colors):\n    cumsum = 0\n    for Zk, color in zip(Z_ks, colors):\n        plot_vector(Zk, ax=ax, color=color, arrowstyle='->', ls='--')\n        plot_vector(Zk, orig=cumsum, ax=ax, color=color)\n        cumsum += Zk\n    plot_vector(cumsum, ax=ax, color=\"red\", alpha=0.5)\n\nplot_sum_vector(Z_ks, axes[1])\naxes[1].set_title('Fourier coefficient X[k=1]')\n\nfig.tight_layout()\n```", "```py\nfig, axes = plt.subplots(2, 5, figsize=(17,9), sharex=True, sharey=True)\n#fig.subplots_adjust(top=0.95, bottom=0.3, left=0.05, right=0.95)\n#ax_X = fig.add_axes([0.17, 0.05, 0.7, 0.2])\nks = np.arange(N)\nX_ks = []\nfor k, ax in zip(ks, axes.flat):\n    Z_ks = x_n * np.exp(-2*1J*np.pi*k*ns/N)\n\n    pretty_ax(ax, b=6)\n    plot_sum_vector(Z_ks, ax)\n    ax.set_title(f'k={k}')\n    # store the average all of the Zks for that value of k : this IS the fourier\n    # coefficient for index k\n    X_ks.append(Z_ks.mean())\n\nX_ks = np.array(X_ks)\nfig.tight_layout()\n\n# Finaly, we can check that the Fourier-coefficients we computed are identical \n# to those computed by numpy. We use norm='forward' so numpy uses the 1/N scale\n# convention.\nassert np.allclose(X_ks, np.fft.fft(x_n, norm='forward'))\n```", "```py\nfig = plt.figure()\nax = fig.add_subplot(121, projection='3d', proj_type = 'ortho')\n\nZs = ks\nXs = X_ks.real\nYs = X_ks.imag\n\nax.plot(Xs, Ys, Zs, \"--\", color='red')\nax.scatter(Xs, Ys, Zs, '-o', color='red')#colors)\nax.set_xlabel('Real')\nax.set_ylabel('Imag')\nax.set_zlabel('k')\nax.set_title(\"Fourier coefficients X[k]\")\nax.quiver(np.zeros_like(Xs), np.zeros_like(Xs), ks,\n            Xs, Ys, np.zeros_like(Xs),\n            colors='red',#colors, \n            arrow_length_ratio = 0.3, lw=3)\nzmin, zmax = ax.get_zlim()\nax.plot([0,0], [0,0], [zmin, zmax], color=\"r\", alpha=0.5, ls=\"--\")\n\nax = fig.add_subplot(322)\nax.plot(x_n, '-o')\nax.set_title(\"Input sequence\")\n\nax = fig.add_subplot(324)\nax.plot(ks, X_ks.real, '--o', color=\"r\", label=\"real\")\nax.plot(ks, X_ks.imag, '--o', color=\"g\", label='imag')\nax.set_title('Real and imaginary parts')\nax.set_xlabel(\"k\")\nax.legend()\n\nax = fig.add_subplot(326)\nax.plot(ks, np.abs(X_ks), '--o', color=\"r\", label=\"mod\")\nax.plot(ks, np.angle(X_ks), '--o', color=\"g\", label='angle')\nax.set_title('Module and phase angle')\nax.set_xlabel(\"k\")    \nax.legend()\nfig.tight_layout()\n```"]