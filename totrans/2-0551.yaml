- en: Constraint Programming Explained
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/constraint-programming-explained-2882dc3ad9df](https://towardsdatascience.com/constraint-programming-explained-2882dc3ad9df)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/6cf518b9ff47ceb0982a963d081b8582.png)'
  prefs: []
  type: TYPE_IMG
- en: Graph coloring problem interpretation, painted by Dall-E 2.
  prefs: []
  type: TYPE_NORMAL
- en: The core of a constraint programming solver and the relationship with mixed
    integer programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://hennie-de-harder.medium.com/?source=post_page-----2882dc3ad9df--------------------------------)[![Hennie
    de Harder](../Images/3e4f2cccd6cb976ca3f8bf15597daea8.png)](https://hennie-de-harder.medium.com/?source=post_page-----2882dc3ad9df--------------------------------)[](https://towardsdatascience.com/?source=post_page-----2882dc3ad9df--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----2882dc3ad9df--------------------------------)
    [Hennie de Harder](https://hennie-de-harder.medium.com/?source=post_page-----2882dc3ad9df--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----2882dc3ad9df--------------------------------)
    ·9 min read·Jan 12, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '**There are many different ways to define and solve optimization problems.
    You can e.g. use greedy algorithms, constraint programming, mixed integer programming,
    genetic algorithms or local search. In this post, we are diving in to constraint
    programming. As example, the graph coloring problem is used to illustrate how
    constraint programming works.**'
  prefs: []
  type: TYPE_NORMAL
- en: If you need an introduction to optimization problems and search heuristics,
    you can read the post below.
  prefs: []
  type: TYPE_NORMAL
- en: '[](/mathematical-optimization-heuristics-every-data-scientist-should-know-b26de0bd43e6?source=post_page-----2882dc3ad9df--------------------------------)
    [## Mathematical Optimization Heuristics Every Data Scientist Should Know'
  prefs: []
  type: TYPE_NORMAL
- en: Local search, genetic algorithms and more.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/mathematical-optimization-heuristics-every-data-scientist-should-know-b26de0bd43e6?source=post_page-----2882dc3ad9df--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Graph Coloring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s start with the graph coloring problem. This problem is used throughout
    the post to illustrate concepts of constraint programming.
  prefs: []
  type: TYPE_NORMAL
- en: For a given map, you want to color every country. You have an unlimited amount
    of colors. It is not allowed to give adjacent countries the same color. What’s
    the lowest amount of colors you need to fill the map?
  prefs: []
  type: TYPE_NORMAL
- en: The *variables* are the colors you give to the countries. The *constraint* is
    that it’s not allowed to give adjacent countries the same color. The *objective*
    is to minimize the number of colors used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sounds easy? In practice it can be hard! Here is a part of the solution for
    Africa:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/976149c266d558818ff234d949fdc50b.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to visualize this problem is by using vertices and edges. Adjacent
    countries are connected with an edge. The vertices correspond with the countries.
    This is the previous example illustrated in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/969454a088b6c1e54cd87910ea887356.png)'
  prefs: []
  type: TYPE_IMG
- en: From the map to vertices and edges. This makes it easier to detect mistakes
    and see adjacent countries. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: What is Constraint Programming?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key idea of constraint programming (CP) is that it uses constraints to reduce
    the set of values that each variable can take. In CP, the program (or solver)
    keeps track of values that can appear. After every move, the search space is pruned.
    This means that the values that can’t happen anymore are removed. It can occur
    that there are no more possible moves while the solver hasn’t found a feasible
    solution yet. In that case, the solver starts from an earlier point where it made
    a decision and reconsiders it.
  prefs: []
  type: TYPE_NORMAL
- en: Basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The focus of CP is on feasibility, instead of optimality. After a decision,
    the solver checks for feasibility and prunes the search space. In the image below
    you can see a basic CP solver. Big parts are the search and the constraint store,
    which I will explain in detail later on. In short: search is where the decisions
    are made, and the constraint store contains all possible variable values in the
    domain store and holds the constraints. A move is made (e.g. you color a country
    red), and in the constraint store the domain store is pruned based on the move.
    There is also the feasibility check, this means that when the move is not possible
    because it violates one or more constraints, it needs to be rolled back (failure).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7b006cc84ac04ff74bcb5f08fa011a85.png)'
  prefs: []
  type: TYPE_IMG
- en: Constraint programming. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: In the example below, you can see that when you color a country red, for the
    connected countries red has to be removed from the domain store, because those
    moves are not possible anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4ddb82cf694a19cff5080a10eb4e423f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Pruning: the two adjacent countries can’t be colored red anymore. Image by
    author.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You might wonder: How can constraint programming find an optimal solution?
    Especially in the graph coloring problem, it’s easy to find a feasible solution.
    The easiest one is to give a different color to every country. That is a feasible
    solution but it is far from optimal. There are different ways to solve this. One
    example is to continuously keep solving the problem, and add a constraint that
    the new solution must use less colors than the previous one.'
  prefs: []
  type: TYPE_NORMAL
- en: Search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For searching, there are some nice rules you can follow that can drastically
    improve the search. The first one is the *first-fail principle*. This means that
    you try first where you are the most likely to fail. This makes things easier
    at the end and reduces the search tree the most. In graph coloring, it’s better
    to start with a country that’s connected to many other countries, than with a
    country that doesn’t have much connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/581ef9a9fd9489d9337bfb07902a807a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'First-fail principle: start with the country with the highest number of connections.
    Image by author.'
  prefs: []
  type: TYPE_NORMAL
- en: This helps, because it’s harder to give this country a color if you already
    colored the surrounding countries. Chances are high that when you don’t start
    with this country you have to give it a new color, which is something you want
    to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different types of searching you can implement. Depending on the
    problem, you can choose the best one (or try them all):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Variable/value labeling** With this search method, you start with the variables.
    In graph coloring, the countries are the variables and the colors are the values.
    You choose the variable (country) to assign next in a smart way. You can for example
    pick the one that has the lowest possible values. Then, you choose the value (color)
    this variable will get. Often a value is chosen that leaves as many options as
    possible to the other variables. Below an easy example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/83260385626fd0c4054ec92b2b670886.png)'
  prefs: []
  type: TYPE_IMG
- en: Example of variable/value labeling. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: '**Value/variable labeling**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another way to handle search is to start with the values. You have a color and
    you select a country to give this color. This is exactly the opposite compared
    to variable/value labeling. In the graph coloring problem, you can make sets of
    countries that can all have the same color.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Domain splitting**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With domain splitting, you don’t assign a value to a variable directly. Instead,
    you split the domain (possible values) of a variable in two or more sets. This
    is a weaker commitment than saying: this country should have this value, because
    you still have options for the country, one of the values from the set.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Symmetry breaking during search** Symmetry breaking can improve search drastically.
    You need to prevent symmetrical solutions from being explored, because this is
    a waste of time. Theoretically, symmetrical solutions are exactly the same. A
    way to start breaking symmetry in graph coloring is to fix colors for certain
    countries. Better ways to break symmetry is by ordering the variables (countries)
    or by only taking the current values (colors) and one new value (color) into account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/27c1646477ab03ff41f73e5fa68d3e8b.png)'
  prefs: []
  type: TYPE_IMG
- en: Symmetrical solutions. Different colors, but the solutions are exactly the same.
    Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: '**Randomization and restarts** It’s also possible to try different solutions
    in a random order. You just randomly pick values for variables and you check if
    the solution is feasible. If no solution is found after some time or number of
    tries, you restart the search.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The methods above are different ways to handle the search part of constraint
    programming. It’s possible to combine some of them.
  prefs: []
  type: TYPE_NORMAL
- en: Constraint store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are different types of constraints possible to implement in the constraint
    store. Constraints are used for feasibility checking and pruning of the domain
    store. The ‘normal’ constraints are, in the case of graph coloring, that a country
    that is connected to another country can’t have the same color. But there are
    other interesting constraints you can create based on the problem. The goal of
    adding constraints is to tighten the problem. If you make a tighter definition,
    the optimal solution can be found faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are different types of constraints you can add to the constraint store:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Global constraints** The most important constraints you can add are global
    constraints. Global constraints help in pruning the search space and can detect
    infeasibility earlier. A global constraint helps in conveying the problem structure
    to the solver directly. An example of a global constraint is the *alldifferent*
    constraint. This constraint means that all variables should have different values.
    In graph coloring, when four countries are all connected, they should all have
    a different color. If we only have three colors left for these countries, the
    solution is infeasible: we can roll back and report failure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/ff5908f31e376d809d4a4147b5ca3ba5.png)'
  prefs: []
  type: TYPE_IMG
- en: The countries are all connected, so they should all have a different color.
    Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: '**Redundant constraints** A redundant constraint is a constraint that doesn’t
    add value in excluding a solution. But redundant constraints are computationally
    significant, because they reduce the search space. A redundant constraint captures
    something that is not possible but not captured in a constraint. An example in
    graph coloring: the number of colors can’t exceed the number of countries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Surrogate constraints** By combining existing constraints, you get surrogate
    constraints. Surrogate constraints are helpful because they provide a more global
    view. An example is merging existing constraints or taking a linear combination
    of them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implied constraints** Another type of constraints you can add are implied
    constraints. Deriving a property from multiple existing constraints gives implied
    constraints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can be creative in creating constraints! For a certain problem, try to understand
    it completely to add useful constraints to the constraint store. This can improve
    the speed of the solver with a huge amount.
  prefs: []
  type: TYPE_NORMAL
- en: What is the relation between CP and MIP?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might have heard of mixed integer programming. This is another technique
    to model discrete optimization problems. MIP uses different ways to find the best
    solutions to a problem. Below, you can read what the similarities and differences
    are between CP and MIP.
  prefs: []
  type: TYPE_NORMAL
- en: What is mixed integer programming?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mixed integer programming (MIP) is a mathematical optimization technique that
    involves finding the optimal solution to a problem by solving a system of linear
    equations and inequalities that contain both integer and continuous variables.
    MIP focuses on optimality. To understand MIP and the math behind it properly,
    it’s important to know how linear programming and the simplex algorithm works.
    Read the article below if you want to have a refresher about those:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/a-beginners-guide-to-linear-programming-and-the-simplex-algorithm-87db017e92b4?source=post_page-----2882dc3ad9df--------------------------------)
    [## A Beginner’s Guide to Linear Programming and the Simplex Algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: Tackling a wide range of optimization problems.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/a-beginners-guide-to-linear-programming-and-the-simplex-algorithm-87db017e92b4?source=post_page-----2882dc3ad9df--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: A MIP solver relaxes constraints by allowing continuous values for the integer
    variables. This makes it possible to use the simplex algorithm. After that, other
    techniques are used to find a valid solution (integer values for integer variables).
    These techniques are out of scope for this post, but if you are interested, you
    can search for terms like branch and bound, branch and cut and cutting planes
    (e.g. Gomory cuts and polyhedral cuts).
  prefs: []
  type: TYPE_NORMAL
- en: How CP and MIP are related
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mathematically, it’s possible to formulate any MIP problem as a CP problem (or
    a CP problem as a MIP problem). So in that sense, they are the same. But because
    their ways to come to the optimal solution are different, you might want to consider
    which one is the best approach for your specific problem. MIP uses linear relaxation
    while CP uses logical inference. CP works in most cases faster for problems with
    many ‘or’ constraints, while MIP can handle ‘and’ constraints faster. If you are
    using a commercial MIP solver, they probably implemented CP techniques inside
    it, like creating high level constraints and logical reasoning. MIP is usually
    more flexible and more reliable. If you have the time, it’s always good to test
    different techniques to see what works best on your problem.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hopefully you enjoyed this introduction about constraint programming. It is
    a technique that focuses on feasibility. The constraint store and way to search
    for solutions are the key components of CP. You can improve the model formulation
    drastically if you add different types of constraints to the constraint store.
    The core of the CP solver propagates through the constraints and checks if the
    solution is still feasible and if pruning is possible. Pruning means removing
    values from the variable domains. CP solvers can find optimal solutions, if you
    give them enough time.
  prefs: []
  type: TYPE_NORMAL
- en: Mixed integer programming is another way to formulate discrete optimization
    problems. It uses algebraic techniques to find an optimal solution. Depending
    on the problem, you can choose if CP or MIP is a better fit.
  prefs: []
  type: TYPE_NORMAL
- en: Below you can find more posts about mathematical optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Related
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](/how-to-handle-optimization-problems-daf97b3c248c?source=post_page-----2882dc3ad9df--------------------------------)
    [## How to Handle Optimization Problems?'
  prefs: []
  type: TYPE_NORMAL
- en: Easy examples with solutions and code.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/how-to-handle-optimization-problems-daf97b3c248c?source=post_page-----2882dc3ad9df--------------------------------)
    [](/four-ways-to-combine-mathematical-optimization-and-machine-learning-8cb874276254?source=post_page-----2882dc3ad9df--------------------------------)
    [## Five ways to combine Mathematical Optimization and Machine Learning
  prefs: []
  type: TYPE_NORMAL
- en: Practical examples of combining two forces.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/four-ways-to-combine-mathematical-optimization-and-machine-learning-8cb874276254?source=post_page-----2882dc3ad9df--------------------------------)
    [](/why-every-data-scientist-should-learn-mathematical-optimization-3ac102663456?source=post_page-----2882dc3ad9df--------------------------------)
    [## Why Every Data Scientist Should Learn Mathematical Optimization
  prefs: []
  type: TYPE_NORMAL
- en: Data science courses are focusing on data visualization, feature engineering,
    data processing, (un)supervised learning…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/why-every-data-scientist-should-learn-mathematical-optimization-3ac102663456?source=post_page-----2882dc3ad9df--------------------------------)
  prefs: []
  type: TYPE_NORMAL
