- en: Spatial Data Engineering with Typescript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/spatial-data-engineering-with-typescript-fb5f59af8bb0](https://towardsdatascience.com/spatial-data-engineering-with-typescript-fb5f59af8bb0)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/d8b3269364c41a6de125247805d7042d.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [T K](https://unsplash.com/@realaxer?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
    on [Unsplash](https://unsplash.com/photos/9AxFJaNySB8?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
  prefs: []
  type: TYPE_NORMAL
- en: Establishing data pipelines towards automated spatial data science
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://sutan.co.uk/?source=post_page-----fb5f59af8bb0--------------------------------)[![Sutan
    Mufti](../Images/0a7922168ff75a80b2ddb38d4a142f37.png)](https://sutan.co.uk/?source=post_page-----fb5f59af8bb0--------------------------------)[](https://towardsdatascience.com/?source=post_page-----fb5f59af8bb0--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----fb5f59af8bb0--------------------------------)
    [Sutan Mufti](https://sutan.co.uk/?source=post_page-----fb5f59af8bb0--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----fb5f59af8bb0--------------------------------)
    ·9 min read·Sep 5, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can think of data as if it were water and companies as towns. Just as a town
    grows as the population grows and needs more water to serve its residents, a company,
    as it gets bigger, requires a ready to consume data to support its operations.
    Such companies require a data pipeline system that acts like the pipes and infrastructure
    that bring water to homes in a town. In our data analogy, data engineers are the
    people who build and maintain these data pipelines. It is quite straight forward
    for regular array or table like data, however, it is a bit more complicated when
    it comes to spatial data.
  prefs: []
  type: TYPE_NORMAL
- en: Spatial data is a bit different compared to regular data; it contains spatial
    attributes. These attributes allow us to establish spatial relationship; also
    known as [geospatial topology](https://en.wikipedia.org/wiki/Geospatial_topology).
    Even though two tables don’t have primary keys and foreign keys, we can still
    join them if they both have the spatial attributes. If we visualise the spatial
    attribute, we have a map!
  prefs: []
  type: TYPE_NORMAL
- en: '[](/spatial-data-science-sql-join-spatially-ecd2f7400753?source=post_page-----fb5f59af8bb0--------------------------------)
    [## Spatial Data Science: SQL Join Spatially'
  prefs: []
  type: TYPE_NORMAL
- en: 'join the tables if they have spatial relationship. Bonus: I’m doing it in Ms.
    Excel'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/spatial-data-science-sql-join-spatially-ecd2f7400753?source=post_page-----fb5f59af8bb0--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Building spatial data pipelines differs from creating ordinary data pipelines.
    In this case, we primarily handle spatial data attributes using spatial SQL, which
    is [a less common skill](https://carto.com/blog/top-insights-state-of-spatial-data-science-report)
    within the data scientist community. Once a data pipe line is built, data analysts
    can proceed in analysing the spatial data from the data pipeline. This means data
    analyst can focus on generating spatial insights without having to worry about
    data availability. This also means that maps can be generated automatically with
    the latest spatial data.
  prefs: []
  type: TYPE_NORMAL
- en: This Article
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This article discusses how to build spatial data pipelines using typescript
    and nodeJS. We can call this an [ETL](https://aws.amazon.com/what-is/etl/) (Extract,
    Transform, Load) process but with spatial data. First, we will walk through how
    we can fetch the data from the source using typescript (Extract). We will then
    transform this data into the right structure for storage (Transform). Finally,
    we will operate spatial SQL to manage and store our data into our database (Load).
  prefs: []
  type: TYPE_NORMAL
- en: The development is done with typescript & Node.js, primarily using the [node-postgres](https://node-postgres.com/)
    library. The demo code is available in the following link.
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://github.com/sutanmufti/spatial-data-engineering-typescript?source=post_page-----fb5f59af8bb0--------------------------------)
    [## GitHub - sutanmufti/spatial-data-engineering-typescript: spatial data engineering
    with typescript…'
  prefs: []
  type: TYPE_NORMAL
- en: spatial data engineering with typescript and node. Contribute to sutanmufti/spatial-data-engineering-typescript…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: github.com](https://github.com/sutanmufti/spatial-data-engineering-typescript?source=post_page-----fb5f59af8bb0--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three prerequisites: you have Node.JS with typescript, and have an
    on demand postgis server. I am using Mac OS (UNIX) for this article, but this
    article is meant for any Linux or Unix like OS for servers.'
  prefs: []
  type: TYPE_NORMAL
- en: Node.JS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Node.js is a JavaScript runtime that executes JavaScript code on the server.
    It functions similarly to Python, serving as an interpreter for JavaScript code.
    For this article, a basic understanding on Javasvript syntaxes suffices.
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://nodejs.org/en/download?source=post_page-----fb5f59af8bb0--------------------------------)
    [## Download | Node.js'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js® is a JavaScript runtime built on Chrome's V8 JavaScript engine.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: nodejs.org](https://nodejs.org/en/download?source=post_page-----fb5f59af8bb0--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Typescript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Typescript is a superset of Javascript that adds type checking feature to javascript.
    This “type checking feature” restricts coding in javascript in return of lowering
    risks of bugs. The code we develop in typescript is compiled into javascript code.
    This javascript code is then executed by Node.JS. Typescript is optional, but
    I like having type check in my projects.
  prefs: []
  type: TYPE_NORMAL
- en: '[## How to set up TypeScript'
  prefs: []
  type: TYPE_NORMAL
- en: Add TypeScript to your project, or install TypeScript globally
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: www.typescriptlang.org](https://www.typescriptlang.org/download?source=post_page-----fb5f59af8bb0--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Postgis Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You must have postgresql server running with Postgis installed. Postgis is a
    postgresql extension that allows us to handle and store geospatial data. This
    is how we can conduct spatial SQL. Of course, you must know fundamental SQL to
    operate Postgresql.
  prefs: []
  type: TYPE_NORMAL
- en: '[](/spatial-data-science-spatial-queries-8d6709fd9747?source=post_page-----fb5f59af8bb0--------------------------------)
    [## Spatial Data Science: Spatial Queries'
  prefs: []
  type: TYPE_NORMAL
- en: answering every “where” question with SQL; with example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/spatial-data-science-spatial-queries-8d6709fd9747?source=post_page-----fb5f59af8bb0--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: You can have your own postgis server with Docker or install it directly in your
    PC. Another alternative is to deploy a cloud instance such as with Amazon RDS,
    Google Cloud SQL, or a general virtual machine with postgresql installed.
  prefs: []
  type: TYPE_NORMAL
- en: '[## Docker'
  prefs: []
  type: TYPE_NORMAL
- en: Edit description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: registry.hub.docker.com](https://registry.hub.docker.com/r/postgis/postgis/?source=post_page-----fb5f59af8bb0--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: The Idea
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can break this job into several tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Extract: fetching the data from the data source. For this article, the data
    source can be anything as long as we are receiving in [GeoJSON](https://geojson.org/)
    format ([RFC7946](https://datatracker.ietf.org/doc/html/rfc7946))! In this demo
    we will take the source from [Stuart Grange](https://skgrange.github.io/data.html)’s
    data that originates from the London Government’s [data store](https://data.london.gov.uk/dataset/statistical-gis-boundary-files-london/resource/9ba8c833-6370-4b11-abdc-314aa020d5e0).
    We can retrieve other geospatial format such as shapefile but that means we must
    handle this with other libraries. For the sake of simplicity, let’s stick with
    GeoJSON.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Transform: validating the data (again, not the focus of this article) and handle
    it if it is not valid. Then, we transform the raw data into the structure that
    will be used by the data analysts; or how we design our data environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Load: inserting the data into the table. This uses spatial SQL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of the article we can see our data being stored inside our postgis
    server. Let’s get into the code.
  prefs: []
  type: TYPE_NORMAL
- en: Building The Data Pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main code is available in the following link. Let’s break down the tasks
    and walk through the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://github.com/sutanmufti/spatial-data-engineering-typescript?source=post_page-----fb5f59af8bb0--------------------------------)
    [## GitHub - sutanmufti/spatial-data-engineering-typescript: spatial data engineering
    with typescript…'
  prefs: []
  type: TYPE_NORMAL
- en: spatial data engineering with typescript and node. Contribute to sutanmufti/spatial-data-engineering-typescript…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: github.com](https://github.com/sutanmufti/spatial-data-engineering-typescript?source=post_page-----fb5f59af8bb0--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 'The [main function](https://github.com/sutanmufti/spatial-data-engineering-typescript/blob/main/src/index.ts)
    is the following code. As you can see, it mainly comprises of 2 functions: the
    `ExtractData` and the `transformAndLoad` . Additionally, there is a constant variable
    named `pool`that handles authentication for the PostGIS server.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Extract the Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This task is done by the `ExtractData()` function. We are expecting a GeoJSON
    like data with this function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this function we have an asynchronous function with name `ExtractData` .
    the `export` statement tells that this function can be imported in another typescript
    file. This makes the project modular. The `async` syntax states that this is an
    asynchronous function. This allows us to run multiple functions at the same time;
    mainly because we will use fetch API to conduct HTTP GET request to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Fetch API is an asynchronous function that is easier to be wrapped inside an
    asynchronous function. Thus we have the `await` statement to wait for the HTTP
    Get request to finish. We will have the `data` in the form of `GeoJSON` format.
  prefs: []
  type: TYPE_NORMAL
- en: I find fetch API & asynchronous function to be confusing for beginners. Furthermore
    on how asynchronous function complements Fetch API is in my other article.
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://insight.sutan.co.uk/using-fetch-api-faa44d4d9a12?source=post_page-----fb5f59af8bb0--------------------------------)
    [## Using Fetch API'
  prefs: []
  type: TYPE_NORMAL
- en: How to use Fetch in Javascript? Why does Fetch return a promise? Introducing
    asynchronous functions & promises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: insight.sutan.co.uk](https://insight.sutan.co.uk/using-fetch-api-faa44d4d9a12?source=post_page-----fb5f59af8bb0--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Transform and Load the Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After we obtain the data, we can then transform it and load the transformed
    data into postgis. We will use `node-postgres` as the client that execute SQL
    with nodeJS. I prefer `node-postgres` as I like writing raw SQL code. Furthermore,
    we have granular control over the spatial SQL. The drawback is that our code might
    look complicated as we might write rows of SQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://node-postgres.com/?source=post_page-----fb5f59af8bb0--------------------------------)
    [## node-postgres'
  prefs: []
  type: TYPE_NORMAL
- en: node-postgres is a collection of node.js modules for interfacing with your PostgreSQL
    database.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: node-postgres.com](https://node-postgres.com/?source=post_page-----fb5f59af8bb0--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: This one is a bit long. I will highlight the important parts, mainly the spatial
    SQL bit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Safe Data Transaction with Node-postgres
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The essential recipe of inserting bulk rows in PostgreSQL is the following
    part of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `client.query("BEGIN")` allows us to stage the inserting process for each
    record of the data. This means that if there is something wrong along the inserting
    process, (for instance, the data at row-n is invalid thus postgresql throws an
    error) we can cancel the data transaction as a whole. This cancelation is done
    with `client.query(‘ROLLBACK’)`. If all of the rows are inserted correctly without
    errors, then we can declare this as a safe insert and invoke `client.query("COMMIT")`
    to commit the data transaction.
  prefs: []
  type: TYPE_NORMAL
- en: If we do not begin with the `client.query("BEGIN")` , any errors that occur
    during the insertion process will result in the data being inserted into the database
    anyway. In most cases, we do not want this.
  prefs: []
  type: TYPE_NORMAL
- en: Parameterised Query
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s see what we do after we invoke `client.query("COMMIT")` . This is where
    we transform and insert our spatial data. There isn’t much to the transformation
    bit as I only extract some of the property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The most important bit is how to use parameterised query. A common SQL vulnerability
    is [SQL injection](https://www.w3schools.com/sql/sql_injection.asp#:~:text=SQL%20injection%20is%20a%20code,statements%2C%20via%20web%20page%20input.).
    Parameterised query mitigate this vulnerability by not inserting raw SQL into
    our data transaction. Look at the following SQL command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Please note the string `$1` , `$2` , `$3` , and `$4` . These are the placeholders
    for the actual values we insert. We **should not** use [template literal](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
    where we format our string. In Javascript Node-postgres, you should NOT do the
    following.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You are subjecting the database to malicious queries. For instance if the `${value}`
    value is a `DROP TABLE` command, then the function will execute the `DROP TABLE`
    command! This is not possible if we use the `$1` parameterised query.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting with Spatial SQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s see the insert statement and how I handle the spatial data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `ST_GeomFromGeoJSON` is a postgis function that takes a *stringified* geometry
    and converts it into a geometry object. For instance,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We then wrap this inside `ST_SetSRID` function to declare its projection. I
    am using the EPSG code `4326` here to indicate that this is a Latitude and Longitude
    values. You might receive data in different projections. For instance, in the
    United Kingdom, the data are often projected into British National Grid which
    has the code `27700` ; Northing and Easting. This is not the case for this demo.
  prefs: []
  type: TYPE_NORMAL
- en: Release the Connection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, we release the client to enable the server to handle another clients.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Running the Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s run the code with `npm run start` which runs `npx tsc` (this compiles
    the typescript code into javascript) and `node build` (this actually executes
    the javascript code that runs the ETL process). The log says it has succeeded.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/cbea3ca1aeb7ac9b4931717945b754db.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Executing the code (source: author, 2023)'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the data with PgAdmin or plain psql by selecting the data. Something
    like,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Using PgAdmin, we can see that the data makes sense in the map! This means the
    data analysts can now start analysing the data.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/44a8b40409f93190c41f39bef0a381ff.png)'
  prefs: []
  type: TYPE_IMG
- en: 'viewing the data (source: author, 2023)'
  prefs: []
  type: TYPE_NORMAL
- en: We can also start playing with the data in QGIS, an open source GIS software
    we can use to analyse geospatial data.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/eb70196573cf6c3160d828837f909d30.png)'
  prefs: []
  type: TYPE_IMG
- en: 'viewing the data with QGIS (source: author, 2023)'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spatial data engineering’s main idea is creating a data pipeline that draws
    the raw data from one source, treat it, and have it stored for use. This allows
    spatial data analysts to focus on analysing data without to worry about data availability;
    which is handled by the spatial data engineers. What makes spatial data engineering
    special is how we handle spatial data, that is, using spatial SQL. Using typescript
    with Node.JS, powered by `node-postgres`, we can construct a simple data pipleline.
    The data pipeline fetches geojson data, transform it, and stores the it inside
    a PostgreSQL database server with spatial data capability enabled by Postgis.
    This stored data can be then analysed using GIS software.
  prefs: []
  type: TYPE_NORMAL
