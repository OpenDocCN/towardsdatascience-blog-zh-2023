["```py\n\"\"\"\nMaking a 3d surface with hills and vallys, for demonstrative purposes\n\"\"\"\n\nimport matplotlib.pyplot as plt \nfrom matplotlib import cm\nfrom matplotlib.ticker import LinearLocator\nimport numpy as np\n\n#creating wide figure\nfig, ax = plt.subplots(subplot_kw={\"projection\": \"3d\"})\n\n# Make data.\nX = np.arange(-5, 5, 0.25)\nY = np.arange(-5, 5, 0.25)\nX, Y = np.meshgrid(X, Y)\nR = np.sqrt(X**2 + Y**2)\nZ = 0.2*np.sin(X+Y + R) - 1*np.sin(X/2)\n\n# Plot the surface.\nsurf = ax.plot_surface(X, Y, Z, cmap=cm.viridis,\n                       linewidth=0, antialiased=False)\n\nplt.show()\n```", "```py\n\"\"\"\nCalculating a simplified gradient using slopes along the X and Y direction\n\"\"\"\n\ndef computeZ(x,y):\n    \"\"\"\n    calculates any point on the surface\n    \"\"\"\n    r = np.sqrt(x**2 + y**2)\n    z = 0.2*np.sin(x+y + r) - 1*np.sin(x/2)\n\n    return z\n\ndef plot_pseudo_gradient(x,y):\n    \"\"\"\n    Calculates an approximation of the gradient using slope calculations\n    of neighboring points offset by a small dx and dy.\n    \"\"\"\n\n    #computing value at point\n    z = computeZ(x,y)\n\n    #defining some small distance to traverse \n    dx = 0.9\n    dy = 0.9\n\n    #getting the change in Z as a result of the change in X and Y\n    dzx = (computeZ(x+dx,y) - computeZ(x,y))\n    dzy = (computeZ(x,y+dy) - computeZ(x,y))\n\n    #calculating the slope along the x and y axis.\n    #these together tell you the direction of increase\n    #and the slope of the current point, so these together\n    #are the actual pseudo gradient\n    slope_x = dzx/dx\n    slope_y = dzy/dy\n\n    #to scale the vectors for visability\n    scale = 7\n\n    #calculating the value at the end of the pseudo gradient\n    #so I can draw a tangent line along the surface in the direction\n    #of the gradient\n    dz = computeZ(x+slope_x*scale,y+slope_y*scale)\n\n    xs = [x, x+slope_x* scale]\n    ys = [y, y+slope_y* scale]\n    zs = [z, z+dz]\n\n    #plotting the actual gradient\n    ax.plot([xs[0], xs[1]],\n            [ys[0],ys[1]],\n            [zs[0],zs[0]], 'b')\n\n    #plotting the tangent line\n    ax.plot(xs, ys, zs, 'r')\n\n    #plotting vector components of the tangent line\n    ax.plot([xs[0],xs[1],xs[1],xs[1]],\n            [ys[0],ys[0],ys[1],ys[1]],\n            [zs[0],zs[0],zs[0],zs[1]], '--k')\n\n    ax.scatter([x],[y],[z], marker='x', c=['k'])\n\n#creating a figure\nfig, ax = plt.subplots(subplot_kw={\"projection\": \"3d\"})\nax.computed_zorder=False #unfortunatly, zorder has pervasive bugs in 3d plots\n\n# Plot the surface.\nsurf.set_zorder(1)\nsurf = ax.plot_surface(X, Y, Z, cmap=cm.viridis, linewidth=0, antialiased=False, alpha=0.2)\nsurf.set_zorder(1)\n\n#plotting the pseudo gradient at x=0 and y=0\nplot_pseudo_gradient(0,0)\n\n#rendering\nplt.show()\n\n#for later use in traversal with the gradient\nreturn slope_x, slope_y\n```", "```py\n\"\"\"\nUsing Gradients to iteratively search for the maximum of the surface\n\"\"\"\n\n#creating a figure\nfig, ax = plt.subplots(subplot_kw={\"projection\": \"3d\"})\nax.computed_zorder=False #unfortunatly, zorder has pervasive bugs in 3d plots\n\n# Plot the surface.\nsurf.set_zorder(1)\nsurf = ax.plot_surface(X, Y, Z, cmap=cm.viridis, linewidth=0, antialiased=False, alpha=0.3)\nsurf.set_zorder(1)\n\n#iteratively following the gradient\nx,y = 0,0\nfor _ in range(10):\n    dx,dy = plot_pseudo_gradient(x,y)\n    x,y = x+dx, y+dy\n\n#rendering\nplt.show()\n\n#printing result\nprint(\"ideal parameters: x={}, y={}\".format(x,y))\n```", "```py\n\"\"\"\nreworking the previous example to find the minumum with gradient descent\n\"\"\"\n\nfig, ax = plt.subplots(subplot_kw={\"projection\": \"3d\"})\nax.computed_zorder=False\n\nsurf.set_zorder(1)\nsurf = ax.plot_surface(X, Y, Z, cmap=cm.viridis, linewidth=0, antialiased=False, alpha=0.3)\nsurf.set_zorder(1)\n\nx,y = 0,0\nfor _ in range(10):\n    dx,dy = plot_pseudo_gradient(x,y)\n    x,y = x-dx, y-dy #<----------- this is the only part that changed\n\nplt.show()\n\nprint(\"ideal parameters: x={}, y={}\".format(x,y))\n```", "```py\n\"\"\"\nPlotting 3 similar landscapes scaled vertically\nto have small, moderate, and large gradients\n\"\"\"\n\ndef f(x, scale):\n    \"\"\"\n    Function to represent the landscape we are attempting to optimize\n    scaling the function vertically will scale the gradients proportionally\n    \"\"\"\n    return scale*(0.3*np.sin(x*0.1) +0.5* np.sin(np.cos(x)) + 0.1*np.sin(x*0.3+2) + 4*np.cos(x*0.1) + 6*np.sin(x*0.05))\n\ndef f_slope(x, scale):\n    \"\"\"\n    Using a pseudo derivative instead of computing the actual derivative\n    \"\"\"\n    dx = 0.00001\n    slope = (f(x+dx, scale)-f(x, scale))/dx\n    return slope\n\n#defining range\nX = np.linspace(50,125,10000)\n\nfor gradient_scale, color in zip([1,10,100], ['r', 'y', 'b']):\n    #computing landscape\n    Y = np.array(list(map(f, X, [gradient_scale]*len(X))))\n\n    point = 58\n    explored_x = []\n    explored_y = []\n    for _ in range(20):\n\n        #marking point as explored\n        explored_x.append(point)\n        explored_y.append(f(point,gradient_scale))\n\n        #traversing along gradient\n        point = point-f_slope(point, gradient_scale)\n\n    #plotting landscape\n    plt.plot(X,Y)\n    #plotting traversal\n    plt.plot(explored_x, explored_y, 'x-'+color)\n    #rendering\n    plt.show()\n```"]