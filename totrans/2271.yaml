- en: Using Machine Learning to Create Custom Color Palettes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://towardsdatascience.com/using-machine-learning-to-create-custom-color-palettes-acb4eeaa06aa](https://towardsdatascience.com/using-machine-learning-to-create-custom-color-palettes-acb4eeaa06aa)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Behind the scenes look at Streamlit‚Äôs app of the month
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@siavashyasini?source=post_page-----acb4eeaa06aa--------------------------------)[![Siavash
    Yasini](../Images/55220a8a9397ba51dcc381828735f4a2.png)](https://medium.com/@siavashyasini?source=post_page-----acb4eeaa06aa--------------------------------)[](https://towardsdatascience.com/?source=post_page-----acb4eeaa06aa--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----acb4eeaa06aa--------------------------------)
    [Siavash Yasini](https://medium.com/@siavashyasini?source=post_page-----acb4eeaa06aa--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ¬∑Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----acb4eeaa06aa--------------------------------)
    ¬∑12 min read¬∑Feb 16, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1f09de41ab54258a22eed6764d2b2464.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Ricardo Gomez Angel](https://unsplash.com/@rgaleriacom?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: '**Intro**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We all love getting our hands on a new dataset, exploring it, and learning from
    it. But raw numbers by themselves are not great storytellers. Our primal brains
    are wired for lines, shapes, and colors. That‚Äôs why numbers need to be visualized
    to tell a good story.
  prefs: []
  type: TYPE_NORMAL
- en: The color palette of your data visualization can make or break your data story
    though. While coming up with the perfect set of colors for your data visualization
    can be an exacting and time-consuming task, you don‚Äôt have to do it all on your
    own. Instead of starting from scratch, you can get inspiration from the greatest
    painters and artists in history.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d50d19ef7363c358c55970608f26affd.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: Creating a color palette from scratch typically falls within the domain of expertise
    of visualization engineers and designers who use color theory to put together
    harmonious palettes suitable for various visualization purposes (e.g. *monochromatic*
    palettes for sequential or gradient plots, or *complimentary* palettes for categorical
    charts). Visualization packages like `[matplotlib](https://matplotlib.org/)` or
    `[plotly](https://plotly.com)` already come with an amazing collection of such
    color palettes.
  prefs: []
  type: TYPE_NORMAL
- en: While data analysts and data scientists can get by using pre-made color palettes,
    there are situations where we may want to put together our own custom palette.
    An example scenario is when you want to make a visualization that is aligned with
    your company‚Äôs color theme. For example, you may want to create a bar chart that
    has a theme matching your favorite company‚Äôs logo. It would be really nice to
    have an app that does this for you automatically, right?
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b101e9b82ec488901cd97df3978afca1.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/262ffc426620d97852cb8bd71881c38b.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: I spend way too much time trying to come up with the perfect set of colors for
    my visualizations, so I decided to make the process a bit easier for myself.
  prefs: []
  type: TYPE_NORMAL
- en: 'I built a web app using [Streamlit](https://www.linkedin.com/company/streamlit/)
    üéà that can infer color palettes from any input image: paintings, movie posters,
    rock album covers, Christmas family photos, you name it! While the app may not
    give you the perfect color palette right out of the box, it will at least give
    you a great starting point.'
  prefs: []
  type: TYPE_NORMAL
- en: So let‚Äôs see how I built this app.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Color Palette Inference App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../Images/9fa1dc289439f16bba94504a7ba93a7a.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: In order to create a color palette inference tool we need a few components.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this post, I‚Äôll teach you:'
  prefs: []
  type: TYPE_NORMAL
- en: How to construct an image-loading component
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to build an image enhancement component with sliders
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to cluster pixels and use group averages to make a palette
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to use the color picker widget to display and modify the palette
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Want to try the app firsthand? You can check it out [here](https://sophisticated-palette.streamlit.app/)
    and see the source code [here](https://github.com/syasini/sophisticated_palette).
  prefs: []
  type: TYPE_NORMAL
- en: 1\. How to construct an image-loading component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first element we need for our app is a way to input the image we want to
    convert to a color palette. There are three ways we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Load from the pre-existing gallery of images or artworks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upload a new image file into the app using `st.file_uploader()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download a new image into the app from a URL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can construct three different tabs using`st.tabs()` that allow us to switch
    between these three input modes seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ef24ea3236c1e77a27219776a2ab50ff.png)'
  prefs: []
  type: TYPE_IMG
- en: Image input sources constructed using `st.tabs()`.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the way Streamlit runs the app (top-to-bottom), the input modes that
    come later will get higher priority and will overwrite the output of the previous
    loader. For example, since you ordered the input modes as Gallery ‚Üí File Uploader
    ‚Üí Image URL, if you save the image into a variable `img`, anything loaded by the
    gallery will be overwritten by the file uploader and URL downloader outputs.
  prefs: []
  type: TYPE_NORMAL
- en: You can add pop-up warnings for the user when they load an image with a loader
    lower in the hierarchy and an image is already loaded with a loader higher in
    the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the code will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So if you‚Äôre trying to load a pre-existing image from the gallery, but there
    is an existing link in the URL downloader, you‚Äôre going to have to remove that
    first. It may not be the most elegant solution, but it works!
  prefs: []
  type: TYPE_NORMAL
- en: Now, on to the implementation of each piece of the loading methods.
  prefs: []
  type: TYPE_NORMAL
- en: '**Gallery View**'
  prefs: []
  type: TYPE_NORMAL
- en: For the gallery view, we can simply save some images in a public repository
    and load those directly in the app (I‚Äôm using GitHub here, but you can also use
    AWS S3 or Google Cloud Storage). The `st.selectbox` contains the names of the
    artworks I have saved, so the user can load them simply by selecting them from
    the dropdown menu. Here is what the implementation looks like.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`gallery_dict` is a dictionary that has a file name and image file path as
    key-value pairs, and `PIL.Image.open()` is used to load those files. The results
    are saved in a variable named `img`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**File Uploader**'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the file uploader is very easy because there is already a Streamlit
    widget for it. It‚Äôs called (can you guess?) `st.file_uploader()`!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the implementation looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This widget allows you to upload a file that you can consequently pass to `PIL.Image.open()`
    to load. This step may break if the file is not actually an image file, or has
    a format inconsistent with what `PIL.Image` expects. To prevent this from becoming
    an issue we can put the loading part into a `try/except` block.
  prefs: []
  type: TYPE_NORMAL
- en: ‚ö†Ô∏è Here I‚Äôm using this block as a catch-all to avoid all sorts of unexpected
    errors when loading a file. However, it is normally not recommended to use `except`
    without actually specifying the `Exception` type you are trying to bypass, especially
    because deadly errors you are not aware of will pass through the block silently,
    making it difficult for you to debug your code.
  prefs: []
  type: TYPE_NORMAL
- en: '**URL Downloader**'
  prefs: []
  type: TYPE_NORMAL
- en: Let‚Äôs face it! While uploading files is a great way for users to load their
    custom images they want to infer the color palettes from, it‚Äôs not the easiest
    way. The user will have to find the image (if they don‚Äôt have it already), download
    it locally, then upload it to the app. Sounds easy, but annoying in practice.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove this barrier, we can add a URL downloader to the app so the
    user can simply copy the image link (e.g. from google search results) and simply
    paste it into the app. In order to accomplish this, we need the `requests` module,
    which gets us the contents of the URL, and the `io.BytesIO` function which makes
    the contents comprehendible by `PIL.Image.open()`. The implementation is simple
    and quite similar to what we did for the file uploader.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 2\. How to build an image enhancement component with sliders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have the image uploaded, we are ready to infer the color palette,
    right? Not exactly.
  prefs: []
  type: TYPE_NORMAL
- en: The original image you load into the app may not be optimized for color inference.
    The colors may be too dull, and you may not have enough brightness or contrast
    across the canvas. That‚Äôs why you need to do some image adjustments first.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5817b6a837e8ae6e175989ec428582ed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to apply enhancements to the image, we can use `PIL.ImageEnhance`
    . The API is very simple. For example, if you want to enhance the color of the
    image (loaded into `img` ) by a factor of 2.5, you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Simply replacing `Color` with `Shapness`, `Contrast`, or `Brightness` will adjust
    these image attributes respectively. We could create four different sliders that
    assign values to each of these attributes, and then write separate blocks of code
    and apply the enhancements to the image in turn. But we are good programmers,
    and we try to keep our codes beautiful and DRY (Don‚Äôt Repeat Yourself) as much
    as possible. So let‚Äôs approach this a bit more pragmatically.
  prefs: []
  type: TYPE_NORMAL
- en: We can define a dictionary that contains all the enhancements we want to apply
    as keys, with values indicating the ranges and step sizes of the sliders we want
    to assign to them in the app.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Using this approach, if we want to change the enhancement type or the range
    of values, we only need to change the original dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the sliders on the sidebar, the only thing left is to apply
    the values to the image using `ImageEnhance`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**Show the Image**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the image loaded, the only thing left is to show it on the
    app using `st.image()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: and *Voil√†*!
  prefs: []
  type: TYPE_NORMAL
- en: 3\. How to cluster pixels and use group averages to make a palette
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, onto the fun stuff! Using machine learning to infer the color palette.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea here is very simple. An image is a collection of pixels that each
    have three values assigned to them: R, G, B. These values basically tell you how
    much red, green, and blue each pixel contains. To infer the color palette, the
    actual location of the pixel on the canvas is virtually irrelevant. What matters
    is where it‚Äôs located within the (R, G, B) coordinate space. So before we proceed
    let‚Äôs decompose the image into this new coordinate system and get rid of the actual
    location of the pixel on the image.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the pixels in the RGB coordinates, we can then group the ones
    that are close together and use the average values of the pixels to represent
    each group ‚Äî essentially a single color in our palette. For example, if we want
    to construct a 5-color palette from the enhanced image of Mona Lisa, we need to
    first look at the distribution of the pixels in the RGB space (here it‚Äôs projected
    into 2D using the PCA algorithm):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/aaf50c2e6a36baff6e418262156e77bc.png)'
  prefs: []
  type: TYPE_IMG
- en: 2-dimensional PCA decomposition of original pixels colors from (R, G, B) space
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/79b2d0844aea6616e93aa70a23ce6a38.png)'
  prefs: []
  type: TYPE_IMG
- en: Then we select 5 distinct clusters and assign the average value of each cluster
    to a slot in our palette.
  prefs: []
  type: TYPE_NORMAL
- en: original sampled pixels assigned to 5 different clusters using K-means algorithm
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, we don‚Äôt need to do this by hand. There is a handy machine learning
    algorithm called K-means clustering that can do this for us in one fell swoop.
    The only parameter we need to provide is the number of clusters, a.k.a. our palette
    size. This is what the implementation looks like using `sklearn.cluster.KMeans`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: And that‚Äôs it! We now have our color palette, and we just need to return it
    to the user on the app.
  prefs: []
  type: TYPE_NORMAL
- en: ‚ÑπÔ∏è Although here we used the popular R, G, B decomposition of the pixels, it‚Äôs
    important to note that it‚Äôs not the only way to decompose colors. We could have
    done the clustering of pixels in HSV (Hue, Saturation, Value) space which would
    have distributed the pixels differently and led to a different color palette.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. How to use the color picker widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Somehow, I feel like the subconscious reason I decided to build this app was
    to use Streamlit‚Äôs amazing `st.color_picker()` widget! The nice thing bout this
    widget is that you can both show the palette colors inferred from the image, and
    also change them if you want. This is perfect because as I mentioned earlier,
    the colors you get back from the app may not be 100% perfect for your particular
    use case, but only a good starting point. So you may want to change them a little
    and do a bit of touch-up before actually using it for your visualization.
  prefs: []
  type: TYPE_NORMAL
- en: We don‚Äôt want the palette to take up half the page on our app, so let‚Äôs put
    them each in a separate column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Beautiful!
  prefs: []
  type: TYPE_NORMAL
- en: One last piece to finish things up, would be to provide the user with a practical
    end product they can use in their day-to-day work. If a data analyst or data scientist
    is using this app to infer a color palette, most likely they are going to use
    it in `matplotlib` or `plotly` to apply the palette to their visualization. Why
    not provide them with a code snippet that takes care of this, so they don‚Äôt have
    to copy-paste every single hex-code from the color palette into their coding environment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a5da3376d560c68a39cdbae2260d0f7b.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to Streamlit‚Äôs `st.code()` widget, the whole code block can be copied
    with a single click!
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There you go! Now you have a fully functional palette inference app that can
    help you figure out what colors Leonardo Da Vinci used to put that smile on Mona
    Lisa‚Äôs face!
  prefs: []
  type: TYPE_NORMAL
- en: In this post, we covered a lot of Streamlit‚Äôs functionalities, especially widgets
    like `st.image`, `st.tabs`, `st.file_uploader`, `st.color_picker`. But there is
    also a lot more that we didn‚Äôt cover here for the sake of brevity, so feel free
    to jump to the [source code](https://github.com/syasini/sophisticated_palette)
    repo and check out all the details yourself. You can see that I have relied heavily
    on `st.session_state` to keep things consistent across multiple runs of the app.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to
  prefs: []
  type: TYPE_NORMAL
- en: Construct an image loading component (load pre-existing, upload, or URL download).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build an image enhancement component with sliders.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cluster pixels together using K-means and use group averages to construct a
    palette.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return the palette to end-user using the color-picker widget.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I had a lot of fun walking you through all these steps, and I really hope you
    enjoyed reading/skimming through the article and hopefully learned a thing or
    two.
  prefs: []
  type: TYPE_NORMAL
- en: You can check out the app firsthand, [here](https://sophisticated-palette.streamlit.app/).
    I would love to hear your thoughts, questions, comments, and feedback! Get in
    touch with me on [LinkedIn](https://www.linkedin.com/in/siavash-yasini/) or through
    my [website](https://www.siavashyasini.com/).
  prefs: []
  type: TYPE_NORMAL
- en: '*This article was written in collaboration with* [*Ksenia Anske*](https://www.linkedin.com/in/kseniaanske/)
    *and team* [*Streamlit*](https://streamlit.io/) *at* [*Snowflake*](https://www.snowflake.com/en/)*.
    See the final version of this article published on Streamlit‚Äôs blog* [*here*](https://blog.streamlit.io/create-a-color-palette-from-any-image/)*.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*All images, unless otherwise noted, are by the author.*'
  prefs: []
  type: TYPE_NORMAL
