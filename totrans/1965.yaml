- en: 'Temporary Variables in Python: Readability versus Performance'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/temporary-variables-in-python-readability-versus-performance-f6708b5f293c](https://towardsdatascience.com/temporary-variables-in-python-readability-versus-performance-f6708b5f293c)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: PYTHON PROGRAMMING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Temporary variables can make code clearer. What about the performance of such
    code?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@nyggus?source=post_page-----f6708b5f293c--------------------------------)[![Marcin
    Kozak](../Images/d7faf62e48ed81dab5d8ad92819fff54.png)](https://medium.com/@nyggus?source=post_page-----f6708b5f293c--------------------------------)[](https://towardsdatascience.com/?source=post_page-----f6708b5f293c--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----f6708b5f293c--------------------------------)
    [Marcin Kozak](https://medium.com/@nyggus?source=post_page-----f6708b5f293c--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----f6708b5f293c--------------------------------)
    ·8 min read·Jun 1, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/df7237943e419001b72e9b50f1dae8b8.png)'
  prefs: []
  type: TYPE_IMG
- en: Are Python shortcuts fast? Photo by [Stefan Steinbauer](https://unsplash.com/@usinglight?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: 'Temporary variables are variables with short lifetimes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://en.wikipedia.org/wiki/Temporary_variable?source=post_page-----f6708b5f293c--------------------------------#:~:text=In%20computer%20programming%2C%20a%20temporary,a%20variable%20with%20local%20scope)
    [## Temporary variable - Wikipedia'
  prefs: []
  type: TYPE_NORMAL
- en: From Wikipedia, the free encyclopedia In computer programming, a temporary variable
    is a variable with short lifetime…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: en.wikipedia.org](https://en.wikipedia.org/wiki/Temporary_variable?source=post_page-----f6708b5f293c--------------------------------#:~:text=In%20computer%20programming%2C%20a%20temporary,a%20variable%20with%20local%20scope)
  prefs: []
  type: TYPE_NORMAL
- en: 'They are used very often in programming, and you don’t have to know this term
    to use temporary variables. One of the most common use cases is to make code clearer,
    for instance, in pipelines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, I used Python’s [walrus operator](https://docs.python.org/3/whatsnew/3.8.html#assignment-expressions)
    to visually represent an assignment, just the way it’s used in Python code. In
    this pipeline, we have two temporary variables: `tempvar_1` and `tempvar_2`. Their
    lifetime is short in terms of data flow through the code, although it can be long
    in terms of real time. `tempvar_1` is used for only one purpose: to pass the results
    from the first step of the pipeline to the next. But note that technically, it’s
    unnecessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Both versions will work the same way, although the latter can be much less readable.
    Thus, the former version is used a lot in programming, with the only reason to
    make the code cleaner.
  prefs: []
  type: TYPE_NORMAL
- en: Note that had `tempvar_1` or `tempvar_2` been used later on in the code, it
    wouldn’t have been a temporary variable, since it wouldn’t have had a short lifetime.
    For the sake of simplicity, we can assume that a temporary variable is one you
    use just once, in order to pass the output of one callable as input to another.
  prefs: []
  type: TYPE_NORMAL
- en: Have you ever pondered if using temporary variables in a pipeline constitutes
    a better option than a direct — and shortest — way of calculating the pipeline?
    As in, which of the two following snippets is better?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, this time using simple arithmetics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Which would you choose? Does it even matter?
  prefs: []
  type: TYPE_NORMAL
- en: 'Python is so popular for various reasons, and one of them is the *readability*
    of its code. At the same time, Python is known for its *poor performance* — although
    it isn’t as bad as many claim, as I wrote in the following article:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/pythoniq/the-speed-of-python-it-aint-that-bad-9f703dd2924e?source=post_page-----f6708b5f293c--------------------------------)
    [## The Speed of Python: It Ain’t That Bad!'
  prefs: []
  type: TYPE_NORMAL
- en: I hear all the time that Python is way too slow. Is it?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/pythoniq/the-speed-of-python-it-aint-that-bad-9f703dd2924e?source=post_page-----f6708b5f293c--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Oftentimes, you can — and need to — choose between readability and performance.
    Sometimes you may need even the slightest improvement in performance, even if
    it means decreased readability. Other times, a small improvement in performance
    means no side effects and as readable and comprehensible code as its slower counterpart;
    why wouldn’t you go for it?
  prefs: []
  type: TYPE_NORMAL
- en: 'When an improvement in performance comes at some cost, however, you should
    be careful. You should ask yourself — or the development team you’re part of —
    the following question: Is this minor improvement in performance worth decreasing
    code readability?'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this article, I want to show you an example of such an improvement, achieved
    by avoiding temporary variables. Getting rid of them can improve performance a
    little bit, but usually at a cost of decreased readability. Yes, usually, so *not
    always*: if you’re lucky, getting rid of temporary variables can help you improve
    both performance *and* readability. A perfect situation, isn’t it?'
  prefs: []
  type: TYPE_NORMAL
- en: Temporary variables in Python code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine you want to implement a function that calculates a sequence of things.
    For simplicity, we will perform some basic arithmetic calculations so that the
    example is simple. In real life, however, such pipelines can contain several functions
    doing various things, even quite complicated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we’re starting with `x`, and then we calculate `y`, `z`, `f` and finally
    `g`, `g` being the final output, so it’s returned. This is similar to [*function
    composition*](https://en.wikipedia.org/wiki/Function_composition_(computer_science)),
    the difference being that here we don’t compose functions but calculations. In
    many scenarios, however, you will have actual functions; for instance, instead
    of `y = x**2`, you can have `y = some_function(x)`. A perfect example of when
    something like that works in Python is generator pipelines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/building-generator-pipelines-in-python-8931535792ff?source=post_page-----f6708b5f293c--------------------------------)
    [## Building Generator Pipelines in Python'
  prefs: []
  type: TYPE_NORMAL
- en: This article proposes an elegant way to build generator pipelines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/building-generator-pipelines-in-python-8931535792ff?source=post_page-----f6708b5f293c--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 'and their general version, comprehension pipelines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/building-comprehension-pipelines-in-python-ec68dce53d03?source=post_page-----f6708b5f293c--------------------------------)
    [## Building Comprehension Pipelines in Python'
  prefs: []
  type: TYPE_NORMAL
- en: Comprehension pipelines are a Python-specific idea for building pipelines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/building-comprehension-pipelines-in-python-ec68dce53d03?source=post_page-----f6708b5f293c--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 'In simple situations, like the one in our `calc_with_tempvar()` function, such
    an approach seems to be an overkill. Instead, we could simply do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Both lead to the very same results, as these tests show:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: No output means this is true indeed.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s disassembly the two functions, to see their translations to Python
    bytecode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/cc0bd7ca49181294b52740181df7c134.png)'
  prefs: []
  type: TYPE_IMG
- en: Disassembly of the two functions using the dis.dis() function. Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Even without analyzing the bytecode of the two functions, we see that Python
    has a more complex job to do with the function employing the temporary variables
    than with the one without them. This does not come as a surprise, does it? The
    way the functions are defined suggests itself that `calc_with_tempvar()` will
    have to do more to reach the outcome than `calc_without_tempvar()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Temporary variables: Performance'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'How does this translate into performance, however? To learn this, let’s use
    the `[perftester](https://github.com/nyggus/perftester)` Python package, dedicated
    to benchmarking and testing time and memory performance of Python functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/benchmarking-python-functions-the-easy-way-perftester-77f75596bc81?source=post_page-----f6708b5f293c--------------------------------)
    [## Benchmarking Python Functions the Easy Way: perftester'
  prefs: []
  type: TYPE_NORMAL
- en: You can use perftester to benchmark Python functions the easy way
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/benchmarking-python-functions-the-easy-way-perftester-77f75596bc81?source=post_page-----f6708b5f293c--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: For benchmarks, I used Python 3.11 on a Windows 10 machine, in WSL 1, 32GB of
    RAM and four physical (eight logical) cores. However, in our case, raw times do
    not matter that much; we will focus on relative comparisons instead.
  prefs: []
  type: TYPE_NORMAL
- en: First, let me change the default settings for the benchmarks. I will use 20
    million function calls repeated 7 times; the quickest among the 7 times will be
    chosen as the benchmark result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the actual benchmarks, for a `float` number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'And let’s see the results¹:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the one-shot version (without temporary variables) is faster —
    around 5% faster. On the one hand, it’s not much. On the other hand, it’s 5% achieved
    by something that small — so small a change!
  prefs: []
  type: TYPE_NORMAL
- en: The above calculations are fast. For long calculations, however, the difference
    would likely be close to invisible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice that we can improve the `calc_with_tempvar()` function a little
    bit? Do we need the last object, `g`? Sometimes an object like this can increase
    a function’s readability, via a good name, but not in this case — so we don’t
    need `g`. Let’s see if getting rid of it will help us in terms of performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: A minor improvement, as the composition version is about `1.032` times slower
    than this one, and this one is about `1.023` times slower than the one-shot version.
    But again, this improvement was achieved by such a small change! If so, isn’t
    this small change worth using?
  prefs: []
  type: TYPE_NORMAL
- en: Conclusions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*For me — it definitely is, but not always.*'
  prefs: []
  type: TYPE_NORMAL
- en: The point is, when performance does not matter, go for readability. If it really
    does not change a thing when your program runs a minute, 10 seconds, or even half
    a second longer — simply don’t even think about improving performance by such
    tricks. Why should you? Why should you worsen readability in order to make minor
    improvements when these improvements do not matter whatsoever? Just go for readability.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there will be times when getting rid of temporary variables will
    increase the readability of the function. In this case, why should we even discuss
    this? Again, just go for readability, and when this means increasing performance,
    too — well, a perfect situation.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes performance does matter. Even a split of a second can make a difference.
    If this is the case, you should profile your code and find bottlenecks. Other
    times, you may wish to optimize every single part of the code. One example is
    working on a framework to be used by others, and for some of them performance
    will matter. In that case, it’s *your* responsibility — as of the framework’s
    author — to offer as fast a tool as possible. Otherwise, you’re risking that some
    users will not use your framework.
  prefs: []
  type: TYPE_NORMAL
- en: '*To summarize*:'
  prefs: []
  type: TYPE_NORMAL
- en: If performance matters, avoid using temporary variables like those in `calc_with_tempvar()`.
    If performance is of secondary (if any) significance, go for readability — which
    means that a decision whether to use temporary variables or not should be based
    solely on code readability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s not that temporary variables always increase readability. For instance,
    imagine you have a mathematical function `y(x) = ((x**2)/2 + 78)/333.333`. Do
    you think `calc_with_tempvar()`, with all those temporary variables, would increase
    readability? I don’t.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, sometimes temporary variables will improve code readability, other times
    they won’t. If performance is of critical importance, remember that temporary
    variables can add some minor overhead. More often than not, this overhead will
    be negligible — but in some projects, even those splits of seconds can matter.
  prefs: []
  type: TYPE_NORMAL
- en: All in all, always double-check if it’s worth getting rid of temporary variables
    in your code — or if it’s worth using them.
  prefs: []
  type: TYPE_NORMAL
- en: Footnotes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '¹ The code uses the `perftester.pp()` function, which pretty-prints (using
    a standard-library function `pprint.pprint()`) a Python object with all numbers
    in it rounded to four significant digits. It does so using the [rounder](https://pypi.org/project/rounder/)
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://github.com/nyggus/rounder?source=post_page-----f6708b5f293c--------------------------------)
    [## GitHub - nyggus/rounder: Python package for rounding floats and complex numbers
    in complex Python…'
  prefs: []
  type: TYPE_NORMAL
- en: rounder is a lightweight package for rounding numbers in complex Python objects,
    such as dictionaries, lists, tuples…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: github.com](https://github.com/nyggus/rounder?source=post_page-----f6708b5f293c--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks for reading. If you enjoyed this article, you may also enjoy other articles
    I wrote; you will see them [here](https://medium.com/@nyggus). And if you want
    to join Medium, please use my referral link below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/@nyggus/membership?source=post_page-----f6708b5f293c--------------------------------)
    [## Join Medium with my referral link - Marcin Kozak'
  prefs: []
  type: TYPE_NORMAL
- en: Read every story from Marcin Kozak (and thousands of other writers on Medium).
    Your membership fee directly supports…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/@nyggus/membership?source=post_page-----f6708b5f293c--------------------------------)
  prefs: []
  type: TYPE_NORMAL
