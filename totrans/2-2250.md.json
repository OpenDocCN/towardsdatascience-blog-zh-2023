["```py\n[1.13-1.56j, 2.34+2.6j, 7.4,-3.98j, ...]\n```", "```py\n[(1.13, 1.56), (2.34, 2.6), (7.4, -3.98), ...]\n```", "```py\n\"\"\"\nLoading a sample waveform, and plotting it in the time domain\n\"\"\"\n\n#importing dependencies\nimport matplotlib.pyplot as plt     #for plotting\nfrom scipy.io import wavfile        #for reading audio file\nimport numpy as np                  #for general numerical processing\n\n#reading a .wav file containing audio data.\n#This is stereo data, so there's a left and right audio audio channel\nsamplerate, data = wavfile.read('trumpet_snippet.wav')\n\n#creating wide figure\nplt.figure(figsize=(18,6))\n\n#defining number of samples we will explore\nN = 3000\n\n#calculating time of each sample\nx = np.linspace(start = 0, stop = N/samplerate, num = N)\n\n#plotting channel 0\nplt.subplot(2, 1, 1)\nplt.plot(x,data[:N,0])\n\n#plotting channel 1\nplt.subplot(2, 1, 2)\nplt.plot(x,data[:N,1])\n\n#rendering\nplt.show()\n```", "```py\n\"\"\"\nConverting the sample waveform to the frequency domain, and plotting it\n\nThis is basically directly from the scipy documentation\nhttps://docs.scipy.org/doc/scipy/tutorial/fft.html\n\"\"\"\n\n#importing dependencies\nfrom scipy.fft import fft, fftfreq      #for computing frequency information\n\n#calculating the period, which is the amount of time between samples\nT = 1/samplerate\n#defining the number of samples to be used in the frequency calculation\nN = 3000\n\n#calculating the amplitudes and frequencies using fft\nyf0 = fft(data[:N,0])\nyf1 = fft(data[:N,1])\nxf = fftfreq(N, T)[:N//2]\n\n#creating wide figure\nplt.figure(figsize=(18,6))\n\n#plotting only frequency and amplitude for the 1st channel\nplt.subplot(2, 1, 1)\nplt.plot(xf, 2.0/N * np.abs(yf0[0:N//2]))\nplt.xlim([0, 6000])\n\n#plotting only frequency and amplitude for the 2st channel\nplt.subplot(2, 1, 2)\nplt.plot(xf, 2.0/N * np.abs(yf1[0:N//2]))\nplt.xlim([0, 6000])\n\nplt.show()\n```", "```py\n\"\"\"\nPlotting the entire frequency domain spectrogram for the mock electrical data\n\"\"\"\n\n#load electrical data, which is a numpy list of values taken at 1000Hz sampling frequency\nx, y = load_electrical_data()\nsamplerate = 1000\nN = len(y)\n\n#calculating the period, which is the amount of time between samples\nT = 1/samplerate\n\n#calculating the amplitudes and frequencies using fft\nyf = fft(y)\nxf = fftfreq(N, T)[:N//2]\n\n#creating wide figure\nplt.figure(figsize=(18,6))\n\n#plotting only frequency and amplitude for the 1st channel\nplt.plot(xf, 2.0/N * np.abs(yf[0:N//2]))\n\n#marking units of the two axis\nplt.xlabel('fq (Frequency in Hz)')\nplt.ylabel('V (Volts)')\n\n#setting the vertical axis as logorithmic, for better visualization\nplt.gca().set_yscale('log')\n\n#rendering\nplt.show()\n```", "```py\n\"\"\"\nconverting the data to the frequency domain, and filtering out\nunwanted frequencies\n\"\"\"\n\n#defining low frequency cutoff\nlowfq = 1/(5*60)\n\n#defining high frequency cutoff\nhighfq = 1\n\n#calculating the amplitudes and frequencies, preserving all information\n#so the inverse fft can work\nyf = fft(y)\nxf = fftfreq(N, T)\n\n#applying naiive filter, which will likely create some artifacts, but will\n#filter out the data we don't want\nyf[np.abs(xf) < lowfq] = 0\nyf[np.abs(xf) > highfq] = 0\n\n#creating wide figure\nplt.figure(figsize=(18,6))\n\n#plotting only frequency and amplitude\nplt.plot(xf[:N//2], 2.0/N * np.abs(yf[0:N//2]))\n\n#marking units of the two axis\nplt.xlabel('fq (Frequency in Hz)')\nplt.ylabel('V (Volts)')\n\n#setting the vertical axis as logorithmic, for better visualization\nplt.gca().set_yscale('log')\n\n#zooming into the frequency range we care about\nplt.xlim([-0.1, 1.1])\n\n#rendering\nplt.show()\n```", "```py\n \"\"\"\nReconstructing the wave with the filtered frequency information\n\"\"\"\n\n#importing dependencies\nfrom scipy.fft import ifft      #for computing the inverse fourier transform\n\n#computing the inverse fourier transform\ny_filt = ifft(yf)\n\n#creating wide figure\nplt.figure(figsize=(18,6))\n\n#plotting\nplt.plot(x,y_filt)\n\n#defining x and y axis\nplt.xlabel('t (seconds)')\nplt.ylabel('V (volts)')\n\n#looking at a few minutes of data, not looking at \n#the beginning or end of the data to avoid filtration artifacts\nplt.xlim([60*2,60*10])\n\n#rendering\nplt.show()\n```", "```py\n\"\"\"\nplotting a mel-spectrogram of motor vibration to diagnose the point of failure\n\nnote: if you don't want to use librosa, you can construct a mel-spectrogram\neasily using scipy's fft function across a rolling window, allowing for more\ngranular calculation, and matplotlib's imshow function for more granular\nrendering\n\"\"\"\n\n#importing dependencies\nimport librosa              #for calculating the mel-spectrogram\nimport librosa.display      #for plotting the mel spectrogram\n\n#loading the motor data\ny = load_motor_data()\nsamplerate = 1000 #in Hz\n\n#calculating the mel spectrogram, as per the librosa documentation\nD = np.abs(librosa.stft(y))**2\nS = librosa.feature.melspectrogram(S=D, sr=samplerate)\n\n#creating wide figure\nfig = plt.figure(figsize=(18,6))\n\n#plotting the mel spectrogram\nax = fig.subplots()\nS_dB = librosa.power_to_db(S, ref=np.max)\nimg = librosa.display.specshow(S_dB, x_axis='time',\n                         y_axis='mel', sr=samplerate,\n                         fmax=8000, ax=ax)\nfig.colorbar(img, ax=ax, format='%+2.0f dB')\nax.set(title='Mel-frequency spectrogram')\n\n#rendering\nplt.show()\n```", "```py\n\"\"\"\nloading and plotting two waveforms recorded in two seperate environments,\nboth including people talking\n\"\"\"\n\n#loading two waveforms\nsamplerate, y1 = wavfile.read('crowd.wav')\n_,          y2 = wavfile.read('citycenter.wav')\n\n#creating x axis for both waveforms\nN = 1000000\nx1 = np.linspace(start = 0, stop = N/samplerate, num = N)\nx2 = np.linspace(start = 0, stop = N/samplerate, num = N)\n\n#creating wide figure\nplt.figure(figsize=(18,6))\n\noffset = 1000000\n\n#plotting waveform 1\nplt.subplot(2, 1, 1)\nplt.plot(x1,y1[offset:offset+N])\nplt.xlabel('t (seconds)')\nplt.ylabel('A (db)')\n\n#plotting waveform 2\nplt.subplot(2, 1, 2)\nplt.plot(x2, y2[offset:offset+N])\nplt.xlabel('t (seconds)')\nplt.ylabel('A (db)')\n\n#rendering\nplt.show()\n```", "```py\n\"\"\"\nConverting both waves to the frequency domain, constructing a wave table, and rendering the wave table\n\"\"\"\n\n#calculating the frequency content for both waves.\n#Only analyzing 1 of the 2 stereo channels\nfq1 = fft(y1[offset:offset+N,0])\nfq2 = fft(y2[offset:offset+N,0])\n\n#defining frequency axis\nT = 1/samplerate\nxf = fftfreq(N, T)\n\n#creating wide figure\nfig = plt.figure(figsize=(18,6))\nax = fig.add_subplot(111, projection='3d')\n\n#plotting source waves\nplt.plot(xf[:N//2], np.array([1]*(N//2)), 2.0/N * np.abs(fq1[0:N//2]))\nplt.plot(xf[:N//2], np.array([0]*(N//2)), 2.0/N * np.abs(fq2[0:N//2]))\n\nfq_interp = []\n#creating interpolations\nfor per in np.linspace(0.1,0.9,9):\n    thisfq = (fq1*per) + (fq2*(1-per))\n    fq_interp.append((per, thisfq))\n\n    #plotting interpolation\n    plt.plot(xf[:N//2], np.array([per]*(N//2)), 2.0/N * np.abs(thisfq[0:N//2]))\n\nplt.show()\n```", "```py\n\"\"\"\nComputing the inverse fft on the frequency content, and constructing the final table of waves\n\"\"\"\n\n#creating wide figure\nfig = plt.figure(figsize=(18,6))\nax = fig.add_subplot(111, projection='3d')\n\nplt.plot(x, np.array([1]*len(x)), y1[offset:offset+N,0])\nplt.plot(x, np.array([0]*len(x)), y2[offset:offset+N,0])\n\n#creating interpolations\nfor per, interp in fq_interp:\n\n    waveform = ifft(interp)\n\n    plt.plot(x, np.array([per]*len(x)), waveform)\n\nplt.show()\n```", "```py\n\"\"\"\nloading 1000 average sentiment scores over the course of a year,\nand plotting the first 10 of them\n\"\"\"\n\n#loading sentiment data\nsentiments = load_sentiments()\n\n#creating wide figure\nplt.figure(figsize=(18,6))\n\n#plotting first 10 sentiments\nfor i in range(10):\n    plt.plot(sentiments[i])\n\n#rendering \nplt.xlabel('days')\nplt.ylabel('sentiment (low to high)')\nplt.show()\n```", "```py\n\"\"\"\nConverting to the frequency domain, removing very low and high frequency content, and plotting the results\nWe do this, so we can visually understand the frequency content which we deem important, before we begin clustering.\n\"\"\"\n\n#importing dependencies\nfrom scipy.fft import fft, ifft      #for computing frequency information\n\n#creating wide figure\nplt.figure(figsize=(18,6))\n\n#defining the low frequency and high frequency cutoffs\n#because lowfq is so low, it effectively only cuts of the wave\n#with a frequency of zero, which controls the vertical offset of the data\nlowfq = 0.0001 \nhighfq = 0.05\n\n#plotting first 10 sentiments\nfor i in range(10):\n\n    #getting signal\n    sig = sentiments[i]\n\n    #calculating the frequency domain\n    yf = fft(sig)\n    T = 1\n    N = len(sig)\n    xf = fftfreq(N, T)\n\n    #applying naiive filter\n    yf[np.abs(xf) < lowfq] = 0\n    yf[np.abs(xf) > highfq] = 0\n\n    #converting back to the time domain, and plotting\n    y = ifft(yf)\n    plt.plot(y)\n\n#rendering\nplt.show()\n```", "```py\n[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0]\n[0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0]\n[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0]\n[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0]\n```", "```py\n\"\"\"\nConverting data to the frequency domain, and applying an exponential\nmoving average in both directions. This is the data we will be clustering.\n\"\"\"\n\n#converting data to frequencies, and filtering out content\nwfs = [np.abs(fft(y)[0:N//2][1:20]) for y in sentiments[:10]]\n\n#loading sample data into a pandas dataframe\ndf = pd.DataFrame(wfs).T\n\n#applying an exponential moving average in both directions, and adding them\ndf_plt = df.iloc[::-1].ewm(span=3, adjust=False).mean().iloc[::-1]\ndf_plt = df.ewm(span=3, adjust=False).mean().add(df_plt)\n\n#creating wide figure\nplt.figure(figsize=(18,6))\nplt.plot(df_plt)\n```", "```py\n\"\"\"\nConverting all the sentiment waveforms to the frequency domain, \napplying filtration, and embedding in 2d with TSNE\n\"\"\"\n\n#importing dependencies\nfrom sklearn.manifold import TSNE\n\n#converting data to frequencies, and filtering out content, for al product sentiment waveforms\nwfs = [np.abs(fft(y)[0:N//2][1:20]) for y in sentiments]\n\n#loading sample data into a pandas dataframe\ndf = pd.DataFrame(wfs).T\n\n#applying an exponential moving average in both directions, and adding them\ndf_plt = df.iloc[::-1].ewm(span=3, adjust=False).mean().iloc[::-1]\ndf_plt = df.ewm(span=3, adjust=False).mean().add(df_plt)\n\n#creating wide figure\nplt.figure(figsize=(18,6))\n\n#embedding the data\nembedding = TSNE(n_components=2 ,init='random', perplexity=20).fit_transform(df_plt.values.T)\n\n#plotting\nplt.scatter(embedding[:,0],embedding[:,1])\n```"]