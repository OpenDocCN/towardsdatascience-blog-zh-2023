- en: 'EDA with Polars: Step-by-Step Guide to Aggregate and Analytic Functions (Part
    2)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/eda-with-polars-step-by-step-guide-to-aggregate-and-analytic-functions-part-2-a22d986315aa](https://towardsdatascience.com/eda-with-polars-step-by-step-guide-to-aggregate-and-analytic-functions-part-2-a22d986315aa)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Advanced aggregates and rolling averages at lightning speed with Polars
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@antonsruberts?source=post_page-----a22d986315aa--------------------------------)[![Antons
    Tocilins-Ruberts](../Images/363a4f32aa793cca7a67dea68e76e3cf.png)](https://medium.com/@antonsruberts?source=post_page-----a22d986315aa--------------------------------)[](https://towardsdatascience.com/?source=post_page-----a22d986315aa--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----a22d986315aa--------------------------------)
    [Antons Tocilins-Ruberts](https://medium.com/@antonsruberts?source=post_page-----a22d986315aa--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----a22d986315aa--------------------------------)
    ·9 min read·Jul 10, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e244e107d7b8e9c628cb4f7312d675a8.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Spencer Davis](https://unsplash.com/@spencerdavis?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the [the first part of this series](/eda-with-polars-step-by-step-guide-for-pandas-users-part-1-b2ec500a1008)
    we’ve covered the basics of Polars and compared its functionalities and syntax
    with Pandas. This part will take the complexity of our queries a notch further,
    so we’ll see how to perform some fairly complex aggregates, rolling statistics,
    and more. If you’re not familiar with Polars or feel like you need a refresher,
    make sure to check out the [previous part](/eda-with-polars-step-by-step-guide-for-pandas-users-part-1-b2ec500a1008).
    Otherwise, let’s continue exploring Polars!
  prefs: []
  type: TYPE_NORMAL
- en: Setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As in the last part, make sure to clone/pull this [GitHub repo](https://github.com/aruberts/tutorials/tree/main/polars)
    since it has all the code you need for this post. In particular, we’ll be covering
    this [notebook](https://github.com/aruberts/tutorials/blob/main/polars/time_analysis.ipynb),
    so make sure to get it if you want to follow along.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data used in this project can be downloaded from [Kaggle](https://www.kaggle.com/datasets/datasnaek/youtube-new?resource=download&sort=published)
    (CC0: Public Domain). I assume that you already have Polars installed, so just
    make sure to update it to the latest version using `pip install -U polars` .'
  prefs: []
  type: TYPE_NORMAL
- en: Data Processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reading Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to the last post, let’s read in the UK trending dataset and the mappings
    for `category_id` columns.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Cleaning Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, let’s parse the dates and map category IDs to the category names. To make
    it more production ready, I’m going to put the date parsing code into a generalisable
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice that because the function return a DataFrame we can chain the category
    mapping to create an elegant (almost) one-linear cleaning code.
  prefs: []
  type: TYPE_NORMAL
- en: Feature Engineering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Frequently, you’ll need to create new features derived from the ones you already
    have. For example, in this YouTube dataset we can calculate the number of days
    it took for a video to get into the Trending tab since we have `publish_time`
    and `trending_date` . Additionally, we can also calculate different ratios with
    likes, dislikes, comments and views.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/adb8c51f894a80776296759e7a0ed5dc.png)![](../Images/29b4b059a1d3e4767894ad9160b04141.png)'
  prefs: []
  type: TYPE_IMG
- en: Sense checks of derived features. Screenshots by author.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we can extract year, month, and weekday from the `trending_date`
    column which can be used in further analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the dataset is pre-processed and ready for further analysis. Let’s
    start by exploring the time it takes to get into trending in more depth.
  prefs: []
  type: TYPE_NORMAL
- en: Time to Trending Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since a video can appear in the trending dataset multiple times (i.e. on different
    dates), we need to first create a data frame with one video per row and the correct
    time it took it to get into trending. For example, consider this video that appears
    in the dataset 3+ times.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6fdc7e1f966aed4a058d5190232ea85b.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot by author.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual time it took to get into trending is 1 day and then it stayed in
    trending for a few days. We can use a `.groupby()` method to group by `video_id`
    and get a few useful values:'
  prefs: []
  type: TYPE_NORMAL
- en: Time it took to get into trending (minimum value of `time_to_trending`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time it was in the Trending tab (maximum value minus minimum value of `trending_date`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, we’d like to bring in other information about the video e.g. `channel_title`
    or `title` for further analysis. To do this, we can use the `.groupby()` method
    with multiple `by` arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Interestingly, the average time to trending is much larger than the median indicating
    that there are large outliers in this data. To not bias the further analysis,
    let’s filter out all the videos that took longer than 60 days to get into trending.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice how easy it is to compose and stack quite complicated queries!
  prefs: []
  type: TYPE_NORMAL
- en: Fastest Categories & Channels to Get Into Trending
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First things first, let’s do this analysis only for the categories that have
    appeared in trending at least 100 times since statistics for infrequent categories
    won’t be as reliable. There are many ways of filtering out these categories (e.g.
    using `.value_counts()` ) but this time let’s use `pl.count().over()` to introduce
    a new expression. Using this method, we can count the number of rows over `category_id`
    which should add a new column `times_in_trending` to the `time_to_trending_df`
    . You can see that the syntax is quite similar to PySpark and SQL, so it should
    be familiar to the most of data professionals.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: After counting the number of occurrences per category, it’s quite trivial to
    filter the infrequent categories out and to calculate the average time to trending
    by group. While this gets the job done, we’ll need to copy-paste this query for
    the `channel_title` level analysis as well which is not very elegant. Instead,
    let’s create a function with a few available parameters to make it more generic.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/5c88df7cb92585510e78e4e91fced00e.png)![](../Images/0e9be23584907792a6693f2ca429fb7c.png)'
  prefs: []
  type: TYPE_IMG
- en: Fastest categories and channels to get into trending. Screenshot by author.
  prefs: []
  type: TYPE_NORMAL
- en: Interesting but kind of expected results — the late shows absolutely dominate
    the Trending tab of YouTube (at least in 2018). Jimmy Fallon gets an express ticket
    to trending, closely followed by SNL and The Ellen Show.
  prefs: []
  type: TYPE_NORMAL
- en: Categories & Channels That Stay in Trending
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides getting into the Trending tab, it’s also important who stays there the
    longest. This analysis is similar to the last one — we want to average some metric
    (days in trending) by group (e.g. category) but only for frequent group values
    (e.g. that appear more than 10 times). Hence, let’s re-use the amazing function
    we’ve previously created.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/a691b6097b058c5936006e3711f228dd.png)![](../Images/e8f660c5047b58fb9f4cbebe111273c5.png)'
  prefs: []
  type: TYPE_IMG
- en: Interestingly, there’s no overlap between the categories. So even though it
    might take some time for a music clip to get into the trending, it’s more likely
    to stay there for longer. The same goes for movie trailers and other entertainment
    content.
  prefs: []
  type: TYPE_NORMAL
- en: Trending Categories Over Time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So we know that the live-comedy shows get into the trending the fastest and
    music and entertainment videos stay there the longest. But has it always been
    the case? To answer this question, we need to create some rolling aggregates.
    Let’s answer three main questions in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the total number of trending videos per category per month?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the number of new videos per category per month?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do the categories compare when it comes to views over time?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Total Number of Monthly Trending Videos per Category
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let’s look at the total number of videos per category per month. To get
    this statistic, we need to use `.groupby_dynamic()` method that allows us to group
    by the date column (specified as `index_column` ) and any other column of choice
    (specified as `by` parameter). The grouping frequency is controlled according
    to the `every` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/4ea1c6f02f8a6b52416bfb5f93818697.png)'
  prefs: []
  type: TYPE_IMG
- en: Resulting resampled data frame. Screenshot by author.
  prefs: []
  type: TYPE_NORMAL
- en: You can see the resulting DataFrame above. Very nice property of Polars is that
    we can output the boundaries to sense check the results. Now, let’s do some plotting
    to visualise the patterns.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/0af2d888e3dbd939bd89f0b8ca136375.png)'
  prefs: []
  type: TYPE_IMG
- en: Number of videos plot. Generated by author.
  prefs: []
  type: TYPE_NORMAL
- en: From this plot we can see that Music has the largest share of Trending stating
    from 2018\. This might indicate some strategic shift within YouTube to become
    the go-to platform for music videos. Entertainment seems to be on the gradual
    decline together with People & Blogs and Howto & Style categories.
  prefs: []
  type: TYPE_NORMAL
- en: Number of New Monthly Trending Videos per Category
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The query is exactly the same, except now we need to provide as `index_column`
    the first the date when a video got into Trending. Would be nice to create a function
    here, but I’ll leave this as an exercise for a curious reader.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/2a87a51ab4e4947c77b2c5fa27aba588.png)'
  prefs: []
  type: TYPE_IMG
- en: Number of new videos plot. Generated by author.
  prefs: []
  type: TYPE_NORMAL
- en: Here we get an interesting insights — the number of new videos by Entertainment
    and Music is roughly equal throughout the time. Since Music videos stay in Trending
    much longer, they are overrepresented in the Trending counts, but when these videos
    are deduped this pattern disappears.
  prefs: []
  type: TYPE_NORMAL
- en: Running Average of Views per Category
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the last step of this analysis, let’s compare two most popular categories
    (Music and Entertainment) according to their views over time. To perform this
    analysis, we’re going to use the 7 day running average statistic to visualise
    the trends. To calculate this rolling statistic Polars has a handy method called
    `.groupby_rolling()` . Before applying it though, let’s sum up all the views by
    `category_id` and `trending_date` and then sort the DataFrame accordingly. This
    format is required to correctly calculate the rolling statistics.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Once the DataFrame is ready, we can use `.groupby_rolling()` method to create
    the rolling average statistic by specifying `1w` in the period argument and creating
    an average expression in the `.agg()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/641c0cb89292c17def0cef4be44c1d12.png)'
  prefs: []
  type: TYPE_IMG
- en: Plot generated by author.
  prefs: []
  type: TYPE_NORMAL
- en: According to the 7-day rolling average views, Music completely dominates the
    Trending tab and starting from February 2018 the gap between these two categories
    has increased massively.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After finishing this post and following along the code you should get a much
    better understanding of advanced aggregate and analytic functions in Polars. In
    particular, we’ve covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Basics of working with `pl.datetime`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.groupby()` aggregations with multiple arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of `.over()` to create aggregates over a specific group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of `.groupby_dynamic()` to generate aggregates over time windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of `.groupby_rolling()` to generate rolling aggregates over period
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Armed with this knowledge you should be able to perform almost every analytical
    task you have at the lightning speed.
  prefs: []
  type: TYPE_NORMAL
- en: You might have felt that some of this analysis felt very ad-hoc and you would
    be right. The next part is going to address exactly this topic — how to structure
    and create data processing pipelines. So stay tuned!
  prefs: []
  type: TYPE_NORMAL
- en: Not a Medium Member yet?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@antonsruberts/membership?source=post_page-----a22d986315aa--------------------------------)
    [## Join Medium with my referral link — Antons Tocilins-Ruberts'
  prefs: []
  type: TYPE_NORMAL
- en: Read every story from Antons Tocilins-Ruberts (and thousands of other writers
    on Medium). Your membership fee directly…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/@antonsruberts/membership?source=post_page-----a22d986315aa--------------------------------)
  prefs: []
  type: TYPE_NORMAL
