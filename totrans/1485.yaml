- en: Mastering Iterators and Generators in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/mastering-iterators-and-generators-in-python-ca30939d962](https://towardsdatascience.com/mastering-iterators-and-generators-in-python-ca30939d962)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Python for AI Engineers and Data Scientists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create Custom Iterators and Generators for Efficient Data Processing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://jvision.medium.com/?source=post_page-----ca30939d962--------------------------------)[![Joseph
    Robinson, Ph.D.](../Images/3117b65a4e10752724585d3457343695.png)](https://jvision.medium.com/?source=post_page-----ca30939d962--------------------------------)[](https://towardsdatascience.com/?source=post_page-----ca30939d962--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----ca30939d962--------------------------------)
    [Joseph Robinson, Ph.D.](https://jvision.medium.com/?source=post_page-----ca30939d962--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----ca30939d962--------------------------------)
    ·11 min read·Jan 17, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8c930dd3fe4ded63beb436fb0128f391.png)'
  prefs: []
  type: TYPE_IMG
- en: Visual created by the author.
  prefs: []
  type: TYPE_NORMAL
- en: This blog post delves into the world of iterators and generators in Python,
    providing an in-depth guide on how to use them to optimize your code and improve
    the performance and efficiency of your programs. The post covers the concepts
    of iterators and generators, including how they work and how to create custom
    them for specific use cases. The blog also explores advanced techniques for combining
    iterators and generators to achieve specific functionality and create complex
    data processing pipelines. Finally, we review a sample data loader in Keras used
    to train a deep network. With this guide, you will learn how to master the art
    of iterator and generator programming in Python and take your data processing
    capabilities to the next level.
  prefs: []
  type: TYPE_NORMAL
- en: Table of Contents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: · [Introduction](#62e9)
  prefs: []
  type: TYPE_NORMAL
- en: · [Understanding Iterators](#1957)
  prefs: []
  type: TYPE_NORMAL
- en: · [Creating Custom Iterators](#6fa2)
  prefs: []
  type: TYPE_NORMAL
- en: · [Understanding Generators](#5e47)
  prefs: []
  type: TYPE_NORMAL
- en: · [Creating Custom Generators](#39db)
  prefs: []
  type: TYPE_NORMAL
- en: · [Combining Iterators and Generators](#2adc)
  prefs: []
  type: TYPE_NORMAL
- en: · [Iterators and Generators for Deep Learning](#061e)
  prefs: []
  type: TYPE_NORMAL
- en: · [Conclusion](#d126)
  prefs: []
  type: TYPE_NORMAL
- en: · [Additional Resources](#94dd)
  prefs: []
  type: TYPE_NORMAL
- en: · [Contact](#d304)
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is a versatile and powerful programming language that offers a wide range
    of features for developers to work with. One of these features is the ability
    to create and use iterators and generators. Understanding and mastering the concepts
    of iterators and generators in Python can significantly enhance your coding skills
    and improve the performance of your programs.
  prefs: []
  type: TYPE_NORMAL
- en: Iterators are objects that can be iterated (looped) upon. They represent a data
    stream, and they implement the iterator protocol, which consists of the methods
    `iter()` and `next()`. On the other hand, generators are a type of iterator that
    allows you to declare a function that behaves like an iterator. They use the yield
    statement to return data and are a more memory-efficient way of working with large
    data sets.
  prefs: []
  type: TYPE_NORMAL
- en: This blog post will delve into Python's world of iterators and generators. We
    will explore the concepts of iterators and generators and how they work under
    the hood. We will also cover how to create custom iterators and generators and
    look at advanced techniques for combining them to achieve specific functionality
    in your programs. By the end of this post, you will have a solid understanding
    of how to use iterators and generators in Python to write efficient and effective
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Python, an iterator is an object that can be iterated (looped) upon. An object
    which will return data, one element at a time. They represent a data stream and
    implement the iterator protocol, which consists of the methods `iter()` and `next()`.
    The `iter()` method returns the iterator object itself, and the `next()` method
    returns the following item from the iterator.
  prefs: []
  type: TYPE_NORMAL
- en: To create an iterator in Python, we need to implement the iterator protocol,
    that is, the `iter()` and `next()` methods in a class. Once this is done, an instance
    of this class can be used as an iterator.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to know that every Python object that implements the `iter()`
    method can be considered an Iterable, but not all are Iterators. An `Iterator`
    has another method `next()`, which is used to fetch the next item.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Iteration Protocol must be followed by an object to be considered an iterator.
    The protocol requires an object to implement two methods: `iter()` and `next()`.
    The `iter()` method should return the iterator object, and the `next()` method
    should return the next item from the iterator. If there are no more items to return,
    the `next()` method should raise `StopIteration` exception.'
  prefs: []
  type: TYPE_NORMAL
- en: In summary, Iterators are objects that can be iterated over, and they implement
    the iterator protocol with the `iter()` and `next()` methods. They are the objects
    used to traverse a container's elements.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Custom Iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating custom iterators in Python allows you to define the behavior of an
    iterator for a specific use case. To create a custom iterator, you need to define
    a class that implements the iterator protocol with the `iter()` and `next()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: The iter() method should return the iterator object itself, typically by returning
    `self`. The `next()` method should return the following item from the iterator
    and raise the StopIteration exception when there are no more items to return.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of a simple custom iterator class that iterates over a range
    of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This iterator class takes a start and an end value as arguments and returns
    the numbers in the range [`start`, `end`] when iterated over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing the above class and creating an instance of it, we can use it
    as an iterator, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will print the numbers from 1 to 5.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom iterators for large data sets is an efficient way of processing
    them. By creating a custom iterator, you can control how the data is accessed
    and limit the amount of data loaded into memory at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, Creating custom iterators in Python allows you to define the behavior
    of an iterator for a specific use case by implementing the iterator protocol,
    `iter()` and `next()` methods. It is an efficient way of handling large data sets
    by controlling how the data is accessed and limiting the amount of data loaded
    into memory at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A generator is a type of iterator in Python that allows you to declare a function
    that behaves like an iterator. They use the yield statement to return data and
    are a more memory-efficient way of working with large data sets.
  prefs: []
  type: TYPE_NORMAL
- en: A generator function is defined like a regular function, but instead of using
    the `return` statement, it uses the `yield`. When the generator function is called,
    it returns a generator object but does not execute the function body immediately.
    The function body is executed only when its `next()` method is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of a simple generator function that generates the numbers
    in a range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This generator takes a start and an end value as arguments and generates the
    numbers in that range to iterate.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use this generator function as an iterator, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will print the numbers from 1 to 5.
  prefs: []
  type: TYPE_NORMAL
- en: Generators are a more memory-efficient way of working with big data because
    the entire data set is not stored in memory. Instead, it generates the data one
    item at a time each time `next()` is called.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, Generators are a type of iterator in Python that allows you to declare
    a function that behaves like an iterator. They use the `yield` statement to return
    data and are a more memory-efficient way of working with large data sets. They
    are defined like a regular function and return a generator object, an iterator,
    that executes the function body when the generator's `next()` method is called.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Custom Generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating custom generators in Python allows you to define the behavior of a
    generator for a specific use case. To create a custom generator, you need to define
    a function that uses the `yield` statement to return data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of a simple custom generator function that generates the
    Fibonacci sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This generator function takes an argument `n`, and generates the first *n* numbers
    of the Fibonacci sequence when iterated over.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use this generator function as an iterator, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This will print the first five numbers of the Fibonacci sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Generator-based coroutines are another way to use generators in Python, allowing
    you to write concurrent code synchronously without explicit locks, threading,
    or multiprocessing. Coroutines are functions that can be paused and resumed, and
    they use the `yield` statement to return data.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom generators for large data sets is an efficient way of processing
    them. Then, you can control how the data is accessed and limit the amount of data
    loaded into memory at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, Creating custom generators in Python allows you to define the behavior
    of a generator for a specific use case by defining a function that uses the `yield`
    statement to return a sample each time `next()` is called. Generator-based coroutines
    are another way to use generators. They allow you to write concurrent code synchronously
    without requiring explicit locks, threading, or multiprocessing.
  prefs: []
  type: TYPE_NORMAL
- en: Combining Iterators and Generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Iterators and generators in Python can be combined in various ways to achieve
    specific functionality in your programs. Complex data processing pipelines become
    easy to understand and maintain by chaining iterators and generators.
  prefs: []
  type: TYPE_NORMAL
- en: Iterator chaining is a technique where you chain multiple iterators to create
    a new iterator that iterates over the original iterators' elements. This can be
    done using the built-in function `itertools.chain()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will print the numbers from 1 to 9
  prefs: []
  type: TYPE_NORMAL
- en: Pipeline Iterators is a technique where you chain multiple iterators together,
    each performing a specific operation on the data and passing the result to the
    next iterator. This can be done using generator expressions, list comprehension,
    or functional tools like `map()` and `filter()`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will print the even squares of the numbers from 0 to 9.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Iterator Techniques can also be implemented to achieve specific functionality,
    like implementing decorators to add additional functionality to an iterator or
    using `zip()` and `enumerate()` to iterate over multiple sequences at once.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, Combining Iterators and Generators in Python can create complex
    data processing pipelines that are easy to understand and maintain. By chaining
    iterators and generators together, you can create new iterators that iterate over
    the elements of all the original iterators. Iterator chaining and pipeline iterators
    are the two most common ways of combining Iterators and Generators. Advanced Iterator
    Techniques like decorators, `zip()`, and `enumerate()` can also be used to achieve
    specific functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Iterators and Generators for Deep Learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One example of using iterators and generators in machine learning is working
    with large datasets that do not fit in memory. Instead of loading the entire dataset
    into memory, a custom generator can load the data one batch at a time. This saves
    memory and allows for processing the data incrementally, which can be helpful
    for online learning algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of using a generator to load a large dataset of images and
    labels for a deep-learning model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In machine learning, iterators and generators can improve your models'' performance
    and efficiency. Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data loading**: When working with large datasets, loading all the data into
    memory can be a problem. By using a generator to load the data, you can load only
    a small batch at a time and feed it to the model. This can be done by creating
    a generator function that reads the data from the disk, processes it, and yields
    it in small batches.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Data preprocessing**: When working with image or video data, it may be necessary
    to perform extensive preprocessing on the data before it can be fed to the model.
    Using a generator, you can preprocess the data on the fly and yield the preprocessed
    data to the model.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Data augmentation**: Data augmentation is a technique used to increase the
    size of the dataset by applying random transformations to the data. Using a generator,
    you can apply data augmentation on the fly and yield the augmented data to the
    model.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Model training**: When training a model, it is often necessary to iterate
    over the data multiple times. By using an iterator, you can repeat the iteration.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s an example of using a generator function to load and preprocess image
    data for a machine-learning model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This example uses the `ImageDataGenerator` class from Keras to load and preprocess
    the images. The `image_generator` function takes in the directory containing the
    images, target size, and batch size as arguments and returns an iterator that
    yields preprocessed pictures and labels. The `model.fit_generator` method is then
    used to train the model on the images by passing the iterator and the number of
    steps per epoch.
  prefs: []
  type: TYPE_NORMAL
- en: This way, the generator function loads the images from the disk, preprocess
    them, and yields them one batch at a time. The model can iterate over it, reducing
    memory usage and allowing it to work with large datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this blog post, we have delved into Python's world of iterators and generators.
    We have explored the concepts of iterators and generators and how they work under
    the hood. We have also covered how to create custom iterators and generators and
    looked at advanced techniques for combining them to achieve specific functionality
    in your programs.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen that iterators are objects that can be iterated over, and they
    implement the iterator protocol with the `iter()` and `next()` methods. On the
    other hand, generators are a type of iterator that allows you to declare a function
    that behaves like an iterator. They use the yield statement to return data and
    are a more memory-efficient way of working with large data sets.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom iterators and generators allows you to define the behavior of
    an iterator or generator for a specific use case. In addition, chaining iterators
    and generators together can create complex data processing pipelines that are
    easy to understand and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this post, you should have a solid understanding of how to use
    iterators and generators in Python to write efficient and effective code. We encourage
    you to try out the concepts discussed in this post and continue learning about
    Python's many other features and capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Additional resources like official documentation, books, tutorials, and videos
    can be found online to continue learning and mastering Iterators and Generators
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Additional Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python documentation on Iterators and Generators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://docs.python.org/3/tutorial/classes.html?source=post_page-----ca30939d962--------------------------------#iterators)
    [## 9\. Classes'
  prefs: []
  type: TYPE_NORMAL
- en: Classes provide a means of bundling data and functionality together. Creating
    a new class creates a new type of object…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: docs.python.org](https://docs.python.org/3/tutorial/classes.html?source=post_page-----ca30939d962--------------------------------#iterators)
  prefs: []
  type: TYPE_NORMAL
- en: '"Python Iterators: A Step-By-Step Guide" by Corey Schafer:'
  prefs: []
  type: TYPE_NORMAL
- en: '"[**How to Use Generators and yield in Python**](https://realpython.com/introduction-to-python-generators/)"
    by Real Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://realpython.com/introduction-to-python-generators/?source=post_page-----ca30939d962--------------------------------)
    [## How to Use Generators and yield in Python - Real Python'
  prefs: []
  type: TYPE_NORMAL
- en: Introduced with PEP 255, generator functions are a special kind of function
    that return a lazy iterator. These are…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: realpython.com](https://realpython.com/introduction-to-python-generators/?source=post_page-----ca30939d962--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: '"Python Iterators and Generators" by Trey Hunner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://treyhunner.com/2018/06/how-to-make-an-iterator-in-python/?source=post_page-----ca30939d962--------------------------------)
    [## How to make an iterator in Python'
  prefs: []
  type: TYPE_NORMAL
- en: I wrote an article sometime ago on the iterator protocol that powers Python's
    for loops. One thing I left out of that…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: treyhunner.com](https://treyhunner.com/2018/06/how-to-make-an-iterator-in-python/?source=post_page-----ca30939d962--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: '"[**What Are Python Generators?**](https://dbader.org/blog/python-generators)"
    by Dan Bader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://dbader.org/blog/python-generators?source=post_page-----ca30939d962--------------------------------)
    [## What Are Python Generators? - dbader.org'
  prefs: []
  type: TYPE_NORMAL
- en: Generators are a tricky subject in Python. With this tutorial you'll make the
    leap from class-based iterators to using…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: dbader.org](https://dbader.org/blog/python-generators?source=post_page-----ca30939d962--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: '"[**Python Iterators & Generators**](https://medium.com/geekculture/python-iterators-generators-ea63c5821550)**"**
    by [Kurtis Pykes](https://medium.com/u/5ba760786877?source=post_page-----ca30939d962--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/geekculture/python-iterators-generators-ea63c5821550?source=post_page-----ca30939d962--------------------------------)
    [## Python Iterators & Generators'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Key Differences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/geekculture/python-iterators-generators-ea63c5821550?source=post_page-----ca30939d962--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: '"Asynchronous iterators in python" by [Dinesh Kumar K B](https://medium.com/u/f3e3395e9bbf?source=post_page-----ca30939d962--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/geekculture/asynchronous-iterators-in-python-fdf55198287d?source=post_page-----ca30939d962--------------------------------)
    [## Asynchronous iterators in Python'
  prefs: []
  type: TYPE_NORMAL
- en: How to write async for loops in python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/geekculture/asynchronous-iterators-in-python-fdf55198287d?source=post_page-----ca30939d962--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: '"[**Iterator Functions**](https://itnext.io/iterator-functions-33265a99e5d1)**"**
    by [Thijmen Dam](https://medium.com/u/63098707ef90?source=post_page-----ca30939d962--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://itnext.io/iterator-functions-33265a99e5d1?source=post_page-----ca30939d962--------------------------------)
    [## Iterator Functions'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate Efficiently with Python's Built-in Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: itnext.io](https://itnext.io/iterator-functions-33265a99e5d1?source=post_page-----ca30939d962--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: '"[**Demystify Iterators and Generators in Python**](/demystify-iterators-and-generators-in-python-f21878c9897)**"**
    by[Lynn Kwong](https://medium.com/u/f649eccbbc3d?source=post_page-----ca30939d962--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/demystify-iterators-and-generators-in-python-f21878c9897?source=post_page-----ca30939d962--------------------------------)
    [## Demystify Iterators and Generators in Python'
  prefs: []
  type: TYPE_NORMAL
- en: Learn an efficient way to work with large datasets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/demystify-iterators-and-generators-in-python-f21878c9897?source=post_page-----ca30939d962--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Contact
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Want to Connect? Follow Dr. Robinson on [LinkedIn](https://www.linkedin.com/in/jrobby/),
    [Twitter](https://twitter.com/jrobvision), [Facebook](https://www.facebook.com/joe.robinson.39750),
    and [Instagram](https://www.instagram.com/doctor__jjj/). Visit my homepage for
    papers, blogs, email signups, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://www.jrobs-vision.com/?source=post_page-----ca30939d962--------------------------------)
    [## AI Research Engineer and Entrepreneur | Joseph P. Robinson'
  prefs: []
  type: TYPE_NORMAL
- en: Researcher & Entrepreneur Greetings! As a researcher, Dr. Robinson proposed
    and employed advanced AI to understand…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: www.jrobs-vision.com.](https://www.jrobs-vision.com/?source=post_page-----ca30939d962--------------------------------)
  prefs: []
  type: TYPE_NORMAL
