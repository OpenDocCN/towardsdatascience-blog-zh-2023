- en: Python Type Hinting with Literal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/python-type-hinting-with-literal-03c60ce42750](https://towardsdatascience.com/python-type-hinting-with-literal-03c60ce42750)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: PYTHON PROGRAMMING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'More powerful than it seems: use typing.Literal to create literal types'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@nyggus?source=post_page-----03c60ce42750--------------------------------)[![Marcin
    Kozak](../Images/d7faf62e48ed81dab5d8ad92819fff54.png)](https://medium.com/@nyggus?source=post_page-----03c60ce42750--------------------------------)[](https://towardsdatascience.com/?source=post_page-----03c60ce42750--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----03c60ce42750--------------------------------)
    [Marcin Kozak](https://medium.com/@nyggus?source=post_page-----03c60ce42750--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----03c60ce42750--------------------------------)
    ·15 min read·Nov 28, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0bdd431c39d954c0d9226fc02679e589.png)'
  prefs: []
  type: TYPE_IMG
- en: typing.Literal creates a type with selected choices. Photo by [Caleb Jones](https://unsplash.com/@gcalebjones?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll admit it: I wasn’t always a fan of `typing.Literal`, a form of creating
    literal types in Python. In fact, I not only undervalued literal types, but I
    completely ignored them, refusing to use them at all. For some reason, which remains
    unclear to me even today, I couldn’t find much practical value in literal types.'
  prefs: []
  type: TYPE_NORMAL
- en: How wrong I was. I was blind to the power of this simple tool, and my code suffered
    as a result. If you’ve been ignoring literal types like I did, I urge you to read
    this article. I hope to convince you that despite its simplicity, `typing.Literal`
    can be a very useful tool in your Python coding arsenal.
  prefs: []
  type: TYPE_NORMAL
- en: Even if you’ve already recognized the value of literal types, don’t stop reading.
    While we won’t delve into all the intricacies of `typing.Literal`, this article
    will provide a more comprehensive introduction than the official Python documentation,
    without getting as bogged down in details as [PEP 586](https://peps.python.org/pep-0586/).
  prefs: []
  type: TYPE_NORMAL
- en: Literal types are so straightforward that they can make code clearer and more
    readable than code without them. This simplicity is their both a strength and
    a weakness of `typing.Literal`, as it doesn’t offer any additional functionalities.
    However, I’ll show you how to implement additional functionality yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this article is to introduce `typing.Literal` and discuss its value
    in Python coding. Along the way, we’ll explore when to use `typing.Literal` —
    and, just as importantly, when not to.
  prefs: []
  type: TYPE_NORMAL
- en: Literal types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Literal types were introduced to the Python typing system by [PEP 586](https://peps.python.org/pep-0586/).
    This PEP provides a comprehensive exploration of the proposal behind literal types,
    serving as a rich source of information on the subject. In contrast, the official
    documentation for the `typing.Literal` type is intentionally concise, reflecting
    its straightforward nature. This article bridges the gap between these two resources,
    providing fundamental information about literal types while also delving into
    details that I consider crucial for the use cases discussed.
  prefs: []
  type: TYPE_NORMAL
- en: As explained in [PEP 586](https://peps.python.org/pep-0586/), literal types
    are particularly useful in scenarios where APIs return different types based on
    the value of an argument. I would broaden this statement by saying that literal
    types allow for the creation of a type that encompasses specific values, not necessarily
    all of the same type. This does not preclude the possibility of all values having
    the same type.
  prefs: []
  type: TYPE_NORMAL
- en: Literal types provide a remarkably simple approach to defining and utilizing
    a type with specific values as the only possible values. This simplicity far surpasses
    any alternative methods. While it’s true that you can achieve the same outcome
    using other methods, these alternatives often come with more complex implementations
    and potentially richer functionality. For instance, creating your own type (class)
    requires careful consideration of both design and implementation — something you
    can ignore altogether when creating a literal type instead.
  prefs: []
  type: TYPE_NORMAL
- en: Employing `typing.Literal` invariably presents a simpler solution, often significantly
    simpler, but at the expense of reduced functionality. Therefore, before making
    a decision, it’s essential to carefully weigh the advantages and disadvantages
    of both approaches. This article can assist you in making an informed choice.
  prefs: []
  type: TYPE_NORMAL
- en: Acceptable types in literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a `typing.Literal` type, you can use the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: a literal value of `int`, `bool`, `str` or `bytes`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: an enum value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`None`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Such types as `float` or instances of a custom (non-enum) class are unacceptable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Literal types: Use cases'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll now explore several use cases where I consider literal types to be an
    excellent choice, often the best option. We’ll also examine situations where alternative
    solutions may be more suitable. Each use case assumes the need for a type that
    accepts only specific values, not necessarily of the same type. `typing.Literal`
    does not create empty types, so `Literal[]` is not valid. It can, however, create
    literal types with a single value.
  prefs: []
  type: TYPE_NORMAL
- en: The use cases discussed below do not constitute an exhaustive list of scenarios.
    Instead, they serve as examples, and some may overlap. This non-exclusive list
    aims to showcase the range of opportunities that `typing.Literal` offers and to
    enhance understanding of this intriguing and valuable tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1: One value only'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As previously mentioned, you can employ a literal type when a variable accepts
    only a single value. While this might seem counterintuitive at first glance, [the](https://docs.python.org/3/library/typing.html#typing.Literal)
    `[typing.Literal](https://docs.python.org/3/library/typing.html#typing.Literal)`
    [documentation](https://docs.python.org/3/library/typing.html#typing.Literal)
    provides a relevant example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This function is designed for data validation and always returns `True`. In
    other words, if the validation fails, the function raises an error; otherwise,
    it returns `True`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theoretically, a type signature with a return value of the `bool` type, as
    shown below, would be acceptable to static checkers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: However, the function never returns `False`, making this type hint misleading
    and inaccurate. Using `bool` implies that the function can, depending on the situation,
    return either of the two Boolean values. When a function consistently returns
    only one of these values and never the other, using `bool` is misleading.
  prefs: []
  type: TYPE_NORMAL
- en: This is precisely where a literal type comes into play. Not only does it satisfy
    static checkers, but it also provides valuable information to users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 2: In a need of a static type'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When runtime type checking is not required, static types often provide the most
    effective solution. Therefore, if you need a type that accepts one or more specific
    values and your primary goal is to inform static checkers, creating the corresponding
    literal type is an excellent approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 3: A number of strings'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This use case encompasses a range of strings, such as modes, products, or colors.
    Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, literal types in this use case can hold two or more strings.
    Importantly, using `Literal` does not allow us to establish relationships between
    the individual values. For instance, we could create the following literal type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Does the order in which the values are provided matters? Before Python 3.9.1,
    it did:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ce3b836d0deb910e815dfa8758489018.png)'
  prefs: []
  type: TYPE_IMG
- en: Before Python 3.9.1, the order of values in a literal type mattered. Image by
    author
  prefs: []
  type: TYPE_NORMAL
- en: 'but ever since it doesn’t:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ac0450355fd1cf468b1b434a124fb7b2.png)'
  prefs: []
  type: TYPE_IMG
- en: As of Python 3.9.1, the order of values in a literal type doesn’t matter. Image
    by author
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, what matters are the possible choices, not their relationships.
    If utilizing the order of values is essential, consider employing a different
    type, not a literal one. One solution is to leverage an enumeration type, utilizing
    the `enum.Enum` class; we’ll delve into this concept soon, in a dedicated article.
  prefs: []
  type: TYPE_NORMAL
- en: '***A word of caution***: Python 3.11 and newer introduce `typing.LiteralString`.
    This constitutes a distinct tool, as unlike `typing.Literal`, it serves as a type
    itself, not a tool for creating types. In this article, we’re exploring the creation
    of literal types, and I wouldn’t want to introduce confusion with this slightly
    different yet related tool. If you’re interested in learning more, visit the Appendix
    at the end of the article. However, let’s set this topic aside for now. The key
    takeaway is that `typing.LiteralString` is not a substitute for `typing.Literal`
    for strings.'
  prefs: []
  type: TYPE_NORMAL
- en: '`typing.LiteralString` is *not* a replacement for `typing.Literal` for strings.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Example 4: Multiple values of the same type'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This example extends the previous one to encompass a broader range of data
    types. Just as we employed literal types for strings, we can apply them to most
    other data types as well. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned above, you can use a literal value of `int`, `bool`, `str` or `bytes`,
    an enum value and `None.`
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 5: Combining values of various types'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This represents the most general form of a literal type. You can combine objects
    of any type, and it will function correctly. This bears some resemblance to using
    the `typing.Union` type, but unlike the typical `Union` use case, we are combining
    objects rather than types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the difference: A common Union use case might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'while a literal type combining objects of `int` and `str` types could be as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some other examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create the following type: `Literal[True, False, None]`. It’s similar
    to the `OptionalBool` type described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/pythoniq/an-optionalbool-type-for-python-none-false-or-true-7667e9cc6dd8?source=post_page-----03c60ce42750--------------------------------)
    [## An OptionalBool Type for Python: None, False or True'
  prefs: []
  type: TYPE_NORMAL
- en: Use OptionalBool instead of Optional[bool].
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/pythoniq/an-optionalbool-type-for-python-none-false-or-true-7667e9cc6dd8?source=post_page-----03c60ce42750--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: The `OptionalBool` type described in the above article is far more complex than
    the corresponding one based on `Literal`, the latter being both easier to use
    and understand but also having significantly poorer functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next three examples from the code block above are also interesting. They
    show that you can create combinations of two (or more, for that matter) literal
    types. Here, `YesOrNo` is a literal type that joins two other literal types, that
    is, `Positives` and `Negatives`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2427259b1f9dc32dd8a2761dcfd8c163.png)'
  prefs: []
  type: TYPE_IMG
- en: Joining two literal types in Python 3.9.1 and newer. Imagine by author
  prefs: []
  type: TYPE_NORMAL
- en: 'Do remember, however, that this wouldn’t work the same way before Python 3.9.1
    (we saw it before, where we discussed the order of literals in type definition):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/935bad7f39f0d05985f7503d3600c7c7.png)'
  prefs: []
  type: TYPE_IMG
- en: Joining two literal types before Python 3.9.1\. Imagine by author
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 6: Runtime m**embershi**p checking'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding examples, we focused exclusively on static applications of
    literal types. However, this does not preclude their use during runtime, even
    though this deviates from the intended purpose of Python type hints. Here, I’ll
    demonstrate that you can perform runtime membership checks for literal types when
    the need arises. In other words, you can verify whether a given value belongs
    to the set of possible choices for a literal type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Frankly, I believe this single capability elevates `typing.Literal` to a much
    more powerful tool. While it strays from the conventional usage of literal types
    (static code checking), it isn’t a hack. It’s a legitimate function of the typing
    module: `typing.get_args()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example will best illustrate this concept. First, let’s define a literal
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Tens` type encompasses various representations of the number `10`. Now,
    let’s define a function that validates whether an object has the type of `Tens`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'A few remarks about the function:'
  prefs: []
  type: TYPE_NORMAL
- en: It accepts any object and returns `Optional[Tens]`, indicating that if `obj`
    is a valid member of `Tens`, the function will return it; otherwise, it will return
    `None`. This is why `typing.Optional` is used (see [this article](/python-types-optional-can-mean-mandatory-8e3b7ac2e805)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The check is performed using the `typing.get_args()` function. For a literal
    type, it returns all its possible values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here’s where it gets interesting. From a dynamic perspective, the last line
    of the function (`return None`) is redundant, as an absent `None` return is implicitly
    interpreted as a `None` return. However, `mypy` does not accept [implicit None
    returns](https://mypy.readthedocs.io/en/stable/kinds_of_types.html#optional-types-and-the-none-type),
    as illustrated in the image below.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/89b9afea9174de2519a6b06455018775.png)'
  prefs: []
  type: TYPE_IMG
- en: Mypy does not accept an implicit None return. Screenshots from Visual Studio
    Code. Image by author
  prefs: []
  type: TYPE_NORMAL
- en: According to [the](https://mypy.readthedocs.io/en/stable/kinds_of_types.html#disabling-strict-optional-checking)
    `[mypy](https://mypy.readthedocs.io/en/stable/kinds_of_types.html#disabling-strict-optional-checking)`
    [documentation](https://mypy.readthedocs.io/en/stable/kinds_of_types.html#disabling-strict-optional-checking),
    you can disable strict `None` checking using the `[--no-strict-optional](https://mypy.readthedocs.io/en/stable/command_line.html#cmdoption-mypy-no-strict-optional)`
    command-line option. Think twice if you want to use this option. I prefer to always
    explicitly declare whether a particular type accepts `None` or not. Disabling
    strict checking means that any type is assumed to accept `None`, which can lead
    to unexpected behavior and make code more difficult to understand and maintain.
    While I am not a great fan of very thorough type hints, using the `[--no-strict-optional](https://mypy.readthedocs.io/en/stable/command_line.html#cmdoption-mypy-no-strict-optional)`
    flag is in my eyes an oversimplification, because `None` is too important a sentinel
    value to ignore it just like that.
  prefs: []
  type: TYPE_NORMAL
- en: If you do need to disable strict checking in specific situations, remember that
    when you do so but someone else doesn’t, they may encounter many static errors
    throughout the code. Maintaining consistent type checking settings throughout
    a codebase is a good general practice.
  prefs: []
  type: TYPE_NORMAL
- en: Literals versus enumerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While reading the previous section, did you notice that some literal types resemble
    enumerations types? Indeed, they do share some similarities, but literal types
    lack the natural order of values inherent in enumerations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compare these two type definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you primarily noticed the difference in syntax, be aware that you can also
    define enumeration types using static factory methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: So, the definition syntax isn’t the key distinction between literal types and
    enumerations. Firstly, literal types are static types with minor dynamic functionality,
    while enumeration types offer both static and dynamic capabilities, making them
    more versatile. If you require more than what literal types provide, enumerations
    are likely the better choice.
  prefs: []
  type: TYPE_NORMAL
- en: This article doesn’t delve into the intricacies of Python enumerations. However,
    the following table compares the two tools. Before proceeding, analyze the table
    and observe that `typing.literal` offers a subset of `enum.Enum`'s features.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c1da3eae32e0978110d2f4ad2870d549.png)'
  prefs: []
  type: TYPE_IMG
- en: Comparison of enum.Enum and typing.Literal. Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Despite their versatility, literal types excel in simplicity, brevity, and readability.
    While Python enumerations are also straightforward and readable, literal types
    offer an even higher level of clarity and conciseness.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The central message of this article is that `typing.Literal` and literal types
    are powerful tools that offer more capabilities than one might initially assume.
    Their simplicity conceals their depth and versatility. As I mentioned at the beginning
    of the article, I had underestimated the value of this tool for quite some time.
    However, today I recognize it — and literal types in general — as a powerful yet
    straightforward mechanism for enhancing Python code conciseness while maintaining
    static correctness.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, using other type hints to express the same concept as a literal type
    can lead to confusion, even if static checkers don’t raise any errors. When all
    you need is a static type to be checked by static checkers, `typing.Literal` should
    be your go-to choice. Its usage is straightforward and doesn’t require excessive
    code: just the type definition, which typically takes one or more lines depending
    on the number of literals included in the type.'
  prefs: []
  type: TYPE_NORMAL
- en: For scenarios requiring more advanced dynamic functionality, enumerations may
    be a better fit. They provide an additional layer of safety at runtime by preventing
    invalid value assignments. Literal types, on the other hand, do not offer this
    inherent safeguard, although it can be implemented as demonstrated with the `is_ten()`
    function above. However, this safeguard would need to be applied every time a
    user provides a value of this type.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, remember about literal types and `typing.Literal`. Incorporate them
    into your Python code to achieve simplicity and readability. I’d say that in Python,
    `typing.Literal` achieves one of the highest usefulness-to-complexity ratios,
    making it simultaneously highly useful and remarkably simple.
  prefs: []
  type: TYPE_NORMAL
- en: Appendix 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: typing.LiteralString
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python 3.11 and newer introduced the `typing.LiteralString` type. Despite its
    name, it is not a direct replacement for `typing.Literal` for strings. To avoid
    unnecessary confusion, let’s not delve into this type in detail here. Instead,
    let’s briefly outline the fundamental aspects of this type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike `typing.Literal`, which serves as a mechanism for creating literal types,
    `typing.LiteralString` is a type itself. It can be used to specify that a variable
    should hold a literal string, as demonstrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Note what the documentation says:'
  prefs: []
  type: TYPE_NORMAL
- en: Any string literal is compatible with `*LiteralString*`, as is another `*LiteralString*`.
    However, an object typed as just `*str*` is not.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: And
  prefs: []
  type: TYPE_NORMAL
- en: '`*LiteralString*` is useful for sensitive APIs where arbitrary user-generated
    strings could generate problems. For example, the two cases above that generate
    type checker errors could be vulnerable to an SQL injection attack.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This brief overview should suffice for our current discussion. If you’re interested
    in exploring this type further, refer to [PEP 675](https://peps.python.org/pep-0675/),
    which introduced this literal type.
  prefs: []
  type: TYPE_NORMAL
- en: Appendix 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Defining literal types using iterables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '***Warning***: This section presents a hack that does not work statically.
    So, if your only aim is to create a static type, do *not* use this hack. It’s
    rather an interesting piece of information than something to be used in production
    code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are not familiar with `typing.Literal`, `Literal[]` might resemble indexing,
    and `Literal[1, 2, 3]` might appear similar to a list. As a result, you might
    be tempted to use a list comprehension, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The error message indicates that this is not valid syntax. This is because `typing.Literal`
    is not meant to be used as a list comprehension. Instead, it is used to specify
    particular values the type accepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'But look here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: No error? So, we’re fine, aren’t we?
  prefs: []
  type: TYPE_NORMAL
- en: 'No, we aren’t. Look at what `OneToTen` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this definition worked but not in the way we intended. `OneToTen`
    is a literal type with only one value: a list of integers from 1 to 10\. Not only
    is a list not an acceptable literal type, this is also not quite what we were
    hoping for!'
  prefs: []
  type: TYPE_NORMAL
- en: 'But don’t worry, we’re not done here. There’s a trick that will help us achieve
    the desired outcome. We can access the possible values of a literal type in two
    ways. One method, which we’ve already seen in action, is the `get_args()` function.
    Another method is to use the `.__args__` attributeof the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'While `get_args()` allows us to get a literal type’s values, we can leverage
    the `.__args__` attribute to update the type. Look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Ha! This is the trick I mentioned above. We can call it the `.__args__` trick.
  prefs: []
  type: TYPE_NORMAL
- en: 'Above, I used a list, but it doesn’t matter what type of iterable you’ll use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'I assigned a list literal to `OneToTen.__args__`, but you can do the same in
    any other way, like using a list comprehension or [another comprehension](https://medium.com/towards-data-science/a-guide-to-python-comprehensions-4d16af68c97e):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You do have to be careful, however, as not always will `Literal` behave in
    a predictable way. For instance, it will work like above with `range()` but won’t
    work with a generator expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Actually, while experimenting with generator expressions used with `Literal`,
    I noticed that it did work several times… I don’t know why: normally it doesn’t
    work that way, so out of say two dozen times I tried it, it worked only 2 or 3
    times. That’s something I’m worried about as I hate situations in which a programming
    language behaves in an unpredictable way — even if in a hack.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Having troubles believing this? Look at this screenshot from Python 3.11:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1be1895fe7235dfc28f471268039feb2.png)'
  prefs: []
  type: TYPE_IMG
- en: Unpredictable behavior of typing.Literal.__args__ used with generator expressions.
    Screenshot from Python 3.11\. Image by author
  prefs: []
  type: TYPE_NORMAL
- en: 'Just so you know, `A` was not used before, but `OneToTen` was — on the other
    hand, this should not change a thing. Besides, the next time I tried this, this
    time for a new name, `B`, it didn’t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/adc7cd43e146f24e89630055329c7534.png)'
  prefs: []
  type: TYPE_IMG
- en: A different behavior of typing.Literal.__args__ with a generator expression
    than before. Screenshot from Python 3.11\. Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Hence, unless you’re ready to accept unpredictable behavior of Python, don’t
    use `typing.Literal` with generator expressions before this issue is solved. But
    there’s nothing to worry about, as generator expressions are typically used to
    overcome memory issues — and creating a literal type doesn’t seem like something
    that should lead to such problems. Hence, instead of using a generator to create
    a literal type, you can make a list out of it and use it.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned at the beginning of this section, you should avoid using the `.__args__`
    hack. It will work dynamically, but `mypy` will not accept it. It’s good to know
    this, as it extends your knowledge of `typing` type hints, but it’s not something
    you should use in production code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks for reading. If you enjoyed this article, you may also enjoy other articles
    I wrote; you will see them [here](https://medium.com/@nyggus). And if you want
    to join Medium, please use my referral link below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/@nyggus/membership?source=post_page-----03c60ce42750--------------------------------)
    [## Join Medium with my referral link - Marcin Kozak'
  prefs: []
  type: TYPE_NORMAL
- en: As a Medium member, a portion of your membership fee goes to writers you read,
    and you get full access to every story…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/@nyggus/membership?source=post_page-----03c60ce42750--------------------------------)
  prefs: []
  type: TYPE_NORMAL
