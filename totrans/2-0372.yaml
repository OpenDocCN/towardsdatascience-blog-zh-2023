- en: Best Practices for Python Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/best-practices-for-python-development-bf74c2880f87](https://towardsdatascience.com/best-practices-for-python-development-bf74c2880f87)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Set up and use a professional Python repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@hrmnmichaels?source=post_page-----bf74c2880f87--------------------------------)[![Oliver
    S](../Images/b5ee0fa2d5fb115f62e2e9dfcb92afdd.png)](https://medium.com/@hrmnmichaels?source=post_page-----bf74c2880f87--------------------------------)[](https://towardsdatascience.com/?source=post_page-----bf74c2880f87--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----bf74c2880f87--------------------------------)
    [Oliver S](https://medium.com/@hrmnmichaels?source=post_page-----bf74c2880f87--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----bf74c2880f87--------------------------------)
    ·8 min read·Feb 8, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/89bfd14b512226b92a7b815046f0d5c8.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Christina @ wocintechchat.com](https://unsplash.com/@wocintechchat?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
    on [Unsplash](https://unsplash.com/photos/EkeThvO9VfM?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this post is sharing best practises for Python development — in
    particular how to set up, use, and manage a Github repository, which adheres to
    professional industry standards. We will discuss useful tools to keep your code
    clean and bug-free, show how to set up the repository and include previously introduced
    tools for automated CI (continuous integration) checks — and finally put it all
    together in a sample project. Note I am not claiming this list is complete or
    the only possible way to do these things. However, I want to share my professional
    experience from working as a software engineer, and can confirm that many large
    software companies follow a similar pattern.
  prefs: []
  type: TYPE_NORMAL
- en: With that said, let’s dive straight into the meaty part — I hope you find this
    useful! You can find full code for this post [here](https://github.com/hermanmichaels/python-sample)
    and follow along as we go.
  prefs: []
  type: TYPE_NORMAL
- en: Used Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section we’ll present tools used in this article.
  prefs: []
  type: TYPE_NORMAL
- en: poetry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Poetry is a neat tool to manage Python versions and dependencies. It makes it
    easy to control and fix a Python version, and manage dependencies in a central
    way. Of all the ways of doing this, I recommend poetry. I wrote a [lengthier introduction
    about this](https://medium.com/@hrmnmichaels/dependency-management-with-poetry-f1d598591161)
    in another post, but will summarise the gist here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Core of poetry’s dependency management is the `pyproject.toml` file. For our
    project, it starts like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We can see a header defining and exposing certain project properties, followed
    by a paragraph defining needed dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: As a “user”, we just have to execute `poetry install` in our terminal, and poetry
    will automatically create a Python environment with all dependencies installed.
    We can then enter this via `poetry shell`.
  prefs: []
  type: TYPE_NORMAL
- en: Developers, after adding a new dependency, run `poetry update`. This will generate
    or update the `poetry.lock` file, which you can kind of picture as a binary representation
    of above specified dependencies. It will need to be added to the repository, too
    — and above described process of installing requirements actually uses this file.
  prefs: []
  type: TYPE_NORMAL
- en: isort
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PEP 8](https://peps.python.org/pep-0008/), the styleguide for Python, also
    defines [how to order imports](https://peps.python.org/pep-0008/#imports). The
    recommendation is to create the following groups:'
  prefs: []
  type: TYPE_NORMAL
- en: Standard library imports (e.g. `os`, `sys`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Related third party imports (e.g. `numpy`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Local, project-specific imports (e.g. different files of the same project)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside these groups, imports should be sorted alphabetically.
  prefs: []
  type: TYPE_NORMAL
- en: '[isort](https://pycqa.github.io/isort/) is a tool which removes the necessity
    of remembering and doing this ourselves. Conveniently, isort and most of the tools
    presented in the next sections work well with poetry, and we even set their settings
    in the `pyproject.toml` file. For our use case, we set the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the Python version we tell isort that we will be working with
    the formatter black (see next section), and define how imports which are too long
    for a single line will be [re-formatted](https://pycqa.github.io/isort/docs/configuration/multi_line_output_modes.html).
  prefs: []
  type: TYPE_NORMAL
- en: black
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[black](https://black.readthedocs.io/en/stable/) is a code formatter for Python.
    Running it formats the code according to certain conventions. By having all developers
    use it, we enforce a specific, uniform style to our code. Think about line indents,
    number of blank lines after functions, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Settings are also managed by poetry, and we simply set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: I.e. a maximal line length of 80, and the target Python version.
  prefs: []
  type: TYPE_NORMAL
- en: flake8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[flake8](https://flake8.pycqa.org/en/latest/) is a code linter. Code linters
    and code formatters are very related, however, linters check the adherence of
    specific styles and guidelines, but do not format it. flake8 does several things,
    one is checking against the previously mentioned PEP 8 standard.'
  prefs: []
  type: TYPE_NORMAL
- en: mypy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[mypy](https://mypy.readthedocs.io/en/stable/) is a static type checker for
    Python. As you (most likely) know, Python is a [dynamically typed language](https://en.wikipedia.org/wiki/Type_system#DYNAMIC),
    meaning variable types are inferred at runtime (as opposed to e.g. C++). This
    flexibility we all love also comes with drawbacks, such as the higher probability
    of making mistakes, without a compiler or similar to act as a first line of defence.
    Thus, in recent years many efforts are actually focused on making type checking
    in Python stricter. mypy is such a type checker, meaning it will check your code,
    and see if you are using variables correctly. Most of this is automatic, however,
    but you can also make certain types explicit by annotating them (which is anyways
    recommended for function parameters and return types, for visibility).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can annotate function arguments and return types as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'mypy would then complain if we tried calling the function with wrong arguments,
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We manage mypy settings in a separate `mypy.ini` file. This is mostly needed
    because some external dependencies cannot be type-checked, and we need to exclude
    them from being checked (although we can fix some).
  prefs: []
  type: TYPE_NORMAL
- en: pytest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unit testing is essential for any somewhat professional software project, and
    recommend for all. We will be using [pytest](https://docs.pytest.org/en/7.2.x/),
    which is preferred by many Python developers. I wrote a [lengthier introduction
    in another post](https://medium.com/@hrmnmichaels/unit-testing-with-pytest-5c59cdf89529),
    with some follow-ups, so I’d like to refer there (or of course any other great
    tutorial out there!) if you’re not familiar with it.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing helps us catch bugs, and thus keep the quality of written code
    at a high level.
  prefs: []
  type: TYPE_NORMAL
- en: Github Actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Github Actions](https://docs.github.com/en/actions) allow automatising and
    running certain steps in the repository — all in the spirit of continuous integration.
    With them, we can create workflows to be run for certain events, such as pull
    requests (PRs). The workflow we will use here is actually an accumulation of above
    introduced tools — i.e. for every opened PR it will run things like formatting,
    linting, type checking and unit tests, and we expect all this to pass before merging
    — thus, protecting our main branch from committing any unclean or faulty code!'
  prefs: []
  type: TYPE_NORMAL
- en: Also for this topic I would like to refer to a [previous post of mine](https://medium.com/gitconnected/introduction-to-github-actions-e742b5370bfa)
    for an introduction.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This post will not be an introduction to version control systems or setting
    up Github repositories from scratch. Instead some basic knowledge is expected,
    and I would refer to any other tutorial out there, such as the [official Github
    one](https://docs.github.com/en/get-started/quickstart/hello-world). Here we will
    only talk about settings in Git which basically any professional software repository
    will have.
  prefs: []
  type: TYPE_NORMAL
- en: 'Broadly speaking, this is only one: protecting the main branch. We don’t want
    anybody to push to this without checks, and in particular require two things:
    approval from other developers, and passing of the CI tests we established. To
    do so, go to your repository and select “Settings”, then “Branches”:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d850fbdecfd43ef7f392c86f9d976d51.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot by author
  prefs: []
  type: TYPE_NORMAL
- en: 'Then add a branch protection rule for your main branch, and enable:'
  prefs: []
  type: TYPE_NORMAL
- en: Require a pull request before merging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Require approval (you can then select the number of necessary approvals)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Require status checks to pass before merging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Putting it All Together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This introduces all needed themes. Now we will put it together, set up a sample
    repository and show a workflow every developer should follow.
  prefs: []
  type: TYPE_NORMAL
- en: Sample Project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our sample project will have a folder `utils`, containing `math_utils.py` and
    a related unit test file (`math_utils_test.py`). In `math_utils` we will be re-implementing
    an exponentiation function for demonstrative purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Thus, `exponentiate(2, [1, 2, 3])` will return `[2, 4, 8]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We test the correctness of the function in the test file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In our main file (`main.py`), we will use this to generate the first 10 powers
    of 2, and plot this with `matplotlib`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pyproject.toml` file for this project looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, we exclude `matplotlib` from mypy checking to prevent errors by
    generating the following `mypy.ini` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Github Workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We then define the following Github Actions workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Thus, this workflow is run for every new PR, and for every PR merged to main.
  prefs: []
  type: TYPE_NORMAL
- en: 'It has the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: It checks out the repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It installs Python 3.10.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It installs poetry, and installs our dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It then runs all our installed checks (note `poetry run X` is identical to
    entering the poetry environment via `poetry shell` and then executing `X`). In
    particular, these are: sort imports via isort, format code with black, lint with
    flake8, check types with mypy, and run pytest.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local Developer Workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we describe the workflow every developer should do occasionally, and especially
    before raising a PR (sorry about the overloading of “workflow” — in the section
    above denoting the Github concept of grouping steps in a workflow, whereas here
    it simply describes a list of steps to execute by the developer).
  prefs: []
  type: TYPE_NORMAL
- en: 'In essence, we don’t want to rely on and stress CI with finding all of our
    errors, but push PRs as “clean” as possible: this means simply running all steps
    run on CI by ourselves locally before pushing. This is achieved via:'
  prefs: []
  type: TYPE_NORMAL
- en: 'run isort to sort the imports: `isort .`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'run black to format the code: `black .`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'run flake8 to check the code: `python -m flake8`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'run mypy for type checking: `mypy .` (note this might take quite a while the
    first time)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'run all unit tests: `python -m pytest`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this post we described useful tools to help manage, organize, and keep Python
    code in good shape and up to professional standards. We then showed how to set
    up a Git repository for versioning and sharing this code, and in particular how
    to use the previously introduced tools in CI: i.e. running certain checks to prevent
    any unclean or faulty commits to the main branch. Finally, we showed how developers
    can run all these tools locally first, to minimize the risk of CI failing.'
  prefs: []
  type: TYPE_NORMAL
- en: I hope this post will be useful for your future private and professional projects.
    Let me know if there are any awesome tools you or your company are using, or you
    feel I missed something. Thanks for reading!
  prefs: []
  type: TYPE_NORMAL
