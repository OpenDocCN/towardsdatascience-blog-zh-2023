- en: Local Search with Simulated Annealing from Scratch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/local-search-with-simulated-annealing-from-scratch-9f8dcb6c2e06](https://towardsdatascience.com/local-search-with-simulated-annealing-from-scratch-9f8dcb6c2e06)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/99361b24f6101d25e65a3ea1a9ea55ed.png)'
  prefs: []
  type: TYPE_IMG
- en: Temperature, an important part of simulated annealing. Image by Dall-E 2.
  prefs: []
  type: TYPE_NORMAL
- en: Generic Python code with 3 examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://hennie-de-harder.medium.com/?source=post_page-----9f8dcb6c2e06--------------------------------)[![Hennie
    de Harder](../Images/3e4f2cccd6cb976ca3f8bf15597daea8.png)](https://hennie-de-harder.medium.com/?source=post_page-----9f8dcb6c2e06--------------------------------)[](https://towardsdatascience.com/?source=post_page-----9f8dcb6c2e06--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----9f8dcb6c2e06--------------------------------)
    [Hennie de Harder](https://hennie-de-harder.medium.com/?source=post_page-----9f8dcb6c2e06--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----9f8dcb6c2e06--------------------------------)
    ·11 min read·Apr 12, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '**In some of my previous posts, I explained heuristics and how you can use
    them to find good quality solutions for a mathematical optimization problem. In
    this post, I will provide generic Python code for local search together with simulated
    annealing. Besides generic code, there are implementations for three classic example
    problems: the traveling salesman problem, the knapsack problem and the Rastrigin
    function.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A short refresher: local search is a heuristic that tries to improve a given
    solution by looking at neighbors. If the objective value of a neighbor is better
    than the current objective value, the neighbor solution is accepted and the search
    continues. Simulated annealing allows worse solutions to be accepted, this makes
    it possible to escape local minima.'
  prefs: []
  type: TYPE_NORMAL
- en: Simulated Annealing Generic Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code works as follows: we are going to create four code files. The most
    important one is `sasolver.py`, this file contains the generic code for simulated
    annealing. The problems directory contains three examples of optimization problems
    that we can run to test the SA solver.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the folder structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/19276977dd1151465bd43f197168a7da.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For solving a problem with simulated annealing, we start to create a class
    that is quite generic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This file is `sasolver.py`. It takes a problem as input, and then you can solve
    the problem with simulated annealing, `run_sa()`. There are different ways to
    handle cooling, implemented in `_calc_temperature`. The acceptance value is calculated
    based on the metropolis acceptance criterion.
  prefs: []
  type: TYPE_NORMAL
- en: By modifying the `problem = 'tsp'` line, (below `if __name__ == '__main__':`,)
    it’s possible to select another problem (replace `tsp` by `knapsack` or `rastrigin`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to have three methods in the example problems to make this code work:'
  prefs: []
  type: TYPE_NORMAL
- en: '`baseline_solution()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This method creates the first solution (starting point) for a problem.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`score_solution(solution)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `score_solution` method calculates the objective value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`select_neighbor(solution)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to apply local moves to the solutions and select a neighbor, this will
    be implemented in this method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We are going to implement these three methods for three problems: traveling
    salesman, knapsack and the Rastrigin function.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 1\. Traveling Salesman
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first problem we are going to look at is the traveling salesman problem.
    In this problem, there are locations that need to be visited. The goal is to minimize
    the distance traveled. Below you can see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/61bf128176b8d5f58ccc0c01a2e32e6e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Example: 10 locations we want to visit and minimize the distance. Image by
    author.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this problem, the baseline solution is created by visiting the locations
    in sequence (0 to 9). For the example, it gives us this route:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e69788d5943834003288e892c63f421e.png)'
  prefs: []
  type: TYPE_IMG
- en: Baseline solution. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: 'This doesn’t look optimal, and it isn’t. A local move is defined by swapping
    two locations. The score of the solution is the distance we need to travel. After
    running simulated annealing, this is the final solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e4329fe5f88b8e491a07211ff9bc23c6.png)'
  prefs: []
  type: TYPE_IMG
- en: Final solution. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: That looks better!
  prefs: []
  type: TYPE_NORMAL
- en: For small problems, this works okay (still not recommended). For larger ones,
    there are better solutions and algorithms available, for example the [Lin-Kernighan
    heuristic](https://en.wikipedia.org/wiki/Lin–Kernighan_heuristic). What also helps
    is a better starting solution, e.g. a greedy algorithm.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Example 2\. Knapsack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The knapsack problem is a classic one, but for those who don’t know it, here
    follows an explanation.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you are in a cave full of beautiful treasures. Due to some unforeseen
    circumstances the cave is collapsing. You have time to fill your knapsack with
    treasures and then you need to run away to safety. Of course, you want to take
    the items with you that together bring most value. What items should you take?
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7eeca27fb41e6bb31a04a81cafe19382.png)'
  prefs: []
  type: TYPE_IMG
- en: The knapsack problem. The knapsack has a capacity of 50\. What items should
    you select to maximize the value? Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: The data you need to have for solving this problem is the capacity of the knapsack,
    the capacity needed for the items and the value of the items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Below the code that defines this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The baseline solution selects an item at random until the knapsack is full.
    The solution score is the sum of values of the items in the knapsack, multiplied
    by -1\. This is necessary because the SA solver minimizes a given objective. In
    this situation, there are three local moves possible: adding an item, removing
    an item or swapping two items. This makes it possible to reach every solution
    possible in solution space. If we swap an item, we need to check if the new solution
    is feasible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next image you can see a sample run log file. There are 10 items we
    need to choose from. On top the item values, below the capacity the items take,
    and on the third line the value densities (item value divided by item capacity).
    Then the solution process starts. The solution contains the index number(s) of
    the selected items. In the final solution, items 4, 5 and 8 are selected (counting
    starts at 0):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ba0a1f2d7da4401a323d42db75705891.png)'
  prefs: []
  type: TYPE_IMG
- en: Example 3\. Rastrigin Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A function that is used often to test optimization algorithms, is the [Rastrigin
    function](https://en.wikipedia.org/wiki/Rastrigin_function). In 3D it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/10d1ece40cf2ce4c17316cfac04ced54.png)'
  prefs: []
  type: TYPE_IMG
- en: Rastrigin function 3D plot. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: 'It has many local optima. The goal is to find the global minimum, which is
    at coordinate (0, 0). It is easier to see in a contour plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ef9a64d0d5e3714ed5f343310867fe2a.png)'
  prefs: []
  type: TYPE_IMG
- en: Contour plot of the Rastrigin function. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: The landscape consists of many local optima with the highest ones in the four
    corners and the lowest ones in the center.
  prefs: []
  type: TYPE_NORMAL
- en: We can try to find the global minimum with simulated annealing. This problem
    is continuous instead of discrete, and we want to find the values for *x* and
    *y* that minimize the Rastrigin function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Rastrigin function is defined with a *n*-dimensional domain as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/088583f7044b989debb8483c4298b7fe.png)'
  prefs: []
  type: TYPE_IMG
- en: Let’s try to find the optimum for the function with three dimensions (*x*, *y*,
    and *z*). The domain is defined by *x* and *y*, so the problem is exactly as the
    plots above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For the baseline solution, we select a random float for *x* and *y* between
    -5.12 and 5.12\. The score of the solution is equal to *z* (the outcome of the
    Rastrigin function). A neighbor is selected by taking a step into a random direction
    with a step size set to 0.1\. The feasibility check is done to make sure we stay
    in the domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'A log of a run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4f4ce8bca0e645b30f83f4d81839969b.png)'
  prefs: []
  type: TYPE_IMG
- en: The final solution comes really close to the optimum.
  prefs: []
  type: TYPE_NORMAL
- en: 'But watch out, if you run the algorithm with more dimensions, it’s not guaranteed
    that you find the optimum:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/01252f63bbbdc128f57e7ae9e96c0fbb.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the final solution is a local optimum instead of the global
    one. It find goods coordinates for the first two variables, but the third one
    is equal to 0.985, which is far away from 0\. It’s important to verify the results
    you get. This specific example will work well by finetuning the SA parameters,
    but for more dimensions you should probably use another optimization technique
    that performs better.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this post, we coded the implementation of simulated annealing. With three
    examples, you have an understanding of different possibilities with it. You only
    need to implement three methods for a new problem to make it work, these are `baseline_solution`,
    `score_solution` and `select_neighbor`. Of course, this implementation is a basic
    one, and if you want to use it you need to tune the parameters of SA and make
    sure that the algorithm returns a feasible solution. What can help a lot in final
    solution quality is a good initial solution and investigating the best way to
    select a neighbor solution.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks for reading, and see you next time!
  prefs: []
  type: TYPE_NORMAL
- en: Related
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](/an-introduction-to-a-powerful-optimization-technique-simulated-annealing-87fd1e3676dd?source=post_page-----9f8dcb6c2e06--------------------------------)
    [## An Introduction to a Powerful Optimization Technique: Simulated Annealing'
  prefs: []
  type: TYPE_NORMAL
- en: Explanation, parameters, strengths, weaknesses and use cases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/an-introduction-to-a-powerful-optimization-technique-simulated-annealing-87fd1e3676dd?source=post_page-----9f8dcb6c2e06--------------------------------)
    [](/mathematical-optimization-heuristics-every-data-scientist-should-know-b26de0bd43e6?source=post_page-----9f8dcb6c2e06--------------------------------)
    [## Mathematical Optimization Heuristics Every Data Scientist Should Know
  prefs: []
  type: TYPE_NORMAL
- en: Local search, genetic algorithms and more.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/mathematical-optimization-heuristics-every-data-scientist-should-know-b26de0bd43e6?source=post_page-----9f8dcb6c2e06--------------------------------)
    [](/four-ways-to-combine-mathematical-optimization-and-machine-learning-8cb874276254?source=post_page-----9f8dcb6c2e06--------------------------------)
    [## Five ways to combine Mathematical Optimization and Machine Learning
  prefs: []
  type: TYPE_NORMAL
- en: Practical examples of combining two forces.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/four-ways-to-combine-mathematical-optimization-and-machine-learning-8cb874276254?source=post_page-----9f8dcb6c2e06--------------------------------)
  prefs: []
  type: TYPE_NORMAL
