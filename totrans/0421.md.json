["```py\n├── database\n│   └── database.go\n├── models\n│   └── models.go\n├── handlers\n│   ├── routes.go\n│   ├── stats.go\n│   ├── timeseries.go\n│   └── timeseriesvalues.go\n├── stats\n│   └── stats.go\n├── go.mod\n├── go.sum\n└── main.go\n```", "```py\ntype TimeSeries struct {\n ID   int    `gorm:\"primaryKey\"`\n Name string `gorm:\"not null\"`\n}\n\ntype TimeSeriesValue struct {\n ID           int `gorm:\"primaryKey\"`\n Time         time.Time\n Value        float64\n TimeSeriesID int `gorm:\"not null\"`\n}\n```", "```py\nfunc (v TimeSeriesValue) GetTime() time.Time { return v.Time }\nfunc (v TimeSeriesValue) GetValue() float64  { return v.Value }\n```", "```py\nfunc GetDatabase(dbFile string) (*gorm.DB, error) {\n return gorm.Open(sqlite.Open(dbFile), &gorm.Config{})\n}\n\nfunc AutoMigrate(db *gorm.DB) {\n db.AutoMigrate(&models.TimeSeries{}, &models.TimeSeriesValue{})\n}\n```", "```py\n// Interface for a data point in a time series\ntype TsValue interface {\n GetTime() time.Time\n GetValue() float64\n}\n```", "```py\nfunc Count(values []TsValue) float64 {\n return float64(len(values))\n}\n```", "```py\nfunc Min(values []TsValue) float64 {\n if len(values) == 0 {\n  return math.NaN()\n }\n min := values[0].GetValue()\n for _, value := range values {\n  if value.GetValue() < min {\n   min = value.GetValue()\n  }\n }\n return min\n}\n```", "```py\nfunc Mean(values []TsValue) float64 {\n count := Count(values)\n if count == 0 {\n  return math.NaN()\n }\n sum := 0.0\n for _, value := range values {\n  sum += value.GetValue()\n }\n return sum / count\n}\n```", "```py\nfunc StandardDeviation(values []TsValue) float64 {\n count := Count(values)\n if count == 0 {\n  return math.NaN()\n }\n mean := Mean(values)\n sumSquare := 0.0\n for _, value := range values {\n  sumSquare += math.Pow(value.GetValue()-mean, 2)\n }\n return math.Sqrt(sumSquare / count)\n}\n```", "```py\nfunc ComputeStatistics(values []TsValue) map[string]float64 {\n result := make(map[string]float64)\n\n result[\"Count\"] = Count(values)\n result[\"Min\"] = Min(values)\n result[\"Max\"] = Max(values)\n result[\"Mean\"] = Mean(values)\n result[\"StdDev\"] = StandardDeviation(values)\n\n return result\n}\n```", "```py\nfunc ComputeStatisticsConcurrent(values []TsValue) map[string]float64 {\n result := make(map[string]float64)\n // 1) Create a WaitGroup to sync, a Channel to collect results, and\n // a map with the statistics to compute.\n var wg sync.WaitGroup\n ch := make(chan struct {\n  string\n  float64\n })\n statsToCompute := map[string]func([]TsValue) float64{\n  \"Count\":             Count,\n  \"Min\":               Min,\n  \"Max\":               Max,\n  \"Mean\":              Mean,\n  \"StandardDeviation\": StandardDeviation,\n }\n\n // 2) Set how many stats to compute.\n wg.Add(len(statsToCompute))\n\n // 3) Compute each stat in a separate goroutine.\n for statName, statFunc := range statsToCompute {\n  go func(name string, operation func([]TsValue) float64) {\n   defer wg.Done()\n   value := operation(values)\n   ch <- struct {\n    string\n    float64\n   }{name, value}\n  }(statName, statFunc)\n }\n\n // 4) Set a goroutine to close the channel once all the\n // stats are computed.\n go func() {\n  wg.Wait()\n  close(ch)\n }()\n\n // 5) Collect the results from the channel.\n for stat := range ch {\n  result[stat.string] = stat.float64\n }\n\n return result\n}\n```", "```py\n// Create a new type that embeds database.Database to assign new\n// methods to it\ntype wrapDB struct {\n DB *gorm.DB\n}\n```", "```py\nfunc SetEndpoints(r *gin.Engine, db *gorm.DB) {\n\n wrapdb := &wrapDB{DB: db}\n\n // timeseries CRUD\n r.GET(\"/timeseries\", wrapdb.listTimeSeries)\n r.GET(\"/timeseries/:tsid\", wrapdb.getTimeSeries)\n r.POST(\"/timeseries\", wrapdb.postTimeSeries)\n r.PUT(\"/timeseries/:tsid\", wrapdb.putTimeSeries)\n r.DELETE(\"/timeseries/:tsid\", wrapdb.deleteTimeSeries)\n\n // timeseries values CRUD\n r.GET(\"/timeseries/:tsid/values\", wrapdb.listTimeSeriesValues)\n r.GET(\"/timeseries/:tsid/values/:valueid\", wrapdb.getTimeSeriesValue)\n r.POST(\"/timeseries/:tsid/values\", wrapdb.postTimeSeriesValues)\n r.PUT(\"/timeseries/:tsid/values/:valueid\", wrapdb.putTimeSeriesValue)\n r.DELETE(\"/timeseries/:tsid/values/:valueid\", wrapdb.deleteTimeSeriesValue)\n\n // statistics\n r.GET(\"/timeseries/:tsid/statistics\", wrapdb.getTimeSeriesStats)\n}\n```", "```py\nfunc (db *wrapDB) listTimeSeries(c *gin.Context) {\n var tseriesList []models.TimeSeries\n if err := db.DB.Find(&tseriesList).Error; err != nil {\n  c.JSON(500, gin.H{\"error\": \"Failed to retrieve timeseries\"})\n  return\n }\n c.JSON(200, tseriesList)\n}\n```", "```py\nfunc (db *wrapDB) checkTimeSeriesID(c *gin.Context) (int, error) {\n id := c.Param(\"tsid\")\n // Check if the time series exists can be converted to\n timeSeriesID, err := strconv.Atoi(id)\n if err != nil {\n  c.JSON(400, gin.H{\"error\": \"Invalid time series ID\"})\n  return timeSeriesID, err\n }\n\n // Check if the time series exists in the TimeSeries table\n var timeSeries models.TimeSeries\n if err := db.DB.First(&timeSeries, timeSeriesID).Error; err != nil {\n  c.JSON(404, gin.H{\"error\": \"Time series not found\"})\n  return timeSeriesID, err\n }\n return timeSeriesID, nil\n}\n```", "```py\nfunc (db *wrapDB) postTimeSeries(c *gin.Context) {\n var tseries models.TimeSeries\n c.BindJSON(&tseries)\n if err := db.DB.Create(&tseries).Error; err != nil {\n  c.JSON(500, gin.H{\"error\": \"Failed to create timeseries\"})\n  return\n }\n c.JSON(201, tseries)\n}\n```", "```py\nfunc (db *wrapDB) getTimeSeries(c *gin.Context) {\n timeSeriesID, err := db.checkTimeSeriesID(c)\n if err != nil {\n  return\n }\n var tseries models.TimeSeries\n if err := db.DB.Where(\"id = ?\", timeSeriesID).First(&tseries).Error; err != nil {\n  c.JSON(404, gin.H{\"error\": \"Failed to retrieve timeseries\"})\n  return\n }\n c.JSON(200, tseries)\n}\n```", "```py\nfunc (db *wrapDB) putTimeSeries(c *gin.Context) {\n timeSeriesID, err := db.checkTimeSeriesID(c)\n if err != nil {\n  return\n }\n var tseries models.TimeSeries\n if err = db.DB.Where(\"id = ?\", timeSeriesID).First(&tseries).Error; err != nil {\n  c.JSON(404, gin.H{\"error\": \"Time series not found\"})\n  return\n }\n c.BindJSON(&tseries)\n if err = db.DB.Save(&tseries).Error; err != nil {\n  c.JSON(500, gin.H{\"error\": \"Error while saving\"})\n }\n c.JSON(200, tseries)\n}\n```", "```py\n// Delete a time series and its values\nfunc (db *wrapDB) deleteTimeSeries(c *gin.Context) {\n timeSeriesID, err := db.checkTimeSeriesID(c)\n if err != nil {\n  return\n }\n var tseries models.TimeSeries\n\n // Delete in a transaction\n db.DB.Transaction(func(tx *gorm.DB) error {\n\n  // Delete values\n  if err := tx.Where(\"time_series_id = ?\", timeSeriesID).\n   Delete(&models.TimeSeriesValue{}).Error; err != nil {\n   c.JSON(500, gin.H{\"error\": \"Deleting the timeseries failed.\"})\n   return err\n  }\n\n  // Delete timeseries\n  if err := tx.Where(\"id = ?\", timeSeriesID).\n   Delete(&tseries).Error; err != nil {\n   c.JSON(500, gin.H{\"error\": \"Deleting the timeseries failed.\"})\n   return err\n  }\n\n  c.JSON(200, gin.H{\"id #\" + strconv.Itoa(timeSeriesID): \"deleted\"})\n  return nil\n })\n\n}\n```", "```py\nfunc (db *wrapDB) postTimeSeriesValues(c *gin.Context) {\n timeSeriesID, err := db.checkTimeSeriesID(c)\n if err != nil {\n  return\n }\n\n // Bind the request body to a slice of TimeSeriesValue\n var timeSeriesValues []models.TimeSeriesValue\n if err := c.ShouldBindJSON(&timeSeriesValues); err != nil {\n  c.JSON(400, gin.H{\"error\": \"Invalid request data\"})\n  return\n }\n // Set the TimeSeriesID for the posted values\n for i := range timeSeriesValues {\n  timeSeriesValues[i].TimeSeriesID = timeSeriesID\n }\n\n // Create the values in the database\n if err := db.DB.Create(&timeSeriesValues).Error; err != nil {\n  c.JSON(500, gin.H{\"error\": \"Failed to create time series values\"})\n  return\n }\n c.JSON(201, gin.H{\"message\": \"Time series values created\"})\n}\n```", "```py\nfunc (db *wrapDB) getTimeSeriesStats(c *gin.Context) {\n timeSeriesID, err := db.checkTimeSeriesID(c)\n if err != nil {\n  return\n }\n // Query the database.Database to retrieve specific fields of time series values\n var tsValues []models.TimeSeriesValue\n if err := db.DB.Where(\"time_series_id = ?\", timeSeriesID).\n  Select(\"id, time, value\").Find(&tsValues).Error; err != nil {\n  c.JSON(500, gin.H{\"error\": \"Failed to retrieve time series values\"})\n  return\n }\n // Convert the slice of TimeSeriesValue to a slice of TsValue interfaces\n values := []stats.TsValue{}\n for _, v := range tsValues {\n  values = append(values, v)\n }\n c.JSON(200, serializeMap(stats.ComputeStatisticsConcurrent(values)))\n}\n```", "```py\n// SerializeMap serializes a map from string to float64,\n// returning null for NaN values\nfunc serializeMap(data map[string]float64) map[string]interface{} {\n serializedData := make(map[string]interface{})\n for key, value := range data {\n  if math.IsNaN(value) {\n   serializedData[key] = nil\n  } else {\n   serializedData[key] = value\n  }\n }\n return serializedData\n}\n```", "```py\nfunc main() {\n // Define flags for command-line arguments\n dbName := flag.String(\"db\", \"timeseries.db\", \"Database name\")\n trustedProxy := flag.String(\"proxy\", \"127.0.0.1\", \"Trusted proxy\")\n port := flag.String(\"port\", \"8080\", \"Port number\")\n flag.Parse()\n\n // Initialize the database\n db, err := database.GetDatabase(*dbName)\n if err != nil {\n  panic(\"failed to connect to the database\")\n }\n database.AutoMigrate(db)\n\n // Set the trusted proxies\n router := gin.Default()\n router.SetTrustedProxies([]string{*trustedProxy})\n\n // Set endpoints and run the server\n handlers.SetEndpoints(router, db)\n router.Run(fmt.Sprintf(\":%s\", *port))\n\n}\n```", "```py\n# Stage 1: Build the Go application\n\nFROM golang:1.21-alpine3.18 AS build\nWORKDIR /app\nCOPY . .\nRUN apk add build-base\n# Download (and cache) all dependencies.\nRUN go mod download\n# Build the Go app with static linking\nRUN go build -ldflags=\"-w -s\" -o tsapi\n\n# Stage 2: Create a minimal image for running the application\n\nFROM alpine:3.18\nWORKDIR /app\nCOPY --from=build /app/tsapi .\nEXPOSE 8080\nCMD [\"./tsapi\"]\n```", "```py\n# Build the docker image\ndocker build -t go-timeseries-api .\n# Run the docker image\ndocker run -p 8080:8080 go-timeseries-api\n```", "```py\n# Create a time series\ncurl -i -X POST http://localhost:8080/timeseries -d '{ \"Name\": \"My time series\"}'\n> {\"ID\":1,\"Name\":\"My time series\"}\n\n# Create time series values\ncurl -i -X POST http://localhost:8080/timeseries/1/values -d '[{\"Time\": \"2023-10-28T12:00:00Z\", \"Value\": 10.0},{\"Time\": \"2023-10-28T12:15:00Z\", \"Value\": 20.5}]'\n> {\"message\":\"Time series values created\"}\n\n# Get statistics\ncurl -i -GET http://localhost:8080/timeseries/1/statistics\n> {\"Count\":2,\"Max\":20.5,\"Mean\":15.25,\"Min\":10,\"StandardDeviation\":5.25}\n\n# Delete a time series\ncurl -i -X DELETE http://localhost:8080/timeseries/1\n> {\"id #1\":\"deleted\"}\n```"]