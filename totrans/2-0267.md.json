["```py\nlen([1, 2, 3])\nlen(\"1, 2, 3\")\nlen(1)\nlen([i**2 for i in range(20)])\nlen(i**2 for i in range(20))\n```", "```py\n>>> len([1, 2, 3])\n3\n>>> len(\"1, 2, 3\")\n7\n>>> len(1)\nTypeError: object of type 'int' has no len()\n>>> len([i**2 for i in range(20)])\n20\n>>> len(i**2 for i in range(20))\n20\n```", "```py\n>>> len(i**2 for i in range(20))\nTraceback (most recent call last):\n  ...\nTypeError: object of type 'generator' has no len()\n```", "```py\nlen(i**2 for i in range(20))\n```", "```py\nimport timeit\n\n# timeit settings\nn = 100\nrep = 7\n\ncode_listcomp = \"[x**2 for x in range(1_000_000)]\"\ncode_map = \"map(lambda x: x**2, range(1_000_000))\"\n\nif __name__ == \"__main__\":\n    t_listcomp = timeit.repeat(\n        code_listcomp,\n        number=n,\n        repeat=rep)\n    t_map = timeit.repeat(\n        code_map,\n        number=n,\n        repeat=rep\n    )\n    print(\n        \"Time for a listcomp:\"\n        f\" {round(min(t_listcomp), 4)}\"\n        \"\\n\"\n        f\"Time for a map    : \"\n        f\"{round(min(t_map), 4)}\"\n    )\n```", "```py\ndf = pd.DataFrame(dict(\n    y=[1.1, 1.2, 1.1, 1.4, 1.3, 1.6,\n         2.1, 2.2, 1.9, 2.0, 2.4, 2.5,\n         2.3, 2.4, 2.5, 2.2, 2.6, 2.9,\n         3.2, 3.3, 3.1, 3.5, 3.7, 3.6,],\n    time=pd.date_range(start='1/1/2021',\n                       end='1/1/2023',\n                       freq=\"M\"))\n)\n```", "```py\nimport pandas as pd\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import mean_squared_error\n\n# Import forecasting libraries\nfrom statsmodels.tsa.arima_model import ARIMA\nfrom fbprophet import Prophet\nfrom pmdarima.arima import auto_arima\n\n# Define a function to evaluate forecasting models\ndef evaluate_model(model, train_df, test_df):\n    # Make predictions\n    predictions = model.fit(train_df).predict(test_df.index)\n\n    # Calculate mean squared error\n    mse = mean_squared_error(test_df[\"y\"], predictions)\n\n    # Return the MSE\n    return mse\n\n# Define a function to choose the best forecasting model\ndef choose_best_model(models, train_df, test_df):\n    # Evaluate each model\n    mse_scores = []\n    for model in models:\n        mse = evaluate_model(model, train_df, test_df)\n        mse_scores.append(mse)\n\n    # Choose the model with the lowest MSE\n    best_model_index = np.argmin(mse_scores)\n    best_model = models[best_model_index]\n\n    # Return the best model\n    return best_model\n\n# Load the data\ndf = pd.DataFrame(dict(\n    y=[1.1, 1.2, 1.1, 1.4, 1.3, 1.6,\n         2.1, 2.2, 1.9, 2.0, 2.4, 2.5,\n         2.3, 2.4, 2.5, 2.2, 2.6, 2.9,\n         3.2, 3.3, 3.1, 3.5, 3.7, 3.6,],\n    time=pd.date_range(start='1/1/2021',\n                       end='1/1/2023',\n                       freq=\"M\"))\n)\n\n# Split the data into train and test sets\ntrain_df, test_df = train_test_split(df, test_size=0.2, shuffle=False)\n\n# Define the forecasting models\nmodels = [\n    ARIMA(),\n    Prophet(),\n    auto_arima()\n]\n\n# Choose the best forecasting model\nbest_model = choose_best_model(models, train_df, test_df)\n\n# Make predictions\npredictions = best_model.fit(train_df).predict(test_df.index)\n\n# Print the predictions\nprint(predictions)\n```", "```py\n2023-01-31    3.448842\n2023-02-28    3.703727\n2023-03-31    3.836334\n2023-04-30    4.058906\n2023-05-31    4.249011\nName: y, dtype: float64\n```", "```py\n>>> rounder.round(1.23456789, precision=2, rounding_mode='ROUND_HALF_EVEN')\n1.23\n>>> rounder.round_nested([1.23456789, 2.3456789], precision=2, rounding_mode='ROUND_HALF_EVEN')\n[1.23, 2.35]\n>>> rounder.round_to_figures(1.23456789, figures=3, rounding_mode='ROUND_HALF_EVEN')\n1.23\n```"]