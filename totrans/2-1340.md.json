["```py\n# Input coordinates are in Cartesian, but represent Polar ingredients\n#   > 'r' is the Cartesian height offset in this case\n#   > the angle is calculated as a percentage along\n#     the straight line in Cartesian space relative to 2*pi\nx = r * cos(angle)\ny = r * sin(angle)\n\n# For converting points, I created this helper function:\n\nfrom math import cos, sin, pi\n\ndef polarize(x, max_x, y, y_offset = 0.):\n    angle = (2.*pi)*(((x)%(max_x))/(max_x))\n    angle_deg = angle * 180./pi\n    angle_rotated = (abs(angle_deg-360.)+90.) % 360\\. \n    angle_new = angle_rotated * pi/180.\n    y += y_offset\n    x_out = (y)*cos(angle_new)\n    y_out = (y)*sin(angle_new)\n    return x_out, y_out\n```", "```py\n# Here's a custom chord function I created for use in the Multi-Chord Diagram\n# chord(x0, y0, x1, y1, x2, y2, points, h_override=0.)\n#   > x0, y0: the circle's center\n#   > x1, y1, x2, y2: two points on a circle\n#   > points: number of desired points along the chord path\n#   > h_override: height constraint on the chord's apex\n\nfrom math import cos, sin, pi, sqrt, atan2\n\ndef LnToPntDst(x0, y0, x1, y1, x2, y2):\n    n = abs((y1-y2)*x0+(x2-x1)*y0+x1*y2-x2*y1)\n    d = sqrt((x2-x1)**2+(y2-y1)**2)\n    return n/d\n\ndef DistBtwTwoPnts(x1, y1, x2, y2):\n    return sqrt((x2-x1)**2+(y2-y1)**2)\n\ndef Rotate(x, y, angledeg, x_offset, y_offset):\n    xa = x*cos(angledeg*pi/180) + y*sin(angledeg*pi/180)\n    ya = -x*sin(angledeg*pi/180) + y*cos(angledeg*pi/180)\n    xa -= x_offset\n    ya -= y_offset\n    return xa, ya\n\ndef AngleByTwoPnts(x1, y1, x2, y2):\n    return atan2(x2-x1, y2-y1)*180/pi - 90\n\ndef chord(x0, y0, x1, y1, x2, y2, points, h_override=0.):\n    h = LnToPntDst(x0, y0, x1, y1, x2, y2)\n    w = DistBtwTwoPnts(x1, y1, x2, y2)\n\n    if h_override == 0.:\n        new_h = (1.-(h/w)/10.)*h\n        if new_h < h*0.01:\n            h = h*0.01\n        else:\n            h = new_h\n    else:\n        h = h*h_override\n\n    a = AngleByTwoPnts(x1, y1, x2, y2)\n    xr = []\n    yr = []\n    for i in range(points+1):\n        arc_percent = i/(points/2.)\n        if i > points/2.:\n            arc_percent = (points-i)/(points/2.)\n        if i == 0 or i == points:\n            arc = 0.\n        else:\n            arc = sqrt((h/2.)**2-((h/2.)-(h/2.)/((points)/2.)*i)**2.)\n        percent = arc/(h/2.)\n\n        y_1 = -percent*arc+(1-percent)*arc_percent\n        y_2 = percent*arc+(1-percent)*arc_percent\n        xr_1, yr_1 = Rotate(i/points*w, y_1, a, -x1, -y1)\n        xr_2, yr_2 = Rotate(i/points*w, y_2, a, -x1, -y1)\n\n        d1 =  DistBtwTwoPnts(x0, y0, xr_1, yr_1)\n        d2 =  DistBtwTwoPnts(x0, y0, xr_2, yr_2)\n\n        if d1 < d2:\n            xr.append(xr_1)\n            yr.append(yr_1)\n        else:\n            xr.append(xr_2)\n            yr.append(yr_2)\n    return list(zip(xr, yr))\n```", "```py\n# 'x_o' is the original value\n# 'x_min' is the current minimum of the values range\n# 'x_max' is the current maximum of the values range\n# 'x_r' is the rescaled value based on a new range, 'new_min' and 'new_max'\nx_r = (new_max - new_min) * ((x_o - x_min)/(x_max - x_min)) + new_min\n```", "```py\nfrom dataoutsider import multi_chord as mc\nimport pandas as pd\n\ndata = [['a', 56.5], ['a,b', 15], ['a,c', 14.4], \n        ['a,b,d', 8.6], ['c,d', 13], ['d', 30.9], \n        ['c,b', 10], ['b', 24.3], ['a,b,c,d', 17.2],\n        ['b,e',5.6], ['c,d,e',17.8]]\ndf = pd.DataFrame(data, columns = ['group', 'value'])\ndf_mc = mc.multi_chord_on_groups_alias(df, percent=75)\nmc.multi_chord_plot(df_mc, level = 3, transparency = 0.5)\n```", "```py\nimport os\ndf_mc.to_csv(os.path.dirname(__file__) + \n    '/multichord_diagram.csv', encoding='utf-8', index=False)\ndf_upset = mc.multi_chord_venn(df_mc).drop_duplicates()\ndf_upset.to_csv(os.path.dirname(__file__) + \n    '/upset_plot.csv', encoding='utf-8', index=False)\n```"]