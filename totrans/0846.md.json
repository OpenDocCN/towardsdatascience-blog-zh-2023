["```py\nfrom datetime import datetime\nimport smbus\nimport math\nimport time\n\n# MPU6050 Registers\nPWR_MGMT_1   = 0x6B\nSMPLRT_DIV   = 0x19\nCONFIG       = 0x1A\nGYRO_CONFIG  = 0x1B\nINT_ENABLE   = 0x38\nACCEL_XOUT_H = 0x3B\nACCEL_YOUT_H = 0x3D\nACCEL_ZOUT_H = 0x3F\nGYRO_XOUT_H  = 0x43\nGYRO_YOUT_H  = 0x45\nGYRO_ZOUT_H  = 0x47\n\nbus = smbus.SMBus(1)\naddress = 0x68\n\ndef device_init():\n    \"\"\" Init the MPU-6050 \"\"\"\n    bus.write_byte_data(address, SMPLRT_DIV, 0x4)\n    bus.write_byte_data(address, PWR_MGMT_1, 1)\n    bus.write_byte_data(address, CONFIG, 0)\n    bus.write_byte_data(address, GYRO_CONFIG, 24)\n    bus.write_byte_data(address, INT_ENABLE, 1)\n\ndef read_byte(reg):\n    \"\"\" Read 1 byte from the sensor \"\"\"\n    return bus.read_byte_data(address, reg)\n\ndef read_word(reg):\n    \"\"\" Read 2 bytes from the sensor \"\"\" \n    h = bus.read_byte_data(address, reg)\n    l = bus.read_byte_data(address, reg + 1)\n    value = (h << 8) + l\n    return value\n\ndef read_word_2c(reg):\n    \"\"\" Read and convert the data \"\"\"\n    val = read_word(reg)\n    return -((65535 - val) + 1) if val >= 0x8000 else val\n\ndef device_read():\n    \"\"\" Get accel and gyro data \"\"\"\n    g_x = read_word_2c(GYRO_XOUT_H) / 131\n    g_y = read_word_2c(GYRO_YOUT_H) / 131\n    g_z = read_word_2c(GYRO_ZOUT_H) / 131\n    a_x = read_word_2c(ACCEL_XOUT_H) / 16384\n    a_y = read_word_2c(ACCEL_YOUT_H) / 16384\n    a_z = read_word_2c(ACCEL_ZOUT_H) / 16384\n    return g_x, g_y, g_z, a_x, a_y, a_z\n\nif __name__ == \"__main__\":\n    device_init()\n    device_read()\n\n    while True:\n        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f')\n        gyro_x1, gyro_y1, gyro_z1, accel_x1, accel_y1, accel_z1 = device_read()\n        gyro_x2, gyro_y2, gyro_z2, accel_x2, accel_y2, accel_z2 = device_read()\n        g_x, g_y, g_z = (gyro_x1 + gyro_x2)/2, (gyro_y1 + gyro_y2)/2, (gyro_z1 + gyro_z2)/2\n        a_x, a_y, a_z = (accel_x1 + accel_x2)/2, (accel_y1 + accel_y2)/2, (accel_z1 + accel_z2)/2\n        s_data = f\"{timestamp},{g_x: .7f},{g_y: .7f},{g_z: .7f},{a_x: .7f},{a_y: .7f},{a_z: .7f}\"\n\n        # Save to log file\n        log_filename = datetime.now().strftime('%Y-%m-%d.log')\n        with open(log_filename, \"a\", encoding=\"ascii\") as log_out:\n            log_out.write(s_data + \"\\n\")\n```", "```py\nnohup python3 accel_read.py >/dev/null 2>&1 &\n```", "```py\nscp pi@raspberrypi3:/home/pi/Documents/AccelData/2023-08-01.log data\n```", "```py\nimport pandas as pd\n\nfrom bokeh.plotting import figure, show\nfrom bokeh.models import Range1d, DatetimeTickFormatter\nfrom bokeh.io import output_notebook\nfrom bokeh.layouts import row, column, gridplot\noutput_notebook()\n```", "```py\ndf_sample = pd.read_csv(\"mpu6050.csv\", \n                        header=None, \n                        names=[\"timestamp\", \"g_x\", \"g_y\", \"g_z\", \"a_x\", \"a_y\", \"a_z\"],\n                        parse_dates=[\"timestamp\"])\ndisplay(df_sample)\n```", "```py\ntimestamps = df_sample['timestamp']\n# Accelerometer data\np1 = figure(title=\"Accelerometer data\", x_axis_type='datetime', \n            x_axis_label='x', y_axis_label='y', width=1600, height=600)\np1.line(timestamps, df_sample[\"a_x\"], legend_label=\"A_X\", line_width=2, color=\"red\")\np1.line(timestamps, df_sample[\"a_y\"], legend_label=\"A_Y\", line_width=2, color=\"green\")\np1.line(timestamps, df_sample[\"a_z\"], legend_label=\"A_Z\", line_width=2, color=\"blue\")\n# Gyroscope data\np2 = figure(title=\"Gyroscope data\", x_axis_type='datetime', \n            x_axis_label='x', y_axis_label='y', width=1600, height=600)\np2.line(timestamps, df_sample[\"g_x\"], legend_label=\"G_X\", line_width=2, color=\"#AA8822\")\np2.line(timestamps, df_sample[\"g_y\"], legend_label=\"G_Y\", line_width=2, color=\"#AA88AA\")\np2.line(timestamps, df_sample[\"g_z\"], legend_label=\"G_Z\", line_width=2, color=\"#2288AA\")\nshow(column(p1, p2))\n```", "```py\ndf = pd.read_csv(\"data/2023-08-06.log\", header=None, \n                 names=[\"timestamp\", \"g_x\", \"g_y\", \"g_z\", \"a_x\", \"a_y\", \"a_z\"], parse_dates=[\"timestamp\"])\n\nt_diff = df[\"timestamp\"].diff().dt.total_seconds()[1:]\ndiff_mean = t_diff.mean()\nprint(diff_mean, 1/diff_mean)\n\n#> 0.0156 63.81\n```", "```py\nt_diff = df[\"timestamp\"].diff().dt.total_seconds()[1:]\n\nh, bins = np.histogram(t_diff.values, bins=1024)\nprint(list(zip(h, bins))[:100])\n\n#> [(159712, 0.010), (5349277, 0.015), (4134, 0.0199), (293, 0.02462), \n#>  (96, 0.0293), (28, 0.0339), (10, 0.0386), (7, 0.043), (21, 0.048),\n#>  ...\n#>  (1, 0.1650), (1, 0.1697), (0, 0.1743), (1, 0.1790), (0, 0.1837), ...]\n\n# Convert X to milliseconds and normalize Y to 0..100%\nn_total = sum(h)\nh = 100*h/n_total\nbins *= 1000\n\n# Create the bar plot\nfig, ax = plt.subplots(1, 1, figsize=(10, 5))\nax.bar(bins[0:8], h[0:8], color='#440154', width=2.0)\nax.yaxis.label.set_color('gray')\nax.spines['left'].set_color('#DDDDDD')\nax.spines['right'].set_color('#DDDDDD')\nax.spines['top'].set_color('#DDDDDD')\nax.spines['bottom'].set_color('gray')\nax.xaxis.label.set_color('black')\nax.yaxis.label.set_color('gray')\nax.tick_params(axis='y', colors='#303030')\nplt.xlabel(\"Timestamp difference, milliseconds\")\nplt.ylabel(\"Percentage of records\")\nplt.title(\"Timestamps accuracy\")\nplt.show()\n```", "```py\ndef draw_sonogram(df_out: pd.DataFrame, t_start: datetime.datetime, t_end: datetime.datetime):\n    \"\"\" Draw a sonogram from the dataframe \"\"\"\n    values = df_[\"g_y\"].values\n    t_diff = df_['timestamp'].diff().dt.total_seconds()[1:].mean()  # 0.015s ~ 50Hz\n\n    fig, ax = plt.subplots(1, 1, figsize=(24, 14))\n    ax.specgram(values, NFFT=256, Fs=1/t_diff, noverlap=50, scale=\"dB\")\n    plt.ylabel('Frequency, Hz')\n    plt.xlabel('Time, sec')\n    plt.show()\n\ndraw_sonogram(df, datetime.time(9,0,0), datetime.time(10,0,0))\n```", "```py\ndf_ = df.copy()\ndf_[\"g_y_norm\"] = (df_[\"g_y\"] - df_[\"g_y\"].mean()).abs()\n```", "```py\nN = 400\ndf_[\"g_y_roll\"] = df_['g_y_norm'].rolling(N).max()\n```", "```py\nimport seaborn as sns\n\ndef draw_heatmap(df: pd.DataFrame):\n    \"\"\" Draw a heatmap from a dataframe \"\"\"\n    # Normalization and applying the rolling maximum\n    df_ = df.copy()\n    N = 400\n    df_[\"g_y_norm\"] = (df_[\"g_y\"] - df_[\"g_y\"].mean()).abs()\n    df_[\"g_y_roll\"] = df_['g_y_norm'].rolling(N).max()\n    df_ = df_.iloc[::N, :]  # Keep each Nth element\n\n    # Reshape all items to (24, N) matrix for heatmap\n    items_all = df_[\"g_y_roll\"].values[2:]\n    items_per_hour = items_all.shape[0]//24\n    items_reshaped = items_all[:items_per_hour*24].reshape((24, -1))\n\n    # Horizontal labels\n    hor_ticks = 6\n\n    # Draw\n    fig, ax = plt.subplots(figsize=(30, 8))\n    sns.heatmap(items_reshaped, vmin=0, vmax=0.08, \n                cbar_kws={\"orientation\": \"vertical\", \"pad\": 0.01}, ax=ax)\n    ax.hlines(list(range(24)), *ax.get_xlim(), colors=\"#303030\")\n    plt.xticks(rotation=0)\n    ax.set_xticks(np.linspace(0, items_per_hour, hor_ticks+1))\n    ax.set_xticklabels([10*n for n in range(hor_ticks+1)])\n    plt.title('MPU6050 Vibration Levels', fontsize=16)\n    plt.xlabel('Minutes', fontsize=12)\n    plt.yticks(rotation=0)\n    plt.ylabel('Hours', fontsize=12)\n    plt.show()\n\ndraw_heatmap(df)\n```", "```py\ndf_ = df.copy()\ndf_[\"g_y_norm\"] = (df_[\"g_y\"] - df_[\"g_y\"].mean()).abs()\nstd_y = df_[\"g_y_norm\"].std()\nthreshold = 7*std_y\n\ndf_filtered = df_.index[df_['g_y_norm'] >= threshold]\nprint(df_filtered)\n# > [2087075, 2153277, 2153981, 2798119, 2800170, 2800171, \n# > 3065854, 3065855,3065856, 3065858]\n```", "```py\ndef shrink_array(data: Any, num_samples: int) -> List:\n    \"\"\" Remove too close items from array. Example: [1, 2, 3, 10, 20] => [1, 10, 20] \"\"\"\n    out = data[:1]\n    for val in data[1:]:\n        if val > out[-1] + num_samples:\n            out.append(val)\n    return out\n\nindexes = shrink_array(df_filtered.values.tolist(), num_samples=500)\nprint(indexes)\n# > [2087075, 2153277, 2153981, 2798119, 2800170, 3065854]\n```", "```py\nfrom bokeh.layouts import gridplot\n\ndef make_plot(df_out: pd.DataFrame, title: str):\n    \"\"\" Show graph data \"\"\"\n    timestamps = pd.to_datetime(df_out['timestamp'].values).to_pydatetime()\n    p = figure(title=title, x_axis_type='datetime', \n               x_axis_label='x', y_axis_label='y', \n               width=600, height=400)\n    p.line(timestamps, df_out[\"g_y\"].values - df_out[\"g_y\"].mean(), \n           legend_label=\"G_Y\", line_width=1, color=\"blue\")\n    p.xaxis.formatter=DatetimeTickFormatter(seconds=\"%H:%M:%S\")\n    p.y_range = Range1d(-1.0, 1.0)\n    return p\n\nplots = []\nfor ind in indexes:\n    plots.append(make_plot(df_[ind - 20:ind + 100], title=f\"Index={ind}\"))\n\nshow(gridplot(np.array_split(plots, 2)))\n```", "```py\nfrom pyod.models.knn import KNN\n\npos_train = 2087075\ndf_ = df[pos_train - 100000:pos_train + 100000]\nfit_data = df_[[\"g_x\", \"g_y\", \"g_z\"]].to_numpy()\n\nclf = KNN(contamination=0.0001)\nclf.fit(fit_data)\n```", "```py\npos_test = 2800170\ndf_test = df[[\"g_x\", \"g_y\", \"g_z\"]][pos_test - 5000:pos_test + 5000]\ndata = df_test.to_numpy()\ny_pred = clf.predict(data)  # Outlier labels (0 or 1)\n```", "```py\n# Draw\nx = np.arange(0, len(y_pred))\ny = y_pred\ny1 = df_test[\"g_x\"]\ny2 = df_test[\"g_y\"]\ny3 = df_test[\"g_z\"]\np = figure(title=\"KNN anomaly detection results\", \n           x_axis_label='x', y_axis_label='y', \n           width=1600, height=500)\np.line(x, 0.04*y, legend_label=\"Anomaly\", line_width=2, color=\"gray\")\np.line(x, y1, legend_label=\"g_x\", line_width=2, color=\"green\")\np.line(x, y2, legend_label=\"g_y\", line_width=2, color=\"red\")\np.line(x, y3, legend_label=\"g_z\", line_width=2, color=\"blue\")\nshow(p)\n```"]