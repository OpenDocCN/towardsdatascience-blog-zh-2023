- en: 'Python Tuple, The Whole Truth and Only the Truth: Let’s Dig Deep'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/python-tuple-the-whole-truth-and-only-truth-lets-dig-deep-24d2bf02971b](https://towardsdatascience.com/python-tuple-the-whole-truth-and-only-truth-lets-dig-deep-24d2bf02971b)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: PYTHON PROGRAMMING
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Learn the intricacies of tuples.
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@nyggus?source=post_page-----24d2bf02971b--------------------------------)[![Marcin
    Kozak](../Images/d7faf62e48ed81dab5d8ad92819fff54.png)](https://medium.com/@nyggus?source=post_page-----24d2bf02971b--------------------------------)[](https://towardsdatascience.com/?source=post_page-----24d2bf02971b--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----24d2bf02971b--------------------------------)
    [Marcin Kozak](https://medium.com/@nyggus?source=post_page-----24d2bf02971b--------------------------------)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----24d2bf02971b--------------------------------)
    ·24 min read·Jan 27, 2023
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e10e34210758fdd1c9b2276ce2c67e81.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
- en: Tuples’ immutability can be confusing and headache-inducing. Photo by [Aarón
    Blanco Tejedor](https://unsplash.com/@innernature?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous article, we discussed the basics of tuples:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[](/python-tuple-the-whole-truth-and-only-the-truth-hello-tuple-12a7ab9dbd0d?source=post_page-----24d2bf02971b--------------------------------)
    [## Python Tuple, the Whole Truth, and Only the Truth: Hello, Tuple!'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Learn the basics of tuples and of using them
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/python-tuple-the-whole-truth-and-only-the-truth-hello-tuple-12a7ab9dbd0d?source=post_page-----24d2bf02971b--------------------------------)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'I showed you what a tuple is, what methods it offers, and most importantly,
    we discussed tuples immutability. But there is far more into tuples than that,
    and this articles offers continuation of the previous one. You will learn here
    the following aspects of the tuple type:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'The intricacies of the tuple: the effect of immutability on copying tuples,
    and tuple type hinting.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheriting from tuple.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tuple performance: execution time and memory.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The advantages of tuples over lists (?): clarity, performance, and tuples as
    dictionary keys.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuple comprehensions (?)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Named tuples
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The intricacies of the tuple
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Likely the most important intricacy of the tuple is its immutability. But since
    it creates the essence of this type, even beginners should know how this immutability
    works and what it means in both theory and practice; thus, we’ve discussed it
    in the above-mentioned previous article. Here, we will discuss other important
    intricacies of tuples.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: The effect of immutability on copying tuples
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This will be fun!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'A theorist would likely scream at me that there is only one immutability of
    tuples, the one we discussed in the previous article. Well, that’s true, but…
    but Python itself makes a distinction between two different types of immutability!
    And Python *must* make this distinction. This is because only a truly immutable
    object is hashable. In the below code, you will see that the first tuple is hashable
    but the second one is not:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一位理论家可能会对我大喊，称只有一种元组的不可变性，那就是我们在上一篇文章中讨论的那个。好吧，这是事实，但……但 Python 本身区分了两种不同的不可变性！而
    Python *必须* 做出这种区分。这是因为只有真正不可变的对象才是可哈希的。在下面的代码中，你会看到第一个元组是可哈希的，而第二个元组则不是：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Whether or not an object is hashable affects various things — and this is why
    Python differentiates hashable and non-hashable tuples; the former are what I
    call truly immutable tuples. I will show you how Python treats both in how copying
    of tuples works, and in using tuples as dictionary keys.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象是否可哈希会影响到各种事情——这也是为什么 Python 区分可哈希和不可哈希的元组；前者是我称之为真正不可变的元组。我将展示 Python 如何处理这两种元组，包括元组复制的工作原理和将元组用作字典键的情况。
- en: 'First, let’s see how it works in tuple copying. For this. let us create a fully
    immutable tuple and copy it using all the available methods:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看在元组复制中它是如何工作的。为此，我们创建一个完全不可变的元组，并使用所有可用的方法进行复制：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Since `a` is a fully immutable tuple, the original tuple (`a`) and all its
    copies should point to the very same object:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `a` 是一个完全不可变的元组，原始元组 (`a`) 及其所有副本应该指向同一个对象：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As expected — and as should be the case for a truly immutable type — all these
    names point to the very same object; their `id`s are the same. This is what I
    call true or full immutability.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样——也应该是完全不可变类型的情况——所有这些名称都指向同一个对象；它们的 `id` 是相同的。这就是我所称的真正或完全不可变性。
- en: 'Now let’s do the same with a tuple of the second type; that is, a tuple with
    one or more mutable elements:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们用第二种类型的元组做同样的事情；也就是说，一个包含一个或多个可变元素的元组：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The copies from `b` to `e` are shallow, so they will refer to the same object
    as the original name:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `b` 到 `e` 的副本是浅复制，因此它们将引用与原始名称相同的对象：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is why we have deep copying. A deep copy should cover all the objects,
    including those nested inside. And since we have a mutable object inside the `a`
    tuple, then unlike before, the deep copy `f` this time will *not* point to the
    same object:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要深度复制的原因。深度复制应该覆盖所有对象，包括嵌套在内部的对象。由于 `a` 元组内部有一个可变对象，因此与之前不同的是，这次深度复制 `f`
    将*不会*指向相同的对象：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The first element (at index `0`) of the tuple is `[1]`, so it’s mutable. When
    we created the shallow copies of `a`, the first elements of the tuples `a` to
    `e` pointed to the same list:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 元组的第一个元素（索引 `0`）是 `[1]`，所以它是可变的。当我们创建 `a` 的浅复制时，元组 `a` 到 `e` 的第一个元素指向相同的列表：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'but creating a deep copy meant creating a new list:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 但创建深度复制意味着创建一个新的列表：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now let’s see how these two types of immutability work differ in terms of using
    tuples as dictionary keys:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看这两种不可变性在将元组用作字典键时的工作差异：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So, if you want to use a tuple as a dictionary key, it must be hashable — so
    it must be truly immutable.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你想将一个元组用作字典键，它必须是可哈希的——也就是说，它必须真正不可变。
- en: 'So, if anyone tells you that there is only one type of immutability of Python
    tuples, you will know that’s not entirely true — as there are two sorts of tuples
    in terms of immutability:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果有人告诉你 Python 元组只有一种不可变性，你会知道这并不完全正确——因为在不可变性方面有两种类型的元组：
- en: fully immutable tuples, containing only immutable elements; this is immutability
    in terms of both references and values;
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全不可变的元组，仅包含不可变元素；这在引用和值两个方面都表现为不可变性；
- en: immutable tuples in terms of references but not values, that is, tuples containing
    mutable element(s).
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从引用角度看不可变但从值角度看可变的元组，即包含可变元素的元组。
- en: Failing to distinguish them would disable you to understand how copying of tuples
    works.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不区分这两者，你将无法理解元组复制的工作原理。
- en: Tuple type hinting
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组类型提示
- en: 'Type hints have been becoming more and more important in Python. Some say that
    there’s no modern Python code without type hints. As I wrote what I think in another
    article, I will not repeat myself here. If you’re interested, feel invited to
    read it:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示在 Python 中变得越来越重要。有些人说现代 Python 代码中没有类型提示是不可能的。正如我在另一篇文章中所写的那样，我不会在这里重复。如果你感兴趣，请阅读它：
- en: '[](https://betterprogramming.pub/pythons-type-hinting-friend-foe-or-just-a-headache-73c7849039c7?source=post_page-----24d2bf02971b--------------------------------)
    [## Python’s Type Hinting: Friend, Foe, or Just a Headache?'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Type hinting’s popularity is increasing in the Python community. Where will
    this lead us? What can we do to use it…
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: betterprogramming.pub](https://betterprogramming.pub/pythons-type-hinting-friend-foe-or-just-a-headache-73c7849039c7?source=post_page-----24d2bf02971b--------------------------------)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Here, let’s shortly discuss how to deal with type hints for tuples. I will show
    the modern version to type hinting tuples, meaning Python 3.11\. As type hinting
    has been dynamically changing, however, be aware that not everything worked the
    same way in older Python versions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: As of Python 3.9, things got simpler, as you can use built-in `tuple` type with
    fields indicated in square brackets `[]`. Below are several examples of what you
    can do.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '`tuple[int, ...]`, `tuple[str, ...]` and the like'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: This means the object is a tuple of `int` / `str` / and the like elements, of
    any length. The ellipsis, `...`, informs that the tuple can have any length; there
    is no way to fix it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '`tuple[int | float, ...]` Like above, but the tuple may contain both `int`
    and `float` items.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '`tuple[int, int]` Unlike above, this tuple is a record of two items, both being
    integers.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '`tuple[str, int|float]` Again, a record of two items, the first being a string
    and the second an integer or a floating-point number.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '`tuple[str, str, tuple[int, float]]` A record with three items, the first two
    being strings and the third one being a two-element tuple of an integer and a
    floating-point number.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '`tuple[Population, Area, Coordinates]`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: This is a specific record, one that contains three elements of specific types.
    These types, `Population`, `Area`, `Coordinates` are either named tuples or data
    types defined earlier, or type aliases. As I explained in the above-mentioned
    article, using such type aliases can be much more readable than using the built-in
    types such as `int`, `float`, and the like.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: These were just several examples, but I hope they will help you see what you
    can do with type hinting for tuples. I have only mentioned *named tuples*, as
    I will discuss this type in another section below. Do remember, however, that
    named tuples are of much help also in the context of type hinting, as thanks to
    a named tuple you can get a custom type alias that is also a data container —
    a powerful combination.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting from `tuple`
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can inherit from `list`, though sometimes it’s better to inherit from `collections.UserList`.
    So, maybe we can do the same with the tuple? Can we inherit from the `tuple` class?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Basically, forget the idea of creating a tuple-like general type. The `tuple`
    does not have its own `.__init__()` method, so you cannot do what you can when
    inheriting from the list, that is, you cannot call `super().__init__()`. And without
    that, you’re left with almost nothing as the `tuple` class inherits `object.__init__()`
    instead.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，忘掉创建类似元组的通用类型的想法。`tuple`没有自己的`.__init__()`方法，因此你不能像继承自列表那样调用`super().__init__()`。没有这一点，你几乎没有任何功能，因为`tuple`类继承的是`object.__init__()`。
- en: Nonetheless, this does not mean you cannot inherit from `tuple` at all. You
    can, but not to create a general type, but a specific one. Do you remember the
    `City` class? We can do something similar with a tuple — but be aware that this
    will be no fun.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不意味着你不能从`tuple`继承。你可以，但不是为了创建通用类型，而是特定类型。你还记得`City`类吗？我们可以做类似的事情，但要注意，这可能并不有趣。
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We have a tuple-like `City` class:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个类似元组的`City`类：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This class takes *exactly* four arguments, not fewer and not more:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类*确切*地接受四个参数，既不多也不少：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note that in the current version, we can use argument names but do not have
    to, as they are positional:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在当前版本中，我们可以使用参数名称，但不必这样做，因为它们是位置参数。
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'But we cannot access the values by names:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们不能通过名称访问值：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can change that in two ways. One is by using a named tuple from the `collections`
    or `typing` module; we will discuss them soon. But we can achieve the same effect
    using our `City` class, thank to the `operator` module:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两种方式来改变这一点。一种是使用`collections`或`typing`模块中的命名元组；我们稍后会讨论它们。但我们也可以使用我们的`City`类来实现相同的效果，感谢`operator`模块：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And now we can access `lat` and `long` attributes by name:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以按名称访问`lat`和`long`属性：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'However, since we did the above only for `lat` and `long`, we will not be able
    to access `population` and `area` by name:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于我们只对`lat`和`long`进行了上述操作，我们将无法按名称访问`population`和`area`：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can of course change that:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以改变这一点：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: I’ve never done anything like this, however. If you want to have such a functionality,
    you should definitely use a named tuple instead.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，我从未做过这样的事情。如果你想要这样的功能，你应该使用命名元组。
- en: Tuple performance
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组性能
- en: Execution time
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行时间
- en: To benchmark various operations using tuples and, for comparison, lists, I used
    the script presented in Appendix close to the end of the article. You will also
    find there the results of running the code. I present the code not only for the
    record, but to enable you to extend the experiment.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了基准测试使用元组的各种操作，以及作为比较的列表，我使用了附录中接近文章末尾的脚本。你还会在那里找到运行代码的结果。我提供代码不仅仅是为了记录，也为了让你可以扩展实验。
- en: Overall, the list was *always* faster, irrespective of its size and the operation
    being performed. I’ve often heard that one of the reasons behind creating tuples
    was their smaller memory consumption. Our little experiment is far from confirming
    this idea. While indeed sometimes tuples used a little less memory, usually they
    used a little more. Hence I conducted the experiment for really long lists and
    tuples, of 5 mln and 10 mln integer items. And again, lists usually consumed less
    memory…
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，无论其大小和执行的操作是什么，列表*总是*更快。我常听说创建元组的原因之一是它们较小的内存消耗。我们的这个小实验远未确认这一观点。虽然有时元组确实使用了稍少的内存，但通常它们使用的内存稍多。因此，我对5百万和1000万整数项的非常长的列表和元组进行了实验。结果是，列表通常消耗的内存更少……
- en: 'So, where is this small memory consumption of tuples? Perhaps it’s related
    to how much disk space a tuple and the corresponding list take? Let’s check:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这些小内存消耗的元组在哪里呢？也许这与元组和相应列表所占的磁盘空间有关？让我们检查一下：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Only in the case of small tuples and their corresponding lists, the difference
    in memory use is noticeable — like, for instance, `152` against `168`. But I think
    you’ll agree with me that `400_000_032` is not really that much smaller than `400_000_048`,
    won’t you?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在小元组及其相应列表的情况下，内存使用差异才是明显的——例如，`152`与`168`。但我认为你会同意，`400_000_032`与`400_000_048`实际上并没有小那么多，对吧？
- en: There’s one more thing I observed in my past experiments (code not presented).
    Tuple literals are treated in an exceptional way by the Python compiler, as it
    keeps them in the static memory — so they are created at compile time. Neither
    lists nor tuples created in any other way can be kept in static memory — they
    always use dynamic memory, which means they are created at run time. This topic
    is complex enough to deserve a separate article, so let’s stop here.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我在过去的实验中观察到的另一件事（代码未展示）。Python编译器以特殊方式处理元组字面量，因为它将它们保存在静态内存中——所以它们是在编译时创建的。其他方式创建的列表和元组都不能保存在静态内存中——它们总是使用动态内存，这意味着它们是在运行时创建的。这个话题复杂到足以值得单独的文章，因此我们就此停下。
- en: I’ll leave you here with these benchmarks. If you want to extend them, go ahead.
    If you learn something new and unexpected, please share this in the comments.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我将这些基准留给你。如果你想扩展它们，请随意。如果你学到了新且意外的东西，请在评论中分享。
- en: What I have learned is that tuples should almost never be used only because
    of their performance. But indeed, tuples can be an interesting choice if we need
    a simple type to store really small records, like consisting of two or three elements.
    If field names would help, however, and for more fields, I’d rather use something
    else, a named tuple being one of the choices and a `dataclasses.dataclass` another.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我学到的是，几乎不要仅仅因为性能而使用元组。但的确，如果我们需要一个简单的类型来存储非常小的记录，比如由两个或三个元素组成，元组可能是一个有趣的选择。如果字段名称有帮助，而且字段更多，我宁愿使用其他东西，命名元组是一个选择，`dataclasses.dataclass`是另一个选择。
- en: '![](../Images/af48b3b5aa071084f4966cb0336dd90b.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/af48b3b5aa071084f4966cb0336dd90b.png)'
- en: A list and a tuple. Image by author.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一个列表和一个元组。作者提供的图像。
- en: Advantages of tuples over lists (?)
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组相对于列表的优势（？）
- en: 'In *Fluent Python*, L. Ramalho mentions two advantages of a tuple over a list:
    clarity and performance. Honestly, I cannot find any other advantage, but these
    two can be enough. So, let’s discuss them one by one and decide if they indeed
    make tuples better than lists, at least in some aspects.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在*流畅的Python*中，L. Ramalho提到元组相对于列表的两个优势：清晰度和性能。老实说，我找不到其他优势，但这两个优势可能已经足够。因此，让我们逐一讨论它们，并决定它们是否确实在某些方面使元组优于列表。
- en: Clarity
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清晰度
- en: As L. Ramalho writes, when you’re using a tuple, you know its length will never
    change — and this increases the clarity of code. We have already discussed what
    can happen with a tuple’s length. Indeed, clarity due to immutability is a great
    thing, and we do know that the length of any tuple will *never* change, but…
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如L. Ramalho所写，当你使用元组时，你知道它的长度永远不会改变——这增加了代码的清晰度。我们已经讨论过元组长度可能发生的情况。的确，由于不可变性带来的清晰度是很棒的，我们确实知道任何元组的长度*永远*不会改变，但……
- en: As L. Ramalho warns himself, a tuple with mutable items can be a source of bugs
    that are difficult to find. Do you remember what I mentioned above in relation
    to in-place operations? On the one hand, we may be sure that a tuple, say `x`,
    will never change its length. It’s a valuable piece of information in terms of
    clarity, I agree. However, when we perform in-place operation(s) on `x`, this
    tuple will *stop* being the same tuple, even though it will remain a tuple named
    `x` — but, let me repeat, a different tuple named `x`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如L. Ramalho自己警告的那样，包含可变项的元组可能是难以发现的错误来源。你还记得我之前提到的与原地操作相关的内容吗？一方面，我们可以确定一个元组，比如`x`，它的长度永远不会改变。我同意这是一个在清晰度方面很有价值的信息。然而，当我们对`x`进行原地操作时，这个元组将*不再*是同一个元组，即便它仍然是一个名为`x`的元组——但，请让我重复，是一个不同的名为`x`的元组。
- en: 'Thus, we should revise the above clarity advantage as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该按如下方式修订上述清晰度优势：
- en: '*We can be sure that a tuple of a particular* `id` *will never change its length*.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*我们可以确定一个特定的* `id` *的元组长度永远不会改变*。'
- en: 'Or:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '*We can be sure that if we define a tuple of a particular length, it will not
    change its length, but we should remember that if we use any in-place operation,
    then this tuple is not the same tuple we meant before*.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*我们可以确定，如果我们定义一个特定长度的元组，它的长度不会改变，但我们应该记住，如果我们使用任何原地操作，那么这个元组就不是我们之前所指的那个元组*。'
- en: 'Sounds a little crazy? I fully agree: this is crazy. For me, this is no clarity;
    this is the opposite of clarity. Does anyone think that way? Imagine you have
    a function in which you define a tuple `x`. You then perform in-place concatenation,
    e.g., `x += y`, so it looks as though `y` remained untouched but `x` changed.
    We know it’s not true — as this original `x` does not exist anymore and we have
    a brand new `x` — but this is what it *looks like*, especially because we still
    have a tuple `x` whose first elements are the very same ones that constituted
    the original `x` tuple.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来有点疯狂？我完全同意：这确实很疯狂。对我来说，这不是清晰；这是清晰的对立面。有人这样想吗？想象一下你在一个函数中定义了一个元组 `x`。然后你执行原地连接操作，例如
    `x += y`，这看起来就像 `y` 保持不变但 `x` 发生了变化。我们知道这不是真的——因为这个原始的 `x` 已经不存在，我们有一个全新的 `x`——但这就是它*看起来*的样子，尤其是因为我们仍然有一个元组
    `x`，其第一个元素与原始 `x` 元组中的元素完全相同。
- en: Sure, I know all this makes sense from a Python point of view. But when I’m
    coding, I do not want my thoughts to be occupied that way. For code to be clear,
    I prefer it to be clear without the necessity of making such assumptions. And
    this is the very reason why for me tuples do not mean clarity; they mean less
    clarity than I see in lists.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我知道从 Python 的角度来看这一切都是有意义的。但当我编码时，我不希望我的思维被这种方式占据。为了使代码清晰，我更倾向于让它在不需要做出这样的假设的情况下保持清晰。这正是为什么对我来说，元组并不意味着清晰；它们意味着比我在列表中看到的清晰度要低。
- en: 'This is not all in the context of the tuple’s clarity. In terms of code, there
    is one thing I particularly like in lists but do not like in tuples. Square brackets
    `[]` used to create lists allow them to stand out in the code, as there is no
    other container that would use square brackets. Look at dictionaries: they use
    curly brackets `{}`, and these can be used by sets, too. Tuples use round parentheses
    `()`, and these are used not only in generator expressions but in many various
    places in code, as Python code uses round parentheses for many different purposes.
    Therefore, I like how lists stand out in code — and I don’t like how tuples do
    *not*.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不是元组清晰度的全部。在代码方面，我特别喜欢列表中的一个特性，但不喜欢元组中的这个特性。用于创建列表的方括号 `[]` 使得它们在代码中显得突出，因为没有其他容器使用方括号。看看字典：它们使用大括号
    `{}`，集合也可以使用这些大括号。元组使用圆括号 `()`，而圆括号不仅在生成器表达式中使用，而且在代码中的许多不同地方使用，因为 Python 代码使用圆括号的目的非常多。因此，我喜欢列表在代码中显得突出——而不喜欢元组的*不突出*。
- en: Performance
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: L. Ramalho, writes that a tuple uses less memory than the corresponding list,
    and Python can do the same optimizations for both. We have already analyzed memory
    performance as we know that it’s not always the case — and that the disk memory
    a tuple uses is indeed smaller than that the corresponding list uses, but the
    difference can be negligible.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: L. Ramalho 写道，元组使用的内存比对应的列表少，Python 可以对这两者进行相同的优化。我们已经分析了内存性能，因为我们知道这并不总是如此——实际上，元组所用的磁盘内存确实比对应的列表要小，但这种差异可能微不足道。
- en: This knowledge, combined with the better performance of lists in terms of execution
    time, makes me think that performance does *not* make tuples a better choice.
    In terms of performance in terms of execution time, lists are better. In terms
    of memory usage, tuples can be better indeed — but these days, with the modern
    computers, differences are really small. Besides, when I need a truly memory-efficient
    container to collect a lot of data, I’d choose neither list nor tuple — but a
    generator.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这种知识，加上列表在执行时间上的更好性能，使我认为性能*不*使元组成为更好的选择。在执行时间方面，列表更好。在内存使用方面，元组确实可以更好——但现在，随着现代计算机的出现，这些差异真的很小。此外，当我需要一个真正节省内存的容器来收集大量数据时，我不会选择列表或元组——而是选择生成器。
- en: 'Another thing: tuples as dictionary keys'
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另一件事：元组作为字典键
- en: In addition to these two aspects, there is a third one that’s worth consideration,
    one we have already mentioned — you cannot use lists as keys in dictionaries,
    but you can use tuples. Or rather, you can use truly immutable (that is, hashable)
    tuples. The reason is the former’s mutability and the latter’s immutability.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这两个方面，还有一个值得考虑的第三个方面，我们已经提到过——你不能将列表用作字典中的键，但可以使用元组。或者说，你可以使用真正不可变（即，可哈希）的元组。原因在于前者的可变性和后者的不可变性。
- en: Unlike the previous two, this advantage can be significant in particular situations,
    even if rather rare ones.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与前两个优势不同，这个优势在特定情况下可能非常显著，即使这种情况比较少见。
- en: Tuple comprehensions (?)
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组推导（?）
- en: If you hope to learn from this section that there are tuple comprehensions in
    Python, or if you hope to learn something amazing that will blew minds of your
    fellow Pythonistas — I am so sorry! I did not want to create false hopes. No tuple
    comprehensions today; no mind-blowing syntax.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望从这一节中了解到 Python 中存在元组推导，或者希望学到一些能让你的 Python 爱好者同伴惊叹的惊人技巧——我很抱歉！我并不想制造虚假的希望。今天没有元组推导；没有让人震撼的语法。
- en: 'You may remember that in my article on Python comprehensions, I did not mention
    tuple comprehensions:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，在我关于 Python 推导的文章中，我并没有提到元组推导：
- en: '[](/a-guide-to-python-comprehensions-4d16af68c97e?source=post_page-----24d2bf02971b--------------------------------)
    [## A Guide to Python Comprehensions'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[](/a-guide-to-python-comprehensions-4d16af68c97e?source=post_page-----24d2bf02971b--------------------------------)
    [## Python 推导指南'
- en: Learn the intricacies of list comprehensions (listcomps), set comprehensions
    (setcomps), dictionary comprehensions…
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习列表推导（listcomps）、集合推导（setcomps）、字典推导的复杂性…
- en: towardsdatascience.com](/a-guide-to-python-comprehensions-4d16af68c97e?source=post_page-----24d2bf02971b--------------------------------)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: towardsdatascience.com](/a-guide-to-python-comprehensions-4d16af68c97e?source=post_page-----24d2bf02971b--------------------------------)
- en: This is because there are no tuple comprehensions. But as I do not want to leave
    you with nothing, I do have a consolation gift for you. I’ll show you some substitutes
    for tuple comprehensions.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为没有元组推导。但我不想让你空手而归，我为你准备了一个安慰奖。我会向你展示一些元组推导的替代方案。
- en: 'First of all, do remember that a generator expression is *not* a tuple comprehension.
    I think many Python beginners make a mistake of confusing the two. I specifically
    remember seeing my first generator expression after learning list comprehensions.
    My first thought was, “Yup, here it is. A tuple comprehension.” I quickly learned
    that while the first from these two was indeed a list comprehension, the second
    was *not* a tuple comprehension:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，记住生成器表达式*不是*元组推导。我认为许多 Python 初学者会混淆这两者。我特别记得在学习列表推导后第一次看到我的生成器表达式。我的第一反应是，“嗯，这就是了。一个元组推导。”我很快意识到，虽然前者确实是列表推导，但后者*不是*元组推导：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: I spent some time — if not *wasted* it — only to learn that there are list comprehensions,
    and set comprehensions, and dict comprehensions, and generator expressions — but
    no tuple comprehensions. Don’t repeat my mistake. Don’t spend hours on looking
    for tuple comprehensions. They don’t exist in Python.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我花了一些时间——如果不是*浪费*的话——才了解到有列表推导、集合推导、字典推导和生成器表达式——但没有元组推导。不要重蹈我的覆辙。不要花几个小时去寻找元组推导。它们在
    Python 中不存在。
- en: But here it is, my consolation gift for you — two substitutes for tuple comprehensions.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我的安慰奖——两个元组推导的替代方案。
- en: '*Substitute 1*: `tuple()` + `genexp`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*替代方案 1*: `tuple()` + `genexp`'
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Have you noticed that you do not need to create a list comprehension first and
    the tuple then? Indeed, here we create a generator expression and use the `tuple()`
    class to it. This, of course, gives us a tuple.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到你不需要先创建一个列表推导然后是元组？确实，在这里我们创建了一个生成器表达式，并用`tuple()`类来转换它。这自然会给我们一个元组。
- en: '*Substitute 2*: `genexp` + generator unpacking'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*替代方案 2*: `genexp` + 生成器解包'
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A nice hack, isn’t it? It uses [the extended unpacking of iterables](https://peps.python.org/pep-3132/),
    which returns a tuple. You can use it for any iterable, and since a generator
    is one, it works! Let’s check if it works also for a list:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不错的小技巧，不是吗？它使用了[扩展的可迭代解包](https://peps.python.org/pep-3132/)，它返回一个元组。你可以用它来处理任何可迭代对象，既然生成器是其中之一，它就有效！让我们检查它是否也对列表有效：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can do the same without assigning to `x`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以不赋值给`x`而做同样的事情：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It will work for any iterable — but don’t forget the comma at the line end;
    without it, the trick will not work:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 它适用于任何可迭代对象——但别忘了行末的逗号；没有它，这个技巧将无法奏效：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let’s check for sets:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查集合：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It works! And note that generally, unpacking provides a tuple. This is why
    the extended iterable unpacking looks a little bit like a tuple comprehension.
    Although it does look like a nice little hack, it’s not: it’s one of the tools
    that Python offers, although it’s an edge case indeed.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 它有效！并且要注意，通常，解包提供一个元组。这就是为什么扩展的可迭代解包看起来有点像元组推导。虽然它确实像一个不错的小技巧，但其实不是：这是 Python
    提供的工具之一，尽管它确实是一个边缘情况。
- en: But I would *not* use *substitute 2*. I’d definitely go for *substitute 1*,
    which uses `tuple()`. Most of us love tricks like the second substitute, but they
    are seldom clear — and *substitute 2*, unlike *substitute 1*, is far from being
    clear. Nevertheless, any Pythonista will see what’s going on in *substitute 1*,
    even if they do not see that there’s a generator expression hidden in an in-between
    step.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 但我*不会*使用*替代方案 2*。我会选择*替代方案 1*，它使用`tuple()`。我们大多数人喜欢像第二个替代方案这样的技巧，但它们很少清晰——而且*替代方案
    2*，与*替代方案 1*相比，远不如前者清晰。不过，任何Python爱好者都会看到*替代方案 1*中的内容，即使他们没有看到其中隐藏的生成器表达式。
- en: Named tuples
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名元组
- en: Tuples are unnamed — but this does not mean there are no named tuples in Python.
    On the contrary, there are — and, unsurprisingly, they are called…named tuples.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是未命名的——但这并不意味着Python中没有命名元组。恰恰相反，确实存在——而且，毫无意外，它们被称为……命名元组。
- en: 'You have two possibilities to use named tuples: `collections.namedtuple` and
    `typing.NamedTuple`. Named tuples are what their named suggest: tuples whose elements
    (called fields) have names. You can see the former in action in Appendix, in the
    benchmarking script.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你有两种方法来使用命名元组：`collections.namedtuple`和`typing.NamedTuple`。命名元组顾名思义：它们的元素（称为字段）具有名称。你可以在附录中的基准测试脚本中看到前者的实际应用。
- en: Personally, I consider them extremely helpful in many various situations. They
    do not offer any improvement in performance; they can even decrease it. But when
    it comes to clarity, they can be much clearer, both to the developer and to the
    code’s user.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 就个人而言，我认为它们在许多不同情况下都非常有帮助。它们不会提高性能；甚至可能会降低性能。但在清晰性方面，它们可以更清楚，无论是对开发者还是对代码的用户。
- en: Thus, although I often go for a regular tuple, sometimes I decide to choose
    a named tuple — and this is exactly because of its clarity.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管我经常使用常规元组，有时我会选择命名元组——这正是因为它的清晰性。
- en: Named tuples offer so rich possibilities that they deserve their own article.
    Therefore, that’s all I’m going to tell you about them here — but I plan to write
    an article dedicated to this powerful type.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 命名元组提供了丰富的可能性，值得专门为它们写一篇文章。因此，我在这里仅仅讲述这些——但我计划写一篇专门讨论这种强大类型的文章。
- en: '![](../Images/3d0766b50bbdc25cfa5ecbb9dde984d7.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3d0766b50bbdc25cfa5ecbb9dde984d7.png)'
- en: Word “tuple” in various languages. Image by author.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: “元组”在各种语言中的表示。图像由作者提供。
- en: Conclusion
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: This article, along with [the previous one](/python-tuple-the-whole-truth-and-only-the-truth-hello-tuple-12a7ab9dbd0d),
    aimed to provide you with deep information about tuples, their use cases, pros
    and cons, and intricacies. Although tuples are used quite often, they are not
    that well known among developers, particularly those with shorter experience in
    Python development. That’s why I wanted to collect rich information about this
    interesting type in one place — and I hope you’ve learned something from reading
    it, maybe even as much as I learned myself from writing it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 本文以及[上一篇文章](/python-tuple-the-whole-truth-and-only-the-truth-hello-tuple-12a7ab9dbd0d)旨在提供关于元组、它们的用例、优缺点及其复杂性的深入信息。尽管元组的使用非常普遍，但在开发者中，尤其是那些经验较少的Python开发者中，它们并不那么知名。这就是为什么我想将关于这个有趣类型的丰富信息集中在一个地方——希望你从阅读中学到了一些东西，甚至像我从写作中学到的一样多。
- en: To be honest, when starting to write about tuples, I thought that I’d find more
    advantages of them. I’ve been using them from the first day I started using Python.
    Although I used lists far more often, I somehow liked tuples, even though I did
    not know too much about them — so some of the information I included in this article
    was new to me.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，在开始写关于元组的内容时，我以为会发现更多的优势。我从开始使用Python的第一天起就一直在使用元组。尽管我使用列表的频率要高得多，但我还是喜欢元组，尽管对它们了解不多——所以我在这篇文章中包含的一些信息对我来说是新的。
- en: After writing this article, however, I am not that great a fan of tuples anymore.
    I still consider them a valuable type for small records, though quite often their
    extension — named tuples — or data classes seem a better approach. What’s more,
    tuples do not seem to be too effective. They are slower than lists, and use only
    a little less memory. So, why should I use them?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在写完这篇文章后，我对元组的喜爱已经不那么强烈了。我仍然认为它们是处理小记录的有价值类型，但它们的扩展——命名元组——或数据类似乎是更好的方法。而且，元组似乎也不是特别有效。它们比列表要慢，而且只节省了少量内存。那么，我为什么还要使用它们呢？
- en: Maybe because of their immutability? Maybe. If you like functional programming,
    which is based upon the concept of immutability, you will definitely prefer tuples
    over lists. I used this argument not once and not twice to convince myself that
    I should prefer a tuple over a list in this or another situation.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 也许是因为它们的不可变性？也许。如果你喜欢基于不可变性概念的函数式编程，你肯定会更喜欢元组而不是列表。我曾多次使用这个论点来说服自己在这种或那种情况下应该更喜欢元组而不是列表。
- en: 'But the immutability that the tuple offers is, as we discussed, not that *clear.*
    Imagine `x`, a tuple of items of immutable types. We know this tuple is trule
    immutable, right? If so, I do not like the following code, which is fully correct
    in Python:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 但元组所提供的不可变性，如我们讨论的那样，并不是那么*明确*。假设`x`是一个不可变类型的项的元组。我们知道这个元组确实是不可变的，对吗？如果是这样，我不喜欢以下代码，这在Python中是完全正确的：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'I know this is correct Python, and I know this is even Pythonic code — but
    I don’t like it. I don’t like that I can do something like this with Python tuples.
    It just does not have the vibe of the tuple’s immutability. The way I see it,
    if you have an immutable type, you should be able to copy it, you should be able
    to concatenate two instances, and the like — but you *should* *not* be able to
    assign a new tuple to an old name using an in-place operation. You want this name
    to be the same? Your choice. So, I am fine with this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这在Python中是正确的，我知道这甚至是Pythonic的代码——但我不喜欢它。我不喜欢我可以用Python元组做这样的事情。它根本没有元组不可变性的感觉。依我看，如果你有一个不可变类型，你应该能够复制它，你应该能够连接两个实例等等——但你*不应该*能够通过就地操作将一个新元组赋给旧名称。你想让这个名称保持不变？你的选择。所以，我对以下情况没问题：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: as it means assigning `x + y` to `x`, which basically means overwriting this
    name. If you choose to overwrite the previous value of `x`, it’s your choice.
    But in-place operations, at least in my eyes, do not have the feeling of immutability.
    I’d prefer to *not* be able to do this in Python.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这意味着将`x + y`赋值给`x`，这基本上意味着覆盖这个名称。如果你选择覆盖`x`的先前值，这是你的选择。但就我而言，就地操作至少没有不可变性的感觉。我更愿意在Python中*不能*做到这一点。
- en: If not immutability, then maybe something else should convince me to use tuples
    more often? But what? Performance? Tuples’ performance is poor, so this does not
    convince me. In terms of execution time, there is no discussion; they are definitely
    slower than the corresponding lists. You may say that in terms of memory. Indeed,
    they do take less disk space, but the difference is subtle, and for long containers
    — totally negligible. RAM memory use? This argument also turned out to not be
    too successful, because generally, lists turned out to be as efficient as tuples
    — and sometimes even more efficient. And if we have a huge collection, a generator
    will do better in terms of memory.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有不可变性，那么也许其他的因素应该说服我更常使用元组？但是什么呢？性能？元组的性能较差，因此这并不能说服我。在执行时间方面，毫无争议；它们确实比相应的列表慢。你可以说在内存方面。确实，它们占用的磁盘空间更少，但差异微妙，对于长容器来说——完全可以忽略。RAM内存使用？这个论点也没有太成功，因为通常列表的效率和元组一样——有时甚至更高。如果我们有一个巨大的集合，生成器在内存方面会表现更好。
- en: Despite all that, tuples do have their place in Python. They are very frequently
    used to return two or three items from a function or method — so, as small unnamed
    records. They are used as the output of iterable unpacking. And they constitute
    the base of named tuples — `collections.namedtuple` and `typing.NamedTuple` —
    the tuple’s powerful siblings that can be used as records with named fields.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，元组在Python中确实有其存在的意义。它们非常频繁地被用来从函数或方法中返回两个或三个项——所以，作为小型未命名记录。它们被用作可迭代解包的输出。它们构成了命名元组的基础——`collections.namedtuple`和`typing.NamedTuple`——这些是元组的强大兄弟，可以用作具有命名字段的记录。
- en: All in all, I do not like tuples as much as I did before writing this article.
    I treated them as an important Python type; now it’s not as important in my eyes
    as it was — but I accept their various use cases in Python, and I even like some
    of them.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我不再像写这篇文章之前那样喜欢元组了。我曾把它们视为一个重要的Python类型；现在在我眼中它们不再那么重要——但我接受它们在Python中的各种使用场景，甚至喜欢其中一些。
- en: Am I unfair for tuples? Maybe. If you think so, please let me know in the comments.
    I always enjoy fruitful discussions with my readers.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我对元组是否不公平？也许。如果你这么认为，请在评论中告诉我。我总是很享受与读者的有益讨论。
- en: 'Thank you for reading. If you enjoyed this article, you may also enjoy other
    articles I wrote; you will see them [here](https://medium.com/@nyggus). If you
    want to join Medium, please use my referral link below:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢阅读。如果你喜欢这篇文章，你可能也会喜欢我写的其他文章；你可以在[这里](https://medium.com/@nyggus)查看。如果你想加入Medium，请使用下面的推荐链接：
- en: '[](https://medium.com/@nyggus/membership?source=post_page-----24d2bf02971b--------------------------------)
    [## Join Medium with my referral link — Marcin Kozak'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@nyggus/membership?source=post_page-----24d2bf02971b--------------------------------)
    [## 使用我的推荐链接加入 Medium — Marcin Kozak'
- en: Read every story from Marcin Kozak (and thousands of other writers on Medium).
    Your membership fee directly supports…
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阅读Marcin Kozak的每一个故事（以及Medium上的其他成千上万的作者）。你的会员费直接支持…
- en: medium.com](https://medium.com/@nyggus/membership?source=post_page-----24d2bf02971b--------------------------------)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[medium.com](https://medium.com/@nyggus/membership?source=post_page-----24d2bf02971b--------------------------------)'
- en: Resources
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源
- en: '[](/a-guide-to-python-comprehensions-4d16af68c97e?source=post_page-----24d2bf02971b--------------------------------)
    [## A Guide to Python Comprehensions'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[](/a-guide-to-python-comprehensions-4d16af68c97e?source=post_page-----24d2bf02971b--------------------------------)
    [## Python 理解的指南'
- en: Learn the intricacies of list comprehensions (listcomps), set comprehensions
    (setcomps), dictionary comprehensions…
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了解列表推导（listcomps）、集合推导（setcomps）、字典推导的细节…
- en: towardsdatascience.com](/a-guide-to-python-comprehensions-4d16af68c97e?source=post_page-----24d2bf02971b--------------------------------)  [##
    PEP 3132 — Extended Iterable Unpacking
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: towardsdatascience.com](/a-guide-to-python-comprehensions-4d16af68c97e?source=post_page-----24d2bf02971b--------------------------------)  [##
    PEP 3132 — 扩展的可迭代解包
- en: This PEP proposes a change to iterable unpacking syntax, allowing to specify
    a “catch-all” name which will be assigned…
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 这个PEP提议对可迭代解包语法进行更改，允许指定一个“全能”名称来接收…
- en: peps.python.org](https://peps.python.org/pep-3132/?source=post_page-----24d2bf02971b--------------------------------)
    [](https://www.oreilly.com/library/view/fluent-python-2nd/9781492056348/?source=post_page-----24d2bf02971b--------------------------------)
    [## Fluent Python, 2nd Edition
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[peps.python.org](https://peps.python.org/pep-3132/?source=post_page-----24d2bf02971b--------------------------------)
    [](https://www.oreilly.com/library/view/fluent-python-2nd/9781492056348/?source=post_page-----24d2bf02971b--------------------------------)
    [## Fluent Python, 第2版'
- en: Python's simplicity lets you become productive quickly, but often this means
    you aren't using everything it has to…
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python 的简洁性让你能够迅速提高生产力，但这通常意味着你没有充分利用它所具备的所有功能…
- en: www.oreilly.com](https://www.oreilly.com/library/view/fluent-python-2nd/9781492056348/?source=post_page-----24d2bf02971b--------------------------------)
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.oreilly.com](https://www.oreilly.com/library/view/fluent-python-2nd/9781492056348/?source=post_page-----24d2bf02971b--------------------------------)'
- en: Appendix
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录
- en: 'In this Appendix, you will find the script I used for benchmarking tuples against
    lists. I used the `perftester` package, about which you can read in this article:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个附录中，你将找到我用来基准测试元组与列表的脚本。我使用了`perftester`包，你可以在这篇文章中阅读相关信息：
- en: '[](/benchmarking-python-functions-the-easy-way-perftester-77f75596bc81?source=post_page-----24d2bf02971b--------------------------------)
    [## Benchmarking Python Functions the Easy Way: perftester'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[](/benchmarking-python-functions-the-easy-way-perftester-77f75596bc81?source=post_page-----24d2bf02971b--------------------------------)
    [## 轻松进行Python函数基准测试：perftester'
- en: You can use perftester to benchmark Python functions the easy way
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你可以使用perftester轻松对Python函数进行基准测试
- en: towardsdatascience.com](/benchmarking-python-functions-the-easy-way-perftester-77f75596bc81?source=post_page-----24d2bf02971b--------------------------------)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: towardsdatascience.com](/benchmarking-python-functions-the-easy-way-perftester-77f75596bc81?source=post_page-----24d2bf02971b--------------------------------)
- en: 'This is the code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码：
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And here are the results:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是结果：
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: I decided to run memory-usage benchmarks for much bigger `n`, that is, of 5
    and 10 million. I will not present the code here, and if you have some time to
    spare, you may consider it a nice exercise to write it, based on the above script.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我决定对更大的`n`进行内存使用基准测试，即500万和1000万。我不会在这里展示代码，如果你有时间，可以基于上面的脚本写一个代码，这将是一个不错的练习。
- en: If you just want to see the code, however, you will find it [here](https://gist.github.com/nyggus/3dc967d5e88593b624e2acb3e675a62d).
    Note that I could make the code better, as I could join the code for the two experiments.
    I decided not to do that, in order to keep the two scripts rather simple.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想查看代码，你可以在[这里](https://gist.github.com/nyggus/3dc967d5e88593b624e2acb3e675a62d)找到。请注意，我可以改进代码，例如将两个实验的代码合并。我决定不这样做，以保持两个脚本的简单性。
- en: 'Here are the results:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果：
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you see, for the operations we study, tuples take either the same or more
    memory — sometimes even significantly more (compare, for instance, `554.8` vs
    `478.5` or `783.7` vs `707.4`).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，对于我们研究的操作，元组要么占用相同的内存，要么占用更多的内存——有时甚至显著更多（例如，比较`554.8`与`478.5`或`783.7`与`707.4`）。
