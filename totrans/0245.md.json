["```py\nimport numpy as np\nimport matplotlib.pyplot as plt\n# define matrices and vector\nx_scaled_matrix = np.array([[2,0],[0,1]])\nmirror_matrix = np.array([[0,1],[1,0]])\nv = np.array([1,2])\n# matrix transformation\nmirrored_v = mirror_matrix.dot(v)\nx_scaled_v = x_scaled_matrix.dot(v)\n# plot transformed vectors\norigin = np.array([[0, 0], [0, 0]])\nplt.quiver(*origin, v[0], v[1], color=['black'],scale=10, label='original vector')\nplt.quiver(*origin, mirrored_v[0], mirrored_v[1] , color=['#D3E7EE'], scale=10, label='mirrored vector' )\nplt.quiver(*origin, x_scaled_v[0], x_scaled_v[1] , color=['#C6A477'], scale=10, label='x_scaled vector')\nplt.legend(loc =\"lower right\")\n```", "```py\n# generate random variables x0 and x1\nimport random\nx0 = [round(random.uniform(-1, 1),2) for i in range(0,100)]\nx1 = [round(2 * i + random.uniform(-1, 1) ,2) for i in x0]\n\n# compute covariance matrix\nX = np.stack((x0, x1), axis=0)\ncovariance_matrix = np.cov(X)\nprint('covariance matrix\\n', covariance_matrix)\n```", "```py\n# plot original data points\nplt.scatter(x0, x1, color=['#D3E7EE'])\n\n# vectors before transformation\nv_original = [np.array([[1,0.2]]), np.array([[-1,1.5]]), np.array([[1.5,-1.3]]), np.array([[1,1.4]])]\n\n# vectors after transformation\nfor v in v_original:\n    v_transformed = v.dot(covariance_matrix)\n    origin = np.array([[0, 0], [0, 0]])\n    plt.quiver(*origin, v[:, 0], v[:, 1], color=['black'], scale=4)\n    plt.quiver(*origin, v_transformed[:, 0], v_transformed[:, 1] , color=['#C6A477'], scale=10)\n\n# plot formatting\nplt.axis('scaled')   \nplt.xlim([-2.5,2.5])\nplt.ylim([-2.5,2.5])\n```", "```py\nfrom numpy.linalg import eig\neigenvalue,eigenvector = eig(covariance_matrix)\nplt.quiver(*origin, eigenvector[:,1][0], eigenvector[:,1][1] , color=['red'], scale=4, label='eigenvector')\n```", "```py\nfrom sklearn.preprocessing import StandardScaler\nscaler = StandardScaler()\nscaled_df = scaler.fit_transform(df)\n```", "```py\nfrom sklearn.decomposition import PCA\npca = PCA(n_components=3)\npca_data = pca.fit_transform(scaled_df)\n```", "```py\nimport matplotlib.pyplot as plt\nprincipal_components = ['PC1', 'PC2', 'PC3']\nexplained_variance = pca.explained_variance_ratio_\ncumulative_variance = np.cumsum(explained_variance)\nplt.figure(figsize=(10, 6))\nplt.bar(principal_components, explained_variance, color='#D3E7EE')\nplt.plot(principal_components, cumulative_variance, 'o-', linewidth=2, color='#C6A477')\n\n# add cumulative variance as the annotation\nfor i,j in zip(principal_components, cumulative_variance):\n   plt.annotate(str(round(j,2)), xy=(i, j))\n```", "```py\npca_component_df = pd.DataFrame(pca.components_, columns = df.columns)\npca_component_df\n```", "```py\nimport seaborn as sns\n# create custom color palette\ncustomPalette = sns.color_palette(\"blend:#D3E7EE,#C6A477\", as_cmap=True)\n\n# create heatmap\nplt.figure(figsize=(24,3))\nsns.heatmap(pca_component_df, cmap=customPalette, annot=True)\n```", "```py\npca_df = pd.DataFrame(pca_data)\nnew_df = pd.concat([pca_df,label_df], axis = 1)\nnew_df.columns = [\"PC1\", \"PC2\", \"PC3\", \"Rank\"]\n```"]