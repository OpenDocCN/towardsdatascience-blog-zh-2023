- en: 'Ghostly Images and Qubits: A New Way to Visualize Quantum Superposition'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/ghostly-images-and-qubits-a-new-way-to-visualize-quantum-superposition-94b582889549](https://towardsdatascience.com/ghostly-images-and-qubits-a-new-way-to-visualize-quantum-superposition-94b582889549)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: TUTORIAL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Explore the mysteries of quantum computing!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@KoryBecker?source=post_page-----94b582889549--------------------------------)[![Kory
    Becker](../Images/53a2493fe53f215d3e715d456b36c553.png)](https://medium.com/@KoryBecker?source=post_page-----94b582889549--------------------------------)[](https://towardsdatascience.com/?source=post_page-----94b582889549--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----94b582889549--------------------------------)
    [Kory Becker](https://medium.com/@KoryBecker?source=post_page-----94b582889549--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----94b582889549--------------------------------)
    ·10 min read·Mar 9, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6322d4be6fdff1aabc739218f6b977ee.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Source: [Stable Diffusion](https://stablediffusionweb.com).'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve always loved creating games
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever I learn a new programming language or framework, I often find myself
    trying to program a [game](https://medium.com/towards-data-science/the-magic-of-quantum-computing-a-beginners-guide-to-writing-a-magic-number-guessing-game-c1cdb384f457)
    as a first try at using the various features of the platform.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of quantum computing, creating the [beginnings](https://medium.com/towards-data-science/programming-in-3d-my-first-steps-into-quantum-computing-566b9b93929d)
    of a game in order to learn the concepts is absolutely perfect.
  prefs: []
  type: TYPE_NORMAL
- en: Now, quantum computing has a range of topics and features to learn. These may
    include how qubits are made, how qubits are [manipulated](https://medium.com/towards-data-science/programming-in-3d-my-first-steps-into-quantum-computing-566b9b93929d),
    the various gates, but the focus of this tutorial will be the all-powerful concept
    of **superposition**!
  prefs: []
  type: TYPE_NORMAL
- en: The incredible qubit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Superposition is one of the core features in programming quantum computers,
    since it allows a qubit to hold a value of both 0 and 1 simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: When a qubit is in superposition it functions in a quantum state. This makes
    it powerful!
  prefs: []
  type: TYPE_NORMAL
- en: Exponential processing power
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A classical computer with one bit can process one bit of information (*0* ***or***
    *1*). By contrast, a quantum computer with one qubit can process two bits of information
    (*0* ***and*** *1*).
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, two classical bits can process two bits of information, while two
    qubits extend this to processing four bits of information (*00, 01, 10, 11*).
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, this allows a quantum computer with n-qubits to process 2^n bits
    of information — all in a single CPU cycle.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/204aa50228e7b6a2acfb1f1d65a50084.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A quantum computer with n-qubits in superposition can process 2^n states per
    cycle. Source: Author.'
  prefs: []
  type: TYPE_NORMAL
- en: It can be quite amazing to consider that a quantum computer with just 55 qubits
    can process nearly 5 petabytes (*2^55 bits*) of information in a single cycle.
  prefs: []
  type: TYPE_NORMAL
- en: This could be the entire database of your favorite social media web site, processed
    in an instant!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: That’s a lot!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Indeed, this is the amazing difference between classical and quantum computers,
    and is a result of the simultaneous nature of a qubit in superposition, also called
    [quantum parallelism](https://www.sciencedirect.com/topics/mathematics/quantum-parallelism).
  prefs: []
  type: TYPE_NORMAL
- en: In fact, superposition allows for quadratic and exponential performance boosts
    from algorithms designed to leverage this unique quantum ability.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, for our project, we will just need a single qubit.
  prefs: []
  type: TYPE_NORMAL
- en: Qubits on a classical computer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to interpret and use the value from a qubit, we have to measure it.
  prefs: []
  type: TYPE_NORMAL
- en: This simple act of measuring a qubit results in a collapse of the quantum state,
    which changes the qubit from holding a value of both 0 and 1 simultaneously, to
    instead holding an exclusive value of 0 or 1 — just like a classical bit.
  prefs: []
  type: TYPE_NORMAL
- en: Since a measured qubit can now be interpreted as a value of 0 or 1, we can use
    the qubit just like you would with a classical computer.
  prefs: []
  type: TYPE_NORMAL
- en: '*Keep this in mind, as this is where the fun begins!*'
  prefs: []
  type: TYPE_NORMAL
- en: Unicorns and gremlins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Visualizing a qubit in superposition is often performed using various [diagrams](https://quantum-computing.ibm.com/composer/docs/iqx/visualizations)
    including: q-spheres, phase disks, and state-vectors.'
  prefs: []
  type: TYPE_NORMAL
- en: However, I wanted to try something more fun!
  prefs: []
  type: TYPE_NORMAL
- en: Since a qubit in superposition will hold a value of 0 and 1 simultaneously,
    I thought it would be fun to draw two images superimposed on top of one another.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6e5ce0558948fedfa4972580765158fe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The two images to be superimposed according to a qubit’s measurements. Source:
    [Stable Diffusion](https://stablediffusionweb.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: Each of the two images will represent a state of either 0 or 1 that the qubit
    may be in. Depending upon the measurement of the qubit in the [computational basis
    state](https://www.quantum-inspire.com/kbase/qubit-basis-states/) and the percentage
    chance that the qubit will measure as a value of 0 or 1, we can adjust the transparency
    (or alpha blend) of the two images in order to show one more prominently than
    the other.
  prefs: []
  type: TYPE_NORMAL
- en: The act of blending the images together on top of one other helps create a beautiful
    effect that shows how a qubit behaves.
  prefs: []
  type: TYPE_NORMAL
- en: Ghostly images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A qubit placed into superposition will have a default measurement chance of
    50% to measure as a value of 0 and 50% to measure as a value of 1.
  prefs: []
  type: TYPE_NORMAL
- en: A qubit in superposition is essentially random.
  prefs: []
  type: TYPE_NORMAL
- en: However, we can partially invert a qubit towards either of the values. This
    results in the qubit measuring more frequently as a 0 or 1, depending upon the
    amount of inversion applied.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use this feature of quantum computing to control the image transparency.
    To do this, we need a to use a special kind of quantum gate.
  prefs: []
  type: TYPE_NORMAL
- en: When an X-gate just isn’t enough
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qubits can be inverted from a value of 0 to 1 or vice-versa by using the [X-gate](https://qiskit.org/documentation/stubs/qiskit.circuit.library.XGate.html).
  prefs: []
  type: TYPE_NORMAL
- en: The X-gate is just like a classical computer’s NOT operator. It simply flips
    the value of a qubit.
  prefs: []
  type: TYPE_NORMAL
- en: However, we don’t want to just flip a qubit from 0 to 1, as that would simply
    flip our image immediately from one to the other, with no ghostly in between state.
    Instead, we want to show a gradual change from one image to the next, and all
    states in between.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, there are more than just a few [gates](https://qiskit.org/textbook/ch-states/single-qubit-gates.html)
    in the quantum toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: The three-dimensional qubit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A qubit contains three axes that affect its measurement behavior. These include
    the X, Y, and Z-axis.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f141ddfb0060cf73105257ab02aeb16c.png)'
  prefs: []
  type: TYPE_IMG
- en: '[Smite-Meister](https://commons.wikimedia.org/wiki/File:Bloch_sphere.svg),
    [CC BY-SA 3.0](https://creativecommons.org/licenses/by-sa/3.0), via Wikimedia
    Commons.'
  prefs: []
  type: TYPE_NORMAL
- en: Certain quantum gates rotate about the various axes in differing ways, which
    end up affecting the resulting measurement of the qubit.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the X-gate performs a 180-degree rotation around the X-axis, flipping
    the qubit value from 0 to 1 (or 1 to 0).
  prefs: []
  type: TYPE_NORMAL
- en: There are also the Y and Z-gates, which rotate about their respective axes in
    a similar fashion.
  prefs: []
  type: TYPE_NORMAL
- en: These gates all have a distinct impact on the resulting measurement of the qubit.
    However, there is one specific gate that provides us with the partial inversion
    effect that we’re looking for.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the U-gate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The [U-gate](https://qiskit.org/documentation/stubs/qiskit.circuit.library.UGate.html)
    is a special gate that takes three arguments. These include *theta*, *phi*, and
    *lam*. The arguments allow modifying the [Euler angles](https://en.wikipedia.org/wiki/Euler_angles)
    of the qubit in order to [rotate](https://quantumcomputinguk.org/tutorials/introduction-to-the-u3-gate-with-code)
    around the [Bloch sphere](https://en.wikipedia.org/wiki/Bloch_sphere).
  prefs: []
  type: TYPE_NORMAL
- en: The U-gate is actually a [generalized](https://qiskit.org/textbook/ch-states/single-qubit-gates.html#generalU)
    version for single-qubit quantum gates and can even be used as a replacement,
    depending on the values for the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: You can try adjusting the various arguments of the U-gate to see the resulting
    effect on the qubit measurements.
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, changing the *theta* argument allows us to skew the chance
    of a qubit measuring a 0 or 1 in exactly the fashion that we’re looking for!
  prefs: []
  type: TYPE_NORMAL
- en: Playing with the U-gate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The U-gate’s value for *theta* generally ranges from -1.5 to 1.5.
  prefs: []
  type: TYPE_NORMAL
- en: At the lower end of the range, the qubit measurements will result closer towards
    a measurement of zero. At the higher end of the range, measurements will be closer
    towards one. Any value between will result in a skew towards 0 or 1.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we could set the qubit to have a 20% chance of measuring as 0,
    and 80% chance as measuring 1, by setting the *theta* angle for the U-gate to
    0.8.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the amount of inversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Continuing to adjust the U-gate’s values, we can see how the qubit measurements
    result in various chances of holding a 0 or 1 according to the U-gate *theta*
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Since the range for *theta* that we will be using is -1.5 to 1.5, if we set
    the rate for *theta* to 0.0, we will see a traditional 50/50 chance of measuring
    0 or 1\. However, if we set the value for *theta* to -0.6, we can see a skewed
    behavior, resulting in a much higher chance of measuring 0 than measuring 1.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f5e71334e61adc344701233b189dbe36.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The distribution of measurements from a qubit in superposition with partial
    inversion from a U-gate. The qubit has a much higher chance of measuring 0 than
    1\. Source: Author.'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, if we set *theta* all the way to -1.5, we’ll have a near 100% chance
    of always measuring a 0\. Likewise, setting the value to 1.5 will result in a
    measurement of 1.
  prefs: []
  type: TYPE_NORMAL
- en: With the mechanics out of the way, let’s put our program together!
  prefs: []
  type: TYPE_NORMAL
- en: Our plan of attack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll start by creating a quantum program that places a single qubit into superposition.
  prefs: []
  type: TYPE_NORMAL
- en: Since the default nature of a qubit in superposition results in a 50/50 chance
    of measuring 0 or 1, we’ll use the U-gate to slightly nudge the qubit towards
    a specific direction.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll adjust the transparency of our two images according to the measurements
    of the qubit, while sliding the *theta* argument for the U-gate up and down.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the quantum program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our quantum circuit is quite simple. We’ll simply create a program that joins
    a Hadamard gate for placing the qubit into superposition, with a U-gate for applying
    the desired rotation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/e2f186b70567672b57f3275833c0d4c4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A qubit in superposition with partial inversion. The resulting measurement
    will skew towards 0 or 1 according to the U-gate theta value. Source: Author.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the invert method to set transparency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we want modify the rate of inversion over time as our images display,
    we can create a helper method for inverting the qubit.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we’ll use a more natural *rate* parameter to control the inversion,
    which will range from 0.0 to 1.0, instead of the more awkward *theta* range of
    -1.5 to 1.5.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ll return the resulting qubit measurements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If we call the *invert()* method with a rate of 0.5, we’ll have the same old
    equal 50/50 chance of measuring a 0 or 1.
  prefs: []
  type: TYPE_NORMAL
- en: However, if we set the rate to 0.3, we’ll have a 70–80% chance of measuring
    a 0 compared to measuring a 1, as shown in the following result.
  prefs: []
  type: TYPE_NORMAL
- en: '{‘0’: 792, ‘1’: 232}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We can slide the value for *rate* up or down to affect the measurement of the
    qubit accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: The battle for display
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our quantum computing program is in place, we can use the qubit as
    our sole indicator to draw either the unicorn or the gremlin with greater opacity.
  prefs: []
  type: TYPE_NORMAL
- en: If there are more zero-measurements for the qubit, we’ll draw the unicorn in
    more clarity.
  prefs: []
  type: TYPE_NORMAL
- en: If there are more one-measurements for the qubit, we’ll draw the gremlin in
    more clarity.
  prefs: []
  type: TYPE_NORMAL
- en: If the qubit measures somewhere between the two, we’ll draw both images on top
    of each other with a blended transparency equal to the measurement from the qubit.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll use the [ipycanvas](https://ipycanvas.readthedocs.io/) library for drawing
    and animating the images, in conjunction with our quantum computing program.
  prefs: []
  type: TYPE_NORMAL
- en: We begin by initializing a graphics canvas which will allow us to draw the images.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Blending images together — quantum style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll also need some helper methods for drawing the images and updating their
    transparency values.
  prefs: []
  type: TYPE_NORMAL
- en: We can do this by creating a *draw()* method which takes the two sprites as
    parameters (the unicorn and the gremlin), along with an alpha value for blending.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also create an *update()* method which calls our quantum computing program,
    applies partial inversion to the qubit, and uses the resulting measurement counts
    of 0 and 1 in order to set the blended image transparency.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Morphing unicorns into gremlins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, let’s put it all together!
  prefs: []
  type: TYPE_NORMAL
- en: We’ll create an *animate()* method that simply loops multiple times, running
    the quantum program at each iteration, while gradually adjusting the inversion
    rate (*theta*)for the qubit up or down.
  prefs: []
  type: TYPE_NORMAL
- en: The result is a ghostly apparition effect, as the unicorn slowly changes into
    a gremlin, along with the resulting measurement of the qubits coinciding with
    0 or 1.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Behold — the results of our creation!
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/781e1dd73c5899f4f83ceb541c00f02a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Superimposed images according to a qubit’s measurements. Source: Author, [Stable
    Diffusion](https://stablediffusionweb.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: What a fascinating way to visualize the measurement of a qubit! Just imagine
    all of the possibilities that can be achieved through combining quantum computing
    with classical games. I hope this helps to stir your creativity in what can be
    done.
  prefs: []
  type: TYPE_NORMAL
- en: You can download the complete code example for the unicorn gremlin program [here](https://gist.github.com/primaryobjects/c9e21e15958812544d835a2f3e3baf82).
  prefs: []
  type: TYPE_NORMAL
- en: About the Author
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’ve enjoyed this article, please consider following me on [Medium](https://medium.com/@KoryBecker),
    [Twitter](https://twitter.com/PrimaryObjects), and my [web site](https://primaryobjects.com/)
    to be notified of my future posts and research work.
  prefs: []
  type: TYPE_NORMAL
