["```py\nimport numpy as np\n\n#Define how many intervals we want per axis\nresolution = 100\n\n#Create x and Y arrays of zeros of length 100\nx = np.zeros(resolution)\ny = np.zeros(resolution)\n\n#Create a mesh grid from above arrays. Outputs are all x and Y values in grid\ngridX, gridY = np.meshgrid(x,y)\n```", "```py\nimport numpy as np\n\n#Define how many intervals we want per axis\nresolution = 100\n\n#Create x and Y arrays of zeros of length 100\nx1 = np.zeros(resolution)\ny1 = np.zeros(resolution)\n\nx2 = np.full(resolution, 1)\ny2 = np.full(resolution, 1)\n\n#Create a mesh grids from above arrays. Outputs are all x and Y values in grid\ngridX, gridY = np.meshgrid(x1,y1)\ngridX2, gridY2 = np.meshgrid(x2,y2)\n\n#Stack both of the mesh grids we have created so every element is [0,1]\nfullGridX = np.dstack([gridX,gridX2])\nfullGridY = np.dstack([gridY,gridY2])\n```", "```py\nimport numpy as np\n\n#Define how many intervals we want per axis\nresolution = 100\nstartingTemperature = 20\nthermalDiffusivity = 1.11*10**-2\n\n#Create x and Y arrays of zeros of length 100\nx1 = np.full(resolution, 20)\ny1 = np.full(resolution, 20)\n\nx2 = np.full(resolution, 1.11*10**-2)\ny2 = np.full(resolution, 1.11*10**-2)\n\n#Create a mesh grids from above arrays. Outputs are all x and Y values in grid\ngridX, gridY = np.meshgrid(x1,y1)\ngridX2, gridY2 = np.meshgrid(x2,y2)\n\n#Stack both of the mesh grids we have created so every element is\n#[20,1.11*10**-2]\nfullGridX = np.dstack([gridX,gridX2])\nfullGridY = np.dstack([gridY,gridY2])\n```", "```py\nimport matplotlib.pyplot as plt\n\n#fullGridX[:,:,0] gets the first index of every element in our mesh grid\n#fullGridX[:,:,0][35:65,35:65] selects a box of values\nfullGridX[:,:,0][35:65,35:65] += 1000\n\nplt.imshow(fullGridX[:,:,0])\n```", "```py\ndef getNeighborsTemperature(grid, point, boundaryTemp):\n    #List to collect all neighboring temperatures\n    neighbors = []\n    #Loop over all neighboring cells\n    for i in range(-1,2):\n        for j in range(-1,2):\n            try:\n                #Ignore corner cells\n                if abs(i) != abs(j):\n                    neighbors.append(grid[point[0] + i][point[1]+ j])\n            except:\n                #Apply boundary condition\n                neighbors.append(boundaryTemp)\n\n    return neighbors\n```", "```py\ndef calculateHeat(cellTemp, neighborTemps, timeStep, thermalDiffusivity):\n    #Converting equation 3 into code\n    cellTemp = cellTemp + timeStep*thermalDiffusivity*((neighborTemps[0] -2*cellTemp + neighborTemps[-1]) + \n                                                       (neighborTemps[1] -2*cellTemp + neighborTemps[-2]))\n    return cellTemp\n```", "```py\ndef heatTransfer(grid, timeStep, boundaryTemp):\n    #Loop over all grid cells \n    for i in range(0,len(grid)):\n        for j in range(0,len(grid)):\n            #Get neighboring cell temperatures\n            neighbors = getNeighborsTemperature(grid[:,:,0], (i,j), boundaryTemp)\n            #Update current cell temperature\n            grid[:,:,0][i][j] = calculateHeat(grid[:,:,0][i][j], neighbors, timeStep, grid[:,:,1][i][j])\n\n    return grid\n```", "```py\n#Applying our heat transfer equation on current grid with a 30 secound time step\nnextGrid = heatTransfer(fullGridX.copy(),30, 20)\n\n#Matplotlib subplots to show the original and updated mesh grid\nplt.figure(figsize = (12,6))\n\nplt.subplot(1,2,1)\nplt.imshow(fullGridX[:,:,0])\nplt.title(\"t = 0\")\n\nplt.subplot(1,2,2)\nplt.imshow(nextGrid[:,:,0])\nplt.title(\"t = 30\")\n```", "```py\nimport imageio\n\"\"\"\nThis make gif function takes in a set of images and turns them into a gif!\nGive the frames as an array of mesh grids (only the temperature)and a name \nfor the gif as well as the temperature bounds for the heat map.\n\"\"\"\ndef makeGif(frames,name,minTemp,maxTemp):\n    !mkdir frames\n\n    counter=0\n    images = []\n    for i in range(0,len(frames)):\n        plt.figure()\n        plt.imshow(frames[i], cmap = \"inferno\", vmin = minTemp, vmax = maxTemp)\n        plt.savefig(\"frames/\" + str(counter)+ \".png\")\n        images.append(imageio.imread(\"frames/\" + str(counter)+ \".png\"))\n        counter += 1\n        plt.close()\n\n    imageio.mimsave(name, images)\n\n    !rm -r frames\n```", "```py\n#RUNNING SIMULATION\n#Keep track of our mesh grid frames to make into gif\nframes = [fullGridX[:,:,0].copy()]\n\ntimeStep = 30\nboundaryTemp = 20\n\n#Run for 500 time steps\nfor t in range(0,500):\n    fullGridX = heatTransfer(fullGridX.copy(),timeStep,boundaryTemp)\n    frames.append(fullGridX[:,:,0].copy())\n\nmakeGif(frames,\"simulation.gif\",20,500)\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport imageio\n\ndef getNeighborsTemperature(grid, point, boundaryTemp):\n    neighbors = []\n    for i in range(-1,2):\n        for j in range(-1,2):\n            try:\n                if abs(i) != abs(j):\n                    neighbors.append(grid[point[0] + i][point[1]+ j])\n            except:\n                neighbors.append(boundaryTemp)\n\n    return neighbors\n\ndef calculateHeat(cellTemp, neighborTemps, timeStep, thermalDiffusivity):\n    cellTemp = cellTemp + timeStep*thermalDiffusivity*((neighborTemps[0] -2*cellTemp + neighborTemps[-1]) + \n                                                       (neighborTemps[1] -2*cellTemp + neighborTemps[-2]))\n    return cellTemp\n\ndef heatTransfer(grid, timeStep, boundaryTemp):\n\n    for i in range(0,len(grid)):\n        for j in range(0,len(grid)):\n            neighbors = getNeighborsTemperature(grid[:,:,0], (i,j), boundaryTemp)\n            grid[:,:,0][i][j] = calculateHeat(grid[:,:,0][i][j], neighbors, timeStep, grid[:,:,1][i][j])\n\n    return grid\n\ndef makeGif(frames,name,minTemp,maxTemp):\n    !mkdir frames\n\n    counter=0\n    images = []\n    for i in range(0,len(frames)):\n        plt.figure()\n        plt.imshow(frames[i], cmap = \"inferno\", vmin = minTemp, vmax = maxTemp)\n        plt.savefig(\"frames/\" + str(counter)+ \".png\")\n        images.append(imageio.imread(\"frames/\" + str(counter)+ \".png\"))\n        counter += 1\n        plt.close()\n\n    imageio.mimsave(name, images)\n\n    !rm -r frames\n\n#Make mesh grid\nresolution = 100\nstartingTemperature = 20\nthermalDiffusivity = 1.11*10**-2\n\nx1 = np.full(resolution, 20)\ny1 = np.full(resolution, 20)\n\nx2 = np.full(resolution, 1.11*10**-2)\ny2 = np.full(resolution, 1.11*10**-2)\n\ngridX, gridY = np.meshgrid(x1,y1)\ngridX2, gridY2 = np.meshgrid(x2,y2)\n\nfullGridX = np.dstack([gridX,gridX2])\nfullGridY = np.dstack([gridY,gridY2])\n\n#Add heat\nfullGridX[:,:,0][35:65,35:65] += 1000\n\n#Run simulation\nframes = [fullGridX[:,:,0].copy()]\n\ntimeStep = 30\nboundaryTemp = 20\n\nfor t in range(0,500):\n    fullGridX = heatTransfer(fullGridX.copy(),timeStep,boundaryTemp)\n    frames.append(fullGridX[:,:,0].copy())\n\n#Make Gif, saves as \"simulation.gif\"\nmakeGif(frames,\"simulation.gif\",20,500)\n```"]