["```py\nimport osmnx as ox # version: 1.0.1\nimport matplotlib.pyplot as plt # version: 3.7.1\n\nadmin  = {}\ncities = ['Budapest', 'Vienna']\nf, ax  = plt.subplots(1,2, figsize = (15,5))\n\n# visualize the admin boundaries\nfor idx, city in enumerate(cities):\n    admin[city] = ox.geocode_to_gdf(city)\n    admin[city].plot(ax=ax[idx],color='none',edgecolor= 'k', linewidth = 2)    ax[idx].set_title(city, fontsize = 16)\n```", "```py\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import LinearSegmentedColormap\n\nvery_peri = '#8C6BF3'  \nsecond_color = '#6BAB55'   \n\ncolors = [second_color, very_peri ]\nn_bins = 100\ncmap_name = \"VeryPeri\"\ncolormap = LinearSegmentedColormap.from_list(cmap_name, colors, N=n_bins)\n```", "```py\nimport geopandas as gpd # version: 0.9.0\n\ndemographics = {}\nf, ax = plt.subplots(1,2, figsize = (15,5))\n\nfor idx, city in enumerate(cities):\n    demographics[city] = gpd.read_file(city.lower() + \\\n      '_population_grid.geojson')[['population', 'geometry']]\n    admin[city].plot(ax=ax[idx], color = 'none', edgecolor = 'k', \\\n      linewidth = 3)\n    demographics[city].plot(column = 'population', cmap = colormap, \\\n      ax=ax[idx], alpha = 0.9, markersize = 0.25)\n    ax[idx].set_title(city)\n    ax[idx].set_title('Population density\\n in ' + city, fontsize = 16)\n    ax[idx].axis('off')\n```", "```py\n# parse the data for each city\ngdf_units= {}\n\ngdf_units['Vienna'] = gpd.read_file('DEFIBRILLATOROGD')\ngdf_units['Budapest'] = gpd.read_file('budapest_defibrillator.geojson')\n\nfor city in cities:\n    gdf_units[city] = gpd.overlay(gdf_units[city], admin[city])\n\n# visualize the units\nf, ax = plt.subplots(1,2, figsize = (15,5))\n\nfor idx, city in enumerate(cities):\n    admin[city].plot(ax=ax[idx],color='none',edgecolor= 'k', linewidth = 3)\n    gdf_units[city].plot( ax=ax[idx], alpha = 0.9, color = very_peri, \\\n      markersize = 6.0)\n    ax[idx].set_title('Locations of defibrillator\\ndevices in ' + city, \\\n      fontsize = 16)\n    ax[idx].axis('off')\n```", "```py\nimport os\nimport pandana # version: 0.6\nimport pandas as pd # version: 1.4.2\nimport numpy as np # version: 1.22.4\nfrom shapely.geometry import Point # version:  1.7.1\nfrom pandana.loaders import osm\n\ndef get_city_accessibility(admin, POIs):\n\n    # walkability parameters\n    walkingspeed_kmh = 15\n    walkingspeed_mm  = walkingspeed_kmh * 1000 / 60\n    distance = 2500\n\n    # bounding box as a list of llcrnrlat, llcrnrlng, urcrnrlat, urcrnrlng\n    minx, miny, maxx, maxy = admin.bounds.T[0].to_list()\n    bbox = [miny, minx, maxy, maxx]\n\n    # setting the input params, going for the nearest POI\n    num_pois = 1\n    num_categories = 1\n    bbox_string = '_'.join([str(x) for x in bbox])\n    net_filename = 'data/network_{}.h5'.format(bbox_string)\n    if not os.path.exists('data'): os.makedirs('data')\n\n    # precomputing nework distances\n\n    if os.path.isfile(net_filename):\n        # if a street network file already exists, just load the dataset from that\n        network = pandana.network.Network.from_hdf5(net_filename)\n        method = 'loaded from HDF5'\n    else:\n        # otherwise, query the OSM API for the street network within the specified bounding box\n        network = osm.pdna_network_from_bbox(bbox[0], bbox[1], bbox[2], bbox[3])\n        method = 'downloaded from OSM'\n\n        # identify nodes that are connected to fewer than some threshold of other nodes within a given distance\n        lcn = network.low_connectivity_nodes(impedance=1000, count=10, imp_name='distance')\n        network.save_hdf5(net_filename, rm_nodes=lcn) #remove low-connectivity nodes and save to h5\n\n    # precomputes the range queries (the reachable nodes within this maximum distance)\n    # so, as long as you use a smaller distance, cached results will be used\n    network.precompute(distance + 1)\n\n    # compute accessibilities on POIs\n    pois = POIs.copy()\n    pois['lon'] = pois.geometry.apply(lambda g: g.x)\n    pois['lat'] = pois.geometry.apply(lambda g: g.y)\n    pois = pois.drop(columns = ['geometry'])\n    network.init_pois(num_categories=num_categories, max_dist=distance, max_pois=num_pois)\n\n    network.set_pois(category='all', x_col=pois['lon'], y_col=pois['lat'])\n\n    # searches for the n nearest amenities (of all types) to each node in the network\n    all_access = network.nearest_pois(distance=distance, category='all', num_pois=num_pois)\n\n    # transform the results into a geodataframe\n    nodes = network.nodes_df\n    nodes_acc = nodes.merge(all_access[[1]], left_index = True, right_index = True).rename(columns = {1 : 'distance'})\n    nodes_acc['time'] = nodes_acc.distance / walkingspeed_mm\n    xs = list(nodes_acc.x)\n    ys = list(nodes_acc.y)\n    nodes_acc['geometry'] = [Point(xs[i], ys[i]) for i in range(len(xs))]\n    nodes_acc = gpd.GeoDataFrame(nodes_acc)\n    nodes_acc = gpd.overlay(nodes_acc, admin)\n\n    nodes_acc[['time', 'geometry']].to_file(city + '_accessibility.geojson', driver = 'GeoJSON')\n\n    return nodes_acc[['time', 'geometry']]\n\naccessibilities = {}\nfor city in cities:\n    accessibilities[city] = get_city_accessibility(admin[city], gdf_units[city])\n```", "```py\nfor city in cities:\n    print('Number of road network nodes in ' + \\\n      city + ': ' + str(len(accessibilities[city])))\n```", "```py\nfor city in cities:\n    f, ax = plt.subplots(1,1,figsize=(15,8))\n    admin[city].plot(ax=ax, color = 'k', edgecolor = 'k', linewidth = 3)\n    accessibilities[city].plot(column = 'time', cmap = 'RdYlGn_r', \\\n      legend = True,  ax = ax, markersize = 2, alpha = 0.5)\n    ax.set_title('Defibrillator accessibility in minutes\\n' + city, \\\n      pad = 40, fontsize = 24)    \n    ax.axis('off')\n```", "```py\nimport geopandas as gpd\nimport h3 # version: 3.7.3\nfrom shapely.geometry import Polygon # version: 1.7.1\nimport numpy as np\n\ndef split_admin_boundary_to_hexagons(admin_gdf, resolution):\n    coords = list(admin_gdf.geometry.to_list()[0].exterior.coords)\n    admin_geojson = {\"type\": \"Polygon\",  \"coordinates\": [coords]}\n    hexagons = h3.polyfill(admin_geojson, resolution, \\\n      geo_json_conformant=True)\n    hexagon_geometries = {hex_id : Polygon(h3.h3_to_geo_boundary(hex_id, \\\n      geo_json=True)) for hex_id in hexagons}\n    return gpd.GeoDataFrame(hexagon_geometries.items(), columns = ['hex_id', 'geometry'])\n\nresolution = 8  \nhexagons_gdf = split_admin_boundary_to_hexagons(admin[city], resolution)\nhexagons_gdf.plot()\n```", "```py\nfor resolution in [7,8,9]:\n\n    admin_h3 = {}\n    for city in cities:\n        admin_h3[city] = split_admin_boundary_to_hexagons(admin[city], resolution)\n\n    f, ax = plt.subplots(1,2, figsize = (15,5))\n\n    for idx, city in enumerate(cities):\n        admin[city].plot(ax=ax[idx], color = 'none', edgecolor = 'k', \\\n          linewidth = 3)\n        admin_h3[city].plot( ax=ax[idx], alpha = 0.8, edgecolor = 'k', \\\n           color = 'none')\n        ax[idx].set_title(city + ' (resolution = '+str(resolution)+')', \\\n            fontsize = 14)\n        ax[idx].axis('off')\n```", "```py\ndemographics_h3 = {}\naccessibility_h3 = {}\n\nfor city in cities:\n\n    # do the spatial join, aggregate on the population level of each \\\n    # hexagon, and then map these population values to the grid ids\n    demographics_dict = gpd.sjoin(admin_h3[city], demographics[city]).groupby(by = 'hex_id').sum('population').to_dict()['population']\n    demographics_h3[city] = admin_h3[city].copy()\n    demographics_h3[city]['population'] = demographics_h3[city].hex_id.map(demographics_dict)\n\n    # do the spatial join, aggregate on the population level by averaging \n    # accessiblity times within each hexagon, and then map these time score  #  to the grid ids\n    accessibility_dict = gpd.sjoin(admin_h3[city], accessibilities[city]).groupby(by = 'hex_id').mean('time').to_dict()['time']\n    accessibility_h3[city]   = admin_h3[city].copy()\n    accessibility_h3[city]['time'] = \\\n      accessibility_h3[city].hex_id.map(accessibility_dict)\n\n    # now show the results\n    f, ax = plt.subplots(2,1,figsize = (15,15))\n\n    demographics_h3[city].plot(column = 'population', legend = True, \\\n      cmap = colormap, ax=ax[0], alpha = 0.9, markersize = 0.25)\n    accessibility_h3[city].plot(column = 'time', cmap = 'RdYlGn_r', \\\n      legend = True,  ax = ax[1])\n\n    ax[0].set_title('Population level\\n in ' + city, fontsize = 16)\n    ax[1].set_title('Defibrillator reachability time\\n in ' + city, \\\n      fontsize = 16)\n\n    for ax_i in ax: ax_i.axis('off')\n```", "```py\nf, ax = plt.subplots(1,2, figsize = (15,5))\n\nfor idx, city in enumerate(cities):\n\n    total_pop  = demographics_h3[city].population.sum()\n    merged = demographics_h3[city].merge(accessibility_h3[city].drop(columns =\\\n     ['geometry']), left_on = 'hex_id', right_on = 'hex_id')\n\n    time_thresholds = range(10)\n    population_reached = [100*merged[merged.time<limit].population.sum()/total_pop for limit in time_thresholds]\n\n    ax[idx].plot(time_thresholds, population_reached, linewidth = 3, \\\n      color = very_peri)\n    ax[idx].set_xlabel('Reachability time (min)', fontsize = 14, \\\n      labelpad = 12)\n    ax[idx].set_ylabel('Fraction of population reached (%)', fontsize = 14, labelpad = 12)\n    ax[idx].set_xlim([0,10])\n    ax[idx].set_ylim([0,100])\n    ax[idx].set_title('Fraction of population vs defibrillator\\naccessibility in ' + city, pad = 20, fontsize = 16) \n```"]