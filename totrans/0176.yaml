- en: A Comprehensive Guide on Common Table Expression in SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/a-comprehensive-guide-on-common-table-expression-in-sql-8c892ffda2f5](https://towardsdatascience.com/a-comprehensive-guide-on-common-table-expression-in-sql-8c892ffda2f5)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Back To Basics | Simplifying Complex Queries and Enhancing Readability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://iffatm.medium.com/?source=post_page-----8c892ffda2f5--------------------------------)[![Iffat
    Malik](../Images/7be3b651053507de2077b3c3c9d3a408.png)](https://iffatm.medium.com/?source=post_page-----8c892ffda2f5--------------------------------)[](https://towardsdatascience.com/?source=post_page-----8c892ffda2f5--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----8c892ffda2f5--------------------------------)
    [Iffat Malik](https://iffatm.medium.com/?source=post_page-----8c892ffda2f5--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----8c892ffda2f5--------------------------------)
    ·14 min read·Aug 22, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b150ba7dccc63bf4a565984c86a8b0aa.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: In programming, it’s a common practice to group instructions or statements in
    smaller and more manageable code blocks. This practice is usually referred as
    [*code block organisation*](https://en.wikipedia.org/wiki/Block_(programming)).
    It’s basically breaking down a program or a large section of a program into smaller
    and logically connected blocks. These blocks are designed to perform a specific
    task or just to group related functionalities. This approach not only improves
    code readability but also makes the code more organised and maintainable. Various
    programming constructs such as functions, methods, try-catch blocks, loops, and
    conditional statements are commonly used for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: In *SQL*, one of the ways to achieve the same is by using *Common Table Expression
    (CTE)*. In this article, we’ll explore how *CTEs* can significantly simplify and
    optimise complex SQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: What is CTE?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CTE, Common Table Expression, is a query that **temporarily** stores the result
    set so that it can be referenced and used in another query. The CTE remains available
    as long as it is within the **same execution scope.**
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In simple terms, a *CTE* acts like a temporary table that holds the intermediate
    results of a query, allowing you to use those results later in another *SQL* query.
    It is also referred as *Subquery Refactoring*.
  prefs: []
  type: TYPE_NORMAL
- en: Here, there are two key points to note,
  prefs: []
  type: TYPE_NORMAL
- en: '***‘temporary result set’***, which means the output of the *CTE* is stored
    temporarily and does not create a permanent table in the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***‘same execution scope’****,* thisrefers to the fact that it can only be
    utilised within the same *SQL* statements where it is defined. Once that *SQL*
    statement is completed, the *CTE* is no longer accessible, making it confined
    to its defined scope.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The motive of *CTE* is to simplify long and complex queries. By breaking down
    the long queries into simple, smaller and manageable blocks of code, it reduces
    the complexity while increasing the readability and in some databases, reusability
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: It is defined by using a ***WITH*** clause. The common syntax of a *CTE* is,
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/82d67437deb3018e0fe736cb0f592e5f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Image by author: Common syntax of a CTE'
  prefs: []
  type: TYPE_NORMAL
- en: You can define multiple *CTEs* as well, the common syntax of defining multiple
    *CTEs* is,
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f84a2cd2774a2df317e9814ad280ff56.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Image by author: Common syntax of using multiple CTEs'
  prefs: []
  type: TYPE_NORMAL
- en: '*CTEs* can be used in the following *SQL* statements,'
  prefs: []
  type: TYPE_NORMAL
- en: SELECT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: INSERT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UPDATE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DELETE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *CTE* can be referenced in another *CTE* too. When a *CTE* refers to itself,
    it becomes a *Recursive CTE*.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a fair background on a *CTE*, let’s begin the action. Here,
    we will be using data from a dummy vehicle retailer company, you can find source
    data in my [GitHub Repo](https://github.com/PhoenixIM/All_Things_SQL/tree/main/Common%20Table%20Expression),
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f3d790d884d1a5855d4484a2af9b1bc9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Image by author: ER diagram of vehicle retailer company'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say we need to generate a report that ranks the products based on their
    total revenue. This report should provide key information such as product ID,
    product names, the total quantity sold, total revenue, and the sales rank based
    on total revenue.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/b3044d4a46ea4b4fc6ae8811d6ae2559.png)'
  prefs: []
  type: TYPE_IMG
- en: GIF by author
  prefs: []
  type: TYPE_NORMAL
- en: 'In the query above, we calculated two important metrics for each product in
    the *CTE, ‘PRODUCTSALES’*:'
  prefs: []
  type: TYPE_NORMAL
- en: The total quantity of items sold (*‘TOTAL_QUANTITY_SOLD’* ) and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The total revenue (*‘TOTAL_REVENUE’* ) generated from those sales.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the main *SQL* query, we put these metrics to use. Additionally, we used
    the *RANK()* function. This *Window Function* assigns a unique sequential number
    to each row of data in a table, or within a specified partition, while maintaining
    the same rank for rows with identical values.
  prefs: []
  type: TYPE_NORMAL
- en: You can refer more details on *Window Functions* here,
  prefs: []
  type: TYPE_NORMAL
- en: '[](/window-functions-a-must-know-for-data-engineers-and-data-scientists-4dd3e4ad0d2?source=post_page-----8c892ffda2f5--------------------------------)
    [## Window Functions — A must know for Data Engineers and Data Scientists'
  prefs: []
  type: TYPE_NORMAL
- en: Back To Basics | SQL fundamentals for beginners
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/window-functions-a-must-know-for-data-engineers-and-data-scientists-4dd3e4ad0d2?source=post_page-----8c892ffda2f5--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we used *RANK()* based on the *‘TOTAL_REVENUE’* andarranged the
    results in descending order. It’s like having a report that helps us understand
    which products are the most successful in terms of sales and revenue.
  prefs: []
  type: TYPE_NORMAL
- en: Practice Exercise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I have created some practice exercises to get comfortable with utilising the
    *CTE*. Feel free to post your answers in the response section of this article.
    If you need any help, don’t hesitate to leave a comment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can refer the following article more details about aggregate functions,
  prefs: []
  type: TYPE_NORMAL
- en: '[](/how-to-use-sql-aggregate-functions-92f7244a07cb?source=post_page-----8c892ffda2f5--------------------------------)
    [## SQL Aggregate Functions for your next Data Science interview'
  prefs: []
  type: TYPE_NORMAL
- en: Back To Basics | SQL fundamentals for beginners
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/how-to-use-sql-aggregate-functions-92f7244a07cb?source=post_page-----8c892ffda2f5--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Recursive CTE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we are comfortable using CTEs, let’s understand *recursive CTE*.
  prefs: []
  type: TYPE_NORMAL
- en: A *recursive CTE* is a special kind of *CTE* that refers back to **itself**
    and builds the result set in an iterative manner. It’s like using a loop in SQL.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It consists of two parts which are combined by [***UNION ALL***](https://www.mssqltips.com/sqlservertip/1387/union-vs-union-all-in-sql-server/):'
  prefs: []
  type: TYPE_NORMAL
- en: The first part, often referred as a ***base part*** as well. This part provides
    the initial data or you can say it provides the starting point for the recursion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second part is the ***recursive part***, it builds the result set based
    on the first part(base part) and then adds more data in each iteration. This process
    continues until there is no more data to add or until a specific condition is
    met.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For beginners, a common question is when to use it? Well! *Recursive* *CTEs*
    are very helpful when working with data which can be represented in the form of
    parent-child relationship such as family tree, nested categories, organisational
    hierarchy, etc. It is also used in generating sequential date series.
  prefs: []
  type: TYPE_NORMAL
- en: The common syntax of a *recursive CTE* is,
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/71945a030904e7d5d94df50a0af29ba8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Image by author: Common syntax of recursive CTE'
  prefs: []
  type: TYPE_NORMAL
- en: Here is the sample data from the *‘EMPLOYEES’* table which we will be using
    to create a *recursive CTE* for generating employee hierarchy*,*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/499e54d69314e8fb9395b47da5fe4a6b.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say we want to retrieve the entire employee hierarchy to track the depth
    or the level of each employee within the company’s hierarchical structure.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will select a starting point as a specific employee, *‘Joyce Duffy’*
    who hold the ‘*JOBTITLE’* as the *‘Chief Executive Office’* and her *‘EMPLOYEEID’*
    is *‘EMP100’,*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/291008b02e3f36d17577911c116d4ac7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Image by author: output of the query'
  prefs: []
  type: TYPE_NORMAL
- en: In the code block above, we created a *CTE*, ‘*EMPLOYEEHIERARCHY’*. Now let’s
    focus on the **base part**. As mentioned earlier, we chose employee *‘Joyce Duffy’*
    as our base point or starting point to build the employee hierarchy column *‘EMPHIERARCHYDEPTH’*
    and we assigned the depth of it as *‘1’.* This means she is at the topmost level
    of the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/405e19593c3b6e094d499fae0b8fdaf4.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Higher levels(e.g. 3,4 etc.) representing employees managed by other employees,
    forming a tree-like structure. The ‘*EMPHIERARCHYDEPTH’* column is useful for
    visualising and understanding the hierarchical relationships among employees in
    the organisation.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/fc1f093a002c74f1c9edb40d02000e56.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Image by author: Employee hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: Now the second part, the **recursive part** is the place where actual magic
    happens. It refers back to the *CTE* ‘*EMPLOYEEHIERARCHY’* and repeatedly joins
    the *‘EMPLOYEES’* table with the previous result(from the base part) of the *CTE*
    using the join condition *‘EMP.MANAGER = EH.EMPLOYEEID’.* This means it looks
    for employees whose manager’s ID matches the current employee’s ID, creating a
    chain of parent-child relationships.
  prefs: []
  type: TYPE_NORMAL
- en: To understand the recursive part**,** let’s take the dataset containing information
    about individuals within the Marketing division only,
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/693b94ed83fa77608137b89e0d21d214.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Image by author: Marketing division employee hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: Below is the visual representation of the above dataset. Notice how it enhances
    clarity and facilitates comprehension quickly, doesn’t it?
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/bbe8ac28a66b31dd1162fc1d2cabcfff.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Image by author: Employee hierarchy of marketing division'
  prefs: []
  type: TYPE_NORMAL
- en: Back to our recursive logic, we joined the *‘EMPLOYEES’* (aliased as *‘EMP’*)
    table with the recursive *CTE* *‘EMPLOYEEHIERARCHY’* (aliased as ‘*EH*’) using
    the condition *‘EMP.MANAGER = EH.EMPLOYEEID’.* This condition simply meansthat
    the employee’s *‘MANAGER’* must match the previous iteration’s *‘EMPLOYEEID’.*
    (This join helps us find the employees with their corresponding managers in the
    hierarchical structure.)
  prefs: []
  type: TYPE_NORMAL
- en: From the base part, we already know,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/405e19593c3b6e094d499fae0b8fdaf4.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Now, during the first round of the recursive step, the join condition is evaluated
    for *‘EH.EMPLOYEEID = EMP100’,* which means it will check if *‘EMP.MANAGER = EMP100’
    (‘EMP.MANAGER = EH.EMPLOYEEID’)* This helps us find all the employees who are
    managed by *‘EMP100’*. This gets us 2 results, To simplify our demonstration,
    we’ll concentrate on understanding the marketing division’s hierarchy only,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/1a2e35b61a6693834311b34fb92d6419.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: For *‘Mrs. Hilary Richardson’,* who is *‘VP Marketing’,* the *‘EMPHIERARCHYDEPTH’*
    increases to *2.* This is achieved by adding *1* to *‘EMPHIERARCHYDEPTH + 1’*
    *(1 + 1 = 2)*. This denotes that we are moving down *1* level in the hierarchy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving to the second round of recursion, the join condition now checks if *‘EH.EMPLOYEEID
    = EMP101’.* This will list out all the employees whose manager is *‘EMP101 - Mrs
    Hilary Richardson’,*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/ed19846ff7cbed100e62e48391a6e1e5.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: In the similar manner, the query keeps iterating and adding rows to the result
    set until no more matches are found for the condition *‘EMP.MANAGER = EH.EMPLOYEEID’*,
    indicating that there are no more levels in the hierarchy to traverse. The recursion
    ends when there are no more child employees to connect with their managers.
  prefs: []
  type: TYPE_NORMAL
- en: One important point to note is that each iteration of the recursive part operates
    only on the rows produced by the previous iteration.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: CTE vs Subquery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Subquery* in *SQL* is essentially a *‘query inside another query’*. It is
    sometimes referred to as a *nested query* or an *inner query*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here comes the million-dollar question: which approach is better, *CTEs*
    or S*ubqueries*? Well! There’s no one-size-fits-all answer. It depends on several
    factors like your table layout, data content, indexing strategies, etc. A single
    approach or solution cannot be universally applied to all the use cases. There
    are 3 major differences between *Subqueries* and *CTEs*,'
  prefs: []
  type: TYPE_NORMAL
- en: '***CTEs* can be recursive** One significant advantage of *CTEs* is their ability
    to be recursive. It can reference itself as we have already discussed previously,
    making it suitable for creating hierarchical data structures. *Subqueries*, however,
    lack this inherent recursive capability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Readability and Maintenance** In the professional realm, *SQL* isn’t always
    seen as a programming language. Unfortunately as a result, you often encounter
    nested messier queries compared to other programming languages. In such scenarios,
    *CTEs* step in to enhance the readability by neatly encapsulating logic when compared
    to *Subqueries*; however, they may not always provide the performance optimisation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reusability** You can refer to a *CTE* multiple times in a single *SQL* query,
    which is useful for complex calculations or transformations. However, this reusability
    varies by database. While subqueries must be rewritten every time they’re used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s quickly query the total quantity of products ordered by each customer,
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Subquery:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Using CTE:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Both the approaches will produce the same result set,
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f628ff435d6678353612a74662f382e2.png)'
  prefs: []
  type: TYPE_IMG
- en: GIF by author
  prefs: []
  type: TYPE_NORMAL
- en: In the real world scenarios, there is no crystal ball, you have to test and
    measure the performance on the dataset you are working with. It’s essential to
    consider the specific use case, query complexity, and database engine optimisation
    when choosing between them.
  prefs: []
  type: TYPE_NORMAL
- en: CTE vs Derived Table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often the terms *Derived Table* and *Subquery* are used interchangeably. But
    there is a distinction. When a *Subquery* is capable of running independently
    from the outer query, it becomes a *Derived Table.* Unlike *Subqueries*, *Derived
    Tables* require an alias to be specified. Also, *Subqueries* are defined in *‘WHERE’*
    clause, while *Derived Tables* are defined in *‘FROM’* clause.
  prefs: []
  type: TYPE_NORMAL
- en: '*MySQL* treats a derived table as an intermediate result that is calculated
    or materialised before executing the main query. The database engine generates
    an execution plan that first calculates the derived table and then uses it in
    the main query.'
  prefs: []
  type: TYPE_NORMAL
- en: Coming back to *CTE* vs *Derived Table,* both techniques are used to encapsulate
    and simplify the complex queries. However, there are differences in the syntax
    and usage,
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntax**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we already know *CTEs* are defined using a *‘WITH’* clause; whereas *Derived
    Tables* are created within the *‘FROM’* clause of the main query using subqueries.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Readability**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both *CTEs* and *Derived Tables* enhance readability by breaking down the complex
    queries into smaller ones. However, I personally find *CTEs* a bit more easier
    to read since it is defined at the beginning of the statement rather than embedded
    within the query.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Recursiveness** A *CTE* can be self-referencing *(recursive)*, as we have
    already discussed while *Derived Table* lacks this ability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Derived Tables* are commonly regarded as virtual tables within the main query
    across different databases, which might introduce slight performance overhead.
    *PostgreSQL* can optimise their execution, while *MySQL* might treat them as materialised
    subqueries. On the other hand, with *CTEs*, specific databases optimise their
    execution, though this isn’t universally true. For example, *SQL Server* often
    optimises the execution of *CTEs*, while *MySQL*’s behaviour in this regard can
    be less consistent.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Both, *CTEs* and *Derived Tables* offer more or less similar advantages in terms
    of readability and simplifying complex queries. The choice between them relies
    on the specific use case and the database system you are working with.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s find out the total quantity in stock vs total quantity sold for each product,
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Derived Table:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Using CTE:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Both will produce the same result set.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3e92ccdbfde994deda35c475bb065a1f.png)'
  prefs: []
  type: TYPE_IMG
- en: GIF by author
  prefs: []
  type: TYPE_NORMAL
- en: CTE vs Temp Table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Temporary Tables* are special kinds of tables in a database where you can
    put data temporarily while you work on it. These tables are session-specific,
    meaning they are visible only during the ongoing session and are automatically
    removed when the session ends. Dropping a database does not automatically drop
    any *Temporary Tables* created within that database.'
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between a *CTE* and a *Temporary Table* is,
  prefs: []
  type: TYPE_NORMAL
- en: '**Storage and Visibility**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Temporary Tables* are physically stored in a database. They exist beyond the
    scope of a single query and remain available until they are explicitly dropped
    or the session ends.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: While, *CTEs* are virtual and not physically stored in a database. They are
    part of the query execution and only exist for the duration of that query.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Reusability**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some databases do permit *CTEs* to be reused by multiple queries within the
    same session.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Temporary Tables* can be reused across multiple queries within the same session,
    making them suitable for scenarios where the same data needs to be referenced
    multiple times.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Indexing and Optimisation**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*CTEs* do not allow to create indexes as they are part of the query execution
    plan.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Temporary Tables* can be indexed and their data can be optimised to improve
    query performance.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Performance**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since *Temporary Tables* are physically stored, they can sometimes lead to disk
    I/O and storage overhead. They are useful when managing large volumes of data
    and need to reference that data across multiple queries within the same session.
    However, depending on data size, they might impact performance. On the other hand,
    *CTEs* are often optimised by the query optimiser, and their data could reside
    in memory, reducing disk I/O and enhancing performance. *CTEs* are preferred when
    the goal is to simplify complex queries for better query readability.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Suppose we want to find out the total sales revenue for each product category,
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Temporary Table:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**Using CTE:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Both the queries produce the similar result,
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d41123f693884dea1df22cf74ecb5c6d.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Final Challenge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Share your answer in the response section and feel free to leave a comment in
    case you need help!
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No matter if you are a beginner or a seasoned *SQL* practitioner, writing queries
    is a bit like being a chef in the kitchen. Your favourite chef knife might work
    wonders for slicing vegetables but that same knife might not be a good choice
    for tenderising meat.(Credit for this analogy goes to my Masterchef binge-watching.)
    Similarly, your go to technique might excel in some situations, but not in others.
    It’s all about assessing the use case and choosing the right technique for the
    best solution. Make sure to refer to the official documentation of the database
    you are using.
  prefs: []
  type: TYPE_NORMAL
- en: Here are some useful resources to get started with *CTE*,
  prefs: []
  type: TYPE_NORMAL
- en: '[CTE in MySQL](https://dev.mysql.com/doc/refman/8.0/en/with.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Temporary Tables in MySQL](https://dev.mysql.com/doc/refman/8.0/en/create-temporary-table.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Derived Tables in MySQL](https://dev.mysql.com/doc/refman/8.0/en/derived-tables.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Subqueries in MySQL](https://dev.mysql.com/doc/refman/8.0/en/subqueries.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The source data, code file used in this article, and solutions to the practice
    exercise can be located in my* [*GitHub Repository*](https://github.com/PhoenixIM/All_Things_SQL/tree/main/Common%20Table%20Expression)*.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Become a member and read every story on Medium*](https://medium.com/@iffatm/membership)*.*'
  prefs: []
  type: TYPE_NORMAL
- en: Happy Learning!
  prefs: []
  type: TYPE_NORMAL
