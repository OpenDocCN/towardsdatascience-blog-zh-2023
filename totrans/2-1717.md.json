["```py\nimport numpy as np\n\ndef f(x):\n    return 2*x + np.cos(2*np.pi/4*x)\n\nexpected_value = 1 + 2/np.pi\n\nN = 101\nxs = np.linspace(0, 1, N)\nys = f(xs)\nI = np.sum(np.diff(xs) * ys[1:])\nprint(f\"Integral estimated to: {I}\")\nprint(f\"Error: {I/expected_value-1:.4%}\") \n```", "```py\nIntegral estimated to: 1.641606682344361\nError: 0.3047%\n```", "```py\nN = 1000\nxs = np.linspace(0, 1, N)\nys = f(xs)\nI = np.sum(np.diff(xs) * ys[1:])\nprint(f\"Integral estimated to: {I}\")\nprint(f\"Error: {I/expected_value-1:.4%}\")\n```", "```py\nIntegral estimated to: 1.6371201417061898\nError: 0.0306%\n```", "```py\nI = np.trapz(ys, x=xs)\nprint(f\"Integral estimated to: {I}\")\nprint(f\"Error: {I/expected_value-1:.8%}\")\n```", "```py\nIntegral estimated to: 1.6366196412056895\nError: -0.00079982% # compared to 0.3047% for the rectangle rul\n```", "```py\n# for N = 1000\nIntegral estimated to: 1.6366196412056895\nError: -0.00000801%\n```", "```py\nfrom scipy.integrate import quad\nI = quad(f, 0, 1)[0] # integrate f between 0 and 1\nprint(\"Best integral value\", I)\nprint(f\"Error {I/expected_value-1:.16%}\")\n```", "```py\nBest integral value 1.6366197723675815\nError 0.0000000000000000%\n```"]