- en: 4 Easy-to-Implement, High-Impact Tweaks for Supercharging Your Python Code’s
    Performance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4种易于实现的高影响力调整方法，用于超级提升你的Python代码性能
- en: 原文：[https://towardsdatascience.com/4-easy-to-implement-high-impact-tweaks-for-supercharging-your-python-codes-performance-eb0652d942b7](https://towardsdatascience.com/4-easy-to-implement-high-impact-tweaks-for-supercharging-your-python-codes-performance-eb0652d942b7)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/4-easy-to-implement-high-impact-tweaks-for-supercharging-your-python-codes-performance-eb0652d942b7](https://towardsdatascience.com/4-easy-to-implement-high-impact-tweaks-for-supercharging-your-python-codes-performance-eb0652d942b7)
- en: How to detect, understand, and eliminate bottlenecks in Python for a 1500x speed
    increase
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何检测、理解和消除Python中的瓶颈，以实现1500倍的速度提升
- en: '[](https://mikehuls.medium.com/?source=post_page-----eb0652d942b7--------------------------------)[![Mike
    Huls](../Images/8f9f55a0d25db00799c5d37383b7f5b6.png)](https://mikehuls.medium.com/?source=post_page-----eb0652d942b7--------------------------------)[](https://towardsdatascience.com/?source=post_page-----eb0652d942b7--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----eb0652d942b7--------------------------------)
    [Mike Huls](https://mikehuls.medium.com/?source=post_page-----eb0652d942b7--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://mikehuls.medium.com/?source=post_page-----eb0652d942b7--------------------------------)[![Mike
    Huls](../Images/8f9f55a0d25db00799c5d37383b7f5b6.png)](https://mikehuls.medium.com/?source=post_page-----eb0652d942b7--------------------------------)[](https://towardsdatascience.com/?source=post_page-----eb0652d942b7--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----eb0652d942b7--------------------------------)
    [Mike Huls](https://mikehuls.medium.com/?source=post_page-----eb0652d942b7--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----eb0652d942b7--------------------------------)
    ·12 min read·Jul 12, 2023
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·发表于 [Towards Data Science](https://towardsdatascience.com/?source=post_page-----eb0652d942b7--------------------------------)
    ·12分钟阅读·2023年7月12日
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/63a41aba468ec040a3d1aa42518c8082.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/63a41aba468ec040a3d1aa42518c8082.png)'
- en: You Python code after this article (image by [SpaceX](https://unsplash.com/@spacex)
    on [Unsplash](https://unsplash.com/photos/-p-KCm6xB9I))
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本文后的Python代码（图片来自 [SpaceX](https://unsplash.com/@spacex) 在 [Unsplash](https://unsplash.com/photos/-p-KCm6xB9I)）
- en: My philosophy centers around attempting simple solutions before resorting to
    complex ones. By exploring the easy methods in this article, you may find the
    performance increase you need, sparing yourself the intricacies and countless
    hours required for implementing and debugging multiprocesssing, threads or packages
    written in another language.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我的理念是尝试简单的解决方案，然后再考虑复杂的方案。通过探索本文中的简单方法，你可能会找到所需的性能提升，从而避免实现和调试多进程、线程或其他语言编写的包所需的复杂性和无数小时。
- en: In this article we’ll delve into the tools and 4 methods of speeding up any
    Python code using **minimal**, **easy-to-implement techniques**. We’ll analyze
    our code, detect bottlenecks and fix them in a structured way. We’ll do this by
    **decreasing the amount of work** Python it has to do.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇文章中，我们将**深入探讨**使用**最小化**、**易于实现的技巧**来加速任何Python代码的工具和4种方法。我们将分析代码，检测瓶颈并以结构化的方式解决这些问题。我们将通过**减少Python的工作量**来完成这一过程。
- en: If you have to cross a certain distance as quickly as possible you can either
    drive faster or shorten your path. Similarly, instead of having Python perform
    a lot of operations faster, you can also reduce the number of operations.
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你必须尽可能快地跨越一定距离，你可以选择加速行驶或缩短路径。同样，与其让Python执行更多的操作，不如减少操作的数量。
- en: Ultimately, you will gain a deeper understanding of code performance, acquire
    valueable skills in code analysis to avoid bottlenecks during development and
    be a better developer. Let’s code!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你将获得对代码性能的更深入理解，掌握代码分析的宝贵技能，以避免在开发过程中遇到瓶颈，并成为一个更好的开发者。让我们开始编码吧！
- en: Contents
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目录
- en: 'We are analyzing our problem in three parts:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从三个方面分析我们的问题：
- en: Ain **part A** we define what we mean by performance and discuss the profiler,
    which we’ll use in the next part to measure our code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在**A部分**我们定义性能的含义并讨论分析器，接下来我们将使用它来测量我们的代码。
- en: B **Part B** revolves around using tools to **spot the bottleneck**. We **measure**
    our code and spot performance bottlenecks. We use a practical example to understand
    why our function underperforms.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**B部分**围绕使用工具**定位瓶颈**展开。我们**测量**我们的代码并发现性能瓶颈。我们使用实际例子来理解为何我们的函数性能不佳。'
- en: 'C in **Part C** we discuss ways to eliminate bottlenecks. In the previous parts
    we’ve learnt how to detect problem-code and analyze it so we know the cause of
    the slowdown. In this part we **discuss strategies for performance increase**:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在**C部分**中，我们讨论了消除瓶颈的方法。在前面的部分中，我们学会了如何检测问题代码并分析它，以便了解减速的原因。在这一部分，我们**讨论性能提升策略**：
- en: Choosing the right data structure
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择合适的数据结构
- en: Eliminating slow-running code (like nested loops)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消除运行缓慢的代码（例如嵌套循环）
- en: using built-in functions
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内置函数
- en: In the end you’ll be able to apply these general strategies to any piece of
    code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最终你将能够将这些通用策略应用于任何代码。
- en: A. About performance
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: A. 关于性能
- en: Let’s first get some definitions and preparation out of the way.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先处理一些定义和准备工作。
- en: 1\. What is performance?
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1\. 什么是性能？
- en: 'Since we are trying to optimize the performance of our code, first we need
    a clear definition about what we mean when we talk about performance:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在尝试优化代码的性能，我们首先需要对性能的定义有一个清晰的认识：
- en: '[Performance: the amount of useful work accomplished estimated in terms of
    time needed, resources used, etc](https://en.wiktionary.org/wiki/performance)'
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[性能：以所需时间、使用的资源等来估计完成的有用工作量](https://en.wiktionary.org/wiki/performance)'
- en: For brevity, I’ve chosen to monitor the execution speed of a function in this
    article. Memory usage and size is relevant as well but I’ve chosen to omit it
    to keep this article a bit shorter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我选择了监控函数的执行速度。内存使用和大小也很重要，但我选择省略它以使文章稍短。
- en: '[](/using-multi-stage-builds-to-make-your-docker-image-almost-10x-smaller-239068cb6fb0?source=post_page-----eb0652d942b7--------------------------------)
    [## Using multi-stage builds to make your docker image 10x smaller'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[](/using-multi-stage-builds-to-make-your-docker-image-almost-10x-smaller-239068cb6fb0?source=post_page-----eb0652d942b7--------------------------------)
    [## 使用多阶段构建使你的 Docker 镜像缩小 10 倍'
- en: Clean up your Docker images by leaving behind unnecessary tools
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过留下不必要的工具来清理你的 Docker 镜像
- en: towardsdatascience.com](/using-multi-stage-builds-to-make-your-docker-image-almost-10x-smaller-239068cb6fb0?source=post_page-----eb0652d942b7--------------------------------)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[towardsdatascience.com](/using-multi-stage-builds-to-make-your-docker-image-almost-10x-smaller-239068cb6fb0?source=post_page-----eb0652d942b7--------------------------------)'
- en: 2\. How to measure performance?
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2\. 如何测量性能？
- en: Python has a very handy tool built in called the `cProfile` . This package provides
    *deterministic profiling* of Python programs. This means that precise timings
    are made for the intervals between *all* function calls, function returns and
    exception events. This differs from *statistical profiling*, which uses random
    samples to deduce relative indications of where time is being spent.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有一个非常方便的内置工具叫做 `cProfile`。这个包提供了*确定性分析*Python 程序的功能。这意味着对*所有*函数调用、函数返回和异常事件之间的时间间隔进行了精确计时。这与*统计分析*不同，后者使用随机样本来推断时间花费的相对情况。
- en: 'Using the `cProfile` is really easy:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `cProfile` 非常简单：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This produces the following result:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下结果：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A quick explanation about the columns:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对列的快速说明：
- en: '**ncalls**: number of calls'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ncalls**: 调用次数'
- en: '**tottime**: total time spent in the given function (excl. subfunctions)'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tottime**: 在给定函数中花费的总时间（不包括子函数）'
- en: '**percall**: tottime / ncalls'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**percall**: tottime / ncalls'
- en: '**cumtime**: cumulative time spent in this function and all subfunctions'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cumtime**: 在该函数及所有子函数中花费的累计时间'
- en: '**percall**: cumtime / primitive calls'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**percall**: cumtime / primitive calls'
- en: '**last column**: location -> functionname at linenumer in filename'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最后一列**: 位置 -> 文件名中的函数名和行号'
- en: As you see `cProfile` provides us with an easy-to-use tool to check the performance
    of our code. Let’s now focus on how to actually improve our Python code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`cProfile` 为我们提供了一个易于使用的工具来检查我们代码的性能。现在让我们专注于如何实际提升我们的 Python 代码。
- en: '[](/create-a-python-package-with-super-fast-rust-code-in-3-steps-a27389629beb?source=post_page-----eb0652d942b7--------------------------------)
    [## Create a Python Package with Super- Fast Rust Code in 3 Steps'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[](/create-a-python-package-with-super-fast-rust-code-in-3-steps-a27389629beb?source=post_page-----eb0652d942b7--------------------------------)
    [## 使用超级快的 Rust 代码在 3 个步骤中创建 Python 包'
- en: Extend you Python code with a package containing Rust code for a >150x performance
    increase!
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用包含 Rust 代码的包来扩展你的 Python 代码，以实现 >150 倍的性能提升！
- en: towardsdatascience.com](/create-a-python-package-with-super-fast-rust-code-in-3-steps-a27389629beb?source=post_page-----eb0652d942b7--------------------------------)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[towardsdatascience.com](/create-a-python-package-with-super-fast-rust-code-in-3-steps-a27389629beb?source=post_page-----eb0652d942b7--------------------------------)'
- en: 'B. Profiling: spotting and understanding bottlenecks'
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: B. 性能分析：发现和理解瓶颈
- en: 'Let’s start out with some code that needs optimizing. As an example we’ll use
    a function that does a very simple thing: it takes two lists and returns *how
    many distinct items are present in both lists (case-insensitive)*.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从需要优化的代码开始。作为示例，我们将使用一个非常简单的函数：它接受两个列表，并返回*两个列表中存在多少个不同的项（不区分大小写）*。
- en: 'Let’s check out this (on purpose super-sub-optimal) function:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下这个（故意设计得超不优化的）函数：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This function is clearly not a smart way to solve our problem but it will really
    nicely demonstrate how we can use `cProfile` to spot bottlenecks.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数显然不是解决我们问题的智能方法，但它确实很好地演示了我们如何使用`cProfile`来发现瓶颈。
- en: '[](/python-args-kwargs-and-all-other-ways-to-pass-arguments-to-your-function-bd2acdce72b5?source=post_page-----eb0652d942b7--------------------------------)
    [## Python args, kwargs, and All Other Ways to Pass Arguments to Your Function'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[](/python-args-kwargs-and-all-other-ways-to-pass-arguments-to-your-function-bd2acdce72b5?source=post_page-----eb0652d942b7--------------------------------)
    [## Python参数、关键字参数及所有其他传递参数的方式'
- en: Expertly design your function parameters in 6 examples
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 熟练设计你的函数参数，提供6个示例
- en: towardsdatascience.com](/python-args-kwargs-and-all-other-ways-to-pass-arguments-to-your-function-bd2acdce72b5?source=post_page-----eb0652d942b7--------------------------------)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[towardsdatascience.com](/python-args-kwargs-and-all-other-ways-to-pass-arguments-to-your-function-bd2acdce72b5?source=post_page-----eb0652d942b7--------------------------------)'
- en: 1\. Profiling our function
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1\. 性能分析我们的函数
- en: 'When we use `cProfile` on our function, this is the result when we pass two
    lists that both contain 1,000 five-letter words:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在我们的函数上使用`cProfile`时，这里是当我们传递两个都包含1000个五字单词的列表时的结果：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Notice that we execute a little over 2 million function calls in a little over
    half a second. Let’s first add this time to our bechmark so we have something
    to compare with later:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在半秒多一点的时间内执行了略多于200万次的函数调用。让我们先将这段时间添加到我们的基准中，以便后续进行比较：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 2\. Spotting bottlenecks
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2\. 发现瓶颈
- en: The most important line is the bottom one; here we see that we call the `upper`
    method roughly **2 million times**. This is because we compare each item in list1
    with each item in list 2.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的一行是底部那一行；在这里我们看到我们调用了`upper`方法大约**200万次**。这是因为我们将list1中的每个项与list2中的每个项进行比较。
- en: Both items need to be *stringified* and *upper-cased* in order to be compared.
    Since both lists are 1K items long this means that we must perform 1 million comparisons
    (1000x1000). The problem in this is that we `upper` both item1 and item2 a million
    times.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 两个项都需要*字符串化*和*转大写*以便进行比较。由于两个列表各有1000项，这意味着我们必须进行100万次比较（1000x1000）。问题在于我们`upper`函数对item1和item2进行了100万次。
- en: This means that in the best case at least `upper` will be **called 2 million**
    times. If items match there will be additional ones to check for their presense
    in the `duplicates` list and appending them (this is why there are 2,000,002 and
    not 2,000,000).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在最佳情况下，至少`upper`会被**调用200万次**。如果项匹配，还会有额外的项检查它们在`duplicates`列表中的存在性并添加它们（这就是为什么会有2,000,002次而不是2,000,000次）。
- en: 3\. Why is this slow?
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3\. 为什么这么慢？
- en: Python is loved for its ease-of-use but this comes with a downside. Under the
    hood Python memory allocation is much slower than other programming languages
    like C (in which Python is written).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Python因其易用性而受到喜爱，但这也带来了缺点。在底层，Python的内存分配比其他编程语言如C（Python是用C编写的）要慢得多。
- en: '[](/why-is-python-so-slow-and-how-to-speed-it-up-485b5a84154e?source=post_page-----eb0652d942b7--------------------------------)
    [## Why Python is so slow and how to speed it up'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[](/why-is-python-so-slow-and-how-to-speed-it-up-485b5a84154e?source=post_page-----eb0652d942b7--------------------------------)
    [## 为什么Python这么慢以及如何加快速度'
- en: Take a look under the hood to see where Python’s bottlenecks lie
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看Python的瓶颈在哪里
- en: towardsdatascience.com](/why-is-python-so-slow-and-how-to-speed-it-up-485b5a84154e?source=post_page-----eb0652d942b7--------------------------------)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[towardsdatascience.com](/why-is-python-so-slow-and-how-to-speed-it-up-485b5a84154e?source=post_page-----eb0652d942b7--------------------------------)'
- en: 'Since [**strings in Python are immutable**](https://mikehuls.medium.com/python-quirks-understand-how-a-variable-can-be-modified-by-a-function-that-doesnt-return-anything-343a40cc6923),
    under the hood **a new variable** is created every time you `uppercase` . For
    all of these variables memory has to be **allocated**, which Python does **relatively
    slow**. When you then do this 2 million times you’ll start to notice the slowdown.
    Read more about Python’s design in the article above or watch this presentation
    below:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 [**Python 中的字符串是不可变的**](https://mikehuls.medium.com/python-quirks-understand-how-a-variable-can-be-modified-by-a-function-that-doesnt-return-anything-343a40cc6923)，在底层每次你`uppercase`
    时都会创建**一个新变量**。所有这些变量都需要**分配内存**，而 Python 的内存分配**相对较慢**。当你这样做 200 万次时，你会开始注意到这种性能下降。了解更多关于
    Python 设计的信息，可以阅读上面的文章或观看下面的演示：
- en: C. Eliminating bottlenecks
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C. 消除瓶颈
- en: Now that we have spotted our bottleneck it’s time to speed up our code. Remember
    that our **goal** is to **make Python do less work**.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经找到了瓶颈，现在是时候加速我们的代码了。记住我们的**目标**是**让 Python 做更少的工作**。
- en: '[](/python-quirks-understand-how-a-variable-can-be-modified-by-a-function-that-doesnt-return-anything-343a40cc6923?source=post_page-----eb0652d942b7--------------------------------)
    [## Python Quirks: Understand How a Variable Can Be Modified by a Function That
    Doesn’t Return Anything'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[](/python-quirks-understand-how-a-variable-can-be-modified-by-a-function-that-doesnt-return-anything-343a40cc6923?source=post_page-----eb0652d942b7--------------------------------)
    [## Python 奇特之处：理解一个函数如何修改一个不返回任何东西的变量'
- en: A deep dive into how Python passes arguments and mutability to prevent unexpected
    bugs
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 深入探讨 Python 如何传递参数和可变性，以防止意外错误。
- en: towardsdatascience.com](/python-quirks-understand-how-a-variable-can-be-modified-by-a-function-that-doesnt-return-anything-343a40cc6923?source=post_page-----eb0652d942b7--------------------------------)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: towardsdatascience.com](/python-quirks-understand-how-a-variable-can-be-modified-by-a-function-that-doesnt-return-anything-343a40cc6923?source=post_page-----eb0652d942b7--------------------------------)
- en: 1\. Make Python do less work — understand your code
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1\. 让 Python 做更少的工作 — 理解你的代码
- en: 'One easy way to do less is to **uppercase each item** in the list **before
    looping** since we don’t care about the casing anyway:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的减少操作的方法是**在循环之前将每个项目大写**，因为我们不在乎大小写：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you see we first uppercase each item in each list. When we profile our code
    again we see that this simple change brought the number of function calls **down
    from roughly 2 million to roughly 2 thousand**. This is because now we have to
    uppercase each item in list1 **and** in list2 (1k + 1k = 2k).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们首先对每个列表中的每个项目进行大写处理。当我们再次对代码进行性能分析时，我们发现这个简单的更改将函数调用的次数**从大约 200 万减少到大约
    2000**。这是因为现在我们需要对 list1 **和** list2 中的每个项目进行大写处理（1k + 1k = 2k）。
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We call the `upper` and `str` functions 1,000x fewer leading to a nice performance
    increase; **execution time decreased by 28x** from 523ms to 18ms:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用 `upper` 和 `str` 函数的次数减少了 1,000 倍，从而显著提升了性能；**执行时间减少了 28 倍**，从 523ms 降至
    18ms：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Also notice that I’ve replaced the duplicates list with a set so we don’t need
    to check if the item is already contained. Using sets will take even more work
    out of Python’s hands since sets only contain unique values by default.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另请注意，我将重复项列表替换为集合，这样我们就不需要检查项目是否已包含。使用集合将进一步减轻 Python 的负担，因为集合默认只包含唯一值。
- en: '[](/args-vs-kwargs-which-is-the-fastest-way-to-call-a-function-in-python-afb2e817120?source=post_page-----eb0652d942b7--------------------------------)
    [## Args vs kwargs: which is the fastest way to call a function in Python?'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[](/args-vs-kwargs-which-is-the-fastest-way-to-call-a-function-in-python-afb2e817120?source=post_page-----eb0652d942b7--------------------------------)
    [## 参数与关键字参数：在 Python 中调用函数的最快方式是什么？'
- en: A clear demonstration of the timeit module
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`timeit` 模块的清晰演示'
- en: towardsdatascience.com](/args-vs-kwargs-which-is-the-fastest-way-to-call-a-function-in-python-afb2e817120?source=post_page-----eb0652d942b7--------------------------------)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: towardsdatascience.com](/args-vs-kwargs-which-is-the-fastest-way-to-call-a-function-in-python-afb2e817120?source=post_page-----eb0652d942b7--------------------------------)
- en: 2\. Avoid nested loops
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2\. 避免嵌套循环
- en: Another easy to spot bottleneck is the fact that we loop over each item in list2
    for each item in list 1\. If both lists contain 10 items this comes down to (10
    x 10=) 100 comparisons. If both lists contain 1000 items we have to do 1 million
    comparisons. You see how the number of comparisons increases exponentially relative
    to the number of inputs and how this quickly escalates our performance problems.
    *Read more about* [***Big-O notation***](https://en.wikipedia.org/wiki/Big_O_notation)*for
    more information.*
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个容易发现的瓶颈是我们对列表 1 中的每一项都遍历列表 2。如果两个列表都包含 10 项，这就需要进行 (10 x 10=) 100 次比较。如果两个列表都包含
    1000 项，则需要进行 100 万次比较。你可以看到，比较次数相对于输入数量呈指数级增长，这会迅速加剧我们的性能问题。*了解更多关于* [***大 O 符号***](https://en.wikipedia.org/wiki/Big_O_notation)*的信息。*
- en: 'Instead of looping twice and comparing items we can also implement the code
    below:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过实现下面的代码来避免进行两次循环和比较项：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this example we only loop through `list_1` and check if `list_2` contains
    that value. Let’s check out the benchmark:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们只遍历 `list_1` 并检查 `list_2` 是否包含该值。让我们查看基准测试：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With two simple changes we’ve increased performance a lot but there’s a way
    to increase performance even more.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过两个简单的改动，我们显著提高了性能，但还有一种方法可以进一步提升性能。
- en: 3\. Use the right data structure— Deduplicating the lists
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3\. 使用合适的数据结构——去重列表
- en: 'In order to save even more work we can de-duplicate both lists since this brings
    down the number of comparisons we have to perform. We’ll take a short detour to
    think about a function to de-duplicate our lists. Then we’ll integrate this into
    our list-comparison-function. The first function you might come up with could
    look like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省更多工作，我们可以对两个列表进行去重，因为这可以减少需要执行的比较次数。我们将暂时绕道思考一个去重列表的函数。然后，我们将把它集成到我们的列表比较函数中。你可能想到的第一个函数可能如下所示：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Nothing too special; it just goes through every item in the list and puts it
    into another list if it isn’t already in there. The bulk of the work of this function
    is in checking if a value is present in a list for deduplication purposes. If
    we take a list of **100,000 words** the function takes a **little over a minute**
    to complete:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么特别的；它只会遍历列表中的每一项，并将其放入另一个列表中，如果该项还不在其中。这个函数的大部分工作是在检查一个值是否存在于列表中以进行去重。如果我们使用一个**100,000
    个单词**的列表，这个函数需要**稍超过一分钟**才能完成：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[](/applying-python-multiprocessing-in-2-lines-of-code-3ced521bac8f?source=post_page-----eb0652d942b7--------------------------------)
    [## Applying Python multiprocessing in 2 lines of code'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[## 使用 Python 多线程的 2 行代码](/applying-python-multiprocessing-in-2-lines-of-code-3ced521bac8f?source=post_page-----eb0652d942b7--------------------------------)'
- en: When and how to use multiple cores to execute many times faster
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 何时以及如何使用多个核心以更快的速度执行
- en: towardsdatascience.com](/applying-python-multiprocessing-in-2-lines-of-code-3ced521bac8f?source=post_page-----eb0652d942b7--------------------------------)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[towardsdatascience.com](/applying-python-multiprocessing-in-2-lines-of-code-3ced521bac8f?source=post_page-----eb0652d942b7--------------------------------)'
- en: 'Let’s **optimize** this function to use **set**s: a dataset can only contain
    unique values. This way we don’t have to let Python check if a value is already
    present in a collection; this now gets handled by the set. fter rewriting we end
    up with a more easily readable and better performing function:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们**优化**这个函数以使用**集合**：数据集只能包含唯一值。这样我们就不需要让 Python 检查一个值是否已经存在于集合中；现在由集合来处理这个问题。重写后，我们得到了一个更易读且性能更好的函数：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you see we use a set comprehension to loop through each item in the list.
    After this is done we end up with a set that contains only unique, uppercase values
    of our list. Before returning we cast it to a list. When we compare this new function
    to the old we see that it’s **over 2,800x faster!**
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用集合推导式遍历列表中的每一项。在完成后，我们得到一个仅包含列表中唯一大写值的集合。在返回之前，我们将其转换为列表。当我们将这个新函数与旧函数进行比较时，我们发现它**快了
    2,800 多倍！**
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The reason sets are this much faster is becasue they are implemented in C (in
    which Python itself is also written). Since it’s memory is also managed by C,
    which is much more efficient. In addition the set is unordered and can only contain
    unique values, saving a lot of operations checking and ordering the items. This,
    again, takes **more work out of Python’s hands**, **increasing performance**.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 集合之所以速度更快，是因为它们是用 C 语言实现的（Python 自身也是用 C 语言编写的）。由于内存也由 C 管理，这样更高效。此外，集合是无序的，并且只能包含唯一值，从而节省了大量的检查和排序操作。这再次将**更多工作从
    Python 手中移开**，**提高了性能**。
- en: 'Let’s implement the set in our list-matching-function and benchmark:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在列表匹配函数中实现集合并进行基准测试：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you see the lists now first get deduplicated. When we benchmark we see a
    **huge performance increase**:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，现在列表首先会被去重。当我们进行基准测试时，看到 **巨大的性能提升**：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Our function completes in **half a millisecond** instead of half a second. Still
    we might have one more trick up our sleeve for the next part
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数在 **半毫秒** 内完成，而不是半秒钟。我们可能还有一个小窍门可以在下一部分使用。
- en: '[](/5-real-handy-python-decorators-for-analyzing-debugging-your-code-c22067318d47?source=post_page-----eb0652d942b7--------------------------------)
    [## 5 real handy python decorators for analyzing/debugging your code'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[](/5-real-handy-python-decorators-for-analyzing-debugging-your-code-c22067318d47?source=post_page-----eb0652d942b7--------------------------------)
    [## 5 个实际有用的 Python 装饰器用于分析/调试代码'
- en: Apply these handy, general-purpose decorators directly to your code
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将这些实用的通用装饰器直接应用到你的代码中
- en: towardsdatascience.com](/5-real-handy-python-decorators-for-analyzing-debugging-your-code-c22067318d47?source=post_page-----eb0652d942b7--------------------------------)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[towardsdatascience.com](/5-real-handy-python-decorators-for-analyzing-debugging-your-code-c22067318d47?source=post_page-----eb0652d942b7--------------------------------)'
- en: 4\. Using data structure functions — set intersection
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4. 使用数据结构函数 — 集合交集
- en: 'One last optimization that we can add is to skip looping altogether and use
    the set’s `intersection` method:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加的最后一个优化是跳过循环，使用集合的 `intersection` 方法：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you see we end up with a nicely readable, compact function. The `intersection`
    methods returns as set of items that are present in both `set_1` and `set_2`.
    Lastly we return the length of this set. Let’s add this to our benchmark and see
    the final results:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们最终得到一个非常易读、简洁的函数。`intersection` 方法返回一个集合，该集合包含在 `set_1` 和 `set_2` 中都存在的项。最后，我们返回这个集合的长度。让我们将其添加到基准测试中，看看最终结果如何：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Not only is our final function a lot more readable, it’s also almost 1500x faster
    than what we started with.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最终函数不仅可读性大大提高，而且比起最初的版本快了几乎 1500 倍。
- en: '[](/cython-for-data-science-6-steps-to-make-this-pandas-dataframe-operation-over-100x-faster-1dadd905a00b?source=post_page-----eb0652d942b7--------------------------------)
    [## 6 Steps to Make this Pandas Dataframe Operation 100 Times Faster'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[](/cython-for-data-science-6-steps-to-make-this-pandas-dataframe-operation-over-100x-faster-1dadd905a00b?source=post_page-----eb0652d942b7--------------------------------)
    [## 6 步骤使 Pandas Dataframe 操作速度提升 100 倍'
- en: 'Cython for Data Science: Combine Pandas with Cython for an incredible speed
    improvement'
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Cython 数据科学：将 Pandas 与 Cython 结合，实现惊人的速度提升
- en: towardsdatascience.com](/cython-for-data-science-6-steps-to-make-this-pandas-dataframe-operation-over-100x-faster-1dadd905a00b?source=post_page-----eb0652d942b7--------------------------------)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[towardsdatascience.com](/cython-for-data-science-6-steps-to-make-this-pandas-dataframe-operation-over-100x-faster-1dadd905a00b?source=post_page-----eb0652d942b7--------------------------------)'
- en: Further optimization?
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步优化？
- en: Maybe you’ve gone through all of these steps and your code performance is still
    not good enough. Then there is the option to apply [**multi-processing**](https://mikehuls.medium.com/applying-python-multiprocessing-in-2-lines-of-code-3ced521bac8f),
    [**threads**](https://mikehuls.medium.com/thread-your-python-program-with-two-lines-of-code-3b474407dbb8)
    or even re-write a (part of a) function in a more optimized language like [**C**](https://mikehuls.medium.com/write-your-own-c-extension-to-speed-up-python-x100-626bb9d166e7),
    [**Rust**](https://mikehuls.medium.com/create-a-python-package-with-super-fast-rust-code-in-3-steps-a27389629beb)
    or [**Cython**](https://mikehuls.medium.com/cython-for-absolute-beginners-30x-faster-code-in-two-simple-steps-bbb6c10d06ad).
    The goal of this article was to not reach for the big guns right away but first
    squeeze out every little drop of performance that Python can offer. If further
    optimization is required the methods in this article will make it even faster.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你已经经历了这些步骤，但代码性能仍然不够理想。那么，你可以选择应用[**多进程**](https://mikehuls.medium.com/applying-python-multiprocessing-in-2-lines-of-code-3ced521bac8f)、[**线程**](https://mikehuls.medium.com/thread-your-python-program-with-two-lines-of-code-3b474407dbb8)或甚至用像[**C**](https://mikehuls.medium.com/write-your-own-c-extension-to-speed-up-python-x100-626bb9d166e7)、[**Rust**](https://mikehuls.medium.com/create-a-python-package-with-super-fast-rust-code-in-3-steps-a27389629beb)或[**Cython**](https://mikehuls.medium.com/cython-for-absolute-beginners-30x-faster-code-in-two-simple-steps-bbb6c10d06ad)这样的更优化语言重新编写（部分）函数。本文的目的是不立即使用大招，而是首先挤出
    Python 能提供的每一滴性能。如果需要进一步优化，本文中的方法将使其更快。
- en: '[](/advanced-multi-tasking-in-python-applying-and-benchmarking-threadpools-and-processpools-90452e0f7d40?source=post_page-----eb0652d942b7--------------------------------)
    [## Advanced multi-tasking in Python: Applying and benchmarking thread pools and
    process pools in 6…'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[链接到文章](https://towardsdatascience.com/advanced-multi-tasking-in-python-applying-and-benchmarking-threadpools-and-processpools-90452e0f7d40?source=post_page-----eb0652d942b7--------------------------------)
    [## Python中的高级多任务处理：在6种情况下应用和基准测试线程池和进程池'
- en: Safely and easily apply multi-tasking to your code
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全且轻松地将多任务处理应用到你的代码中
- en: towardsdatascience.com](/advanced-multi-tasking-in-python-applying-and-benchmarking-threadpools-and-processpools-90452e0f7d40?source=post_page-----eb0652d942b7--------------------------------)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[链接到 Data Science](https://towardsdatascience.com/advanced-multi-tasking-in-python-applying-and-benchmarking-threadpools-and-processpools-90452e0f7d40?source=post_page-----eb0652d942b7--------------------------------)'
- en: Conclusion
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: In this article we’ve gone through a very practical example of **spotting**,
    **understanding** and **eliminating performance bottlenecks**. We’ve seen that
    you don’t have to make complex, structural changes to your code right away; sometimes
    easy, small, easy-to-implement changes can optimize your code a lot. When this
    is not enough there is always the option of using threads, multiple processes
    or writing a Python package in a compile language anyway.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇文章中，我们通过了一个非常实用的例子来**识别**、**理解**和**消除性能瓶颈**。我们已经看到，你不必立即对代码进行复杂的结构性更改；有时简单的小的、易于实施的更改可以大大优化你的代码。当这些还不够时，总是可以选择使用线程、多进程或在编译语言中编写Python包。
- en: I think the most important part is to truly understand your code, understand
    how Python works and where it is less performant and apply the right data structures.
    For this, check out my [**other articles here**](https://mikehuls.com/articles?tags=fast)or
    this [**this presentation**](https://www.youtube.com/watch?v=N7cgUnW-tZQ).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为最重要的部分是真正理解你的代码，理解Python如何工作以及在哪里性能较差，并应用正确的数据结构。为此，请查看我[**其他文章**](https://mikehuls.com/articles?tags=fast)或这个[**演示文稿**](https://www.youtube.com/watch?v=N7cgUnW-tZQ)。
- en: 'I hope this article was as clear as I hope it to be but if this is not the
    case please let me know what I can do to clarify further. In the meantime, check
    out my [other articles](https://mikehuls.com/articles) on all kinds of programming-related
    topics like these:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这篇文章像我希望的那样清晰，但如果不是这样，请告诉我我可以做些什么以进一步澄清。同时，请查看我关于各种编程相关主题的[其他文章](https://mikehuls.com/articles)：
- en: '[Git for absolute beginners: understanding Git with the help of a video game](https://mikehuls.medium.com/git-for-absolute-beginners-understanding-git-with-the-help-of-a-video-game-88826054459a)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[针对绝对初学者的Git：通过视频游戏理解Git](https://mikehuls.medium.com/git-for-absolute-beginners-understanding-git-with-the-help-of-a-video-game-88826054459a)'
- en: '[Create and publish your own Python package](https://mikehuls.medium.com/create-and-publish-your-own-python-package-ea45bee41cdc)'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[创建和发布自己的Python包](https://mikehuls.medium.com/create-and-publish-your-own-python-package-ea45bee41cdc)'
- en: '[Create a fast auto-documented, maintainable, and easy-to-use Python API in
    5 lines of code with FastAPI](https://mikehuls.medium.com/create-a-fast-auto-documented-maintainable-and-easy-to-use-python-api-in-5-lines-of-code-with-4e574c00f70e)'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[用FastAPI在5行代码中创建一个快速的自动文档、可维护且易于使用的Python API](https://mikehuls.medium.com/create-a-fast-auto-documented-maintainable-and-easy-to-use-python-api-in-5-lines-of-code-with-4e574c00f70e)'
- en: Happy coding!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 快乐编程！
- en: — Mike
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: — Mike
- en: '*P.S: like what I’m doing?* [*Follow me!*](https://mikehuls.medium.com/membership)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*附注：喜欢我做的事情吗？* [*关注我！*](https://mikehuls.medium.com/membership)'
- en: '[](https://mikehuls.medium.com/membership?source=post_page-----eb0652d942b7--------------------------------)
    [## Join Medium with my referral link — Mike Huls'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[链接到Medium会员页面](https://mikehuls.medium.com/membership?source=post_page-----eb0652d942b7--------------------------------)
    [## 使用我的推荐链接加入Medium — Mike Huls'
- en: Read every story from Mike Huls (and thousands of other writers on Medium).
    Your membership fee directly supports Mike…
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阅读Mike Huls（以及Medium上的其他成千上万名作者）的每一个故事。你的会员费直接支持Mike…
- en: mikehuls.medium.com](https://mikehuls.medium.com/membership?source=post_page-----eb0652d942b7--------------------------------)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[链接到Medium会员页面](https://mikehuls.medium.com/membership?source=post_page-----eb0652d942b7--------------------------------)'
