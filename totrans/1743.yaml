- en: 'Python Type Hinting: Duck Type Compatibility and Consistent-With'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/python-type-hinting-duck-type-compatibility-and-consistent-with-72e8b348d8ac](https://towardsdatascience.com/python-type-hinting-duck-type-compatibility-and-consistent-with-72e8b348d8ac)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: PYTHON PROGRAMMING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You don’t have to hint int when you’re hinting float, or namedtuple when you’re
    hinting tuple. Why?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@nyggus?source=post_page-----72e8b348d8ac--------------------------------)[![Marcin
    Kozak](../Images/d7faf62e48ed81dab5d8ad92819fff54.png)](https://medium.com/@nyggus?source=post_page-----72e8b348d8ac--------------------------------)[](https://towardsdatascience.com/?source=post_page-----72e8b348d8ac--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----72e8b348d8ac--------------------------------)
    [Marcin Kozak](https://medium.com/@nyggus?source=post_page-----72e8b348d8ac--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----72e8b348d8ac--------------------------------)
    ·8 min read·Jun 6, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7661c8753bdda73a66f4cc31ac70bc99.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Markus Winkler](https://unsplash.com/@markuswinkler?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, Python type hinting can make things easier. True, not always — but
    at least in my opinion, quite often it does — given that it’s done wisely. Some
    disagree, but I am not going to dispute with them: in my eyes, this is quite a
    subjective subject.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I wrote what I think about Python type hinting, how to use it to increase code
    readability, and how *not* to use it to do otherwise, in the following article:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://betterprogramming.pub/pythons-type-hinting-friend-foe-or-just-a-headache-73c7849039c7?source=post_page-----72e8b348d8ac--------------------------------)
    [## Python’s Type Hinting: Friend, Foe, or Just a Headache?'
  prefs: []
  type: TYPE_NORMAL
- en: Type hinting’s popularity is increasing in the Python community. Where will
    this lead us? What can we do to use it…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: betterprogramming.pub](https://betterprogramming.pub/pythons-type-hinting-friend-foe-or-just-a-headache-73c7849039c7?source=post_page-----72e8b348d8ac--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Today, we’ll discuss what *consistent-with* and *duck-type compatibility* mean
    in terms of Python types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine you’re hinting the use of `float`, like in the function below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is a typical statistical function, calculating the sum of squares of a
    variable. It takes a container of floating-point numbers and returns a float.
  prefs: []
  type: TYPE_NORMAL
- en: As you see, to annotate the function, I used `Sequence`, a generic abstract
    base class available from `collections.abc` (before Python 3.9 you needed to use
    `typing.Sequence`). This means you can provide a list or a tuple — but you can’t
    provide, for instance, a generator¹.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, so this is a statistical function, and it expects a sequence of floating-point
    numbers. That makes sense, right? But in real-life, quite often quantitative variables
    are integers, like the number of mites per shoot, the number of items sold, the
    number of inhabitants, to name just a few.
  prefs: []
  type: TYPE_NORMAL
- en: Shouldn’t we thus do something with the function, to take this fact into account?
    We all know that *dynamically*, the function will work just fine for integers,
    and that *dynamically* we can easily join integers and floating-point numbers
    in `x`. But what about type hints and static checkers?
  prefs: []
  type: TYPE_NORMAL
- en: Is it fine to use `int` for this function, or should we rather make it clear
    that it accepts `int` values, too? Should we do it like below?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This seems clear: you can use a sequence of floating-point numbers or integers,
    and the function returns a float. Isn’t this version better, at least from type-hinting
    perspective?'
  prefs: []
  type: TYPE_NORMAL
- en: To answer this question, let’s return to the previous version, without `int`.
    What do static type checkers say about that?
  prefs: []
  type: TYPE_NORMAL
- en: 'Not a word! Look what `Pylance` (in Visual Studio Code) says about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/baaf9324c6318ec4be4e3ad671e78857.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Screenshot from Visual Studio Code: Pylance does not indicate any error. Image
    by author'
  prefs: []
  type: TYPE_NORMAL
- en: 'Nothing! Had `Pylance` seen a static error, we would’ve seen it underlined
    in the color red. And here, `mypy`’s opinion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9b9a0fd14b3351e967d152476db544c9.png)'
  prefs: []
  type: TYPE_IMG
- en: Mypy says all’s fine when you use int for float annotation. Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Why can you use `int` instead of `float`?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve come to the main topic of this article. Long story short, you can use
    `int` instead of `float` when you hint `float`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s have a look at the webpage of `mypy`’s documentation describing
    duck type compatibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[## Duck type compatibility - mypy 1.3.0 documentation'
  prefs: []
  type: TYPE_NORMAL
- en: In Python, certain types are compatible even though they aren't subclasses of
    each other. For example, objects are…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: mypy.readthedocs.io](https://mypy.readthedocs.io/en/stable/duck_type_compatibility.html?source=post_page-----72e8b348d8ac--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what we will read there, among others:'
  prefs: []
  type: TYPE_NORMAL
- en: In Python, certain types are compatible even though they aren’t subclasses of
    each other. For example, `int` objects are valid whenever `float` objects are
    expected. Mypy supports this idiom via *duck type compatibility*.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Ha!
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t worry, this doesn’t widen the knowledge you should know about type hints
    too much:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is supported for a small set of built-in types:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* `int` is duck type compatible with `float` and `complex`.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* `float` is duck type compatible with `complex`.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* `bytearray` and `memoryview` are duck type compatible with `bytes`.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So now we know. We do not have to hint `int` when we already hint the use of
    `float`. This will work in exactly the same way as `float | int` (or `Union[float,
    int]`). This means that the `| int` part in the hint is redundant.
  prefs: []
  type: TYPE_NORMAL
- en: And just like `int` is duck type compatible with `float`, it is also duck type
    compatible with `complex`, and `float` is duck type compatible with `complex`,
    and both `bytearray` and `memoryview` are duck type compatible with `bytes`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, that’s `mypy`. Now, let’s look into my favorite Python book, one I’ve
    referred to quite a lot in my articles: *Fluent Python*, 2nd ed., by Luciano Ramalho:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://www.fluentpython.com/?source=post_page-----72e8b348d8ac--------------------------------)
    [## Fluent Python, the lizard book'
  prefs: []
  type: TYPE_NORMAL
- en: An accessibility-friendly Hugo theme, ported from the original Cupper project.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: www.fluentpython.com](https://www.fluentpython.com/?source=post_page-----72e8b348d8ac--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: To learn what’s going on in here, we should move to where Luciano explains what
    *consistent-with* means. What he writes is, we don’t have to add `int` to a `float`
    type hint because `int` is *consistent-with* `float`.
  prefs: []
  type: TYPE_NORMAL
- en: But what does *consistent-with* mean? (And yes, Luciano does use the hyphen
    in and the italics for *consistent-with* every time, unlike [PEP 484](https://peps.python.org/pep-0484/)*.)*
  prefs: []
  type: TYPE_NORMAL
- en: As he explains, `T2` is *consistent-with* `T1` when `T1` is a subtype of `T2`.
    In other words, a subclass is *consistent-with* all its superclasses — with some
    exceptions that enwiden the definition of *consistent-with*. Based on [this section
    of PEP 484](https://peps.python.org/pep-0484/#the-numeric-tower), Luciano explains
    that the definition also comprises the above-cited scenarios with numbers.
  prefs: []
  type: TYPE_NORMAL
- en: And when we add the scenario with the types *consistent-with* `bytes`, we will
    have the following definition of *consistent-with:*
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/84df5d4ef8b1cb03651755dbbbd826f7.png)'
  prefs: []
  type: TYPE_IMG
- en: '`T2` is *consistent-with* `T1` when:'
  prefs: []
  type: TYPE_NORMAL
- en: '`T1` is a subtype of `T2`, or'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T1` is duck type compatible with `T2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/84df5d4ef8b1cb03651755dbbbd826f7.png)'
  prefs: []
  type: TYPE_IMG
- en: What we need to remember is that if one type is *consistent-with* another type,
    it’s either its subtype (subclass), or it is duck type compatible with it — which
    boils down to a fact that it’s enough to type hint the latter; you can simply
    omit the former.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be honest, I did such a mistake quite often — I mean, I did this redundant
    thing, something like below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: I always thought I was making the user’s life easier, thanks to clarifying that
    `x` can include both integers and floating-point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Was I? I don’t know. For sure, I was making the code verbose. A person who does
    not know that `int` is a duck type of `float` may think, why only `float`? On
    the other hand, we should not write the code in a way that makes easy to understand
    by those who do not know. Of course, there are some limits, but I don’t think
    this situation crosses a line. Besides, anyone who knows Python a little bit should
    know that where a `float` is expected, an `int` can be used; this is rather common
    knowledge. Anyway, this is one of the reasons why I’m writing this article — so
    that my readers know that not only can an `int` be used dynamically instead of
    a `float`, but also that this is fine from a static checkers point of view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s return to the `sum_of_squares()` function. When you know about duck type
    compatibility, the concise version is as clear but shorter and thus cleaner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: So, I could say that my lack of Python knowledge made me think I was doing a
    favor to the users of my code — now I know that I wasn’t.
  prefs: []
  type: TYPE_NORMAL
- en: Named tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With `collection.namedtupes` and `typing.NamedTuples`, the situation is similar,
    with a small difference. Both these types are subtypes of the regular `tuple`
    type, and this is why they are *consistent-with* it.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s why the below annotation is… Well, it’s not the best:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The function itself is not the smartest among those I’ve written, but that’s
    not the point. The point is, if you want to accept a `tuple`, a `namedtuple` and
    a `NamedTuple`, you can do it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you want to accept only one of the two named tuples, you can type
    hint it, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: And here, only instances of `collections.namedtuple` and of its subclasses can
    be used. You could of course indicate `typing.NamedTuple` the same way, and then
    a `collections.namedtuple` could not be used. Remember, if `T1` is *consistent-with*
    `T2`, it does not mean that `T2` is *consistent-with* `T1`.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, if `T1` is *consistent-with* `T2`, it does not mean that `T2` is *consistent-with*
    `T1`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We learned what *consistent-with* and *duck type compatibility* mean. Don’t
    be afraid to use this knowledge in your code. You know how to respond to the following
    questions: “Why only `float`? What if I want to use an `int`?”'
  prefs: []
  type: TYPE_NORMAL
- en: Footnotes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ¹ That `sum_of_squares()` defined that way does not accept a generator makes
    plenty of sense. To see why, analyze the function’s body, keeping in mind how
    generators work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that calculating `len(x)` would consume the generator — so, the function
    would not be able to calculate the sum of `x`. Look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`Pylance` screams:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/20aa90352469f55f0a3ad8835a38536a.png)'
  prefs: []
  type: TYPE_IMG
- en: '`mypy` does not like it, either:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Do you see how using a static type checker can help you catch errors that otherwise
    would be caught at runtime?
  prefs: []
  type: TYPE_NORMAL
- en: So, kudos to type hinting? Yes — but kudos to *good* type hinting!
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks for reading. If you enjoyed this article, you may also enjoy other articles
    I wrote; you will see them [here](https://medium.com/@nyggus). And if you want
    to join Medium, please use my referral link below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/@nyggus/membership?source=post_page-----72e8b348d8ac--------------------------------)
    [## Join Medium with my referral link - Marcin Kozak'
  prefs: []
  type: TYPE_NORMAL
- en: Read every story from Marcin Kozak (and thousands of other writers on Medium).
    Your membership fee directly supports…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/@nyggus/membership?source=post_page-----72e8b348d8ac--------------------------------)
  prefs: []
  type: TYPE_NORMAL
