["```py\ndef load_from_url_in_memory(url):\n    '''This function load the xml file from the url in memory after unziping it\n       It assume only one file with a .xml extention is available in the zip\n    '''\n\n    with urllib.request.urlopen(url) as url:\n        s = io.BytesIO(url.read())\n        z = zipfile.ZipFile(s)\n\n    return z\n```", "```py\n<?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\"?>\n```", "```py\n<pdv_liste>\n  <pdv id=\"40140005\" latitude=\"4374653.865\" longitude=\"-132117.12497344\" cp=\"40140\" pop=\"R\">\n    <adresse>9 AVENUE DE CRAMAT</adresse>\n    <ville>SOUSTONS</ville>\n    <horaires automate-24-24=\"1\">\n      <jour id=\"1\" nom=\"Lundi\" ferme=\"\"/>\n      <jour id=\"2\" nom=\"Mardi\" ferme=\"\"/>\n      <jour id=\"3\" nom=\"Mercredi\" ferme=\"\"/>\n      <jour id=\"4\" nom=\"Jeudi\" ferme=\"\"/>\n      <jour id=\"5\" nom=\"Vendredi\" ferme=\"\"/>\n      <jour id=\"6\" nom=\"Samedi\" ferme=\"\"/>\n      <jour id=\"7\" nom=\"Dimanche\" ferme=\"\"/>\n    </horaires>\n    <services>\n      <service>Laverie</service>\n      <service>Station de gonflage</service>\n      <service>Automate CB 24/24</service>\n    </services>\n    <prix nom=\"Gazole\" id=\"1\" maj=\"2023-01-18 07:27:47\" valeur=\"1.891\"/>\n    <prix nom=\"E85\" id=\"3\" maj=\"2023-01-14 08:15:44\" valeur=\"1.059\"/>\n    <prix nom=\"E10\" id=\"5\" maj=\"2023-01-18 07:27:47\" valeur=\"1.839\"/>\n  </pdv>\n  <pdv>\n    ...\n  </pdv>\n</pdv_liste> \n```", "```py\n<pdv id=\"40140005\" latitude=\"4374653.865\" longitude=\"-132117.12497344\" cp=\"40140\" pop=\"R\">\n```", "```py\nurl = f'https://donnees.roulez-eco.fr/opendata/instantane'\nxml_file = load_from_url_in_memory(url)\npd.read_xml(z.open(xml_file), encoding=\"ISO-8859-1\")\n```", "```py\nimport xml.etree.ElementTree as ET\n\n#Link of instant data feed\nurl = f'https://donnees.roulez-eco.fr/opendata/instantane'\n#from the function defined earlier\nxml_file = load_from_url_in_memory(url)\n\nwith z.open(xml_file, \"r\") as file:\n    #Create the tree using xml parser\n    tree = ET.parse(file)\n    #Access the root node\n    root = tree.getroot()\n```", "```py\n<Element 'pdv_liste' at 0x0000019EAEF3B400>\n```", "```py\nfor child in root:\n    #Do something\n```", "```py\ndef parse_pdv(pdv, stations, oil_types):\n    '''This function retrieve all the data available in a pdv element'''\n\n    station = {}\n    #Get attributes of the pdv\n    station.update(pdv.attrib)\n\n    #It is precised in the doc that lats and longs have to be divided by 100 000\n    station['latitude'] = float(station['latitude'])/100000\n    station['longitude'] = float(station['longitude'])/100000\n\n    #Rename the id key\n    station[\"station_id\"] = station[\"id\"]\n    del station[\"id\"]\n\n    #Explore children, by type of children\n    for element in pdv:\n        if element.tag == \"adresse\":\n            station[\"adress\"] = element.text\n        if element.tag == \"ville\":\n            station[\"city\"] = element.text\n        if element.tag == \"horaires\":\n            #Some children, more complicated to parse, have their own subfunctions\n            station = parse_schedules(element, station)\n        if element.tag == 'prix':\n            #Some children, more complicated to parse, have their own subfunctions\n            oil_types = parse_oil(element, station, oil_types)\n\n    stations.append(station)\n    return stations, oil_types\n\ndef parse_xml(z):\n    '''Parse the whole xml'''\n    xml_file = [file for file in z.namelist() if file.endswith('.xml')][0]\n    with z.open(xml_file, \"r\") as file:\n        #Create the tree using xml parser\n        tree = ET.parse(file)\n        #Access the root node\n        root = tree.getroot()\n\n        #Initiate stations and oil_types\n        stations = []\n        oil_types = []\n\n        for pdv in root:\n            stations, oil_types = parse_pdv(pdv, stations, oil_types)\n\n    stations_df = pd.DataFrame(stations)\n    oil_types_df = pd.DataFrame(oil_types)\n\n    return stations_df, gas_types_df\n```", "```py\ndef haversine_distance(lat1, lon1, lat2, lon2):\n    '''Calculate the distance between two points (lat1,lon1) and (lat2, lon2) in km'''\n    R = 6371 \n\n    lat1, lon1, lat2, lon2 = map(np.radians, [lat1, lon1, lat2, lon2])\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n\n    a = np.sin(dlat / 2)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon / 2)**2\n    c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1 - a))\n\n    distance = R * c\n    return distance\n```", "```py\ndef filter_dataset_from_source_point(stations_df, lat_point, lon_point, distance = 20):\n\n    return stations_df.loc[haversine_distance(stations_df.latitude, stations_df.longitude, lat_point, lon_point)<=distance]\n```", "```py\nfilter_dataset_from_source_point(stations_df, lat_point = 49.131, lon_point = 2.521, distance = 5)\n```", "```py\ndef filter_dataset_by_gas_type(sub_station_df, gas_types_df, gas_type):\n\n    joined_df = sub_station_df.set_index(\"station_id\") \\\n          .join(\n              gas_types_df.set_index(\"station_id\"), how = 'left'\n          )\n    return joined_df.loc[joined_df.nom==gas_type]\n\nfilter_dataset_by_gas_type(sub_station_df, gas_types_df, \"SP98\").dropna(axis=1)\n```", "```py\nurl = f\"https://geo.api.gouv.fr/communes?fields=codesPostaux,nom,centre\"\nreq = requests.get(url).json()\n\n#We need to unpack the json via a loop as we want duplicated lines for each postal code\ncity_data = []\nfor elmt in req:\n    for code_postal in elmt['codesPostaux']:\n        city = {}\n        city[\"postal_code\"] = code_postal\n        city[\"name\"] = elmt['nom']\n        city[\"lat\"] = elmt['centre']['coordinates'][1]\n        city[\"lon\"] = elmt['centre']['coordinates'][0]\n        city_data.append(city)\n\ncities_df = pd.DataFrame(city_data)\n```", "```py\nfrom builtins import ValueError\n\ndef get_close_gas_prices(postal_code, distance_km, gas_type):\n\n    global cities_df\n    global stations_df\n    global gas_types_df\n\n    sub_cities = cities_df.loc[cities_df.postal_code==postal_code]\n\n    #If the postal code is not value, raise a value error\n    if len(sub_cities)==0:\n        raise BadInputError(\"Postal code is not a valid code\")\n\n    lat_point, lon_point = sub_cities.iloc[0][[\"lat\",\"lon\"]]\n    sub_station_df = filter_dataset_from_source_point(stations_df, lat_point, lon_point, distance_km)\n    return filter_dataset_by_gas_type(sub_station_df, gas_types_df, gas_type)[[\"latitude\" ,\"longitude\" ,\"cp\" ,\"city\",\"nom\", \"valeur\"]]\n```", "```py\nget_close_gas_prices(postal_code='60560', distance_km=5, gas_type='SP98')\n```", "```py\nfrom builtins import Exception\n\nclass BadInputError(Exception):\n    def __init__(self, message):\n        self.message = message\n```", "```py\nimport plotly.graph_objects as go\n\n#I hardcode my lat/lon for now, we integrate this in a proper class later\nlat,lon = cities_df.loc[cities_df.postal_code=='60560'][[\"lat\",\"lon\"]].iloc[0]\n\nstations = go.Scattermapbox(\n    lat= station_df.latitude,\n    lon= station_df.longitude,\n    mode='markers',\n    marker = dict(\n        size = 14,\n        symbol = 'fuel',\n    ),\n    showlegend = False\n)\n\n#create the layout\nlayout = go.Layout(\n    height = 700,\n    width = 700,\n    mapbox = dict(\n        accesstoken = token,\n        style ='streets',\n        center = dict(\n            lat = lat,\n            lon = lon\n        ),\n        zoom = 10,\n    ),\n)\n\nfig = go.FigureWidget(data=[stations], layout=layout)\nfig.show()\n```", "```py\nprices = go.Scattermapbox(\n    lat = station_df.latitude,\n    lon = station_df.longitude,\n    mode ='markers',\n    marker = dict(\n        size = 30,\n        color = station_df.valeur.astype(float),\n        colorscale = 'PiYG_r'\n    ),\n    opacity = 0.5,\n    text = station_df.valeur+' €/L',\n    showlegend = False\n)\n\n#This is a bit hacky, but it allows us to add a solid border around the circle\nsolid_price_border = go.Scattermapbox(\n    lat= station_df.latitude,\n    lon= station_df.longitude,\n    mode='markers',\n    marker=dict(\n        size=45,\n        color='black',\n    ),\n    opacity = 0.8,\n    text=station_df.valeur+' €/L',\n    showlegend = False,\n)\n```", "```py\ndef points_on_circle(lat, lon, radius, num_points):\n    '''This function return a list of coordinates as lat/lon of size num_points forming a circle of a certain radius centered on a \n       a point of coordinate lat,lon. Thanks internet :)\n    '''\n    points = []\n    R = 6371\n    for i in range(num_points):\n        bearing = 360/num_points*i\n        lat2 = np.arcsin(np.sin(np.radians(lat))*np.cos(radius/R) +\n                    np.cos(np.radians(lat))*np.sin(radius/R)*np.cos(np.radians(bearing)))\n        lon2 = np.radians(lon) + np.arctan2(np.sin(np.radians(bearing))*np.sin(radius/R)*np.cos(np.radians(lat)),\n                                   np.cos(radius/R)-np.sin(np.radians(lat))*np.sin(lat2))\n        points.append((np.degrees(lat2), np.degrees(lon2)))\n    points = np.array(points)\n    points = np.vstack([points, points[0]])\n\n    return points[:,0], points[:,1] \n```", "```py\ncircle_lats, circle_longs = points_on_circle(lat,lon, 5, 50)\n\nresearch_zone = go.Scattermapbox(\n    lat= circle_lats,\n    lon= circle_longs,\n    mode='lines',\n    fill='toself',\n    fillcolor = \"rgba(1,1,1,0.2)\",\n    marker=dict(\n        size=45,\n        color='black',\n    ),\n    opacity = 0.8,\n    showlegend = False,\n)\n```", "```py\nURL = f'https://donnees.roulez-eco.fr/opendata/instantane'\nCITY_PATH = 'cities_coordinates.csv'\nINIT_POST_CODE = '75001'\nINIT_FUEL = 'SP98'\nINIT_DIST = 3\n\nimport plotly.graph_objects as go\n\nclass FuelWidget:\n\n    def __init__(self):\n        '''We initiate the instance of our class with the functions we saw so far\n           1\\. We download the latest data from the stations price and gen our 2 dataframe\n           2\\. We load the postal code -> lat/lon .csv \n           3\\. We filter the dataset based on initial values\n           4\\. We initiate the layout with the figure we saw before and some UI components\n        '''\n\n        self._distance = INIT_DIST\n        self._fuel = INIT_FUEL\n        self._post_code = INIT_POST_CODE\n\n        #Load the stations data\n        z = load_from_url_in_memory(URL)\n        self._stations_df , self._gas_types_df = parse_xml(z)\n\n        #Load the cities data\n        self._cities_df = pd.read_csv(CITY_PATH, index_col=0, dtype={\"postal_code\":str})\n\n        #Filter the dataset with the initial constants\n        self._filter_by_postal_code(self._post_code, self._distance, self._fuel)\n\n        #Initialise the layout\n        self._init_layout()\n\n    def _init_layout(self):\n        '''This function initiate the widget layout and the different callbacks'''\n        #Select fuel dropdown\n        fuel_type_dropdown = Dropdown(options  = self._gas_types_df.nom.unique(), \n                                      value = INIT_FUEL, \n                                      description = \"Fuel type\")\n        fuel_type_dropdown.observe(self._on_fuel_change, names='value')\n\n        #Select max distance dropdown\n        distance_dropdrown = Dropdown(options  = [*range(1,30)], \n                                      value = INIT_DIST, \n                                      description = \"distance (km)\")\n        distance_dropdrown.observe(self._on_distance, names='value')\n\n        #Select postal code from text\n        postal_code_text= Text(placeholder=\"Postal Code\")\n        postal_code_text.observe(self._on_change_text, names='value')\n\n        #Create the figure based on initial value\n        self._fig = init_chart(self._sub_station_with_prices, \n                               self._lat_pos, \n                               self._lon_pos, \n                               self._distance)\n\n        #Create the widget \n        self._widget = VBox([postal_code_text,\n                            HBox([fuel_type_dropdown, \n                                  distance_dropdrown]), \n                            self._fig])\n```", "```py\n def _on_distance(self, change):\n        '''This callback is called when the distance dropdown change, refilter the dataset,\n           and update the figure\n        '''\n        self._distance = change[\"new\"]\n        done = self._filter_by_postal_code(self._post_code, self._distance, self._fuel)\n        if done:\n            self._update_fig()\n```", "```py\ndef _update_fig(self):\n    #Initialize a new figure\n    new_fig = init_chart(self._sub_station_with_prices, self._lat_pos, self._lon_pos, self._distance)\n    with self._fig.batch_update():\n        #Update all the lat longs for our 5 traces\n        for k in range(5):\n            self._fig.data[k].lat = new_fig.data[k].lat\n            self._fig.data[k].lon = new_fig.data[k].lon\n\n        #Update the color markers of the prices\n        self._fig.data[2].marker = new_fig.data[2].marker\n\n        #Update the overlayed text\n        for k in [1,2,3]:\n            self._fig.data[k].text = new_fig.data[k].text\n\n        #Update the new center of the map\n        center = {\"lat\":self._lat_pos, \"lon\":self._lon_pos}\n        self._fig.layout.mapbox.center = center \n```", "```py\ndef display(self):\n    display(self._widget)\n```"]