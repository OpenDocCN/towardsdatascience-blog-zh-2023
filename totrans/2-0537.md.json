["```py\n|Ingredient|Quantity (gr)| Purpose   | Price per Kilo (€) |\n|----------|-------------| -------   | ------------------ |\n|Apple     | 50          | crunch    | 3                  |\n|Orange    | 50          | juiciness | 4                  |\n|Banana    | 50          | creamy    | 3                  |\n|Raspberry | 50          | beautify  | 30                 |\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\ndef calculate_log_utility(weights):\n    \"\"\"\n    Calculate the log utility for the given weights of the fruits.\n    :param weights: Dictionary containing the weights of each fruit.\n    :return: Sum of the logarithm of the weights of the fruits.\n    \"\"\"\n    return np.sum([np.log(weights[fruit]) for fruit in weights], axis=0)\n\ndef calculate_total_price(weights, prices):\n    \"\"\"\n    Calculate the total price per portion for the given weights and prices of the fruits.\n    :param weights: Dictionary containing the weights of each fruit.\n    :param prices: Dictionary containing the prices of each fruit per kg.\n    :return: Total price per portion.\n    \"\"\"\n    return np.sum([weights[fruit] * prices[fruit] for fruit in weights], axis=0)\n\ndef calculate_lagrangian(weights, prices, lambda_value, budget):\n    \"\"\"\n    Calculate the Lagrangian for the given weights, prices, lambda, and budget.\n    :param weights: Dictionary containing the weights of each fruit.\n    :param prices: Dictionary containing the prices of each fruit per kg.\n    :param lambda_value: The value of the Lagrange multiplier.\n    :param budget: The budget per portion.\n    :return: Calculated Lagrangian value.\n    \"\"\"\n    log_utility = calculate_log_utility(weights)\n    total_price = calculate_total_price(weights, prices)\n    return log_utility - lambda_value * (total_price - budget)\n\n# Set the style of seaborn for better visualization\nsns.set(style=\"whitegrid\")\n\n# Define the random weights for each fruit in kg.\nweights = {\n    'apple': np.random.rand(1000) * 0.075 + 0.02, \n    'orange': np.random.rand(1000) * 0.075 + 0.02,\n    'banana': np.random.rand(1000) * 0.075 + 0.02,\n    'raspberry': np.random.rand(1000) * 0.075 + 0.0001,\n}\n\n# Define the prices for each fruit in euros per kg.\nprices = {\n    'apple': 3, 'orange': 4, 'banana': 3, 'raspberry': 30\n}\n\n# Define the optimum and original recipes in kg.\nrecipes = {\n    'optimum': {'apple': 1/12, 'orange': 1/16, 'banana': 1/12, 'raspberry': 1/120},\n    'original': {'apple': 0.05, 'orange': 0.05, 'banana': 0.05, 'raspberry': 0.05}\n}\n\n# Plot Log Utility Graph\nplt.figure(figsize=(10, 6))\nsns.scatterplot(x=calculate_total_price(weights, prices), \n                y=calculate_log_utility(weights), alpha=0.5, edgecolor=None)\nplt.scatter([calculate_total_price(recipes['optimum'], prices)], \n            [calculate_log_utility(recipes['optimum'])], color='red', label='Optimum Recipe')\nplt.scatter([calculate_total_price(recipes['original'], prices)], \n            [calculate_log_utility(recipes['original'])], color='orange', label='Original Recipe')\nplt.title('Log Utility as a Function of Price per Portion')\nplt.xlabel('Price per Portion (€)')\nplt.ylabel('Log Utility')\nplt.xlim(0.5, 3)\nplt.ylim(-16, -9)\nplt.legend(loc='upper left')\nplt.show()\n\n# Define lambda_value and budget for Lagrangian Graph\nlambda_value = 4  # Given value of lambda\nbudget = 1  # Given budget per portion\n\n# Plot Lagrangian Graph\nplt.figure(figsize=(10, 6))\nsns.scatterplot(x=calculate_total_price(weights, prices), \n                y=calculate_lagrangian(weights, prices, lambda_value, budget), alpha=0.5, edgecolor=None)\nplt.scatter([calculate_total_price(recipes['optimum'], prices)], \n            [calculate_lagrangian(recipes['optimum'], prices, lambda_value, budget)], color='red', label='Optimum Recipe')\nplt.scatter([calculate_total_price(recipes['original'], prices)], \n            [calculate_lagrangian(recipes['original'], prices, lambda_value, budget)], color='orange', label='Original Recipe')\nplt.title('Lagrangian as a Function of Price per Portion')\nplt.xlabel('Price per Portion (€)')\nplt.ylabel('Lagrangian')\nplt.xlim(0.5, 3)\nplt.ylim(-18, -12)\nplt.legend(loc='upper right')\nplt.show()\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport sympy as sp\n\n# Setting the style of seaborn for better visualization\nsns.set()\n\n# Amounts of each fruit\na, o, b, r = sp.symbols('a o b r', positive=True, real=True)  # Quantities of apples, oranges, bananas, and raspberries\n\n# Prices of each fruit per kilo\nP_a, P_o, P_b, P_r = sp.symbols('P_a P_o P_b P_r', positive=True, real=True)  # Prices for apples, oranges, bananas, and raspberries per kilo\n\n# Total price of the ingredients\nP = a*P_a + o*P_o + b*P_b + r*P_r\n\n# Budget\nB = sp.Symbol('B', positive=True, real=True)  # Budget for the fruit salad\n\n# Lagrange multiplier\nλ = sp.Symbol('λ', positive=True, real=True)  # Lagrange multiplier\n\n# Cobb-Douglas utility function in its logarithmic form\nU_log = sp.ln(a) + sp.ln(o) + sp.ln(b) + sp.ln(r)\n\n# The Lagrangian\nL = U_log - λ * (P - B)\n\n# Derive the first order conditions\nfoc_a = sp.diff(L, a)\nfoc_o = sp.diff(L, o)\nfoc_b = sp.diff(L, b)\nfoc_r = sp.diff(L, r)\nfoc_λ = sp.diff(L, λ)\n\n# Solve for λ and the optimized quantities of each ingredient\nsolution = sp.solve((foc_a, foc_o, foc_b, foc_r, foc_λ), (a, o, b, r, λ), dict=True)\n\nsolution\n```"]