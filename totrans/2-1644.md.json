["```py\nfrom sklearn.base import BaseEstimator\n\nclass Perceptron(BaseEstimator):\n    def __init__(self, alpha, n_epochs):\n        self.alpha = alpha        # the learning rate\n        self.n_epochs = n_epochs  # number of training iterations\n\n    def fit(self, X, y):\n        (n, m) = X.shape  # n is the number of samples, m is the number of features\n\n        # Initialize the weights to small random values\n        self.w = np.random.randn(m)\n        self.b = 0\n\n        # The training loop\n        for epoch in range(self.n_epochs):\n            n_errors = 0  # number of misclassification errors\n\n            for i in range(n):\n                o = self.predict(X[i])\n                if o != y[i]:\n                    # Apply the perceptron learning rule\n                    self.w += self.alpha * (y[i] - o) * X[i]\n                    self.b += self.alpha * (y[i] - o)\n                    n_errors += 1\n\n            # Compute the accuracy on the training set\n            accuracy = 1 - (n_errors / n)\n            print(f'Epoch {epoch + 1}: accuracy = {accuracy:.3f}')\n\n            # Stop the training when there are no more errors\n            if n_errors == 0:\n                break\n\n    def predict(self, X):\n        z = X @ self.w + self.b\n        return np.heaviside(z, 1)  # the step function\n```", "```py\ndef __init__(self, alpha, n_epochs):\n    self.alpha = alpha\n    self.n_epochs = n_epochs\n```", "```py\n(n, m) = X.shape\n```", "```py\nself.w = np.random.randn(m)\nself.b = 0\n```", "```py\nfor i in range(n):\n    o = self.predict(X[i])\n    if o != y[i]:\n```", "```py\nself.w += self.alpha * (y[i] - o) * X[i]\nself.b += self.alpha * (y[i] - o)\nn_errors += 1\n```", "```py\naccuracy = 1 - (n_errors / n)\nprint(f'Epoch {epoch + 1}: accuracy = {accuracy:.3f}')\n\nif n_errors == 0:\n    break\n```", "```py\nz = X @ self.w + self.b\n```", "```py\nreturn np.heaviside(z, 1)\n```", "```py\nfrom sklearn.datasets import make_blobs\n\nX, y = make_blobs(n_samples=100, n_features=2, centers=2, cluster_std=0.5)\n```", "```py\nimport seaborn as sns\n\nsns.scatterplot(x=X[:, 0], y=X[:, 1], hue=y, style=y, markers=('s', 'o'), \n                palette=('r', 'b'), edgecolor='black')\nplt.xlabel('$x_1$')\nplt.ylabel('$x_2$')\n```", "```py\nperceptron = Perceptron(alpha=0.01, n_epochs=10)\nperceptron.fit(X, y)\n```", "```py\nEpoch 1: accuracy = 0.250\nEpoch 2: accuracy = 0.950\nEpoch 3: accuracy = 1.000\n```", "```py\ndef plot_decision_boundary(model, X, y):\n    # Retrieve the model parameters\n    w1, w2, b = model.w[0], model.w[1], model.b\n\n    # Calculate the intercept and slope of the separating line\n    slope = -w1 / w2\n    intercept = -b / w2\n\n    # Plot the line\n    x1 = X[:, 0]\n    x2 = X[:, 1]\n    x1_min, x1_max = x1.min() - 0.2, x1.max() + 0.2\n    x2_min, x2_max = x2.min() - 0.5, x2.max() + 0.5\n    x1_d = np.array([x1_min, x1_max])\n    x2_d = slope * x1_d + intercept\n\n    # Fill the two classification areas with two different colors\n    plt.plot(x1_d, x2_d, 'k', ls='--')\n    plt.fill_between(x1_d, x2_d, x2_min, color='blue', alpha=0.25)\n    plt.fill_between(x1_d, x2_d, x2_max, color='red', alpha=0.25)\n    plt.xlim(x1_min, x1_max)\n    plt.ylim(x2_min, x2_max)\n\n    # Draw the data points\n    sns.scatterplot(x=x1, y=x2, hue=y, style=y, markers=('s', 'o'), \n                    palette=('r', 'b'), edgecolor='black')\n    plt.xlabel('$x_1$')\n    plt.ylabel('$x_2$')\n```", "```py\nplot_decision_boundary(perceptron, X, y)\n```"]