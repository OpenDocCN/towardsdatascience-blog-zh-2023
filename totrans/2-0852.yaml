- en: Explore Variants of Time Intelligence in DAX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/explore-variants-of-time-intelligence-in-dax-e795545e2a40](https://towardsdatascience.com/explore-variants-of-time-intelligence-in-dax-e795545e2a40)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*We have some valuable functions to calculate the previous year, YTC, etc.,
    in DAX. But other functions allow us to calculate the same result differently.
    Let’s explore our options and why they matter.*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@salvatorecagliari?source=post_page-----e795545e2a40--------------------------------)[![Salvatore
    Cagliari](../Images/a24b0cefab6e707cfee06cde9e857559.png)](https://medium.com/@salvatorecagliari?source=post_page-----e795545e2a40--------------------------------)[](https://towardsdatascience.com/?source=post_page-----e795545e2a40--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----e795545e2a40--------------------------------)
    [Salvatore Cagliari](https://medium.com/@salvatorecagliari?source=post_page-----e795545e2a40--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----e795545e2a40--------------------------------)
    ·11 min read·Nov 6, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/38219b1d3802a388882421def14b50bf.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Lukas Blazek](https://unsplash.com/@goumbik?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we look at the values in a report, we must give them meaning.
  prefs: []
  type: TYPE_NORMAL
- en: The most common way of doing this is by comparing them with the values of the
    previous period.
  prefs: []
  type: TYPE_NORMAL
- en: This is when Time Intelligence kicks in as one of the principal things we want
    to show in reports.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, look at the following report page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/66b511fd289c0defd973c77c592b45e8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1 — Example report (Figure by the Author)
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see the comparison of the Sales figures with the previous year,
    the Year-to-Date, and the rolling total values.
  prefs: []
  type: TYPE_NORMAL
- en: This is a typical report that makes extensive use of Time Intelligence logic.
  prefs: []
  type: TYPE_NORMAL
- en: Now, I will show you how to create the Measures to calculate these results and
    the variants using different DAX functions.
  prefs: []
  type: TYPE_NORMAL
- en: I will show the results only in tables for better readability.
  prefs: []
  type: TYPE_NORMAL
- en: Time Intelligence in DAX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have a large number of Time Intelligence functions in DAX. Looking at the
    [dax.guide](https://dax.guide/functions/time-intelligence/), we find a list of
    over 35 functions.
  prefs: []
  type: TYPE_NORMAL
- en: Some functions incorporate the complete logic for Time Intelligence, like [TOTALYTD()](https://dax.guide/totalytd/)
    or [SAMEPERIODLASTYEAR()](https://dax.guide/sameperiodlastyear/). Alternatively,
    we can use more fundamental functions that must be used in conjunction with [CALCULATE()](https://dax.guide/calculate/),
    like [DATEADD()](https://dax.guide/dateadd/) or [DATESBETWEEN()](https://dax.guide/datesbetween/).
  prefs: []
  type: TYPE_NORMAL
- en: I want to show you how to use the “easy to use” functions and then how to use
    the underlying functions to explore their benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we get different results depending on the used function, and sometimes,
    we can avoid problems by using the correct function.
  prefs: []
  type: TYPE_NORMAL
- en: In the conclusion, I will explain why it matters to know the different functions
    and your options to do the calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Date table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We must have a proper date table to use the Time Intelligence functions properly.
  prefs: []
  type: TYPE_NORMAL
- en: When I search Google for “Why do we need a date table in Power BI,” I get 149,000,000
    results. So, there is a lot of stuff out there to learn why we need it.
  prefs: []
  type: TYPE_NORMAL
- en: 'And one of my first articles here on Medium was about Date tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/3-ways-to-improve-your-reporting-with-an-expanded-date-table-2d983d76cced?source=post_page-----e795545e2a40--------------------------------)
    [## 3 Ways to Improve your reporting with an expanded date table'
  prefs: []
  type: TYPE_NORMAL
- en: Time is the most crucial reporting dimension. You can extend your reporting
    capabilities with a good date table.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/3-ways-to-improve-your-reporting-with-an-expanded-date-table-2d983d76cced?source=post_page-----e795545e2a40--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: To leave it short, I can do many cool things with a central date table.
  prefs: []
  type: TYPE_NORMAL
- en: For example, I can add columns with particular logic to the date table to facilitate
    my work in DAX and Power BI.
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of this article, I suppose you know why and how to build a date
    table and that you have marked this table as a “date table” in the Data model
    ([Set and use date tables in Power BI Desktop — Power BI | Microsoft Learn](https://learn.microsoft.com/en-us/power-bi/transform-model/desktop-date-tables)).
  prefs: []
  type: TYPE_NORMAL
- en: Year-to-Date (YTD)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I take the YTD function as a placeholder for the other two variants for Quarter-To-Date
    (QTD) and Month-To-Date (MTD).
  prefs: []
  type: TYPE_NORMAL
- en: YTD calculates the expression for all dates from the start of the year to the
    current date (of the current filter context).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the [TOTALYTD()](https://dax.guide/totalytd/) function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This function works flawlessly if the Date table is marked as “Date table” in
    the Data model.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t want to do this, this function doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the [DATESYTD()](https://dax.guide/datesytd/) function must be
    used in conjunction with the [ALL()](https://dax.guide/all/) function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Sidenote:** If you don’t want to set your date table as a “Date table” in
    your data model, you must add the ALL(‘Date’) filter in all Measures.'
  prefs: []
  type: TYPE_NORMAL
- en: I prefer using the form with CALCULATE() anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'As I always mark my date tables as “Date table”, I don’t need to add the ALL(‘Date’)
    filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Any of these three forms gives the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c62d115d09ff52bd271456f45d05effb.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2 — Result of YTD (Figure by the Author)
  prefs: []
  type: TYPE_NORMAL
- en: The form with CALCULATE() and DATESYTD() is more flexible and allows additional
    logic if necessary. And TOTALYTD() performs the same process as combining the
    former two functions.
  prefs: []
  type: TYPE_NORMAL
- en: I checked it in DAX Studio using the Server Timings, and the Execution Plans
    are identical.
  prefs: []
  type: TYPE_NORMAL
- en: Previous Year (PY)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get the value for the previous year, we can use the [SAMEPERIODLASTYEAR()](https://dax.guide/sameperiodlastyear/)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Like TOTALYTD(), this is an easy way to calculate the previous year’s value.
  prefs: []
  type: TYPE_NORMAL
- en: To understand what this function does, we can use [DATEADD()](https://dax.guide/dateadd/).
  prefs: []
  type: TYPE_NORMAL
- en: Previous Year — with DATEADD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The expression to calculate the previous year’s value with DATEADD() is the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In both cases, the result is the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c48723e461f757cc9ab5716187b95028.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3 — Result of both forms of PY (Figure by the Author)
  prefs: []
  type: TYPE_NORMAL
- en: Like with the YTD calculation, SAMEPERIODLASTYEAR() executes the same process
    as when we write it with DATEADD().
  prefs: []
  type: TYPE_NORMAL
- en: But what sets DATEADD() apart from SAMEPERIODLASTYEAR() is that I can define
    the period and the distance from which I want to get the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, I want to get the previous Quarter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Or do I want to get the previous Month:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And for the previous Semester, I can do it in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of these variants is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4d10274d166de24995e3e91cff820299.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4 — Result of the Measures using DATEADD() (Figure by the Author)
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s essential to understand that each of these Measures calculates the previous
    period (Year, Semester, Quarter, and Month, at each level of the Calendar hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/86b36ddcf5ac4b4d742bdd27e3030aaf.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5 — Result of the Measures at different levels (Figure by the Author)
  prefs: []
  type: TYPE_NORMAL
- en: For me, it’s intuitive that the results look like this, but I think it’s worth
    pointing out this detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'One important detail: DATEADD() can work with Days, Months, Quarters, and Years.
    This is why I need to go back six months or two quarters when I have to get the
    previous semester.'
  prefs: []
  type: TYPE_NORMAL
- en: And there is more to explore when we talk about Time Intelligence.
  prefs: []
  type: TYPE_NORMAL
- en: What’s about PARALLELPERIOD()?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The PARALLELPERIOD() function is very interesting.
  prefs: []
  type: TYPE_NORMAL
- en: I strongly recommend reading the description on [dax.guide](https://dax.guide/parallelperiod/)
    and watching the attached video.
  prefs: []
  type: TYPE_NORMAL
- en: In short, PARALLELPERIOD() expands the current Filter context on a Date to the
    entire period.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following Measure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: At first glance, it looks similar to a Measure that uses DATEADD() to go back
    3 Months.
  prefs: []
  type: TYPE_NORMAL
- en: 'But look at the Results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/df295d34a617ecd2f40253c3425477e4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6 — Result for PARALLELPERIOD() (Figure by the Author)
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the result for the Sales three months ago is the same even at
    the Day level.
  prefs: []
  type: TYPE_NORMAL
- en: Whereas, when using DATEADD(), the result at the Day level is the same as at
    the Month level, but for the previous period, as set in the Measure (for example,
    the previous quarter).
  prefs: []
  type: TYPE_NORMAL
- en: 'When I write another Measure, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5c1555c2c542e5b43f0de0fd235692ff.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7 — Result for PARALLELPERIOD for the quarter before the previous quarter
    (Figure by the Author)
  prefs: []
  type: TYPE_NORMAL
- en: As you might expect, the result is the same for the Days within each month.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, look at the description for this function. It might surprise
    you.
  prefs: []
  type: TYPE_NORMAL
- en: Sliding Window (Last three months)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last scenario to explore is the so-called “Sliding Window”.
  prefs: []
  type: TYPE_NORMAL
- en: This is when you want to calculate the sum of a defined time window.
  prefs: []
  type: TYPE_NORMAL
- en: For example, “Last three months” will calculate the sum of the last three months
    based on the actual date.
  prefs: []
  type: TYPE_NORMAL
- en: We use the [DATESINPERIOD()](https://dax.guide/datesinperiod/) and the [PARALLELPERIOD()](https://dax.guide/parallelperiod/)
    functions to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: But take care. These two functions work differently and give you different results.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at both and check the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'To calculate the result for the last three months using DATESINPERIOD(), we
    can write this Measure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5c14a05396bc3f95e923d3c082880bc1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8 — Result of last three months with DATESINPERIOD() (Figure by Author)
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the screenshot above, the sum for each month is the sum of
    the actual month plus the previous two months.
  prefs: []
  type: TYPE_NORMAL
- en: 'But take care: When we look at the single days, the result is slightly different:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ca2f9800604984996757ff837d969f5e.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9 — Result of last three months with DATESINPERIOD() for each day (Figure
    by Author)
  prefs: []
  type: TYPE_NORMAL
- en: This is because the Measure gets the last date for each row and uses it as the
    starting point to “travel” back for three months.
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, when we look at single days, the starting point is that specific
    day, not the entire month.
  prefs: []
  type: TYPE_NORMAL
- en: 'A variant to get the sum of the previous three months can be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This Measure returns the sum of Online Sales for the last three months starting
    from the first date of the selected period minus one day. So, the last day of
    the previous period.
  prefs: []
  type: TYPE_NORMAL
- en: I use the word “period”. But I should use the word “interval”, as, according
    to [dax.guide](https://dax.guide/), I can use DATESINPERIOD() with the interval
    of Day, Month, Quarter, and Year.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case below: The Sales for the three months before the current month.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7602989ab44fa23c2b6f60571e407f3b.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10 — Result for the last three months before the current period (Figure
    by the Author)
  prefs: []
  type: TYPE_NORMAL
- en: This Measure returns the same result as the first one when observing the results
    for the days.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following variant uses DATESBETWEEN():'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The function DATESBETWEEN() returns a list of Dates between the first and the
    second date (second and third parameter).
  prefs: []
  type: TYPE_NORMAL
- en: In this case, I use the [EOMONTH()](https://dax.guide/eomonth) function to calculate
    the first and the last day of the three-month windows
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is almost the same as with DATESINPERIOD():'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/58f2df566ccfadf3c1293d9c78d2410b.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11 — Result of “Last three months” by using DATESBETWEEN() (Figure by
    the Author)
  prefs: []
  type: TYPE_NORMAL
- en: 'But there are two significant differences between using DATESINPERIOD() and
    DATESBETWEN():'
  prefs: []
  type: TYPE_NORMAL
- en: The result is the same when using DATESBETWEEN(), even at the Day level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But the result is wrong at the level above the Month (Quarter, Semester, and
    Year).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This happens as the Measure gets the current period’s first and last date. At
    the levels above the Month, they are the dates based on the current level.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To solve the second issue, we can change the Measure to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/82235e6d2b14dec3ad93625aa0ee475d.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12 — Result of “Last three Months” with DATESBETWEEN — Second variant
    (Figure by the Author)
  prefs: []
  type: TYPE_NORMAL
- en: I marked the previous result, with the wrong results for the Years, Semesters,
    and Quarters in red and the new results in Blue.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you must decide which variant will best suit your needs, as the
    requirements might change from case to case.
  prefs: []
  type: TYPE_NORMAL
- en: Why do it differently
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, why should we consider the different methods of calculating Time Intelligence
    Results?
  prefs: []
  type: TYPE_NORMAL
- en: There are many reasons for doing it.
  prefs: []
  type: TYPE_NORMAL
- en: For example, to understand the effect of the different functions.
  prefs: []
  type: TYPE_NORMAL
- en: All these functions return a table with one column and a list of Dates. But
    the different functions build this table in slightly different ways.
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, now we are in a better position to fulfill the requirements for
    the reporting as we know more ways to provide the needed result.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, we can propose different solutions and challenge our Stakeholders
    to think about them and find the best solution for their needs.
  prefs: []
  type: TYPE_NORMAL
- en: The next reason is flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the two variants for YTD. While TOTALYTD() delivers the correct result,
    we are more flexible when using the second variant with CALCULATE() and DATESYTD()
    without losing anything in performance or efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: 'And now we are at the last reason in understanding the different variants for
    these Measures: Performance and efficiency.'
  prefs: []
  type: TYPE_NORMAL
- en: A specific calculation might work without problem in one scenario but could
    be slow in another.
  prefs: []
  type: TYPE_NORMAL
- en: So, knowing how to do it differently could be a lifesaver.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the different variants for “Last three Months” deliver different
    results while being very efficient. I analyzed all four variants, and the performance
    is very similar.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After exploring the different variants, we have a more extensive toolbox when
    calculating results involving Time Intelligence functions.
  prefs: []
  type: TYPE_NORMAL
- en: Given the many ways we can calculate a result and the many differences in our
    stakeholders’ understanding of the business logic, the larger the toolbox, the
    better.
  prefs: []
  type: TYPE_NORMAL
- en: But sometimes, we must take care of many details when elaborating a possible
    solution as “the devil lies in the detail” and we must consider how our users
    can use the Measures in their reports.
  prefs: []
  type: TYPE_NORMAL
- en: Here, I covered only a small number of Time Intelligence functions available
    in DAX. There are a lot more that cover specific requirements. I strongly recommend
    looking at dax.guide and exploring the possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, I learned some details while writing about this complex topic, and
    I hope you learn more about it.
  prefs: []
  type: TYPE_NORMAL
- en: Leave a comment if there is any topic you are interested in that I could cover
    in future articles.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2957753c8a17da4fa9247941534cbcc3.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Brett Jordan](https://unsplash.com/@brett_jordan?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The SQLBI article [Time Intelligence in Power BI Desktop](https://www.sqlbi.com/articles/time-intelligence-in-power-bi-desktop/)
    is a very useful source about this topic. You can find more information on working
    with Time Intelligence functions there.
  prefs: []
  type: TYPE_NORMAL
- en: 'I analyzed the performance with DAX Studio and the built-in Server Timings
    feature. To learn more about this feature, I recommend reading my article on this
    topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/how-to-get-performance-data-from-power-bi-with-dax-studio-b7f11b9dd9f9?source=post_page-----e795545e2a40--------------------------------)
    [## How to get performance data from Power BI with DAX Studio'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes we have a slow Report, and we need to figure out why. We will see
    how to collect performance data and the…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/how-to-get-performance-data-from-power-bi-with-dax-studio-b7f11b9dd9f9?source=post_page-----e795545e2a40--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: I use the Contoso sample dataset, like in my previous articles. You can download
    the ContosoRetailDW Dataset for free from Microsoft [here](https://www.microsoft.com/en-us/download/details.aspx?id=18279).
  prefs: []
  type: TYPE_NORMAL
- en: The Contoso Data can be freely used under the MIT License, as described [here](https://github.com/microsoft/Power-BI-Embedded-Contoso-Sales-Demo).
  prefs: []
  type: TYPE_NORMAL
- en: I enlarged the dataset to make the DAX engine work harder.
  prefs: []
  type: TYPE_NORMAL
- en: The Online Sales table contains 71 million rows (instead of 12.6 million rows),
    and the Retail Sales table contains 18.5 million rows (instead of 3.4 million
    rows).
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/@salvatorecagliari/subscribe?source=post_page-----e795545e2a40--------------------------------)
    [## Get an email whenever Salvatore Cagliari publishes.'
  prefs: []
  type: TYPE_NORMAL
- en: Get an email whenever Salvatore Cagliari publishes. By signing up, you will
    create a Medium account if you don't…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/@salvatorecagliari/subscribe?source=post_page-----e795545e2a40--------------------------------)
  prefs: []
  type: TYPE_NORMAL
