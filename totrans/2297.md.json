["```py\nimport folium\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport requests\nfrom scipy.stats import gaussian_kde\nimport seaborn as sns\nfrom shapely.geometry import Point, shape, box, Polygon\n```", "```py\n# Pull data\napi_endpoint = 'https://data.cityofnewyork.us/resource/qb5r-6dgf.json'\nlimit = 1000  # Number of rows per request\noffset = 0   # Starting offset\ndata_frames = []  # List to hold chunks of data\n\n# Loop to fetch data iteratively\n# while offset <= 100000: # uncomment this and comment while True to fetch a \n#   sample much faster\nwhile True: # while True will take a long time but gets all the data\n    url = f\"{api_endpoint}?$limit={limit}&$offset={offset}\"\n    chunk = pd.read_json(url)\n    if chunk.empty:\n        break  # Stop the loop when no more data is returned\n    data_frames.append(chunk)\n    offset += limit\n\n# Concatenate all chunks into a single DataFrame\ndata = pd.concat(data_frames, ignore_index=True)\n\n# Convert the 'the_geom' column from a dictionary to a Shapely geometry object\ndata['geometry'] = data['the_geom'].apply(lambda x: shape(x))\n\n# Convert the Pandas DataFrame to a GeoDataFrame\ngdf = gpd.GeoDataFrame(data, geometry='geometry', crs=\"EPSG:4326\")\n\n# Convert 'MultiPolygon' to representative points for visualization\ngdf['centroid'] = gdf['geometry'].centroid.to_crs(epsg=3395).centroid.to_crs(epsg=4326)\n\n# Get rid of columns we don't need anymore\nkeep_cols = ['cnstrct_yr', 'heightroof', 'geometry', 'centroid']\ngdf = gdf[keep_cols]\n```", "```py\n# Create the bounding box from the provided corner points\nbounding_box = box(-74.0294, 40.685, -73.91695, 40.742)\n\n# Filter the GeoDataFrame using the bounding polygon\ngdf = gdf[gdf['centroid'].within(bounding_box)]\n\n# Create a new column for building decade\ngdf['decade'] = (gdf['cnstrct_yr'] // 10) * 10\n\n# Remove rows where 'cnstrct_yr' is NaN\ngdf = gdf[gdf['cnstrct_yr'].notna()]\n\n# Get unique decades\nunique_decades = sorted(gdf['decade'].unique())\n\n# Use the Cividis colorscale and split it for our unique decades\ncolorscale = px.colors.sequential.Cividis\nnum_decades = len(unique_decades)\ncolors = [colorscale[i * len(colorscale) // num_decades] for i in range(num_decades)]\ncolor_map = dict(zip(unique_decades, colors))\n\n# Filter the data for buildings built in the 1930s and earlier\nold_buildings = gdf[gdf['decade'] <= 1930]\n\n# Create a new figure for better control\nfig = go.Figure()\n\n# Add the traces for each decade\nfor decade, color in color_map.items():\n    subset = gdf[gdf['decade'] == decade]\n    # Add the original trace with showlegend set to False\n    fig.add_trace(go.Scattermapbox(\n        lat=subset['centroid'].y,\n        lon=subset['centroid'].x,\n        mode='markers',\n        marker=go.scattermapbox.Marker(\n            size=3,\n            color=color,\n            opacity=0.8\n        ),\n        text=decade,\n        name=str(int(decade)),\n        hoverinfo='none',\n        showlegend=False\n    ))\n    # Add a dummy trace with larger markers for the legend\n    #   placed outside the visible map\n    fig.add_trace(go.Scattermapbox(\n        lat=[90],  # Latitude outside the visible map\n        lon=[0],   # Longitude outside the visible map\n        mode='markers',\n        marker=go.scattermapbox.Marker(\n            size=10,\n            color=color,\n            opacity=1\n        ),\n        legendgroup=str(int(decade)),\n        showlegend=True,\n        name=str(int(decade)),\n        hoverinfo='none'\n    ))\n\n# Add heatmap for older buildings\nfig.add_trace(go.Densitymapbox(\n    lat=old_buildings['centroid'].y,\n    lon=old_buildings['centroid'].x,\n    radius=4,\n    colorscale=\"Greens\",\n    opacity=1,\n    name=\"Density of Prewar Buildings\",\n    showlegend=True,\n    zmax=3,\n    zmin=0,\n    showscale=False\n))\n\nfig.update_layout(\n    title='Buildings by Decade with Density Underlay for Prewar Buildings',\n    autosize=True,\n    mapbox=dict(\n        accesstoken=None,\n        bearing=0,\n        center=dict(lat=40.71359, lon=-73.97216),\n        pitch=0,\n        zoom=12.6,\n        style='carto-positron'\n    ),\n    height=800,\n    width=1200,\n    legend=dict(tracegroupgap=0)\n)\n\n# Display the map\nfig.show()\n```", "```py\n# ...following from data pull code block\n\n# Define borough bounding boxes\n# These are very loose bounds and a more thorough analysis should use a higher\n#   precision polygon. \nboroughs = {\n    \"Manhattan\": box(-74.02, 40.70, -73.91, 40.88),\n    \"Bronx\": box(-73.93, 40.80, -73.79, 40.92),\n    \"Brooklyn\": box(-74.05, 40.57, -73.85, 40.74),\n    \"Queens\": box(-73.94, 40.54, -73.70, 40.80),\n    \"Staten Island\": box(-74.26, 40.50, -74.03, 40.65)\n}\n\n# Assign borough to each building based on its centroid\ndef assign_borough(centroid):\n    for borough, bbox in boroughs.items():\n        if bbox.contains(centroid):\n            return borough\n    return None\n\n# Assuming the gdf variable already contains your data\ngdf['borough'] = gdf['centroid'].apply(assign_borough)\n\n# Calculate building volume using footprint area and height\ngdf['volume'] = gdf['geometry'].area * gdf['heightroof']\n\n# Compute average volume by borough\navg_volume_by_borough = gdf.groupby('borough')['volume'].median()\n\n# Create 3D bar shapes using surface plots\ndef create_3d_bar(x, y, z, dx, dy, dz):\n    # Define vertices of the bar\n    x_data = [[x, x, x+dx, x+dx, x], [x, x, x+dx, x+dx, x]]\n    y_data = [[y, y+dy, y+dy, y, y], [y, y+dy, y+dy, y, y]]\n    z_data = [[z, z, z, z, z], [z+dz, z+dz, z+dz, z+dz, z+dz]]\n    return go.Surface(\n        x=x_data, \n        y=y_data, \n        z=z_data, \n        colorscale=[[0, 'blue'], [1, 'blue']], \n        showscale=False,\n        opacity=0.5\n    )\n\n# Define bar dimensions\ndx = 0.4\ndy = 0.4\n\n# Create figure\nfig = go.Figure()\n\n# Add bars to the figure\nfor i, borough in enumerate(avg_volume_by_borough.index):\n    fig.add_trace(create_3d_bar(i, 0, 0, dx, dy, avg_volume_by_borough[borough]))\n\n# Define the layout with adjusted aspect ratio for wider chart area\nfig.update_layout(\n    title='Average Building Volume by Borough',\n    scene=dict(\n        xaxis=dict(\n            title='Borough',\n            tickvals=list(range(len(avg_volume_by_borough))),\n            ticktext=avg_volume_by_borough.index\n        ),\n        yaxis=dict(title='', visible=False),\n        zaxis=dict(title='Average Building Volume (m^3)'),\n        aspectratio=dict(x=3, y=2, z=1.5)  # Adjusting the aspect ratio for wider x-axis\n    ),\n    margin=dict(t=40, b=40, l=60, r=60)\n)\n\nfig.show()\n```", "```py\n# Define the URL\nurl = \"https://data.cityofnewyork.us/resource/yjub-udmw.json\"\n\n# Send a GET request\nresponse = requests.get(url)\n\n# Load the response into a JSON\ndata = response.json()\n\n# Convert the JSON data into a DataFrame\ndf = pd.DataFrame(data)\n\n# Convert lat and lon columns to float\ndf['latitude'] = df['latitude'].astype(float)\ndf['longitude'] = df['longitude'].astype(float)\n\n# Map the borough codes to borough names\nborough_dict = {'1': 'Manhattan', '2': 'Bronx', '3': 'Brooklyn', '4': 'Queens', '5': 'Staten Island'}\ndf['borough'] = df['borough'].map(borough_dict)\n\n# Replace the 'token' with your own Mapbox access token\npx.set_mapbox_access_token('token')\n\nfig = px.density_mapbox(\n    df,\n    lat='latitude',\n    lon='longitude',\n    zoom=10,\n    mapbox_style=\"carto-positron\",\n    title=\"Distribution of WiFi Hotspots in NYC\",\n    radius=6\n)\n\nfig.update_layout(\n    height=800,\n    width=1200\n)\n\nfig.show()\n```", "```py\n# Pull data\ndata_url = 'https://data.cityofnewyork.us/api/views/vfnx-vebw/rows.csv?accessType=DOWNLOAD'\nsquirrels = pd.read_csv(\n    data_url,\n    usecols=['X', 'Y', 'Kuks', 'Quaas', 'Moans']\n)\n\n# Create column denoting that the squirrel made any kind of noise\nsquirrels['noisy'] = squirrels[['Kuks', 'Quaas', 'Moans']].any(axis=1)\n\n# Filter out the quiet squirrels\nnoisy_squirrels = squirrels[squirrels['noisy']]\n\n# Convert noisy column to integer\nnoisy_squirrels['noisy'] = noisy_squirrels['noisy'].astype(int)\n\n# Create the density heatmap\nfig = px.density_mapbox(\n    noisy_squirrels, lat='Y', lon='X', z='noisy', radius=50,\n    center=dict(lat=40.783, lon=-73.969),  # Center coordinates for Central Park\n    zoom=13,\n    mapbox_style=\"stamen-terrain\",\n    #mapbox_style=\"stamen-watercolor\",\n    color_continuous_scale=[\"white\", \"orange\", \"red\"],\n    range_color=[0, 5], # Adjusting the range for color scale\n)\n\n# Set the bearing to orient Central Park horizontally\nfig.update_layout(\n    mapbox_bearing=0,\n    height=700,\n    width=1000,\n    title='Density of Noisy Squirrel Observations',\n    showlegend=False,\n    coloraxis_showscale=False\n)\n\nfig.show()\n```"]