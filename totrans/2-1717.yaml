- en: 'Python: Computing Integrals the Right Way'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/python-computing-integrals-the-right-way-22e9257a5836](https://towardsdatascience.com/python-computing-integrals-the-right-way-22e9257a5836)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Muscle-up your integral game with python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://mocquin.medium.com/?source=post_page-----22e9257a5836--------------------------------)[![Yoann
    Mocquin](../Images/b30a0f70c56972aabd2bc0a74baa90bb.png)](https://mocquin.medium.com/?source=post_page-----22e9257a5836--------------------------------)[](https://towardsdatascience.com/?source=post_page-----22e9257a5836--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----22e9257a5836--------------------------------)
    [Yoann Mocquin](https://mocquin.medium.com/?source=post_page-----22e9257a5836--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----22e9257a5836--------------------------------)
    ·7 min read·Sep 3, 2023
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with scientific computing or physics problems, it is very common
    to compute the integral of some functions.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/da236dd8662c72933ed6e008ba4016e6.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Jeswin Thomas](https://unsplash.com/@jeswinthomas?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: 'In this short post, I want to demonstrate 3 ways you can compute the integral
    of a 1D function in python. We will split the approaches in 2 cases :'
  prefs: []
  type: TYPE_NORMAL
- en: '**First case: computing integral of a sampled function**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Second case: computing integral of a generic function**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**In the first case**, the function we want to integrate has already been sampled
    to some sample points, and we don’t have access to the underlying “true” function.
    For example, we don’t know the “formula” of that function, and we cannot sample
    any other point of that function. In other words, we only have arrays of x and
    corresponding y values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**In the second case**, we will consider that we have a function object, to
    which we can pass a sample point and it’ll return the value of that function at
    that point. This is the ideal approach because we have access to all the information
    of the function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we can always use the sampled approach: if we still have access to
    the function, we can choose sample points and use them to sample the function
    and use the first approach. **But as we will see, the choice of those sample points
    is precisely the important part to compute clean integrals.**'
  prefs: []
  type: TYPE_NORMAL
- en: Integral definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this first post, we will focus on a single variable function that returns
    another single value. The integral we want to compute is the standard definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a4e4a5f895402b793880d29655bf7629.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now our goal is to compute I as accurately as possible — within the limits
    of what we know of “f”. As an example, we’ll try to compute the following integral:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a2a06bce6df7f4339ed0f857defae860.png)'
  prefs: []
  type: TYPE_IMG
- en: Using basic math, you can show that the value of that integral is
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/cf82377d3143a7791a28c003ee8bee39.png)'
  prefs: []
  type: TYPE_IMG
- en: In this post, we’ll see different approaches to compute the integral, and see
    how close we are to the true value.
  prefs: []
  type: TYPE_NORMAL
- en: '**First approach: Integrate sampled functions**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s say we retrieve data from a sampled function, in the form of an X array
    and the corresponding values in a Y array. How would you compute the integral
    under that (X,Y) curve ?
  prefs: []
  type: TYPE_NORMAL
- en: 'As the function is already sampled, we are not dealing with a continuous signal
    but with a discrete signal. In other words, we don’t know “f”, we only know a
    sequence of values of f:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/551eb68b48885c30618e31d35379f1f2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Hence, it seems logical to transpose the integral formula using discrete notations,
    where the integral symbol turns into a discrete symbol, and ‘dx’ turns into the
    distance between each x samples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1fc00b15aebd24eed900d48cff17fac4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Seems logical, right ? Let’s see how that works for our example. To compute
    the differences of the xs, we’ll use numpy’s ***diff*** function. To simplify,
    we’ll use equally sampled xs with numpy’s ***linspace*** function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So only 0.3% error is pretty good, we should be able to improve the integral
    using more points right ?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Better, but still not perfect.
  prefs: []
  type: TYPE_NORMAL
- en: 'The error is due to boundaries effects: notice that we do not use the first
    value of y (y_0), and the distance between each x (x_i+1 — x_i) is multiplied
    by the value of f for x_i. [This approach is called the “rectangle” rule or “Riemann
    sum”](https://en.wikipedia.org/wiki/Riemann_sum), and corresponds to the following
    geometry:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c5d9b9985cbb19b4017b4e4122580165.png)'
  prefs: []
  type: TYPE_IMG
- en: (Right) rectangle rule, [image from public domain hosted on wikipedia](https://en.wikipedia.org/wiki/Riemann_sum#/media/File:RightRiemann2.svg)
  prefs: []
  type: TYPE_NORMAL
- en: It’s basically the simplest — and worst—approach to estimate an integral from
    sampled values.
  prefs: []
  type: TYPE_NORMAL
- en: 'To improve our approach a good step, we should use instead numpy’s [***trapz***](https://numpy.org/doc/stable/reference/generated/numpy.trapz.html)that
    is specifically designed to this problem: it uses [the trapezoidal rule](https://en.wikipedia.org/wiki/Trapezoidal_rule)
    to compute the integral from a vector X and vector Y. Basically, it computes the
    integral using the following geometry:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2d14d0c8c62321e4ee357cdf5806d076.png)'
  prefs: []
  type: TYPE_IMG
- en: '[Image from public domain, hosted on wikipedia](https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how it performs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: So about 1e-3% error! It is pretty good compared to .3% of the rectangle rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using more points (assuming we can have more, which is not always possible)
    we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: About 1e-5% error, starting to be pretty decent.
  prefs: []
  type: TYPE_NORMAL
- en: 'To improve even further, here’s what we can do:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Increase the number of sampled points** (if possible): as a general rule,
    increasing the number of points will always decrease the error, but in various
    proportions. In other words, increasing the number of samples improves the error
    down to a certain amount — it becomes less and less efficient. Note that this
    requires to still have “access” to the function — and if it is the case, you’d
    better use the second approach. Also, computing the values of f is sometimes time-consuming.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Make assumptions**: when using the rectangle or trapezoidal rules, we make
    the underlying assumption that the function is “constant” between each x-samples.
    If we “allow” it, we can make other assumptions, like the function behaves like
    a polynomial of a certain order, and use that information to compute the integral.
    Given the fact that we use the “sampled approach”, we usually don’t have access
    to more information about the true function, so making different assumptions (constant,
    polynomial), is not better that the other, it’s just different.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the end, both of these approaches require access and/or more knowledge on
    the true function. Which is why we’ll move on to the second approach!
  prefs: []
  type: TYPE_NORMAL
- en: 'Second approach: integrate continuous function'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this case, we still have access to the function f.
  prefs: []
  type: TYPE_NORMAL
- en: For cases like that, there are [a lot of possibilities to compute integrals](https://en.wikipedia.org/wiki/Numerical_integration).
    Trying to understand them, how they work, their pros and cons, is a good start
    to grasp the complexity of those problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Which is where [***scipy.integrate***](https://docs.scipy.org/doc/scipy/tutorial/integrate.html)
    comes into play: this module provides with lots of integration schemes, and the
    default settings will most of the time be quite enough.'
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we are going to use the [***quad***](https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.quad.html#scipy.integrate.quad)function,
    which is the general purpose integration function for 1-dimensional functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how it does for our problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Tada! Numerical-precision integration, right out of the box. So remember, rather
    than sampling the function f yourself, and using a trapezoid to compute the integral,
    let scipy do the hard work !
  prefs: []
  type: TYPE_NORMAL
- en: '*Scipy is truly filled with amazingly useful tools for many applications. Check
    its documentation once from time to time.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Wrap up**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So remember:'
  prefs: []
  type: TYPE_NORMAL
- en: '**if you only have X and Y vectors sampled from an unknown function f, use
    numpy’s *trapz*** to quickly and safely compute its integral using the trapezoidal
    rule. It’s probably the greatest compromise between complexity and accuracy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**if you have acces to f, use scipy’s *quad* function to compute the integral:**
    it’ll probably give you amazing results out of the box, and you can further customize
    the integration scheme with parameters if needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next post, I’ll show how to compute integral of complex-valued functions,
    so stay tuned!
  prefs: []
  type: TYPE_NORMAL
- en: '**If you’re considering joining Medium, use this link to quiclky subscribe
    and become one of my refered member** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/@mocquin/membership?source=post_page-----22e9257a5836--------------------------------)
    [## Join Medium with my referral link - Yoann Mocquin'
  prefs: []
  type: TYPE_NORMAL
- en: As a Medium member, a portion of your membership fee goes to writers you read,
    and you get full access to every story…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/@mocquin/membership?source=post_page-----22e9257a5836--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: '**and subscribe to get an notification when I publish new post:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://mocquin.medium.com/subscribe?source=post_page-----22e9257a5836--------------------------------)
    [## Get an email whenever I publish !'
  prefs: []
  type: TYPE_NORMAL
- en: Get an email whenever I publish ! New publication will include data transformation,
    advanced plotting and simulation…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: mocquin.medium.com](https://mocquin.medium.com/subscribe?source=post_page-----22e9257a5836--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 'Finaly, you can check out some of my other post, on Fourier transform or linear
    algebra techniques for datascience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/fourier-transform-for-time-series-detrending-f0f470f4bf14?source=post_page-----22e9257a5836--------------------------------)
    [## Fourier-transform for time-series : detrending'
  prefs: []
  type: TYPE_NORMAL
- en: Detrending your time-series might be a game-changer.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'towardsdatascience.com](/fourier-transform-for-time-series-detrending-f0f470f4bf14?source=post_page-----22e9257a5836--------------------------------)
    [](/pca-lda-ica-a-components-analysis-algorithms-comparison-c5762c4148ff?source=post_page-----22e9257a5836--------------------------------)
    [## PCA/LDA/ICA : a components analysis algorithms comparison'
  prefs: []
  type: TYPE_NORMAL
- en: Review the concepts and differences between these famous algorithms.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'towardsdatascience.com](/pca-lda-ica-a-components-analysis-algorithms-comparison-c5762c4148ff?source=post_page-----22e9257a5836--------------------------------)
    [](/pca-whitening-vs-zca-whitening-a-numpy-2d-visual-518b32033edf?source=post_page-----22e9257a5836--------------------------------)
    [## PCA-whitening vs ZCA-whitening : a numpy 2d visual'
  prefs: []
  type: TYPE_NORMAL
- en: The process of whitening data consists in a transformation such that the transformed
    data has identity matrix as…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/pca-whitening-vs-zca-whitening-a-numpy-2d-visual-518b32033edf?source=post_page-----22e9257a5836--------------------------------)
    [](/300-times-faster-resolution-of-finite-difference-method-using-numpy-de28cdade4e1?source=post_page-----22e9257a5836--------------------------------)
    [## 300-times faster resolution of Finite-Difference Method using numpy
  prefs: []
  type: TYPE_NORMAL
- en: Finite-difference method is a powerfull technique to solve complex problems,
    and numpy makes it fast !
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/300-times-faster-resolution-of-finite-difference-method-using-numpy-de28cdade4e1?source=post_page-----22e9257a5836--------------------------------)
  prefs: []
  type: TYPE_NORMAL
