- en: Nine Rules for Creating Fast, Safe, and Compatible Data Structures in Rust (Part
    1)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建快速、安全且兼容的数据结构的九条规则（第1部分）
- en: 原文：[https://towardsdatascience.com/nine-rules-for-creating-fast-safe-and-compatible-data-structures-in-rust-part-1-c0973092e0a3?source=collection_archive---------6-----------------------#2023-04-05](https://towardsdatascience.com/nine-rules-for-creating-fast-safe-and-compatible-data-structures-in-rust-part-1-c0973092e0a3?source=collection_archive---------6-----------------------#2023-04-05)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/nine-rules-for-creating-fast-safe-and-compatible-data-structures-in-rust-part-1-c0973092e0a3?source=collection_archive---------6-----------------------#2023-04-05](https://towardsdatascience.com/nine-rules-for-creating-fast-safe-and-compatible-data-structures-in-rust-part-1-c0973092e0a3?source=collection_archive---------6-----------------------#2023-04-05)
- en: Lessons from RangeSetBlaze
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 来自 RangeSetBlaze 的经验教训
- en: '[](https://medium.com/@carlmkadie?source=post_page-----c0973092e0a3--------------------------------)[![Carl
    M. Kadie](../Images/9dbe27c76e9567136e5a7dc587f1fb15.png)](https://medium.com/@carlmkadie?source=post_page-----c0973092e0a3--------------------------------)[](https://towardsdatascience.com/?source=post_page-----c0973092e0a3--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----c0973092e0a3--------------------------------)
    [Carl M. Kadie](https://medium.com/@carlmkadie?source=post_page-----c0973092e0a3--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@carlmkadie?source=post_page-----c0973092e0a3--------------------------------)[![Carl
    M. Kadie](../Images/9dbe27c76e9567136e5a7dc587f1fb15.png)](https://medium.com/@carlmkadie?source=post_page-----c0973092e0a3--------------------------------)[](https://towardsdatascience.com/?source=post_page-----c0973092e0a3--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----c0973092e0a3--------------------------------)
    [Carl M. Kadie](https://medium.com/@carlmkadie?source=post_page-----c0973092e0a3--------------------------------)'
- en: ·
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fa5e87027005f&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnine-rules-for-creating-fast-safe-and-compatible-data-structures-in-rust-part-1-c0973092e0a3&user=Carl+M.+Kadie&userId=a5e87027005f&source=post_page-a5e87027005f----c0973092e0a3---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----c0973092e0a3--------------------------------)
    ·13 min read·Apr 5, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fc0973092e0a3&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnine-rules-for-creating-fast-safe-and-compatible-data-structures-in-rust-part-1-c0973092e0a3&user=Carl+M.+Kadie&userId=a5e87027005f&source=-----c0973092e0a3---------------------clap_footer-----------)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[关注](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fa5e87027005f&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnine-rules-for-creating-fast-safe-and-compatible-data-structures-in-rust-part-1-c0973092e0a3&user=Carl+M.+Kadie&userId=a5e87027005f&source=post_page-a5e87027005f----c0973092e0a3---------------------post_header-----------)
    发表在 [Towards Data Science](https://towardsdatascience.com/?source=post_page-----c0973092e0a3--------------------------------)
    · 13 分钟阅读 · 2023年4月5日[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fc0973092e0a3&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnine-rules-for-creating-fast-safe-and-compatible-data-structures-in-rust-part-1-c0973092e0a3&user=Carl+M.+Kadie&userId=a5e87027005f&source=-----c0973092e0a3---------------------clap_footer-----------)'
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fc0973092e0a3&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnine-rules-for-creating-fast-safe-and-compatible-data-structures-in-rust-part-1-c0973092e0a3&source=-----c0973092e0a3---------------------bookmark_footer-----------)![](../Images/77adb3f2a102655781a270954799608d.png)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fc0973092e0a3&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnine-rules-for-creating-fast-safe-and-compatible-data-structures-in-rust-part-1-c0973092e0a3&source=-----c0973092e0a3---------------------bookmark_footer-----------)![](../Images/77adb3f2a102655781a270954799608d.png)'
- en: 'Storing numbers in a tree — Source: Stable Diffusion'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 将数字存储在树中 — 来源：Stable Diffusion
- en: 'This year, I developed a new Rust crate called `[range-set-blaze](https://crates.io/crates/range-set-blaze)`
    that implements the range set data structure. A range set is a useful (if obscure)
    data structure that stores sets of integers as sorted and disjoint ranges. For
    example, it stores these three ranges:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 今年，我开发了一个新的 Rust crate，名为 `[range-set-blaze](https://crates.io/crates/range-set-blaze)`，它实现了范围集合数据结构。范围集合是一种有用（虽然较少见）的数据结构，它将整数集合存储为已排序且不相交的范围。例如，它存储以下三个范围：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: rather than 30,220,996 individual integers. In addition to potential memory
    savings, `range-set-blaze` provides efficient set operations such as union, intersection,
    complement, difference, and symmetric difference.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是30220996个单独的整数。除了潜在的内存节省，`range-set-blaze`还提供了高效的集合操作，如并集、交集、补集、差集和对称差集。
- en: While creating `range-set-blaze`, I learned nine rules that can help you create
    data structures in Rust. Beyond data structures, many of the rules can help you
    improve the performance and compatibility of any Rust code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`range-set-blaze`时，我学到了九条规则，这些规则可以帮助你在Rust中创建数据结构。除了数据结构，这些规则中的许多还可以帮助你提高任何Rust代码的性能和兼容性。
- en: 'The rules are:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 规则如下：
- en: Plagiarize your API, documentation, and even code — from the standard library.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抄袭你的API、文档，甚至代码——从标准库中抄袭。
- en: Design constructors for ease-of-use, compatibility, and speed.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计构造函数以便于使用、兼容性和速度。
- en: Create more Rust iterators than you expect.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建比预期更多的Rust迭代器。
- en: Make illegal values unrepresentable with traits.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用traits使非法值不可表示。
- en: Define generic iterators with guaranteed properties and useful methods.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义具有保证属性和有用方法的通用迭代器。
- en: '*Covered in* [*Part 2*](/nine-rules-for-creating-fast-safe-and-compatible-data-structures-in-rust-part-2-da5e6961a0b7)*:*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*在* [*第2部分*](/nine-rules-for-creating-fast-safe-and-compatible-data-structures-in-rust-part-2-da5e6961a0b7)*中讨论：*'
- en: '*6\. Define operators and fast operations.*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*6\. 定义运算符和快速操作。*'
- en: '*7\. Follow the “Nine Rules of Good API Design” especially “write good documentation”.*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*7\. 遵循“良好API设计的九条规则”，特别是“编写良好的文档”。*'
- en: '*8\. Optimize performance using representative data, Criterion Benchmarking,
    and profiling.*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*8\. 使用代表性数据、Criterion Benchmarking和性能分析来优化性能。*'
- en: '*9\. Test coverage, docs, traits, compiler errors, and correctness.*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*9\. 测试覆盖率、文档、traits、编译器错误和正确性。*'
- en: Before looking at the first five rules, let’s see when `range-set-blaze` might
    be useful, how its set operations work, and how it compares to other range set
    crates.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看前五条规则之前，让我们先看看`range-set-blaze`可能的使用场景，它的集合操作是如何工作的，以及它与其他范围集crate的比较。
- en: '**Usefulness:** Imagine running ten billion statistical experiments on an unreliable
    cluster. Each task on the cluster runs a few experiments. Each experiment produces
    one line of output with an experiment number. So, one task might put this into
    a file:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**有用性：** 想象一下在一个不可靠的集群上运行100亿个统计实验。集群上的每个任务运行几个实验。每个实验产生一行带有实验编号的输出。所以，一个任务可能会把这些放入一个文件中：'
- en: '![](../Images/39ad3c9b2cde703e0f3e8e37d1c985c9.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/39ad3c9b2cde703e0f3e8e37d1c985c9.png)'
- en: 'What data structure would you use to find which experiments are missing and
    need to be re-submitted? One option: store the outputted experiment numbers in
    a `[BTreeSet](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html)`
    and then do a linear scan for gaps.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你会使用什么数据结构来查找哪些实验缺失并需要重新提交？一个选项是：将输出的实验编号存储在一个`[BTreeSet](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html)`中，然后进行线性扫描以查找间隙。
- en: 'A faster and more memory-efficient option: use a range set. Eight years ago,
    I created `[IntRangeSet](https://fastlmm.github.io/PySnpTools/#util-intrangeset)`,
    a range set in Python to solve this problem. Now, I would use `range-set-blaze`
    in Rust ([example code](https://github.com/CarlKCarlK/range-set-blaze/blob/main/examples/missing.rs)).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 更快且内存效率更高的选项：使用范围集。八年前，我创建了`[IntRangeSet](https://fastlmm.github.io/PySnpTools/#util-intrangeset)`，一个用Python编写的范围集来解决这个问题。现在，我会在Rust中使用`range-set-blaze`（[示例代码](https://github.com/CarlKCarlK/range-set-blaze/blob/main/examples/missing.rs)）。
- en: '**Set Operations**: Here is a simple example of the union operator (`|`):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**集合操作**：这是一个简单的并集运算符（`|`）示例：'
- en: '![](../Images/c39d2fc449a075e26bc091e3cdf11e5e.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c39d2fc449a075e26bc091e3cdf11e5e.png)'
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Aside: See the project’s `[README.md](https://github.com/CarlKCarlK/range-set-blaze)`
    for another set operator example from biology. That example uses the `RangeSetBlaze`
    struct to find the intron regions of a gene from the transcription region and
    the exon regions.'
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附注：请参阅项目的`[README.md](https://github.com/CarlKCarlK/range-set-blaze)`以获取来自生物学的另一个集合运算符示例。该示例使用`RangeSetBlaze`结构体从转录区域和外显子区域中查找基因的内含子区域。
- en: '**Comparison with other range-related crates**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**与其他范围相关的crate的比较**'
- en: '**Benefits:** Although [Rust’s crates.io already contains several range set
    crates](https://github.com/CarlKCarlK/range-set-blaze/blob/main/docs/bench.md),
    I hoped my version could offer full set operations while being performant. Through
    optimizations both fowl and fair, I believe it achieves these goals (see [the
    benchmark report](https://github.com/CarlKCarlK/range-set-blaze/blob/main/docs/bench.md)).
    For example, it can intake individual integers 75 times faster than the most popular
    range set crate (because the other crate doesn’t special-case individual intake
    — but it could easily add this optimization). On another benchmark, `range-set-blaze`
    — using a hybrid algorithm — is 30% to 600% faster at unioning two sets.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**好处：** 尽管 [Rust 的 crates.io 已经包含了几个范围集合的 crate](https://github.com/CarlKCarlK/range-set-blaze/blob/main/docs/bench.md)，我希望我的版本能提供完整的集合操作，同时保持性能。通过各种优化措施，我相信它达到了这些目标（请参见
    [基准报告](https://github.com/CarlKCarlK/range-set-blaze/blob/main/docs/bench.md)）。例如，它可以比最流行的范围集合
    crate 快 75 倍来处理单个整数（因为其他 crate 没有对单个处理做特殊优化——但它可以轻松添加这种优化）。在另一个基准测试中，`range-set-blaze`——使用混合算法——在合并两个集合时比其他
    crate 快 30% 到 600%。'
- en: '**Deficits:** Compared to other range-related crates, `range-set-blaze` has
    two important deficits. First, it works only with Rust integer types. Most other
    crates handle any element that can be sorted (dates, floats, IP addresses, strings,
    etc.). Second, it only offers sets. Many other crates also handle mappings. With
    interest (and perhaps help) these deficits might be addressed in the future.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**不足：** 与其他范围相关的 crate 相比，`range-set-blaze` 有两个重要不足。首先，它仅适用于 Rust 整数类型。大多数其他
    crate 处理任何可以排序的元素（日期、浮点数、IP 地址、字符串等）。其次，它仅提供集合功能。许多其他 crate 还处理映射。随着兴趣（以及可能的帮助），这些不足可能会在未来得到解决。'
- en: Creating a data structure requires many decisions. Based on my experience with
    `range-set-blaze`, here are the decisions I recommend. To avoid wishy-washiness,
    I’ll express these recommendations as rules. Of course, every data structure is
    different, so not every rule will apply to every data structure.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数据结构需要做出许多决策。根据我在 `range-set-blaze` 上的经验，以下是我推荐的决策。为了避免优柔寡断，我将这些建议表述为规则。当然，每个数据结构都不同，因此并非每条规则都适用于每个数据结构。
- en: This article covers rules 1 to 5\. [Part 2](/nine-rules-for-creating-fast-safe-and-compatible-data-structures-in-rust-part-2-da5e6961a0b7)
    covers rules 6 to 9.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 本文涵盖规则 1 到 5。[第 2 部分](/nine-rules-for-creating-fast-safe-and-compatible-data-structures-in-rust-part-2-da5e6961a0b7)
    涵盖规则 6 到 9。
- en: 'Rule 1: Plagiarize the API, Documentation, and even Code — from the Standard
    Library'
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 1：抄袭 API、文档甚至代码——来自标准库
- en: Find a similar data structure in the standard library and study its documentation
    line-by-line. I picked `[BTreeSet](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html)`
    as my model. It can store sets of integers in a cache-efficient balanced tree.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 查找标准库中的类似数据结构，并逐行研究其文档。我选择了 [`BTreeSet`](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html)
    作为我的模型。它可以在缓存高效的平衡树中存储整数集合。
- en: 'Aside: Later, in benchmarking (Rule 8), we’ll see that `range_set_blaze::*RangeSetBlaze*`
    can be 1000’s of times faster than `*BTreeSet*` on some ‘clumpy’ integer sets.'
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附带说明：稍后，在基准测试（规则 8）中，我们将看到 `range_set_blaze::*RangeSetBlaze*` 在某些“块状”整数集合上的速度可能比
    `*BTreeSet*` 快 1000 倍。
- en: '`BTreeSet` offers 28 methods, for example, `[clear](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html#method.clear)`
    and `[is_subset](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html#method.is_subset)`.
    It also implements 18 traits, for example, `[FromIterator<T>](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html#impl-FromIterator%3CT%3E-for-BTreeSet%3CT%2C%20Global%3E)`.
    Here is the `BTreeSet` documentation for `clear` and the `RangeSetBlaze` documentation
    for `clear`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`BTreeSet` 提供了 28 个方法，例如，[`clear`](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html#method.clear)
    和 [`is_subset`](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html#method.is_subset)。它还实现了
    18 个特性，例如，[`FromIterator<T>`](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html#impl-FromIterator%3CT%3E-for-BTreeSet%3CT%2C%20Global%3E)。这是
    `BTreeSet` 的 `clear` 文档和 `RangeSetBlaze` 的 `clear` 文档：'
- en: '![](../Images/7852ec97e3809279c5dfd01079f1fe04.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7852ec97e3809279c5dfd01079f1fe04.png)'
- en: 'You can see that I mostly just copied. I changed “elements” to “integer elements”
    to remind users what `RangeSetBlaze` supports. I removed `where A: Clone` because
    all integers are necessarily cloneable. Notice that Rust documentation includes
    a “source” link. This makes copying easy.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到我主要是直接复制的。我将“元素”改为“整数元素”，以提醒用户 `RangeSetBlaze` 支持什么。我删除了 `where A: Clone`，因为所有整数必然是可克隆的。注意，Rust
    文档包括一个“源”链接，这使得复制变得容易。'
- en: 'Copying offers these advantages:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 复制提供了这些优点：
- en: It tells you what methods to provide. In other words, it gives you a starting
    point for your API (application programming interface). This saves design time.
    Moreover, users will understand and expect these methods. You may even be able
    to make your data structure a drop-in replacement for a standard data structure.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它告诉你需要提供哪些方法。换句话说，它为你的 API（应用程序编程接口）提供了一个起点。这节省了设计时间。此外，用户会理解并期望这些方法。你甚至可以使你的数据结构成为标准数据结构的直接替代品。
- en: You get documentation text and documentation tests for almost free.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几乎可以免费获得文档文本和文档测试。
- en: 'You may even be able to copy code. For example, here is the code for `is_superset`
    for `BTreeSet` and, then, `RangeSetBlaze` :'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你甚至可以复制代码。例如，这里是 `BTreeSet` 和 `RangeSetBlaze` 的 `is_superset` 代码：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `BTreeSet` code reminded me that superset can be defined in terms of subset
    and that `#[must use]` is a thing and appropriate here.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`BTreeSet` 代码让我想起了超集可以通过子集来定义，以及 `#[must_use]` 是一个存在且在这里适用的特性。'
- en: You may *decide* not to support everything in the standard data structure. For
    example, I skipped `new_in`, an experimental feature. Likewise, the standard library
    supports maps (not just sets), any sortable element (not just integers), and Serde
    serialization. For me, these are possible future features.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能 *决定* 不支持标准数据结构中的所有功能。例如，我跳过了 `new_in`，这是一个实验性特性。同样，标准库支持映射（不仅仅是集合）、任何可排序的元素（不仅仅是整数）和
    Serde 序列化。对我而言，这些是可能的未来特性。
- en: You may also *decide* to support something differently. For example, `BTreeSet::first`
    returns an `Option<&T>` but `RangeSetBlaze::first` returns an `Option<T>`. I know
    `T` is a cheap-to-clone integer and so it doesn’t need to be a reference.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以 *决定* 以不同的方式支持某些内容。例如，`BTreeSet::first` 返回 `Option<&T>` 但 `RangeSetBlaze::first`
    返回 `Option<T>`。我知道 `T` 是一个便于克隆的整数，所以不需要是一个引用。
- en: 'Aside: Doesn’t Rust have a generic `*Set*` trait, that tells what methods all
    sets should implement and even provides some default implementations (for example,
    `*is_superset*` in terms of `*is_subset*`?) No, but it is being [discussed](https://www.reddit.com/r/rust/comments/ypuf8f/generic_mapset_traits/).'
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 顺便提一下：Rust 没有一个通用的 `*Set*` 特性来告诉所有集合应该实现哪些方法，甚至提供一些默认实现（例如，`*is_superset*` 以
    `*is_subset*` 作为基础）吗？没有，但这个问题正在被 [讨论](https://www.reddit.com/r/rust/comments/ypuf8f/generic_mapset_traits/)。
- en: You will likely also *decide* to support more methods than the standard data
    structure. For example, `RangeSetBlaze::len`, like `BTreeSet::len`, returns the
    number of elements in the set. However, `RangeSetBlaze` also offers `ranges_len`,
    which returns the number of sorted, disjoint ranges in the set.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可能 *决定* 支持比标准数据结构更多的方法。例如，`RangeSetBlaze::len` 和 `BTreeSet::len` 一样，返回集合中的元素数量。然而，`RangeSetBlaze`
    还提供 `ranges_len`，它返回集合中排序的、不相交的范围的数量。
- en: 'Rule 2: Design Constructors for Ease-of-Use, Compatibility, and Speed'
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 2：设计构造函数以提高易用性、兼容性和速度
- en: If it makes sense to have an empty version of your data structure, you’ll want
    to define a `new` method and a `[Default::default](https://doc.rust-lang.org/std/default/trait.Default.html)`
    method.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个空版本的数据结构是有意义的，你会想定义一个 `new` 方法和一个 `[Default::default](https://doc.rust-lang.org/std/default/trait.Default.html)`
    方法。
- en: 'Similarly, if it makes sense to fill your data structure from an iterator,
    you’ll want to define `[FromIterator::from_iter](https://doc.rust-lang.org/std/iter/trait.FromIterator.html)`
    methods. These automatically define `collect` methods, too. Like `BTreeSet`, `RangeSetBlaze`
    accepts iterators of integers and references to integers. (Accepting references
    is important because many Rust iterators provide references.) Here is an example
    of `from_iter` and `collect` in use:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果从迭代器填充数据结构是有意义的，你会想定义 `[FromIterator::from_iter](https://doc.rust-lang.org/std/iter/trait.FromIterator.html)`
    方法。这些方法也会自动定义 `collect` 方法。像 `BTreeSet` 一样，`RangeSetBlaze` 接受整数的迭代器和对整数的引用。（接受引用很重要，因为许多
    Rust 迭代器提供引用。）以下是 `from_iter` 和 `collect` 使用的示例：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`RangeSetBlaze` also accepts iterators of inclusive ranges and references to
    such ranges. It places no constraints on the input ranges. They can be out-of-order,
    overlapping, empty, or repeated.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`RangeSetBlaze` 也接受包含范围的迭代器以及对这些范围的引用。它对输入范围没有限制。这些范围可以是无序的、重叠的、空的或重复的。'
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Finally, consider defining additional `From::from` methods. These automatically
    define an `into` methods. For example, for compatibility with `BTreeSet`, `RangeSetBlaze`
    defines a `From::from` method on arrays.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，考虑定义额外的 `From::from` 方法。这些方法会自动定义 `into` 方法。例如，为了兼容 `BTreeSet`，`RangeSetBlaze`
    在数组上定义了一个 `From::from` 方法。
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`RangeSetBlaze` also defines `from_sorted_disjoint/into_range_set_blaze` for
    iterators of ranges that are guaranteed to be sorted and disjoint. (We’ll see
    in Rule 5, how we enforce this guarantee with special traits and the Rust compiler.)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`RangeSetBlaze`还定义了`from_sorted_disjoint/into_range_set_blaze`，用于保证已排序且不相交的区间的迭代器。（我们将在规则5中看到，如何通过特殊特性和Rust编译器来强制执行这一保证。）'
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Aside: Why `*from_sorted_disjoint*`/`*into_range_set_blaze*` instead of `*from_iter
    /collect*` or `*from/into*`? See [this discussion](https://stackoverflow.com/questions/75522966/construct-a-struct-that-holds-a-generic-iterator-of-i32-from-from-iter)
    and [this discussion](https://stackoverflow.com/questions/37347311/how-is-there-a-conflicting-implementation-of-from-when-using-a-generic-type).'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附言：为什么使用`*from_sorted_disjoint*`/`*into_range_set_blaze*`而不是`*from_iter /collect*`或`*from/into*`？请参见[这个讨论](https://stackoverflow.com/questions/75522966/construct-a-struct-that-holds-a-generic-iterator-of-i32-from-from-iter)和[这个讨论](https://stackoverflow.com/questions/37347311/how-is-there-a-conflicting-implementation-of-from-when-using-a-generic-type)。
- en: 'For each of your constructors, think about possible speed ups and optimizations.
    `RangeSetBlaze` implements this optimization in `from_iter`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的每一个构造函数，考虑可能的加速和优化。`RangeSetBlaze`在`from_iter`中实现了这种优化：
- en: collects adjacent (possibly unsorted) integers/ranges into disjoint ranges,
    O(*n₁*)
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将相邻（可能无序）整数/区间合并成不相交的区间，O(*n₁*)
- en: sort the disjoint ranges by their start, O(*n₂* log *n₂*)
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按起始位置对不相交的区间进行排序，O(*n₂* log *n₂*)
- en: merge adjacent ranges, O(*n₂*)
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并相邻的区间，O(*n₂*)
- en: create a `BTreeMap` from the now sorted & disjoint ranges, O(*n₃* log *n₃*)
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从现在排序且不相交的区间创建一个`BTreeMap`，O(*n₃* log *n₃*)
- en: where *n*₁ is the number of input integers/ranges, n₂ is the number of disjoint
    & unsorted ranges, and *n*₃ is the final number of sorted & disjoint ranges.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *n*₁ 是输入整数/区间的数量，n₂ 是不相交且无序的区间数量，*n*₃ 是最终排序且不相交的区间数量。
- en: What is the effect of ‘clumpy’ integers? If *n₂* ≈ sqrt(*n₁*), then construction
    is O(*n₁*). (Indeed, as long as *n₂* ≤ *n₁*/ln(*n₁*), construction is O(*n₁*).)
    In benchmarks, this turns into a 700 time speed up over `HashSet` and `BTreeSet`
    on clumpy integer iterators.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: “块状”整数的影响是什么？如果 *n₂* ≈ sqrt(*n₁*)，则构建时间为O(*n₁*)。（实际上，只要 *n₂* ≤ *n₁*/ln(*n₁*)，构建时间为O(*n₁*)。）在基准测试中，这在块状整数迭代器上变成了比`HashSet`和`BTreeSet`快700倍。
- en: 'Rule 3: Create More Rust Iterators than You Expect'
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则3：创建比你预期的更多的Rust迭代器
- en: How many different iterator types would you guess the standard `BTreeSet` defines?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你猜测标准`BTreeSet`定义了多少种不同的迭代器类型？
- en: 'The answer is eight: `Iter`, `IntoIter`, `DrainFilter`, `Range`, `Difference`,
    `SymmetricDifference`, `Intersection`, and `Union`. Many non-Rust programming
    languages can turn any method into an iterator/generator, with a few “yield” statements.
    Rust, however, doesn’t offer this (but [it is under discussion](https://www.reddit.com/r/rust/comments/nsaovn/generatorsyield/)).
    So, pretty much every method related to iteration will require you to define a
    new iterator struct type. These structs will, at a minimum, implement a `next`
    method that returns either `Some(`value`)` or `None`.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是八种：`Iter`，`IntoIter`，`DrainFilter`，`Range`，`Difference`，`SymmetricDifference`，`Intersection`，和`Union`。许多非Rust编程语言可以将任何方法变成迭代器/生成器，只需几个“yield”语句。然而，Rust并不提供这种功能（但[正在讨论中](https://www.reddit.com/r/rust/comments/nsaovn/generatorsyield/)）。因此，几乎每个与迭代相关的方法都需要你定义一个新的迭代器结构类型。这些结构至少会实现一个`next`方法，该方法返回`Some(`值`)`或`None`。
- en: '`RangeSetBlaze` and its related types define 13 iterators structs. Let’s look
    at two of them.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`RangeSetBlaze`及其相关类型定义了13个迭代器结构。让我们看两个。'
- en: First, a user can call `ranges` and iterate through the integers as a sequence
    of sorted, disjoint ranges. (Recall that `RangeSetBlaze` accepts unsorted, overlapping
    ranges but stores sorted, disjoint ranges.)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，用户可以调用`ranges`并将整数作为一系列排序的不相交区间进行迭代。（请记住，`RangeSetBlaze`接受无序、重叠的区间，但存储排序的不相交区间。）
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Internally, `RangeSetBlaze` uses a standard `BTreeMap` to hold the range information.
    So, the `RangeSetBlaze::ranges` method constructs a `RangesIter` struct containing
    a `BTreeMap::Iter`. We then have the `RangesIter::next` method call `BTreeMap::Iter`''s
    `next` method and translates the result into the desired type. Here is the code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，`RangeSetBlaze`使用标准`BTreeMap`来存储区间信息。因此，`RangeSetBlaze::ranges`方法构造一个包含`BTreeMap::Iter`的`RangesIter`结构。然后我们让`RangesIter::next`方法调用`BTreeMap::Iter`的`next`方法，并将结果转换成所需类型。这里是代码：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Second, a user may want to call `iter` and iterate through the integers one
    at a time, in sorted order. In that case, we’ll return a struct called `Iter`
    that contains a `RangeIter` and then iterates the integers inside the ranges one
    at a time. Here is the original code for `Iter::next`. It is followed by a discussion
    of points of interest.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，用户可能希望调用`iter`并逐个以排序顺序遍历整数。在这种情况下，我们将返回一个名为`Iter`的结构体，它包含一个`RangeIter`，然后逐个遍历范围内的整数。以下是`Iter::next`的原始代码，之后是关注点的讨论。
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `SortedDisjoint` trait relates to guaranteeing that the inside iterator
    provides sorted, disjoint ranges. We’ll discuss it in Rule 5.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`SortedDisjoint`特征涉及到保证内部迭代器提供排序的、不相交的范围。我们将在规则5中讨论它。'
- en: The `option_range` field holds the range (if any) from which we are currently
    returning integers. We use `loop` and `continue` to fill `option_range` when it
    is empty. This loop never loops more than twice, so I could have used recursion.
    However, some of the other iterators recurse enough to cause a stack overflow.
    So, …
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`option_range` 字段保存我们当前返回整数的范围（如果有的话）。我们使用`loop`和`continue`来填充空的`option_range`。这个循环最多只循环两次，因此我本可以使用递归。然而，其他一些迭代器的递归次数足以导致栈溢出。因此，…'
- en: '[Tail recursion optimization is not guaranteed in Rust](https://stackoverflow.com/questions/59257543/when-is-tail-recursion-guaranteed-in-rust).
    My policy: Never use recursion in `next` functions.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[尾递归优化在Rust中没有保证](https://stackoverflow.com/questions/59257543/when-is-tail-recursion-guaranteed-in-rust)。我的政策是：在`next`函数中从不使用递归。'
- en: 'Aside: Thanks to Michael Roth, the current version of `Iter::next` is now shorter.
    His pull request is [here](https://github.com/CarlKCarlK/range-set-blaze/commit/b582f30689502993e1079520ce806c3a905e523e).'
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附注：感谢Michael Roth，当前版本的`Iter::next`现在更简短了。他的拉取请求在[这里](https://github.com/CarlKCarlK/range-set-blaze/commit/b582f30689502993e1079520ce806c3a905e523e)。
- en: Both `BTreeSet` and `RangeSetBlaze` define an `into_iter` iterator method in
    addition to the `iter` method. Similarly, `RangeSetBlaze` defines an `into_ranges`
    iterator method in addition to its `ranges` method. These `into`*_whatever* methods
    take ownership of the underlying `RangeSetBlaze` which is sometimes useful.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`BTreeSet`和`RangeSetBlaze`除了`iter`方法外，还定义了一个`into_iter`迭代器方法。同样，`RangeSetBlaze`除了其`ranges`方法外，还定义了一个`into_ranges`迭代器方法。这些`into`*_whatever*方法获取`RangeSetBlaze`的所有权，这在某些情况下很有用。'
- en: 'Rule 4: Make Illegal Values Unrepresentable with Traits'
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 4：通过特征使非法值不可表示
- en: I said that `RangeSetBlaze` only works on integers, but what stops you applying
    it to characters like so?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我说过`RangeSetBlaze`只适用于整数，但有什么阻止你将它应用于字符呢？
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The answer? The compiler stops you. It returns this error message:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 答案？编译器会阻止你。它返回这个错误消息：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To make this happen, `RangeSetBlaze` defines a trait it calls `Integer`. Here
    is that definition (with all the super traits that I found that I needed):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，`RangeSetBlaze`定义了一个它称之为`Integer`的特征。以下是该定义（以及我找到的所有超级特征）：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: I, next, implemented trait `Integer` on all the integer types of interest (`u8`
    to `u128` including `usize`, `i8` to `i128` including `isize)`. For example,
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我在所有感兴趣的整数类型（`u8`到`u128`包括`usize`，`i8`到`i128`包括`isize`）上实现了`Integer`特征。例如，
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With this, I could make the code generic on `<T: Integer>`, as seen in the
    code sample in Rule 3.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '有了这个，我可以使代码泛型化为`<T: Integer>`，如规则3中的代码示例所示。'
- en: 'Aside: Why doesn’t Rust offer a single standard ‘integer’ trait that does everything?
    [Here is a discussion](https://www.reddit.com/r/rust/comments/qlyn12/how_to_write_a_generic_function_for_only_numeric/).'
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附注：为什么Rust没有提供一个标准的“整数”特征来做所有事情？[这里是讨论](https://www.reddit.com/r/rust/comments/qlyn12/how_to_write_a_generic_function_for_only_numeric/)。
- en: 'Rule 5: Define Generic Iterators with Guaranteed Properties and Useful Methods'
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 5：定义具有保证属性和有用方法的泛型迭代器
- en: '`RangeSetBlaze`’s `from_sorted_disjoint` constructor assumes an input of sorted
    and disjoint ranges. This lets `RangeSetBlaze` avoid work. But what if the assumption
    is wrong? For example, what happens if we give it unsorted ranges, like so?'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`RangeSetBlaze`的`from_sorted_disjoint`构造函数假设输入是排序好的不相交范围。这让`RangeSetBlaze`避免了工作。但是如果这个假设错误了呢？例如，如果我们给它未排序的范围，会发生什么？'
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As in Rule 4, the compiler catches the error and returns a useful message:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 与规则4一样，编译器会捕捉错误并返回有用的消息：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To make this happen, `RangeSetBlaze` defines trait `SortedDisjoint`. Here is
    the relevant definition:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，`RangeSetBlaze`定义了特征`SortedDisjoint`。以下是相关定义：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This says `SortedDisjoint` is generic across integers and that every `SortedDisjoint`
    must be a `SortedStarts`. Moreover, all `SortedStarts` are iterators of ranges
    of integers.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明 `SortedDisjoint` 是对整数的泛型，并且每个 `SortedDisjoint` 必须是 `SortedStarts`。此外，所有
    `SortedStarts` 都是整数范围的迭代器。
- en: 'Aside: My project needs two new traits because I need to guarantee two different
    properties. A project that needs to guarantee only one property will need only
    one new trait.'
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附注：我的项目需要两个新的特征，因为我需要保证两个不同的属性。需要保证一个属性的项目只需要一个新的特征。
- en: 'So, what’s the point? Why introduce new traits when we could just use `Iterator<Item
    = RangeInclusive<T>` directly? As I learned from Rüdiger Klaehn’s wonderful [sorted-iter](https://docs.rs/sorted-iter/latest/sorted_iter/)
    crate, we can use these new traits to enforce guarantees. For example, this constructor
    function uses a `where` clause to accept only guaranteed (sorted and disjoint)
    iterators of integers:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，重点是什么呢？为什么要引入新的特征，而不是直接使用 `Iterator<Item = RangeInclusive<T>`？正如我从 Rüdiger
    Klaehn 的精彩 [sorted-iter](https://docs.rs/sorted-iter/latest/sorted_iter/) crate
    中学到的，我们可以使用这些新特征来强制执行保证。例如，这个构造函数使用 `where` 子句只接受保证的（排序且不重叠的）整数迭代器：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And how do guaranteed iterators get the required `SortedDisjoint` trait? They
    implement it! For example, we know the `RangeSetBlaze::ranges` method returns
    a iterator `RangesIter` of sorted and disjoint ranges, so we have `RangesIter`
    implement the `SortedDisjoint` trait like so:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，保证的迭代器如何获得所需的 `SortedDisjoint` 特征？它们实现了这个特征！例如，我们知道 `RangeSetBlaze::ranges`
    方法返回一个 `RangesIter` 迭代器，它由排序且不重叠的范围组成，因此我们让 `RangesIter` 实现 `SortedDisjoint` 特征，如下所示：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: That’s it. We have just marked `RangesIter` as being `SortedDisjoint`. The compiler
    will do the rest.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。我们已经将 `RangesIter` 标记为 `SortedDisjoint`。编译器会完成剩下的工作。
- en: '**Not guaranteed to guaranteed**: I also marked an iterator called `CheckSortedDisjoint`
    as being `SortedDisjoint`. Interestingly, it iterates over a *not guaranteed*
    internal iterator. How can that be OK? Well, while it iterates, it also checks
    — panicking if it finds any unsorted or overlapping ranges. The result is a guaranteed
    iterator.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**不保证到保证**：我还标记了一个名为 `CheckSortedDisjoint` 的迭代器为 `SortedDisjoint`。有趣的是，它遍历一个
    *不保证* 的内部迭代器。这怎么可能呢？实际上，当它迭代时，它也会检查——如果发现任何未排序或重叠的范围则会引发恐慌。结果是一个保证的迭代器。'
- en: '**Sometimes guaranteed outside iterators**: What about an iterator that is
    sometimes `SortedDisjoint` and sometimes not? The popular `[Itertools::tee](https://docs.rs/itertools/latest/itertools/trait.Itertools.html#method.tee)`
    method, for example, turns any iterator into two iterators with the same contents.
    Here is how we say that if its input iterator is `SortedDisjoint`, its output
    iterators will be, too:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**有时保证外部迭代器**：那么有时是`SortedDisjoint`而有时不是的迭代器呢？例如，流行的 `[Itertools::tee](https://docs.rs/itertools/latest/itertools/trait.Itertools.html#method.tee)`
    方法将任何迭代器转换为两个具有相同内容的迭代器。如果其输入迭代器是`SortedDisjoint`，那么其输出迭代器也将是：'
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Defining methods:** Almost as a bonus, we can define methods on the generic
    `SortedDisjoint` iterator. For example, here we define `complement`, a method
    that produces every range of sorted & disjoint integers *not* in the current iterator.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义方法**：几乎可以说是额外的好处，我们可以在泛型 `SortedDisjoint` 迭代器上定义方法。例如，在这里我们定义了 `complement`
    方法，该方法生成当前迭代器中 *不* 包含的每个排序且不重叠的整数范围。'
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And here is a use example from the `complement` documentation:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自 `complement` 文档的一个使用示例：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `complement` method uses `NotIter`, yet another iterator (see Rule 3). `NotIter`
    also implements `SortedDisjoint`. The example additionally uses `to_string`, another
    `SortedDisjoint` method.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`complement` 方法使用 `NotIter`，另一个迭代器（见规则 3）。`NotIter` 也实现了 `SortedDisjoint`。这个示例还使用了
    `to_string`，这是另一个 `SortedDisjoint` 方法。'
- en: To use `complement` and `to_string`, the user must either
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `complement` 和 `to_string`，用户必须
- en: '`use range_set_blaze::SortedDisjoint;` or `use range_set_blaze::prelude::*;`.The
    prelude works because the project’s `lib.rs` says'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`use range_set_blaze::SortedDisjoint;` 或 `use range_set_blaze::prelude::*;`。前导模块起作用是因为项目的
    `lib.rs` 指定了'
- en: '`pub mod prelude;` and `prelude.rs` file contains this `pub use` that includes
    `SortedDisjoint`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`pub mod prelude;` 和 `prelude.rs` 文件包含这个 `pub use` 语句，它包括 `SortedDisjoint`：'
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Those are the first five rules for creating a data structure in Rust. See [Part
    2](/nine-rules-for-creating-fast-safe-and-compatible-data-structures-in-rust-part-2-da5e6961a0b7)
    for rules 6 to 9.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是创建 Rust 数据结构的前五条规则。请参见 [第 2 部分](/nine-rules-for-creating-fast-safe-and-compatible-data-structures-in-rust-part-2-da5e6961a0b7)
    了解规则 6 到 9。
- en: 'Aside: If you’re interested in future articles, please [follow me on Medium](https://medium.com/@carlmkadie).
    I write on scientific programming in Rust and Python, machine learning, and statistics.
    I tend to write about one article per month.'
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附言：如果你对未来的文章感兴趣，请[关注我的 Medium](https://medium.com/@carlmkadie)。我写关于 Rust 和 Python
    的科学编程、机器学习和统计学的文章。我通常每个月写一篇文章。
