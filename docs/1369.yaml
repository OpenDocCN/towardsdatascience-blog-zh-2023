- en: Implementing a sales & support agent with LangChain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/implementing-a-sales-support-agent-with-langchain-63c4761193e7?source=collection_archive---------0-----------------------#2023-04-19](https://towardsdatascience.com/implementing-a-sales-support-agent-with-langchain-63c4761193e7?source=collection_archive---------0-----------------------#2023-04-19)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Learn how to develop a chatbot that can answer questions based on the information
    provided in your company’s documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://bratanic-tomaz.medium.com/?source=post_page-----63c4761193e7--------------------------------)[![Tomaz
    Bratanic](../Images/d5821aa70918fcb3fc1ff0013497b3d5.png)](https://bratanic-tomaz.medium.com/?source=post_page-----63c4761193e7--------------------------------)[](https://towardsdatascience.com/?source=post_page-----63c4761193e7--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----63c4761193e7--------------------------------)
    [Tomaz Bratanic](https://bratanic-tomaz.medium.com/?source=post_page-----63c4761193e7--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F57f13c0ea39a&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fimplementing-a-sales-support-agent-with-langchain-63c4761193e7&user=Tomaz+Bratanic&userId=57f13c0ea39a&source=post_page-57f13c0ea39a----63c4761193e7---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----63c4761193e7--------------------------------)
    ·10 min read·Apr 19, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F63c4761193e7&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fimplementing-a-sales-support-agent-with-langchain-63c4761193e7&user=Tomaz+Bratanic&userId=57f13c0ea39a&source=-----63c4761193e7---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F63c4761193e7&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fimplementing-a-sales-support-agent-with-langchain-63c4761193e7&source=-----63c4761193e7---------------------bookmark_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: Recently, I have been fascinated by the power of ChatGPT and its ability to
    construct various types of chatbots. I have tried and written about multiple approaches
    to implementing a chatbot that can access external information to improve its
    answers. I joined a few Discord channels during my chatbot coding sessions, hoping
    to get some help as the libraries are relatively new, and not much documentation
    is available yet. To my amazement, I found custom bots that could answer most
    of the questions for the given library.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b6412e36fd86059a0c293b5f63d8d361.png)'
  prefs: []
  type: TYPE_IMG
- en: Example of a discord support bot. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to provide the chatbot the ability to dig through various resources
    like company documentation, code, or other content in order to allow it to answer
    company support questions. Since I already have some experience with chatbots,
    I decided to test how hard it is to implement a custom bot with access to the
    company’s resources.
  prefs: []
  type: TYPE_NORMAL
- en: In this blog post, I will walk you through how I used OpenAI’s models to implement
    a sales & support agent with in the [LangChain library](https://python.langchain.com/en/latest/index.html)
    that can be used to answer information about applications with a [graph database
    Neo4j](https://neo4j.com/). The agent can also help you debug or produce any Cypher
    statement you are struggling with. Such an agent could then be deployed to serve
    users on Discord or other platforms.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9ec9e7b7feaa9f81a3bee35083bf94a1.png)'
  prefs: []
  type: TYPE_IMG
- en: Agent design. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using the [LangChain library](https://python.langchain.com/en/latest/index.html)
    to implement the support bot. The library is easy to use and provides an excellent
    integration of LLM prompts and Python code, allowing us to develop chatbots in
    only a few minutes. In addition, the library supports a range of LLMs, text embedding
    models, and vector databases, along with utility functions that help us load and
    embed frequent types of files we might come across, like text, PowerPoint, images,
    HTML, PDF, and more.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this blog post is available on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://github.com/tomasonjo/blogs/blob/master/neo4jdocs/neo4j_support_bot.ipynb?source=post_page-----63c4761193e7--------------------------------)
    [## blogs/neo4j_support_bot.ipynb at master · tomasonjo/blogs'
  prefs: []
  type: TYPE_NORMAL
- en: You can't perform that action at this time. You signed in with another tab or
    window. You signed out in another tab or…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: github.com](https://github.com/tomasonjo/blogs/blob/master/neo4jdocs/neo4j_support_bot.ipynb?source=post_page-----63c4761193e7--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: LangChain document loaders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we must preprocess the company’s resources and store them in a vector
    database. Luckily, LangChain can help us load external data, calculate text embeddings,
    and store the documents in a vector database of our choice.
  prefs: []
  type: TYPE_NORMAL
- en: First, we have to load the text into documents. LangChain offers a variety of
    [helper functions that can take various formats and types of data and produce
    a document output](https://python.langchain.com/en/latest/modules/indexes/document_loaders.html?highlight=document+loaders).
    The helper functions are called Document loaders.
  prefs: []
  type: TYPE_NORMAL
- en: Neo4j has a lot of its documentation available in GitHub repositories. Conveniently,
    LangChain provides a document loader that takes a repository URL as input and
    produces a document for each file in the repository. Additionally, we can use
    the filter function to ignore files during the loading process if needed.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin by loading the AsciiDoc files from the [Neo4j’s knowledge base
    repository](https://github.com/neo4j-documentation/knowledge-base).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Wasn’t that easy as a pie? The `GitLoader` function clones the repository and
    load relevant files as documents. In this example, we specified that the file
    must end with `.adoc` suffix and be a part of the `articles` folder. In total,
    309 articles were loaded. We also have to be mindful of the size of the documents.
    For example, GPT-3.5-turbo has a token limit of 4000, while GPT-4 allows 8000
    tokens in a single request. While number of words is not exactly identical to
    the number of tokens, it is still a good estimator.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will load the documentation of the [Graph Data Science repository](https://github.com/neo4j/graph-data-science).
    Here, we will use a text splitter to make sure none of the documents exceed 2000
    words. Again, I know that number of words is not equal to the number of tokens,
    but it is a good approximation. Defining the threshold number of tokens can significantly
    affect how the database is found and retrieved. I found a [great article by Pinecone
    that can help you understand the basics of various chunking strategies](https://www.pinecone.io/learn/chunking-strategies/).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We could load other Neo4j repositories that contain documentation. However,
    the idea is to show various data loading methods and not explore all of Neo4j’s
    repositories containing documentation. Therefore, we will move on and look at
    how we can load documents from a Pandas Dataframe.
  prefs: []
  type: TYPE_NORMAL
- en: For example, say that we want to load a YouTube video as a document source for
    our chatbot. Neo4j has its own YouTube channel and, even I appear in a video or
    two. Two years ago I presented how to implement an information extraction pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: With LangChain, we can use the captions of the video and load it as documents
    with only three lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It couldn’t get any easier than this. Next, we will look at loading documents
    from a Pandas dataframe. A month ago, I retrieved information from Neo4j medium
    publication for a separate blog post. Since we want to bring external information
    about Neo4j to the bot, we can also use the content of the medium articles.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used Pandas to load a CSV file from GitHub, renamed one column, and
    used the `DataFrameLoader`function to load the articles as documents. Since medium
    posts could exceed 4000 tokens, we used the text splitter to split the articles
    into multiple chunks.
  prefs: []
  type: TYPE_NORMAL
- en: The last source we will use is the Stack Overflow API. Stack Overflow is a web
    platform where users help others solve coding problems. Their API does not require
    any authorization. Therefore, we can use the API to retrieve questions with accepted
    answers that are tagged with the Neo4j tag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Each approved answer and the original question are used to construct a single
    document. Since most Stack overflow questions and answers do not exceed 4000 tokens,
    we skipped the text-splitting step.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have loaded the documentation resources as documents, we can move
    on to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Storing documents in a vector database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A chatbot finds relevant information by comparing the vector embedding of questions
    with document embeddings. A text embedding is a machine-readable representation
    of text in the form of a vector or, more plainly, a list of floats. In this example,
    we will use the **ada-002** model provided by OpenAI to embed documents.
  prefs: []
  type: TYPE_NORMAL
- en: The whole idea behind vector databases is the ability to store vectors and provide
    fast similarity searches. The vectors are usually compared using cosine similarity.
    LangChain includes [integration with a variety of vector databases](https://python.langchain.com/en/latest/modules/indexes/vectorstores.html).
    To keep things simple, we will use the [Chroma vector database](https://www.trychroma.com/),
    which can be used as a local in-memory. For a more serious chatbot application,
    we want to use a persistent database that doesn’t lose data once the script or
    notebook is closed.
  prefs: []
  type: TYPE_NORMAL
- en: We will create two collections of documents. The first will be more sales and
    marketing oriented, containing documents from Medium and YouTube. The second collection
    focuses more on support use cases and consists of documentation and Stack Overflow
    documents.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This script runs each document through OpenAI’s text embedding API and inserts
    the resulting embedding along with text in the Chroma database. The process of
    text embedding costs 0.80$, which is a reasonable price.
  prefs: []
  type: TYPE_NORMAL
- en: Question answering using external context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last thing to do is to implement two separate question-answering flow. The
    first will handle the sales & marketing requests, while the other will handle
    support. The LangChain library uses LLMs for reasoning and providing answers to
    the user. Therefore, we start by defining the LLM. Here, we will be using the
    **GPT-3.5-turbo** model from OpenAI.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Implementing a question-answering flow is about as easy as it gets with LangChain.
    We only need to provide the LLM to be used along with the retriever that is used
    to fetch relevant documents. Additionally, we have the option to customize the
    LLM prompt used to answer questions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The most important part of the sales prompt is to prohibit the LLM from basing
    its responses without relying on official company resources. Remember, LLMs can
    act very assertively while providing invalid information. However, we would like
    to avoid that scenario and avoid getting into problems where the bot promised
    or sold non-existing features. We can test the sales question answering flow by
    asking the following question:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/51fd80bad01f9fae580506c01f7a2ca2.png)'
  prefs: []
  type: TYPE_IMG
- en: Sales question-answering. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: The response to the question seems relevant and accurate. Remember, the information
    to construct this response came from Medium articles.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will implement the support question-answering flow. Here, we will allow
    the LLM model to use its knowledge of Cypher and Neo4j to help solve the user’s
    problem if the context doesn’t provide enough information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: And again, we can test the support question-answering abilities. I took a random
    question from Neo4j’s discord server.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7376d8dd9759b3e0de2dbb97c731112d.png)'
  prefs: []
  type: TYPE_IMG
- en: Support question-answering. Image by the author
  prefs: []
  type: TYPE_NORMAL
- en: The response is quite to the point. Remember, we retrieved the Graph Data Science
    documentation and are using it as context to form the chatbot questions.
  prefs: []
  type: TYPE_NORMAL
- en: Agent implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now have two separate instructions and stores for **sales** and **support**
    responses. If we had to put a human in the loop to distinguish between the two,
    the whole point of the chatbot would be lost. Luckily, we can use a LangChain
    agent to decide which tool to use based on the user input. First, we need to define
    the available tools of an agent along with instructions on when and how to use
    them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The description of a tool is used by an agent to identify when and how to use
    a tool. For example, the support tool should be used to optimize or debug a Cypher
    statement and the input to the tool should be a fully formed question.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do is to initialize the agent.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now we can go ahead and test the agent on a couple of questions.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c41124f57d1518b2aa058f12e21ff37a.png)'
  prefs: []
  type: TYPE_IMG
- en: Sales agent example. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6b5bda832a1d884337d9dd5258180510.png)'
  prefs: []
  type: TYPE_IMG
- en: Support agent example. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, the main difference between the two QAs beside the context sources
    is that we allow the support QA to form answers that can’t be found in the provided
    context. On the other hand, we prohibit the sales QA from doing that to avoid
    any overpromising statements.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the era of LLMs, you can develop a chatbot that uses company’s resources
    to answer questions in a single day thanks to LangChain library as it offers various
    document loaders as well as integration with popular LLM models. Therefore, the
    only thing you need to do is to collect company’s resources, import them into
    a vector database, and you are good to go. Just note that the implementation is
    not deterministic, which means you can get slightly different results on identical
    prompts. GPT-4 model is much better for more accurate and consistent responses.
  prefs: []
  type: TYPE_NORMAL
- en: Let me know if you have any ideas or feedback regarding the chatbot implementation.
    As always, the code is available on [GitHub](https://github.com/tomasonjo/blogs/blob/master/neo4jdocs/neo4j_support_bot.ipynb).
  prefs: []
  type: TYPE_NORMAL
