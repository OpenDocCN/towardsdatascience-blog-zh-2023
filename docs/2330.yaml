- en: Map-Matching for Trajectory Prediction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轨迹预测中的地图匹配
- en: 原文：[https://towardsdatascience.com/map-matching-for-trajectory-prediction-be307a1547f0?source=collection_archive---------4-----------------------#2023-07-20](https://towardsdatascience.com/map-matching-for-trajectory-prediction-be307a1547f0?source=collection_archive---------4-----------------------#2023-07-20)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/map-matching-for-trajectory-prediction-be307a1547f0?source=collection_archive---------4-----------------------#2023-07-20](https://towardsdatascience.com/map-matching-for-trajectory-prediction-be307a1547f0?source=collection_archive---------4-----------------------#2023-07-20)
- en: Where are you going? Should you be going that way?
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你要去哪里？你是否应该朝那个方向前进？
- en: '[](https://medium.com/@joao.figueira?source=post_page-----be307a1547f0--------------------------------)[![João
    Paulo Figueira](../Images/54e4176f66e4ab0324d86ec71d8b033d.png)](https://medium.com/@joao.figueira?source=post_page-----be307a1547f0--------------------------------)[](https://towardsdatascience.com/?source=post_page-----be307a1547f0--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----be307a1547f0--------------------------------)
    [João Paulo Figueira](https://medium.com/@joao.figueira?source=post_page-----be307a1547f0--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@joao.figueira?source=post_page-----be307a1547f0--------------------------------)[![João
    Paulo Figueira](../Images/54e4176f66e4ab0324d86ec71d8b033d.png)](https://medium.com/@joao.figueira?source=post_page-----be307a1547f0--------------------------------)[](https://towardsdatascience.com/?source=post_page-----be307a1547f0--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----be307a1547f0--------------------------------)
    [João Paulo Figueira](https://medium.com/@joao.figueira?source=post_page-----be307a1547f0--------------------------------)'
- en: ·
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F64bc009cedeb&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmap-matching-for-trajectory-prediction-be307a1547f0&user=Jo%C3%A3o+Paulo+Figueira&userId=64bc009cedeb&source=post_page-64bc009cedeb----be307a1547f0---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----be307a1547f0--------------------------------)
    ·16 min read·Jul 20, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fbe307a1547f0&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmap-matching-for-trajectory-prediction-be307a1547f0&user=Jo%C3%A3o+Paulo+Figueira&userId=64bc009cedeb&source=-----be307a1547f0---------------------clap_footer-----------)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[关注](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F64bc009cedeb&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmap-matching-for-trajectory-prediction-be307a1547f0&user=Jo%C3%A3o+Paulo+Figueira&userId=64bc009cedeb&source=post_page-64bc009cedeb----be307a1547f0---------------------post_header-----------)
    发布于 [Towards Data Science](https://towardsdatascience.com/?source=post_page-----be307a1547f0--------------------------------)
    ·16 min read·2023年7月20日[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fbe307a1547f0&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmap-matching-for-trajectory-prediction-be307a1547f0&user=Jo%C3%A3o+Paulo+Figueira&userId=64bc009cedeb&source=-----be307a1547f0---------------------clap_footer-----------)'
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fbe307a1547f0&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmap-matching-for-trajectory-prediction-be307a1547f0&source=-----be307a1547f0---------------------bookmark_footer-----------)![](../Images/a73b6217b65a4dfaed426ff4ff6ec0d4.png)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fbe307a1547f0&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmap-matching-for-trajectory-prediction-be307a1547f0&source=-----be307a1547f0---------------------bookmark_footer-----------)![](../Images/a73b6217b65a4dfaed426ff4ff6ec0d4.png)'
- en: Photo by [Mateusz Wacławek](https://unsplash.com/@wacalke?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 照片由[Mateusz Wacławek](https://unsplash.com/@wacalke?utm_source=medium&utm_medium=referral)拍摄，来源于[Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: This article presents a method to predict vehicle trajectories on a digital
    road network using a database of past trips sampled from noisy GPS sensors. Besides
    predicting future directions, this method also assigns a probability to an arbitrary
    sequence of locations.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本文提出了一种方法，利用从嘈杂的GPS传感器采样的历史旅行数据库来预测数字道路网络上的车辆轨迹。除了预测未来方向外，该方法还为任意位置序列分配一个概率。
- en: Central to this idea is using a digital map unto which we project all sampled
    locations by aggregating them into individual trajectories and matching them to
    the map. This matching process discretizes the continuous GPS space into predetermined
    locations and sequences. After encoding these locations into unique geospatial
    tokens, we can more easily predict sequences, evaluate the probability of current
    observations, and estimate future directions. This is the gist of this article.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这一理念的核心是使用数字地图，我们将所有采样位置投影到地图上，通过将它们聚合到单独的轨迹中并与地图匹配。这一匹配过程将连续的 GPS 空间离散化为预定位置和序列。将这些位置编码为唯一的地理空间标记后，我们可以更容易地预测序列，评估当前观察的概率，并估计未来的方向。这是本文的要旨。
- en: The Problems
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What problems am I trying to solve here? If you need to analyze vehicle path
    data, you might need to answer questions like those in the article’s sub-heading.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里尝试解决哪些问题？如果你需要分析车辆路径数据，可能需要回答文章小标题中的问题。
- en: Where are you going? Should you be going that way?
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你要去哪里？你应该那样走吗？
- en: How do you evaluate the probability that the path under observation follows
    frequently traveled directions? This is an important question as, by answering
    it, you could program an automated system to classify trips according to their
    observed frequency. A new trajectory with a low score would cause concern and
    prompt immediate flagging.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如何评估观察到的路径是否遵循经常行驶的方向的概率？这是一个重要的问题，因为通过回答它，你可以编程一个自动化系统来根据观察到的频率对行程进行分类。新轨迹的低分将引起关注并促使立即标记。
- en: How do you predict which maneuvers the vehicle will do next? Will it keep going
    straight ahead, or will it turn right at the next intersection? Where do you expect
    to see the vehicle in the next ten minutes or ten miles? Quick answers to these
    questions will assist an online tracking software solution provide answers and
    insights to delivery planners, online route optimizers, or even opportunity charging
    systems.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如何预测车辆接下来会进行哪些操作？它会继续直行，还是在下一个交叉口右转？你期望在接下来的十分钟或十英里内看到车辆在哪里？对这些问题的快速回答将帮助在线跟踪软件解决方案向配送规划者、在线路线优化器，甚至机会充电系统提供答案和见解。
- en: Solution
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: The solution I am presenting here uses a database of historical trajectories,
    each consisting of a timed sequence of positions generated by the motion of a
    specific vehicle. Each positional record must contain time, position information,
    a reference to the vehicle identifier, and the trajectory identifier. A vehicle
    has many trajectories, and each trajectory has many positional records. A sample
    of our input data is depicted in **Figure 1** below.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里提出的解决方案使用了一个历史轨迹数据库，每个轨迹由特定车辆运动生成的时间序列位置组成。每个位置记录必须包含时间、位置信息、车辆标识符的参考以及轨迹标识符。一辆车有很多轨迹，每个轨迹有很多位置记录。我们输入数据的样本如**图
    1**所示。
- en: '![](../Images/b1ba6d6813bc8c2cdeda3ae3ef91f9c9.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b1ba6d6813bc8c2cdeda3ae3ef91f9c9.png)'
- en: '**Figure 1** — The table above shows a small sample of a trajectory from the
    [Extended Vehicle Energy Dataset](https://arxiv.org/abs/2203.08630). Although
    each row contains more properties than the ones displayed, we only need the implicit
    order and the locations. Note that there are many duplicated locations due to
    the sampling strategy. We will handle this issue later on. (Image source: Author)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 1** — 上表显示了来自[扩展车辆能量数据集](https://arxiv.org/abs/2203.08630)的一个轨迹的小样本。虽然每一行包含比展示的更多属性，但我们只需要隐含顺序和位置。注意，由于采样策略，有很多重复的位置。我们稍后将处理这个问题。（图片来源：作者）'
- en: I drew the data above from the [Extended Vehicle Energy Dataset](https://arxiv.org/abs/2203.08630)
    (EVED) **[1]** article. You can build the corresponding database by following
    the code in one of my previous articles.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我从[扩展车辆能量数据集](https://arxiv.org/abs/2203.08630)（EVED）**[1]** 文章中提取了上述数据。你可以通过参考我之前文章中的代码来构建相应的数据库。
- en: '[](/travel-time-estimation-using-quadkeys-ecf6d54823b4?source=post_page-----be307a1547f0--------------------------------)
    [## Travel Time Estimation Using Quadkeys'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[](/travel-time-estimation-using-quadkeys-ecf6d54823b4?source=post_page-----be307a1547f0--------------------------------)
    [## 使用 Quadkeys 进行旅行时间估计'
- en: This article explains how to estimate travel times using known speed vectors
    indexed by quadkeys.
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本文解释了如何使用通过 Quadkeys 索引的已知速度向量来估计旅行时间。
- en: towardsdatascience.com](/travel-time-estimation-using-quadkeys-ecf6d54823b4?source=post_page-----be307a1547f0--------------------------------)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: towardsdatascience.com](/travel-time-estimation-using-quadkeys-ecf6d54823b4?source=post_page-----be307a1547f0--------------------------------)
- en: Our first job is to match these trajectories to a supporting digital map. The
    purpose of this step is not only to eliminate the GPS data sampling errors but,
    most importantly, to coerce the acquired trip data to an existing road network
    where each node and edge are known and fixed. Each recorded trajectory is thus
    converted from a sequence of geospatial locations into another sequence of numeric
    tokens coinciding with the existing digital map nodes. Here, we will use open-sourced
    data and software, with map data sourced from [OpenStreetMap](https://www.openstreetmap.org/)
    (compiled by [Geofabrik](https://www.geofabrik.de/)), the [Valhalla](https://valhalla.github.io/valhalla/)
    map-matching package, and [H3](https://www.uber.com/en-PT/blog/h3/) as the geospatial
    tokenizer.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一项工作是将这些轨迹匹配到支持的数字地图上。这个步骤的目的不仅是为了消除 GPS 数据采样误差，更重要的是，将获取的旅行数据强制转换为已知和固定的现有道路网络，其中每个节点和边都已知。每条记录的轨迹因此被转换为与现有数字地图节点相符的一系列数值标记。在这里，我们将使用开源数据和软件，地图数据来源于[OpenStreetMap](https://www.openstreetmap.org/)（由[Geofabrik](https://www.geofabrik.de/)编译）、[Valhalla](https://valhalla.github.io/valhalla/)地图匹配包和[H3](https://www.uber.com/en-PT/blog/h3/)作为地理空间分词器。
- en: Edge Versus Node Matching
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 边缘与节点匹配
- en: Map-matching is more nuanced than it might look at first sight. To illustrate
    what this concept entails, let us look at **Figure 2** below.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 地图匹配比乍看起来要复杂。为了说明这个概念的含义，我们来看一下下面的**图 2**。
- en: '![](../Images/2fc824d827b903fce0e6ac71bfc620a3.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2fc824d827b903fce0e6ac71bfc620a3.png)'
- en: '**Figure 2** — The map above shows a noisy trajectory taken from the EVED in
    blue. As you can see, it does not match the nearest road and needs matching to
    the map. Once we project the blue line vertices to the map, we obtain a sequence
    of projections of the original points to the inferred map edges, and you can see
    the resulting trajectory in red. Still, this path misses the underlying map in
    some places, most notably in the image’s center, where the red line jumps between
    roads. We aim to reconstruct the trip’s path on the map, as represented by the
    green line, that follows the underlying map nodes. (Image source: Author using
    Folium and OpenStreetMap imagery)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 2** — 上图展示了从 EVED 中获得的噪声轨迹（蓝色）。如你所见，它与最近的道路不匹配，需要与地图进行匹配。一旦我们将蓝线的顶点投影到地图上，就可以得到原始点到推断地图边缘的一系列投影，你可以看到结果轨迹为红色。然而，这条路径在某些地方仍然未能覆盖底层地图，特别是在图像的中心，红线在道路之间跳跃。我们的目标是重建地图上的旅行路径，如绿色线所示，遵循底层地图节点。（图片来源：作者使用
    Folium 和 OpenStreetMap 图像）'
- en: '**Figure 2** above shows that we can derive two trajectories from an original
    GPS sequence. We obtain the first trajectory by projecting the original GPS locations
    into the nearest (and most likely) road network segments. As you can see, the
    resulting polyline will only sometimes follow the road because the map uses graph
    nodes to define its basic shapes. By projecting the original locations to the
    map *edges*, we get new points that belong to the map but may stray from the map’s
    geometry when connected to the next ones by a straight line.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 上述**图 2**显示，我们可以从原始 GPS 序列中推导出两条轨迹。我们通过将原始 GPS 位置投影到最近（且最可能的）道路网络段来获得第一条轨迹。如你所见，结果折线有时只会沿着道路，因为地图使用图形节点来定义其基本形状。通过将原始位置投影到地图*边缘*，我们获得了属于地图的新点，但在通过直线连接到下一个点时，可能会偏离地图的几何形状。
- en: By projecting the GPS trajectory to the map *nodes*, we get a path that perfectly
    overlays the map, as shown by the green line in **Figure 2**. Although this path
    better represents the initially driven trajectory, it does not necessarily have
    a one-to-one location correspondence with the original. Fortunately, this will
    be fine for us as we will always map-match any trajectory to the map nodes, so
    we will always get coherent data, with one exception. The Valhalla map-matching
    code always edge-projects the initial and final trajectory points, so we will
    systematically discard them as they do not correspond to map nodes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 GPS 轨迹投影到地图上的*节点*，我们得到了一条完美覆盖地图的路径，如**图 2**中的绿色线所示。虽然这条路径更好地表示了最初驱动的轨迹，但它不一定与原始位置一一对应。幸运的是，这对我们来说没有问题，因为我们将始终将任何轨迹与地图节点进行匹配，因此我们将始终获得一致的数据，只有一个例外。Valhalla
    地图匹配代码始终将初始和最终轨迹点进行边缘投影，因此我们会系统性地丢弃它们，因为它们与地图节点不对应。
- en: H3 Tokenization
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: H3 分词
- en: Unfortunately, Valhalla does not report the unique road network node identifiers,
    so we must convert the node coordinates to unique integer tokens for later sequence
    frequency calculation. This is where H3 enters the picture by allowing us to encode
    the node coordinates into a sixty-four-bit integer uniquely. We pick the Valhalla-generated
    polyline, strip the initial and final points (these points are not nodes but edge
    projections), and map all remaining coordinates to [level 15 H3 indices](https://h3geo.org/docs/core-library/restable/).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The Dual Graph
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the process above, we convert each historical trajectory into a sequence
    of H3 tokens. The next step is to convert each trajectory to a sequence of token
    triplets. Three values in a sequence represent two consecutive edges of the prediction
    graph, and we want to know the frequencies of these, as they will be the core
    data for both the prediction and the probability assessment. **Figure 3** below
    depicts this process visually.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3b69e2aacdf1d111ab679baeb19abd54.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3** — The list of geospatial tokens on the left is expanded to another
    list of triplets, representing a dual vision of the implicit graph. Each token
    is a node on the geospatial graph, and its sequence represents the edges. The
    transformed list considers each edge a node in the dual graph, and the middle
    token is the new edge, as shown in the right column. (Image source: Author)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: The transformation above computes the dual of the road graph, reversing the
    roles of the original nodes and edges.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: We can now start to answer the proposed questions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Should you be going that way?
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to know the vehicle trajectory up to a given moment to answer this question.
    We map-match and tokenize the trajectory using the same process as above and then
    compute each trajectory triplet frequency using the known historic frequencies.
    The final result is the product of all individual frequencies. If the input trajectory
    has an unknown triplet, its frequency will be zero as the final path probability.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: A triplet probability is the ratio of counts of a specific sequence *(A, B,
    C)* to the count of all *(A, B, *)* triplets, as depicted in **Figure 4** below.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3f2a013dfc05e514790e23f06dfaf861.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
- en: '**Figure 4** — The triplet probability is the ratio of its frequency to the
    frequency of all triplets with the same two initial tokens. (Image source: Author)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: The trip probability is just the product of individual trip triplets, as depicted
    in **Figure 5** below.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/63a1a05726650fc3d47ed0b011dbfe04.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5** — The trip probability is the simple product of all matched triplets.
    (Image source: Author)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Where are you going?
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use the same principles to answer this question but start with the last known
    triplet only. We can predict the *k* most likely successors using this triplet
    as input by enumerating all triplets that have as their first two tokens the last
    two of the input. **Figure 6** below illustrates the process for triplet sequence
    generation and evaluation.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的原则来回答这个问题，但仅从最后一个已知的三元组开始。我们可以使用这个三元组作为输入，通过列举所有以输入的最后两个令牌作为前两个令牌的三元组，预测最可能的
    *k* 个后继者。下方的**图6**展示了三元组序列生成和评估的过程。
- en: '![](../Images/6a24f954180d02aadb06ac87356c66a9.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6a24f954180d02aadb06ac87356c66a9.png)'
- en: '**Figure 6** — In this fictitious case, the next most likely triplet is the
    one with the highest observed frequency (B, C, D). (Image source: Author)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**图6** — 在这个虚拟的案例中，最可能的下一个三元组是观察到的频率最高的三元组（B, C, D）。(图片来源：作者)'
- en: We can extract the top *k* successor triplets and repeat the process to predict
    the most likely trip.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提取前 *k* 个后继三元组并重复该过程，以预测最可能的旅行。
- en: Implementation
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: We are ready to discuss the implementation details, starting with map-matching
    and some associated concepts. Next, we will see how to use the Valhalla toolset
    from Python, extract the matched paths and generate the token sequences. The data
    preprocessing step will be over once we store the result in the database.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备讨论实现细节，从地图匹配和一些相关概念开始。接下来，我们将学习如何从 Python 使用 Valhalla 工具集，提取匹配的路径并生成令牌序列。一旦我们将结果存储在数据库中，数据预处理步骤就完成了。
- en: Finally, I illustrate a simple user interface using [Streamlit](https://streamlit.io/)
    that calculates the probability of any hand-drawn trajectory and then projects
    it into the future.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我展示了一个使用 [Streamlit](https://streamlit.io/) 的简单用户界面，该界面计算任何手绘轨迹的概率，并将其投射到未来。
- en: Map-Matching
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地图匹配
- en: '[Map-matching](https://en.wikipedia.org/wiki/Map_matching) converts GPS coordinates
    sampled from a moving object’s path into an existing road graph. A road graph
    is a discrete model of the underlying physical road network consisting of *nodes*
    and connecting *edges*. Each node corresponds to a known geospatial location along
    the road, encoded as a latitude, longitude, and altitude tuple. Each *directed
    edge* connects adjacent nodes following the underlying road and contains many
    properties such as the heading, maximum speed, road type, and more. **Figure 7**
    below illustrates the concept with a straightforward example.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[地图匹配](https://en.wikipedia.org/wiki/Map_matching) 将从移动物体路径中采样的 GPS 坐标转换为现有的道路图。道路图是一个离散的模型，表示物理道路网络，由
    *节点* 和连接的 *边* 组成。每个节点对应于沿道路已知的地理位置，编码为纬度、经度和高度元组。每个 *有向边* 连接沿着基础道路的相邻节点，并包含许多属性，如航向、最高速度、道路类型等。下方的**图7**用一个简单的例子说明了这个概念。'
- en: '![](../Images/ac91e1c9f23d35de0d6164bf25a3d1f1.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ac91e1c9f23d35de0d6164bf25a3d1f1.png)'
- en: '**Figure 7** — The picture above shows a tiny digital road network highlighting
    an intersection. Each red dot represents a known geospatial location along the
    existing road. The blue lines represent the connecting edges between the nodes.
    Note that these edges are usually directed and might also be multiple. (Image
    source: Author)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7** — 上图展示了一个小型数字道路网络，突出了一个交叉口。每个红点代表现有道路上的已知地理位置。蓝色线条表示节点之间的连接边。请注意，这些边通常是有向的，并且可能是多个的。(图片来源：作者)'
- en: When successful, the map-matching process produces relevant and valuable information
    on the sampled trajectory. On the one hand, the process projects the sampled GPS
    points to locations along the most likely road graph *edges*. The map-matching
    process “corrects” the observed spots by squarely placing them over the inferred
    road graph *edges*. On the other hand, the method also reconstructs the sequence
    of graph *nodes* by providing the most likely path through the road graph corresponding
    to the sampled GPS locations. Note that, as previously explained, these outputs
    are different. The first output contains coordinates along the *edges* of the
    most likely path, while the second output consists of the reconstructed sequence
    of graph *nodes*. **Figure 8** below illustrates the process.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时，地图匹配过程会生成有关采样轨迹的相关和有价值的信息。一方面，该过程将采样的 GPS 点投射到最可能的道路图 *边* 上。地图匹配过程通过将观察到的点准确地放置到推断的道路图
    *边* 上来“纠正”观察到的点。另一方面，该方法还通过提供最可能的路径，通过道路图重建图 *节点* 的序列，以对应于采样的 GPS 位置。请注意，如前所述，这些输出是不同的。第一个输出包含沿着最可能路径的
    *边* 的坐标，而第二个输出由重建的图 *节点* 序列组成。下方的**图8**展示了这个过程。
- en: '![](../Images/443a5756f68bb893a9107d3fdc3dcada.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/443a5756f68bb893a9107d3fdc3dcada.png)'
- en: '**Figure 8** — The diagram above illustrates the map-matching process, where
    the green dots represent the observed GPS coordinates, and the orange diamonds
    represent the projected locations along the known edges. Note that, for the simplified
    example above, we can only safely reconstruct the path between nodes 2 and 3\.
    This predicament is not as dire as it looks because, in actual maps, trajectories
    match many more edges than just one, so the information loss is minimal. (Image
    source: Author)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**图8** — 上图展示了地图匹配过程，其中绿色点代表观察到的GPS坐标，橙色钻石代表沿已知边的投影位置。请注意，对于上述简化的示例，我们只能安全地重建节点2和3之间的路径。这种困境并不像看起来那么严重，因为在实际地图中，轨迹匹配的边缘远远超过一个，因此信息丢失最小。（图片来源：作者）'
- en: 'A byproduct of the map-matching process is the standardization of the input
    locations using a shared road network representation, especially when considering
    the second output type: the most likely sequence of nodes. When converting sampled
    GPS trajectories to a series of nodes, we make them comparable by reducing the
    inferred path to a series of node identifiers. We can think of these node sequences
    as *phrases* of a known language, where each inferred node identifier is a *word*,
    and their arrangement conveys behavioral information.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 地图匹配过程的一个副产品是使用共享道路网络表示法对输入位置进行标准化，特别是在考虑第二种输出类型时：最可能的节点序列。在将采样的GPS轨迹转换为一系列节点时，我们通过将推断路径减少为一系列节点标识符，使其可比拟。我们可以将这些节点序列视为已知语言的*短语*，其中每个推断的节点标识符是一个*词*，其排列传达了行为信息。
- en: This is the fifth article where I explore the [Extended Vehicle Energy Dataset](https://arxiv.org/abs/2203.08630)¹
    (EVED) [1]. This dataset is an enhancement and review of [prior work](https://arxiv.org/abs/1905.02081)
    and provides the map-matched versions of the original GPS-sampled locations (the
    orange diamonds in **Figure 8** above).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第五篇文章，我在其中探讨了[扩展车辆能源数据集](https://arxiv.org/abs/2203.08630)¹ (EVED) [1]。该数据集是对[先前工作的](https://arxiv.org/abs/1905.02081)扩展和评审，并提供了原始GPS采样位置的地图匹配版本（上方**图8**中的橙色钻石）。
- en: Unfortunately, the EVED only contains the projected GPS locations and misses
    the reconstructed road network node sequences. In my previous two articles, I
    addressed the issue of rebuilding the road segment sequences from the transformed
    GPS locations without map-matching. I found the result somewhat disappointing,
    as I expected less than the observed 16% of defective reconstructions. You can
    follow this discussion from the articles below.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，EVED仅包含投影的GPS位置，而缺少重建的道路网络节点序列。在我之前的两篇文章中，我解决了从转换后的GPS位置重建道路段序列而无需地图匹配的问题。我发现结果有些令人失望，因为我预期的缺陷重建率低于观察到的16%。您可以从以下文章中跟踪这一讨论。
- en: '[](/road-network-edge-matching-with-triangles-5dc989a77edf?source=post_page-----be307a1547f0--------------------------------)
    [## Road Network Edge Matching With Triangles'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[](/road-network-edge-matching-with-triangles-5dc989a77edf?source=post_page-----be307a1547f0--------------------------------)
    [## 路网边缘匹配与三角形'
- en: Triangles have mighty properties for geospatial queries
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 三角形在地理空间查询中具有强大的特性
- en: towardsdatascience.com](/road-network-edge-matching-with-triangles-5dc989a77edf?source=post_page-----be307a1547f0--------------------------------)
    [](/more-on-road-network-matching-c2ea0728c415?source=post_page-----be307a1547f0--------------------------------)
    [## More on Road Network Matching
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: towardsdatascience.com](/road-network-edge-matching-with-triangles-5dc989a77edf?source=post_page-----be307a1547f0--------------------------------)
    [](/more-on-road-network-matching-c2ea0728c415?source=post_page-----be307a1547f0--------------------------------)
    [## 更多关于道路网络匹配
- en: Road network matching shenanigans
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 道路网络匹配的趣事
- en: towardsdatascience.com](/more-on-road-network-matching-c2ea0728c415?source=post_page-----be307a1547f0--------------------------------)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: towardsdatascience.com](/more-on-road-network-matching-c2ea0728c415?source=post_page-----be307a1547f0--------------------------------)
- en: Now, I am looking at the source map-matching tool to see how far it can go in
    correcting the defective reconstructions. So, let’s put [Valhalla](https://valhalla.github.io/valhalla/)
    through its paces. Below are the steps, references, and code I used to run Valhalla
    on a Docker container.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我正在查看源地图匹配工具，以了解它在纠正缺陷重建方面的能力。因此，让我们对[Valhalla](https://valhalla.github.io/valhalla/)进行测试。以下是我用来在Docker容器中运行Valhalla的步骤、参考文献和代码。
- en: Valhalla Setup
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Valhalla 设置
- en: Here, I closely follow the instructions provided by [Sandeep Pandey](https://ikespand.github.io/posts/meili/)
    [2] on his blog.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我紧跟[桑迪普·潘迪](https://ikespand.github.io/posts/meili/) [2]在其博客上提供的说明。
- en: First, make sure that you have Docker installed on your machine. To install
    the Docker engine, please follow the [online instructions](https://docs.docker.com/engine/install/).
    If you work on a Mac, a great alternative is [Colima](https://github.com/abiosoft/colima).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保你的机器上已安装 Docker。要安装 Docker 引擎，请参阅 [在线说明](https://docs.docker.com/engine/install/)。如果你使用的是
    Mac，另一个很好的选择是 [Colima](https://github.com/abiosoft/colima)。
- en: Once installed, you must pull a Valhalla image from GitHub by issuing the following
    commands at your command line, as the shell code in **Figure 9** below depicts.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你必须从 GitHub 拉取一个 Valhalla 镜像，方法是按照下面的 **Figure 9** 所示在命令行中发出以下命令。
- en: '**Figure 9** — Pulling Valhalla’s docker image from the command line. (Image
    source: Author)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**Figure 9** — 从命令行拉取 Valhalla 的 Docker 镜像。（图片来源：作者）'
- en: While executing the above commands, you may have to enter your GitHub credentials.
    Also, ensure you have cloned this article’s [GitHub repository](https://github.com/joaofig/eved-explore),
    as some files and folder structures refer to it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行上述命令时，你可能需要输入你的 GitHub 凭据。此外，确保你已经克隆了本文的 [GitHub 仓库](https://github.com/joaofig/eved-explore)，因为一些文件和文件夹结构会引用它。
- en: 'Once done, you should open a new terminal window and issue the following command
    to start the Valhalla API server (MacOS, Linux, [WSL](https://learn.microsoft.com/en-us/windows/wsl/install)):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你应该打开一个新的终端窗口，并发出以下命令以启动 Valhalla API 服务器（MacOS、Linux、[WSL](https://learn.microsoft.com/en-us/windows/wsl/install/)）：
- en: '**Figure 10** — The above command runs the pulled Valhalla image in a Docker
    container. During first-time execution, the command also downloads and prepares
    the latest Geofabrik Michigan data file before starting. (Image source: Author)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**Figure 10** — 上述命令在 Docker 容器中运行拉取的 Valhalla 镜像。首次执行时，该命令还会在启动之前下载和准备最新的
    Geofabrik Michigan 数据文件。（图片来源：作者）'
- en: The command line above explicitly states which OSM file to download from the
    [Geofabrik](https://www.geofabrik.de/) service, the latest Michigan file. This
    specification means that when executed the first time, the server will download
    and process the file and generate an optimized database. In subsequent calls,
    the server omits these steps. When needed, delete everything under the target
    directory to refresh the downloaded data and spin up Docker again.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令行明确指定了要从 [Geofabrik](https://www.geofabrik.de/) 服务下载哪个 OSM 文件，即最新的 Michigan
    文件。这一指定意味着第一次执行时，服务器将下载并处理该文件并生成优化后的数据库。在后续调用中，服务器将省略这些步骤。需要时，删除目标目录下的所有内容以刷新下载的数据，并重新启动
    Docker。
- en: We can now call the Valhalla API with a specialized client.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用专用客户端调用 Valhalla API。
- en: Enter PyValhalla
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入 PyValhalla
- en: This spin-off project simply offers packaged Python bindings to the fantastic
    [Valhalla project](https://github.com/valhalla/valhalla).
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个衍生项目简单地提供了对精彩的 [Valhalla 项目](https://github.com/valhalla/valhalla) 的打包 Python
    绑定。
- en: Using the [PyValhalla](https://github.com/gis-ops/pyvalhalla) Python package
    is quite simple. We start with a neat install procedure using the following command
    line.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [PyValhalla](https://github.com/gis-ops/pyvalhalla) Python 包非常简单。我们从使用以下命令行进行的简洁安装过程开始。
- en: '**Figure 11** — You can install PyValhalla using PIP. (Image source: Author)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**Figure 11** — 你可以使用 PIP 安装 PyValhalla。（图片来源：作者）'
- en: In your Python code, you must import the required references, instantiate a
    configuration from the processed GeoFabrik files, and finally create an **Actor**
    object, your gateway to the Valhalla API.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 Python 代码中，你必须导入所需的引用，从处理后的 GeoFabrik 文件中实例化配置，最后创建一个 **Actor** 对象，这是你访问
    Valhalla API 的入口。
- en: '**Figure 12** — The code above shows how easy it is to set up PyValhalla on
    a Python application or notebook. (Image source: Author)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**Figure 12** — 上述代码展示了如何在 Python 应用程序或笔记本上轻松设置 PyValhalla。（图片来源：作者）'
- en: Before we call the [Meili](https://valhalla.github.io/valhalla/api/map-matching/api-reference/)
    map-matching service, we must get the trajectory GPS locations using the function
    listed below in **Figure 13**.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们调用 [Meili](https://valhalla.github.io/valhalla/api/map-matching/api-reference/)
    地图匹配服务之前，我们必须使用 **Figure 13** 中列出的函数获取轨迹 GPS 位置。
- en: '**Figure 13** — The function above loads the unique positions of a vehicle’s
    trajectory, returning a Pandas DataFrame with latitude, longitude, and timestamp.
    (Image source: Author)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**Figure 13** — 上述函数加载车辆轨迹的唯一位置，返回一个包含纬度、经度和时间戳的 Pandas DataFrame。（图片来源：作者）'
- en: We can now set up the parameter dictionary to pass into the PyValhalla call
    to trace the route. Please refer to the [Valhalla documentation](https://valhalla.github.io/valhalla/)
    for more details on these parameters. The function below calls the map-matching
    feature in Valhalla (Meili) and is included in the [data preparation script](https://github.com/joaofig/eved-explore/blob/main/match-trips.py).
    It illustrates how to determine the inferred route from a Pandas data frame containing
    the observed GPS locations encoded as latitude, longitude, and time tuples.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以设置参数字典以传递给 PyValhalla 调用以追踪路线。有关这些参数的更多细节，请参见 [Valhalla 文档](https://valhalla.github.io/valhalla/)。下面的函数调用了
    Valhalla（Meili）中的地图匹配功能，并包含在 [数据准备脚本](https://github.com/joaofig/eved-explore/blob/main/match-trips.py)
    中。它展示了如何从包含观测 GPS 位置的 Pandas 数据框中推断路线，这些位置编码为纬度、经度和时间元组。
- en: '**Figure 14** — The function above accepts a PyValhalla Actor object and a
    Pandas DataFrame containing the source path and returns a map-matched string-encoded
    polyline. This string is later decoded into a list of geospatial locations corresponding
    to the digital map network nodes, except for the extremities, which are edge-projected.
    (Image source: Author)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 14** — 上述函数接受一个 PyValhalla Actor 对象和一个包含源路径的 Pandas DataFrame，并返回一个地图匹配的字符串编码折线。这个字符串随后会解码为与数字地图网络节点对应的地理空间位置列表，极端位置除外，这些位置被投影到边缘上。（图片来源：作者）'
- en: The above function returns the matched path as a string-encoded polyline. As
    illustrated in the data preparation code below, we can easily decode the returned
    string using a PyValhalla library call. Note that this function returns a polyline
    whose first and last locations are projected to edges, not graph nodes. You will
    see these extremities removed by code later in the article.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数返回的匹配路径是字符串编码的折线。如下面的数据准备代码所示，我们可以使用 PyValhalla 库调用轻松解码返回的字符串。请注意，这个函数返回的是一条折线，其第一个和最后一个位置被投影到边缘，而不是图节点。您将看到这些极端位置在本文后面的代码中被去除。
- en: Let us now look at the data preparation phase, where we convert all the trajectories
    in the EVED database into a set of map edge sequences, from where we can derive
    pattern frequencies.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看数据准备阶段，我们将 EVED 数据库中的所有轨迹转换为一组地图边缘序列，从中我们可以导出模式频率。
- en: Data Preparation
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据准备
- en: Data preparation aims at converting the noisy GPS-acquired trajectories into
    sequences of geospatial tokens corresponding to known map locations. The main
    code iterates through the existing trips, processing one at a time.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 数据准备的目的是将噪声较大的 GPS 获取轨迹转换为对应于已知地图位置的地理空间标记序列。主要代码遍历现有的行程，一次处理一个。
- en: I use an SQLite database in this article to store all the data processing results.
    We start by filling the matched trajectory path. You can follow the description
    using the code in **Figure 15** below.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本文中使用 SQLite 数据库来存储所有数据处理结果。我们从填充匹配的轨迹路径开始。您可以参考下面的 **图 15** 中的代码描述。
- en: '**Figure 15** — The code above contains the preprocessing data loop. This loop
    iterates through the known trajectories, computes their map-matched paths (if
    any), tokenizes the nodes, and expands them into triplets. The code stores all
    intermediary and final results in the database. (Image source: Author)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 15** — 上述代码包含了预处理数据的循环。这个循环遍历已知的轨迹，计算它们的地图匹配路径（如果有的话），将节点分词，并将其扩展为三元组。代码将所有中间结果和最终结果存储在数据库中。（图片来源：作者）'
- en: For each trajectory, we instantiate an object of the **Actor** type (*line 9*).
    This is an unstated requirement, as each call to the map-matching service requires
    a new instance. Next, we load the trajectory points (*line 13*) acquired by the
    vehicles’ GPS receivers with the added noise, as stated in the original VED article.
    In line *14*, we make the map-matching call to Valhalla, retrieve the string-encoded
    matched path, and save it to the database. Next, we decode the string into a list
    of geospatial coordinates, remove the extremities (*line 17*), and then convert
    them to a list of H3 indices computed at level 15 (*line 19*). On line *23*, we
    save the converted H3 indices and the original coordinates to the database for
    later reverse mapping. Finally, on lines *25* to *27*, we generate a sequence
    of 3-tuples based on the H3 indices list and save them for later inference calculations.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每条轨迹，我们实例化一个**Actor**类型的对象（*第9行*）。这是一个未明确说明的要求，因为每次调用地图匹配服务都需要一个新实例。接下来，我们加载（*第13行*）车辆GPS接收器获取的轨迹点，这些点带有原始VED文章中提到的添加噪声。在*第14行*，我们调用Valhalla进行地图匹配，检索编码后的匹配路径并将其保存到数据库。接着，我们将编码后的字符串解码成一组地理空间坐标列表，去除两端极值（*第17行*），然后将其转换为计算在15级别H3网格上的H3索引列表（*第19行*）。在*第23行*，我们将转换后的H3索引和原始坐标保存到数据库，以便后续的反向映射。最后，在*第25*至*27*行，我们基于H3索引列表生成一系列3元组，并保存它们以便后续推断计算。
- en: Let’s go through each of these steps and explain them in detail.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分析每一个步骤，并详细解释它们。
- en: Trajectory Loading
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 轨迹加载
- en: We have seen how to load each trajectory from the database (see **Figure 13**).
    A trajectory is a time-ordered sequence of sampled GPS locations encoded as a
    latitude and longitude pair. Note that we are not using the matched versions of
    these locations as provided by the EVED data. Here, we use the noisy and original
    coordinates as they existed in the initial VED database.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何从数据库中加载每条轨迹（参见**图13**）。一条轨迹是一个按时间顺序排列的采样GPS位置序列，编码为纬度和经度对。请注意，我们没有使用EVED数据提供的匹配版本的这些位置。在这里，我们使用最初VED数据库中存在的带有噪声和原始坐标。
- en: Map Matching
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地图匹配
- en: The code that calls the map-matching service is already presented in **Figure
    14** above. Its central issue is the configuration settings; other than that,
    it is a pretty straightforward call. Saving the resulting encoded string to the
    database is also simple.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 调用地图匹配服务的代码已经在上文的**图14**中介绍过。其核心问题在于配置设置；除此之外，这是一个非常直接的调用。将结果编码后的字符串保存到数据库中也很简单。
- en: '**Figure 16** — The code above saves the encoded polyline string to the new
    database. (Image source: Author)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**图16** — 上述代码将编码后的折线字符串保存到新的数据库中。（图片来源：作者）'
- en: On line *17* of the main loop (**Figure 15**), we decode the geometry string
    into a list of latitude and longitude tuples. Note that this is where we strip
    out the initial and final locations, as they are not projected to nodes. Next,
    we convert this list to its corresponding H3 token list on line *19*. We use the
    maximum detail level to try and avoid overlaps and ensure a one-to-one relationship
    between H3 tokens and map graph nodes. We insert the tokens in the database in
    the following two lines. First, we save the whole token list, associating it to
    the trajectory.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在主循环的*第15图*中的第17行，我们将几何字符串解码为纬度和经度元组列表。请注意，这是我们剥离初始和最终位置的地方，因为它们没有投影到节点上。接下来，在*第19行*，我们将此列表转换为相应的H3标记列表。我们使用最大详细级别来尝试避免重叠，并确保H3标记与地图图形节点之间的一对一关系。在接下来的两行中，我们将这些标记插入数据库中。首先，我们保存整个标记列表，并将其与轨迹关联。
- en: '**Figure 17** — The function above inserts the trajectory H3 token list in
    the database. (Image source: Author)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**图17** — 上述函数将轨迹的H3标记列表插入数据库中。（图片来源：作者）'
- en: Next, we insert the mapping of node coordinates to H3 tokens to enable drawing
    polylines from a given list of tokens. This feature will be helpful later on when
    inferring future trip directions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们插入节点坐标到H3标记的映射，以便从给定的标记列表绘制折线。这一功能在推断未来行程方向时将会很有帮助。
- en: '**Figure 18** — We insert a mapping between H3 tokens and node coordinates
    to enable the reconstruction of a trajectory from given inferred tokens. (Image
    source: Author)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**图18** — 我们插入H3标记和节点坐标之间的映射，以便从给定的推断标记重构轨迹。（图片来源：作者）'
- en: We can now generate and save the corresponding token triples. The function below
    uses the newly generated list of H3 tokens and expands it to another list of triples,
    as detailed in **Figure 3** above. The expansion code is depicted in **Figure
    19** below.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以生成并保存相应的令牌三元组。下面的函数使用新生成的 H3 令牌列表并将其扩展为另一个三元组列表，如**图3**中详细说明的那样。扩展代码在**图19**中展示。
- en: '**Figure 19** — The code above converts a list of H3 tokens into a list of
    the corresponding triples. (Image source: Author)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**图19** — 上述代码将 H3 令牌列表转换为相应三元组的列表。（图片来源：作者）'
- en: After triplet expansion, we can finally save the final product to the database,
    as shown by the code in **Figure 20** below. Through clever querying of this table,
    we will infer current trip probabilities and future most likely trajectories.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在三重扩展之后，我们可以将最终产品保存到数据库中，如下方的**图20**所示。通过巧妙地查询这个表，我们将推断当前的三重概率和未来最可能的轨迹。
- en: '**Figure 20** — The function above saves the H3 triples to the database. This
    is the final step of the data preparation phase. We can now move on to exploring
    the information we collected. (Image source: Author)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**图20** — 上述函数将 H3 三元组保存到数据库中。这是数据准备阶段的最后一步。我们现在可以开始探索我们收集的信息。（图片来源：作者）'
- en: We are now done with one cycle of the data preparation loop. Once the outer
    loop is completed, we have a new database with all the trajectories converted
    to token sequences that we can explore at will.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了一轮数据准备循环。一旦外循环完成，我们将拥有一个新的数据库，所有轨迹都转换为令牌序列，我们可以随意探索。
- en: You can find the whole [data preparation code](https://github.com/joaofig/eved-explore/blob/main/match-trips.py)
    in the GitHub repository.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 仓库中找到完整的[数据准备代码](https://github.com/joaofig/eved-explore/blob/main/match-trips.py)。
- en: Probabilities and Predictions
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概率和预测
- en: We now turn to the problem of estimating existing trip probabilities and predicting
    future directions. Let’s start by defining what I mean by “existing trip probabilities.”
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在转向估计现有行程概率和预测未来方向的问题。让我们先定义一下“现有行程概率”的含义。
- en: Trip Probabilities
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行程概率
- en: We start with an arbitrary path projected into the road network nodes through
    map-matching. Thus, we have a sequence of nodes from the map and want to assess
    how probable that sequence is, using as a frequency reference the known trip database.
    We use the formula in **Figure 5** above. In a nutshell, we compute the product
    of the probabilities of all individual token triplets.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从通过地图匹配投影到道路网络节点的任意路径开始。因此，我们有一个来自地图的节点序列，并希望评估该序列的概率，使用已知的行程数据库作为频率参考。我们使用**图5**中的公式。简而言之，我们计算所有单独的三重组概率的乘积。
- en: To illustrate this feature, I implemented a simple [Streamlit application](https://github.com/joaofig/eved-explore/blob/main/map-predict.py)
    that allows the user to draw an arbitrary trip over the covered Ann Arbor area
    and immediately compute its probability.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一功能，我实现了一个简单的[Streamlit 应用程序](https://github.com/joaofig/eved-explore/blob/main/map-predict.py)，允许用户在覆盖的安娜堡区域绘制任意行程并立即计算其概率。
- en: Once the user draws points on the map representing the trip or the hypothetical
    GPS samples, the code map matches them to retrieve the underlying H3 tokens. From
    then on, it’s a simple matter of computing the individual triplet frequencies
    and multiplying them to compute the total probability. The function in **Figure
    21** below computes the probability of an arbitrary trip.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户在地图上绘制表示行程或假设 GPS 样本的点，代码会将它们进行地图匹配以检索底层的 H3 令牌。从那时起，只需计算单个三重组的频率并将其相乘即可计算总概率。**图21**中的函数计算任意行程的概率。
- en: '**Figure 21** — The function above computes an arbitrary path probability from
    the triplet frequency database. (Image source: Author)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**图21** — 上述函数从三重频率数据库中计算任意路径的概率。（图片来源：作者）'
- en: The code gets support from another function that retrieves the successors of
    any existing pair of H3 tokens. The function listed below in **Figure 22** queries
    the frequency database and returns a Python **Counter** object with the counts
    of all successors of the input token pair. When the query finds no successors,
    the function returns the **None** constant. Note how the function uses a cache
    to improve database access performance (code not listed here).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码得到另一个函数的支持，该函数检索任何现有的 H3 令牌对的后继。下列函数在**图 22**中列出，查询频率数据库并返回一个 Python **Counter**
    对象，包含输入令牌对所有后继的计数。当查询未找到后继时，函数返回**None** 常量。注意该函数如何使用缓存以提高数据库访问性能（此处未列出代码）。
- en: '**Figure 22** — The function above queries the frequency database for the known
    successors of any pair of H3 tokens and returns a Counter object with the counts
    of all successors. (Image source: Author)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 22** — 上述函数查询频率数据库以获取任何一对 H3 令牌的已知后继，并返回一个包含所有后继计数的 Counter 对象。(图片来源：作者)'
- en: I designed both functions such that the computed probability is zero when no
    known successors exist for any given node.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我设计了这两个函数，使得在任何给定节点没有已知后继时，计算的概率为零。
- en: Let us look at how we can predict a trajectory’s most probable future path.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何预测轨迹的最可能未来路径。
- en: Predicting Directions
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预测方向
- en: We only need the last two tokens from a given running trip to predict its most
    likely future directions. The idea involves expanding all the successors of that
    token pair and selecting the most frequent ones. The code below shows the function
    as the entry point to the directions prediction service.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要从给定的运行轨迹中获取最后两个令牌，以预测其最可能的未来方向。这个想法涉及扩展该令牌对的所有后继，并选择最频繁的那些。下面的代码展示了作为方向预测服务入口点的函数。
- en: '**Figure 23** — The function above populates a FeatureGroup object from Folium
    with the predicted paths of the existing user-provided trip. (Image source: Author)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 23** — 上述函数从 Folium 中填充一个 FeatureGroup 对象，包含现有用户提供的轨迹的预测路径。(图片来源：作者)'
- en: 'The above function starts by retrieving the user-drawn trajectory as a list
    of map-matched H3 tokens and extracting the last pair. We call this token pair
    the *seed* and will expand it further in the code. At line *9,* we call the seed-expansion
    function that returns a list of polylines corresponding to the input expansion
    criteria: the maximum branching per iteration and the total number of iterations.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数首先通过检索用户绘制的轨迹作为一组与地图匹配的 H3 令牌，并提取最后一对。我们将这一对令牌称为*种子*，并将在代码中进一步扩展它。在*第 9
    行*，我们调用种子扩展函数，该函数返回一个与输入扩展标准对应的折线列表：每次迭代的最大分支数和总迭代次数。
- en: Let us see how the seed expansion function works by following the code listed
    below in **Figure 24**.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看下列代码了解种子扩展函数的工作原理，如**图 24**所示。
- en: '**Figure 24** — The seed expansion function uses the PredictedPath class to
    manage each iteration. Please see below for more details on this class. (Image
    source: Author)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 24** — 种子扩展函数使用 PredictedPath 类来管理每次迭代。有关该类的更多详细信息，请见下文。(图片来源：作者)'
- en: By calling a path expansion function that generates the best successor paths,
    the seed expansion function iteratively expands paths, starting with the initial
    one. Path expansion operates by picking a path and generating the most probable
    expansions, as shown below in **Figure 25**.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用生成最佳后继路径的路径扩展函数，种子扩展函数迭代地扩展路径，从初始路径开始。路径扩展通过选择一条路径并生成最可能的扩展，如**图 25**所示。
- en: '**Figure 25** — The path expansion function above iterates the most frequent
    successors to the current path. It creates a new path for each of the most frequent
    successors using a specialized function (see below). (Image source: Author)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 25** — 上述路径扩展函数迭代当前路径的最频繁后继。它为每个最频繁的后继创建一条新路径，使用一个专门的函数（见下文）。(图片来源：作者)'
- en: The code generates new paths by appending the successor nodes to the source
    path, as shown in **Figure 26** below.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码通过将后继节点附加到源路径上来生成新路径，如下**图 26**所示。
- en: '**Figure 26** — To generate a “child” path, we only need to append the successor
    node to an existing path, as shown below. Note that the code creates a copy of
    the original path before appending the new node. (Image source: Author)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 26** — 要生成“子”路径，我们只需将后继节点附加到现有路径上，如下所示。注意，代码在附加新节点之前创建了原始路径的副本。(图片来源：作者)'
- en: The code implements predicted paths using a specialized class, as shown in **Figure
    27**.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码使用一个专门的类来实现预测路径，如**图 27**所示。
- en: '**Figure 27** — The class above implements a predicted path with probability
    sorting support, creation from a seed token pair, and map polyline generation.
    (Image source: Author)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 27** — 上述类实现了一个具有概率排序支持的预测路径，基于种子令牌对进行创建，并生成地图折线。（图片来源：作者）'
- en: The Application
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用
- en: We can now see the resulting [Streamlit application](https://github.com/joaofig/eved-explore/blob/main/map-predict.py)
    in **Figure 28** below.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以在下面的**图 28**中查看结果 [Streamlit应用程序](https://github.com/joaofig/eved-explore/blob/main/map-predict.py)。
- en: '![](../Images/058ee4d531abec3ba6917f9a2656d4d6.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/058ee4d531abec3ba6917f9a2656d4d6.png)'
- en: '**Figure 28** — The Streamlit application shows the two described features
    in action. The input trajectory is in blue, and you can draw it using the tool
    menu on the left-hand side of the map. Once drawn, the code computes its probability
    and displays it at the bottom. The three red trajectories are the three most likely
    fifty-edge predictions for where the source trajectory may evolve. You get a popup
    with the computed probability by clicking on each trajectory. (Image source: Author)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 28** — Streamlit应用程序展示了两个描述的功能。输入轨迹为蓝色，可以使用地图左侧的工具菜单绘制。一旦绘制完成，代码将计算其概率并在底部显示。三条红色轨迹是源轨迹可能演变的三个最可能的五十边预测。点击每条轨迹可以弹出计算出的概率。（图片来源：作者）'
- en: Conclusion
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: In this article, I presented a means to predict a vehicle’s future trajectory
    when driving through a digitally mapped road network. Using a historical trajectory
    database, this method assigns a probability to any trip and also predicts the
    most likely directions for the near future. Consequently, this method can detect
    unlikely or even novel trajectories never seen before.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇文章中，我介绍了一种预测车辆在数字地图道路网络中未来轨迹的方法。利用历史轨迹数据库，该方法为任何行程分配一个概率，并预测近期最可能的方向。因此，这种方法可以检测到不太可能的或甚至是前所未见的新轨迹。
- en: We start with an extensive database of vehicle trajectories from the area of
    interest. Each path is a chronological sequence of geospatial coordinates (latitude
    and longitude) and other relevant properties such as speed. We typically collect
    these trajectories from onboard GPS receivers and centrally compile them into
    a database.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从感兴趣区域的大量车辆轨迹数据库开始。每条路径都是地理坐标（纬度和经度）的时间顺序序列，以及其他相关属性，如速度。我们通常从车载GPS接收器收集这些轨迹，并将其集中编入数据库。
- en: GPS samples are noisy due to unavoidable errors that occur during signal measurement.
    Natural and artificial obstacles, such as urban canyons, can significantly decrease
    the signal’s reception accuracy and increase geolocation errors. Fortunately,
    workable solutions solve this issue by probabilistically matching the GPS samples
    to a digital map. This is what map matching is all about.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: GPS样本由于信号测量过程中不可避免的误差而产生噪声。自然和人工障碍物，如城市峡谷，可能显著降低信号的接收精度并增加地理位置误差。幸运的是，实用的解决方案通过概率匹配将GPS样本与数字地图对齐来解决这个问题。这就是地图匹配的全部内容。
- en: By matching the noisy GPS samples to a known digital map, we not only correct
    the accuracy problem by projecting each instance to the map’s most likely road
    segment, but we also get a discrete sequence of existing map-defined locations
    that the vehicle most likely went through. This last result is instrumental for
    our trajectory prediction because it essentially converts a set of noisy GPS coordinates
    into a clean and well-known collection of points in the digital map. These digital
    markers are fixed and never change, and by projecting the GPS sample sequence
    into them, we get a string of well-known tokens that we can later use for prediction.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将嘈杂的GPS样本与已知数字地图进行匹配，我们不仅通过将每个实例投影到地图上最可能的道路段来纠正精度问题，还获得了一系列车辆最可能经过的现有地图定义的位置。这个最后的结果对我们的轨迹预测至关重要，因为它本质上将一组嘈杂的GPS坐标转换为数字地图中干净且已知的点集。这些数字标记是固定的，不会改变，通过将GPS样本序列投影到这些标记中，我们得到一串已知的令牌，稍后可以用于预测。
- en: We calculate all probabilities using the known token sequence frequencies for
    arbitrary trajectories and their future evolution. The result is a couple of Python
    scripts, one for data preparation and another for data input and visualization
    using the Streamlit platform.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用已知令牌序列频率来计算所有概率，这些序列代表任意轨迹及其未来演变。结果是几个Python脚本，一个用于数据准备，另一个用于使用Streamlit平台进行数据输入和可视化。
- en: Notes
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 备注
- en: The original paper authors licensed the dataset under the Apache 2.0 License
    (see the [VED](https://github.com/gsoh/VED) and [EVED](https://github.com/zhangsl2013/eVED)
    GitHub repositories). Note that this also applies to derivative work.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始论文作者将数据集以 Apache 2.0 许可证进行授权（参见 [VED](https://github.com/gsoh/VED) 和 [EVED](https://github.com/zhangsl2013/eVED)
    GitHub 存储库）。请注意，这也适用于衍生作品。
- en: References
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: '**[1]** Zhang, S., Fatih, D., Abdulqadir, F., Schwarz, T., & Ma, X. (2022).
    Extended vehicle energy dataset (eVED): an enhanced large-scale dataset for deep
    learning on vehicle trip energy consumption. *arXiv*. [https://doi.org/10.48550/arXiv.2203.08630](https://doi.org/10.48550/arXiv.2203.08630)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**[1]** 张三、Fatih、Abdulqadir、Schwarz、和马晓（2022）。扩展车辆能源数据集（eVED）：一个用于深度学习车辆行程能源消耗的增强型大规模数据集。*arXiv*。
    [https://doi.org/10.48550/arXiv.2203.08630](https://doi.org/10.48550/arXiv.2203.08630)'
- en: '**[2]** [Efficient and fast map matching with Valhalla — Sandeep Pandey (ikespand.github.io)](https://ikespand.github.io/posts/meili/)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**[2]** [Valhalla的高效快速地图匹配 — Sandeep Pandey（ikespand.github.io）](https://ikespand.github.io/posts/meili/)'
- en: '**[3]** [Map Matching done right using Valhalla’s Meili | by Serge Zotov |
    Towards Data Science](/map-matching-done-right-using-valhallas-meili-f635ebd17053)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**[3]** [使用 Valhalla 的 Meili 正确完成地图匹配 | by Serge Zotov | Towards Data Science](/map-matching-done-right-using-valhallas-meili-f635ebd17053)'
- en: João Paulo Figueira is a Data Scientist at [tb.lx by Daimler Truck](https://tblx.io/)
    in Lisbon, Portugal.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: João Paulo Figueira 是 [tb.lx by Daimler Truck](https://tblx.io/) 在葡萄牙里斯本的数据科学家。
