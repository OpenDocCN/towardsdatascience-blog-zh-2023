["```py\nnum_tiles = 9\nnum_dice = 2\nnum_states = (2**num_tiles)+1 # +1 for the game over/lose state\n```", "```py\n# Generate representation of all possible states\ntile_nums = [i for i in range(1, num_tiles+1)]\nstates = []\nfor i in range(0, 2**num_tiles):\n  binary_rep = np.binary_repr(int(i), width=num_tiles)\n  states.append([tile_nums[idx] for idx, a in enumerate(binary_rep) if a == '1'])\n```", "```py\n# Generate transition matrix\ntransition_matrix = np.zeros((num_states, num_states))\nfor i in range(num_states):\n  for j in range(num_states):\n    transition_matrix[i][j] = compute_transition_probability(i, j)\n  transition_matrix[i][num_states-1] = 1 - transition_matrix[i][:num_states-1].sum()\n  assert np.allclose(transition_matrix[i].sum(), 1), \"Transition matrix is not stochastic\"\n```", "```py\n# Define the initial state distribution\ninit_state_dist = np.zeros((1, num_states))\ninit_state_dist[:, num_states-2] = 1\n```", "```py\n# Compute and print the win and lose probabilities\nt = 9\nmultiple_transition_matrix = np.linalg.matrix_power(transition_matrix, t)\nfinal_dist = np.matmul(init_state_dist, multiple_transition_matrix)\n\nwin_prob = final_dist[0, 0]\nlose_prob = final_dist[0, num_states-1]\n\n# Print results to 4 decimal places\nprint(\"Win Probability: {:.4f}\".format(win_prob))\nprint(\"Lose Probability: {:.4f}\".format(lose_prob))\n```"]