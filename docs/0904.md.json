["```py\nSELECT AVG((expected_value - conversion_cost) * conversion - impression_cost)\nFROM preds_and_ground_truth\nWHERE predicted_treatment = ground_truth_treatment;\n```", "```py\ndf, X_names = make_uplift_classification(\n    n_samples=5000,\n    treatment_name=[\"control\", \"treatment1\", \"treatment2\"],\n    positive_class_proportion=0.1,\n)\n```", "```py\ndf['expected_value'] = np.abs(df['x6_irrelevant']) * 20 + np.random.normal(0, 5)\n```", "```py\n# Put costs into dicts\nconversion_cost_dict = {\"control\": 0, \"treatment1\": 2.5, \"treatment2\": 10}\nimpression_cost_dict = {\"control\": 0, \"treatment1\": 0, \"treatment2\": 0.02}\n\n# Use a helper function to put treatment costs to array\ncc_array, ic_array, conditions = get_treatment_costs(\n    treatment=df[\"treatment_group_key\"],\n    control_name=\"control\",\n    cc_dict=conversion_cost_dict,\n    ic_dict=impression_cost_dict,\n)\n\n# Put the conversion value into an array\nconversion_value_array = df['expected_value'].to_numpy()\n```", "```py\nactual_value = get_actual_value(\n    treatment=df[\"treatment_group_key\"],\n    observed_outcome=df[\"conversion\"],\n    conversion_value=conversion_value_array,\n    conditions=conditions,\n    conversion_cost=cc_array,\n    impression_cost=ic_array,\n)\n```", "```py\ntest_actual_value = actual_value.loc[test_idx]\nrandom_treatments = pd.Series(\n    np.random.choice(conditions, test_idx.shape[0]), index=test_idx\n)\ntest_treatments = df.loc[test_idx, \"treatment_group_key\"]\nrandom_allocation_value = test_actual_value[test_treatments == random_treatments]\n```", "```py\nbest_ate = df_train.groupby(\"treatment_group_key\")[\"conversion\"].mean().idxmax()\n\nactual_is_best_ate = df_test[\"treatment_group_key\"] == best_ate\n\nbest_ate_value = actual_value.loc[test_idx][actual_is_best_ate]\n```", "```py\ntest_value = actual_value.loc[test_idx]\nbest_value = test_value[test_value >= 0]\n```", "```py\nxm = XLearner()\nencoder = {\"control\": 0, \"treatment1\": 1, \"treatment2\": 2}\nX = df.loc[train_idx, X_names].to_numpy()\ny = df.loc[train_idx, \"conversion\"].to_numpy()\nT = np.array([encoder[x] for x in df.loc[train_idx, \"treatment_group_key\"]])\n\nxm.fit(X, y, T)\n```", "```py\nX_test = df.loc[test_idx, X_names].to_numpy()\nxm_pred = xm.predict(X_test).drop(0, axis=1)\nxm_best = xm_pred.idxmax(axis=1)\nxm_best = [conditions[idx] for idx in xm_best]\n\nactual_is_xm_best = df_test[\"treatment_group_key\"] == xm_best\nxm_value = actual_value.loc[test_idx][actual_is_xm_best]\n```", "```py\nproba_model = lgb.LGBMClassifier()\n\nW_dummies = pd.get_dummies(df[\"treatment_group_key\"])\nXW = np.c_[df[X_names], W_dummies]\n\nproba_model.fit(XW[train_idx], df_train[\"conversion\"])\ny_proba = proba_model.predict_proba(XW[test_idx])[:, 1]\n```", "```py\nexpected_value_model = lgb.LGBMRegressor()\nexpected_value_model.fit(XW[train_idx], df_train['expected_value'])\npred_conv_value = expected_value_model.predict(XW[test_idx])\n```", "```py\ncve = CounterfactualValueEstimator(\n    treatment=df_test[\"treatment_group_key\"],\n    control_name=\"control\",\n    treatment_names=conditions[1:],  # idx 0 is control\n    y_proba=y_proba,\n    cate=xm_pred,\n    value=pred_conv_value,\n    conversion_cost=cc_array[test_idx],\n    impression_cost=ic_array[test_idx],\n)\n```", "```py\ncve_best_idx = cve.predict_best()\ncve_best = [conditions[idx] for idx in cve_best_idx]\nactual_is_cve_best = df.loc[test_idx, \"treatment_group_key\"] == cve_best\ncve_value = actual_value.loc[test_idx][actual_is_cve_best]\n```", "```py\nnvex = XLearner(ic_lookup=ic_lookup, cc_lookup=cc_lookup)\n\nX = df.loc[train_idx, X_names].to_numpy()\ny = df.loc[train_idx, \"conversion\"].to_numpy()\nT = np.array([encoder[x] for x in df.loc[train_idx, \"treatment_group_key\"]])\nvalue = df.loc[train_idx, \"expected_value\"].to_numpy()\n\nnvex.fit(X, y, T, value)\n```"]