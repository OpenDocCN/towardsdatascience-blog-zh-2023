["```py\n pip install cfnow\n```", "```py\nimport warnings\n\nimport pandas as pd\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.metrics import accuracy_score\nwarnings.filterwarnings(\"ignore\", message=\"X does not have valid feature names, but RandomForestClassifier was fitted with feature names\")\n```", "```py\n# Make the classifier\nimport warnings\n\nimport pandas as pd\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.metrics import accuracy_score\nwarnings.filterwarnings(\"ignore\", message=\"X does not have valid feature names, but RandomForestClassifier was fitted with feature names\")\n\n# Load the Adult dataset\ndataset_url = \"https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data\"\ncolumn_names = ['age', 'workclass', 'fnlwgt', 'education', 'education-num', 'marital-status',\n                'occupation', 'relationship', 'race', 'sex', 'capital-gain', 'capital-loss',\n                'hours-per-week', 'native-country', 'income']\n\ndata = pd.read_csv(dataset_url, names=column_names, na_values=\" ?\", skipinitialspace=True)\n\n# Drop rows with missing values\ndata = data.dropna()\n\n# Identify the categorical features that are not binary\nnon_binary_categoricals = [column for column in data.select_dtypes(include=['object']).columns \n                           if len(data[column].unique()) > 2]\n\nbinary_categoricals = [column for column in data.select_dtypes(include=['object']).columns \n                       if len(data[column].unique()) == 2]\n\ncols_numericals = [column for column in data.select_dtypes(include=['int64']).columns]\n\n# Apply one-hot encoding to the non-binary categorical features\ndata = pd.get_dummies(data, columns=non_binary_categoricals)\n\n# Convert the binary categorical features into numbers\n# This will also binarize the target variable (income)\nfor bc in binary_categoricals:\n    data[bc] = data[bc].apply(lambda x: 1 if x == data[bc].unique()[0] else 0)\n\n# Split the dataset into features and target variable\nX = data.drop('income', axis=1)\ny = data['income']\n\n# Split the dataset into training and testing sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n\n# Initialize a RandomForestClassifier\nclf = RandomForestClassifier(random_state=42)\n\n# Train the classifier\nclf.fit(X_train, y_train)\n\n# Make predictions on the testing set\ny_pred = clf.predict(X_test)\n\n# Evaluate the classifier\naccuracy = accuracy_score(y_test, y_pred)\nprint(\"Accuracy:\", accuracy)\n```", "```py\nclf.predict([X_test.iloc[0]])\n# Result: 0 -> High income\n```", "```py\nfrom cfnow import find_tabular\n# Then, we use CFNOW to generate the minimum modification to change the classification\ncf_res = find_tabular(\n    factual=X_test.iloc[0],\n    feat_types={c: 'num' if c in cols_numericals else 'cat' for c in X.columns},\n    has_ohe=True,\n    model_predict_proba=clf.predict_proba,\n    limit_seconds=60)\n```", "```py\nclf.predict([cf_obj.cfs[0]])\n# Result: 1-> Low income\n```", "```py\npip install cfnow\n```", "```py\npip install torch torchvision Pillow requests\n```", "```py\nimport requests\nimport numpy as np\nfrom PIL import Image\nfrom torchvision import models, transforms\nimport torch\n\n# Load a pre-trained ResNet model\nmodel = models.resnet50(pretrained=True)\nmodel.eval()\n\n# Define the image transformation\ntransform = transforms.Compose([\n    transforms.Resize(256),\n    transforms.CenterCrop(224),\n    transforms.ToTensor(),\n    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),\n])\n\n# Fetch an image from the web\nimage_url = \"https://upload.wikimedia.org/wikipedia/commons/thumb/4/41/Sunflower_from_Silesia2.jpg/320px-Sunflower_from_Silesia2.jpg\"\nresponse = requests.get(image_url, stream=True)\nimage = np.array(Image.open(response.raw))\n\ndef predict(images):\n    if len(np.shape(images)) == 4:\n        # Convert the list of numpy arrays to a batch of tensors\n        input_images = torch.stack([transform(Image.fromarray(image.astype('uint8'))) for image in images])\n    elif len(np.shape(images)) == 3:\n        input_images = transform(Image.fromarray(images.astype('uint8')))\n    else:\n        raise ValueError(\"The input must be a list of images or a single image.\")\n\n    # Check if a GPU is available and if not, use a CPU\n    device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n    input_images = input_images.to(device)\n    model.to(device)\n\n    # Perform inference\n    with torch.no_grad():\n        outputs = model(input_images)\n\n    # Return an array of prediction scores for each image\n    return torch.asarray(outputs).cpu().numpy()\n\nLABELS_URL = \"https://raw.githubusercontent.com/anishathalye/imagenet-simple-labels/master/imagenet-simple-labels.json\"\ndef predict_label(outputs):\n    # Load the labels used by the pre-trained model\n    labels = requests.get(LABELS_URL).json()\n\n    # Get the predicted labels\n    predicted_idxs = [np.argmax(od) for od in outputs]\n    predicted_labels = [labels[idx.item()] for idx in predicted_idxs]\n\n    return predicted_labels\n\n# Check the prediction for the image\npredicted_label = predict([np.array(image)])\nprint(\"Predicted labels:\", predict_label(predicted_label))\n```", "```py\nfrom cfnow import find_image\n\ncf_img = find_image(img=image, model_predict=predict)\n\ncf_img_hl = cf_img.cfs[0]\nprint(\"Predicted labels:\", predict_label(predict([cf_img_hl])))\n\n# Show the CF image\nImage.fromarray(cf_img_hl.astype('uint8'))\n```", "```py\npip install cfnow\n```", "```py\npip install transformers\n```", "```py\nfrom transformers import DistilBertTokenizer, DistilBertForSequenceClassification\nfrom transformers import pipeline\n\nimport numpy as np\n\n# Load pre-trained model and tokenizer for sentiment analysis\nmodel_name = \"distilbert-base-uncased-finetuned-sst-2-english\"\ntokenizer = DistilBertTokenizer.from_pretrained(model_name)\nmodel = DistilBertForSequenceClassification.from_pretrained(model_name)\n\n# Define the sentiment analysis pipeline\nsentiment_analysis = pipeline(\"sentiment-analysis\", model=model, tokenizer=tokenizer)\n\n# Define a simple dataset\ntext_factual = \"I liked this movie because it was funny but my friends did not like it because it was too long and boring.\"\n\nresult = sentiment_analysis(text_factual)\nprint(f\"{text_factual}: {result[0]['label']} (confidence: {result[0]['score']:.2f})\")\n\ndef pred_score_text(list_text):\n    if type(list_text) == str:\n        sa_pred = sentiment_analysis(list_text)[0]\n        sa_score = sa_pred['score']\n        sa_label = sa_pred['label']\n        return sa_score if sa_label == \"POSITIVE\" else 1.0 - sa_score\n    return np.array([sa[\"score\"] if sa[\"label\"] == \"POSITIVE\" else 1.0 - sa[\"score\"] for sa in sentiment_analysis(list_text)])\n```", "```py\nfrom cfnow import find_text\ncf_text = find_text(text_input=text_factual, textual_classifier=pred_score_text)\nresult_cf = sentiment_analysis(cf_text.cfs[0])\nprint(f\"CF: {cf_text.cfs[0]}: {result_cf[0]['label']} (confidence: {result_cf[0]['score']:.2f})\")\n```"]