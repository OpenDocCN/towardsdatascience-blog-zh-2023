["```py\nimport pydantic\nclass RpgCharacterModel(pydantic.BaseModel):\n    CREATION_DATE: datetime\n    NAME: str = pydantic.Field(...)\n    GENDER: GenderEnum\n    RACE: RaceEnum = pydantic.Field(...)\n    CLASS: ClassEnum = pydantic.Field(...)\n    HOME: str\n    GUILD: str\n    PAY: int = pydantic.Field(..., ge=1, le=500)\n```", "```py\nimport pydantic\nclass RpgRaceModelBasic(pydantic.BaseModel):\n    RACE_ID: int = pydantic.Field(..., ge=10, le=99)\n    RACE: RaceEnum = pydantic.Field(...)\n    HP_MODIFIER_PER_LEVEL: int = pydantic.Field(..., ge=-6, le=6)\n    STR_MODIFIER: int = pydantic.Field(..., ge=-6, le=6, description=\"Character's strength\")\n    CON_MODIFIER: int = pydantic.Field(..., ge=-6, le=6, description=\"Character's strength\")\n    DEX_MODIFIER: int = pydantic.Field(..., ge=-6, le=6, description=\"Character's strength\")\n    INT_MODIFIER: int = pydantic.Field(..., ge=-6, le=6, description=\"Character's strength\")\n    WIS_MODIFIER: int = pydantic.Field(..., ge=-6, le=6, description=\"Character's strength\")\n    CHR_MODIFIER: int = pydantic.Field(..., ge=-6, le=6, description=\"Character's strength\")\n```", "```py\nimport functools\nimport pydantic\n\nid_partial = functools.partial(pydantic.Field, ..., ge=10, le=99)\nattribute_partial = functools.partial(pydantic.Field, ..., ge=-6, le=6)\n\nclass RpgRaceModelDry(pydantic.BaseModel):\n    RACE_ID: int = id_partial(..., ge=10, le=99)\n    RACE: RaceEnum = pydantic.Field(...)\n    HP_MODIFIER_PER_LEVEL: int = attribute_partial()\n    STR_MODIFIER: int = attribute_partial(description=\"Character's strength\")\n    CON_MODIFIER: int = attribute_partial(description=\"Character's constitution\")\n    DEX_MODIFIER: int = attribute_partial(description=\"Character's dexterity\")\n    INT_MODIFIER: int = attribute_partial(description=\"Character's intelligence\")\n    WIS_MODIFIER: int = attribute_partial(description=\"Character's wisdom\")\n    CHR_MODIFIER: int = attribute_partial(description=\"Character's charisma\")\n```", "```py\nimport enum\nimport pydantic\n\nclass AttributeEnum(enum.Enum):\n    STR = 'STR'\n    DEX = 'DEX'\n    CON = 'CON'\n    INT = 'INT'\n    WIS = 'WIS'\n    CHR = 'CHR'\n\nclass AlignmentEnum(enum.Enum):\n    LAWFUL_GOOD = 'Lawful Good'\n    LAWFUL_NEUTRAL = 'Lawful Neutral'\n    LAWFUL_EVIL = 'Lawful Evil'\n    NEUTRAL_GOOD = 'Neutral Good'\n    TRUE_NEUTRAL = 'True Neutral'\n    NEUTRAL_EVIL = 'Neutral Evil'\n    CHAOTIC_GOOD = 'Chaotic Good'\n    CHAOTIC_NEUTRAL = 'Chaotic Neutral'\n    CHAOTIC_EVIL = 'Chaotic Evil'\n\nclass RpgClassModel(pydantic.BaseModel):\n    CLASS_ID: int = id_partial()\n    CLASS: ClassEnum = pydantic.Field(...)\n    PRIMARY_CLASS_ATTRIBUTE: AttributeEnum = pydantic.Field(...)\n    SPELLCASTER: bool = pydantic.Field(...)\n\nclass RpgPolityModel(pydantic.BaseModel):\n    KINGDOM_ID: int = id_partial(ge=100, le=999)\n    POLITY: str = pydantic.Field(...)\n    TYPE: str = pydantic.Field(...)\n\nclass RpgGuildModel(pydantic.BaseModel):\n    GUILD_ID: int = id_partial(ge=100, le=999)\n    GUILD: str = pydantic.Field(...)\n    ALIGNMENT: AlignmentEnum\n    WEEKLY_DUES: int = pydantic.Field(..., ge=10, le=100)\n```", "```py\nimport pydantic\nclass RpgCharacterModel(pydantic.BaseModel):\n    CREATION_DATE: datetime\n    NAME: str = pydantic.Field(...)\n    GENDER: GenderEnum\n    RACE_NESTED: RpgRaceModelDry = pydantic.Field(...)\n    CLASS_NESTED: RpgClassModel = pydantic.Field(...)\n    HOME_NESTED: RpgPolityModel\n    GUILD_NESTED: RpgGuildModel\n    PAY: int = pydantic.Field(..., ge=1, le=500)\n```", "```py\n# Standard Library imports\nfrom datetime import datetime\nimport enum\nimport functools\n\n# 3rd Party package imports\nimport pydantic\n\n# Enums for limiting string data in our model\n\nclass GenderEnum(enum.Enum):\n    M = 'M'\n    F = 'F'\n    NB = 'NB'\n\nclass ClassEnum(enum.Enum):\n    Druid = 'Druid'\n    Fighter = 'Fighter'\n    Warlock = 'Warlock'\n    Ranger = 'Ranger'\n    Bard = 'Bard'\n    Sorcerer = 'Sorcerer'\n    Paladin = 'Paladin'\n    Rogue = 'Rogue'\n    Wizard = 'Wizard'\n    Monk = 'Monk'\n    Barbarian = 'Barbarian'\n    Cleric = 'Cleric'\n\nclass RaceEnum(enum.Enum):\n    Human = 'Human'\n    Dwarf = 'Dwarf'\n    Halfling = 'Halfling'\n    Elf = 'Elf'\n    Dragonborn = 'Dragonborn'\n    Tiefling = 'Tiefling'\n    Half_Orc = 'Half-Orc'\n    Gnome = 'Gnome'\n    Half_Elf = 'Half-Elf'\n\nclass AttributeEnum(enum.Enum):\n    STR = 'STR'\n    DEX = 'DEX'\n    CON = 'CON'\n    INT = 'INT'\n    WIS = 'WIS'\n    CHR = 'CHR'\n\nclass AlignmentEnum(enum.Enum):\n    LAWFUL_GOOD = 'Lawful Good'\n    LAWFUL_NEUTRAL = 'Lawful Neutral'\n    LAWFUL_EVIL = 'Lawful Evil'\n    NEUTRAL_GOOD = 'Neutral Good'\n    TRUE_NEUTRAL = 'True Neutral'\n    NEUTRAL_EVIL = 'Neutral Evil'\n    CHAOTIC_GOOD = 'Chaotic Good'\n    CHAOTIC_NEUTRAL = 'Chaotic Neutral'\n    CHAOTIC_EVIL = 'Chaotic Evil'\n\n# partial function for siloing our logic in one place:\nid_partial = functools.partial(pydantic.Field, ..., ge=10, le=99))\nattribute_partial = functools.partial(pydantic.Field, ..., ge=-6, le=6)\n\n# models that make up our main model\n\nclass RpgRaceModelDry(pydantic.BaseModel):\n    RACE_ID: int = id_partial()\n    RACE: RaceEnum = pydantic.Field(...)\n    HP_MODIFIER_PER_LEVEL: int = attribute_partial()\n    STR_MODIFIER: int = attribute_partial()\n    CON_MODIFIER: int = attribute_partial()\n    DEX_MODIFIER: int = attribute_partial()\n    INT_MODIFIER: int = attribute_partial()\n    WIS_MODIFIER: int = attribute_partial()\n    CHR_MODIFIER: int = attribute_partial()\n\nclass RpgClassModel(pydantic.BaseModel):\n    CLASS_ID: int = id_partial()\n    CLASS: ClassEnum = pydantic.Field(...)\n    PRIMARY_CLASS_ATTRIBUTE: AttributeEnum = pydantic.Field(...)\n    SPELLCASTER: bool = pydantic.Field(...)\n\nclass RpgPolityModel(pydantic.BaseModel):\n    KINGDOM_ID: int = id_partial(ge=100, le=999)\n    POLITY: str = pydantic.Field(...)\n    TYPE: str = pydantic.Field(...)\n\nclass RpgGuildModel(pydantic.BaseModel):\n    GUILD_ID: int = id_partial(ge=100, le=999)\n    GUILD: str = pydantic.Field(...)\n    ALIGNMENT: AlignmentEnum\n    WEEKLY_DUES: int = pydantic.Field(..., ge=10, le=100)\n\n# Our top level model:\nclass RpgCharacterModel(pydantic.BaseModel):\n    CREATION_DATE: datetime\n    NAME: str = pydantic.Field(...)\n    GENDER: GenderEnum\n    RACE_NESTED: RpgRaceModelDry = pydantic.Field(...)\n    CLASS_NESTED: RpgClassModel = pydantic.Field(...)\n    HOME_NESTED: RpgPolityModel\n    GUILD_NESTED: RpgGuildModel\n    PAY: int = pydantic.Field(..., ge=1, le=500)\n\n# We didn't talk about this one, but from a previous article,\n# this validates each row of data\n\ndef validate_data(list_o_dicts, model: pydantic.BaseModel, index_offset: int = 0):\n    list_of_dicts_copy = list_o_dicts.copy()\n    #capturing our good data and our bad data\n    good_data = []\n    bad_data = []\n    for index, row in enumerate(list_of_dicts_copy):\n        try:\n            model(**row)  #unpacks our dictionary into our keyword arguments\n            good_data.append(row)  #appends valid data to a new list of dictionaries\n        except pydantic.ValidationError as e:\n            # Adds all validation error messages associated with the error\n            # and adds them to the dictionary\n            row['Errors'] = [error_message for error_message in e.errors()]\n            row['Error_row_num'] = index + index_offset\n            #appends bad data to a different list of dictionaries\n            bad_data.append(row)\n\n    return (good_data, bad_data)\n```"]