["```py\ndef get_matching_edge(self, latitude, longitude, bearing=None):\n    loc = np.array([latitude, longitude])\n    _, r = self.geo_spoke.query_knn(loc, 1)\n    radius = self.max_edge_length + r[0]\n    node_idx, dists = self.geo_spoke.query_radius(loc, radius)\n    nodes = self.ids[node_idx]\n    distances = dict(zip(nodes, dists))\n    adjacent_set = set()\n    graph = self.graph\n\n    best_edge = None\n    for node in nodes:\n        if node not in adjacent_set:\n            adjacent_nodes = np.intersect1d(np.array(graph.adj[node]),\n                                            nodes, assume_unique=True)\n\n            adjacent_set.update(adjacent_nodes)\n            for adjacent in adjacent_nodes:\n                edge_length = graph[node][adjacent][0]['length']\n                ratio = (distances[node] + distances[adjacent]) / \\\n                        edge_length\n                if best_edge is None or ratio < best_edge[2]:\n                    best_edge = (node, adjacent, ratio)\n\n        if bearing is not None:\n            best_edge = fix_edge_bearing(best_edge, bearing, graph)\n    return best_edge\n```", "```py\ndef get_matching_edge(self, latitude, longitude,\n                      bearing=None, min_r=1.0):\n    best_edge = None\n    loc = np.array([latitude, longitude])\n    _, r = self.geo_spoke.query_knn(loc, 1)\n    if r > min_r:\n        radius = self.max_edge_length + r[0]\n        node_idx, dists = self.geo_spoke.query_radius(loc, radius)\n        nodes = self.ids[node_idx]\n        distances = dict(zip(nodes, dists))\n        tested_edges = set()\n        graph = self.graph\n        node_set = set(nodes)\n\n        for node in nodes:\n            adjacent_nodes = node_set & set(graph.adj[node])\n\n            for adjacent in adjacent_nodes:\n                if (node, adjacent) not in tested_edges:\n                    edge_length = graph[node][adjacent][0]['length']\n                    ratio = edge_length / (distances[node] + distances[adjacent])\n\n                    if best_edge is None or ratio > best_edge[2]:\n                        best_edge = (node, adjacent, ratio)\n                    tested_edges.add((node, adjacent))\n                    tested_edges.add((adjacent, node))\n\n        if bearing is not None:\n            best_edge = fix_edge_bearing(best_edge, bearing, graph)\n    return best_edge\n```", "```py\ndef match_edges(road_network, trajectory):\n    edges = []\n    unique_locations = set()\n    edge_set = set()\n    for p in trajectory:\n        if p not in unique_locations:\n            e = road_network.get_matching_edge(*p, min_r=1.0)\n            if e is not None:\n                n0, n1, _ = e\n                edge = (n0, n1)\n                if edge not in edge_set:\n                    edge_set.add(edge)\n                    edges.append(edge)\n                unique_locations.add(p)\n    return edges\n```", "```py\ndef build_path(rn, edges):\n    path = []\n    for e0, e1 in pairwise(edges):\n        if not len(path):\n            path.append(e0[0])\n        if e0[0] != e1[0] and e0[1] != e1[1]:\n            if e0[1] == e1[0]:\n                path.extend([e0[1], e1[1]])\n            else:\n                n0, n1 = int(e0[1]), int(e1[0])\n                sp = ox.distance.shortest_path(rn, n0, n1)\n                if sp is not None:\n                    path.extend(sp[1:])\n    return path\n```", "```py\ndef process_trajectories():\n    rn = download_network()\n    road_network = RoadNetwork(rn)\n\n    state = load_state()\n    if state is None:\n        state = {\n            \"trajectories\": get_trajectories(),\n            \"errors\": []\n        }\n\n    save_counter = 0\n    trajectories = state[\"trajectories\"]\n    while len(trajectories) > 0:\n        trajectory_id = trajectories[0]\n        trajectory = load_trajectory_points(trajectory_id,\n                                            unique=True)\n        if len(trajectory) > 3:\n            edges = match_edges(road_network, trajectory)\n            path = build_path(rn, edges)\n\n            if len(path) > 0:\n                diff = calculate_difference(rn, path, trajectory)\n                print(f\"Trajectory: {trajectory_id}, Difference: {diff}\")\n                state[\"errors\"].append((trajectory_id, diff))\n\n        trajectories = trajectories[1:]\n        state[\"trajectories\"] = trajectories\n\n        save_counter += 1\n        if save_counter % 100 == 0:\n            save_state(state)\n\n    save_state(state)\n```", "```py\ndef calculate_difference(rn, path, trajectory):\n    p_loc = np.array([(rn.nodes[n]['y'], rn.nodes[n]['x']) for n in path])\n    t_loc = np.array([(t[0], t[1]) for t in trajectory])\n\n    p_length = vec_haversine(p_loc[1:, 0], p_loc[1:, 1], \n                             p_loc[:-1, 0], p_loc[:-1, 1]).sum()\n    t_length = vec_haversine(t_loc[1:, 0], t_loc[1:, 1], \n                             t_loc[:-1, 0], t_loc[:-1, 1]).sum()\n    return p_length - t_length\n```"]