["```py\nclass Board(object):\n    \"\"\"\n    This class is defines the chessboard.\n    \"\"\"\n\n    def __init__(self, fen_label):\n        self.fen_label = re.sub(pattern=r'\\d',\n                                repl=lambda x: self.get_ones(char=x.group()),\n                                string=fen_label)\n        self.fen_matrix = self.get_fen_matrix()\n\n    def get_ones(self, char):\n        \"\"\"\n        This method returns repetitive 1s based on input digit character.\n        \"\"\"\n        if char.isdigit():\n            return '1' * int(char)\n\n    def get_fen_matrix(self):\n        \"\"\"\n        This method constructs a FEN matrix.\n        \"\"\"\n        fen_matrix = np.array([list(row) for row in self.fen_label.split('/')])\n        return fen_matrix\n\n    def get_piece_positions(self, notation):\n        \"\"\"\n        This method returns the 2D index of the piece from FEN matrix.\n        \"\"\"\n        (i, j) = np.where(self.fen_matrix == notation)\n        try:\n            if i is not None and j is not None:\n                return i, j\n        except:\n            return None\n```", "```py\nclass Check(Board):\n    \"\"\"\n    This class finds if there are any checks in the chessboard.\n    \"\"\"\n\n    def __init__(self, fen_label):\n        super().__init__(fen_label=fen_label)\n\n    def get_sub_matrix(self, ai, aj, di, dj):\n        \"\"\"\n        This method chops the chessboard to a sub-matrix.\n        \"\"\"\n        corners = np.array([(ai, aj), (di, aj), (ai, dj), (di, dj)])\n        min_i, max_i = min(corners[:, 0]), max(corners[:, 0])\n        min_j, max_j = min(corners[:, 1]), max(corners[:, 1])\n        sub_matrix = self.fen_matrix[min_i:max_i+1, min_j:max_j+1]\n        return sub_matrix, sub_matrix.shape\n\n    def get_straight_checks(self, ai, aj, di, dj, a, d):\n        \"\"\"\n        This method returns the checks along the straight path.\n        \"\"\"\n        checks = list()\n        for (i, j) in zip(ai, aj):\n            if di == i:\n                attack_path = self.fen_matrix[di]\n            elif dj == j:\n                attack_path = self.fen_matrix[:, dj]\n            else:\n                continue\n            a_ind = np.where(attack_path == a)[0]\n            d_ind = np.where(attack_path == d)[0][0]\n            for a_i_ in a_ind:\n                attack_path_ = attack_path[min(a_i_, d_ind): max(a_i_, d_ind)+1]\n                checks.append(np.where(attack_path_ != '1')[0])\n        checks = list(filter(lambda x: len(x) == 2, checks))\n        return checks\n\n    def get_diagonal_checks(self, ai, aj, di, dj, a):\n        \"\"\"\n        This method returns the checks along the diagonal path.\n        \"\"\"\n        checks = list()\n        for (i, j) in zip(ai, aj):\n            sub_mat, sub_shape = self.get_sub_matrix(ai=i, aj=j, di=di, dj=dj)\n            if sub_shape[0] == sub_shape[1]:\n                if a not in sub_mat.diagonal():\n                    sub_mat = np.flipud(m=sub_mat)\n                checks.append(np.where(sub_mat.diagonal() != '1')[0])\n            else:\n                continue\n        checks = list(filter(lambda x: len(x) == 2, checks))\n        return checks\n\n    def get_knight_checks(self, ai, aj, di, dj):\n        \"\"\"\n        This method returns the checks along the L-shaped paths for knights.\n        \"\"\"\n        checks = list()\n        for (i, j) in zip(ai, aj):\n            attack_positions = [(i-2, j-1), (i-2, j+1),\n                                (i-1, j-2), (i-1, j+2),\n                                (i+1, j-2), (i+1, j+2),\n                                (i+2, j-1), (i+2, j+1)]\n            if (di, dj) in attack_positions:\n                checks.append((i, j))\n        return checks\n\n    def get_pawn_checks(self, ai, aj, di, dj):\n        \"\"\"\n        This method returns the checks for pawns.\n        \"\"\"\n        checks = list()\n        for (i, j) in zip(ai, aj):\n            _, sub_shape = self.get_sub_matrix(ai=i, aj=j, di=di, dj=dj)\n            if sub_shape[0] == 2 and sub_shape[1] == 2:\n                checks.append((i, j))\n            else:\n                continue\n        return checks\n\n    def king_checks_king(self, attacker, defendant):\n        \"\"\"\n        This method checks if the king is being attacked by the other king.\n        This is unlikely, but I am just adding a validation rule.\n        \"\"\"\n        flag = False\n        di, dj = self.get_piece_positions(notation=defendant)\n        if len(di) == 1 and len(dj) == 1:\n            di, dj = di[0], dj[0]\n        else:\n            return flag\n        ai, aj = self.get_piece_positions(notation=attacker)\n        ai, aj = ai[0], aj[0]\n        attack_positions = [(di, dj-1), (di, dj+1),\n                            (di-1, dj), (di+1, dj),\n                            (di-1, dj+1), (di-1, dj-1),\n                            (di+1, dj-1), (di+1, dj+1)]\n        if (ai, aj) in attack_positions:\n            flag = True\n        return flag\n\n    def rook_checks_king(self, attacker, defendant):\n        \"\"\"\n        This method checks if the king is being attacked by the rook.\n        \"\"\"\n        flag = False\n        di, dj = self.get_piece_positions(notation=defendant)\n        if len(di) == 1 and len(dj) == 1:\n            di, dj = di[0], dj[0]\n        else:\n            return flag\n        ai, aj = self.get_piece_positions(notation=attacker)\n        checks = self.get_straight_checks(\n            ai=ai, aj=aj, di=di, dj=dj, a=attacker, d=defendant)\n        if checks:\n            flag = True\n        return flag\n\n    def bishop_checks_king(self, attacker, defendant):\n        \"\"\"\n        This method checks if the king is being attacked by the bishop.\n        \"\"\"\n        flag = False\n        di, dj = self.get_piece_positions(notation=defendant)\n        if len(di) == 1 and len(dj) == 1:\n            di, dj = di[0], dj[0]\n        else:\n            return flag\n        ai, aj = self.get_piece_positions(notation=attacker)\n        checks = self.get_diagonal_checks(\n            ai=ai, aj=aj, di=di, dj=dj, a=attacker)\n        if checks:\n            flag = True\n        return flag\n\n    def knight_checks_king(self, attacker, defendant):\n        \"\"\"\n        This method checks if the king is being attacked by the knight.\n        \"\"\"\n        flag = False\n        di, dj = self.get_piece_positions(notation=defendant)\n        if len(di) == 1 and len(dj) == 1:\n            di, dj = di[0], dj[0]\n        else:\n            return flag\n        ai, aj = self.get_piece_positions(notation=attacker)\n        checks = self.get_knight_checks(ai=ai, aj=aj, di=di, dj=dj)\n        if checks:\n            flag = True\n        return flag\n\n    def queen_checks_king(self, attacker, defendant):\n        \"\"\"\n        This method checks if the king is being attacked by the queen.\n        \"\"\"\n        flag = False\n        di, dj = self.get_piece_positions(notation=defendant)\n        if len(di) == 1 and len(dj) == 1:\n            di, dj = di[0], dj[0]\n        else:\n            return flag\n        ai, aj = self.get_piece_positions(notation=attacker)\n        straight_checks = self.get_straight_checks(\n            ai=ai, aj=aj, di=di, dj=dj, a=attacker, d=defendant)\n        diagonal_checks = self.get_diagonal_checks(\n            ai=ai, aj=aj, di=di, dj=dj, a=attacker)\n        if straight_checks or diagonal_checks:\n            flag = True\n        return flag\n\n    def pawn_checks_king(self, attacker, defendant):\n        \"\"\"\n        This methos checks if the king is being attacked by the pawn.\n\n        Note: It is hard to determine from an image, which side of \n              the chessboard is black or is white.\n              Hence, this method assumes the pawn is attacking the king \n              if both the pieces are diagnolly aligned by 1 step.\n        \"\"\"\n        flag = False\n        di, dj = self.get_piece_positions(notation=defendant)\n        if len(di) == 1 and len(dj) == 1:\n            di, dj = di[0], dj[0]\n        else:\n            return flag\n        ai, aj = self.get_piece_positions(notation=attacker)\n        checks = self.get_pawn_checks(ai=ai, aj=aj, di=di, dj=dj)\n        if checks:\n            flag = True\n        return flag\n```", "```py\nclass IllegalPosition(Check):\n    \"\"\"\n    This class finds if the pieces are illegally positioned in the chessboard.\n    \"\"\"\n\n    def __init__(self, fen_label):\n        super().__init__(fen_label=fen_label)\n\n    def are_kings_less(self):\n        \"\"\"\n        Rule on kings.\n        \"\"\"\n        k_c = self.fen_label.count('k')\n        K_c = self.fen_label.count('K')\n        return (k_c < 1 and K_c < 1) or (k_c < 1) or (K_c < 1)\n\n    def are_kings_more(self):\n        \"\"\"\n        Rule on kings.\n        \"\"\"\n        k_c = self.fen_label.count('k')\n        K_c = self.fen_label.count('K')\n        return (k_c > 1 and K_c > 1) or (k_c > 1) or (K_c > 1)\n\n    def are_queens_more(self):\n        \"\"\"\n        Rule on queens.\n        \"\"\"\n        q_c = self.fen_label.count('q')\n        Q_c = self.fen_label.count('Q')\n        return (q_c > 9 and Q_c > 9) or (q_c > 9) or (Q_c > 9)\n\n    def are_bishops_more(self):\n        \"\"\"\n        Rule on bishops.\n        \"\"\"\n        b_c = self.fen_label.count('b')\n        B_c = self.fen_label.count('B')\n        return (b_c > 10 and B_c > 10) or (b_c > 10) or (B_c > 10)\n\n    def are_knights_more(self):\n        \"\"\"\n        Rule on knights.\n        \"\"\"\n        n_c = self.fen_label.count('n')\n        N_c = self.fen_label.count('N')\n        return (n_c > 10 and N_c > 10) or (n_c > 10) or (N_c > 10)\n\n    def are_rooks_more(self):\n        \"\"\"\n        Rule on rooks.\n        \"\"\"\n        r_c = self.fen_label.count('r')\n        R_c = self.fen_label.count('R')\n        return (r_c > 10 and R_c > 10) or (r_c > 10) or (R_c > 10)\n\n    def are_pawns_more(self):\n        \"\"\"\n        Rule on pawns.\n        \"\"\"\n        p_c = self.fen_label.count('p')\n        P_c = self.fen_label.count('P')\n        return (p_c > 8 and P_c > 8) or (p_c > 8) or (P_c > 8)\n\n    def rule_1(self):\n        \"\"\"\n        This method checks the count of the kings and the pieces in the board.\n        1\\. The count of white king and black king should always be 1.\n        2\\. The count of white queen and/or black queen should not cross 9.\n        3\\. The count of white bishop and/or black bishop should not cross 10.\n        4\\. The count of white knight and/or black knight should not cross 10.\n        5\\. The count of white rook and/or black rook should not cross 10.\n        6\\. The count of while pawn and/or black pawn should not cross 8.\n        7\\. The chessboard should never be empty.\n        \"\"\"\n        flag = False\n        if self.are_kings_less():\n            flag = True\n        elif self.are_kings_more():\n            flag = True\n        elif self.are_queens_more():\n            flag = True\n        elif self.are_bishops_more():\n            flag = True\n        elif self.are_knights_more():\n            flag = True\n        elif self.are_rooks_more():\n            flag = True\n        elif self.are_pawns_more():\n            flag = True\n        return flag\n\n    def rule_2(self):\n        \"\"\"\n        This method checks if the pawns are in the first and last row of the board.\n        1\\. No pawn should be on the first row and/or on the last row.\n           The pawn that reaches the last row always gets promoted.\n           Hence no pawns on the last row.\n        \"\"\"\n        flag = False\n        fen_label_list = self.fen_label.split('/')\n        f_row, l_row = fen_label_list[0], fen_label_list[-1]\n        p_f_row = 'p' in f_row\n        p_l_row = 'p' in l_row\n        P_f_row = 'P' in f_row\n        P_l_row = 'P' in l_row\n        if (p_f_row and p_l_row) or p_f_row or p_l_row:\n            flag = True\n        elif (P_f_row and P_l_row) or P_f_row or P_l_row:\n            flag = True\n        return flag\n\n    def rule_3(self):\n        \"\"\"\n        This method checks if the king is attacking the other king.\n        1\\. The king never checks the other king.\n        2\\. The king can attack other enemy pieces except the enemy king.\n        \"\"\"\n        return self.king_checks_king(attacker='k', defendant='K')\n\n    def rule_4(self):\n        \"\"\"\n        This method checks if the kings are under check simultaneously.\n        1\\. The two kings are never under check at the same time.\n        \"\"\"\n        r_checks_K = self.rook_checks_king(attacker='r', defendant='K')\n        n_checks_K = self.knight_checks_king(attacker='n', defendant='K')\n        b_checks_K = self.bishop_checks_king(attacker='b', defendant='K')\n        q_checks_K = self.queen_checks_king(attacker='q', defendant='K')\n        p_checks_K = self.pawn_checks_king(attacker='p', defendant='K')\n        R_checks_k = self.rook_checks_king(attacker='R', defendant='k')\n        N_checks_k = self.knight_checks_king(attacker='N', defendant='k')\n        B_checks_k = self.bishop_checks_king(attacker='B', defendant='k')\n        Q_checks_k = self.queen_checks_king(attacker='Q', defendant='k')\n        P_checks_k = self.pawn_checks_king(attacker='P', defendant='k')\n        is_K_checked = r_checks_K or n_checks_K or b_checks_K or q_checks_K or p_checks_K\n        is_k_checked = R_checks_k or N_checks_k or B_checks_k or Q_checks_k or P_checks_k\n        return is_K_checked and is_k_checked\n\n    def is_illegal(self):\n        \"\"\"\n        This method is a consolidation of all the above basic rules of chess.\n        \"\"\"\n        return self.rule_1() or self.rule_2() or self.rule_3() or self.rule_4()\n```", "```py\nclass DataPipeline(object):\n    \"\"\"\n    This class is a data pipeline for deep learning model.\n    \"\"\"\n\n    def __init__(self, tr_images, tr_labels, cv_images, cv_labels, te_images, te_labels):\n        self.rows, self.cols = (8, 8)\n        self.square = None\n        self.h, self.w, self.c = None, None, None\n        self.N = 13\n        self.tr_images = np.array(tr_images)\n        self.tr_labels = np.array(tr_labels)\n        self.cv_images = np.array(cv_images)\n        self.cv_labels = np.array(cv_labels)\n        self.te_images = np.array(te_images)\n        self.te_labels = np.array(te_labels)\n        self.piece_symbols = 'prbnkqPRBNKQ'\n\n    def preprocess_input_image(self, imagefile, resize_scale=(200, 200)):\n        \"\"\"\n        This function preprocesses in the input image.\n        \"\"\"\n        img = cv.imread(filename=imagefile)\n        img = cv.resize(src=img, dsize=resize_scale)\n\n        self.h, self.w, self.c = img.shape\n        self.square = self.h // self.rows\n\n        img_blocks = view_as_blocks(\n            arr_in=img, block_shape=(self.square, self.square, self.c))\n        img_blocks = img_blocks.reshape(\n            self.rows * self.cols, self.square, self.square, self.c)\n\n        return img_blocks\n\n    def tr_data_generator(self):\n        \"\"\"\n        This method preprocess the input images.\n        \"\"\"\n        for i, l in zip(self.tr_images, self.tr_labels):\n            yield (self.preprocess_input_image(imagefile=i),\n                   self.onehot_from_fen(fen=l))\n\n    def cv_data_generator(self):\n        \"\"\"\n        This method preprocess the input images.\n        \"\"\"\n        for i, l in zip(self.cv_images, self.cv_labels):\n            yield (self.preprocess_input_image(imagefile=i),\n                   self.onehot_from_fen(fen=l))\n\n    def te_data_generator(self):\n        \"\"\"\n        This method preprocess the input targets.\n        \"\"\"\n        for i in self.te_images:\n            yield self.preprocess_input_image(imagefile=i)\n\n    def onehot_from_fen(self, fen):\n        \"\"\"\n        This method converts FEN to onehot.\n        The original author of this method is 'Pavel Koryakin'.\n        Pavel Koryakin is also the maintainer of Chess Positions dataset.\n        \"\"\"\n        eye = np.eye(N=self.N)\n        output = np.empty(shape=(0, self.N))\n        fen = re.sub(pattern='[/]', repl='', string=fen)\n\n        for char in fen:\n            if char in '12345678':\n                output = np.append(\n                    arr=output,\n                    values=np.tile(A=eye[self.N-1], reps=(int(char), 1)), axis=0\n                )\n            else:\n                idx = self.piece_symbols.index(char)\n                output = np.append(\n                    arr=output,\n                    values=eye[idx].reshape((1, self.N)), axis=0\n                )\n\n        return output\n\n    def fen_from_onehot(self, onehot):\n        \"\"\"\n        This method converts onehot to FEN.\n        The original author of this method is 'Pavel Koryakin'.\n        Pavel Koryakin is also the maintainer of Chess Positions dataset.\n        \"\"\"\n        output = str()\n        for j in range(self.rows):\n            for i in range(self.cols):\n                if onehot[j][i] == 12: # TensorFlow coded 12 for empty squares.\n                    output += ' '\n                else:\n                    output += self.piece_symbols[int(onehot[j][i])]\n            if j != self.rows - 1:\n                output += '/'\n\n        for i in range(self.rows, 0, -1):\n            output = output.replace(' ' * i, str(i))\n\n        return output\n\n    def construct_dataset(self):\n        \"\"\"\n        This method constructs the dataset.\n        \"\"\"\n        tr_dataset = tf.data.Dataset.from_generator(\n            generator=self.tr_data_generator, output_types=(tf.int64, tf.int64))\n        tr_dataset = tr_dataset.repeat()\n\n        cv_dataset = tf.data.Dataset.from_generator(\n            generator=self.cv_data_generator, output_types=(tf.int64, tf.int64))\n        cv_dataset = cv_dataset.repeat()\n\n        te_dataset = tf.data.Dataset.from_generator(\n            generator=self.te_data_generator, output_types=tf.int64)\n        te_dataset = te_dataset.repeat()\n\n        it_tr = tr_dataset.__iter__()\n        it_cv = cv_dataset.__iter__()\n        it_te = te_dataset.__iter__()\n\n        return it_tr, it_cv, it_te\n```", "```py\nclass ChessModel(object):\n    \"\"\"\n    This class is for deep learning model for chess recognition problem.\n    \"\"\"\n\n    def __init__(self,\n                 tr_dataset,\n                 cv_dataset,\n                 tr_size,\n                 cv_size,\n                 filepath_tuner,\n                 filepath_fitter,\n                 filepath_tracker):\n        self.tr_dataset = tr_dataset\n        self.cv_dataset = cv_dataset\n        self.input_shape = (25, 25, 3)\n        self.batch_size = 64\n        self.output_units = 13 # 12 for chess pieces and 1 for empty square.\n        self.tr_size = tr_size\n        self.cv_size = cv_size\n        self.filepath_tuner = filepath_tuner\n        self.filepath_fitter = filepath_fitter\n        self.filepath_tracker = filepath_tracker\n\n    def build_model(self, hp):\n        \"\"\"\n        This method builds the optimized model.\n        \"\"\"\n        hp_activations = hp.Choice(\n            name='activation', values=['relu', 'tanh', 'sigmoid'])\n        hp_filters_1 = hp.Int(\n            name='filter_1', min_value=32, max_value=64, step=10)\n        hp_filters_2 = hp.Int(\n            name='filter_2', min_value=32, max_value=64, step=10)\n        hp_kernel_1 = hp.Int(\n            name='Kernel_1', min_value=2, max_value=5, step=None)\n        hp_kernel_2 = hp.Int(\n            name='Kernel_2', min_value=2, max_value=5, step=None)\n        hp_units = hp.Int(\n            name='dense', min_value=32, max_value=64, step=10)\n        hp_learning_rate = hp.Choice(\n            name='learning_rate', values=[1e-2, 1e-3, 1e-4])\n\n        input_layer = Input(\n            shape=self.input_shape, batch_size=self.batch_size, name='Input')\n        conv_2d_layer_1 = Conv2D(\n            filters=hp_filters_1, kernel_size=hp_kernel_1,\n            activation=hp_activations, name='Conv2D_1')(input_layer)\n        conv_2d_layer_2 = Conv2D(\n            filters=hp_filters_2, kernel_size=hp_kernel_2,\n            activation=hp_activations, name='Conv2D_2')(conv_2d_layer_1)\n        flatten_layer = Flatten(name='Flatten')(conv_2d_layer_2)\n        dense_layer = Dense(\n            units=hp_units, activation=hp_activations, name='Dense')(flatten_layer)\n        output_layer = Dense(\n            units=self.output_units, activation='softmax', name='Output')(dense_layer)\n\n        model = Model(inputs=input_layer, outputs=output_layer, name='Chess_Model')\n\n        optimizer = tf.keras.optimizers.Adam(learning_rate=hp_learning_rate)\n        model.compile(\n            optimizer=optimizer, loss='categorical_crossentropy',\n            metrics=['accuracy'])\n\n        return model\n\n    def model_tuner(self):\n        \"\"\"\n        This method tunes the chess model.\n        \"\"\"\n        if not os.path.isfile(path=self.filepath_tuner):\n            print(\"Tuning the model.\")\n            stop_early = tf.keras.callbacks.EarlyStopping(monitor='val_loss', patience=3)\n            tuner = kt.Hyperband(\n                hypermodel=self.build_model, objective='val_accuracy', max_epochs=10)\n            tuner.search(\n                x=tr_dataset, epochs=50, steps_per_epoch=self.tr_size,\n                validation_data=cv_dataset, validation_steps=self.cv_size,\n                callbacks=[stop_early])\n            print(\"Tuning completed.\")\n\n            best_hps = tuner.get_best_hyperparameters(num_trials=1)[0]\n            model = tuner.hypermodel.build(best_hps)\n            tf.keras.models.save_model(model=model, filepath=self.filepath_tuner)\n            print(\"Saved the best model to the file.\")\n        else:\n            print(\"Model is already tuned, and is also saved.\")\n            model = tf.keras.models.load_model(filepath=self.filepath_tuner)\n            print(\"Loaded the tuned model and ready for fitting.\")\n\n        return model\n\n    def model_fitter(self):\n        \"\"\"\n        This method fits the tuned model.\n        \"\"\"\n        model = self.model_tuner()\n        print()\n        model.summary()\n        print()\n\n        model_save_callback = ModelCheckpoint(\n            filepath=self.filepath_fitter, monitor='val_accuracy',\n            verbose=1, save_best_only=True, mode='auto')\n        callbacks = [model_save_callback]\n\n        if not os.path.isfile(path=self.filepath_fitter):\n            print(\"Fitting the model.\")\n\n            epochs = 10\n            tracker = model.fit(\n                x=tr_dataset, validation_data=cv_dataset, epochs=epochs,\n                steps_per_epoch=len(tr_images), validation_steps=len(cv_images),\n                callbacks=callbacks)\n            print(\"\\nSaved the fitted model.\")\n\n            tracker_df = pd.DataFrame(data=tracker.history)\n            tracker_df.to_csv(path_or_buf=self.filepath_tracker, index=False)\n            print(\"Saved the history to the file.\")\n        else:\n            print(\"Model is already fitted, and is also saved.\")\n            model = tf.keras.models.load_model(filepath=self.filepath_fitter)\n            print(\"Loaded the fitted model and ready for prediction.\")\n\n            tracker_df = pd.read_csv(filepath_or_buffer=self.filepath_tracker)\n\n        print()\n        plot_model_performance(tracker_df=tracker_df)\n\n        return model\n```", "```py\nModel: \"Chess_Model\"\n_________________________________________________________________\n Layer (type)                Output Shape              Param #   \n=================================================================\n Input (InputLayer)          [(64, 25, 25, 3)]         0         \n\n Conv2D_1 (Conv2D)           (64, 21, 21, 32)          2432      \n\n Conv2D_2 (Conv2D)           (64, 19, 19, 62)          17918     \n\n Flatten (Flatten)           (64, 22382)               0         \n\n Dense (Dense)               (64, 42)                  940086    \n\n Output (Dense)              (64, 13)                  559       \n\n=================================================================\nTotal params: 960,995\nTrainable params: 960,995\nNon-trainable params: 0\n_________________________________________________________________\n```", "```py\nfrom chess_positions import IllegalPosition\nfrom chess_positions import Check\nfrom glob import glob\nfrom skimage.util.shape import view_as_blocks\n\nimport cv2 as cv\nimport plotly.express as px\nimport random\nimport tensorflow as tf\nimport warnings\nwarnings.filterwarnings(action='ignore')\n\nclass Pipeline(object):\n    \"\"\"\n    This class is a pipeline mechanism to feed the\n    query chess image into the model for FEN prediction.\n    \"\"\"\n\n    def __init__(self, chess_image):\n        self.piece_symbols = \"prbnkqPRBNKQ\"\n        self.rows, self.cols = (8, 8)\n        self.square = None\n        self.h, self.w, self.c = None, None, None\n        self.chess_image = chess_image\n        self.chess_model = tf.keras.models.load_model(\n            filepath='chess_model.h5')\n        self.chess_image_display = self.display_image()\n\n    def display_image(self):\n        \"\"\"\n        This method reads the image and\n        gives plotly fig for the final display.\n        \"\"\"\n        image = cv.imread(filename=self.chess_image)\n        image = cv.cvtColor(src=image, code=cv.COLOR_BGR2RGB)\n\n        image_fig = px.imshow(img=image)\n        image_fig.update_layout(\n            coloraxis_showscale=False, autosize=True,\n            margin=dict(l=0, r=0, b=0, t=0))\n        image_fig.update_xaxes(showticklabels=False)\n        image_fig.update_yaxes(showticklabels=False)\n        return image_fig\n\n    def preprocess(self, resize_scale=(200, 200)):\n        \"\"\"\n        This method preprocesses the chess image.\n        \"\"\"\n        img = cv.imread(filename=self.chess_image)\n        img = cv.resize(src=img, dsize=resize_scale)\n\n        self.h, self.w, self.c = img.shape\n        self.square = self.h // self.rows\n\n        img_blocks = view_as_blocks(\n            arr_in=img, block_shape=(self.square, self.square, self.c))\n        img_blocks = img_blocks.reshape(\n            self.rows * self.cols, self.square, self.square, self.c)\n\n        return img_blocks\n\n    def fen_from_onehot(self, onehot):\n        \"\"\"\n        This method converts onehot to FEN.\n        The original author of this method is 'Pavel Koryakin'.\n        Pavel Koryakin is also the maintainer of Chess Positions dataset.\n        \"\"\"\n        output = str()\n        for j in range(self.rows):\n            for i in range(self.cols):\n                if onehot[j][i] == 12: # TensorFlow coded 12 for empty squares.\n                    output += ' '\n                else:\n                    output += self.piece_symbols[int(onehot[j][i])]\n            if j != self.rows - 1:\n                output += '/'\n\n        for i in range(self.rows, 0, -1):\n            output = output.replace(' ' * i, str(i))\n\n        return output\n\n    def predict(self):\n        \"\"\"\n        This method predicts the FEN of the query chess image.\n        \"\"\"\n        chess_image_blocks = self.preprocess()\n\n        onehot = self.chess_model.predict(x=chess_image_blocks)\n        onehot = onehot.argmax(axis=1).reshape(-1, 8, 8)[0]\n\n        fen_label = self.fen_from_onehot(onehot=onehot)\n\n        interpretation = self.illegal_interpreter(fen_label=fen_label)\n        if len(interpretation) > 0:\n            interpretation = f\"This is an illegal chess position. Reason is {interpretation}\"\n        else:\n            interpretation = self.check_interpreter(fen_label=fen_label)\n\n        fen_label = f\"The Forsyth-Edwards Notation (FEN) of an uploaded chess image is {fen_label}.\"\n        interpretation = f\"Further interpretation: {interpretation}\"\n\n        return fen_label, interpretation\n\n    def illegal_interpreter(self, fen_label):\n        \"\"\"\n        This method interprets the predicted FEN.\n        \"\"\"\n        reason = str()\n\n        chess_illegal = IllegalPosition(fen_label=fen_label)\n\n        if chess_illegal.are_kings_less():\n            reason += \"either white king, black king, or both are missing.\"\n        elif chess_illegal.are_kings_more():\n            reason += \"either white king, black king, or both are more than 1.\"\n        elif chess_illegal.are_queens_more():\n            reason += \"either white queen, black queen, or both are more than 9.\"\n        elif chess_illegal.are_bishops_more():\n            reason += \"either white bishop, black bishop, or both are more than 10.\"\n        elif chess_illegal.are_knights_more():\n            reason += \"either white knight, black knight, or both are more than 10.\"\n        elif chess_illegal.are_rooks_more():\n            reason += \"either white rook, black rook, or both are more than 10.\"\n        elif chess_illegal.are_pawns_more():\n            reason += \"either white pawn, black pawn, or both are more than 8.\"\n        elif chess_illegal.rule_2():\n            reason += \"either white pawn, black pawn, or both are in first row and/or last row.\"\n        elif chess_illegal.rule_3():\n            reason += \"the king checks the other the king.\"\n        elif chess_illegal.rule_4():\n            reason += \"white king and black king are under attack simultaneously.\"\n        else:\n            reason += \"\"\n\n        return reason\n\n    def check_interpreter(self, fen_label):\n        \"\"\"\n        This method interprets the predicted FEN.\n        \"\"\"\n        reason = str()\n\n        chess_check = Check(fen_label=fen_label)\n\n        r_checks_K = chess_check.rook_checks_king(\n            attacker='r', defendant='K')\n        n_checks_K = chess_check.knight_checks_king(\n            attacker='n', defendant='K')\n        b_checks_K = chess_check.bishop_checks_king(\n            attacker='b', defendant='K')\n        q_checks_K = chess_check.queen_checks_king(\n            attacker='q', defendant='K')\n        p_checks_K = chess_check.pawn_checks_king(\n            attacker='p', defendant='K')\n        R_checks_k = chess_check.rook_checks_king(\n            attacker='R', defendant='k')\n        N_checks_k = chess_check.knight_checks_king(\n            attacker='N', defendant='k')\n        B_checks_k = chess_check.bishop_checks_king(\n            attacker='B', defendant='k')\n        Q_checks_k = chess_check.queen_checks_king(\n            attacker='Q', defendant='k')\n        P_checks_k = chess_check.pawn_checks_king(\n            attacker='P', defendant='k')\n\n        is_K_checked = r_checks_K or n_checks_K or b_checks_K or q_checks_K or p_checks_K\n        is_k_checked = R_checks_k or N_checks_k or B_checks_k or Q_checks_k or P_checks_k\n\n        if is_K_checked:\n            reason += \"The white king is under attack.\"\n        elif is_k_checked:\n            reason += \"The black king is under attack.\"\n        else:\n            reason += \"Both kings are safe.\"\n\n        return reason\n```"]