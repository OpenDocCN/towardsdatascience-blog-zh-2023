- en: Write DRY data models with partials and Pydantic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/write-dry-data-models-with-partials-and-pydantic-b0b13d0eeb3a?source=collection_archive---------4-----------------------#2023-02-14](https://towardsdatascience.com/write-dry-data-models-with-partials-and-pydantic-b0b13d0eeb3a?source=collection_archive---------4-----------------------#2023-02-14)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Build clean nested data models for use in data engineering pipelines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@Carobert?source=post_page-----b0b13d0eeb3a--------------------------------)[![Charles
    Mendelson](../Images/0a8dea9bab2a49da65687095d31065e9.png)](https://medium.com/@Carobert?source=post_page-----b0b13d0eeb3a--------------------------------)[](https://towardsdatascience.com/?source=post_page-----b0b13d0eeb3a--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----b0b13d0eeb3a--------------------------------)
    [Charles Mendelson](https://medium.com/@Carobert?source=post_page-----b0b13d0eeb3a--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fa6f4d278f87e&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fwrite-dry-data-models-with-partials-and-pydantic-b0b13d0eeb3a&user=Charles+Mendelson&userId=a6f4d278f87e&source=post_page-a6f4d278f87e----b0b13d0eeb3a---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----b0b13d0eeb3a--------------------------------)
    ·7 min read·Feb 14, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fb0b13d0eeb3a&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fwrite-dry-data-models-with-partials-and-pydantic-b0b13d0eeb3a&user=Charles+Mendelson&userId=a6f4d278f87e&source=-----b0b13d0eeb3a---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fb0b13d0eeb3a&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fwrite-dry-data-models-with-partials-and-pydantic-b0b13d0eeb3a&source=-----b0b13d0eeb3a---------------------bookmark_footer-----------)![](../Images/a5f33117bda3e5651248696317ad5a7a.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Photo by [Didssph](https://unsplash.com/ko/@didsss?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
    on [Unsplash](https://unsplash.com/photos/PB80D_B4g7c?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pydantic is an incredibly powerful library for data modeling and validation
    that should become a standard part of your data pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Part of what makes them so powerful is they can easily accommodate nested data
    files like JSON.
  prefs: []
  type: TYPE_NORMAL
- en: For a quick refresher, Pydantic is a Python library that lets you define a data
    model in a Pythonic way, and use that model to validate data inputs, mainly through
    type hints.
  prefs: []
  type: TYPE_NORMAL
- en: Pydantic type-hints are much stronger and can be much more customized than standard
    library ones.
  prefs: []
  type: TYPE_NORMAL
- en: Partials on the other hand let you preload a function call with specific args
    and kwargs, which is particularly helpful if you’re going to call the same function
    with the same parameters numerous times.
  prefs: []
  type: TYPE_NORMAL
- en: '[In a previous article](https://medium.com/towards-data-science/easily-validate-user-generated-data-using-pydantic-5ace695cc3c8),
    I talked about using Enums to define valid string inputs for validating.'
  prefs: []
  type: TYPE_NORMAL
- en: We can take this further by incepting our Pydantic data model with other Pydantic
    data models.
  prefs: []
  type: TYPE_NORMAL
- en: The Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I created our sample data using various random name generators. The dataset
    represents characters in a Dungeons and Dragons-type game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with an inspection of our data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c3bb3d39f2feb2387af43a34175a2db6.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author, generated with Carbon
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, rather than a flat data structure, we now have data within data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inspecting our previous data model we can see that we now have to make some
    changes to accommodate the nested data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Visualizing the problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One tool I find helpful for exploring nested data structures is [JSONCrack](https://jsoncrack.com/),
    which provides a fantastic visualization of JSON data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ec7fd0634f18cdb24d4708c2154d393c.png)'
  prefs: []
  type: TYPE_IMG
- en: image downloaded from JSON crack under the [GNU General Public License v3.0](https://github.com/AykutSarac/jsoncrack.com/blob/main/LICENSE)
  prefs: []
  type: TYPE_NORMAL
- en: We can see that 4 other models underneath it support our top-level model.
  prefs: []
  type: TYPE_NORMAL
- en: 'DRY defining our model:'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the fields we can easily see from JSON crack, we can make our first pass
    at the model like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`pydantic.Field()` lets us specify additional parameters for our model beyond
    type hints.'
  prefs: []
  type: TYPE_NORMAL
- en: '`...` indicates that it is a required field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ge` indicates that the field must be greater than or equal to this value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`le` indicates that the field must be less than or equal to this value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, there is also a lot of repeated code in the fields defining our attribute
    modifiers. 7 of our modifiers must be between -6 and 6\. Consequently, in future
    changes we’d have to make changes to 7 lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can simplify our definitions using a `partial` function from the `functools`
    library. What a partial does is allow us to pin parameters in place for a function
    and they''re perfect for a situation like this where we are calling the same function
    with the same arguments over and over again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We now have a single place we can make changes to our code if we ever need to
    change the range of the attribute modifiers. This is a much cleaner and DRYer
    way of writing code.
  prefs: []
  type: TYPE_NORMAL
- en: Also, notice that we can still pass other parameters to the partial function,
    in this case `description`
  prefs: []
  type: TYPE_NORMAL
- en: Partials are also flexible and let you override keyword arguments you’ve already
    passed to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finishing out the model:'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have to define our other three models as well as a couple of enums to
    go with them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Pay particular attention to the `KINGDOM_ID` and `GUILD_ID`. We overrode the
    `ge` and `le` arguments in the partial function which is ok. It still preserves
    the `...` which indicates it’s a required field.
  prefs: []
  type: TYPE_NORMAL
- en: By calling the partial function on our ID columns we never have to worry about
    forgetting to make them required fields.
  prefs: []
  type: TYPE_NORMAL
- en: Defining our top-level model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now all the supporting models have been built, we can define our top-level
    model which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Focus on `HOME_NESTED` and `GUILD_NESTED`:'
  prefs: []
  type: TYPE_NORMAL
- en: Notice how they aren't required in our top-level model but those models have
    fields within them that are required. That means that if you pass data to the
    field, it must conform to the model, but if you don't pass the data to the field,
    it is still considered valid.
  prefs: []
  type: TYPE_NORMAL
- en: That effectively means you can pass to it a valid model or nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Combining `functools.partial()` with Pydantic data models can do a lot to make
    your code cleaner, easier to understand and ensure that you're properly handling
    invalid data in a scalable way.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we only built a single level of nesting, but you can nest repeatedly
    to manage any gnarly JSON object you encounter.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, a well-built data model gives downstream consumers confidence that
    the data you’re sending to them is exactly what they’re expecting.
  prefs: []
  type: TYPE_NORMAL
- en: How do you think you can apply these techniques to your data pipelines?
  prefs: []
  type: TYPE_NORMAL
- en: About
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Charles Mendelson is a Data Engineer working at PitchBook data. [If you would
    like to get in touch with him, the best way is on LinkedIn.](https://www.linkedin.com/in/charles-mendelson-carobert/)
  prefs: []
  type: TYPE_NORMAL
- en: 'All the code:'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Originally published at* [*https://charlesmendelson.com*](https://charlesmendelson.com/tds/pydantic-and-partials/)
    *on February 23, 2023.*'
  prefs: []
  type: TYPE_NORMAL
