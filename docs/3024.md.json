["```py\n// hello.dfy\nmethod Main()\n{\n  var s := \"Hello World\";\n  print s, \"\\n\";\n}\n```", "```py\nghost predicate ValidSeq(sequence: seq<NeIntRange>) {\n  (forall i:nat, j:nat | i < j < |sequence| :: sequence[i].0 < sequence[j].0)\n  && (forall i:nat, j:nat | i < j < |sequence| :: !Touch(sequence[i], sequence[j]))\n}\n\ntype IntRange = (int, int)\ntype NeIntRange = x: IntRange | !IsEmpty(x) witness (0,0)\n\nfunction IsEmpty(r: IntRange): bool\n{\n  r.0 > r.1\n}\n```", "```py\nforall i:nat, j:nat | i < j < |sequence| :: sequence[i].0 < sequence[j].0\n```", "```py\nforall i:nat, j:nat | i < j < |sequence| :: !Touch(sequence[i], sequence[j])\n```", "```py\npredicate Touch(i: NeIntRange, j: NeIntRange)\n  ensures Touch(i, j) == exists i0, j0 ::\n                    Contains(i, i0) && Contains(j, j0) && -1 <= i0 - j0 <= 1\n{\n  assert Contains(i, i.0) && Contains(i, i.1) && Contains(j, j.0) && Contains(j, j.1);\n  if i.1 < j.0 then\n    assert  (-1 <= i.1 - j.0 <= 1) == (i.1+1 == j.0);\n    i.1+1 == j.0\n  else if j.1 < i.0 then\n    assert (-1 <= j.1 - i.0 <= 1) == (j.1+1 == i.0);\n    j.1+1 == i.0\n  else\n    var k0 := Max(i.0, j.0);\n    assert Contains(i, k0) && Contains(j, k0);\n    true\n}\n\nfunction Contains(r: IntRange, i: int): bool\n{\n  r.0 <= i && i <= r.1\n}\n\nfunction Max(a: int, b: int): int\n{\n  if a < b then b else a\n}\n```", "```py\nmethod InternalAdd(xs: seq<NeIntRange>, a: IntRange) returns (rs: seq<NeIntRange>)\n  requires ValidSeq(xs)\n  ensures ValidSeq(rs)\n  ensures SeqToSet(rs) == SeqToSet(xs) + RangeToSet(a)\n{\n  if IsEmpty(a)\n  {\n    rs := xs;\n  }\n  else\n  {\n    assume false; // cheat for now\n  }\n}\n```", "```py\nghost function RangeToSet(pair: IntRange): set<int>\n{\n  set i {:autotriggers false} | pair.0 <= i <= pair.1 :: i\n}\n```", "```py\nghost function SeqToSet(sequence: seq<NeIntRange>): set<int>\n  decreases |sequence|\n  requires ValidSeq(sequence)\n{\n  if |sequence| == 0 then {}\n  else if |sequence| == 1 then RangeToSet(sequence[0])\n  else RangeToSet(sequence[0]) + SeqToSet(sequence[1..])\n}\n```", "```py\nmethod InternalAdd(xs: seq<NeIntRange>, a: IntRange) returns (rs: seq<NeIntRange>)\n  requires ValidSeq(xs)\n  ensures ValidSeq(rs)\n  ensures SeqToSet(rs) == SeqToSet(xs) + RangeToSet(a)\n{\n  if IsEmpty(a)\n  {\n    rs := xs;\n  }\n  else\n  {\n    var notTouching, merged := PartitionAndMerge(xs, a);\n    var indexAfter := NoTouchIndexAfter(notTouching, merged);\n    rs := InsertAt(notTouching, [merged], indexAfter);\n  }\n}\n```", "```py\nmethod PartitionAndMerge(xs: seq<NeIntRange>, a: NeIntRange) returns (notTouching: seq<NeIntRange>, merged: NeIntRange)\n  requires ValidSeq(xs)\n\n  ensures ValidSeq(notTouching)\n  ensures RangeToSet(merged) >= RangeToSet(a)\n  ensures forall range | range in notTouching :: !Touch(range, merged)\n  ensures SeqToSet(xs) + RangeToSet(a) == SeqToSet(notTouching) + RangeToSet(merged)\n{\n  // Split into touching and not touching seqs\n  var touching: seq<NeIntRange>;\n  touching, notTouching := Partition(a, xs);\n\n  // Merge the touching seq into one range with our original range\n  merged := UnionSeq(a, touching);\n}\n```", "```py\nfunction UnionRange(x: IntRange, y: IntRange): IntRange\n  requires IsEmpty(x) || IsEmpty(y) || Touch(x, y)\n  ensures RangeToSet(x) + RangeToSet(y) == RangeToSet(UnionRange(x,y))\n{\n  if IsEmpty(x) then y\n  else if IsEmpty(y) then x\n  else (Min(x.0, y.0), Max(x.1, y.1))\n}\n```"]