["```py\nimport numpy as np\nfrom numpy.random import seed\nfrom numpy.random import randn\nimport random\nimport datetime\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns \n\nimport math\nimport decimal\nfrom scipy import stats\nnp.seterr(divide='raise') #Make sure you set this\n```", "```py\nyt1 = u1 + 0.1*randn(30)\nyt2 = u2 + 0.1*randn(30)\n\ny = np.concatenate((yt1, yt2), axis=0)\nplt.figure(figsize=(16, 10))\nplt.plot(y)\n```", "```py\ndef Center_Kohonen(y, X=0, K=2, alfa=0.8, C=500):    \n# This kohonen network implementation finds two centers in a time series\n#Params:\n#Y = Time Series\n#M = Number of input patterns\n#N = Dimension of the input pattern (for our case it will be 1)\n#K = number of neurons, for the proposed problem (number of centers)\n    M = y.shape[0]\n    N = 1\n    f = 0\n\n#Initializin the neurons' weights\n    I = y.argsort(axis=0) # Sorted Indexes\n    Y = np.sort(y)        # Sortes Points in the Time Series    \n    c1 = Y[0:7]           # Beginning of the series     \n    c2 = Y[M-7:M]         # End of the series\n\n    #Adjusting the values\n    while np.std(c2) > 0.1: #As long as the standard deviation is greater than 0.1, replace the highest value with the mean\n        ma = c2.argmax()\n        c2[ma] = np.mean(c2);    \n        y[I[ma+60-7]] = np.mean(c2);\n\n    while np.std(c1) > 0.1: #As long as the standard deviation is greater than 0.1, replace the lowest value with the mean\n        mi = c1.argmin()\n        c1[mi] = np.mean(c1)\n        y[I[mi]] = np.mean(c1);\n\n    #Definition of weight values\n    W = [np.mean(c1), np.mean(c2)] \n\n    #Finding centers from Kohonen's network training   \n    for l in range(1, C+1):\n        alfa=alfa*(1-(C-(C-l))/C)\n\n        for i in range(0, M): #For each value in the time series\n            a=999\n\n            for j in range(0, K): #Where K is the number of cluster\n                if np.linalg.norm([(y[i]-W[j])], 2) < a:\n                    a = np.linalg.norm([(y[i]-W[j])], 2)\n                    f = j\n\n            W[f] = W[f]+alfa*(y[i]-W[f])\n\n    return c1, c2, I, Y, W, a, alfa\n```", "```py\ndef Fuzzy_Set(y, W):\n    # This program finds membership values for a time series from previously specified centers.\n    # Where y is the time series and c a vector with the found centers\n    center_1 = []\n    center_2 = []\n    n = y.shape[0]\n    l = 2\n# Finding the membership association for each point in the time series\n    for i in range(0, l):\n        for t in range(0, n):\n            sum=0;\n            for k in range(0, l):\n                sum = sum+(y[t]-W[k])*(y[t]-W[k])\n            if i == 0:\n                center_1.append(np.round(1-((y[t]-W[i])*(y[t]-W[i]))/sum, 3))\n            else:\n                center_2.append(np.round(1-((y[t]-W[i])*(y[t]-W[i]))/sum, 3))\n      return center_1, center_2\n```", "```py\nc1, c2, I, Y, W, a, alfa = Center_Kohonen(y, X=0, K=2, alfa=0.8, C=500)\ncenter_1, center_2 = Fuzzy_Set(y, W)\nplt.figure(figsize=(16, 10))\nplt.plot(center_1, 'b') # plotting t, a separately \nplt.plot(center_2, 'r') # plotting t, b separately \nplt.show()\n```", "```py\ndef Metropolis_Hastings(center_kohonen, n_sims=1000):\n     n = len(y)\n     m = 1 + round((n-1) * np.random.uniform(0, 1))\n     shape, scale, loc = 10, 0.1, 0\n#Lists to save the date for each parameter\n     a_params = []\n     b_params = []\n     c_params = []\n     d_params = [] \n     m_params = []\n#Prior Distributions for the Parameters\n     a = stats.erlang.rvs(shape, loc=loc, scale=scale, size=1, random_state=None)[0]\n     b = stats.erlang.rvs(shape, loc=loc, scale=scale, size=1, random_state=None)[0]\n     c = stats.erlang.rvs(shape, loc=loc, scale=scale, size=1, random_state=None)[0]\n     d = stats.erlang.rvs(shape, loc=loc, scale=scale, size=1, random_state=None)[0]\n\nfor i in range(0, n_sims): \n         m1 = 1+round((n-1) * np.random.uniform(0, 1));\n         a1 = stats.erlang.rvs(shape, loc=loc, scale=scale, size=1, random_state=None)[0]\n         b1 = stats.erlang.rvs(shape, loc=loc, scale=scale, size=1, random_state=None)[0]\n         c1 = stats.erlang.rvs(shape, loc=loc, scale=scale, size=1, random_state=None)[0]\n         d1 = stats.erlang.rvs(shape, loc=loc, scale=scale, size=1, random_state=None)[0]\n#PARAM A    \n         aux1 = 1\n         for j in range(0, m):\n             try:\n                 aux1 = aux1 * (center_kohonen[j] ** (a1-1))\n             except:\n                 aux1 = aux1\naux2 = 1\n         for j in range(0, m):\n             try:\n                 aux2 = aux2 * center_kohonen[j] ** (a-1)\n             except:\n                 aux2 = aux2\ntry:\n             ra = ((math.gamma(a1+b)/math.gamma(a1))**m)*aux1*((((a/a1)**.9)*math.exp(-.1*(a1-a)))**2)/(((math.gamma(a+b)/math.gamma(a))**m)*aux2)  \n             if (min(1, ra) > np.random.uniform(0, 1)):\n                 a=a1\n         except:\n             pass\n#PARAM B\n         aux1 = 1\n         for j in range(0, m):\n             try:\n                 aux1 = aux1*(1-center_kohonen[j])**(b1-1)\n             except:\n                 aux1 = aux1\naux2 = 1\n         for j in range(0, m):\n             try:\n                 aux2 = aux2*(1-center_kohonen[j])**(b-1)\n             except:\n                 aux2 = aux2\n\n         try:\n             rb = ((math.gamma(a+b1)/math.gamma(b1))**m)*aux1*((((b/b1)**.9)*math.exp(-.1*(b1-b)))**2)/(((math.gamma(a+b)/math.gamma(b))**m)*aux2)\n             if (min(1, rb) > np.random.uniform(0, 1)):\n                 b = b1\n         except:\n             pass\n#PARAM C\n         aux1 = 1\n         for j in range(m, n):\n             try:\n                 aux1=aux1*center_kohonen[j]**(c1-1)\n             except:\n                 aux1 = aux1\naux2 = 1\n         for j in range(m, n):\n             try:\n                 aux2=aux2*center_kohonen[j]**(c-1)\n             except:\n                 aux2 = aux2\ntry:\n             rc = ((math.gamma(c1+d)/math.gamma(c1))**(n-m))*aux1*((((c/c1)**.9)*math.exp(-.1*(c1-c)))**2)/(((math.gamma(c+d)/math.gamma(c))**(n-m))*aux2)\n             if (min(1, rc) > np.random.uniform(0, 1)):\n                 c = c1\n         except:\n             pass\n#PARAM D    \n         aux1 = 1\n         for j in range(m, n):\n             try:\n                 aux1=aux1*(1-center_kohonen[j])**(d1-1)\n             except:\n                 aux1 = aux1\naux2 = 1\n         for j in range(m, n):\n             try:\n                 aux2=aux2*(1-center_kohonen[j])**(d-1)\n             except:\n                 aux2 = aux2\ntry:\n             rd = ((math.gamma(c+d1)/math.gamma(d1))**(n-m))*aux1*((((d/d1)**.9)*math.exp(-.1*(d1-d)))**2)/(((math.gamma(c+d)/math.gamma(d))**(n-m))*aux2)\n             if (min(1, rd) > np.random.uniform(0, 1)):\n                 d = d1\n         except:\n             pass\n#PARAM M\n         aux1 = 1 \n         for j in range(0, m1):\n             try:\n                 aux1 = aux1*(center_kohonen[j]**(a-1))*((1-center_kohonen[j])**(b-1))\n             except:\n                 aux1 = aux1\naux2 = 1;\n         for j in range(m1, n):\n             try:\n                 aux2 = aux2*(center_kohonen[j]**(c-1))*((1-center_kohonen[j])**(d-1))            \n             except:\n                 aux2 = aux2\naux3 = 1\n         for j in range(0, m):\n             try:\n                 aux3 = aux3*(center_kohonen[j]**(a-1))*((1-center_kohonen[j])**(b-1))            \n             except:\n                 aux3 = aux3\naux4 = 1\n         for j in range(m, n):\n             try:\n                 aux4 = aux4*(center_kohonen[j]**(c-1))*((1-center_kohonen[j])**(d-1))\n             except:\n                 aux4 = aux4\ntry:\n             rm = (((math.gamma(a+b)/(math.gamma(a)*math.gamma(b)))**m1)*((math.gamma(c+d)/(math.gamma(c)*math.gamma(d)))**(n-m1))*aux1*aux2)/(((math.gamma(a+b)/(math.gamma(a)*math.gamma(b)))**m)*((math.gamma(c+d)/(math.gamma(c)*math.gamma(d)))**(n-m))*aux3*aux4)        \n             if (min(1, rm) > np.random.uniform(0, 1)):\n                 m = m1\n         except:\n             pass\n\n         a_params.append(a)\n         b_params.append(b)\n         c_params.append(c)\n         d_params.append(d)\n         m_params.append(m)\n    return a_params, b_params, c_params, d_params, m_params\n```", "```py\na_params, b_params, c_params, d_params, m_params = Metropolis_Hastings(center_1, n_sims=1000)\nfig_dims = (16, 10)\nfig, ax = plt.subplots(figsize=fig_dims)\nplt.plot(m_params, 'r')\nax.set(xlabel='# Simulations', ylabel='Change Point Candidates (m)')\n```", "```py\nfig_dims = (16, 10)\nfig, ax = plt.subplots(figsize=fig_dims)\nax.set(xlabel='Change Point Candidates', ylabel='Density')\nsns.kdeplot(m_params[200:])\n```", "```py\nfig, ax = plt.subplots(1, 1, figsize=(16, 8))\n\nax.set_ylabel('Density')\n\nbeta_1 = np.random.beta(np.mean(a_params[200:]), np.mean(b_params[200:]), size=1000)\nbeta_2 = np.random.beta(np.mean(c_params[200:]), np.mean(d_params[200:]), size=1000)\n\nsns.kdeplot(beta_1, color='b', fill=True, common_norm=False, alpha=.5, linewidth=0)\nsns.kdeplot(beta_2, color='r', fill=True, common_norm=False, alpha=.5, linewidth=0)\n```"]