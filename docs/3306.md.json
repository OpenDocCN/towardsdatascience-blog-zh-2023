["```py\nimport numpy as np\n\nclass KalmanFilter:\n    \"\"\"\n    An implementation of the classic Kalman Filter for linear dynamic systems.\n    The Kalman Filter is an optimal recursive data processing algorithm which\n    aims to estimate the state of a system from noisy observations.\n\n    Attributes:\n        F (np.ndarray): The state transition matrix.\n        B (np.ndarray): The control input marix.\n        H (np.ndarray): The observation matrix.\n        u (np.ndarray): the control input.\n        Q (np.ndarray): The process noise covariance matrix.\n        R (np.ndarray): The measurement noise covariance matrix.\n        x (np.ndarray): The mean state estimate of the previous step (k-1).\n        P (np.ndarray): The state covariance of previous step (k-1).\n    \"\"\"\n    def __init__(self, F, B, u, H, Q, R, x0, P0):\n        \"\"\"\n        Initializes the Kalman Filter with the necessary matrices and initial state.\n\n        Parameters:\n            F (np.ndarray): The state transition matrix.\n            B (np.ndarray): The control input marix.\n            H (np.ndarray): The observation matrix.\n            u (np.ndarray): the control input.\n            Q (np.ndarray): The process noise covariance matrix.\n            R (np.ndarray): The measurement noise covariance matrix.\n            x0 (np.ndarray): The initial state estimate.\n            P0 (np.ndarray): The initial state covariance matrix.\n        \"\"\"\n        self.F = F  # State transition matrix\n        self.B = B  # Control input matrix\n        self.u = u  # Control vector\n        self.H = H  # Observation matrix\n        self.Q = Q  # Process noise covariance\n        self.R = R  # Measurement noise covariance\n        self.x = x0  # Initial state estimate\n        self.P = P0  # Initial estimate covariance\n\n    def predict(self):\n        \"\"\"\n        Predicts the state and the state covariance for the next time step.\n        \"\"\"\n        self.x = self.F @ self.x + self.B @ self.u\n        self.P = self.F @ self.P @ self.F.T + self.Q\n        return self.x\n\n    def update(self, z):\n        \"\"\"\n        Updates the state estimate with the latest measurement.\n\n        Parameters:\n            z (np.ndarray): The measurement at the current step.\n        \"\"\"\n        y = z - self.H @ self.x\n        S = self.H @ self.P @ self.H.T + self.R\n        K = self.P @ self.H.T @ np.linalg.inv(S)\n        self.x = self.x + K @ y\n        I = np.eye(self.P.shape[0])\n        self.P = (I - K @ self.H) @ self.P\n\n        return self.x\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Set the random seed for reproducibility\nnp.random.seed(42)\n\n# Simulate the ground truth position of the object\ntrue_velocity = 0.5  # units per time step\nnum_steps = 50\ntime_steps = np.linspace(0, num_steps, num_steps)\ntrue_positions = true_velocity * time_steps\n\n# Simulate the measurements with noise\nmeasurement_noise = 10  # increase this value to make measurements noisier\nnoisy_measurements = true_positions + np.random.normal(0, measurement_noise, num_steps)\n\n# Plot the true positions and the noisy measurements\nplt.figure(figsize=(10, 6))\nplt.plot(time_steps, true_positions, label='True Position', color='green')\nplt.scatter(time_steps, noisy_measurements, label='Noisy Measurements', color='red', marker='o')\n\nplt.xlabel('Time Step')\nplt.ylabel('Position')\nplt.title('True Position and Noisy Measurements Over Time')\nplt.legend()\nplt.show()\n```", "```py\n# Kalman Filter Initialization\nF = np.array([[1, 1], [0, 1]])   # State transition matrix\nB = np.array([[0], [0]])          # No control input\nu = np.array([[0]])               # No control input\nH = np.array([[1, 0]])            # Measurement function\nQ = np.array([[1, 0], [0, 3]])    # Process noise covariance\nR = np.array([[measurement_noise**2]]) # Measurement noise covariance\nx0 = np.array([[0], [0]])         # Initial state estimate\nP0 = np.array([[1, 0], [0, 1]])   # Initial estimate covariance\n\nkf = KalmanFilter(F, B, u, H, Q, R, x0, P0)\n\n# Allocate space for estimated positions and velocities\nestimated_positions = np.zeros(num_steps)\nestimated_velocities = np.zeros(num_steps)\n\n# Kalman Filter Loop\nfor t in range(num_steps):\n    # Predict\n    kf.predict()\n\n    # Update\n    measurement = np.array([[noisy_measurements[t]]])\n    kf.update(measurement)\n\n    # Store the filtered position and velocity\n    estimated_positions[t] = kf.x[0]\n    estimated_velocities[t] = kf.x[1]\n\n# Plot the true positions, noisy measurements, and the Kalman filter estimates\nplt.figure(figsize=(10, 6))\nplt.plot(time_steps, true_positions, label='True Position', color='green')\nplt.scatter(time_steps, noisy_measurements, label='Noisy Measurements', color='red', marker='o')\nplt.plot(time_steps, estimated_positions, label='Kalman Filter Estimate', color='blue')\n\nplt.xlabel('Time Step')\nplt.ylabel('Position')\nplt.title('Kalman Filter Estimation Over Time')\nplt.legend()\nplt.show()\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\nclass KalmanFilter:\n    \"\"\"\n    An implementation of the classic Kalman Filter for linear dynamic systems.\n    The Kalman Filter is an optimal recursive data processing algorithm which\n    aims to estimate the state of a system from noisy observations.\n\n    Attributes:\n        F (np.ndarray): The state transition matrix.\n        B (np.ndarray): The control input marix.\n        H (np.ndarray): The observation matrix.\n        u (np.ndarray): the control input.\n        Q (np.ndarray): The process noise covariance matrix.\n        R (np.ndarray): The measurement noise covariance matrix.\n        x (np.ndarray): The mean state estimate of the previous step (k-1).\n        P (np.ndarray): The state covariance of previous step (k-1).\n    \"\"\"\n    def __init__(self, F=None, B=None, u=None, H=None, Q=None, R=None, x0=None, P0=None):\n        \"\"\"\n        Initializes the Kalman Filter with the necessary matrices and initial state.\n\n        Parameters:\n            F (np.ndarray): The state transition matrix.\n            B (np.ndarray): The control input marix.\n            H (np.ndarray): The observation matrix.\n            u (np.ndarray): the control input.\n            Q (np.ndarray): The process noise covariance matrix.\n            R (np.ndarray): The measurement noise covariance matrix.\n            x0 (np.ndarray): The initial state estimate.\n            P0 (np.ndarray): The initial state covariance matrix.\n        \"\"\"\n        self.F = F  # State transition matrix\n        self.B = B  # Control input matrix\n        self.u = u  # Control input\n        self.H = H  # Observation matrix\n        self.Q = Q  # Process noise covariance\n        self.R = R  # Measurement noise covariance\n        self.x = x0  # Initial state estimate\n        self.P = P0  # Initial estimate covariance\n\n    def predict(self):\n        \"\"\"\n        Predicts the state and the state covariance for the next time step.\n        \"\"\"\n        self.x = np.dot(self.F, self.x) + np.dot(self.B, self.u)\n        self.P = np.dot(np.dot(self.F, self.P), self.F.T) + self.Q\n\n    def update(self, z):\n        \"\"\"\n        Updates the state estimate with the latest measurement.\n\n        Parameters:\n            z (np.ndarray): The measurement at the current step.\n        \"\"\"\n        y = z - np.dot(self.H, self.x)\n        S = np.dot(self.H, np.dot(self.P, self.H.T)) + self.R\n        K = np.dot(np.dot(self.P, self.H.T), np.linalg.inv(S))\n        self.x = self.x + np.dot(K, y)\n        self.P = self.P - np.dot(np.dot(K, self.H), self.P)\n\n# Parameters for simulation\ntrue_angular_velocity = 0.1  # radians per time step\nradius = 20\nnum_steps = 100\ndt = 1  # time step\n\n# Create time steps\ntime_steps = np.arange(0, num_steps*dt, dt)\n\n# Ground truth state\ntrue_x_positions = radius * np.cos(true_angular_velocity * time_steps)\ntrue_y_positions = radius * np.sin(true_angular_velocity * time_steps)\ntrue_z_positions = 0.5 * time_steps  # constant velocity in z\n\n# Create noisy measurements\nmeasurement_noise = 1.0\nnoisy_x_measurements = true_x_positions + np.random.normal(0, measurement_noise, num_steps)\nnoisy_y_measurements = true_y_positions + np.random.normal(0, measurement_noise, num_steps)\nnoisy_z_measurements = true_z_positions + np.random.normal(0, measurement_noise, num_steps)\n\n# Kalman Filter initialization\nF = np.array([[1, 0, 0, -radius*dt*np.sin(true_angular_velocity*dt)],\n              [0, 1, 0, radius*dt*np.cos(true_angular_velocity*dt)],\n              [0, 0, 1, 0],\n              [0, 0, 0, 1]])\nB = np.zeros((4, 1))\nu = np.zeros((1, 1))\nH = np.array([[1, 0, 0, 0],\n              [0, 1, 0, 0],\n              [0, 0, 1, 0]])\nQ = np.eye(4) * 0.1  # Small process noise\nR = measurement_noise**2 * np.eye(3)  # Measurement noise\nx0 = np.array([[0], [radius], [0], [true_angular_velocity]])\nP0 = np.eye(4) * 1.0\n\nkf = KalmanFilter(F, B, u, H, Q, R, x0, P0)\n\n# Allocate space for estimated states\nestimated_states = np.zeros((num_steps, 4))\n\n# Kalman Filter Loop\nfor t in range(num_steps):\n    # Predict\n    kf.predict()\n\n    # Update\n    z = np.array([[noisy_x_measurements[t]],\n                  [noisy_y_measurements[t]],\n                  [noisy_z_measurements[t]]])\n    kf.update(z)\n\n    # Store the state\n    estimated_states[t, :] = kf.x.ravel()\n\n# Extract estimated positions\nestimated_x_positions = estimated_states[:, 0]\nestimated_y_positions = estimated_states[:, 1]\nestimated_z_positions = estimated_states[:, 2]\n\n# Plotting\nfig = plt.figure(figsize=(10, 8))\nax = fig.add_subplot(111, projection='3d')\n\n# Plot the true trajectory\nax.plot(true_x_positions, true_y_positions, true_z_positions, label='True Trajectory', color='g')\n# Plot the start and end markers for the true trajectory\nax.scatter(true_x_positions[0], true_y_positions[0], true_z_positions[0], label='Start (Actual)', c='green', marker='x', s=100)\nax.scatter(true_x_positions[-1], true_y_positions[-1], true_z_positions[-1], label='End (Actual)', c='red', marker='x', s=100)\n\n# Plot the noisy measurements\nax.scatter(noisy_x_measurements, noisy_y_measurements, noisy_z_measurements, label='Noisy Measurements', color='r')\n\n# Plot the estimated trajectory\nax.plot(estimated_x_positions, estimated_y_positions, estimated_z_positions, label='Estimated Trajectory', color='b')\n\n# Plot settings\nax.set_xlabel('X position')\nax.set_ylabel('Y position')\nax.set_zlabel('Z position')\nax.set_title('3D Trajectory Estimation with Kalman Filter')\nax.legend()\n\nplt.show()\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\nclass ExtendedKalmanFilter:\n    \"\"\"\n    An implementation of the Extended Kalman Filter (EKF).\n    This filter is suitable for systems with non-linear dynamics by linearising\n    the system model at each time step using the Jacobian.\n\n    Attributes:\n        state_transition (callable): The state transition function for the system.\n        jacobian_F (callable): Function to compute the Jacobian of the state transition.\n        H (np.ndarray): The observation matrix.\n        jacobian_H (callable): Function to compute the Jacobian of the observation model.\n        Q (np.ndarray): The process noise covariance matrix.\n        R (np.ndarray): The measurement noise covariance matrix.\n        x (np.ndarray): The initial state estimate.\n        P (np.ndarray): The initial estimate covariance.\n    \"\"\"\n    def __init__(self, state_transition, jacobian_F, observation_matrix, jacobian_H, Q, R, x, P):\n        \"\"\"\n        Constructs the Extended Kalman Filter.\n\n        Parameters:\n            state_transition (callable): The state transition function.\n            jacobian_F (callable): Function to compute the Jacobian of F.\n            observation_matrix (np.ndarray): Observation matrix.\n            jacobian_H (callable): Function to compute the Jacobian of H.\n            Q (np.ndarray): Process noise covariance.\n            R (np.ndarray): Measurement noise covariance.\n            x (np.ndarray): Initial state estimate.\n            P (np.ndarray): Initial estimate covariance.\n        \"\"\"\n        self.state_transition = state_transition  # Non-linear state transition function\n        self.jacobian_F = jacobian_F  # Function to compute Jacobian of F\n        self.H = observation_matrix  # Observation matrix\n        self.jacobian_H = jacobian_H  # Function to compute Jacobian of H\n        self.Q = Q  # Process noise covariance\n        self.R = R  # Measurement noise covariance\n        self.x = x  # Initial state estimate\n        self.P = P  # Initial estimate covariance\n\n    def predict(self, u):\n        \"\"\"\n        Predicts the state at the next time step.\n\n        Parameters:\n            u (np.ndarray): The control input vector.\n        \"\"\"\n        self.x = self.state_transition(self.x, u)\n        F = self.jacobian_F(self.x, u)\n        self.P = F @ self.P @ F.T + self.Q\n\n    def update(self, z):\n        \"\"\"\n        Updates the state estimate with a new measurement.\n\n        Parameters:\n            z (np.ndarray): The measurement vector.\n        \"\"\"\n        H = self.jacobian_H()\n        y = z - self.H @ self.x\n        S = H @ self.P @ H.T + self.R\n        K = self.P @ H.T @ np.linalg.inv(S)\n        self.x = self.x + K @ y\n        self.P = (np.eye(len(self.x)) - K @ H) @ self.P\n\n# Define the non-linear transition and Jacobian functions\ndef state_transition(x, u):\n    \"\"\"\n    Defines the state transition function for the system with non-linear dynamics.\n\n    Parameters:\n        x (np.ndarray): The current state vector.\n        u (np.ndarray): The control input vector containing time step and rate of change of angular velocity.\n\n    Returns:\n        np.ndarray: The next state vector as predicted by the state transition function.\n    \"\"\"\n    dt = u[0]\n    alpha = u[1]\n    x_next = np.array([\n        x[0] - x[3] * x[1] * dt,\n        x[1] + x[3] * x[0] * dt,\n        x[2] + x[3] * dt,\n        x[3],\n        x[4] + alpha * dt\n    ])\n    return x_next\n\ndef jacobian_F(x, u):\n    \"\"\"\n    Computes the Jacobian matrix of the state transition function.\n\n    Parameters:\n        x (np.ndarray): The current state vector.\n        u (np.ndarray): The control input vector containing time step and rate of change of angular velocity.\n\n    Returns:\n        np.ndarray: The Jacobian matrix of the state transition function at the current state.\n    \"\"\"\n    dt = u[0]\n    # Compute the Jacobian matrix of the state transition function\n    F = np.array([\n        [1, -x[3]*dt, 0, -x[1]*dt, 0],\n        [x[3]*dt, 1, 0, x[0]*dt, 0],\n        [0, 0, 1, dt, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 0, 1]\n    ])\n    return F\n\ndef jacobian_H():\n    # Jacobian matrix for the observation function is simply the observation matrix\n    return H\n\n# Simulation parameters\nnum_steps = 100\ndt = 1.0\nalpha = 0.01  # Rate of change of angular velocity\n\n# Observation matrix, assuming we can directly observe the x, y, and z position\nH = np.eye(3, 5)\n\n# Process noise covariance matrix\nQ = np.diag([0.1, 0.1, 0.1, 0.1, 0.01])\n\n# Measurement noise covariance matrix\nR = np.diag([0.5, 0.5, 0.5])\n\n# Initial state estimate and covariance\nx0 = np.array([0, 20, 0, 0.5, 0.1])  # [x, y, z, v, omega]\nP0 = np.eye(5)\n\n# Instantiate the EKF\nekf = ExtendedKalmanFilter(state_transition, jacobian_F, H, jacobian_H, Q, R, x0, P0)\n\n# Generate true trajectory and measurements\ntrue_states = []\nmeasurements = []\nfor t in range(num_steps):\n    u = np.array([dt, alpha])\n    true_state = state_transition(x0, u)  # This would be your true system model\n    true_states.append(true_state)\n    measurement = true_state[:3] + np.random.multivariate_normal(np.zeros(3), R)  # Simulate measurement noise\n    measurements.append(measurement)\n    x0 = true_state  # Update the true state\n\n# Now we run the EKF over the measurements\nestimated_states = []\nfor z in measurements:\n    ekf.predict(u=np.array([dt, alpha]))\n    ekf.update(z=np.array(z))\n    estimated_states.append(ekf.x)\n\n# Convert lists to arrays for plotting\ntrue_states = np.array(true_states)\nmeasurements = np.array(measurements)\nestimated_states = np.array(estimated_states)\n\n# Plotting the results\nfig = plt.figure(figsize=(12, 9))\nax = fig.add_subplot(111, projection='3d')\n\n# Plot the true trajectory\nax.plot(true_states[:, 0], true_states[:, 1], true_states[:, 2], label='True Trajectory')\n# Increase the size of the start and end markers for the true trajectory\nax.scatter(true_states[0, 0], true_states[0, 1], true_states[0, 2], label='Start (Actual)', c='green', marker='x', s=100)\nax.scatter(true_states[-1, 0], true_states[-1, 1], true_states[-1, 2], label='End (Actual)', c='red', marker='x', s=100)\n\n# Plot the measurements\nax.scatter(measurements[:, 0], measurements[:, 1], measurements[:, 2], label='Measurements', alpha=0.6)\n# Plot the start and end markers for the measurements\nax.scatter(measurements[0, 0], measurements[0, 1], measurements[0, 2], c='green', marker='o', s=100)\nax.scatter(measurements[-1, 0], measurements[-1, 1], measurements[-1, 2], c='red', marker='x', s=100)\n\n# Plot the EKF estimate\nax.plot(estimated_states[:, 0], estimated_states[:, 1], estimated_states[:, 2], label='EKF Estimate')\n\nax.set_xlabel('X')\nax.set_ylabel('Y')\nax.set_zlabel('Z')\nax.legend()\n\nplt.show()\n```"]