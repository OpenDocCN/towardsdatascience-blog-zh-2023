["```py\nv_Riley = get_value('Riley')\nv_dog = get_value('dog')\n\nratio = .75\nv_Riley = (ratio * v_Riley) + ((1-ratio) * v_dog)\n```", "```py\nv_Riley, v_dog = get_value('Riley'), get_value('dog')\nk_Riley, k_dog = get_key('Riley'), get_key('dog')\n\nrelevance = k_Riley 路 k_dog # dot product\n\nv_Riley = (relevance) * v_Riley + (1 - relevance) * v_dog\n```", "```py\nsentence = \"Evan's dog Riley is so hyper, she never stops moving\"\nwords = sentence.split()\n\n# obtain a list of values\nvalues = get_values(words)\n\n# oh yeah, that's what k stands for by the way\nkeys = get_keys(words)\n\n# get riley's relevance key\nriley_index = words.index('Riley')\nriley_key = keys[riley_index]\n\n# generate relevance of \"Riley\" to each other word\nrelevances = [riley_key 路 key for key in keys] #still pretending python has 路\n\n# normalize relevances to sum to 1\nrelevances /= sum(relevances)\n\n# takes a linear combination of values, weighted by relevances\nv_Riley = relevances 路 values\n```", "```py\nsentence = \"Evan's dog Riley is so hyper, she never stops moving\"\nwords = sentence.split()\nseq_len = len(words)\n\n# obtain arrays of queries, keys, and values, each of shape (seq_len, n)\nQ = array(get_queries(words))\nK = array(get_keys(words))\nV = array(get_values(words))\n\nrelevances = Q @ K.T\nnormalized_relevances = relevances / relevances.sum(axis=1)\n\nnew_V = normalized_relevances @ V\n```"]