["```py\n┌───────┬───────────┐\n│ value ┆ run_value │\n│ ---   ┆ ---       │\n│ i64   ┆ i64       │\n╞═══════╪═══════════╡\n│ 1     ┆ 1         │   # First run starts here\n│ 2     ┆ 3         │\n│ 3     ┆ 6         │\n│ -1    ┆ -1        │   # Run resets here\n│ -2    ┆ -3        │\n│ 1     ┆ 1         │   # Run resets here\n└───────┴───────────┘\n```", "```py\ndef calculate_runs_pd(s: pd.Series) -> pd.Series:\n    out = []\n    is_positive = True\n    current_value = 0.0\n    for value in s:\n        if value > 0:\n            if is_positive:\n                current_value += value\n            else:\n                current_value = value\n                is_positive = True\n        else:\n            if is_positive:\n                current_value = value\n                is_positive = False\n            else:\n                current_value += value\n        out.append(current_value)\n    return pd.Series(out)\n```", "```py\ndef calculate_runs_pl_apply(s: pl.Series) -> pl.DataFrame:\n    out = []\n    is_positive = True\n    current_value = 0.0\n    for value in s:\n        if value is None:\n            pass\n        elif value > 0:\n            if is_positive:\n                current_value += value\n            else:\n                current_value = value\n                is_positive = True\n        else:\n            if is_positive:\n                current_value = value\n                is_positive = False\n            else:\n                current_value += value\n        out.append(current_value)\n    return pl.DataFrame(pl.Series(\"run\", out))\n```", "```py\ndef calculate_runs_pl_native(df: pl.LazyFrame, col: str, by: str) -> pl.LazyFrame:\n    return (\n        df.with_columns((pl.col(col) > 0).alias(\"__is_positive\"))\n        .with_columns(\n            (pl.col(\"__is_positive\") != pl.col(\"__is_positive\").shift(1))\n            .over(by)\n            .fill_null(False)\n            .alias(\"__change_sides\")\n        )\n        .with_columns(pl.col(\"__change_sides\").cumsum().over(by).alias(\"__run_groups\"))\n        .with_columns(pl.col(col).cumsum().over(by, \"__run_groups\").alias(\"runs\"))\n        .select(~cs.starts_with(\"__\"))\n    )\n```", "```py\nuse polars::prelude::*;\nuse pyo3_polars::derive::polars_expr;\n\n#[polars_expr(output_type=Float64)]\nfn calculate_runs(inputs: &[Series]) -> PolarsResult<Series> {\n    let values = inputs[0].f64()?;\n    let mut run_values: Vec<f64> = Vec::with_capacity(values.len());\n    let mut current_run_value = 0.0;\n    let mut run_is_positive = true;\n    for value in values {\n        match value {\n            None => {\n                run_values.push(current_run_value);\n            }\n            Some(value) => {\n                if value > 0.0 {\n                    if run_is_positive {\n                        current_run_value += value;\n                    } else {\n                        current_run_value = value;\n                        run_is_positive = true;\n                    }\n                } else if run_is_positive {\n                    current_run_value = value;\n                    run_is_positive = false;\n                } else {\n                    current_run_value += value;\n                }\n                run_values.push(current_run_value);\n            }\n        }\n    }\n\n    Ok(Series::from_vec(\"runs\", run_values))\n}\n```", "```py\nfrom polars import selectors as cs\nfrom polars.utils.udfs import _get_shared_lib_location\n\nlib = _get_shared_lib_location(__file__)\n\n@pl.api.register_expr_namespace(\"runs\")\nclass RunNamespace:\n    def __init__(self, expr: pl.Expr):\n        self._expr = expr\n\n    def calculate_runs(\n        self,\n    ) -> pl.Expr:\n        return self._expr.register_plugin(\n            lib=lib,\n            symbol=\"calculate_runs\",\n            is_elementwise=False,\n            cast_to_supertypes=True,\n        )\n```", "```py\nfrom polars_extentsion import RunNamespace\n\ndf.select(\n  pl.col(feat_col).runs.calculate_runs().over(entity_col).alias(\"run_value\")\n).collect()\n```"]