["```py\npostcode,latitude,longitude,area_code,area_name,all_persons,females,males\n```", "```py\npostcode,latitude,longitude,area_code,area_name,all_persons,females,males,geometry_wkt \n```", "```py\npcd,pcd2,pcds,dointr,doterm,oscty,ced,oslaua,osward,parish,usertype,oseast1m,osnrth1m,osgrdind,oshlthau,nhser,ctry,rgn,streg,pcon,eer,teclec,ttwa,pct,itl,statsward,oa01,casward,park,lsoa01,msoa01,ur01ind,oac01,oa11,lsoa11,msoa11,wz11,sicbl,bua11,buasd11,ru11ind,oac11,lat,long,lep1,lep2,pfa,imd,calncv,icb,oa21,lsoa21,msoa21\n```", "```py\nmkdir -p indata\ncd indata\nif [ ! -f census2021.xlsx ]; then\n    wget -O census2021.xlsx https://www.ons.gov.uk/file?uri=/peoplepopulationandcommunity/populationandmigration/populationestimates/datasets/populationandhouseholdestimatesenglandandwalescensus2021/census2021/census2021firstresultsenglandwales1.xlsx\nfi\n```", "```py\nimport pandas as pd\npd.read_csv(POSTCODES_CSV)\n```", "```py\nimport duckdb\nconn = duckdb.connect()\n\nukpop = conn.execute(f\"\"\"\ninstall spatial;\nload spatial;\n\nSELECT \n  * \nFROM\nst_read('{POPULATION_XLS}', layer='P01')\n\"\"\").df()\n```", "```py\nukpop = ukpop.drop(range(0,7), axis=0).rename(columns={\n    'Field1': 'area_code', \n    'Field2': 'area_name', \n    'Field3': 'all_persons', \n    'Field4': 'females', \n    'Field5': 'males'\n})\n```", "```py\nukpop.to_csv(\"temp/ukpop.csv\", index=False)\n```", "```py\nonspd = pd.read_csv(ONSPD_CSV)\nonspd = onspd[['pcd', 'oslaua', 'osward', 'parish']]\nonspd.to_csv(\"temp/onspd.csv\", index=False)\n```", "```py\n /* pcd,oslaua,osward,parish */\nWITH onspd AS (\n    SELECT \n      * \n    FROM\n    read_csv_auto('temp/onspd.csv', header=True)\n),\n\n/* area_code,area_name,all_persons,females,males */\nukpop AS (\n    SELECT \n      * \n    FROM\n    read_csv_auto('temp/ukpop.csv', header=True)\n),\n\n/* id,postcode,latitude,longitude */\npostcodes AS (\n    SELECT \n      * \n    FROM\n    read_csv_auto('indata/ukpostcodes.csv', header=True)\n),\n\n/* postcode, area_code */\npostcode_to_areacode AS (\n  SELECT \n    pcd AS postcode,\n    ANY_VALUE(area_code) as area_code\n  FROM onspd\n  JOIN ukpop \n  ON (area_code = oslaua OR area_code = osward OR area_code = parish)\n  GROUP BY pcd\n)\n\nSELECT\n  postcode, latitude, longitude, /* from postcodes */\n  area_code, area_name, /* from ukpop */\n  all_persons,females,males /* from ukpop, but has to be spatially corrected */\nFROM postcode_to_areacode\nJOIN postcodes USING (postcode)\nJOIN ukpop USING (area_code) \n```", "```py\nnpostcodes = ukpop.groupby('area_code')['postcode'].count()\nfor col in ['females', 'males', 'all_persons']:\n    ukpop[col] = ukpop.apply(lambda row:  row[col]/npostcodes[row['area_code']], axis=1)\n```", "```py\nukpop.to_csv(\"ukpopulation.csv\", index=False)\n```", "```py\nimport numpy as np\nfrom scipy.spatial import Voronoi, voronoi_plot_2d\n\npoints = df[['latitude', 'longitude']].to_numpy()\nvor = Voronoi(points)\n```", "```py\ndef make_polygon(point_no):\n    region_no = vor.point_region[point_no]\n    region = vor.regions[region_no]\n    if len(region) >= 3:\n        # close the ring\n        closed_region = region.copy()\n        closed_region.append(closed_region[0])\n        # create a WKT of the points\n        polygon = \"POLYGON ((\" + ','.join([ f\"{vor.vertices[v][1]} {vor.vertices[v][0]}\" for v in closed_region]) + \"))\"\n        return polygon\n    else:\n        return None\n```", "```py\nPOLYGON ((-0.32491691953979235 51.7393550489536,-0.32527234008402217 51.73948967705648,-0.32515738641624575 51.73987124225542,-0.3241646650618929 51.74087626616231,-0.3215663358407994 51.742660660928614,-0.32145633473723817 51.742228570262824,-0.32491691953979235 51.7393550489536))\n```", "```py\nimport geopandas as gpd\nfrom shapely import wkt\ndf['geometry'] = gpd.GeoSeries.from_wkt(df['geometry_wkt'])\ngdf = gpd.GeoDataFrame(df, geometry='geometry')\n\ngdf[gdf['area_name'] == 'St Albans'].plot()\n```", "```py\ngdf[gdf['area_name'] == 'Birmingham'].plot()\n```", "```py\nGRIDRES = 0.01\nmin_lat, max_lat = np.round(min(df['latitude']), 2) - GRIDRES, max(df['latitude']) + GRIDRES\nmin_lon, max_lon = np.round(min(df['longitude']), 2) - GRIDRES, max(df['longitude']) + GRIDRES\nprint(min_lat, max_lat, min_lon, max_lon)\n\nnpostcodes = np.zeros([ int(1+(max_lat-min_lat)/GRIDRES), int(1+(max_lon-min_lon)/GRIDRES) ])\nfor point in points:\n    latno = int((point[0] - min_lat)/GRIDRES)\n    lonno = int((point[1] - min_lon)/GRIDRES)\n    npostcodes[latno, lonno] += 1\n\nunpop = []\nfor latno in range(len(npostcodes)):\n    for lonno in range(len(npostcodes[latno])):\n        if npostcodes[latno][lonno] == 0:\n            # no one lives here.\n            # make up a postcode for this location\n            # postcode latitude longitude area_code area_name persons_per_sqkm\n            unpop.append({\n                'postcode': f'UNPOP {latno}x{lonno}',\n                'latitude': min_lat + latno * 0.01,\n                'longitude': min_lon + lonno * 0.01,\n                'all_persons': 0\n            }) \n```", "```py\ndf2 = pd.concat([df, pd.DataFrame.from_records(unpop)])\npoints = df2[['latitude', 'longitude']].to_numpy()\nvor = Voronoi(points)\ndf2['geometry_wkt'] = [make_polygon(x) for x in range(len(vor.point_region))]\ndf2['geometry'] = gpd.GeoSeries.from_wkt(df2['geometry_wkt'])\ngdf = gpd.GeoDataFrame(df2, geometry='geometry')\n```", "```py\ngdf.to_csv(\"ukpostcodes.csv\", index=False)\n```", "```py\nCREATE OR REPLACE TABLE uk_public_data.postcode_popgeo2\nCLUSTER BY postcode\nAS\n\nSELECT \n  * EXCEPT(geometry_wkt),\n  SAFE.ST_GEOGFROMTEXT(geometry_wkt, make_valid=>TRUE) AS geometry,\nFROM uk_public_data.postcode_popgeo\n```", "```py\nSELECT \n  COUNT(*) AS num_postcodes,\n  SUM(ST_AREA(geometry))/1e6 AS total_area,\n  SUM(all_persons) AS population,\n  area_name\n FROM uk_public_data.postcode_popgeo2\n GROUP BY area_name\n ORDER BY population DESC\n```"]