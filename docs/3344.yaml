- en: How to Convert Any Text Into a Graph of Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://towardsdatascience.com/how-to-convert-any-text-into-a-graph-of-concepts-110844f22a1a?source=collection_archive---------0-----------------------#2023-11-10](https://towardsdatascience.com/how-to-convert-any-text-into-a-graph-of-concepts-110844f22a1a?source=collection_archive---------0-----------------------#2023-11-10)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A method to convert any text corpus into a Knowledge Graph using Mistral 7B
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@rahul.nyk?source=post_page-----110844f22a1a--------------------------------)[![Rahul
    Nayak](../Images/9f8aa2f9af4e02b31c114222756489e5.png)](https://medium.com/@rahul.nyk?source=post_page-----110844f22a1a--------------------------------)[](https://towardsdatascience.com/?source=post_page-----110844f22a1a--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----110844f22a1a--------------------------------)
    [Rahul Nayak](https://medium.com/@rahul.nyk?source=post_page-----110844f22a1a--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ¬∑
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F473e87f4b733&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-to-convert-any-text-into-a-graph-of-concepts-110844f22a1a&user=Rahul+Nayak&userId=473e87f4b733&source=post_page-473e87f4b733----110844f22a1a---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----110844f22a1a--------------------------------)
    ¬∑12 min read¬∑Nov 10, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F110844f22a1a&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-to-convert-any-text-into-a-graph-of-concepts-110844f22a1a&user=Rahul+Nayak&userId=473e87f4b733&source=-----110844f22a1a---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F110844f22a1a&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-to-convert-any-text-into-a-graph-of-concepts-110844f22a1a&source=-----110844f22a1a---------------------bookmark_footer-----------)![](../Images/fb08cad7edf14d0bbf132f706493fdbf.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Image generated by the author using the project shared in this article.
  prefs: []
  type: TYPE_NORMAL
- en: A few months ago, knowledge-based QnA (KBQA) was a novelty. Now KBQA with Retrieval
    Augmented Generation (RAG) is a piece of cake for any AI enthusiast. It‚Äôs fascinating
    to see how the realm of possibilities in NLP has expanded so rapidly due to LLMs.
    And it's getting better by the day.
  prefs: []
  type: TYPE_NORMAL
- en: In my last article, I shared a recursive RAG approach to implement QnA with
    multi-hop reasoning to answer complex queries based on a large corpus of text.
  prefs: []
  type: TYPE_NORMAL
- en: '[](/the-research-agent-4ef8e6f1b741?source=post_page-----110844f22a1a--------------------------------)
    [## The Research Agent: Addressing the Challenge of Answering Questions Based
    on a Large Text Corpus'
  prefs: []
  type: TYPE_NORMAL
- en: I made an Autonomous AI Research Agent that can answer difficult questions with
    deep multi-hop reasoning capabilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/the-research-agent-4ef8e6f1b741?source=post_page-----110844f22a1a--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: A good number of folks tried it out and sent their feedback. Thanks all for
    your feedback. I have since collated these contributions and made a few improvements
    to the code to address some of the problems with the original implementation.
    I plan to write a separate article about it.
  prefs: []
  type: TYPE_NORMAL
- en: In this article, I want to share another idea that may help create a super research
    agent when combined with recursive RAG. The idea emerged out of my experiments
    with recursive RAG with smaller LLMs, and a few other ideas that I read on Medium
    ‚Äî specifically one, the **Knowledge-Graph Augmented Generation.**
  prefs: []
  type: TYPE_NORMAL
- en: '**Abstract**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Knowledge Graphs (KG), or any Graph, is made up of Nodes and Edges. Each node
    of the KG represents a concept and each edge is a relationship between a pair
    of such concepts. In this article, I will share a method to convert any text corpus
    into a Graph of Concepts. I am using the term ‚ÄòGraph of Concept‚Äô (GC) interchangeably
    with the terms KG to better describe what I am demoing here.
  prefs: []
  type: TYPE_NORMAL
- en: All the components I used in this implementation can be set up locally, so this
    project can be run easily on a personal machine. I have adopted a no-GPT approach
    here because I believe in smaller open source models. I am using the fantastic
    Mistral 7B Openorca instruct and Zephyr models. These models can be set up locally
    with Ollama.
  prefs: []
  type: TYPE_NORMAL
- en: Databases like Neo4j make it easy to store and retrieve graph data. Here I am
    using in-memory Pandas Dataframes and the NetworkX Python library, to keep things
    simple.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal here is to convert any text corpus into a Graph of Concepts (GC) and
    visualise it like the beautiful banner image of this article. We will even interact
    with the network graph by moving nodes and edges, zooming in and out, and change
    the physics of the graph to our heart‚Äôs desire. Here is the Github page link that
    shows the result of what we are building.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://rahulnyk.github.io/knowledge_graph/](https://rahulnyk.github.io/knowledge_graph/)'
  prefs: []
  type: TYPE_NORMAL
- en: But first, let‚Äôs delve into the fundamental idea of KGs and why we need them.
    If you are familiar with this concept already, feel free to skip the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '**Knowledge Graph**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consider the following text.
  prefs: []
  type: TYPE_NORMAL
- en: '*Mary had a little lamb,'
  prefs: []
  type: TYPE_NORMAL
- en: You‚Äôve heard this tale before;
  prefs: []
  type: TYPE_NORMAL
- en: But did you know she passed her plate,
  prefs: []
  type: TYPE_NORMAL
- en: And had a little more!*
  prefs: []
  type: TYPE_NORMAL
- en: (I hope the kids are not reading this üòù)
  prefs: []
  type: TYPE_NORMAL
- en: Here is one possible representation of the text as a KG.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4fd39148664c94a81f884489e8151fa3.png)'
  prefs: []
  type: TYPE_IMG
- en: Diagram created by the Author using draw.io
  prefs: []
  type: TYPE_NORMAL
- en: The following article from IBM aptly explains the fundamental concept of Knowledge
    Graphs.
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://www.ibm.com/topics/knowledge-graph?source=post_page-----110844f22a1a--------------------------------)
    [## What is a Knowledge Graph? | IBM'
  prefs: []
  type: TYPE_NORMAL
- en: Learn about knowledge graphs, networks of semantic metadata which represent
    a collection of related entities.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: www.ibm.com](https://www.ibm.com/topics/knowledge-graph?source=post_page-----110844f22a1a--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 'Quoting an excerpt from the article to summarise the idea:'
  prefs: []
  type: TYPE_NORMAL
- en: A knowledge graph, also known as a semantic network, represents a network of
    real-world entities ‚Äî i.e. objects, events, situations, or concepts ‚Äî and illustrates
    the relationship between them. This information is usually stored in a graph database
    and visualised as a graph structure, prompting the term knowledge ‚Äúgraph.‚Äù
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Why Knowledge Graph?**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Knowledge Graphs are useful in a variety of ways. We can run graph algorithms
    and calculate the centralities for any node, to understand how important a concept
    (node) is to the body of work. We can analyse connected and disconnected sets
    of concepts, or calculate communities of concepts for a deep understanding of
    the subject matter. We can understand links between seemingly disconnected concepts.
  prefs: []
  type: TYPE_NORMAL
- en: We can also use knowledge graphs to implement Graph Retrieval Augmented Generation
    (GRAG or GAG) and chat with our documents. This can give us much better results
    than the plain old version of RAG, which suffers several shortcomings. For example,
    retrieving the context that is the most relevant for the query with a simple semantic
    similarity search is not always effective. Especially, when the query does not
    provide enough context about its true intent, or when the context is fragments
    across a large corpus of text.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider this query ‚Äî
  prefs: []
  type: TYPE_NORMAL
- en: '***Tell me about the family tree of Jos√© Arcadio Buend√≠a in the book ‚ÄòOne Hundred
    years of Solitude‚Äô.***'
  prefs: []
  type: TYPE_NORMAL
- en: The book documents 7 generations of *Jos√© Arcadio Buend√≠a* with half of the
    characters named *Jos√© Arcadio Buend√≠a*. It will be quite a challenge, if even
    possible, to answer the query using a simple RAG pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Another shortcoming of RAG is that it can‚Äôt tell you what to ask. Very often,
    asking the right question is more important that getting the answers.
  prefs: []
  type: TYPE_NORMAL
- en: Graph Augmented generation (GAG) can address these shortcomings of RAG up to
    some extent. Better still, we can mix and match and build a Graph Augmented Retrieval
    Augmented Generation pipeline to get the best of both worlds.
  prefs: []
  type: TYPE_NORMAL
- en: So now we know that Graphs are interesting, they can be extremely useful, and
    they also look beautiful.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating the Graph of Concepts**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you were to ask GPT, how to create a graph of knowledge from a given text?
    it may suggest a process like the following.
  prefs: []
  type: TYPE_NORMAL
- en: Extract concepts and entities from the body of work. These are the nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract relations between the concepts. These are the edges.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Populate nodes (concepts) and edges (relations) in a graph data structure or
    a graph database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visualise, for some artistic gratification if nothing else.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Steps 3 and 4 sound understandable. But how do you achieve steps 1 and 2?
  prefs: []
  type: TYPE_NORMAL
- en: Here is a flow diagram of the method I devised to extract a graph of concepts
    from any given text corpus. It is similar to the above method but for a few minor
    differences.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/df5cd67aa84360e05c33020c840d23dc.png)'
  prefs: []
  type: TYPE_IMG
- en: Diagram created by the Author using draw.io
  prefs: []
  type: TYPE_NORMAL
- en: Split the corpus of text into chunks. Assign a chunk_id to each of these chunks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For every text chunk extract concepts and their semantic relationships using
    an LLM. Let‚Äôs assign this relation a weightage of W1\. There can be multiple relationships
    between the same pair of concepts. Every such relation is an edge between a pair
    of concepts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consider that the concepts that occur in the same text chunk are also related
    by their contextual proximity. Let‚Äôs assign this relation a weightage of W2\.
    Note that the same pair of concepts may occur in multiple chunks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Group similar pairs, sum their weights, and concatenate their relationships.
    So now we have only one edge between any distinct pair of concepts. The edge has
    a certain weight and a list of relations as its name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can see the implementation of this method as a Python code, in the GitHub
    repository I share in this article. Let us briefly walk through the key ideas
    of the implementation in the next few sections.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate the method here, I am using the following review article published
    in PubMed/Cureus under the terms of the Creative Commons Attribution License.
    Credit to the authors at the end of this article.
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://www.cureus.com/articles/158868-indias-opportunity-to-address-human-resource-challenges-in-healthcare?source=post_page-----110844f22a1a--------------------------------#!/)
    [## India''s Opportunity to Address Human Resource Challenges in Healthcare'
  prefs: []
  type: TYPE_NORMAL
- en: India's health indicators have improved in recent times but continue to lag
    behind those of its peer nations. The‚Ä¶
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: www.cureus.com](https://www.cureus.com/articles/158868-indias-opportunity-to-address-human-resource-challenges-in-healthcare?source=post_page-----110844f22a1a--------------------------------#!/)
  prefs: []
  type: TYPE_NORMAL
- en: '**The Mistral and the Prompt**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Step 1 in the above flow chart is easy. Langchain provides a plethora of text
    splitters we can use to split our text into chunks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2 is where the real fun starts. To extract the concepts and their relationships,
    I am using the Mistral 7B model. Before converging on the variant of the model
    best suited for our purpose, I experimented with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Mistral Instruct](https://huggingface.co/mistralai/Mistral-7B-Instruct-v0.1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Mistral OpenOrca](https://huggingface.co/Open-Orca/Mistral-7B-OpenOrca), and'
  prefs: []
  type: TYPE_NORMAL
- en: '[Zephyr (Hugging Face version derived from Mistral)](https://huggingface.co/HuggingFaceH4/zephyr-7b-beta)'
  prefs: []
  type: TYPE_NORMAL
- en: I used the 4-bit quantised version of these models ‚Äî So that my Mac doesn‚Äôt
    start hating me ‚Äî hosted locally with Ollama.
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://ollama.ai/?source=post_page-----110844f22a1a--------------------------------)
    [## Ollama'
  prefs: []
  type: TYPE_NORMAL
- en: Get up and running with large language models, locally.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ollama.ai](https://ollama.ai/?source=post_page-----110844f22a1a--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: These models are all instruction-tuned models with a system prompt and a user
    prompt. They all do a pretty good job at following the instructions and formatting
    the answer neatly in JSONs if we tell them to.
  prefs: []
  type: TYPE_NORMAL
- en: After a few rounds of hit and trial, I finally converged on to the **Zephyr
    model** with the following prompts.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]) Your task is to extract the ontology "'
  prefs: []
  type: TYPE_NORMAL
- en: '"of terms mentioned in the given context. These terms should represent the
    key concepts as per the context. \n"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"Thought 1: While traversing through each sentence, Think about the key terms
    mentioned in it.\n"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"\tTerms may include object, entity, location, organization, person, \n"'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"\tcondition, acronym, documents, service, concept, etc.\n"'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"\tTerms should be as atomistic as possible\n\n"'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"Thought 2: Think about how these terms can have one on one relation with other
    terms.\n"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"\tTerms that are mentioned in the same sentence or the same paragraph are
    typically related to each other.\n"'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"\tTerms can be related to many other terms\n\n"'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"Thought 3: Find out the relation between each such related pair of terms.
    \n\n"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"Format your output as a list of json. Each element of the list contains a
    pair of terms"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"and the relation between them, like the follwing: \n"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"[\n"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"   {\n"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '''       "node_1": "A concept from extracted ontology",\n'''
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '''       "node_2": "A related concept from extracted ontology",\n'''
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '''       "edge": "relationship between the two concepts, node_1 and node_2
    in one or two sentences"\n'''
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"   }, {...}\n"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"]"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'USER_PROMPT = f"context: [PRE1] \n\n output: "'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '['
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"node_1": "Mary",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"node_2": "lamb",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"edge": "owned by"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"node_1": "plate",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"node_2": "food",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"edge": "contained"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}, . . .'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: G = nx.Graph()
  prefs: []
  type: TYPE_NORMAL
- en: Add nodes to the graph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'for node in nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: G.add_node(str(node))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add edges to the graph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'for index, row in dfg.iterrows():'
  prefs: []
  type: TYPE_NORMAL
- en: G.add_edge(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: str(row["node_1"]),
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: str(row["node_2"]),
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: title=row["edge"],
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: weight=row['count']
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '['
  prefs: []
  type: TYPE_NORMAL
- en: '''digital technology'','
  prefs: []
  type: TYPE_NORMAL
- en: '''EVIN'','
  prefs: []
  type: TYPE_NORMAL
- en: '''medical devices'','
  prefs: []
  type: TYPE_NORMAL
- en: '''online training management information systems'','
  prefs: []
  type: TYPE_NORMAL
- en: '''wearable, trackable technology'''
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: This immediately gives us an idea about the broad theme of health technologies
    discussed in the review paper and enables us to ask questions that we can then
    answer with our RAG Pipeline. Isn‚Äôt that great?
  prefs: []
  type: TYPE_NORMAL
- en: Let us also calculate the degree of each concept in our graph. The degree of
    a node is the total number of edges it is connected with. So in our case, the
    higher the degree of a concept, the more central it is to the subject of our text.
    We will use the degree as the size of the node in our visualisation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Graph Visualisation**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visualisation is the most fun part of this exercise. It has a certain quality
    to it that gives you an artistic gratification.
  prefs: []
  type: TYPE_NORMAL
- en: I am using the PiVis library to create interactive graphs. [Pyvis is a Python
    library for visualizing networks](https://github.com/WestHealth/pyvis/tree/master#pyvis---a-python-library-for-visualizing-networks).
    Here is a medium article that demonstrates the ease and the power of the Library
  prefs: []
  type: TYPE_NORMAL
- en: '[](/pyvis-visualize-interactive-network-graphs-in-python-77e059791f01?source=post_page-----110844f22a1a--------------------------------)
    [## Pyvis: Visualize Interactive Network Graphs in Python'
  prefs: []
  type: TYPE_NORMAL
- en: All it Takes is a Few Lines of Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/pyvis-visualize-interactive-network-graphs-in-python-77e059791f01?source=post_page-----110844f22a1a--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Pyvis has a built-in NetworkX Helper to translate our NetworkX graph into PyVis
    Objects. So we need no more coding‚Ä¶. Yay!!
  prefs: []
  type: TYPE_NORMAL
- en: Remember, we have already calculated the weights of each edge for the thickness
    of the edge, the communities of nodes for their colour, and the degree of each
    node as their size.
  prefs: []
  type: TYPE_NORMAL
- en: So, with all these bells and whistles, here is our graph.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/fe3e0691e930bea4d3bfe6249c4f9582.png)'
  prefs: []
  type: TYPE_IMG
- en: Gif generate by the author using the project discussed in this article.
  prefs: []
  type: TYPE_NORMAL
- en: 'Link to the interactive graph: [*https://rahulnyk.github.io/knowledge_graph/*](https://rahulnyk.github.io/knowledge_graph/)'
  prefs: []
  type: TYPE_NORMAL
- en: We can zoom in and out and move nodes and edges as we wish. We also have slider
    pannel at the bottom of the page to change the physics of the graph. See how the
    graph can help us ask the right questions and understand the subject matter better!
  prefs: []
  type: TYPE_NORMAL
- en: We can further discuss how our graph can help us build Graph Augmented Retrieval
    and how that can help us build a better RAG pipeline. But I think it‚Äôs better
    to leave it for another day. We have achieved our goal for this article already!
  prefs: []
  type: TYPE_NORMAL
- en: Github Repo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://github.com/rahulnyk/knowledge_graph?source=post_page-----110844f22a1a--------------------------------)
    [## GitHub - rahulnyk/knowledge_graph: Convert any text to a graph of knowledge.
    This can be used for‚Ä¶'
  prefs: []
  type: TYPE_NORMAL
- en: Convert any text to a graph of knowledge. This can be used for Graph Augmented
    Generation or Knowledge Graph based QnA‚Ä¶
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: github.com](https://github.com/rahulnyk/knowledge_graph?source=post_page-----110844f22a1a--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Contributions and suggestions most welcome
  prefs: []
  type: TYPE_NORMAL
- en: I have used the following article for the demonstration of my code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saxena S G, Godfrey T (June 11, 2023) India‚Äôs Opportunity to Address Human
    Resource Challenges in Healthcare. Cureus 15(6): e40274\. DOI 10.7759/cureus.40274**'
  prefs: []
  type: TYPE_NORMAL
- en: I am grateful to the authors for the wonderful work, and for releasing it under
    the Creative Commons Attribution License.
  prefs: []
  type: TYPE_NORMAL
- en: '**About me**'
  prefs: []
  type: TYPE_NORMAL
- en: I am a learner of architecture (not the buildings‚Ä¶ the tech kind). In the past,
    I have worked with Semiconductor modelling, Digital circuit design, Electronic
    Interface modelling, and the Internet of Things. Currently, I am working with
    Data Interoperability and data warehouse architectures for Health and Wellness,
    at Walmart Health and Wellness.
  prefs: []
  type: TYPE_NORMAL
