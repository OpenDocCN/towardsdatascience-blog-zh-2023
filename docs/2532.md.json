["```py\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nimport librosa\nimport librosa.display\nimport IPython.display as ipd\nimport scipy as spp\n```", "```py\n# Listen to the audio files\n# Ensure correct relative / absolute path to the sound files.\n\nacoustic_guitar_path = \"acoustic_guitar.wav\"\nipd.Audio(acoustic_guitar_path)\n\nbrass_path = \"brass.wav\"\nipd.Audio(brass_path)\n\n# Keep volume low!\ndrum_set_path = \"drum_set.wav\"\nipd.Audio(drum_set_path)\n```", "```py\n# Load music in librosa\nsr = 22050\nacoustic_guitar, sr = librosa.load(acoustic_guitar_path, sr = sr)\nbrass, sr = librosa.load(brass_path, sr = sr)\ndrum_set, sr = librosa.load(drum_set_path, sr = sr)\n```", "```py\ndef show_waveform(signal, name=\"\"):\n    # Create a new figure with a specific size\n    plt.figure(figsize=(15, 7))\n    # Display the waveform of the signal using librosa\n    librosa.display.waveshow(signal, alpha=0.5)\n    # Set the title of the plot\n    plt.title(\"Waveform for \" + name)\n    # Show the plot\n    plt.show()\n\nshow_waveform(acoustic_guitar, \"Acoustic Guitar\")\nshow_waveform(brass, \"Brass\")\nshow_waveform(drum_set, \"Drum Set\")\n```", "```py\nFRAME_SIZE = 1024\nHOP_LENGTH = 512\n\ndef amplitude_envelope(signal, frame_size=1024, hop_length=512):\n    \"\"\"\n    Computes the Amplitude Envelope of a signal using a sliding window.\n\n    Args:\n        signal (array): The input signal.\n        frame_size (int): The size of each frame in samples.\n        hop_length (int): The number of samples between consecutive frames.\n\n    Returns:\n        np.array: An array of Amplitude Envelope values.\n    \"\"\"\n    res = []\n    for i in range(0, len(signal), hop_length):\n        # Get a portion of the signal\n        cur_portion = signal[i:i + frame_size]  \n        # Compute the maximum value in the portion\n        ae_val = max(cur_portion)  \n        # Store the amplitude envelope value\n        res.append(ae_val)  \n    # Convert the result to a NumPy array\n    return np.array(res)\n\ndef plot_amplitude_envelope(signal, name, frame_size=1024, hop_length=512):\n    \"\"\"\n    Plots the waveform of a signal with the overlay of Amplitude Envelope values.\n\n    Args:\n        signal (array): The input signal.\n        name (str): The name of the signal for the plot title.\n        frame_size (int): The size of each frame in samples.\n        hop_length (int): The number of samples between consecutive frames.\n    \"\"\"\n    # Compute the amplitude envelope\n    ae = amplitude_envelope(signal, frame_size, hop_length)\n    # Generate the frame indices\n    frames = range(0, len(ae))  \n    # Convert frames to time\n    time = librosa.frames_to_time(frames, hop_length=hop_length)  \n    # Create a new figure with a specific size\n    plt.figure(figsize=(15, 7))  \n    # Display the waveform of the signal\n    librosa.display.waveshow(signal, alpha=0.5)  \n    # Plot the amplitude envelope over time\n    plt.plot(time, ae, color=\"r\") \n    # Set the title of the plot\n    plt.title(\"Waveform for \" + name + \" (Amplitude Envelope)\")  \n    # Show the plot\n    plt.show()  \n\nplot_amplitude_envelope(acoustic_guitar, \"Acoustic Guitar\")\nplot_amplitude_envelope(brass, \"Brass\")\nplot_amplitude_envelope(drum_set, \"Drum Set\")\n```", "```py\ndef RMS_energy(signal, frame_size=1024, hop_length=512):\n    \"\"\"\n    Computes the RMS (Root Mean Square) energy of a signal using a sliding window.\n\n    Args:\n        signal (array): The input signal.\n        frame_size (int): The size of each frame in samples.\n        hop_length (int): The number of samples between consecutive frames.\n\n    Returns:\n        np.array: An array of RMS energy values.\n    \"\"\"\n    res = []\n    for i in range(0, len(signal), hop_length):\n        # Extract a portion of the signal\n        cur_portion = signal[i:i + frame_size]  \n        # Compute the RMS energy for the portion\n        rmse_val = np.sqrt(1 / len(cur_portion) * sum(i**2 for i in cur_portion))  \n        res.append(rmse_val)\n    # Convert the result to a NumPy array\n    return np.array(res)\n\ndef plot_RMS_energy(signal, name, frame_size=1024, hop_length=512):\n    \"\"\"\n    Plots the waveform of a signal with the overlay of RMS energy values.\n\n    Args:\n        signal (array): The input signal.\n        name (str): The name of the signal for the plot title.\n        frame_size (int): The size of each frame in samples.\n        hop_length (int): The number of samples between consecutive frames.\n    \"\"\"\n    # Compute the RMS Energy\n    rmse = RMS_energy(signal, frame_size, hop_length)\n    # Generate the frame indices\n    frames = range(0, len(rmse))  \n    # Convert frames to time\n    time = librosa.frames_to_time(frames, hop_length=hop_length) \n    # Create a new figure with a specific size\n    plt.figure(figsize=(15, 7))\n    # Display the waveform as a spectrogram-like plot\n    librosa.display.waveshow(signal, alpha=0.5)  \n    # Plot the RMS energy values\n    plt.plot(time, rmse, color=\"r\") \n    # Set the title of the plot\n    plt.title(\"Waveform for \" + name + \" (RMS Energy)\")\n    plt.show()\n\nplot_RMS_energy(acoustic_guitar, \"Acoustic Guitar\")\nplot_RMS_energy(brass, \"Brass\")\nplot_RMS_energy(drum_set, \"Drum Set\")\n```", "```py\ndef crest_factor(signal, frame_size=1024, hop_length=512):\n    \"\"\"\n    Computes the crest factor of a signal using a sliding window.\n\n    Args:\n        signal (array): The input signal.\n        frame_size (int): The size of each frame in samples.\n        hop_length (int): The number of samples between consecutive frames.\n\n    Returns:\n        np.array: An array of crest factor values.\n    \"\"\"\n    res = []\n    for i in range(0, len(signal), hop_length):\n        # Get a portion of the signal\n        cur_portion = signal[i:i + frame_size]  \n        # Compute the RMS energy for the portion\n        rmse_val = np.sqrt(1 / len(cur_portion) * sum(i ** 2 for i in cur_portion))  \n        # Compute the crest factor\n        crest_val = max(np.abs(cur_portion)) / rmse_val  \n        # Store the crest factor value\n        res.append(crest_val)  \n    # Convert the result to a NumPy array\n    return np.array(res)  \n\ndef plot_crest_factor(signal, name, frame_size=1024, hop_length=512):\n    \"\"\"\n    Plots the crest factor of a signal over time.\n\n    Args:\n        signal (array): The input signal.\n        name (str): The name of the signal for the plot title.\n        frame_size (int): The size of each frame in samples.\n        hop_length (int): The number of samples between consecutive frames.\n    \"\"\"\n    # Compute the crest factor\n    crest = crest_factor(signal, frame_size, hop_length)  \n    # Generate the frame indices\n    frames = range(0, len(crest))  \n    # Convert frames to time\n    time = librosa.frames_to_time(frames, hop_length=hop_length)  \n    # Create a new figure with a specific size\n    plt.figure(figsize=(15, 7))  \n    # Plot the crest factor over time\n    plt.plot(time, crest, color=\"r\")  \n    # Set the title of the plot\n    plt.title(name + \" (Crest Factor)\")  \n    # Show the plot\n    plt.show()  \n\nplot_crest_factor(acoustic_guitar, \"Acoustic Guitar\")\nplot_crest_factor(brass, \"Brass\")\nplot_crest_factor(drum_set, \"Drum Set\")\n```", "```py\ndef ZCR(signal, frame_size=1024, hop_length=512):\n    \"\"\"\n    Computes the Zero Crossing Rate (ZCR) of a signal using a sliding window.\n\n    Args:\n        signal (array): The input signal.\n        frame_size (int): The size of each frame in samples.\n        hop_length (int): The number of samples between consecutive frames.\n\n    Returns:\n        np.array: An array of ZCR values.\n    \"\"\"\n    res = []\n    for i in range(0, len(signal), hop_length):\n        # Get a portion of the signal\n        cur_portion = signal[i:i + frame_size]  \n         # Compute the number of sign changes in the portion\n        zcr_val = num_sign_changes(cur_portion) \n        # Store the ZCR value\n        res.append(zcr_val)  \n    # Convert the result to a NumPy array\n    return np.array(res)  \n\ndef num_sign_changes(signal):\n    \"\"\"\n    Computes the number of sign changes in a signal.\n\n    Args:\n        signal (array): The input signal.\n\n    Returns:\n        int: The number of sign changes.\n    \"\"\"\n    res = 0\n    for i in range(0, len(signal) - 1):\n        # Check if there is a sign change between consecutive samples\n        if (signal[i] * signal[i + 1] < 0):  \n            res += 1\n    return res\n\ndef plot_ZCR(signal, name, frame_size=1024, hop_length=512):\n    \"\"\"\n    Plots the Zero Crossing Rate (ZCR) of a signal over time.\n\n    Args:\n        signal (array): The input signal.\n        name (str): The name of the signal for the plot title.\n        frame_size (int): The size of each frame in samples.\n        hop_length (int): The number of samples between consecutive frames.\n    \"\"\"\n    # Compute the ZCR\n    zcr = ZCR(signal, frame_size, hop_length)  \n    # Generate the frame indices\n    frames = range(0, len(zcr)) \n    # Convert frames to time\n    time = librosa.frames_to_time(frames, hop_length=hop_length)  \n     # Create a new figure with a specific size\n    plt.figure(figsize=(15, 7)) \n    # Plot the ZCR over time\n    plt.plot(time, zcr, color=\"r\")  \n    # Set the title of the plot\n    plt.title(name + \" (Zero Crossing Rate)\")  \n    # Show the plot\n    plt.show()  \n\nplot_ZCR(acoustic_guitar, \"Acoustic Guitar\")\nplot_ZCR(brass, \"Brass\")\nplot_ZCR(drum_set, \"Drum Set\")\n```", "```py\nFRAME_SIZE = 1024\nHOP_LENGTH = 512\n\ndef plot_spectrogram(signal, sample_rate, frame_size=1024, hop_length=512):\n    \"\"\"\n    Plots the spectrogram of an audio signal.\n\n    Args:\n        signal (array-like): The input audio signal.\n        sample_rate (int): The sample rate of the audio signal.\n        frame_size (int): The size of each frame in samples.\n        hop_length (int): The number of samples between consecutive frames.\n    \"\"\"\n    # Compute the STFT\n    spectrogram = librosa.stft(signal, n_fft=frame_size, hop_length=hop_length)  \n    # Convert the STFT to dB scale\n    spectrogram_db = librosa.amplitude_to_db(np.abs(spectrogram))  \n    # Create a new figure with a specific size\n    plt.figure(figsize=(15, 7))  \n    # Display the spectrogram\n    librosa.display.specshow(spectrogram_db, sr=sample_rate, hop_length=hop_length, x_axis='time', y_axis='log') \n    # Add a colorbar to show the magnitude scale\n    plt.colorbar(format='%+2.0f dB') \n    # Set the title of the plot\n    plt.title('Spectrogram')  \n    # Set the label for the x-axis\n    plt.xlabel('Time') \n    # Set the label for the y-axis\n    plt.ylabel('Frequency (Hz)')  \n    # Adjust the layout of the plot\n    plt.tight_layout()  \n    # Show the plot\n    plt.show()  \n\nplot_spectrogram(acoustic_guitar, sr)\nplot_spectrogram(brass, sr)\nplot_spectrogram(drum_set, sr)\n```", "```py\ndef find_split_freq_bin(spec, split_freq, sample_rate, frame_size=1024, hop_length=512):\n    \"\"\"\n    Calculate the bin index corresponding to a given split frequency.\n\n    Args:\n        spec (array): The spectrogram.\n        split_freq (float): The split frequency in Hz.\n        sample_rate (int): The sample rate of the audio.\n        frame_size (int, optional): The size of each frame in samples. Default is 1024.\n        hop_length (int, optional): The number of samples between consecutive frames. Default is 512.\n\n    Returns:\n        int: The bin index corresponding to the split frequency.\n    \"\"\"\n    # Calculate the range of frequencies\n    range_of_freq = sample_rate / 2\n    # Calculate the change in frequency per bin\n    change_per_bin = range_of_freq / spec.shape[0]\n    # Calculate the bin corresponding to the split frequency\n    split_freq_bin = split_freq / change_per_bin\n    return int(np.floor(split_freq_bin))\n\ndef band_energy_ratio(signal, split_freq, sample_rate, frame_size=1024, hop_length=512):\n    \"\"\"\n    Compute the band energy ratio (BER) of a signal.\n\n    Args:\n        signal (array): The input signal.\n        split_freq (float): The split frequency in Hz.\n        sample_rate (int): The sample rate of the audio.\n        frame_size (int, optional): The size of each frame in samples. Default is 1024.\n        hop_length (int, optional): The number of samples between consecutive frames. Default is 512.\n\n    Returns:\n        ndarray: The band energy ratios for each frame of the signal.\n    \"\"\"\n    # Compute the spectrogram of the signal\n    spec = librosa.stft(signal, n_fft=frame_size, hop_length=hop_length)\n    # Find the bin corresponding to the split frequency\n    split_freq_bin = find_split_freq_bin(spec, split_freq, sample_rate, frame_size, hop_length)\n    # Extract the magnitude and transpose it\n    modified_spec = np.abs(spec).T\n    res = []\n    for sub_arr in modified_spec:\n        # Compute the energy in the low-frequency range\n        low_freq_density = sum(i ** 2 for i in sub_arr[:split_freq_bin])\n        # Compute the energy in the high-frequency range\n        high_freq_density = sum(i ** 2 for i in sub_arr[split_freq_bin:])\n        # Compute the band energy ratio\n        ber_val = low_freq_density / high_freq_density\n        res.append(ber_val)\n    return np.array(res)\n\ndef plot_band_energy_ratio(signal, split_freq, sample_rate, name, frame_size=1024, hop_length=512):\n    \"\"\"\n    Plot the band energy ratio (BER) of a signal over time.\n\n    Args:\n        signal (ndarray): The input signal.\n        split_freq (float): The split frequency in Hz.\n        sample_rate (int): The sample rate of the audio.\n        name (str): The name of the signal for the plot title.\n        frame_size (int, optional): The size of each frame in samples. Default is 1024.\n        hop_length (int, optional): The number of samples between consecutive frames. Default is 512.\n    \"\"\"\n    # Compute the band energy ratio (BER)\n    ber = band_energy_ratio(signal, split_freq, sample_rate, frame_size, hop_length)\n    # Generate the frame indices\n    frames = range(0, len(ber))\n    # Convert frames to time\n    time = librosa.frames_to_time(frames, hop_length=hop_length)\n    # Create a new figure with a specific size\n    plt.figure(figsize=(15, 7))\n    # Plot the BER over time\n    plt.plot(time, ber)\n    # Set the title of the plot\n    plt.title(name + \" (Band Energy Ratio)\")\n    # Show the plot\n    plt.show()\n\nplot_band_energy_ratio(acoustic_guitar, 2048, sr, \"Acoustic Guitar\")\nplot_band_energy_ratio(brass, 2048, sr, \"Brass\")\nplot_band_energy_ratio(drum_set, 2048, sr, \"Drum Set\")\n```", "```py\ndef spectral_centroid(signal, sample_rate, frame_size=1024, hop_length=512):\n    \"\"\"\n    Compute the Spectral Centroid of a signal.\n\n    Args:\n        signal (array): The input signal.\n        sample_rate (int): The sample rate of the audio.\n        frame_size (int, optional): The size of each frame in samples. Default is 1024.\n        hop_length (int, optional): The number of samples between consecutive frames. Default is 512.\n\n    Returns:\n        ndarray: The spectral centroids for each frame of the signal.\n    \"\"\"\n    # Compute the spectrogram of the signal\n    spec = librosa.stft(signal, n_fft=frame_size, hop_length=hop_length)\n    # Extract the magnitude and transpose it\n    modified_spec = np.abs(spec).T\n    res = []\n    for sub_arr in modified_spec:\n        # Compute the spectral centroid\n        sc_val = sc(sub_arr)\n        # Store the value of spectral centroid for current frame\n        res.append(sc_val)\n    return np.array(res)\n\ndef sc(arr):\n    \"\"\"\n    Computes the spectral centroid in a signal.\n\n    Args:\n        arr (array): Frequency domain array for current frame.\n\n    Returns:\n        float: The spectral centroid value for current frame.\n    \"\"\"\n    res = 0\n    for i in range(0, len(arr)):\n        # Compute weighted sum\n        res += i*arr[i]\n    return res/sum(arr)\n\ndef bin_to_freq(spec, bin_val, sample_rate, frame_size=1024, hop_length=512):\n    \"\"\"\n    Calculate the frequency corresponding to a given bin value\n\n    Args:\n        spec (array): The spectrogram.\n        bin_val (): The bin value.\n        sample_rate (int): The sample rate of the audio.\n        frame_size (int, optional): The size of each frame in samples. Default is 1024.\n        hop_length (int, optional): The number of samples between consecutive frames. Default is 512.\n\n    Returns:\n        int: The bin index corresponding to the split frequency.\n    \"\"\"\n    # Calculate the range of frequencies\n    range_of_freq = sample_rate / 2\n    # Calculate the change in frequency per bin\n    change_per_bin = range_of_freq / spec.shape[0]\n    # Calculate the frequency corresponding to the bin\n    split_freq = bin_val*change_per_bin\n    return split_freq\n\ndef plot_spectral_centroid(signal, sample_rate, name, frame_size=1024, hop_length=512, col = \"black\"):\n    \"\"\"\n    Plot the spectral centroid of a signal over time.\n\n    Args:\n        signal (ndarray): The input signal.\n        sample_rate (int): The sample rate of the audio.\n        name (str): The name of the signal for the plot title.\n        frame_size (int, optional): The size of each frame in samples. Default is 1024.\n        hop_length (int, optional): The number of samples between consecutive frames. Default is 512.\n    \"\"\"\n    # Compute the STFT\n    spectrogram = librosa.stft(signal, n_fft=frame_size, hop_length=hop_length)  \n    # Convert the STFT to dB scale\n    spectrogram_db = librosa.amplitude_to_db(np.abs(spectrogram)) \n    # Compute the Spectral Centroid\n    sc_arr = spectral_centroid(signal, sample_rate, frame_size, hop_length)\n    # Compute corresponding frequencies:\n    sc_freq_arr = bin_to_freq(spectrogram_db, sc_arr, sample_rate, frame_size, hop_length)\n    # Generate the frame indices\n    frames = range(0, len(sc_arr))\n    # Convert frames to time\n    time = librosa.frames_to_time(frames, hop_length=hop_length)\n    # Create a new figure with a specific size\n    plt.figure(figsize=(15, 7))\n    # Display the Spectrogram\n    librosa.display.specshow(spectrogram_db, sr=sample_rate, hop_length=hop_length, x_axis='time', y_axis='log') \n    # Add a colorbar to show the magnitude scale\n    plt.colorbar(format='%+2.0f dB')  \n    # Plot the Spectral Centroid over time\n    plt.plot(time, sc_freq_arr, color=col)\n    # Set the title of the plot\n    plt.title(name + \" (Spectral Centroid)\")\n    # Show the plot\n    plt.show()\n\nplot_spectral_centroid(acoustic_guitar, sr, \"Acoustic Guitar\")\nplot_spectral_centroid(brass, sr, \"Brass\", col = \"white\")\nplot_spectral_centroid(drum_set, sr, \"Drum Set\")\n```", "```py\ndef spectral_bandwidth(signal, sample_rate, frame_size=1024, hop_length=512):\n    \"\"\"\n    Compute the Spectral Bandwidth of a signal.\n\n    Args:\n        signal (array): The input signal.\n        sample_rate (int): The sample rate of the audio.\n        frame_size (int, optional): The size of each frame in samples. Default is 1024.\n        hop_length (int, optional): The number of samples between consecutive frames. Default is 512.\n\n    Returns:\n        ndarray: The spectral bandwidths for each frame of the signal.\n    \"\"\"\n    # Compute the spectrogram of the signal\n    spec = librosa.stft(signal, n_fft=frame_size, hop_length=hop_length)\n    # Extract the magnitude and transpose it\n    modified_spec = np.abs(spec).T\n    res = []\n    for sub_arr in modified_spec:\n        # Compute the spectral bandwidth\n        sb_val = sb(sub_arr)\n        # Store the value of spectral bandwidth for current frame\n        res.append(sb_val)\n    return np.array(res)\n\ndef sb(arr):\n    \"\"\"\n    Computes the spectral bandwidth in a signal.\n\n    Args:\n        arr (array): Frequency domain array for current frame.\n\n    Returns:\n        float: The spectral bandwidth value for current frame.\n    \"\"\"\n    res = 0\n    sc_val = sc(arr)\n    for i in range(0, len(arr)):\n        # Compute weighted sum\n        res += (abs(i - sc_val))*arr[i]\n    return res/sum(arr)\n\ndef plot_spectral_bandwidth(signal, sample_rate, name, frame_size=1024, hop_length=512):\n    \"\"\"\n    Plot the spectral bandwidth of a signal over time.\n\n    Args:\n        signal (ndarray): The input signal.\n        sample_rate (int): The sample rate of the audio.\n        name (str): The name of the signal for the plot title.\n        frame_size (int, optional): The size of each frame in samples. Default is 1024.\n        hop_length (int, optional): The number of samples between consecutive frames. Default is 512.\n    \"\"\"\n    # Compute the Spectral bandwidth\n    sb_arr = spectral_bandwidth(signal, sample_rate, frame_size, hop_length)\n    # Generate the frame indices\n    frames = range(0, len(sb_arr))\n    # Convert frames to time\n    time = librosa.frames_to_time(frames, hop_length=hop_length)\n    # Create a new figure with a specific size\n    plt.figure(figsize=(15, 7))\n    # Plot the Spectral Bandwidth over time\n    plt.plot(time, sb_arr)\n    # Set the title of the plot\n    plt.title(name + \" (Spectral Bandwidth)\")\n    # Show the plot\n    plt.show()\n\nplot_spectral_bandwidth(acoustic_guitar, sr, \"Acoustic Guitar\")\nplot_spectral_bandwidth(brass, sr, \"Brass\")\nplot_spectral_bandwidth(drum_set, sr, \"Drum Set\")\n```", "```py\ndef spectral_flatness(signal, sample_rate, frame_size=1024, hop_length=512):\n    \"\"\"\n    Compute the Spectral Flatness of a signal.\n\n    Args:\n        signal (array): The input signal.\n        sample_rate (int): The sample rate of the audio.\n        frame_size (int, optional): The size of each frame in samples. Default is 1024.\n        hop_length (int, optional): The number of samples between consecutive frames. Default is 512.\n\n    Returns:\n        ndarray: The spectral flatness for each frame of the signal.\n    \"\"\"\n    # Compute the spectrogram of the signal\n    spec = librosa.stft(signal, n_fft=frame_size, hop_length=hop_length)\n    # Extract the magnitude and transpose it\n    modified_spec = np.abs(spec).T\n    res = []\n    for sub_arr in modified_spec:\n        # Compute the geometric mean\n        geom_mean = np.exp(np.log(sub_arr).mean())\n        # Compute the arithmetic mean\n        ar_mean = np.mean(sub_arr)\n        # Compute the spectral flatness\n        sl_val = geom_mean/ar_mean\n        # Store the value of spectral flatness for current frame\n        res.append(sl_val)\n    return np.array(res)\n\ndef plot_spectral_flatness(signal, sample_rate, name, frame_size=1024, hop_length=512):\n    \"\"\"\n    Plot the spectral flatness of a signal over time.\n\n    Args:\n        signal (ndarray): The input signal.\n        sample_rate (int): The sample rate of the audio.\n        name (str): The name of the signal for the plot title.\n        frame_size (int, optional): The size of each frame in samples. Default is 1024.\n        hop_length (int, optional): The number of samples between consecutive frames. Default is 512.\n    \"\"\"\n    # Compute the Spectral bandwidth\n    sl_arr = spectral_flatness(signal, sample_rate, frame_size, hop_length)\n    # Generate the frame indices\n    frames = range(0, len(sl_arr))\n    # Convert frames to time\n    time = librosa.frames_to_time(frames, hop_length=hop_length)\n    # Create a new figure with a specific size\n    plt.figure(figsize=(15, 7))\n    # Plot the Spectral Flatness over time\n    plt.plot(time, sl_arr)\n    # Set the title of the plot\n    plt.title(name + \" (Spectral Flatness)\")\n    # Show the plot\n    plt.show()\n\nplot_spectral_flatness(acoustic_guitar, sr, \"Acoustic Guitar\")\nplot_spectral_flatness(brass, sr, \"Brass\")\nplot_spectral_flatness(drum_set, sr, \"Drum Set\")\n```"]