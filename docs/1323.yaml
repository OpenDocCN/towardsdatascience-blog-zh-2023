- en: The One Thing You Need to Learn Recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/the-one-thing-you-need-to-learn-lecursion-55c03637b5e1?source=collection_archive---------18-----------------------#2023-04-14](https://towardsdatascience.com/the-one-thing-you-need-to-learn-lecursion-55c03637b5e1?source=collection_archive---------18-----------------------#2023-04-14)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (And *a lot* more)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://sassoli.medium.com/?source=post_page-----55c03637b5e1--------------------------------)[![Bernardino
    Sassoli](../Images/b4c956d5070100e4e798264f4947652a.png)](https://sassoli.medium.com/?source=post_page-----55c03637b5e1--------------------------------)[](https://towardsdatascience.com/?source=post_page-----55c03637b5e1--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----55c03637b5e1--------------------------------)
    [Bernardino Sassoli](https://sassoli.medium.com/?source=post_page-----55c03637b5e1--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F64ab339d120f&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fthe-one-thing-you-need-to-learn-lecursion-55c03637b5e1&user=Bernardino+Sassoli&userId=64ab339d120f&source=post_page-64ab339d120f----55c03637b5e1---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----55c03637b5e1--------------------------------)
    ·9 min read·Apr 14, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F55c03637b5e1&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fthe-one-thing-you-need-to-learn-lecursion-55c03637b5e1&user=Bernardino+Sassoli&userId=64ab339d120f&source=-----55c03637b5e1---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F55c03637b5e1&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fthe-one-thing-you-need-to-learn-lecursion-55c03637b5e1&source=-----55c03637b5e1---------------------bookmark_footer-----------)![](../Images/0feb822326f96d5b06af9f9b11d93f3f.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Photo by [Szabo Viktor](https://unsplash.com/@vmxhu?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: 'An old, somewhat abused quip goes:'
  prefs: []
  type: TYPE_NORMAL
- en: '*To understand recursion, you need to understand recursion.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It’s the kind of joke that only programmers, mathematicians, or logicians find
    funny. It also isn’t true.
  prefs: []
  type: TYPE_NORMAL
- en: Like many other things, the one thing you need to understand recursion is *practice*.
    Write a lot of simple recursive functions. Then write a lot more. Then write some
    more complex recursive ones. And so on. But how do you do it? I have a trick.
    It’s a book. It’s short (less than 200 pages), compelling, and will teach you
    much more than how to write recursion. It will also introduce you to some of the
    most foundational concepts in computer science, such as the Y combinator, interpreters,
    combinators, and the halting problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'This marvelous little book is called *The Little Schemer*.¹ In the “Preface”,
    almost at the very beginning, the authors emphatically state:'
  prefs: []
  type: TYPE_NORMAL
- en: The goal of the book is to teach the reader to thinkrecursively*.*
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you go through *The Little Schemer*, recursion will become a familiar way
    of thinking about problems. But, in the meantime, you will learn a veritable treasure
    trove of basic ideas. Moreover, the book is written in a very peculiar style,
    forcing you to work through its problems and assimilate its concepts.
  prefs: []
  type: TYPE_NORMAL
- en: In what follows, I will give a brief overview of what recursion is and why you
    should learn it. Then I will introduce you to the book and explain why it’s an
    outstanding tool that will make you a better programmer.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**: if you are a complete beginner, and you aren’t into more abstract
    topics, this might not be the best book for you. If you are at the stage in which
    you want to learn to code and have something to show, my suggestion is come back
    to the book later, when you feel comfortable in one programming language. Then
    again, if your interests in programming are more philosophical or theoretical,
    this might be a good starting point.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Recursion: why it matters'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recursion is daunting; the word “magic” gets thrown around a lot. Advice to
    beginners abound. I read someone advising beginners to “trust the magic” — or
    something to that effect. You might get told to learn how the call stack works.
    Sure, it’s useful, even fundamental: yet, not the best way to become proficient
    or even comfortable using recursion. I know none of those suggestions truly worked
    for me. What *did* work was, you guessed it, practice. I may not be a master of
    recursion. But certainly, I am now more than comfortable with using it. As a matter
    of fact, I sometimes now struggle *not* to write recursive functions even when
    I could use simpler, more efficient solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I suspect people struggle with recursion because it somehow (mistakenly) suggests
    that an *infinite regress* is going on behind the scenes. It *seems* as though
    recursion is akin to what happens when two mirrors are placed in front of themselves:
    the first reflects the reflection of the second which reflects the reflection
    of the first which reflects …. It’s an effect that was — incidentally — [cleverly
    employed](https://en.wikipedia.org/wiki/Droste_effect) by many artists and designers.
    But that’s not at all what happens.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A recursive *function* is a function that calls itself. For example, here are
    two (slightly different) functions that consume an array or list of integers and
    return its sum, in Javascript and Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Both functions will:'
  prefs: []
  type: TYPE_NORMAL
- en: Check if the input is empty, in which case they will return 0 (the *base case*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, they will add the first item of the input to the result of calling
    that function of the remainder of the input (all of the items except the first
    one) (the *recursive call*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A recursive function *will* keep calling itself infinitely, *unless* it hits
    the base case. When that happens, the recursive calls stop — which is why we avoid
    an infinite loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'That may be all well and good: but why should I become proficient in writing
    recursive functions? After all, anything you can write recursively, you can do
    with iteration in a while loop. Why struggle with this magic-seeming tool? That’s
    a sensible question. Off the top of my head I can think of at least the following
    three reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Algorithms and data structures**: many foundational algorithms are recursive
    in nature (think “divide and conquer”). Some data structures are best represented
    recursively (think graphs or trees)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even within **machine learning** recursive structures and algorithms are more
    common than one might think **(**not to mention **AI** in general, where they
    are ubiquitous). For example, the implementation of [decision trees](https://en.wikipedia.org/wiki/Decision_tree)
    is [inherently recursive](https://machinelearningmastery.com/implement-decision-tree-algorithm-scratch-python/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functional programming**: some say functional *languages* are slowly growing
    in popularity. That may or may not be true. Certainly, more and more “mainstream”
    languages such as Python or Javascript now support functional programming. Moreover,
    some widely used libraries and frameworks (such as React) are by and large based
    on functional practices. Given that the functional paradigm has no notion of *assignment*
    (a little more on that later), recursion is absolutely paramount for it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Understanding**: recursion forces you to reduce problems to other, smaller-sized,
    problems. That is one of the most valuable skills you may develop as a programmer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unfortunately, I can’t think of a single extensive resource dedicated to practicing
    recursion. That’s where *The Little Schemer* comes in.
  prefs: []
  type: TYPE_NORMAL
- en: The best book for learning recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../Images/b350f8680dd9e708e14f3af7170cf952.png)'
  prefs: []
  type: TYPE_IMG
- en: My copy of TLS — and a cup of espresso (I am Italian!) [Image by the author]
  prefs: []
  type: TYPE_NORMAL
- en: Judging by the title, *The Little Schemer* (henceforth, *TLS*) should be a book
    about the programming language [Scheme](https://en.wikipedia.org/wiki/Scheme_(programming_language)),
    one of the many that compose the family of LISPs. So why would someone want to
    learn a LISP or Scheme specifically? The thing is, the title is a misnomer. Scheme
    is a language that is very well suited to teaching certain fundamentals of computer
    science² — and for the purposes of *TLS* the syntax you need is so sparse you
    can seriously pick it up in a few minutes. You can safely see it more as a pedagogical
    tool than as a full-fledged language³.
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking of pedagogy: the book employs a quirky style. It is written in two
    columns, as some sort of Socratic dialogue between a student and a teacher. This
    is how it begins:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Is it true that this is an atom? atom*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It doesn’t give you definitions — it asks the reader questions (often in the
    form of exercises) and then provides answers (or solutions). It takes some getting
    used to, but it’s strangely effective.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9e674942a67744b3172fa55689b19168.png)'
  prefs: []
  type: TYPE_IMG
- en: The quirky style of TLS [Image by the author]
  prefs: []
  type: TYPE_NORMAL
- en: 'What does recursion have to do with all this? Well, in *TLS* the authors use
    Scheme in a way that doesn’t support variable assignment or iterations. There
    are no `while` or `for` loops. This means that if you have to write a function
    what will, for example, check if a certain number is contained in a list or array
    of numbers, you cannot do something like (in Python):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, you *have* to think recursively:'
  prefs: []
  type: TYPE_NORMAL
- en: There is a base case in which the list will be *empty* and the function should
    return False
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, you *select the first* item of the list and *check it for equality*
    against the given number; if they match the function returns True. If they do
    not, (recursively) call the function with the *remainder* of the list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is how you write *everything* in TLS. Scheme operates on only two basic
    syntactic elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '*atom*s: one or more alphanumeric characters'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*lists*: zero or more atoms or lists enclosed in parentheses.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To write functions such as the above all you need is:'
  prefs: []
  type: TYPE_NORMAL
- en: a programming construct to *test* if two expressions are the same
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: another *test* to check if a a list is *empty*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*selectors* for the first element of a list and for the remainder of the list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a way to express conditionals (such as `if`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more complex functions, you also need a *constructor* to build lists. Together
    with some means of *defining* functions, that’s all. This is why almost all of
    the syntax you need is introduced in the first chapter, in less than 10 breezy
    pages (the exception is the list-building constructor cons which gets introduced
    in chapter 3). The first three chapters walk you through many simpler recursive
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the time you reach Chapter 4 you should have become familiar with the basic
    design pattern for writing recursive functions which operate on lists: functions
    such as the one above that check for whether a particular item is a member of
    a list. Or functions that replace the first (or all) occurrences of a given item
    in a list with another.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That knowledge is subsequently applied to building the basic *arithmetic operations
    from first principles*. Again, this is done by using recursion on numbers and
    resorting to provided primitives, which increment and decrement a number by 1\.
    For example, addition of two numbers *n* and *m* is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: 'base case: if *m* is zero, return *n*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, recursively return the result of applying the addition function to
    incremented *n* and decremented *m*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chapters 5 and 6 introduce recursive functions on arbitrarily deeply-nested
    lists: lists that may contain lists that may, in turn, contain lists, and so on.
    Basically, you rewrite all of the functions from the previous chapters so that
    they work in the “deeper” cases.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This knowledge finds its concrete application in Chapter 6, where you write
    an interpreter for arithmetic expressions. Let me emphasize: we are 100 pages
    into the book. We began with no knowledge of Scheme and the sparsest syntax —
    yet here we are, building an interpreter that evaluates operations *we defined*.
    If you are interested in the more theoretical aspects of programming, chances
    are you will find this very rewarding and exciting.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 is devoted to set-theoretic constructs, relations, and functions,
    all of which, again, is left for the reader to discover in the course of reading
    through the student-teacher dialogue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 8 is perhaps the least satisfying of the book: it is remarkably steep,
    and it’s hard to see the point of some of the constructs introduced here. The
    crux of it seems to be the introduction of [continuations](https://en.wikipedia.org/wiki/Continuation-passing_style),
    but I must confess that I struggled with this chapter (as, apparently, have many
    others).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the preceding one, Chapter 9 is *challenging*: a lot of fundamental concepts
    get introduced in a few pages which lead up to a discussion of the *applicative-order
    Y combinator*. I did enjoy it a lot, but it took me quite a few attempts and the
    help of some online resources (see below) to get through it. By the way, if you
    ever wondered what on Earth the Y combinator is (while we are on the topic of
    recursion): it’s (very coarsely) how you *define* recursion in a language that
    has no way to name functions (and hence, a language in which all functions are
    anonymous — such as *lambda* functions in Python). Being able to grok the Y combinator
    is an enriching experience and, for me, one of the book’s highlights.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The final chapter puts it all together when you end up writing a Scheme interpreter
    *in Scheme*. Let it sink in: with only a few primitives, and *using only recursion*
    you are writing an interpreter for a language by bootstrapping that language itself.'
  prefs: []
  type: TYPE_NORMAL
- en: I hope I was able to convey the excitement I felt while going through *TLS*.
    And I hope you will reach out to me to share your experience.
  prefs: []
  type: TYPE_NORMAL
- en: Additional resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have a GitHub repo (in progress!) where I am publishing notes, the solutions,
    and a fairly extensive test-suite for the book in Racket [here](https://github.com/bsassoli/The-Little-Schemer)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another GitHub repo (also in Racket) I like: [https://github.com/bmitc/the-little-scheme](https://github.com/bmitc/the-little-schemer)r'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And yet another one: [https://github.com/willprice/little-schemer](https://github.com/willprice/little-schemer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A negative (yet, not entirely off-base) review of the book: [https://inventwithpython.com/blog/2018/12/09/book-review-the-little-schemer/](https://inventwithpython.com/blog/2018/12/09/book-review-the-little-schemer/))
    to counterbalance my enthusiasm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An [excellent blog post](https://mvanier.livejournal.com/2897.html) on the Y
    combinator if you get stuck
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[**1**] Friedman, Daniel, P, Felleisen, Matthias [The Little Schemer], The
    MIT Press, Cambridge, MA, 1986, 4th edition 1996 ([https://mitpress.mit.edu/9780262560993/the-little-schemer/](https://mitpress.mit.edu/9780262560993/the-little-schemer/)).
    Originally published as *The Little LISPer*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[**2**] In fact one of (if not the) most well-regarded computer science books
    of all time, [*Structure and Interpretation of Computer Programs*](https://web.mit.edu/6.001/6.037/sicp.pdf)
    utilizes Scheme.'
  prefs: []
  type: TYPE_NORMAL
- en: '[**3**] This is not significant but I should mention that my implementation
    of the exercises in TLS is not in Scheme but in [Racket](https://racket-lang.org/),
    which is basically a successor to Scheme.'
  prefs: []
  type: TYPE_NORMAL
