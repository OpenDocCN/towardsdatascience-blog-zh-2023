["```py\nclass Solution:\n    def shortestPath(self, grid: List[List[int]], k: int) -> int:\n        rows, cols = len(grid), len(grid[0])\n        target = (rows - 1, cols - 1)\n\n        # if we have sufficient quotas to eliminate the obstacles in the worst case,\n        # then the shortest distance is the Manhattan distance\n        if k >= rows + cols - 2:\n            return rows + cols - 2\n\n        # (row, col, remaining quota to eliminate obstacles)\n        state = (0, 0, k)\n        # (steps, state)\n        queue = deque([(0, state)])\n        seen = set([state])\n\n        while queue:\n            steps, (row, col, k) = queue.popleft()\n\n            # we reach the target here\n            if (row, col) == target:\n                return steps\n\n            # explore the four directions in the next step\n            for new_row, new_col in [(row, col + 1), (row + 1, col), (row, col - 1), (row - 1, col)]:\n                # if (new_row, new_col) is within the grid boundaries\n                if (0 <= new_row < rows) and (0 <= new_col < cols):\n                    new_eliminations = k - grid[new_row][new_col]\n                    new_state = (new_row, new_col, new_eliminations)\n                    # add the next move in the queue if it qualifies\n                    if new_eliminations >= 0 and new_state not in seen:\n                        seen.add(new_state)\n                        queue.append((steps + 1, new_state))\n\n        # did not reach the target\n        return -1\n```"]