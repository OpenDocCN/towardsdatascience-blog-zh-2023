["```py\nhalf_saturation_unscaled = half_saturation * (spend_max - spend_min) + spend_min\n```", "```py\nclass HillSaturation(BaseEstimator, TransformerMixin):\n    def __init__(self, slope_s, half_saturation_k):\n        self.slope_s = slope_s\n        self.half_saturation_k = half_saturation_k\n\n    def fit(self, X, y=None):\n        return self\n\n    def transform(self, X: np.ndarray, x_point = None):\n\n        self.half_saturation_k_transformed  = self.half_saturation_k * (np.max(X) - np.min(X)) + np.min(X)\n\n        if x_point is None:\n            return (1 + self.half_saturation_k_transformed**self.slope_s / X**self.slope_s)**-1\n\n        #calculate y at x_point\n        return (1 + self.half_saturation_k_transformed**self.slope_s / x_point**self.slope_s)**-1\n```", "```py\noptimization_percentage = 0.2\n\nmedia_channel_average_spend = result[\"model_data\"][media_channels].mean(axis=0).values\n\nlower_bound = media_channel_average_spend * np.ones(len(media_channels))*(1-optimization_percentage)\nupper_bound = media_channel_average_spend * np.ones(len(media_channels))*(1+optimization_percentage)\n\nboundaries = optimize.Bounds(lb=lower_bound, ub=upper_bound)\n\ndef budget_constraint(media_spend, budget):  \n  return np.sum(media_spend) - budget\n\ndef saturation_objective_function(coefficients, \n                                  hill_slopes, \n                                  hill_half_saturations, \n                                  media_min_max_dictionary, \n                                  media_inputs):\n\n    responses = []\n    for i in range(len(coefficients)):\n        coef = coefficients[i]\n        hill_slope = hill_slopes[i]\n        hill_half_saturation = hill_half_saturations[i]\n\n        min_max = np.array(media_min_max_dictionary[i])\n        media_input = media_inputs[i]\n\n        hill_saturation = HillSaturation(slope_s = hill_slope, half_saturation_k=hill_half_saturation).transform(X = min_max, x_point = media_input)\n        response = coef * hill_saturation\n        responses.append(response)\n\n    responses = np.array(responses)\n    responses_total = np.sum(responses)\n    return -responses_total\n\npartial_saturation_objective_function = partial(saturation_objective_function, \n                                                media_coefficients, \n                                                media_hill_slopes, \n                                                media_hill_half_saturations, \n                                                media_min_max)\n\nmax_iterations = 100\nsolver_func_tolerance = 1.0e-10\n\nsolution = optimize.minimize(\n      fun=partial_saturation_objective_function,\n      x0=media_channel_average_spend,\n      bounds=boundaries,\n      method=\"SLSQP\",\n      jac=\"3-point\",\n      options={\n          \"maxiter\": max_iterations,\n          \"disp\": True,\n          \"ftol\": solver_func_tolerance,\n      },\n      constraints={\n          \"type\": \"eq\",\n          \"fun\": budget_constraint,\n          \"args\": (np.sum(media_channel_average_spend), )\n      })\n```", "```py\noptimization_period = result[\"model_data\"].shape[0]\nprint(f\"optimization period: {optimization_period}\")\n\noptimization_percentage = 0.2\n\nmedia_channel_average_spend = optimization_period * result[\"model_data\"][media_channels].mean(axis=0).values\n\nlower_bound = media_channel_average_spend * np.ones(len(media_channels))*(1-optimization_percentage)\nupper_bound = media_channel_average_spend * np.ones(len(media_channels))*(1+optimization_percentage)\n\nboundaries = optimize.Bounds(lb=lower_bound, ub=upper_bound)\n```", "```py\ndef model_based_objective_function(model, \n                                   optimization_period, \n                                   model_features, \n                                   additional_inputs, \n                                   hill_slopes, \n                                   hill_half_saturations, \n                                   media_min_max_ranges, \n                                   media_channels, \n                                   media_inputs):\n\n    media_channel_period_average_spend = media_inputs/optimization_period\n\n    #transform original spend into hill transformed\n    transformed_media_spends = []\n    for index, media_channel in enumerate(media_channels):\n        hill_slope = hill_slopes[media_channel]\n        hill_half_saturation = hill_half_saturations[media_channel]\n\n        min_max_spend = media_min_max_ranges[index]\n        media_period_spend_average = media_channel_period_average_spend[index]\n\n        transformed_spend = HillSaturation(slope_s = hill_slope, half_saturation_k=hill_half_saturation).transform(np.array(min_max_spend), x_point = media_period_spend_average)\n        transformed_media_spends.append(transformed_spend)\n\n    transformed_media_spends = np.array(transformed_media_spends)\n\n    #replicate average perio spends into all optimization period\n    replicated_media_spends = np.tile(transformed_media_spends, optimization_period).reshape((-1, len(transformed_media_spends)))\n\n    #add _hill to the media channels\n    media_channels_input = [media_channel + \"_hill\" for media_channel in media_channels]\n    media_channels_df = pd.DataFrame(replicated_media_spends, columns = media_channels_input)\n\n    #prepare data for predictions\n    new_data = pd.concat([additional_inputs, media_channels_df], axis = 1)[model_features]\n\n    predictions = model.predict(X = new_data)\n\n    total_sum = predictions.sum()\n\n    return -total_sum\n```"]