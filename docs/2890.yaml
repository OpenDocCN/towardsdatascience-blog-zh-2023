- en: 'Understanding SQL: Getting Started with Window Functions'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/understanding-sql-getting-started-with-window-functions-287391b9cef5?source=collection_archive---------5-----------------------#2023-09-17](https://towardsdatascience.com/understanding-sql-getting-started-with-window-functions-287391b9cef5?source=collection_archive---------5-----------------------#2023-09-17)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Get more from your aggregations by using SQL window functions
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@dataforyou?source=post_page-----287391b9cef5--------------------------------)[![Rob
    Taylor, PhD](../Images/5e4e86da7b77404ed42d00a60ea5eacf.png)](https://medium.com/@dataforyou?source=post_page-----287391b9cef5--------------------------------)[](https://towardsdatascience.com/?source=post_page-----287391b9cef5--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----287391b9cef5--------------------------------)
    [Rob Taylor, PhD](https://medium.com/@dataforyou?source=post_page-----287391b9cef5--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: ·
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F98de080592fc&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funderstanding-sql-getting-started-with-window-functions-287391b9cef5&user=Rob+Taylor%2C+PhD&userId=98de080592fc&source=post_page-98de080592fc----287391b9cef5---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----287391b9cef5--------------------------------)
    ·15 min read·Sep 17, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F287391b9cef5&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funderstanding-sql-getting-started-with-window-functions-287391b9cef5&user=Rob+Taylor%2C+PhD&userId=98de080592fc&source=-----287391b9cef5---------------------clap_footer-----------)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F287391b9cef5&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funderstanding-sql-getting-started-with-window-functions-287391b9cef5&source=-----287391b9cef5---------------------bookmark_footer-----------)![](../Images/7d9d02bd38237ca6dc7bedb3e5383324.png)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Photo by [Components AI](https://unsplash.com/@components_ai?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to aggregating data in SQL, *window functions* provide greater
    flexibility than aggregations used in conjunction with `GROUP BY` clauses. While
    both approaches indeed perform similar functions, window functions differ by virtue
    of how the outputs are structured. Specifically, window functions apply operations
    across a *set* of related rows, where the relation is determined by some grouping,
    or *partition*, of the table rows. And, unlike their non-window counterparts that
    collapse rows into a single output row, *all* rows retain their separate identities
    and are present in the output table.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: This behaviour is quite unlike your usual run of the mill aggregation and can
    greatly extend your analytical toolbox beyond simple summary statistics. For example,
    window functions allows us to compute running sums, moving averages, and even
    statistical measures like *z*-scores.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: In this post we’re going to take a look at the anatomy and basic functionality
    of SQL window functions. The focus here is somewhat rudimentary, so if you haven’t
    come across window functions, or have limited experience using them, this will
    hopefully be of some interest to you.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'For this post we’ll be using some high level summary data about the FIFA World
    Cup competitions between 1930 and 2022\. The placings and statistics were sourced
    from Wikipedia and is made available under the Creative Commons Attribution Share-Alike
    license (CC-BY-SA). The data and related information can be found [here](https://en.wikipedia.org/wiki/FIFA_World_Cup).
    For the purpose of this blog I imported the table into my own PostgresSQL database,
    but if you want to follow along you can grab a copy of the table from my [Git
    repository](https://github.com/dataforyounz/fifa-world-cup). In my database this
    table is called `world_cup_placings` and an output is shown below:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A quick note on execution order
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The order in which SQL executes each clause is important to understand, so let’s
    just take a few minutes to examine where window functions fall in the [order of
    execution](/understanding-sql-order-of-execution-ba2b4e558828).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Window functions can only be used within `SELECT` lists and the`ORDER BY` clause.
    They **cannot** be used with `GROUP BY` , `HAVING` , or `WHERE` clauses. The reason
    for this is that window functions are executed *after* these clauses have been
    processed. Another thing to note is that window functions are processed *after*
    non-window aggregate functions (i.e., `SUM` , `MAX,` `AVG` , etc). As we’ll see
    later, this is useful because it means we can actually use these functions within
    our window function.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: The OVER clause
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let’s take a look at the simplest version of a window function:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `FUNCTION_NAME()` is just a placeholder for whatever function you wish to
    use; however, window functions must *always* contain an `OVER` clause. This clause
    is what distinguishes window from non-window functions and its role is to determine
    *how* the rows are split up for processing. In the example above, though, no arguments
    have been passed to `OVER` . This is perfectly legitimate so lets see what this
    looks like in practice.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'A common use case for window functions is to assign a numerical value to each
    row in the table. This can be achieved using the inbuilt `ROW_NUMBER` function.
    For example, consider the example query below:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We now have a newly minted column called `row_num` that contains a sequential
    list of numbers; one for each table row. With just the vanilla `OVER` clause the
    window function treats the *entire* table as a single partition. That’s because
    we haven’t told it anything otherwise.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what happens if we replace `ROW_NUMBER` with an aggregate function,
    like `SUM` , and apply it to the `total_goals` columns, which is the total number
    of goals during the entire competition. The query for this is provided next:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Okay, so we just get a single value for each row — but this is exactly what
    we should expect to see. Remember, window functions are applied across all rows
    within a partition, and here (like above) the window function is treating the
    entire table as a partition. As a result, it will just sum all values in the `total_goals`
    column. Also, window functions retain row identity and so this output value is
    repeated for each output row. Note also that we’re using an aggregation function
    within the window function — this is possible because window functions are processed
    *after* aggregate functions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Right, let’s see how far we can push this approach by computing the average
    number of goals scored across all competitions (note the rounding off for output
    value):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, this is quite useful. Having the average number of goals listed alongside
    the competition totals allows us to directly compare these values. We can easily
    see how individual totals compare to the average taken across all competitions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s push this even further by computing a *z*-score for each row. To do so
    we’ll also need to use the `STDDEV` function within another window function. The
    query below shows you how to do this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That’s looking pretty good!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: The PARTITION BY clause
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Up until this point I have been using the term *partition* a lot, so let’s
    take a look at what this actually means. Recall that in the earlier examples we
    didn’t explicitly state how we wanted the table partitioned, so operations were
    performed across all rows in the table. The `PARTITION BY` clause, on the other
    hand, is called *within* the `OVER` clause and it dictates how rows should be
    divided into groups, or *partitions.* With this clause included the anatomy of
    the window function now looks like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The placeholder `[var]` refers to a column that is used to group rows. To demonstrate,
    let’s take another crack at numbering rows using the `ROW_NUMBER` function, only
    this time we’ll use the `first_place` column to partition the rows. Check out
    the query below:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 占位符`[var]`指的是用于分组行的列。为了演示，我们再试一次使用`ROW_NUMBER`函数对行进行编号，这次我们将使用`first_place`列来对行进行分区。查看下面的查询：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Okay, things are looking very different to last time. First, we can see that
    the output has ordered the table using the `first_place` column, but that’s not
    all that interesting. What *is* interesting are the changes to the `row_num` column.
    Starting at the top and working down, we can see that the number sequence resets
    for each distinct value in `first_place`, counting only the rows associated with
    each country’s partition.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，情况与上次看起来非常不同。首先，我们可以看到输出已使用`first_place`列对表进行了排序，但这并不特别有趣。*有趣*的是`row_num`列的变化。从顶部开始向下查看，我们可以看到编号序列在`first_place`的每个不同值上都会重置，只计数与每个国家的分区相关的行。
- en: 'Let’s build on our query some more. In addition to the `row_num` column let’s
    compute the total number of goals scored and the maximum total attendance. We’ll
    again use the `first_place` column to partition the table, so these aggregations
    will apply only to the rows associated with each partition. The query below shows
    you how to do this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在查询基础上再做些扩展。除了`row_num`列，我们还计算总进球数和最大总出席人数。我们将再次使用`first_place`列来对表进行分区，因此这些聚合将仅适用于与每个分区相关的行。下面的查询展示了如何做到这一点：
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, neither of these aggregations are particularly useful in and of themselves
    and they’re really just for demonstration purposes. But let’s take a look at what
    we actually get back from this query.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这些聚合本身并不是特别有用，它们只是为了演示目的。但让我们看看从这个查询中实际得到的结果。
- en: First, the `all_goals` column provides the total number of goals scored across
    all competitions for each winning country (recall, we have partitioned rows using
    the `first_place` column). For example, in competitions where Argentina won, we
    can see that a total of 102 goals were scored when Argentina hosted in 1978, 132
    goals were scored in 1986 when Mexico hosted, and 172 goals most recently in Qatar.
    The `all_goals` value, then, is simply the sum of these two values, which is 406.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`all_goals`列提供了每个获胜国家在所有比赛中进球的总数（回忆一下，我们已使用`first_place`列对行进行了分区）。例如，在阿根廷获胜的比赛中，我们可以看到在1978年阿根廷主办时进了102球，1986年墨西哥主办时进了132球，最近在卡塔尔进了172球。`all_goals`值就是这两个值的总和，即406。
- en: Second, the `max_attendance` value returns the highest competition attendance
    for each winning country. For example, of the World Cups listed in the table,
    Italy has won four of them, with the highest attendance recorded during the 2006
    World Cup held in Germany (3,359,439). So, for all rows where Italy was the winner,
    this is value returned for `max_attendance` .
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，`max_attendance`值返回每个获胜国家的最高比赛出席人数。例如，在表中列出的世界杯中，意大利赢得了其中四场，其中2006年在德国举办的世界杯的最高出席人数（3,359,439）。因此，对于所有意大利获胜的行，这就是`max_attendance`返回的值。
- en: 'Looking back over the query, you might have noticed that we need write `OVER(
    PARTITION BY first_place )` three times; once for each window function in the
    `SELECT` list. This can become a little tedious if your query requires multiple
    window functions that partition using the same column. So is there a better to
    achieve the same goal? Yes. Yes there is. In cases like these — where the windowing
    is the same for all functions — we can use a separate `WINDOW` clause to define
    the partition and assign it a name that can be called by `OVER` . Take a look
    at the query below:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾查询，你可能会注意到我们需要写`OVER( PARTITION BY first_place )`三次；每个窗口函数在`SELECT`列表中出现一次。如果你的查询需要多个窗口函数，并且使用相同的列进行分区，这可能会变得有些乏味。那么有没有更好的方法来实现相同的目标？有的。确实有。在这些情况下——所有函数的窗口设置相同——我们可以使用一个单独的`WINDOW`子句来定义分区，并为其指定一个可以通过`OVER`调用的名称。查看下面的查询：
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, this doesn’t eliminate the need to provide an argument after the `OVER`
    clause — that can’t be avoided — but this approach is far less error-prone and
    definitely helps declutter the query. You can check that the results are identical
    to the output above.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这并不会消除在`OVER`子句后提供参数的需要——这是无法避免的——但这种方法出错的可能性要小得多，并且确实有助于清理查询。你可以检查结果是否与上面的输出一致。
- en: The ORDER BY clause
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`ORDER BY`子句'
- en: 'Another clause that can be added to `OVER` is the `ORDER BY` clause. This clause
    will certainly look familiar, and indeed it works exactly how you’d expect it
    to. The only difference is that when we use it within the `OVER` clause it affects
    the ordering within each partition. With this clause included our window function
    now looks like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can use the `ORDER BY` clause to order values before performing an operation.
    This is particularly useful if we want to rank values using the `RANK` function
    which assigns a numerical value to each *distinct* `ORDER BY` value. This means
    it behaves slightly differently to the `ROW_NUMBER` function because the `RANK`
    function will assign the same rank to duplicated values. Check out the query below
    and compare the row outputs:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: See the difference? If we look at the rows two and three, we see that both Brazil
    2014 and France 1998 resulted in 171 goals. While the `row_num` column assigns
    different values to these rows, the `row_rank` columns has assigned the same rank.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Just note that, for the `ROW_NUMBER` window function, I didn’t actually need
    to specify `ORDER BY total_goals DESC` , but I’ve done this to highlight the fact
    that the `ROW_NUMBER` window function doesn’t care about duplicated values; it
    simply numbers each row despite the ordering by `total_goals` .
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, now let’s try using the `ORDER BY` and `PARTITION BY` clause together
    to find in which year each team last won the World Cup. First, we’ll use the `first_place`
    column to partition the table and then sort the rows in descending order using
    the `year` column. The following query shows you how to do this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: By sorting the competition years in descending order we ensure that the most
    recent year occupies the first row of each partition. Now, because there can only
    be one winner each year there are no duplicate values in the `year` column. So,
    when we assign ranks to each partition, the first row will always have a rank
    of 1 which corresponds to the most recent win for each country.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'This output, however, is a bit noisy and we have to read each row to find the
    ranks for each partition. We can tidy things up a bit by placing the above query
    within a sub-query and filtering out only the rows that have a rank of 1\. Check
    out the query below to see this in action:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Final Remarks
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Window functions are remarkably versatile and are often more efficient when
    needing to compute values using only a subset of rows. This post just scratches
    the surface of what can be done using window functions and demonstrates only their
    basic functionality. Regardless, I hope you found something useful in this post.
    In a later post we’ll build on these concepts and explore how window functions
    can be used to compute some more exotic measures.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Related Articles
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Understanding SQL: Order of Execution](https://medium.com/towards-data-science/understanding-sql-order-of-execution-ba2b4e558828)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thanks for reading!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: If you enjoyed this post and would like to stay up to date then please consider
    [following me on Medium.](https://medium.com/@dataforyou) This will ensure you
    don’t miss out on any new content.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢这篇文章并希望保持更新，请考虑[关注我的 Medium 账号](https://medium.com/@dataforyou)。这将确保你不会错过任何新内容。
- en: To get unlimited access to all content consider signing up for a [Medium subscription](https://medium.com/membership).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 若要无限制访问所有内容，请考虑注册[Medium 订阅](https://medium.com/membership)。
- en: You can also follow me on [Twitter](https://twitter.com/dataforyounz), [LinkedIn](https://www.linkedin.com/in/dataforyou/),
    or check out my [GitHub](https://github.com/dataforyounz) if that’s more your
    thing.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在[Twitter](https://twitter.com/dataforyounz)、[LinkedIn](https://www.linkedin.com/in/dataforyou/)上关注我，或者查看我的[GitHub](https://github.com/dataforyounz)，如果这更符合你的兴趣。
