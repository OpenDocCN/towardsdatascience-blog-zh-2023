- en: 'Embracing Julia: An Invitation Letter'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'Embracing Julia: An Invitation Letter'
- en: 原文：[https://towardsdatascience.com/embracing-julia-an-invitation-letter-332f5709378e?source=collection_archive---------2-----------------------#2023-10-13](https://towardsdatascience.com/embracing-julia-an-invitation-letter-332f5709378e?source=collection_archive---------2-----------------------#2023-10-13)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/embracing-julia-an-invitation-letter-332f5709378e?source=collection_archive---------2-----------------------#2023-10-13](https://towardsdatascience.com/embracing-julia-an-invitation-letter-332f5709378e?source=collection_archive---------2-----------------------#2023-10-13)
- en: Warmly Extended to Python Lovers, Scientific Computing Wizards and Data Scientists
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 诚挚地向 Python 爱好者、科学计算大师和数据科学家致敬
- en: '[](https://essamwissam.medium.com/?source=post_page-----332f5709378e--------------------------------)[![Essam
    Wisam](../Images/6320ce88ba2e5d56d70ce3e0f97ceb1d.png)](https://essamwissam.medium.com/?source=post_page-----332f5709378e--------------------------------)[](https://towardsdatascience.com/?source=post_page-----332f5709378e--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----332f5709378e--------------------------------)
    [Essam Wisam](https://essamwissam.medium.com/?source=post_page-----332f5709378e--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://essamwissam.medium.com/?source=post_page-----332f5709378e--------------------------------)[![Essam
    Wisam](../Images/6320ce88ba2e5d56d70ce3e0f97ceb1d.png)](https://essamwissam.medium.com/?source=post_page-----332f5709378e--------------------------------)[](https://towardsdatascience.com/?source=post_page-----332f5709378e--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----332f5709378e--------------------------------)
    [Essam Wisam](https://essamwissam.medium.com/?source=post_page-----332f5709378e--------------------------------)'
- en: ·
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fccb82b9f3b87&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fembracing-julia-an-invitation-letter-332f5709378e&user=Essam+Wisam&userId=ccb82b9f3b87&source=post_page-ccb82b9f3b87----332f5709378e---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----332f5709378e--------------------------------)
    ·19 min read·Oct 13, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F332f5709378e&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fembracing-julia-an-invitation-letter-332f5709378e&user=Essam+Wisam&userId=ccb82b9f3b87&source=-----332f5709378e---------------------clap_footer-----------)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[关注](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fccb82b9f3b87&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fembracing-julia-an-invitation-letter-332f5709378e&user=Essam+Wisam&userId=ccb82b9f3b87&source=post_page-ccb82b9f3b87----332f5709378e---------------------post_header-----------)
    发表在 [Towards Data Science](https://towardsdatascience.com/?source=post_page-----332f5709378e--------------------------------)
    ·19 分钟阅读·2023 年 10 月 13 日[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F332f5709378e&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fembracing-julia-an-invitation-letter-332f5709378e&user=Essam+Wisam&userId=ccb82b9f3b87&source=-----332f5709378e---------------------clap_footer-----------)'
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F332f5709378e&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fembracing-julia-an-invitation-letter-332f5709378e&source=-----332f5709378e---------------------bookmark_footer-----------)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F332f5709378e&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fembracing-julia-an-invitation-letter-332f5709378e&source=-----332f5709378e---------------------bookmark_footer-----------)'
- en: Julia is a general-purpose, dynamic, high-performance and high-level programming
    language that is just-in-time compiled. It’s a fairly recent language with its
    major 1.0 release rolled out only in 2018\. In this story, we aim to demonstrate
    that this language is absolutely worth adding to your arsenal if you are into
    data science, scientific computing or are just an avid Python user. It may be
    true that this is *most beautiful programming language* you will *ever come across*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 是一种通用、动态、高性能和高级别的编程语言，采用即时编译。这是一门相对较新的语言，其主要 1.0 版本直到 2018 年才发布。在这篇文章中，我们旨在展示，如果你对数据科学、科学计算或者是
    Python 爱好者，那么将这门语言加入你的工具箱绝对是值得的。也许这确实是你*见过的最美的编程语言*。
- en: '![](../Images/82c79c88f55be43b1146afcae81a7b3c.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/82c79c88f55be43b1146afcae81a7b3c.png)'
- en: Galaxy with Purple, Green and Red Planets Digital Art — Generated by author
    using DALLE 2
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 紫色、绿色和红色行星的星系数字艺术 — 由作者使用 DALLE 2 生成
- en: 'In this story, we will go over the heights of ideas with Julia and why it’s
    worth learning. Once you are **done**, we highly recommend you check the next
    story [From Python to Julia: An Ultimate Guide](https://medium.com/@essamwissam/from-python-to-julia-an-ultimate-guide-244fd3dc35c6)
    for an easy transition from Python to Julia.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个故事中，我们将探讨 Julia 的思想高度及其学习的价值。完成后，我们强烈推荐你查看下一个故事 [从 Python 到 Julia：终极指南](https://medium.com/@essamwissam/from-python-to-julia-an-ultimate-guide-244fd3dc35c6)，以便从
    Python 轻松过渡到 Julia。
- en: Table of Contents
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目录
- en: · [**Julia is High-level**](#a247)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: · [**Julia 是高级语言**](#a247)
- en: ∘ [Basic Syntax](#e83b)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [基本语法](#e83b)
- en: ∘ [Elegant Syntax for Mathematics](#c19a)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [数学的优雅语法](#c19a)
- en: · [**Julia is Fast**](#8745)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: · [**Julia 很快**](#8745)
- en: ∘ [Benchmark](#2330)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [基准测试](#2330)
- en: ∘ [The Two Language Problem](#baba)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [双语言问题](#baba)
- en: ∘ [Julia is Just-in-time Compiled](#51c2)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [Julia 是即时编译的](#51c2)
- en: · [**Julia Solves the Expression Problem**](#0a96)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: · [**Julia 解决了表达式问题**](#0a96)
- en: ∘ [The Expression Problem](#597f)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [表达式问题](#597f)
- en: ∘ [Multiple Dispatch](#27b3)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [多重分发](#27b3)
- en: ∘ [Abstract and Concrete Types](#fbf2)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [抽象和具体类型](#fbf2)
- en: · [**Julia is Fully Featured**](#c1b5)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: · [**Julia 功能全面**](#c1b5)
- en: ∘ [Array Support](#7065)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [数组支持](#7065)
- en: ∘ [String Support](#103e)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [字符串支持](#103e)
- en: ∘ [Multi-threading](#6f11)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [多线程](#6f11)
- en: ∘ [Easy Integration with C Code](#c5f6)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [与 C 代码的简单集成](#c5f6)
- en: ∘ [The Standard Library](#634e)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [标准库](#634e)
- en: · [**Julia is General Purpose**](#9999)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: · [**Julia 是通用的**](#9999)
- en: ∘ [Introduction](#d5a5)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [介绍](#d5a5)
- en: ∘ [Automation and Scripting](#2b2b)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [自动化和脚本编写](#2b2b)
- en: · [**Julia is Extensively Extendible**](#2fc2)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: · [**Julia 可扩展性广**](#2fc2)
- en: ∘ [Introduction](#9c86)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [介绍](#9c86)
- en: ∘ [Macros](#6c2d)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [宏](#6c2d)
- en: · [**Wrapping Up**](#12c0)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: · [**总结**](#12c0)
- en: '![](../Images/758e49b62b7e3d994ce7e4802624b3d2.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/758e49b62b7e3d994ce7e4802624b3d2.png)'
- en: Photo by [Daniele Levis Pelusi](https://unsplash.com/@yogidan2012?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 照片由 [Daniele Levis Pelusi](https://unsplash.com/@yogidan2012?utm_source=medium&utm_medium=referral)
    提供，来源于 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: '**Julia is High-level**'
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**Julia 是高级语言**'
- en: The introduction already may have made you feel that this will be like Python
    — a general purpose, dynamic and high-level language as well. To verify, let’s
    get a taste how basic Julia code looks like compared to Python.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍可能已经让你觉得这将类似于 Python——也是一种通用、动态和高级语言。为了验证这一点，我们来看看基本的 Julia 代码与 Python 的比较。
- en: Basic Syntax
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本语法
- en: 'Consider the following guessing game in Python:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下下面这个用 Python 编写的猜谜游戏：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following is the equivalent in Julia:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Julia 中的等效代码：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Main differences here are that Julia does not assume any indentation or require
    colons but instead requires an explicit “end” to end scopes for constructs such
    as if-conditions, loops and functions. You should feel right at home with this
    if you come from Matlab or Fortran.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于 Julia 不假设任何缩进或要求使用冒号，而是需要显式的“end”来结束 if 条件、循环和函数等构造的作用域。如果你来自 Matlab
    或 Fortran，你应该会觉得很熟悉。
- en: Another difference that you may have noticed is that Julia naturally supports
    type annotations in variable declarations, function arguments (and return types,
    although rarely used). **They are always optional** but are generally used for
    type assertions, letting the compiler choose the right method instance to call
    when the same method is overloaded for multiple types and in some cases of variable
    and struct declaration, for performance benefits.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个你可能注意到的区别是 Julia 自然支持变量声明、函数参数（和返回类型，尽管很少使用）中的类型注解。**它们总是可选的**，但通常用于类型断言，允许编译器在方法重载多个类型时选择正确的方法实例，在某些情况下对于变量和结构体声明也有性能优势。
- en: '**Elegant Syntax for Mathematics**'
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**数学的优雅语法**'
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: One serious edge that Julia has over Python is syntax support for mathematics.
    * need not be used when multiplying constants by variables, latex symbols are
    supported for variable names (may need to use a VSCode extension to convert \pi
    to π, v\_1 to v₁, etc.) and matrices in general respect the layout in the code
    definition.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 相对于 Python 的一个重大优势是其对数学语法的支持。* 乘以常量时无需使用 latex 符号，支持变量名称的 latex 符号（可能需要使用
    VSCode 插件将 \pi 转换为 π，v\_1 转换为 v₁ 等），矩阵一般遵循代码定义中的布局。
- en: For instance, if you were to implement gradient descent for a neural network.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你要为神经网络实现梯度下降。
- en: 'In Python, you would probably write:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，你可能会写：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Compare the readability of that to what you can write using Julia:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 比较一下你用 Julia 编写的代码的可读性：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can try to write code like this in Python, but editors will often put yellow
    squares around the Unicode variables (or fail to highlight them) and your code
    may not work with third party packages such as Pickle.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试用 Python 编写类似的代码，但编辑器通常会在 Unicode 变量周围加上黄色方块（或无法高亮显示它们），而且你的代码可能无法与诸如 Pickle
    的第三方包兼容。
- en: '![](../Images/a4c591a4efa970f6ff7b1fd06a848df0.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a4c591a4efa970f6ff7b1fd06a848df0.png)'
- en: Photo by [Solaiman Hossen](https://unsplash.com/@sh_sumon?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 照片由[Solaiman Hossen](https://unsplash.com/@sh_sumon?utm_source=medium&utm_medium=referral)拍摄，来源于[Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)。
- en: Julia is Fast
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Julia 非常快速。
- en: Another major reason why Julia can be thought of as a Python dream come true
    is that, unlike Python, Ruby and other high-level languages, it does not compromise
    speed for being high-level. In fact, it can be as fast as low-level languages
    such as C and C++.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使 Julia 被认为是 Python 梦想成真的主要原因是，与 Python、Ruby 和其他高级语言不同，它在保持高级的同时不会牺牲速度。实际上，它可以和低级语言如
    C 和 C++ 一样快。
- en: Benchmark
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基准测试
- en: 'For reference, the following reports the performance of Julia, along with other
    languages on popular performance benchmarks:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参考，以下报告了 Julia 的性能，以及其他语言在流行性能基准测试中的表现：
- en: '![](../Images/d79a52100be8befa37ae63b7bac86e88.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d79a52100be8befa37ae63b7bac86e88.png)'
- en: '*Julia Microbenchmarks: Image via* [*JuliaLang*](https://julialang.org/benchmarks/)
    *under MIT license*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*Julia 微基准测试：图片来源于* [*JuliaLang*](https://julialang.org/benchmarks/) *在 MIT
    许可下*'
- en: '**The Two Language Problem**'
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**双语言问题**'
- en: A corollary to Julia’s performance is that is solves the *two-language problem:*
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 性能的一个推论是它解决了*双语言问题：*
- en: Research code (e.g., a machine learning model), is typically, written in a high-level
    language such Python because it’s high-level and interactive; hence, allows focusing
    more on the science (less code issues) and allows more exploration.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究代码（例如，一个机器学习模型）通常用高级语言如 Python 编写，因为它的高级和交互性；因此，能更专注于科学（减少代码问题）并允许更多探索。
- en: Once research code is finalized, it must be rewritten in a low-level language
    such as C before it’s rolled out to production.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦研究代码完成，它必须用低级语言如 C 重写，才能在生产中使用。
- en: The issue here is that the same code has to be rewritten in more than one language.
    This is generally hard and error prone; consider if the research code is modified
    after it’s rolled out, in the worst case it will all have to be rewritten in the
    low-level language again.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于相同的代码必须用多种语言重写。这通常困难且容易出错；考虑到研究代码在发布后进行修改，最坏情况下，它将不得不再次用低级语言重写。
- en: 'One way to get around this issue is to write performance-critical libraries
    (e.g., Numpy) in low-level languages, such as C, then it’s possible to wrap them
    with Python functions that internally call the C ones which can be used for both
    research and production without worrying about performance. In reality, this is
    very limited because:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决此问题的方法是将性能关键的库（例如，Numpy）用低级语言如 C 编写，然后可以用 Python 函数包装这些库，这些函数内部调用 C 代码，可以用于研究和生产而不必担心性能。在现实中，这种方法非常有限，因为：
- en: It makes it really hard for new developers to contribute or collaborate with
    novel scientific methods they have written, since they may need to rewrite those
    in a low-level language such as C for performance before exposing them in the
    high-level library.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这使得新开发者很难为他们编写的新颖科学方法做出贡献或进行合作，因为他们可能需要将这些方法用低级语言如 C 重写以提高性能，然后再在高级库中公开。
- en: Hilarious constraints may be imposed on the developers of the high-level language
    in the scientific computing domain. For instance, writing explicit for loops may
    be heavily discouraged.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 科学计算领域的高级语言可能会对开发人员施加一些搞笑的限制。例如，写显式的 for 循环可能会被强烈不鼓励。
- en: Julia solves the two-language problem by being high-level, interactive AND quite
    fast, even for production.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 通过保持高级、交互性强且非常快速，即使在生产环境中也能解决双语言问题。
- en: Julia is Just-in-time Compiled
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Julia 是即时编译的。
- en: There is a small note related to Julia’s performance. Because Julia is JIT compiled,
    the first run of any piece of Julia code will take more time to complete. During
    this time, every function code will be converted to native code (i.e., code that
    the processor can interpret) for the specific variable types inferred from the
    code. Once it does, it will cache the compiled representation so that if the function
    is called again with different inputs of same types, then it will be interpreted
    immediately.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有一小段关于 Julia 性能的说明。由于 Julia 是 JIT 编译的，任何 Julia 代码的第一次运行都需要更多时间来完成。在这段时间里，每个函数代码将被转换为特定变量类型的本地代码（即处理器可以解释的代码）。一旦完成，它将缓存编译后的表示，以便如果该函数再次被调用并且输入的类型相同，它将立即被解释。
- en: To elaborate further, for a function with *N* arguments, there are possibly
    an exponential number of possible native code representations; one for every possible
    combination of types for the *N* arguments. Julia will compile the function down
    to the representation that corresponds to the types inferred from the code the
    first time the code is run. Once it does, further calls for the function will
    be effortless. Note that it does not necessarily use type annotations (which are
    optional and can have other purposes we mentioned) during type inference, types
    can be inferred from runtime values of the inputs.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细地说，对于一个有 *N* 个参数的函数，可能会有指数级数量的本地代码表示；每种可能的参数类型组合都有一个。Julia 会将函数编译成与首次运行代码时推断出的类型对应的表示。一旦完成，进一步调用该函数将变得轻而易举。请注意，在类型推断过程中，它不一定使用类型注释（这些注释是可选的，并且可以有我们提到的其他用途），类型可以从输入的运行时值中推断出来。
- en: This is not an issue because research code or code running on a server has to
    initially compile only once and once that’s done any further runs (real API calls
    or further experimentation) of the code are blazing fast.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是问题，因为研究代码或在服务器上运行的代码只需初次编译一次，完成后任何进一步运行（实际 API 调用或进一步实验）的代码都非常快速。
- en: '![](../Images/7a1ed7aac2b56fb711d85e7b9c96cd62.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7a1ed7aac2b56fb711d85e7b9c96cd62.png)'
- en: Photo by [Thom Milkovic](https://unsplash.com/@thommilkovic?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由 [Thom Milkovic](https://unsplash.com/@thommilkovic?utm_source=medium&utm_medium=referral)
    在 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral) 提供的照片
- en: Julia Solves the Expression Problem
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Julia 解决了表达式问题
- en: '**The Expression Problem**'
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**表达式问题**'
- en: 'The expression problem is about being able to define a data abstraction that
    is extensible both in its representations (i.e., supported types) and its behaviors
    (i.e., supported methods). That is, a solution to the expression problem allows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式问题涉及能够定义一个在其表示（即支持的类型）和行为（即支持的方法）方面都可扩展的数据抽象。也就是说，解决表达式问题的方案允许：
- en: Adding **new types** to which **existing operations** apply
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加**新类型**到**现有操作**适用的类型中
- en: Adding **new operations** to which **existing types** apply
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加**新操作**到**现有类型**适用的类型中
- en: without violating the **open-closed principle** (or causing other issues)*.*
    This implies that it should be possible to add the new types without modifying
    the code for existing operations and it should be possible to add new operations
    without modifying the code for existing types.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 而不违反**开闭原则**（或导致其他问题）。这意味着应该可以在不修改现有操作代码的情况下添加新类型，并且应该可以在不修改现有类型代码的情况下添加新操作。
- en: Python, like many other programming languages, is object-oriented and fails
    to address the expression problem.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Python 像许多其他编程语言一样，是面向对象的，未能解决表达式问题。
- en: 'Suppose we have the following data abstraction:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下数据抽象：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It’s very easy to add new types to which existing methods should apply. Just
    inherit from the `Shape` base class. It does not require the modification of any
    existing code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易将新类型添加到现有方法应适用的类型中。只需继承 `Shape` 基类即可。这不需要修改任何现有代码：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Meanwhile, it’s not easy to add operations to which existing types apply. If
    we want to add a `perimeter` method, then we have to modify the base and every
    single child class implemented so far.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，向现有类型中添加操作并不容易。如果我们想添加一个 `perimeter` 方法，那么必须修改基础类以及到目前为止实现的每一个子类。
- en: One consequence of this problem is that if package *x* is maintained by author
    X and it initially supports the set of operations *Sx,* and if another set of
    operations *Sy* is helpful to another set of developers Y, they must be able to
    modify the package by X to add these methods. In practice, developers Y just make
    another package on their own, possibly duplicating code from that in package *x*
    to implement the type because developer X may not be happy with more code to maintain
    and *Sy* may be a different genre of methods that doesn’t have to live in the
    same package.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, because it’s easy to add new types for which existing operations
    apply, if developerYrather wanted to just define a new type that implements operations
    in the type implemented by X, then they could easily do that without even needing
    to modify package *x* or duplicating any code in it. Just importing the type and
    then inheriting from it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '**Multiple Dispatch**'
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To solve the expression problem, which allows massive integration among different
    packages, Julia does away with traditional object-oriented programming completely.
    Instead of classes, Julia uses **abstract type** definitions, **structs** (custom
    type instances of abstract types) and **methods** and a technique called **multiple
    dispatch** that as we will see**,** perfectly solves the expression problem.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'To see an equivalent of what we had above:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here we defined an abstract type “Shape”. The fact that it’s abstract implies
    that it cannot be instantiated; however, other types (classes) can subtype (inherit
    from) it. Afterwards, we defined a circle type, as a subtype of the `Shape` abstract
    type and we defined the `area` method while specifying that the input must be
    of type `Circle`. By this we can do
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This would print `28.26`. Although, `c` satisfies both `area` definitions because
    it’s also a `Shape`, the second is more specific so it’s the one the compiler
    chooses for the call.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to class-based OOP, it’s easy to add another type “rectangle” without
    touching existing code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: And now when we do
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We get `18.0`. This is multiple dispatch in action; the correct instance of
    the method `area` was dynamically dispatched based on the run-time type of the
    arguments. If you come from a C or C++ background, then this must remind you of
    function overloading. The difference is that function overloading is not dynamic,
    it relies on the types found during compile time. Thus, you can devise examples
    where its behavior is different.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, and unlike class-based OOP, we can add methods to any of `Shape`,
    `Circle` or `Rectangle` without needing to modify their files. If all the files
    above are in my package and you wish to add a set of methods that produce animations
    and 3D visuals of the geometric shapes (which I don’t care about), then all you
    need is to import my package. Now you can access the `Shape`, `Circle` and `Rectangle`
    types and you can write the new functions, then export them in your own “ShapeVisuals”
    package.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，与基于类的 OOP 不同，我们可以向 `Shape`、`Circle` 或 `Rectangle` 添加方法，而无需修改它们的文件。如果所有这些文件都在我的包中，而你希望添加一组方法来生成几何形状的动画和
    3D 视觉效果（这是我不关心的），那么你只需导入我的包。现在你可以访问 `Shape`、`Circle` 和 `Rectangle` 类型，你可以编写新的函数，然后将它们导出到你自己的“ShapeVisuals”包中。
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When you think about it, the major distinction between this and OOP that you
    know of is that it follows the pattern `func(obj, args)` instead of `obj.func(args)`.
    As a bonus, it also makes things like `func(obj1, obj2, args)` a breeze. The other
    distinction is that it does not encapsulate methods and data together or impose
    any protection on them; perhaps, an irrelevant measure when developers are mature
    enough and code is reviewed anyway.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你考虑一下，这与你知道的面向对象编程 (OOP) 的主要区别在于它遵循 `func(obj, args)` 的模式，而不是 `obj.func(args)`。作为附加好处，它也使
    `func(obj1, obj2, args)` 等操作变得轻而易举。另一个区别是它不会将方法和数据封装在一起或对它们施加任何保护；也许这在开发人员足够成熟且代码已被审查时是一个无关紧要的措施。
- en: '**Abstract and Concrete Types**'
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**抽象与具体类型**'
- en: The fact that you now know that an abstract type is simply a type that you cannot
    instantiate values from but that other types can subtype, paves the way to discuss
    Julia’s type system. Recall that is optional, to use the syntax `var::type`to
    annotate the types of variables upon declaration, as function arguments or returns.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在知道抽象类型只是一个你无法实例化值的类型，但其他类型可以从它子类化，这为讨论 Julia 的类型系统铺平了道路。请记住，使用语法 `var::type`
    来注释变量的类型是可选的，无论是在声明时、作为函数参数还是返回值。
- en: Any type in Julia is either abstract, as we defined above, or concrete. Concrete
    types are those you can instantiate like the custom types we defined above.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 中的任何类型要么是抽象的，如我们上面定义的，要么是具体的。具体类型是那些你可以实例化的，就像我们上面定义的自定义类型一样。
- en: 'Julia has the following hierarchical type system for numbers:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 为数字提供了以下层次化的类型系统：
- en: '![](../Images/566fc275758736561329441578abe9fd.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/566fc275758736561329441578abe9fd.png)'
- en: '*Julia Microbenchmarks: Image via J*[*ulia for Optimization and Learning*](https://juliateachingctu.github.io/Julia-for-Optimization-and-Learning/stable/lecture_06/compositetypes/)
    *under MIT license*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*Julia 微基准测试：图片来自 J*[*ulia for Optimization and Learning*](https://juliateachingctu.github.io/Julia-for-Optimization-and-Learning/stable/lecture_06/compositetypes/)
    *根据 MIT 许可协议*'
- en: If your function takes one argument and operates on any Number, you will use
    `func(x::Number)`. This would only throw an error if non-numeric value, such as
    a string, is passed. Meanwhile, if it only works for any float then you would
    do `func(x::AbstractFloat)`. No error will be thrown if the input is of type `BigFloat,
    Float64, Floar32 or Floar16`. Because multiple dispatch exists, you can also define
    another instance of the function `func(x::Integer)` to handle the case when the
    given number is an integer.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的函数接受一个参数并对任何数字进行操作，你将使用 `func(x::Number)`。只有当传入非数字值，如字符串时，才会抛出错误。与此同时，如果它仅适用于任何浮点数，那么你将使用
    `func(x::AbstractFloat)`。如果输入的类型是 `BigFloat, Float64, Float32 或 Float16`，则不会抛出错误。由于存在多重分派，你还可以定义另一个函数实例
    `func(x::Integer)` 来处理给定数字为整数的情况。
- en: Julia similarly has a hierarchical type system for [other abstract types](https://www.oreilly.com/library/view/learning-julia-abstract/9781491999585/ch01.html)
    such as `AbstractString` but they are much simpler.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 也有一个层次化的类型系统用于 [其他抽象类型](https://www.oreilly.com/library/view/learning-julia-abstract/9781491999585/ch01.html)，如
    `AbstractString`，但它们要简单得多。
- en: '![](../Images/ddab1ebf8e79e00104559b5292c23fb7.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ddab1ebf8e79e00104559b5292c23fb7.png)'
- en: Photo by [Paul Melki](https://unsplash.com/@paulmelki?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由 [Paul Melki](https://unsplash.com/@paulmelki?utm_source=medium&utm_medium=referral)
    提供，[Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: Julia is Fully Featured
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Julia 功能齐全
- en: If you think about it, Python only comes with bare bone functionality out of
    the box. For instance, you can do very little in data science and scientific computing
    if you are using Python only without popular packages such as Numpy. The vast
    majority of other packages in the field also heavily depend on Numpy. They all
    use and assume the “Numpy” array type (instead of the default Python list type)
    just as if it’s part of the language.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑一下，Python 开箱即用地只有基本功能。例如，如果你仅使用 Python 而没有像 Numpy 这样的流行软件包，你在数据科学和科学计算方面能做的事情非常有限。该领域的大多数其他软件包也严重依赖
    Numpy。它们都使用并假定“ Numpy” 数组类型（而不是默认的 Python 列表类型），就像它是语言的一部分一样。
- en: 'Julia isn’t like that. It comes with many important features out-of-the-box,
    including:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 并不是这样。它开箱即用地提供了许多重要的特性，包括：
- en: '**Array Support**'
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**数组支持**'
- en: 'Julia comes with array support similar to Numpy out-of-the-box which includes
    broadcasting and vectorization support. For instance, the following compares popular
    Numpy operations with how you would write them natively in Julia:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 开箱即用地提供了类似于 Numpy 的数组支持，包括广播和矢量化支持。例如，以下比较了流行的 Numpy 操作与如何在 Julia 中原生编写它们：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**String Support**'
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**字符串支持**'
- en: 'Julia also comes with extensive support for strings and regular expressions
    out-of-the-box:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 还开箱即用地提供了对字符串和正则表达式的广泛支持：
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When strings are compared, those later in the lexicographical order (general
    alphabetical order) are considered greater than those that show up earlier in
    the order. It can be shown that most of what you can do with strings in advanced
    string processing languages such as Perl, can be also done in Julia.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当字符串被比较时，按字典顺序（一般的字母顺序）靠后的字符串被认为比靠前的字符串大。可以证明，大多数在 Perl 等高级字符串处理语言中可以做的字符串操作，也可以在
    Julia 中完成。
- en: '**Multi-threading**'
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**多线程**'
- en: The fact that Python does not support true parallel multi-threading is justified
    by that it comes with a Global Interpreter Lock (GIL). This disallows running
    the interpreter to run multiple threads at the same time as an overly easy solution
    to guarantee thread-safety. It’s only possible to switch between multiple threads
    (e.g., if a server thread is busy waiting for a network request, the interpreter
    can switch to another thread).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Python 不支持真正的并行多线程是因为它有一个全局解释器锁（GIL）。这禁止了解释器同时运行多个线程，以便通过一种过于简单的解决方案来保证线程安全。只有在多个线程之间切换才是可能的（例如，如果一个服务器线程忙于等待网络请求，解释器可以切换到另一个线程）。
- en: Luckily, it’s not hard to release this lock in C programs called by Python which
    explains why Numpy is possible. However, if you have a massive computing for loop,
    then you can’t write Python code that executes it in parallel to speed up computation.
    The sad reality for Python is that the vast majority of mathematical operations
    that apply to large structures of data such as matrices, are parallelizable.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在 Python 调用的 C 程序中释放这个锁并不难，这解释了为什么 Numpy 是可能的。然而，如果你有一个大规模的计算循环，那么你不能编写可以并行执行的
    Python 代码来加速计算。Python 的悲惨现实是，大多数应用于大数据结构（如矩阵）的数学操作都是可以并行化的。
- en: 'Meanwhile, in Julia true parallel multi-threading is natively supported out-of-the-box
    and it’s as easy as doing this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，Julia 原生支持真正的并行多线程，并且只需简单操作即可实现：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When you run the code, you get to specify how many threads you want to use among
    the available ones in your system.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码时，你可以指定要使用系统中可用的线程数量。
- en: '**Easy Integration with C Code**'
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**与 C 代码的轻松集成**'
- en: The process of calling C code from Julia is officially supported out-of-the-box
    and can be done more efficiently and more easily than in Python. If you want to
    call
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Julia 调用 C 代码的过程是开箱即用并且比 Python 更高效和更容易。如果你想调用
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: then the main step (after a small setup) to call this function in Julia is writing
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后主要步骤（在小的设置之后）是在 Julia 中调用此函数就是编写
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It’s far tricker to do this in Python and it can be less efficient. Especially
    because it’s much easier to map Julia types and structures to those in C.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中做到这一点要复杂得多，效率可能更低。特别是因为将 Julia 类型和结构映射到 C 中的类型和结构要容易得多。
- en: 'A major consequence of this is that it’s possible to run the vast majority
    of languages that can output object C code here in Julia. Typically, external
    well-known packages exist for those. For instance, to call Python code you can
    use the `PyCall.jl` package as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这一个主要的结果是，可以在 Julia 中运行绝大多数能够输出 C 代码的语言。通常，外部的知名软件包存在于这些语言中。例如，要调用 Python 代码，你可以使用
    `PyCall.jl` 软件包，如下所示：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Almost no prior setup is needed for this besides installing the package. It’s
    likewise possible to call functions written in Fortran, C++, R, Java, Mathematica,
    Matlab, Node.js, and more using similar packages.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 除了安装包外，几乎不需要任何先期设置。使用类似的包，也可以调用用Fortran、C++、R、Java、Mathematica、Matlab、Node.js等编写的函数。
- en: On the other hand, it’s possible to call Julia from Python, although not in
    an as elegant fashion. This has been probably used before to speed up functions
    without resorting to implementing them in C.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，可以从Python调用Julia，尽管不如优雅。这可能以前用于加速函数，而不需要用C实现它们。
- en: '**The Standard Library**'
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**标准库**'
- en: A set of packages come pre-installed (but have to be explicitly loaded) with
    Julia. This includes the **Statistics** and **LinearAlgebra** packages, the **Downloads**
    package to access the internet, and more importantly the **Distribued** package
    for distributed computing (like Hadoop), also the **Profile** package for profiling
    (help optimizing code) and notably the **Tests** package for unit testing and
    the **Pkg** package for package management along with many others.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一组包随Julia预安装（但需要显式加载）。这包括**Statistics**和**LinearAlgebra**包、用于访问互联网的**Downloads**包，以及更重要的分布式计算（如Hadoop）的**Distribued**包，还有用于性能分析（帮助优化代码）的**Profile**包，显著的**Tests**包用于单元测试和**Pkg**包用于包管理，以及许多其他包。
- en: I must say that I am an avid Python user that has developed multiple packages
    in Python. There is no comparison between the third-party package “Setuptools”
    in Python and **Pkg** in Julia which is really much cleaner and easier to use.
    I was never able to comprehend why Python does not have its own package management
    and testing tools. These are really basic needs in a programming language.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须说，我是一个热衷于Python的用户，开发了多个Python包。在Python中，第三方包“Setuptools”和Julia中的**Pkg**之间没有可比性，后者确实更干净、更易于使用。我一直无法理解为什么Python没有自己的包管理和测试工具。这些在编程语言中确实是基本需求。
- en: '![](../Images/b3db8ea6be5cea905935c76d940bb969.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b3db8ea6be5cea905935c76d940bb969.png)'
- en: Photo by [Tom M](https://unsplash.com/@t_mac?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 摄影师 [Tom M](https://unsplash.com/@t_mac?utm_source=medium&utm_medium=referral)
    的照片，来源于 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: Julia is General Purpose
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Julia是通用的
- en: Introduction
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: If you have encountered Julia in the past, then it would be natural to hear
    that you think Julia is a domain-specific language where scientific computing
    is the domain. It’s true that Julia has been carefully designed to be expressive
    and efficient for scientific computing but that does not stop it from being a
    general-purpose language. It’s just one built with scientific computing in mind.
    There are whatsoever degrees to which a language can be general purpose. For instance,
    Julia can be used for data science and machine learning, web development, automation
    and scripting, robotics aside from scientific computing, but there are still no
    mature packages that help developers use Julia for things like game development
    similar to Pygame in Python. Even if the Julia package `Genie.jl` is very close
    to be on par with `Flask`, it may fall short from more comprehensive frameworks
    like `Django`. In short, even if Julia is not as general-purpose as you want it
    to be at the moment, it’s built with that in mind and is expected to be eventually.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经遇到过Julia，那么你会自然地认为Julia是一个领域特定的语言，科学计算是这个领域。确实，Julia经过精心设计，以便在科学计算中具有表现力和效率，但这并不妨碍它成为通用语言。它只是一个以科学计算为重点构建的语言。语言的通用性有一定的程度。例如，Julia可以用于数据科学和机器学习、网页开发、自动化和脚本编写、机器人技术等，除了科学计算，但目前还没有成熟的包帮助开发者使用Julia进行类似于Python中Pygame的游戏开发。即使Julia包`Genie.jl`非常接近`Flask`，它可能在更全面的框架如`Django`方面有所欠缺。总之，即使Julia目前不像你期望的那样通用，但它是以此为目标构建的，并预计最终会实现这一点。
- en: '**Automation and Scripting**'
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**自动化和脚本编写**'
- en: Having mentioned that Julia can be used for automation and scripting, it’s worth
    to point out that it helps do so with elegant shell-like syntax.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 既然提到Julia可以用于自动化和脚本编写，值得指出的是，它通过优雅的类似Shell的语法帮助实现这一点。
- en: 'For instance, here is a set of file system and process operations you can perform
    in Julia:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里是一组你可以在Julia中执行的文件系统和进程操作：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice the similarity to what you actually write in the terminal.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你在终端中实际输入的内容的相似性。
- en: '![](../Images/a4c3d31a9ef21d695a4fe21ac8bb29e9.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a4c3d31a9ef21d695a4fe21ac8bb29e9.png)'
- en: An Alternative to Starry Night Digital Art — Generated by author using DALLE
    2
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 星夜数字艺术的替代品 — 作者使用 DALLE 2 生成
- en: Julia is Extensively Extendible
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Julia 具有广泛的扩展性
- en: Introduction
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: One beautiful feature in the LISP programming language is that it is homoiconic.
    Meaning that code can be treated just like data and hence, new features and semantics
    could be added to the language by ordinary developers. Julia was also built to
    be homoiconic. For instance, remember that I said that Julia supports multiple
    dispatch only. Well, it looks like someone has made a `ObjectOriented.jl` package
    that allows developers to write OOP in Julia. As another example, if you make
    any new type, it’s easy to overload base functions and operators (which are just
    functions) to work with your new type.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: LISP 编程语言中的一个美丽特性是它是同构的。这意味着代码可以像数据一样处理，因此普通开发者可以向语言中添加新特性和语义。Julia 也被构建为同构的。例如，记得我说过
    Julia 仅支持多重分发。好吧，看起来有人制作了一个 `ObjectOriented.jl` 包，允许开发者在 Julia 中编写面向对象编程。另一个例子是，如果你创建任何新类型，很容易重载基函数和操作符（它们只是函数）以适应你的新类型。
- en: Macros
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 宏
- en: 'Julia’s support for macros is a major reason why this is possible. You can
    think of a macro as a function that returns the code to be executed during the
    parse time of the program. Suppose you define the following macro:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 对宏的支持是实现这一点的主要原因。你可以将宏视为一个在程序解析时返回要执行的代码的函数。假设你定义了以下宏：
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Similar to a function, this allows you to call it in this way:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于函数，这允许你以这种方式调用它：
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: which returns 12\. What happens under the hood is that during parse time (before
    compilation) the macro executes, returning the code `5 + 7` which during compile
    time evaluates to `12`. You can think of macros are just way to dynamically perform
    `CTRL+H` (find and replace) operations.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回 12。发生的事情是，在解析时（编译前），宏执行，返回代码 `5 + 7`，在编译时计算为 `12`。你可以认为宏只是动态执行 `CTRL+H`（查找和替换）操作的一种方式。
- en: For another practical use case, suppose you have a package with 10 useful methods,
    and you want to add a new interface to the package which means you have to write
    10 structs, one for each method. Suppose it’s systematic to write any of the structs
    given the corresponding function, then you can simply write a single macro where
    you loops over the 10 functions to generate code for the 10 structs. In effect,
    the code you write will be equivalent to writing a single struct in a generic
    manner, so this saves time.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于另一个实际应用场景，假设你有一个包含10个有用方法的包，你想向包中添加一个新接口，这意味着你需要为每个方法编写一个结构体，共10个。假设根据对应的函数编写这些结构体是有系统的，那么你可以简单地编写一个宏，循环遍历这10个函数来生成这10个结构体的代码。实际上，你编写的代码将等同于以通用方式编写一个结构体，因此节省了时间。
- en: The fact that macros are possible allows for much more magic. For instance,
    if you recall above, we were able to multi-thread a for loop using the `Threads.@threads`
    macro. To measure the execution time of a function call all you do is `@time func()`
    if you are using the `BenchmarkTools` package then `@benchmark func()` would call
    the function many times to return statistics about the time and even a small plot.
    If you know what [memoization](https://en.wikipedia.org/wiki/Memoization) is,
    even that can be applied to any function with a simple `@memoize` macro. There
    is no need to modify it in anyway. There is even `@code_native func()` which would
    show you the native code generated by the function and there are other macros
    that show you other representations of the code during the compilation process.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 宏的存在允许更多的魔法。例如，如果你记得上面，我们能够使用 `Threads.@threads` 宏对一个 for 循环进行多线程。要测量函数调用的执行时间，你只需使用
    `@time func()`，如果你使用 `BenchmarkTools` 包，那么 `@benchmark func()` 会多次调用函数，以返回时间统计数据，甚至生成小图。如果你知道什么是[备忘录化](https://en.wikipedia.org/wiki/Memoization)，那么也可以通过一个简单的
    `@memoize` 宏将其应用于任何函数，无需以任何方式修改它。还有 `@code_native func()` 可以显示函数生成的原生代码，以及其他宏可以在编译过程中显示代码的其他表示形式。
- en: Wrapping Up
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'It turns out that all the language features we have talked about were initially
    part of the plan for Julia. As stated on Julia’s website, this is the language’s
    [vision](https://julialang.org/blog/2012/02/why-we-created-julia/):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，我们讨论的所有语言特性最初都是 Julia 计划的一部分。正如 Julia 网站上所述，这是该语言的[愿景](https://julialang.org/blog/2012/02/why-we-created-julia/)：
- en: “We want a language that’s open source, with a liberal license. We **want the
    speed of C** with the **dynamism of Ruby**. We want a language that’s **homoiconic**,
    with **true macros like Lisp**, but with obvious, **familiar mathematical notation
    like Matlab**. We want something as usable for **general programming as Python**,
    as **easy for statistics as R**, as **natural for string processing as Perl**,
    as **powerful for linear algebra as Matlab**, as good at **gluing programs together
    as the shell**. Something that is **dirt simple to learn**, yet keeps the most
    serious hackers happy. We want it interactive, and we want it compiled.”
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “我们想要一种开源的语言，拥有宽松的许可证。我们**想要C语言的速度**，结合**Ruby的动态特性**。我们希望这是一种**同构的**语言，拥有**像Lisp一样的真正宏**，但使用明显的、**类似于Matlab的数学符号**。我们希望它在**通用编程**方面像Python一样好，在**统计分析**方面像R一样简单，在**字符串处理**方面像Perl一样自然，在**线性代数**方面像Matlab一样强大，在**将程序连接在一起**方面像Shell一样出色。我们希望它**简单易学**，但仍能让最严肃的黑客满意。我们希望它是互动式的，并且我们希望它可以编译。”
- en: Having read the story, you should more or less be able to reflect on every word
    mentioned in the vision statement at this point.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读了这个故事，你现在应该或多或少能够反思愿景声明中提到的每一个词。
- en: I hope that reading this has helped you learn more about the Julia language
    and that you will consider learning the language. Till next time, au revoir.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望阅读这些内容能够帮助你更多地了解Julia语言，并且你会考虑学习这门语言。下次见，再见。
