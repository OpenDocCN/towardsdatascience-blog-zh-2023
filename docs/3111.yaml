- en: 'Embracing Julia: An Invitation Letter'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/embracing-julia-an-invitation-letter-332f5709378e?source=collection_archive---------2-----------------------#2023-10-13](https://towardsdatascience.com/embracing-julia-an-invitation-letter-332f5709378e?source=collection_archive---------2-----------------------#2023-10-13)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Warmly Extended to Python Lovers, Scientific Computing Wizards and Data Scientists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://essamwissam.medium.com/?source=post_page-----332f5709378e--------------------------------)[![Essam
    Wisam](../Images/6320ce88ba2e5d56d70ce3e0f97ceb1d.png)](https://essamwissam.medium.com/?source=post_page-----332f5709378e--------------------------------)[](https://towardsdatascience.com/?source=post_page-----332f5709378e--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----332f5709378e--------------------------------)
    [Essam Wisam](https://essamwissam.medium.com/?source=post_page-----332f5709378e--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fccb82b9f3b87&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fembracing-julia-an-invitation-letter-332f5709378e&user=Essam+Wisam&userId=ccb82b9f3b87&source=post_page-ccb82b9f3b87----332f5709378e---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----332f5709378e--------------------------------)
    ·19 min read·Oct 13, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F332f5709378e&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fembracing-julia-an-invitation-letter-332f5709378e&user=Essam+Wisam&userId=ccb82b9f3b87&source=-----332f5709378e---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F332f5709378e&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fembracing-julia-an-invitation-letter-332f5709378e&source=-----332f5709378e---------------------bookmark_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: Julia is a general-purpose, dynamic, high-performance and high-level programming
    language that is just-in-time compiled. It’s a fairly recent language with its
    major 1.0 release rolled out only in 2018\. In this story, we aim to demonstrate
    that this language is absolutely worth adding to your arsenal if you are into
    data science, scientific computing or are just an avid Python user. It may be
    true that this is *most beautiful programming language* you will *ever come across*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/82c79c88f55be43b1146afcae81a7b3c.png)'
  prefs: []
  type: TYPE_IMG
- en: Galaxy with Purple, Green and Red Planets Digital Art — Generated by author
    using DALLE 2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this story, we will go over the heights of ideas with Julia and why it’s
    worth learning. Once you are **done**, we highly recommend you check the next
    story [From Python to Julia: An Ultimate Guide](https://medium.com/@essamwissam/from-python-to-julia-an-ultimate-guide-244fd3dc35c6)
    for an easy transition from Python to Julia.'
  prefs: []
  type: TYPE_NORMAL
- en: Table of Contents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: · [**Julia is High-level**](#a247)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Basic Syntax](#e83b)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Elegant Syntax for Mathematics](#c19a)
  prefs: []
  type: TYPE_NORMAL
- en: · [**Julia is Fast**](#8745)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Benchmark](#2330)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [The Two Language Problem](#baba)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Julia is Just-in-time Compiled](#51c2)
  prefs: []
  type: TYPE_NORMAL
- en: · [**Julia Solves the Expression Problem**](#0a96)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [The Expression Problem](#597f)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Multiple Dispatch](#27b3)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Abstract and Concrete Types](#fbf2)
  prefs: []
  type: TYPE_NORMAL
- en: · [**Julia is Fully Featured**](#c1b5)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Array Support](#7065)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [String Support](#103e)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Multi-threading](#6f11)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Easy Integration with C Code](#c5f6)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [The Standard Library](#634e)
  prefs: []
  type: TYPE_NORMAL
- en: · [**Julia is General Purpose**](#9999)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Introduction](#d5a5)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Automation and Scripting](#2b2b)
  prefs: []
  type: TYPE_NORMAL
- en: · [**Julia is Extensively Extendible**](#2fc2)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Introduction](#9c86)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Macros](#6c2d)
  prefs: []
  type: TYPE_NORMAL
- en: · [**Wrapping Up**](#12c0)
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/758e49b62b7e3d994ce7e4802624b3d2.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Daniele Levis Pelusi](https://unsplash.com/@yogidan2012?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: '**Julia is High-level**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The introduction already may have made you feel that this will be like Python
    — a general purpose, dynamic and high-level language as well. To verify, let’s
    get a taste how basic Julia code looks like compared to Python.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following guessing game in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent in Julia:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Main differences here are that Julia does not assume any indentation or require
    colons but instead requires an explicit “end” to end scopes for constructs such
    as if-conditions, loops and functions. You should feel right at home with this
    if you come from Matlab or Fortran.
  prefs: []
  type: TYPE_NORMAL
- en: Another difference that you may have noticed is that Julia naturally supports
    type annotations in variable declarations, function arguments (and return types,
    although rarely used). **They are always optional** but are generally used for
    type assertions, letting the compiler choose the right method instance to call
    when the same method is overloaded for multiple types and in some cases of variable
    and struct declaration, for performance benefits.
  prefs: []
  type: TYPE_NORMAL
- en: '**Elegant Syntax for Mathematics**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: One serious edge that Julia has over Python is syntax support for mathematics.
    * need not be used when multiplying constants by variables, latex symbols are
    supported for variable names (may need to use a VSCode extension to convert \pi
    to π, v\_1 to v₁, etc.) and matrices in general respect the layout in the code
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if you were to implement gradient descent for a neural network.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, you would probably write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare the readability of that to what you can write using Julia:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can try to write code like this in Python, but editors will often put yellow
    squares around the Unicode variables (or fail to highlight them) and your code
    may not work with third party packages such as Pickle.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a4c591a4efa970f6ff7b1fd06a848df0.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Solaiman Hossen](https://unsplash.com/@sh_sumon?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Julia is Fast
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another major reason why Julia can be thought of as a Python dream come true
    is that, unlike Python, Ruby and other high-level languages, it does not compromise
    speed for being high-level. In fact, it can be as fast as low-level languages
    such as C and C++.
  prefs: []
  type: TYPE_NORMAL
- en: Benchmark
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For reference, the following reports the performance of Julia, along with other
    languages on popular performance benchmarks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d79a52100be8befa37ae63b7bac86e88.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Julia Microbenchmarks: Image via* [*JuliaLang*](https://julialang.org/benchmarks/)
    *under MIT license*'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Two Language Problem**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A corollary to Julia’s performance is that is solves the *two-language problem:*
  prefs: []
  type: TYPE_NORMAL
- en: Research code (e.g., a machine learning model), is typically, written in a high-level
    language such Python because it’s high-level and interactive; hence, allows focusing
    more on the science (less code issues) and allows more exploration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once research code is finalized, it must be rewritten in a low-level language
    such as C before it’s rolled out to production.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The issue here is that the same code has to be rewritten in more than one language.
    This is generally hard and error prone; consider if the research code is modified
    after it’s rolled out, in the worst case it will all have to be rewritten in the
    low-level language again.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to get around this issue is to write performance-critical libraries
    (e.g., Numpy) in low-level languages, such as C, then it’s possible to wrap them
    with Python functions that internally call the C ones which can be used for both
    research and production without worrying about performance. In reality, this is
    very limited because:'
  prefs: []
  type: TYPE_NORMAL
- en: It makes it really hard for new developers to contribute or collaborate with
    novel scientific methods they have written, since they may need to rewrite those
    in a low-level language such as C for performance before exposing them in the
    high-level library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hilarious constraints may be imposed on the developers of the high-level language
    in the scientific computing domain. For instance, writing explicit for loops may
    be heavily discouraged.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Julia solves the two-language problem by being high-level, interactive AND quite
    fast, even for production.
  prefs: []
  type: TYPE_NORMAL
- en: Julia is Just-in-time Compiled
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a small note related to Julia’s performance. Because Julia is JIT compiled,
    the first run of any piece of Julia code will take more time to complete. During
    this time, every function code will be converted to native code (i.e., code that
    the processor can interpret) for the specific variable types inferred from the
    code. Once it does, it will cache the compiled representation so that if the function
    is called again with different inputs of same types, then it will be interpreted
    immediately.
  prefs: []
  type: TYPE_NORMAL
- en: To elaborate further, for a function with *N* arguments, there are possibly
    an exponential number of possible native code representations; one for every possible
    combination of types for the *N* arguments. Julia will compile the function down
    to the representation that corresponds to the types inferred from the code the
    first time the code is run. Once it does, further calls for the function will
    be effortless. Note that it does not necessarily use type annotations (which are
    optional and can have other purposes we mentioned) during type inference, types
    can be inferred from runtime values of the inputs.
  prefs: []
  type: TYPE_NORMAL
- en: This is not an issue because research code or code running on a server has to
    initially compile only once and once that’s done any further runs (real API calls
    or further experimentation) of the code are blazing fast.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7a1ed7aac2b56fb711d85e7b9c96cd62.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Thom Milkovic](https://unsplash.com/@thommilkovic?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Julia Solves the Expression Problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**The Expression Problem**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The expression problem is about being able to define a data abstraction that
    is extensible both in its representations (i.e., supported types) and its behaviors
    (i.e., supported methods). That is, a solution to the expression problem allows:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding **new types** to which **existing operations** apply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding **new operations** to which **existing types** apply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: without violating the **open-closed principle** (or causing other issues)*.*
    This implies that it should be possible to add the new types without modifying
    the code for existing operations and it should be possible to add new operations
    without modifying the code for existing types.
  prefs: []
  type: TYPE_NORMAL
- en: Python, like many other programming languages, is object-oriented and fails
    to address the expression problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have the following data abstraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s very easy to add new types to which existing methods should apply. Just
    inherit from the `Shape` base class. It does not require the modification of any
    existing code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Meanwhile, it’s not easy to add operations to which existing types apply. If
    we want to add a `perimeter` method, then we have to modify the base and every
    single child class implemented so far.
  prefs: []
  type: TYPE_NORMAL
- en: One consequence of this problem is that if package *x* is maintained by author
    X and it initially supports the set of operations *Sx,* and if another set of
    operations *Sy* is helpful to another set of developers Y, they must be able to
    modify the package by X to add these methods. In practice, developers Y just make
    another package on their own, possibly duplicating code from that in package *x*
    to implement the type because developer X may not be happy with more code to maintain
    and *Sy* may be a different genre of methods that doesn’t have to live in the
    same package.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, because it’s easy to add new types for which existing operations
    apply, if developerYrather wanted to just define a new type that implements operations
    in the type implemented by X, then they could easily do that without even needing
    to modify package *x* or duplicating any code in it. Just importing the type and
    then inheriting from it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Multiple Dispatch**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To solve the expression problem, which allows massive integration among different
    packages, Julia does away with traditional object-oriented programming completely.
    Instead of classes, Julia uses **abstract type** definitions, **structs** (custom
    type instances of abstract types) and **methods** and a technique called **multiple
    dispatch** that as we will see**,** perfectly solves the expression problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see an equivalent of what we had above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here we defined an abstract type “Shape”. The fact that it’s abstract implies
    that it cannot be instantiated; however, other types (classes) can subtype (inherit
    from) it. Afterwards, we defined a circle type, as a subtype of the `Shape` abstract
    type and we defined the `area` method while specifying that the input must be
    of type `Circle`. By this we can do
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This would print `28.26`. Although, `c` satisfies both `area` definitions because
    it’s also a `Shape`, the second is more specific so it’s the one the compiler
    chooses for the call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to class-based OOP, it’s easy to add another type “rectangle” without
    touching existing code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: And now when we do
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We get `18.0`. This is multiple dispatch in action; the correct instance of
    the method `area` was dynamically dispatched based on the run-time type of the
    arguments. If you come from a C or C++ background, then this must remind you of
    function overloading. The difference is that function overloading is not dynamic,
    it relies on the types found during compile time. Thus, you can devise examples
    where its behavior is different.
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, and unlike class-based OOP, we can add methods to any of `Shape`,
    `Circle` or `Rectangle` without needing to modify their files. If all the files
    above are in my package and you wish to add a set of methods that produce animations
    and 3D visuals of the geometric shapes (which I don’t care about), then all you
    need is to import my package. Now you can access the `Shape`, `Circle` and `Rectangle`
    types and you can write the new functions, then export them in your own “ShapeVisuals”
    package.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When you think about it, the major distinction between this and OOP that you
    know of is that it follows the pattern `func(obj, args)` instead of `obj.func(args)`.
    As a bonus, it also makes things like `func(obj1, obj2, args)` a breeze. The other
    distinction is that it does not encapsulate methods and data together or impose
    any protection on them; perhaps, an irrelevant measure when developers are mature
    enough and code is reviewed anyway.
  prefs: []
  type: TYPE_NORMAL
- en: '**Abstract and Concrete Types**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The fact that you now know that an abstract type is simply a type that you cannot
    instantiate values from but that other types can subtype, paves the way to discuss
    Julia’s type system. Recall that is optional, to use the syntax `var::type`to
    annotate the types of variables upon declaration, as function arguments or returns.
  prefs: []
  type: TYPE_NORMAL
- en: Any type in Julia is either abstract, as we defined above, or concrete. Concrete
    types are those you can instantiate like the custom types we defined above.
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia has the following hierarchical type system for numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/566fc275758736561329441578abe9fd.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Julia Microbenchmarks: Image via J*[*ulia for Optimization and Learning*](https://juliateachingctu.github.io/Julia-for-Optimization-and-Learning/stable/lecture_06/compositetypes/)
    *under MIT license*'
  prefs: []
  type: TYPE_NORMAL
- en: If your function takes one argument and operates on any Number, you will use
    `func(x::Number)`. This would only throw an error if non-numeric value, such as
    a string, is passed. Meanwhile, if it only works for any float then you would
    do `func(x::AbstractFloat)`. No error will be thrown if the input is of type `BigFloat,
    Float64, Floar32 or Floar16`. Because multiple dispatch exists, you can also define
    another instance of the function `func(x::Integer)` to handle the case when the
    given number is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: Julia similarly has a hierarchical type system for [other abstract types](https://www.oreilly.com/library/view/learning-julia-abstract/9781491999585/ch01.html)
    such as `AbstractString` but they are much simpler.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ddab1ebf8e79e00104559b5292c23fb7.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Paul Melki](https://unsplash.com/@paulmelki?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Julia is Fully Featured
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you think about it, Python only comes with bare bone functionality out of
    the box. For instance, you can do very little in data science and scientific computing
    if you are using Python only without popular packages such as Numpy. The vast
    majority of other packages in the field also heavily depend on Numpy. They all
    use and assume the “Numpy” array type (instead of the default Python list type)
    just as if it’s part of the language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia isn’t like that. It comes with many important features out-of-the-box,
    including:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Array Support**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Julia comes with array support similar to Numpy out-of-the-box which includes
    broadcasting and vectorization support. For instance, the following compares popular
    Numpy operations with how you would write them natively in Julia:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '**String Support**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Julia also comes with extensive support for strings and regular expressions
    out-of-the-box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When strings are compared, those later in the lexicographical order (general
    alphabetical order) are considered greater than those that show up earlier in
    the order. It can be shown that most of what you can do with strings in advanced
    string processing languages such as Perl, can be also done in Julia.
  prefs: []
  type: TYPE_NORMAL
- en: '**Multi-threading**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The fact that Python does not support true parallel multi-threading is justified
    by that it comes with a Global Interpreter Lock (GIL). This disallows running
    the interpreter to run multiple threads at the same time as an overly easy solution
    to guarantee thread-safety. It’s only possible to switch between multiple threads
    (e.g., if a server thread is busy waiting for a network request, the interpreter
    can switch to another thread).
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, it’s not hard to release this lock in C programs called by Python which
    explains why Numpy is possible. However, if you have a massive computing for loop,
    then you can’t write Python code that executes it in parallel to speed up computation.
    The sad reality for Python is that the vast majority of mathematical operations
    that apply to large structures of data such as matrices, are parallelizable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Meanwhile, in Julia true parallel multi-threading is natively supported out-of-the-box
    and it’s as easy as doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When you run the code, you get to specify how many threads you want to use among
    the available ones in your system.
  prefs: []
  type: TYPE_NORMAL
- en: '**Easy Integration with C Code**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The process of calling C code from Julia is officially supported out-of-the-box
    and can be done more efficiently and more easily than in Python. If you want to
    call
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: then the main step (after a small setup) to call this function in Julia is writing
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It’s far tricker to do this in Python and it can be less efficient. Especially
    because it’s much easier to map Julia types and structures to those in C.
  prefs: []
  type: TYPE_NORMAL
- en: 'A major consequence of this is that it’s possible to run the vast majority
    of languages that can output object C code here in Julia. Typically, external
    well-known packages exist for those. For instance, to call Python code you can
    use the `PyCall.jl` package as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Almost no prior setup is needed for this besides installing the package. It’s
    likewise possible to call functions written in Fortran, C++, R, Java, Mathematica,
    Matlab, Node.js, and more using similar packages.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, it’s possible to call Julia from Python, although not in
    an as elegant fashion. This has been probably used before to speed up functions
    without resorting to implementing them in C.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Standard Library**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A set of packages come pre-installed (but have to be explicitly loaded) with
    Julia. This includes the **Statistics** and **LinearAlgebra** packages, the **Downloads**
    package to access the internet, and more importantly the **Distribued** package
    for distributed computing (like Hadoop), also the **Profile** package for profiling
    (help optimizing code) and notably the **Tests** package for unit testing and
    the **Pkg** package for package management along with many others.
  prefs: []
  type: TYPE_NORMAL
- en: I must say that I am an avid Python user that has developed multiple packages
    in Python. There is no comparison between the third-party package “Setuptools”
    in Python and **Pkg** in Julia which is really much cleaner and easier to use.
    I was never able to comprehend why Python does not have its own package management
    and testing tools. These are really basic needs in a programming language.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b3db8ea6be5cea905935c76d940bb969.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Tom M](https://unsplash.com/@t_mac?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Julia is General Purpose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have encountered Julia in the past, then it would be natural to hear
    that you think Julia is a domain-specific language where scientific computing
    is the domain. It’s true that Julia has been carefully designed to be expressive
    and efficient for scientific computing but that does not stop it from being a
    general-purpose language. It’s just one built with scientific computing in mind.
    There are whatsoever degrees to which a language can be general purpose. For instance,
    Julia can be used for data science and machine learning, web development, automation
    and scripting, robotics aside from scientific computing, but there are still no
    mature packages that help developers use Julia for things like game development
    similar to Pygame in Python. Even if the Julia package `Genie.jl` is very close
    to be on par with `Flask`, it may fall short from more comprehensive frameworks
    like `Django`. In short, even if Julia is not as general-purpose as you want it
    to be at the moment, it’s built with that in mind and is expected to be eventually.
  prefs: []
  type: TYPE_NORMAL
- en: '**Automation and Scripting**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having mentioned that Julia can be used for automation and scripting, it’s worth
    to point out that it helps do so with elegant shell-like syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, here is a set of file system and process operations you can perform
    in Julia:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Notice the similarity to what you actually write in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a4c3d31a9ef21d695a4fe21ac8bb29e9.png)'
  prefs: []
  type: TYPE_IMG
- en: An Alternative to Starry Night Digital Art — Generated by author using DALLE
    2
  prefs: []
  type: TYPE_NORMAL
- en: Julia is Extensively Extendible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One beautiful feature in the LISP programming language is that it is homoiconic.
    Meaning that code can be treated just like data and hence, new features and semantics
    could be added to the language by ordinary developers. Julia was also built to
    be homoiconic. For instance, remember that I said that Julia supports multiple
    dispatch only. Well, it looks like someone has made a `ObjectOriented.jl` package
    that allows developers to write OOP in Julia. As another example, if you make
    any new type, it’s easy to overload base functions and operators (which are just
    functions) to work with your new type.
  prefs: []
  type: TYPE_NORMAL
- en: Macros
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Julia’s support for macros is a major reason why this is possible. You can
    think of a macro as a function that returns the code to be executed during the
    parse time of the program. Suppose you define the following macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to a function, this allows you to call it in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: which returns 12\. What happens under the hood is that during parse time (before
    compilation) the macro executes, returning the code `5 + 7` which during compile
    time evaluates to `12`. You can think of macros are just way to dynamically perform
    `CTRL+H` (find and replace) operations.
  prefs: []
  type: TYPE_NORMAL
- en: For another practical use case, suppose you have a package with 10 useful methods,
    and you want to add a new interface to the package which means you have to write
    10 structs, one for each method. Suppose it’s systematic to write any of the structs
    given the corresponding function, then you can simply write a single macro where
    you loops over the 10 functions to generate code for the 10 structs. In effect,
    the code you write will be equivalent to writing a single struct in a generic
    manner, so this saves time.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that macros are possible allows for much more magic. For instance,
    if you recall above, we were able to multi-thread a for loop using the `Threads.@threads`
    macro. To measure the execution time of a function call all you do is `@time func()`
    if you are using the `BenchmarkTools` package then `@benchmark func()` would call
    the function many times to return statistics about the time and even a small plot.
    If you know what [memoization](https://en.wikipedia.org/wiki/Memoization) is,
    even that can be applied to any function with a simple `@memoize` macro. There
    is no need to modify it in anyway. There is even `@code_native func()` which would
    show you the native code generated by the function and there are other macros
    that show you other representations of the code during the compilation process.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It turns out that all the language features we have talked about were initially
    part of the plan for Julia. As stated on Julia’s website, this is the language’s
    [vision](https://julialang.org/blog/2012/02/why-we-created-julia/):'
  prefs: []
  type: TYPE_NORMAL
- en: “We want a language that’s open source, with a liberal license. We **want the
    speed of C** with the **dynamism of Ruby**. We want a language that’s **homoiconic**,
    with **true macros like Lisp**, but with obvious, **familiar mathematical notation
    like Matlab**. We want something as usable for **general programming as Python**,
    as **easy for statistics as R**, as **natural for string processing as Perl**,
    as **powerful for linear algebra as Matlab**, as good at **gluing programs together
    as the shell**. Something that is **dirt simple to learn**, yet keeps the most
    serious hackers happy. We want it interactive, and we want it compiled.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Having read the story, you should more or less be able to reflect on every word
    mentioned in the vision statement at this point.
  prefs: []
  type: TYPE_NORMAL
- en: I hope that reading this has helped you learn more about the Julia language
    and that you will consider learning the language. Till next time, au revoir.
  prefs: []
  type: TYPE_NORMAL
