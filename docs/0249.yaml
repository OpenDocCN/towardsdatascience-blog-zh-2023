- en: Quantum Computing for Optimization Problems — Solving the Knapsack Problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/quantum-computing-for-optimization-problems-solving-the-knapsack-problem-274f01e78ed8?source=collection_archive---------7-----------------------#2023-01-16](https://towardsdatascience.com/quantum-computing-for-optimization-problems-solving-the-knapsack-problem-274f01e78ed8?source=collection_archive---------7-----------------------#2023-01-16)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How to solve an optimization problem using quantum computing, compared to a
    traditional solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://florin-andrei.medium.com/?source=post_page-----274f01e78ed8--------------------------------)[![Florin
    Andrei](../Images/372ac3e80dbc03cbd20295ec1df5fa6f.png)](https://florin-andrei.medium.com/?source=post_page-----274f01e78ed8--------------------------------)[](https://towardsdatascience.com/?source=post_page-----274f01e78ed8--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----274f01e78ed8--------------------------------)
    [Florin Andrei](https://florin-andrei.medium.com/?source=post_page-----274f01e78ed8--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Faeaeb9d7d248&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fquantum-computing-for-optimization-problems-solving-the-knapsack-problem-274f01e78ed8&user=Florin+Andrei&userId=aeaeb9d7d248&source=post_page-aeaeb9d7d248----274f01e78ed8---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----274f01e78ed8--------------------------------)
    ·12 min read·Jan 16, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F274f01e78ed8&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fquantum-computing-for-optimization-problems-solving-the-knapsack-problem-274f01e78ed8&user=Florin+Andrei&userId=aeaeb9d7d248&source=-----274f01e78ed8---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F274f01e78ed8&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fquantum-computing-for-optimization-problems-solving-the-knapsack-problem-274f01e78ed8&source=-----274f01e78ed8---------------------bookmark_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: There are many problems that require finding the maximum or minimum of a function,
    called the objective function, that depends on several (or many) variables; certain
    constraints may or may not need to be applied to the variables. The variables
    could be binary, integer, elements in sets, floating point, etc. The constraints
    may apply to variables individually, or could be more complex.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, these problems could offer solutions for optimizing industrial
    processes, or optimizing the flow of goods between factories and warehouses (by
    cost, by time, by throughput), could optimize driving routes, could find all members
    of a social network that satisfy some complex criterion — the examples could go
    on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithms for solving these problems are numerous: linear programming,
    integer programming, simulated annealing, pure simulation techniques, and many
    more. These tend to be studied in fields you may know as Prescriptive Analytics,
    Operations Research, etc. Generally, these algorithms run on conventional CPUs.
    Where applicable, GPU solvers are also used.'
  prefs: []
  type: TYPE_NORMAL
- en: Quantum computing is a future-oriented topic that has been gaining popularity
    in recent years. While full general-purpose quantum computing is not generally
    available right now (January 2023), certain specialized machines can be used already
    to solve optimization problems extremely fast. [Here is an article published by
    Ars Technica](https://arstechnica.com/science/2023/01/companies-are-relying-on-quantum-annealers-for-useful-computations/)
    showcasing some applications for these early quantum systems.
  prefs: []
  type: TYPE_NORMAL
- en: In this article, we will describe briefly one of these early quantum architectures,
    and we will compare it with a classical approach for solving a typical optimization
    case — the knapsack problem.
  prefs: []
  type: TYPE_NORMAL
- en: But first, let’s talk about models.
  prefs: []
  type: TYPE_NORMAL
- en: Quadratic Models — Binary, Discrete, Constrained
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a class of models called binary quadratic (BQM). Their variables are
    binary (can take one out of two possible values), and they are a combination of
    linear and quadratic terms. The Ising formula provides an example of an objective
    function for a BQM model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0de87df3dedcb658e41b6d9ad831888e.png)'
  prefs: []
  type: TYPE_IMG
- en: Ising model, objective function
  prefs: []
  type: TYPE_NORMAL
- en: The variables s can take values from {-1, +1}. The h coefficients are the linear
    biases. The J coefficients are the quadratic couplings. The objective function
    can be thought of as the energy of the system — more on that later.
  prefs: []
  type: TYPE_NORMAL
- en: 'An equivalent way to describe the same BQM models is the QUBO formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5a4b7ff7b5a562c58748aaff6265f1ff.png)'
  prefs: []
  type: TYPE_IMG
- en: QUBO model, objective function
  prefs: []
  type: TYPE_NORMAL
- en: The model variables are the vector x of binary values — the possible values
    are {0, 1}. The upper-diagonal matrix Q contains the linear coefficients on the
    diagonal, and the quadratic coefficients are off-diagonal.
  prefs: []
  type: TYPE_NORMAL
- en: Both the Ising and the QUBO equations describe the same models, and converting
    between them should be trivial. Ising may look more familiar from a physics background,
    whereas QUBO is more akin to a computer science model. Solving these models means
    finding the values for variables that minimize the objective function.
  prefs: []
  type: TYPE_NORMAL
- en: If the variables can take discrete values from a set larger than just binary,
    the model is called discrete quadratic — DQM. If the variables can have any integer
    or real values, and various constraints may bind these variables, then the model
    is called constrained quadratic — CQM. These are generalizations of the basic
    BQM description.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore a hardware architecture that can solve such models very efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: D-Wave Quantum Annealers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A general-purpose quantum computer may contain a number of qubits (quantum bits,
    with values of either 0 or 1) connected via quantum logic gates. Such a machine
    could be programmed via an SDK like [Qiskit](https://qiskit.org/), and could solve
    virtually any problem — hence the qualifier “general-purpose”. Right now, no such
    machines can yet solve real-world problems since the hardware is still very limited
    by low qubit counts and high error rates.
  prefs: []
  type: TYPE_NORMAL
- en: 'But for specialized applications, quantum computers can already be used. [D-Wave](https://www.dwavesys.com/)
    has built quantum computers that can be used to solve various optimization problems
    today. This is the architecture of a D-Wave QPU:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/36a4790cdb67e88c640bc342a250b804.png)'
  prefs: []
  type: TYPE_IMG
- en: D-Wave Chimera QPU
  prefs: []
  type: TYPE_NORMAL
- en: The thin, elongated black shapes, grouped in 4+4 grids (unit cells), are tiny
    superconductive loops, criss-crossing the surface of the chip. Each loop, being
    superconductive, can hold an electric current. Due to the current, the loop will
    have a small magnetic field. The direction of the magnetic field could be either
    up or down (either +1 or -1). Think of the loops as qubits — quantum bits.
  prefs: []
  type: TYPE_NORMAL
- en: The green dots are called internal couplers — they are internal to each 4x4
    unit cell. They couple the magnetic fields of two intersecting loops by some amount,
    so the values of the fields are partially co-dependent. The loops do not touch,
    they are just coupled magnetically.
  prefs: []
  type: TYPE_NORMAL
- en: The blue dots are called external couplers. They couple the magnetic fields
    of loops in different unit cells.
  prefs: []
  type: TYPE_NORMAL
- en: There are many unit cells in a Chimera QPU, with the total number of qubits
    exceeding 2000 per QPU.
  prefs: []
  type: TYPE_NORMAL
- en: Remember the Ising formula for BQMs? The magnetic fields in the loops are the
    variables s in the model. Each loop can have a hardware bias that strengthens
    or weakens the field — the biases are the linear coefficients h in the Ising formula.
    And the couplers (internal or external) are the quadratic coefficients J in Ising.
  prefs: []
  type: TYPE_NORMAL
- en: 'The total energy of the system, as calculated via the Ising formula, is given
    by:'
  prefs: []
  type: TYPE_NORMAL
- en: the orientation (up or down) of the magnetic field of each loop (the s variables
    in Ising, which can be either +1 or -1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the bias of each loop (the h coefficients in Ising)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the couplings (the J coefficients in Ising)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In other words, the total energy of the quantum device is the same as the objective
    function in the Ising model. If the physical system reaches its minimum possible
    energy, that ought to be the same as the smallest possible value for the objective
    function.
  prefs: []
  type: TYPE_NORMAL
- en: To solve a BQM, the Ising formula needs to be written according to the specifics
    of the problem. The h and J coefficients from the Ising formula give the biases
    and couplings within the QPU, and are coded into the hardware. Initially, all
    loops are set in a state of quantum superposition, where their magnetic fields
    are pointing both up and down. That corresponds to a high energy state. The whole
    setup process can be done in Python via the D-Wave API.
  prefs: []
  type: TYPE_NORMAL
- en: The total energy of the system is then lowered gradually (a process called annealing),
    until it reaches the minimum possible value given the h and J coefficients (biases
    and couplings). At that point, the quantum superposition of the magnetic fields
    is destroyed; the field of any loop will point either up or down.
  prefs: []
  type: TYPE_NORMAL
- en: The minimum value of the total energy is the value of the objective function
    that corresponds to the solution to the BQM. The directions of the magnetic fields
    of the loops are the values of the variables which solve the optimization problem
    (up=+1, down=-1). Simply reading the loops at that point provides the solution
    to the problem.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, quantum annealing takes a fraction of a second. Regardless of the
    size of the problem, if the Ising BQM can fit on a QPU chip, the solution (the
    annealed final state) is obtained very quickly. D-Wave exploits the tendency of
    physical systems to reach low energy states, and uses that to solve NP-hard problems
    very quickly. The name Ising may ring a bell — the equations determined by Lenz
    and Ising a century ago are a statistical model for ferromagnetism, and are here
    used to solve a specific type of model via physical processes.
  prefs: []
  type: TYPE_NORMAL
- en: In a sense, the quantum annealer (D-Wave QPU) is like an analog computer that
    simulates numeric problems with physical processes. It could also be thought of
    as related to an FPGA, in the sense that it’s a device that can be configured
    for a specific problem, solves the problem quickly, then can be reconfigured for
    a different problem.
  prefs: []
  type: TYPE_NORMAL
- en: Back to the Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As long as your problem can be expressed as a BQM, it can be solved by a D-Wave
    quantum annealer directly and very quickly.
  prefs: []
  type: TYPE_NORMAL
- en: What if the problem is not quadratic? It could be linear, or cubic, etc. In
    general, models can be reformulated by introducing dummy variables, and via other
    techniques, until they become quadratic. [The D-Wave Problem-Solving Handbook](https://docs.dwavesys.com/docs/latest/doc_handbook.html)
    describes several such techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if the models, even after reformulation, are quadratic but not purely
    binary? Some could be discrete models (DQM — more than just two values for each
    variable), others may have constraints and the variables could be anything (CQM
    — constrained quadratic models). DQM and CQM cannot run directly on a quantum
    annealer. However, you can still code the problem using the D-Wave API and submit
    it to the solvers in the cloud. D-Wave will decompose the problem into BQM (which
    can be solved by the quantum machine) and the rest (which is then solved by D-Wave
    using regular solvers). Think of it as divide-and-conquer: D-Wave tries to solve
    as much of your model as possible using the quantum annealer, but some problems
    still have parts that do not conform to the BQM equations. The combination of
    quantum and classical solvers that can solve different kinds of quadratic models
    is called a hybrid solver.'
  prefs: []
  type: TYPE_NORMAL
- en: In practice, even when a DQM or a CQM is solved with hybrid solvers, the process
    tends to still be very fast. The hard kernel of the problem is solved as BQM (perhaps
    many BQMs are sampled from a large parameter space), and the classical algorithms
    can be thought of as summarizing across large sample sets of BQMs.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth spending time to formulate the problem as a BQM, as that will be
    solved extremely fast on a quantum annealer. It may still be worth formulating
    the problem as a DQM or CQM, since in many cases the problem will still be solved
    by the D-Wave hybrid solvers in a very short time.
  prefs: []
  type: TYPE_NORMAL
- en: If the objective function needs to be maximized instead of minimized, just flip
    the sign on the whole formula. If you need to solve an equality instead of minimizing
    some expression, move all terms to the left side (which then becomes equal to
    zero), then square it — the squared amount, when minimized, will reach zero, which
    is what you want.
  prefs: []
  type: TYPE_NORMAL
- en: Many mathematical tricks like these can be used to formulate the problem in
    terms close to the quadratic models that the D-Wave solvers (quantum and hybrid)
    can solve very efficiently — minimize a function that looks a lot like a quadratic
    model.
  prefs: []
  type: TYPE_NORMAL
- en: The Knapsack Problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example we will use here to compare quantum technology with traditional
    approaches is called the knapsack problem.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8174c1109d708465e32c4f5f34e89cb9.png)'
  prefs: []
  type: TYPE_IMG
- en: knapsack problem
  prefs: []
  type: TYPE_NORMAL
- en: You have a knapsack with a weight limit — it can only carry a certain maximum
    weight. You have many items, each with a different weight, and a different monetary
    value. You want to choose a number of items to carry in the knapsack, while maximizing
    the monetary value of the whole transport, but without exceeding the maximum allowable
    weight.
  prefs: []
  type: TYPE_NORMAL
- en: The objective function is obviously the monetary value of all items in the knapsack
    — bigger is better. The constraint is the total weight of the items, which must
    be at or below some value.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to solve this problem. A brute force approach is doable
    if the number of items is small. This becomes very quickly unfeasible even for
    a moderate number of items.
  prefs: []
  type: TYPE_NORMAL
- en: The classical approach we will describe below is called integer programming.
    Then we will compare it with the D-Wave hybrid solvers.
  prefs: []
  type: TYPE_NORMAL
- en: Integer Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Out of the many ways to solve this problem, we will pick [the Pyomo library](http://www.pyomo.org/)
    to construct the integer programming model, and then we will use [the GLPK solver](https://www.gnu.org/software/glpk/)
    to solve it. There are certainly faster methods available, but this code is simple
    and looks rather similar to the quantum code in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full Jupyter notebook is linked at the end of the article. This is just
    the integer programming part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The values and weights lists contain the monetary values and the weights of
    all items. The objective function is created by summing the monetary values of
    all chosen items. The constraint is built by summing all weights of chosen items,
    then capping that sum as equal to or less than max_weight.
  prefs: []
  type: TYPE_NORMAL
- en: The complete model is sent to the solver, running locally. When the solver is
    done, the results are parsed out of the solver output.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use the D-Wave SDK, which formulates the model, then submits it to the D-Wave
    solvers running in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We start with the same weights and values lists. The model for this problem
    cannot be pure BQM, since we have a constraint. Therefore, we choose a hybrid
    sampler.
  prefs: []
  type: TYPE_NORMAL
- en: An interesting twist is that many sample sets may be returned by D-Wave as part
    of the solution. Some are not feasible (e.g. violate constraints) and we need
    to filter them out of the results. Out of the feasible sample sets, one or several
    will have the lowest Ising energy — those are the best solutions found by the
    quantum computer.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming there is a “best” solution, the quantum annealer does not always converge
    on it. Details are complex, see the D-Wave handbook, but in essence a heuristic
    search is sometimes employed to find a “good enough” solution. In other cases,
    the solver can be coaxed into converging more strongly toward the absolute best
    solution. Finally, another trick is to repeatedly sample the solutions until the
    absolute best combination is obtained. The D-Wave documentation is very good,
    and it provides many techniques for fine-tuning the solvers for finding the best
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve tested both algorithms with a randomly generated dataset containing 50
    thousand items, with weights and values varying randomly in a discrete uniform
    distribution between 1 and 9999\. The knapsack weight limit was set to 80% of
    the total weight of all items — so some items will always be discarded.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the output from Pyomo / GLPK:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: GLPK took over 2 minutes to solve the problem. It came up with a combination
    of items that is just under the maximum allowed knapsack weight.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the output from D-Wave:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The total time spent by the D-Wave hybrid solver was 18 seconds. This is not
    quite an order-of-magnitude improvement over integer programming, but it’s getting
    there. Moreover, slight increases in the number of items force the integer programming
    code to spend a much, much longer time solving the problem — the increase is non-linear.
  prefs: []
  type: TYPE_NORMAL
- en: Not so with the D-Wave solver. It, too, spends a longer time solving a bigger
    problem, but the time it takes to do that does not increase catastrophically with
    the number of items.
  prefs: []
  type: TYPE_NORMAL
- en: The time spent on the actual QPU (the quantum annealer) is only 16 milliseconds.
    Most of the 18 seconds total is spent decomposing the problem, sampling the solution
    space, then sending the results back to the coder. The larger the fraction of
    the problem that runs on the actual QPU, the bigger the speed gain.
  prefs: []
  type: TYPE_NORMAL
- en: With very large problems, your Internet connection may become a limiting factor.
    In my case, running this problem over a mediocre connection, my code spent a few
    extra seconds pushing and pulling data across the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, please note that the solution found by the hybrid solver is actually
    a tiny bit worse than the solution found by the integer programming solver. The
    hybrid solvers can be optimized to find even better solutions, as mentioned above,
    but that is outside the scope of this article.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The complete notebook with the entire code used in this article, along with
    other files and materials, can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://github.com/FlorinAndrei/misc/tree/master/quantum_computing_knapsack_article?source=post_page-----274f01e78ed8--------------------------------)
    [## misc/quantum_computing_knapsack_article at master · FlorinAndrei/misc'
  prefs: []
  type: TYPE_NORMAL
- en: You can't perform that action at this time. You signed in with another tab or
    window. You signed out in another tab or…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: github.com](https://github.com/FlorinAndrei/misc/tree/master/quantum_computing_knapsack_article?source=post_page-----274f01e78ed8--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 'The quantum solver code is based on D-Wave’s own examples repository, refactored
    for clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://github.com/dwave-examples?source=post_page-----274f01e78ed8--------------------------------)
    [## D-Wave Systems Examples'
  prefs: []
  type: TYPE_NORMAL
- en: D-Wave Ocean code examples. D-Wave Systems Examples has 50 repositories available.
    Follow their code on GitHub.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: github.com](https://github.com/dwave-examples?source=post_page-----274f01e78ed8--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: All images shown in this article are created by the author.
  prefs: []
  type: TYPE_NORMAL
