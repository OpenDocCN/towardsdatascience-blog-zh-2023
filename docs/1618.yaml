- en: Modeling the Traveling Salesman Problem from first principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://towardsdatascience.com/modeling-the-traveling-salesman-problem-from-first-principles-bd6530c9c07?source=collection_archive---------1-----------------------#2023-05-14](https://towardsdatascience.com/modeling-the-traveling-salesman-problem-from-first-principles-bd6530c9c07?source=collection_archive---------1-----------------------#2023-05-14)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A concepts-first, math-second approach to modeling the most well-known routing
    problem in Operations Research
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@carlosjuribe?source=post_page-----bd6530c9c07--------------------------------)[![Carlos
    J. Uribe](../Images/902c5f4ac5d404dd99916f145be6756c.png)](https://medium.com/@carlosjuribe?source=post_page-----bd6530c9c07--------------------------------)[](https://towardsdatascience.com/?source=post_page-----bd6530c9c07--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----bd6530c9c07--------------------------------)
    [Carlos J. Uribe](https://medium.com/@carlosjuribe?source=post_page-----bd6530c9c07--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ¬∑
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F4337eddb94ed&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmodeling-the-traveling-salesman-problem-from-first-principles-bd6530c9c07&user=Carlos+J.+Uribe&userId=4337eddb94ed&source=post_page-4337eddb94ed----bd6530c9c07---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----bd6530c9c07--------------------------------)
    ¬∑15 min read¬∑May 14, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fbd6530c9c07&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmodeling-the-traveling-salesman-problem-from-first-principles-bd6530c9c07&user=Carlos+J.+Uribe&userId=4337eddb94ed&source=-----bd6530c9c07---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fbd6530c9c07&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmodeling-the-traveling-salesman-problem-from-first-principles-bd6530c9c07&source=-----bd6530c9c07---------------------bookmark_footer-----------)![](../Images/eb338d2b5f2eb31841f667fa8c183c65.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Image generated by DALL¬∑E 3 with author‚Äôs prompt: ‚Äúa map displaying the typical
    tourist route in Paris with equations scattered throughout‚Äù'
  prefs: []
  type: TYPE_NORMAL
- en: '*üëÅÔ∏è* **This is article #2 of the series covering the project ‚Äú**[**An Intelligent
    Decision Support System for Tourism in Python**](https://medium.com/@carlosjuribe/list/an-intelligent-decision-support-system-for-tourism-in-python-b6ba165b4236)**‚Äù.**
    I encourage you to check it out to get a general overview of the whole project.
    If you‚Äôre only interested in how to model the TSP, you‚Äôre still at the right place,
    as this article is self-contained. **If you‚Äôre** **also interested in solving
    the problem**, not just modeling it, you‚Äôll love the next 5 articles of the series.
    Trust me, they‚Äôll provide you with what you need and what you didn‚Äôt know you
    needed *üòâ*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Table of contents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[**1\. Motivation and purpose**](#e5c2)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[**2\. Understanding the data**](#e164)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[**3\. Defining a conceptual model from the problem description**](#9b59)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[**4\. Building a mathematical model from the conceptual model**](#d2ba)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[4.1\. Putting the data in Sets and Parameters](#94fd)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[4.2\. Encoding decisions in Variables](#b192)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[4.3\. Defining the Objective](#8d7b)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[4.4\. Creating the Constraints](#6582)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1\. Motivation and purpose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This article continues right where [the article for sprint 1](https://medium.com/@carlosjuribe/plan-an-optimal-trip-for-your-next-holidays-with-the-help-of-operations-research-and-python-481b1ea38fef)
    left off. You don‚Äôt need to have read it to understand what we‚Äôll do here, but
    let me give you a quick recap (feel free to jump to section 2 if you did read
    the previous article). In a nutshell, we laid out the common problems that tourists
    face when planning a trip, and we set out to build a system that can *help us
    plan trips more effectively*, speeding up decision-making, or even fully automating
    the schedule for any given trip. We observed that stated like that, the problem
    is too complex, so we decomposed it and arrived at its essential version, and
    we called it the **minimum valuable problem**. In the end, we concluded that it
    took the form of the [Traveling Salesman Problem](https://en.wikipedia.org/wiki/Travelling_salesman_problem)
    (TSP), where the ‚Äúcities‚Äù that the proverbial salesman must visit correspond,
    in our version, to the ‚Äúsites of interest‚Äù in a city that a tourist desires to
    visit.
  prefs: []
  type: TYPE_NORMAL
- en: So, as a kickstarter, we must first formulate and solve the TSP, and once that‚Äôs
    done, we‚Äôll be on firm grounds to progress toward a more sophisticated and general
    solution to our trip planning problem. We chose this approach because **this article
    series aims to teach an agile approach to modeling in Operations Research (OR)**,
    so many of the lessons, tips, and tricks you‚Äôll find here are *applicable to any
    kind of problem* you may face in OR in general.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to our business, we have the problem **description** of the TSP:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Goal**: walk as little distance as possible'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Requirements**: visit each site only once, and return to the original departure
    site (in our case, the hotel).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What we need is **a *model* of the problem**, **not a *solution* to the problem**.
    I know it‚Äôs tempting to focus on getting solutions, but think about it: if we
    obtained a *direct solution* to the TSP, say, with some kind of [heuristic algorithm](https://en.wikipedia.org/wiki/Heuristic_(computer_science))
    that finds *some* solution ‚Äî even if it‚Äôs optimal‚Äî, it would still be insufficient
    for us because *the TSP is not our actual problem, but a simple approximation
    to it that we‚Äôll need to expand to make it* ***approximate*** *our real-life problem.*
    The moment we change the problem description (which we‚Äôll do), any [solution algorithm](https://youtu.be/GiDsjIBOVoA?si=sY8LGNiehLoAXFtV)
    tailored for the TSP will become obsolete, and we‚Äôd have to start from scratch.'
  prefs: []
  type: TYPE_NORMAL
- en: Models can be augmented, tweaked and refined to adapt to your problem and its
    changing requirements. Solution algorithms, however, tend to be customized to
    specific problems, and are very hard to modify when the problem changes.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Hence, our goal is to **build a model of the TSP.** Once you learn how to reason
    your way into such a model, you will have a good understanding to go and read
    [the next sprint‚Äôs article](https://medium.com/@carlosjuribe/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c),
    where we will **implement the model in Python:**
  prefs: []
  type: TYPE_NORMAL
- en: '[](/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c?source=post_page-----bd6530c9c07--------------------------------)
    [## Implementing, solving and visualizing the Traveling Salesman Problem with
    Python'
  prefs: []
  type: TYPE_NORMAL
- en: Learn how to translate an optimization model from Math to Python, optimize it,
    and visualize the solution to gain quick‚Ä¶
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c?source=post_page-----bd6530c9c07--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Understanding the data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you recall from [our last sprint](https://medium.com/@carlosjuribe/plan-an-optimal-trip-for-your-next-holidays-with-the-help-of-operations-research-and-python-481b1ea38fef),
    the *basic input* for the TSP is just a list of sites that we want to visit in
    a single day. In this proof-of-concept, we‚Äôre using Paris, so I‚Äôve chosen these
    eight famous, must-visit places:'
  prefs: []
  type: TYPE_NORMAL
- en: Sacre Coeur
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Louvre
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Montmartre
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Port de Suffren
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arc de Triomphe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Av. Champs √âlys√©es
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notre Dame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tour Eiffel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since the problem consists of finding a tour of minimal *distance*, the actual
    data we need is *distance data,* whichdepends on the sites and their relative
    geographic positions. How to compute distance data from geographic locations will
    be covered in [sprint 4](https://medium.com/@carlosjuribe/compute-the-distance-matrix-of-a-set-of-sites-from-their-coordinates-in-python-d5fc92a0ba9e),
    since covering it now would entail a *de-tour* (pun intended) that would distract
    you from the main focus here: model building.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for now, consider you‚Äôre given the distances between all possible pairs.
    They will be given as a CSV file in the [next sprint](https://medium.com/@carlosjuribe/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c)
    when we implement the model in Python. The data looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/18f610b518e1fed4161c761c29896bb7.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 2.1.** Distance data for a sample set of Paris sites, needed for the
    TSP. (Image by author)'
  prefs: []
  type: TYPE_NORMAL
- en: We‚Äôll call this table the **distance matrix**. Note that, although not particularly
    postcard-worthy, the hotel is included in the matrix too, as it counts as another
    site that needs to be in the final tour. For this MVP, we keep things simple and
    use a **symmetric distance matrix**, which is a fancy way of saying that the distance
    from ùê¥ to ùêµ is the same as the distance from ùêµ to ùê¥, for any A and B. In more
    advanced settings, this need not be the case to a relevant degree, making this
    approximation ineffective.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Defining a conceptual model from the problem description
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we‚Äôre at the stage represented as the green block in the flowchart below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9fa991cd58851a35926426135bddd4b2.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 2.2.** Minimalist workflow to problem-solving in OR. 2nd stage: **conceptual
    model** (Image by author)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of the conceptual model is to state the problem using words, but
    in a **standardized format**, so that the **mapping between ‚Äúsentences‚Äù and ‚Äúmathematical
    objects‚Äù becomes clear** later in the subsequent phase (mathematical model formulation).
    We can postulate our **conceptual model** like this:'
  prefs: []
  type: TYPE_NORMAL
- en: (Knowing)
  prefs: []
  type: TYPE_NORMAL
- en: '**Data (sets and parameters)**:'
  prefs: []
  type: TYPE_NORMAL
- en: The list of sites to visit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The distance between any pair of sites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (We need to decide)
  prefs: []
  type: TYPE_NORMAL
- en: '**Decisions**: In which order to visit the sites'
  prefs: []
  type: TYPE_NORMAL
- en: (In a way that we)
  prefs: []
  type: TYPE_NORMAL
- en: '**Objective**: Minimize the total distance traveled'
  prefs: []
  type: TYPE_NORMAL
- en: (Such that)
  prefs: []
  type: TYPE_NORMAL
- en: '**Constraints**:'
  prefs: []
  type: TYPE_NORMAL
- en: All sites are visited
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each site is visited just once
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last site visited is the site we started from (we do a closed tour)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***üëÅÔ∏è Follow good practices and, in practice, goodness will follow you***'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You may have thought that the conceptual model looks quite trivial and not very
    different from the ‚Äúsimple‚Äù problem statement we started the article with. And
    you would be right. For small problems like this one, it can be a repetitive step.
    **But for bigger problems, this stage is indispensable, and attempting to build
    a mathematical model without having a conceptual model first usually translates
    into mayhem** (unclear or vague requirements, bad formulations, buggy code, infeasible
    models, etc.) Thus, it is paramount that we build the discipline now and go through
    this stage here too, even if the marginal value in our simple case is very low.
    Focus on good habits, and good results will follow.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 4\. Building a mathematical model from the conceptual model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We just reached ‚Äústage 3‚Äù of the workflow, in green below. The ‚Äú**mathematical
    model** stage‚Äù, probably the most challenging stage of all, is where *natural*
    *language becomes mathematics.*
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/59a610c78053af6bbc78697cbfb9e844.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 2.3.** Minimalist workflow to problem-solving in OR. 3rd stage: **mathematical
    model** (Image by author)'
  prefs: []
  type: TYPE_NORMAL
- en: It is at this stage where not even the least amount of ambiguity is permitted.
  prefs: []
  type: TYPE_NORMAL
- en: A well defined mathematical model is worth a hundred clarifications
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this stage of our workflow, we build a *pure* model for the TSP, and in the
    next phase (covered in ‚Äú[sprint 3](https://medium.com/@carlosjuribe/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c)‚Äù)
    we will construct a **model instance** out of the CSV dataset we explained earlier,
    with the help of Python.
  prefs: []
  type: TYPE_NORMAL
- en: '*üìù* ***Theory refresher: ‚Äú*abstract model‚Äù *vs ‚Äú*model instance‚Äù**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Mathematical models (in OR) are made of ‚Äú**components**‚Äù. These are **all the
    elements** (equations, data, etc.) **that collectively represent a problem** of
    a certain structure. **What truly defines a model is its structure, *i.e.*, how
    its components relate to each other**, regardless of the particular numerical
    values that these components take in any given example.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A **model instance** is a specific ‚Äúmaterialization‚Äù of an ‚Äúabstract model‚Äù
    with **concrete data**. Thus, we normally define abstract models, then populate
    them with data of particular scenarios, which yields **model instances**. It is
    those model instances that we optimize to get **concrete results.**
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the subsections below, I will briefly touch on the components that make up
    a model, and their purposes, while I‚Äôm defining them. Feel free to skip these
    explanations, and jump directly to the mathematical definitions, if you are not
    a beginner and already know the functions of the model components.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1\. Putting the data in Sets and Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the data we need resides in the dataframe displayed in Figure 2.1\. We *could*
    keep the data *only* there, fetching all the numbers from that dataframe when
    creating the constraints and objective of the model. In fact many people do that,
    but **it‚Äôs a bad habit that doesn‚Äôt scale well with the size of the model**. As
    the model complexity grows, this approach necessitates of ever growing [glue code](https://en.wikipedia.org/wiki/Glue_code)
    (to deal with dataframe operations) that could be avoided if the data were kept
    organized in other data structures more geared towards the building of optimization
    models. These data structures are the **sets** and **parameters** of a model.
  prefs: []
  type: TYPE_NORMAL
- en: '*üí°* ***Different data structures to serve different needs***'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In case you were wondering **‚ÄúWhy create sets and parameters, when we already
    have the data we need in a table?‚Äù**, the short answer is: because doing so makes
    the model building easier, more general, and less error-prone.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '‚Äú***Sets***‚Äù are the model components used to **store the main ‚Äúentities‚Äù,**
    or ‚Äúelements‚Äù, of a problem, whereas ‚Äú***parameters*‚Äù are used to store the**
    **numerical properties** **of those entities, or of their *relationships***. In
    our example, the sites are the main ‚Äúentities‚Äù, so they will be stored in a **set**,
    and the distances between pairs of sites are the ‚Äúnumerical properties‚Äù of their
    relationships, so they will be stored as **parameters**. At the ‚Äúimplementation
    level‚Äù, it is also very useful to make this categorization because **each component
    serves a different function** that will make model building easier:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ‚Ä¢ The function of **sets** is the **convenient storage and manipulation of indices**.
    These indices are the IDs or names that represent the different ‚Äúentities‚Äù of
    the problem, and they are used **to *index* parameters in *convenient* ways**
    for the creation of constraints and objectives.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ‚Ä¢ The function of **parameters** is the **convenient storage and manipulation
    of numerical properties of the ‚Äúentities‚Äù they are indexed by**, and these are
    the numbers that **actually appear** in the constraints and objectives.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'From our conceptual model, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of sites to visit, which we define as the **set** ùïä:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/395f8548dbc2fa320bc17034897f5338.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Expression 2.1.** The set of all sites to visit on the trip (displaying just
    2 for brevity).'
  prefs: []
  type: TYPE_NORMAL
- en: The phrase ‚Äúindexed by ùëñ, ùëó‚Äù is placed next to the set definition to signal
    that whenever the indices ùëñ or ùëó are used in the model, they represent members
    of ùïä. That way, when we have several sets, and thus multiple indices in use, it‚Äôs
    easier to remember what each index means.
  prefs: []
  type: TYPE_NORMAL
- en: 'The distance between any pair of sites, which we define as the *indexed* **parameter**
    ùê∑·µ¢‚±º:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/ede4dd301fb2d100773d9a5b77baac7f.png)'
  prefs: []
  type: TYPE_IMG
- en: The parameter is called ‚Äú**indexed**‚Äù simply to indicate that it is not a scalar
    parameter (*i.e.*, a single number), but a 2-D matrix of numbers. To retrieve
    a number from this *indexed parameter* you need to specify two indices, ùëñ and
    ùëó, which in turn will be taken from the set ùïä.
  prefs: []
  type: TYPE_NORMAL
- en: ùïä and ùê∑·µ¢‚±º are the only ‚Äúdata components‚Äù present in the conceptual model. But
    that shouldn‚Äôt limit our ability to come up with other sets or parameters that
    *prove useful when building a model*.
  prefs: []
  type: TYPE_NORMAL
- en: As an illustration, note that the indices of ùê∑·µ¢‚±º, ùëñ and ùëó, are members of ùïä
    but *cannot coincide*. If they did, the distance would be zero, which is a trivial
    datum. Besides, we would never go from one place to itself again, so it is useless
    to consider pairs (ùëñ, ùëñ) at all. Thus, it‚Äôs useful to limit the combinations that
    pairs (ùëñ, ùëó) can take, **so that modeling becomes easier (and *errors less likely*).**
    To that end, we now create another set, ùî∏, **derived** from ùïä, that contains all
    pairs (ùëñ, ùëó) of *different sites*. Each pair represents an **arc** connecting
    site ùëñ to site ùëó, hence the symbol ùî∏.
  prefs: []
  type: TYPE_NORMAL
- en: '*üìù* **An arc is just a ‚Äúdirected link‚Äù** between two nodes of a ‚Äúnetwork‚Äù.
    Just think of an arc (ùëñ, ùëó) as a vector starting at ùëñ and ending at ùëó. **When
    the ‚Äúlink‚Äù between two nodes is not directed** (i.e., the direction is irrelevant)
    **the word ‚Äúedge‚Äù is used**, as saying ‚Äúundirected arc‚Äù all the time would be
    too wordy. People in Graph Theory like to be efficient too.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A nice property of ùî∏ is that it is the **domain over which** ùê∑·µ¢‚±º **is defined**,
    and as we will see when implementing the model in Python, defining such a domain
    explicitly makes it *reusable* for other model components, and that‚Äôs also convenient.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set of possible arcs between different sites:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/d715b2ebc97925fc3acc15991d0d540e.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Expression 2.2.** (Derived) set of possible arcs of the tour (site-to-site
    paths).'
  prefs: []
  type: TYPE_NORMAL
- en: 4.2\. Encoding decisions in variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we are building a model so it can tell us what actions we should take,
    and these prescribed actions are *unknown* to us before the model is optimized,
    we must encode into variables all the **potential actions we could take**.
  prefs: []
  type: TYPE_NORMAL
- en: But how do we define such potential actions? From our conceptual model, the
    generic ‚Äúdecision‚Äù we need to make is the ‚Äúorder in which to visit the sites‚Äù.
    This ‚Äúorder‚Äù refers to one path among all possible paths we could follow when
    doing a tour. The key idea is that a *path is made of a sequence of arcs connecting
    individual nodes (i.e., sites)*. Therefore, **deciding to do a particular path
    is actually deciding to traverse a particular sequence of arcs.** **These ‚Äúatomic
    decisions‚Äù about *whether or not* to traverse a particular arc connecting two
    sites** are the decisions we want to encode as variables.
  prefs: []
  type: TYPE_NORMAL
- en: '*‚ÄúWhether or not* to go from site A to site B‚Äù is clearly a **binary decision**:
    either I go, or I don‚Äôt. Because of this nature, the decision variables need to
    be binary (*i.e.*, taking only 0 or 1 as values) and are defined only for valid
    arcs (for which the derived ùî∏ comes in handy now). In mathematical terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/991fc19df0913c668de95e6e5728825e.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Expression 2.3.** Binary (go/no-go) decision variables, defined over possible
    arcs only.'
  prefs: []
  type: TYPE_NORMAL
- en: '**There is a unique decision variable for each possible arc (ùëñ, ùëó)**, but when
    the model is optimized, we will only be interested in **the variables that take
    the value 1, for they indicate what arcs should be traversed.** For example, if
    the variable ùõø·µ¢‚±º, with ùëñ=*hotel*, and ùëó=*Louvre*, takes the value 1, it means
    we should go from the hotel to the Louvre as part of our tour.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.3\. Defining the objective
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine we have 4 points, ùëé, ùëè, ùëê, ùëë, and we follow the path ùëé ‚Üí ùëè ‚Üí ùëê, in
    which point ùëë is not visited. Its total distance is the sum of the distances of
    its arcs: ùê∑·µÉ·µá + ùê∑·µá·∂ú. But, if we don‚Äôt know in advance what path we will follow,
    **how do we represent the total distance of this unknown path?**'
  prefs: []
  type: TYPE_NORMAL
- en: '*üí°* Precisely because the optimal path is unknown, **we need an expression
    that covers all possible paths**, but that reduces to the distance of the ‚Äúbest
    path‚Äù when the model is optimized.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: By exploiting the fact that any *traversed* arc (ùëñ, ùëó) will have ùõø·µ¢‚±º = 1, and
    any *untraversed* arc (ùëñ‚Ä≤,ùëó‚Ä≤) will have ùõø·µ¢·ëä‚±º·ëä = 0, we can create an expression
    that, once the variables have been decided, will **reduce to the total distance
    of the traversed path**. The way to do that is to **‚Äúadd up all potentialities‚Äù**,
    *i.e.*, to do the summation over all possible arc distances ùê∑·µ¢‚±º weighted by their
    binary ‚Äúarc variables‚Äù ùõø·µ¢‚±º, and let the 0‚Äôs and 1‚Äôs that those variables will
    take decide which distances remain (ùê∑·µ¢‚±º √ó 1 = ùê∑·µ¢‚±º) and which vanish (ùê∑·µ¢‚±º √ó 0 =
    0), in the expression for the total distance. This ‚Äúsummation of potentialities‚Äù
    represents the total distance the final tour will take, so it will be our objective
    (called ùëç) to be *minimized*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mathematically, this is expressed as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/83034bc0bd4482a82054bf782181fd43.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Expression 2.4.** Definition of the objective function in its raw version,
    using the primitive set ùïä only (left); and its simplified version, using the derived
    set ùî∏ (right).'
  prefs: []
  type: TYPE_NORMAL
- en: Note how the summation at the right has become simpler to read (and implement)
    thanks to the use of ùî∏, the domain (set of indices) for both ùê∑·µ¢‚±º and ùõø·µ¢‚±º.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that **the objective constitutes our definition of goodness**. Since
    we want to minimize it, a lower value is **better** than a higher value, so obviously,
    the minimum value is the **best** value. The values of the decision variables
    ùõø·µ¢‚±º that correspond to this ‚Äúbest‚Äù value of the objective constitute the (optimal)
    solution to the problem, and they will be found by the optimization process.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4\. Creating the constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From our conceptual model, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: All sites are visited.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each site is visited just once
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last site visited is the site we started from (we do a closed tour)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We realize that requirement (1) is already ‚Äúincluded‚Äù in requirement (2), for
    if *each* site is visited just once, that entails each site is visited, and thus
    *all sites* are visited. So we dismiss the need for a separate constraint for
    requirement (1) and focus on how to model requirement (2) as a constraint.
  prefs: []
  type: TYPE_NORMAL
- en: 'To say that ‚Äúeach site is visited just once‚Äù is the same as to say that ‚Äúeach
    site is *entered* and *exited* just once‚Äù. And that phrase, in turn, is equivalent
    to these two phrases together: ‚Äúeach site is *entered* just once‚Äù **and** ‚Äúeach
    site is *exited* just once‚Äù. Let‚Äôs model the ‚Äúphrases‚Äù separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Each site is *entered* just once**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/b77de8c8305e21df5c734eb15e98d8b5.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Expression 2.5.** Constraint set enforcing that each site is ‚Äúentered‚Äù just
    once.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It‚Äôs useful to *read* the whole expression from right to left. If you first
    see over which indices the constraint is defined, interpreting the meaning of
    the constraint definition on the left side will be easier. I would read this constraint
    aloud as:'
  prefs: []
  type: TYPE_NORMAL
- en: '*for each site ùëó belonging to the set of all sites ùïä, the sum of all potential
    arcs ùõø*·µ¢‚±º**arriving at *ùëó*** *must be equal to 1, meaning that* only one***incoming******arc***
    *must happen at ùëó. Or, more colloquially: each site must be* visited from *only
    one other site.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Each site is *exited* just once**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/19605aa22a16c154824f63abdd7e883e.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Expression 2.6.** Constraint set enforcing that each site is ‚Äúexited‚Äù just
    once.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I would read this constraint as:'
  prefs: []
  type: TYPE_NORMAL
- en: '*for each site ùëñ belonging to the set of all sites ùïä, the sum of all potential
    arcs ùõø*·µ¢‚±º**departing from *ùëñ*** *must be equal to 1, meaning that* only one***outgoing******arc***
    *must happen at ùëñ. Or, more colloquially: each site must* departure to *only one
    other site.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We‚Äôre left with only requirement (3). It states that the optimal path must
    finish at the same site it started from, or equivalently, that the path must be
    a tour (a closed loop). Here‚Äôs a possible line of reasoning one can have at first
    sight: ‚ÄúBecause we have already created constraints to enforce that each site
    is **both *entered* and *exited* once**, this implies that the resulting path
    must be closed, since it is impossible for any site to be a ‚Äúsink‚Äù (*i.e., a*
    site has one incoming arc but *no outgoing arcs*) or to be a ‚Äúsource‚Äù (*i.e.,*
    a site has an outgoing arc but *no incoming arcs*). Therefore, the previous two
    constraints, *presumably*, **force the final trajectory to be a closed loop‚Äù.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Is that line of reasoning correct?** Let‚Äôs take an experimental approach.
    Let‚Äôs assume this reasoning is correct, and try to solve the model as is now.
    When we look at the solution, we will see if it looks right or if something‚Äôs
    wrong. **If the results are wrong (or don‚Äôt make sense in any way), we can always
    go back and revise our logic** (something which in real-life projects happens
    all the time). **The implementation, solution, and ‚Äúexperimental validation‚Äù**
    is what it‚Äôs covered in our ‚Äú[next sprint](https://medium.com/@carlosjuribe/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c)‚Äù,
    where a Python model is created, solved, inspected, and re-formulated based on
    the results we get.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, we conclude here (*tentatively*) the ‚Äúmathematical model formulation‚Äù
    stage. Next stop: the ‚Äú**computer model** implementation‚Äù, carried out in [Implementing,
    solving, and visualizing the Traveling Salesman Problem with Python](https://medium.com/@carlosjuribe/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c):'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c?source=post_page-----bd6530c9c07--------------------------------)
    [## Implementing, solving and visualizing the Traveling Salesman Problem with
    Python'
  prefs: []
  type: TYPE_NORMAL
- en: Learn how to translate an optimization model from Math to Python, optimize it,
    and visualize the solution to gain quick‚Ä¶
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c?source=post_page-----bd6530c9c07--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: There will be more articles of more ‚Äúsprints‚Äù coming out, so if you‚Äôre eager
    to be my companion on this journey, stay tuned and **check the project timeline
    in section 3 of the** [**first article in this series**](https://medium.com/@carlosjuribe/plan-an-optimal-trip-for-your-next-holidays-with-the-help-of-operations-research-and-python-481b1ea38fef),
    to navigate to your desired sprint and follow the work being done there.
  prefs: []
  type: TYPE_NORMAL
- en: Also, feel free to follow me, ask me questions in the comments, **give me feedback**,
    or contact me on [LinkedIn](https://www.linkedin.com/in/carlosjuribe/).
  prefs: []
  type: TYPE_NORMAL
- en: Thanks for reading, and see you in the [next one](https://medium.com/@carlosjuribe/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c)!
    üìàüòä
  prefs: []
  type: TYPE_NORMAL
