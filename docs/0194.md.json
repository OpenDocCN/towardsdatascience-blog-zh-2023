["```py\nmodel = Sequential()\nmodel.add(LSTM(\n    256,\n    input_shape=(network_input.shape[1], network_input.shape[2]),\n    return_sequences=True\n))\nmodel.add(Dropout(0.3))\nmodel.add(LSTM(512, return_sequences=True))\nmodel.add(Dropout(0.3))\nmodel.add(LSTM(256))\nmodel.add(Dense(256))\nmodel.add(Dropout(0.3))\nmodel.add(Dense(n_vocab))\nmodel.add(Activation('softmax'))\nmodel.compile(loss='categorical_crossentropy', optimizer='rmsprop')\nmodel.fit(network_input, network_output, epochs=200, batch_size=128)\n```", "```py\nNOTE_TYPE = {\n            \"eighth\": 0.5,\n            \"quarter\": 1,\n            \"half\": 2,\n            \"16th\": 0.25\n        }\noffset = 0\noutput_notes = []\nfor pattern in prediction_output:\n    curr_type = numpy.random.choice(list(NOTE_TYPE.keys()), p=[0.65,0.05,0.05, 0.25])\n\n    # pattern is a chord\n    if ('.' in pattern) or pattern.isdigit():\n        notes_in_chord = pattern.split('.')\n        notes = []\n        for current_note in notes_in_chord:\n            new_note = note.Note(int(current_note))\n            new_note.storedInstrument = instrument.Piano()\n            notes.append(new_note)\n        new_chord = chord.Chord(notes, type=curr_type)\n        new_chord.offset = offset\n        output_notes.append(new_chord)\n    elif str(pattern).upper() == \"R\":\n        curr_type = '16th'\n        new_rest = note.Rest(type=curr_type)\n        new_rest.offset = offset\n        output_notes.append(new_rest)\n    # pattern is a note\n    else:\n        new_note = note.Note(pattern, type=curr_type)\n        new_note.offset = offset\n        new_note.storedInstrument = instrument.Piano()\n        output_notes.append(new_note)\n# increase offset each iteration so that notes do not stack\n    offset += NOTE_TYPE[curr_type]\nmidi_stream = stream.Stream(output_notes)\nmidi_stream.write('midi', fp='test_output.mid')\n```"]