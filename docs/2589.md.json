["```py\n!pip install torch_geometric\n```", "```py\nimport torch\nimport numpy as np\nimport networkx as nx\nimport matplotlib.pyplot as plt\n```", "```py\nfrom torch_geometric.datasets import KarateClub\n```", "```py\n# Import dataset from PyTorch Geometric\ndataset = KarateClub()# Print information\nprint(dataset)\nprint('------------')\nprint(f'Number of graphs: {len(dataset)}')\nprint(f'Number of features: {dataset.num_features}')\nprint(f'Number of classes: {dataset.num_classes}')\n```", "```py\nKarateClub()\n------------\nNumber of graphs: 1\nNumber of features: 34\nNumber of classes: 4\n```", "```py\n# Print first element\nprint(f'Graph: {dataset[0]}')\n```", "```py\nGraph: Data(x=[34, 34], edge_index=[2, 156], y=[34], train_mask=[34])\n```", "```py\ndata = dataset[0]\n```", "```py\nprint(f'x = {data.x.shape}')\nprint(data.x)\n```", "```py\nx = torch.Size([34, 34])\ntensor([[1., 0., 0.,  ..., 0., 0., 0.],\n        [0., 1., 0.,  ..., 0., 0., 0.],\n        [0., 0., 1.,  ..., 0., 0., 0.],\n        ...,\n        [0., 0., 0.,  ..., 1., 0., 0.],\n        [0., 0., 0.,  ..., 0., 1., 0.],\n        [0., 0., 0.,  ..., 0., 0., 1.]])\n```", "```py\nprint(f'edge_index = {data.edge_index.shape}')\nprint(data.edge_index)\n```", "```py\nedge_index = torch.Size([2, 156])\ntensor([[ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,\n          1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  3,\n          3,  3,  3,  3,  3,  4,  4,  4,  5,  5,  5,  5,  6,  6,  6,  6,  7,  7,\n          7,  7,  8,  8,  8,  8,  8,  9,  9, 10, 10, 10, 11, 12, 12, 13, 13, 13,\n         13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 19, 20, 20, 21,\n         21, 22, 22, 23, 23, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 27, 27,\n         27, 27, 28, 28, 28, 29, 29, 29, 29, 30, 30, 30, 30, 31, 31, 31, 31, 31,\n         31, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 33, 33, 33, 33, 33,\n         33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33],\n        [ 1,  2,  3,  4,  5,  6,  7,  8, 10, 11, 12, 13, 17, 19, 21, 31,  0,  2,\n          3,  7, 13, 17, 19, 21, 30,  0,  1,  3,  7,  8,  9, 13, 27, 28, 32,  0,\n          1,  2,  7, 12, 13,  0,  6, 10,  0,  6, 10, 16,  0,  4,  5, 16,  0,  1,\n          2,  3,  0,  2, 30, 32, 33,  2, 33,  0,  4,  5,  0,  0,  3,  0,  1,  2,\n          3, 33, 32, 33, 32, 33,  5,  6,  0,  1, 32, 33,  0,  1, 33, 32, 33,  0,\n          1, 32, 33, 25, 27, 29, 32, 33, 25, 27, 31, 23, 24, 31, 29, 33,  2, 23,\n         24, 33,  2, 31, 33, 23, 26, 32, 33,  1,  8, 32, 33,  0, 24, 25, 28, 32,\n         33,  2,  8, 14, 15, 18, 20, 22, 23, 29, 30, 31, 33,  8,  9, 13, 14, 15,\n         18, 19, 20, 22, 23, 26, 27, 28, 29, 30, 31, 32]])\n```", "```py\nfrom torch_geometric.utils import to_dense_adj\n```", "```py\nA = to_dense_adj(data.edge_index)[0].numpy().astype(int)\nprint(f'A = {A.shape}')\nprint(A)\n```", "```py\nA = (34, 34)\n[[0 1 1 ... 1 0 0]\n [1 0 1 ... 0 0 0]\n [1 1 0 ... 0 1 0]\n ...\n [1 0 0 ... 0 1 1]\n [0 0 1 ... 1 0 1]\n [0 0 0 ... 1 1 0]]\n```", "```py\nprint(f'y = {data.y.shape}')\nprint(data.y)\n```", "```py\ny = torch.Size([34])\ntensor([1, 1, 1, 1, 3, 3, 3, 1, 0, 1, 3, 1, 1, 1, 0, 0, 3, 1, 0, 1, 0, 1, 0, 0,\n        2, 2, 0, 0, 2, 0, 0, 2, 0, 0])\n```", "```py\nprint(f'train_mask = {data.train_mask.shape}')\nprint(data.train_mask)\n```", "```py\ntrain_mask = torch.Size([34])\ntensor([ True, False, False, False,  True, False, False, False,  True, False,\n        False, False, False, False, False, False, False, False, False, False,\n        False, False, False, False,  True, False, False, False, False, False,\n        False, False, False, False])\n```", "```py\nprint(f'Edges are directed: {data.is_directed()}')\nprint(f'Graph has isolated nodes: {data.has_isolated_nodes()}')\nprint(f'Graph has loops: {data.has_self_loops()}')\n```", "```py\nEdges are directed: False\nGraph has isolated nodes: False\nGraph has loops: False\n```", "```py\nfrom torch_geometric.utils import to_networkx\n```", "```py\nG = to_networkx(data, to_undirected=True)\nplt.figure(figsize=(12,12))\nplt.axis('off')\nnx.draw_networkx(G,\n                pos=nx.spring_layout(G, seed=0),\n                with_labels=True,\n                node_size=800,\n                node_color=data.y,\n                cmap=\"hsv\",\n                vmin=-2,\n                vmax=3,\n                width=0.8,\n                edge_color=\"grey\",\n                font_size=14\n                )\nplt.show()\n```", "```py\nfrom torch.nn import Linear\nfrom torch_geometric.nn import GCNConv \n```", "```py\nclass GCN(torch.nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.gcn = GCNConv(dataset.num_features, 3)\n        self.out = Linear(3, dataset.num_classes) def forward(self, x, edge_index):\n        h = self.gcn(x, edge_index).relu()\n        z = self.out(h)\n        return h, zmodel = GCN()\nprint(model)\n```", "```py\nGCN(\n  (gcn): GCNConv(34, 3)\n  (out): Linear(in_features=3, out_features=4, bias=True)\n)\n```", "```py\ncriterion = torch.nn.CrossEntropyLoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.02)\n```", "```py\n# Calculate accuracy\ndef accuracy(pred_y, y):\n    return (pred_y == y).sum() / len(y)# Data for animations\nembeddings = []\nlosses = []\naccuracies = []\noutputs = []# Training loop\nfor epoch in range(201):\n    # Clear gradients\n    optimizer.zero_grad() # Forward pass\n    h, z = model(data.x, data.edge_index) # Calculate loss function\n    loss = criterion(z, data.y) # Calculate accuracy\n    acc = accuracy(z.argmax(dim=1), data.y) # Compute gradients\n    loss.backward() # Tune parameters\n    optimizer.step() # Store data for animations\n    embeddings.append(h)\n    losses.append(loss)\n    accuracies.append(acc)\n    outputs.append(z.argmax(dim=1)) # Print metrics every 10 epochs\n    if epoch % 10 == 0:\n        print(f'Epoch {epoch:>3} | Loss: {loss:.2f} | Acc: {acc*100:.2f}%')\n```", "```py\nEpoch   0 | Loss: 1.40 | Acc: 41.18%\nEpoch  10 | Loss: 1.21 | Acc: 47.06%\nEpoch  20 | Loss: 1.02 | Acc: 67.65%\nEpoch  30 | Loss: 0.80 | Acc: 73.53%\nEpoch  40 | Loss: 0.59 | Acc: 73.53%\nEpoch  50 | Loss: 0.39 | Acc: 94.12%\nEpoch  60 | Loss: 0.23 | Acc: 97.06%\nEpoch  70 | Loss: 0.13 | Acc: 100.00%\nEpoch  80 | Loss: 0.07 | Acc: 100.00%\nEpoch  90 | Loss: 0.05 | Acc: 100.00%\nEpoch 100 | Loss: 0.03 | Acc: 100.00%\nEpoch 110 | Loss: 0.02 | Acc: 100.00%\nEpoch 120 | Loss: 0.02 | Acc: 100.00%\nEpoch 130 | Loss: 0.02 | Acc: 100.00%\nEpoch 140 | Loss: 0.01 | Acc: 100.00%\nEpoch 150 | Loss: 0.01 | Acc: 100.00%\nEpoch 160 | Loss: 0.01 | Acc: 100.00%\nEpoch 170 | Loss: 0.01 | Acc: 100.00%\nEpoch 180 | Loss: 0.01 | Acc: 100.00%\nEpoch 190 | Loss: 0.01 | Acc: 100.00%\nEpoch 200 | Loss: 0.01 | Acc: 100.00%\n```", "```py\n%%capture\nfrom IPython.display import HTML\nfrom matplotlib import animation\nplt.rcParams[\"animation.bitrate\"] = 3000\n```", "```py\ndef animate(i):\n    G = to_networkx(data, to_undirected=True)\n    nx.draw_networkx(G,\n                    pos=nx.spring_layout(G, seed=0),\n                    with_labels=True,\n                    node_size=800,\n                    node_color=outputs[i],\n                    cmap=\"hsv\",\n                    vmin=-2,\n                    vmax=3,\n                    width=0.8,\n                    edge_color=\"grey\",\n                    font_size=14\n                    )\n    plt.title(f'Epoch {i} | Loss: {losses[i]:.2f} | Acc: {accuracies[i]*100:.2f}%',\n              fontsize=18, pad=20)fig = plt.figure(figsize=(12, 12))\nplt.axis('off')anim = animation.FuncAnimation(fig, animate, \\\n            np.arange(0, 200, 10), interval=500, repeat=True)\nhtml = HTML(anim.to_html5_video())\ndisplay(html)\n```", "```py\n# Print embeddings\nprint(f'Final embeddings = {h.shape}')\nprint(h)\n```", "```py\nFinal embeddings = torch.Size([34, 3])\ntensor([[1.9099e+00, 2.3584e+00, 7.4027e-01],\n        [2.6203e+00, 2.7997e+00, 0.0000e+00],\n        [2.2567e+00, 2.2962e+00, 6.4663e-01],\n        [2.0802e+00, 2.8785e+00, 0.0000e+00],\n        [0.0000e+00, 0.0000e+00, 2.9694e+00],\n        [0.0000e+00, 0.0000e+00, 3.3817e+00],\n        [0.0000e+00, 1.5008e-04, 3.4246e+00],\n        [1.7593e+00, 2.4292e+00, 2.4551e-01],\n        [1.9757e+00, 6.1032e-01, 1.8986e+00],\n        [1.7770e+00, 1.9950e+00, 6.7018e-01],\n        [0.0000e+00, 1.1683e-04, 2.9738e+00],\n        [1.8988e+00, 2.0512e+00, 2.6225e-01],\n        [1.7081e+00, 2.3618e+00, 1.9609e-01],\n        [1.8303e+00, 2.1591e+00, 3.5906e-01],\n        [2.0755e+00, 2.7468e-01, 1.9804e+00],\n        [1.9676e+00, 3.7185e-01, 2.0011e+00],\n        [0.0000e+00, 0.0000e+00, 3.4787e+00],\n        [1.6945e+00, 2.0350e+00, 1.9789e-01],\n        [1.9808e+00, 3.2633e-01, 2.1349e+00],\n        [1.7846e+00, 1.9585e+00, 4.8021e-01],\n        [2.0420e+00, 2.7512e-01, 1.9810e+00],\n        [1.7665e+00, 2.1357e+00, 4.0325e-01],\n        [1.9870e+00, 3.3886e-01, 2.0421e+00],\n        [2.0614e+00, 5.1042e-01, 2.4872e+00],\n...\n        [2.1778e+00, 4.4730e-01, 2.0077e+00],\n        [3.8906e-02, 2.3443e+00, 1.9195e+00],\n        [3.0748e+00, 0.0000e+00, 3.0789e+00],\n        [3.4316e+00, 1.9716e-01, 2.5231e+00]], grad_fn=<ReluBackward0>)\n```", "```py\n# Get first embedding at epoch = 0\nembed = h.detach().cpu().numpy()\n```", "```py\nfig = plt.figure(figsize=(12, 12))\nax = fig.add_subplot(projection='3d')\nax.patch.set_alpha(0)\nplt.tick_params(left=False,\n                bottom=False,\n                labelleft=False,\n                labelbottom=False)\nax.scatter(embed[:, 0], embed[:, 1], embed[:, 2],\n           s=200, c=data.y, cmap=\"hsv\", vmin=-2, vmax=3)plt.show()\n```", "```py\n%%capture\n```", "```py\ndef animate(i):\n    embed = embeddings[i].detach().cpu().numpy()\n    ax.clear()\n    ax.scatter(embed[:, 0], embed[:, 1], embed[:, 2],\n           s=200, c=data.y, cmap=\"hsv\", vmin=-2, vmax=3)\n    plt.title(f'Epoch {i} | Loss: {losses[i]:.2f} | Acc: {accuracies[i]*100:.2f}%',\n              fontsize=18, pad=40)fig = plt.figure(figsize=(12, 12))\nplt.axis('off')\nax = fig.add_subplot(projection='3d')\nplt.tick_params(left=False,\n                bottom=False,\n                labelleft=False,\n                labelbottom=False)anim = animation.FuncAnimation(fig, animate, \\\n              np.arange(0, 200, 10), interval=800, repeat=True)\nhtml = HTML(anim.to_html5_video())\ndisplay(html)\n```"]