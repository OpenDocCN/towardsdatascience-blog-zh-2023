- en: 3D Data Processing with Open3D
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/3d-data-processing-with-open3d-c3062aadc72e?source=collection_archive---------1-----------------------#2023-05-08](https://towardsdatascience.com/3d-data-processing-with-open3d-c3062aadc72e?source=collection_archive---------1-----------------------#2023-05-08)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A quick walkthrough on processing 3D models with Python’s Open3D library (with
    an interactive Jupyter Notebook)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@prerak12.agarwal?source=post_page-----c3062aadc72e--------------------------------)[![Prerak
    Agarwal](../Images/631f00675c83812d32b983fb41b41edf.png)](https://medium.com/@prerak12.agarwal?source=post_page-----c3062aadc72e--------------------------------)[](https://towardsdatascience.com/?source=post_page-----c3062aadc72e--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----c3062aadc72e--------------------------------)
    [Prerak Agarwal](https://medium.com/@prerak12.agarwal?source=post_page-----c3062aadc72e--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F885f74d5a8c&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2F3d-data-processing-with-open3d-c3062aadc72e&user=Prerak+Agarwal&userId=885f74d5a8c&source=post_page-885f74d5a8c----c3062aadc72e---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----c3062aadc72e--------------------------------)
    ·13 min read·May 8, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fc3062aadc72e&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2F3d-data-processing-with-open3d-c3062aadc72e&user=Prerak+Agarwal&userId=885f74d5a8c&source=-----c3062aadc72e---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fc3062aadc72e&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2F3d-data-processing-with-open3d-c3062aadc72e&source=-----c3062aadc72e---------------------bookmark_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: In this article, I provide a quick walkthrough on how to explore, process and
    visualize 3D models using Python’s [Open3D](http://www.open3d.org/docs/release/index.html)
    library — an open-source library for 3D data processing.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d71b3cf9d03ac81a2e4fbbcc7784b555.png)'
  prefs: []
  type: TYPE_IMG
- en: A 3D model visualized using Open3D (original 3D model found [here](https://sketchfab.com/3d-models/tesla-model-s-plaid-9de8855fae324e6cbbb83c9b5288c961)).
  prefs: []
  type: TYPE_NORMAL
- en: You might find this walkthrough helpful if you’re thinking of processing 3D
    data/models for specific tasks, such as training an AI model for 3D model classification
    and/or segmentation. 3D models found on the internet (in datasets like [ShapeNet](https://shapenet.org/))
    are available in a variety of formats, such as *.obj*, *.glb*, *.gltf*, and so
    on. Using libraries like Open3D, such models can be easily processed, visualized
    and converted to other formats, like point clouds, which are easier to understand
    and interpret.
  prefs: []
  type: TYPE_NORMAL
- en: This article is also available as a Jupyter Notebook for those who wish to follow
    along and run the code locally. The zip file containing the Jupyter Notebook along
    with all the other data and assets can be downloaded from the link below.
  prefs: []
  type: TYPE_NORMAL
- en: '[## 3D Data Processing with Open3D.zip'
  prefs: []
  type: TYPE_NORMAL
- en: Zip file containing the Jupyter Notebook, the 3D model and all other necessary
    files.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: drive.google.com](https://drive.google.com/file/d/1290xG3_BEYn9WN9TwkYKMmNbNRsrWjGk/view?usp=share_link&source=post_page-----c3062aadc72e--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 'In this tutorial, I go through the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Loading and visualizing a 3D model as a *mesh***'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Converting the *mesh* to a *point cloud* by sampling points**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Removing hidden points from the *point cloud***'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Converting the *point cloud* to a dataframe**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Saving the *point cloud* and dataframe**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s start by importing all the necessary libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Loading and visualizing a 3D model as a *mesh*
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The 3D model can be read as a mesh by running the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To visualize the mesh, run the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The mesh should open up in a new window and should look like the image below
    (take note that the mesh opens up as a static image, and not like the animated
    one shown here). The mesh image can be rotated around as needed using the mouse
    pointer.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/70991296dafd91cf39eca3039cabb112.png)'
  prefs: []
  type: TYPE_IMG
- en: 3D model visualized as a mesh (**before** estimation of surface normals).
  prefs: []
  type: TYPE_NORMAL
- en: As seen above, the car mesh does not appear like a typical 3D model, and is
    painted in a uniform grey colour. This is because the mesh does not have any information
    about *normals* for the vertices and the surfaces in the 3D model.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are *normals*?** — The normal vector to a surface at a given point is
    a vector which is perpendicular to the surface at that point. The normal vector
    is often simply called the “*normal*”. To read more on this topic, you can refer
    to these two links: [Normal Vector](https://mathworld.wolfram.com/NormalVector.html)
    and [Estimating Surface Normals in a PointCloud](https://pcl.readthedocs.io/en/latest/normal_estimation.html#).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *normals* for the 3D mesh above can be estimated by running the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once visualized, the mesh should now appear as shown in the image below. After
    computing the *normals*, the car renders properly and looks like a 3D model.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4118a351aecbd1187a8df69c2276047e.png)'
  prefs: []
  type: TYPE_IMG
- en: 3D model visualized as a mesh (**after** estimation of surface normals).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now create a XYZ coordinate frame to understand the orientation of this
    car model in the Euclidean space. The XYZ coordinate frame can be overlaid on
    the 3D mesh above and visualized by running the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/04e234bb2232060711c09961583c0ff9.png)'
  prefs: []
  type: TYPE_IMG
- en: '3D mesh visualized with the XYZ coordinate frame. X-axis: Red arrow, Y-axis:
    Green arrow, Z-axis: Blue arrow [Easy way to remember — XYZ::RGB]'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the above visualization, we see that this car mesh is oriented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Origin** of XYZ axes : **At the volumetric center** of the car model *(not
    seen in the image above as it is inside the car mesh)*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**X-axis** (Red arrow) : Along the **length dimension** of the car with positive
    X-axis pointing towards the hood of the car *(not seen in the image above as it
    is inside the car mesh)*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Y-axis** (Green arrow) : Along the **height dimension** of the car with the
    positive Y-axis pointing towards the roof of the car.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Z-axis** (Blue arrow) : Along the **width dimension** of the car with the
    positive Z-axis pointing towards the right side of the car.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us now take a look at what is inside this car model. To do this, we will
    crop the mesh in the Z-axis and remove the right half of the car (positive Z-axis).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/c66e1e5fba2f67f19c913c3c686aee6e.png)'
  prefs: []
  type: TYPE_IMG
- en: 3D mesh cropped in Z-axis with the right half of the car removed (positive Z-axis).
    The cropped mesh shows the detailed interior in this 3D car model.
  prefs: []
  type: TYPE_NORMAL
- en: From the above visualization, we see that this car model has a detailed interior.
    Now that we have seen what is inside this 3D mesh, we can convert it to a point
    cloud before removing the “hidden” points which belong to the interior of the
    car.
  prefs: []
  type: TYPE_NORMAL
- en: Converting the *mesh* to a *point cloud* by sampling points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Converting the mesh to a point cloud can be easily done in Open3D by defining
    the number of points we wish to sample from the mesh.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/3489992121f80d4da3c30e9043befd92.png)'
  prefs: []
  type: TYPE_IMG
- en: 3D point cloud created by sampling 100,000 points uniformly from the 3D mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Take note that the colours in the point cloud above only indicate the position
    of the points along the Z-axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to crop the point cloud exactly like we did for the mesh above,
    this is what it would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/656d506ef643e3a682cf68cb60597adf.png)'
  prefs: []
  type: TYPE_IMG
- en: 3D point cloud cropped in Z-axis with the right half of the car removed (positive
    Z-axis). Like the cropped mesh above, the cropped point cloud also shows the detailed
    interior in this 3D car model.
  prefs: []
  type: TYPE_NORMAL
- en: We see in this visualization of the cropped point cloud that it also contains
    points which belong to the interior of the car model. This is expected as this
    point cloud was created by uniformly sampling points from the entire mesh. In
    the next section, we will remove these “hidden” points which belong to the interior
    of the car and are not on the outer surface of the point cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Removing hidden points from the *point cloud*
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine yourself pointing a light on the right side of the car model. All the
    points that fall on the right outer surface of the 3D model would be illuminated,
    while all the other points in the point cloud would not.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b9c54a72522967a3ed2ccfb7c22c4579.png)'
  prefs: []
  type: TYPE_IMG
- en: Illustration showing how Open3D’s Hidden Point Removal works on the point cloud
    from a given viewpoint. All the illuminated points are considered “visible”, while
    all other points are considered “hidden”.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now label these illuminated points as “visible” and all the non-illuminated
    points as “hidden”. These “hidden” points would also include all the points that
    belong to the interior of the car.
  prefs: []
  type: TYPE_NORMAL
- en: 'This operation is known as *Hidden Point Removal* in Open3D. In order to perform
    this operation on the point cloud using Open3D, run the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Using the above output list of indexes of points that are visible, we can colour
    the visible and hidden points in different colours before visualizing the point
    cloud.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/f390adb4db7eae032618205b1879c1a0.png)'
  prefs: []
  type: TYPE_IMG
- en: Point cloud after the hidden point removal operation from the camera viewpoint
    shown in the illustration above. The “visible” points are in blue while the “hidden”
    points are in red.
  prefs: []
  type: TYPE_NORMAL
- en: From the visualization above, we see how the hidden point removal operation
    works from a given camera viewpoint. The operation eliminates all the points in
    the background that are occluded by the points in the foreground from a given
    camera viewpoint.
  prefs: []
  type: TYPE_NORMAL
- en: To understand this better, we could repeat the same operation again, but this
    time after rotating the point cloud slightly. **Effectively, we’re trying to change
    the viewpoint here. But instead of changing it by re-defining the camera parameters,
    we will be rotating the point cloud itself.**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/78ac4406b6279930d1595b81f570d332.png)'
  prefs: []
  type: TYPE_IMG
- en: 3D point cloud **rotated about the X-axis by 90 degrees**. Notice that now,
    unlike before, the **Y-axis** (Green arrow) is running along the **width dimension**
    of the car, and the **Z-axis** (Blue arrow) is running along the **height dimension**
    of the car. There is no change in the X-axis (Red arrow) which is still running
    along the length dimension of the car.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7c39065ff5c12fb88d444f91e97b3920.png)'
  prefs: []
  type: TYPE_IMG
- en: Illustration showing how the hidden point removal operation works on the rotated
    point cloud from the same given viewpoint as earlier. As explained earlier, all
    the illuminated points are considered “visible”, while all other points are considered
    “hidden”.
  prefs: []
  type: TYPE_NORMAL
- en: By repeating the same process again with the rotated car model, we would see
    that this time all the points that fall on the upper outer surface of the 3D model
    (roof of the car) would get illuminated, while all the other points in the point
    cloud would not.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can repeat the hidden point removal operation with the rotated point cloud
    by running the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/eb03d7895f7075a8b11f7c162fe8a8d5.png)'
  prefs: []
  type: TYPE_IMG
- en: Rotated point cloud after the hidden point removal operation from the camera
    viewpoint shown in the illustration above. Again, the “visible” points are in
    blue while the “hidden” points are in red.
  prefs: []
  type: TYPE_NORMAL
- en: 'The above visualization of the rotated point cloud clearly illustrates how
    the hidden point removal operation works. So now, in order to remove *all* the
    “hidden” points from this car point cloud, we can **perform this hidden point
    removal operation *sequentially* by rotating the point cloud slightly about all
    the three axes from -90 to +90 degrees.** After each hidden point removal operation,
    we can aggregate the output list of indexes of points. **After all the hidden
    point removal operations, the aggregated list of indexes of points will contain
    all the points that are not hidden (ie., points that are on the outer surface
    of the point cloud).** The following code performs this sequential hidden point
    removal operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/43f28acf371940f0bdaa0586e51c7fff.png)'
  prefs: []
  type: TYPE_IMG
- en: Point cloud after all the sequential hidden point removal operations from the
    same camera viewpoint. The aggregated “visible” points (ie., points on the outer
    surface of the point cloud) are in blue while the “hidden” points (ie., points
    **not** on the outer surface of the point cloud) are in red.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s crop the point cloud again to have a look at the points which belong to
    the interior of the car.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/df3b98c5c29de1be0d3e19aa573568da.png)'
  prefs: []
  type: TYPE_IMG
- en: Cropped point cloud after all the sequential hidden point removal operations
    showing all the “hidden” points in red that belong to the interior of the 3D car
    model.
  prefs: []
  type: TYPE_NORMAL
- en: From the above visualization of the cropped point cloud after the hidden point
    removal operation, we see that all the “hidden” points which belong to the interior
    of the car model (red) are now separated from the “visible” points which are on
    the outer surface of the point cloud (blue).
  prefs: []
  type: TYPE_NORMAL
- en: Converting the *point cloud* to a dataframe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As one might expect, the position of each point in the point cloud can be defined
    by three numerical values — the *X, Y & Z coordinates*. However, recall that in
    the section above, we also estimated the surface normals for each point in the
    3D mesh. As we sampled points from this mesh to create the point cloud, each point
    in the point cloud also contains three additional attributes related to these
    surface normals — the *normal unit vector coordinates in the X, Y & Z directions*.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in order to convert the point cloud to a dataframe, **each point in the
    point cloud can be represented in a single row by the following seven attribute
    columns**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**X coordinate** (*float*)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Y coordinate** (*float*)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Z coordinate** (*float*)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Normal vector coordinate in X direction** (*float*)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Normal vector coordinate in Y direction** (*float*)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Normal vector coordinate in Z direction** (*float*)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Point visible** (*boolean True or False*)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The point cloud can be converted to a dataframe by running the following lines
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This would return a dataframe as shown below, where each point is a row represented
    by the seven attribute columns explained above.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8c803e2c89581a325d6cfcda32e90ab1.png)'
  prefs: []
  type: TYPE_IMG
- en: 3D point cloud converted to a dataframe.
  prefs: []
  type: TYPE_NORMAL
- en: Saving the *point cloud* and dataframe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The point clouds (before and after hidden point removal) and the dataframe
    can now be saved by running the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/ac1332b3826c2f4143e32746af5f5131.png)'
  prefs: []
  type: TYPE_IMG
- en: '3D model (top: whole, bottom: cropped) visualized as 1\. a mesh, 2\. a point
    cloud & 3\. a point cloud after hidden point removal.'
  prefs: []
  type: TYPE_NORMAL
- en: And that’s it! Hope this walkthrough gave you a bit of clarity on how to process
    3D data in Python. Do let me know if you have any questions or any suggestions
    on how I could have approached these tasks in a better way. Reach out to me if
    you have any cool ideas for applications which require the use of 3D data — always
    happy to connect and share similar interests! Also, feel free to connect with
    me on [LinkedIn](https://www.linkedin.com/in/prerakagarwal/).
  prefs: []
  type: TYPE_NORMAL
- en: The 3D car model used in this walkthrough has been modified slightly from the
    original file to fit the purposes of this exercise. Credit to the original creator
    — *“Tesla Model S Plaid” (*[*https://skfb.ly/oEqT9*](https://skfb.ly/oEqT9)*)
    by ValentunW is licensed under Creative Commons Attribution (*[*http://creativecommons.org/licenses/by/4.0/*](http://creativecommons.org/licenses/by/4.0/)*).*
  prefs: []
  type: TYPE_NORMAL
