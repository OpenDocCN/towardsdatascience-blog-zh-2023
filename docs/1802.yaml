- en: How to Make Your Python Packages Really Fast with Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/how-to-make-your-python-packages-really-fast-with-rust-91a9bebacbc2?source=collection_archive---------2-----------------------#2023-05-31](https://towardsdatascience.com/how-to-make-your-python-packages-really-fast-with-rust-91a9bebacbc2?source=collection_archive---------2-----------------------#2023-05-31)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Goodbye, slow code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.isaacharrisholt.com/?source=post_page-----91a9bebacbc2--------------------------------)[![Isaac
    Harris-Holt](../Images/723dfa962a9eb9b9d4fcc99502a7a294.png)](https://medium.isaacharrisholt.com/?source=post_page-----91a9bebacbc2--------------------------------)[](https://towardsdatascience.com/?source=post_page-----91a9bebacbc2--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----91a9bebacbc2--------------------------------)
    [Isaac Harris-Holt](https://medium.isaacharrisholt.com/?source=post_page-----91a9bebacbc2--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fae5d6a2a28aa&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-to-make-your-python-packages-really-fast-with-rust-91a9bebacbc2&user=Isaac+Harris-Holt&userId=ae5d6a2a28aa&source=post_page-ae5d6a2a28aa----91a9bebacbc2---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----91a9bebacbc2--------------------------------)
    ·6 min read·May 31, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F91a9bebacbc2&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-to-make-your-python-packages-really-fast-with-rust-91a9bebacbc2&user=Isaac+Harris-Holt&userId=ae5d6a2a28aa&source=-----91a9bebacbc2---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F91a9bebacbc2&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-to-make-your-python-packages-really-fast-with-rust-91a9bebacbc2&source=-----91a9bebacbc2---------------------bookmark_footer-----------)![](../Images/aa4989d4b59e24e5610fb197df1de377.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Photo by [Chris Liverani](https://unsplash.com/@chrisliverani?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Python is… slow. This is not a revelation. Lots of dynamic languages are. In
    fact, Python is so slow that many authors of performance-critical Python packages
    have turned to another language — C. But C is not fun, and C has enough foot guns
    to cripple a centipede.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Rust is a memory-efficient language with no runtime or garbage collector. It’s
    incredibly fast, super reliable, and has a really great community around it. Oh,
    and it’s also *super easy* to embed into your Python code thanks to excellent
    tools like PyO3 and maturin.
  prefs: []
  type: TYPE_NORMAL
- en: Sound exciting? Great! Because I’m about to show you how to create a Python
    package in Rust step-by-step. And if you don’t know any Rust, don’t worry — we’re
    not going to be doing anything too crazy, so you should still be able to follow
    along. Are you ready? Let’s oxidise this snake.
  prefs: []
  type: TYPE_NORMAL
- en: Pre-requisites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we get started, you’re going to need to install Rust on your machine.
    You can do that by heading to [rustup.rs](https://rustup.rs/) and following the
    instructions there. I would also recommend creating a virtual environment that
    you can use for testing your Rust package.
  prefs: []
  type: TYPE_NORMAL
- en: Script overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here’s a script that, given a number n, will calculate the nth Fibonacci number
    100 times and time how long it takes to do so.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very naive, totally unoptimised function, and there are plenty of
    ways to make this faster using Python alone, but I’m not going to be going into
    those today. Instead, we’re going to take this code and use it to create a Python
    package in Rust
  prefs: []
  type: TYPE_NORMAL
- en: Maturin setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step is to install [maturin](https://www.maturin.rs/), which is a
    build system for building and publishing Rust crates as Python packages. You can
    do that with `pip install maturin`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, create a directory for your package. I’ve called mine `fibbers`. The final
    setup step is to run `maturin init` from your new directory. At this point, you’ll
    be prompted to select which Rust bindings to use. Select `pyo3`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b909e60c1bf09cc8fdeed5803878c8b8.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you take a look at your `fibbers` directory, you’ll see a few files.
    Maturin has created some config files for us, namely a `Cargo.toml` and `pyproject.toml`.
    The `Cargo.toml` file is configuration for Rust’s build tool, `cargo`, and contains
    some default metadata about the package, some build options and a dependency for
    `pyo3`. The `pyproject.toml` file is fairly standard, but it’s set to use `maturin`
    as the build backend.
  prefs: []
  type: TYPE_NORMAL
- en: Maturin will also create a GitHub Actions workflow for releasing your package.
    It’s a small thing, but makes life *so* much easier when you’re maintaining an
    open source project. The file we mostly care about, however, is the `lib.rs` file
    in the `src` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an overview of the resulting file structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Writing the Rust
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Maturin has already created the scaffold of a Python module for us using the
    PyO3 bindings we mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The main parts of this code are this `sum_as_string` function, which is marked
    with the `pyfunction` attribute, and the `fibbers` function, which represents
    our Python module. All the `fibbers` function is really doing is registering our
    `sum_as_string` function with our `fibbers` module.
  prefs: []
  type: TYPE_NORMAL
- en: If we installed this now, we’d be able to call `fibbers.sum_as_string()` from
    Python, and it would all work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: However, what I’m going to do first is replace the `sum_as_string` function
    with our `fib` function.
  prefs: []
  type: TYPE_NORMAL
- en: This has exactly the same implementation as the Python we wrote earlier — it
    takes in a positive unsigned integer n and returns the nth Fibonacci number. I’ve
    also registered our new function with the `fibbers` module, so we’re good to go!
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarking our function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To install our `fibbers` package, all we have to do is run `maturin develop`in
    our terminal. This will download and compile our Rust package and install it into
    our virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1403ae627ee0b4a01ea8ad0968f0b11a.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: Now, back in our `fib.py` file, we can import `fibbers`, print out the result
    of `fibbers.fib()` and then add a `timeit` case for our Rust implementation.
  prefs: []
  type: TYPE_NORMAL
- en: If we run this now for the 10th Fibonacci number, you can see that our Rust
    function is about 5 times faster than Python, despite the fact we’re using an
    identical implementation!
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/42faca074401862fe3478468a5e55196.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: If we run for the 20th and 30th fib numbers, we can see that Rust gets up to
    being about 15 times faster than Python.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/dd9ba721121d38effa68225d2e8f6e41.png)'
  prefs: []
  type: TYPE_IMG
- en: 20th fib number results. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/56c728d6b3607441c5f57b78a9dd71dd.png)'
  prefs: []
  type: TYPE_IMG
- en: 30th fib number results. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: But what if I told you that we’re not even at maximum speed?
  prefs: []
  type: TYPE_NORMAL
- en: You see, by default, `maturin develop`will build the dev version of your Rust
    crate, which will forego many optimisations to reduce compile time, meaning the
    program isn’t running as fast as it could. If we head back into our `fibbers`
    directory and run `maturin develop`again, but this time with the `--release` flag,
    we’ll get the optimised production-ready version of our binary.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7f723ac21a572c815c7dbd8c320a9f7a.png)'
  prefs: []
  type: TYPE_IMG
- en: If we now benchmark our 30th fib number, we see that Rust now gives us a whopping
    *40 times* speed improvement over Python!
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f75f3a616edc770b5df0868e54190488.png)'
  prefs: []
  type: TYPE_IMG
- en: 30th fib number, optimised. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: Rust limitations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: However, we do have a problem with our Rust implementation. If we try to get
    the 50th Fibonacci number using `fibbers.fib()`, you’ll see that we actually hit
    an overflow error and get a different answer to Python.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8a5ced8efee69a67b0329f1a8c5e7c69.png)'
  prefs: []
  type: TYPE_IMG
- en: Rust experiences integer overflow. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: This is because, unlike Python, Rust has fixed-size integers, and a 32-bit integer
    isn’t large enough to hold our 50th Fibonacci number.
  prefs: []
  type: TYPE_NORMAL
- en: We can get around this by changing the type in our Rust function from `u32`
    to `u64`, but that will use more memory and might not be supported on every machine.
    We could also solve it by using a crate like [num_bigint](https://docs.rs/num-bigint/latest/num_bigint/),
    but that’s outside the scope of this article.
  prefs: []
  type: TYPE_NORMAL
- en: Another small limitation is that there’s some overhead to using the PyO3 bindings.
    You can see that here where I’m just getting the 1st Fibonacci number, and Python
    is actually faster than Rust thanks to this overhead.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/21a63bceb9f6e6ef68242a6c1d67e854.png)'
  prefs: []
  type: TYPE_IMG
- en: Python is faster for n=1\. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: Things to remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The numbers in this article were not recorded on a perfect machine. The benchmarks
    were run on my personal machine, and may not reflect real-world problems. Please
    take care with micro-benchmarks like this one in general, as they are often imperfect
    and emulate many aspects of real world programs.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you’ve found this article helpful, and that it’s encouraged you to try
    rewriting performance-critical parts of your Python code in Rust. Be wary that
    while Rust can speed up a lot of things, it won’t provide much advantage if most
    of your CPU cycles are spent on syscalls or network IO, as those slowdowns are
    outside the scope of your program.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’d like to see more complete examples of Python packages written in Rust,
    please check out the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[isaacharrisholt/uuidt](https://github.com/isaacharrisholt/uuidt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[pydantic/pydantic-core](https://github.com/pydantic/pydantic-core)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[pola-rs/polars](https://github.com/pola-rs/polars/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This article was based on the script for this video of mine, so if you’re more
    of a visual learner, or would like quick reference material, feel free to check
    it out:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or check out the code on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://github.com/isaacharrisholt/youtube/tree/main/010-creating-python-packages-with-rust?source=post_page-----91a9bebacbc2--------------------------------)
    [## youtube/010-creating-python-packages-with-rust at main · isaacharrisholt/youtube'
  prefs: []
  type: TYPE_NORMAL
- en: Everyone knows that program speed isn't Python's strong point. That's why so
    many number-crunching data science…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: github.com](https://github.com/isaacharrisholt/youtube/tree/main/010-creating-python-packages-with-rust?source=post_page-----91a9bebacbc2--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Stay fast!
  prefs: []
  type: TYPE_NORMAL
- en: Isaac
  prefs: []
  type: TYPE_NORMAL
