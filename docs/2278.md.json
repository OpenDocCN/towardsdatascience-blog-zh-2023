["```py\nimport pandas as pd\n\nprint(f\"version pandas: {pd.__version__}\")\n\nDATA_FOLDER = (\"https://raw.githubusercontent.com/carlosjuribe/\"\n               \"traveling-tourist-problem/main/data\")\nFILE_LOCATION_HOTEL = \"location_hotel.csv\"\nFILE_LOCATION_SITES = \"sites_coordinates.csv\"\n\ndf_sites = pd.concat([\n    pd.read_csv(f\"{DATA_FOLDER}/{FILE_LOCATION_SITES}\", index_col='site'),\n    pd.read_csv(f\"{DATA_FOLDER}/{FILE_LOCATION_HOTEL}\", index_col='site')\n])\n\ndisplay(df_sites)\n```", "```py\nconda install -y -c conda-forge geopy=2.3.0\n```", "```py\nfrom geopy.distance import geodesic\n\ndef ellipsoidal_distance(p1, p2) -> float:\n    \"\"\" Calculate distance (in meters) between p1 and p2, where \n    each point is represented as a tuple (lat, lon) \"\"\"\n    return geodesic(p1, p2).meters\n```", "```py\np1 = df_sites.loc['Tour Eiffel']\np2 = df_sites.loc['Louvre']\n\nellipsoidal_distance(p1, p2)  # output: 3173.119635531859\n```", "```py\nellipsoidal_distance(\n    df_sites.loc['Tour Eiffel'],\n    df_sites.loc['Port de Suffren']\n)  # output: 328.3147101635456\n```", "```py\ndef compute_distance_matrix(df_sites, dist_metric=ellipsoidal_distance):\n    \"\"\" Creates an N x N distance matrix from a dataframe of N locations \n    with a latitute column and a longitude column \"\"\"\n    df_dist_matrix = pd.DataFrame(index=df_sites.index, \n                                  columns=df_sites.index)\n\n    for orig, orig_loc in df_sites.iterrows():  # for each origin\n        for dest, dest_loc in df_sites.iterrows():  # for each destination\n            df_dist_matrix.at[orig, dest] = dist_metric(orig_loc, dest_loc)\n    return df_dist_matrix\n\ndf_distances = compute_distance_matrix(df_sites)\n\ndisplay(df_distances)\n```", "```py\nfrom typing import Tuple\n\nimport pandas as pd\nfrom geopy.distance import geodesic\n\nclass GeoAnalyzer:\n    \"\"\" Utils for geolocation information and processing \"\"\"  \n    _GeoPoint = Tuple[float, float]\n\n    def __init__(self):\n        \"\"\" Use method `add_locations` to store some locations inside \n        and start using the geo-utilities \"\"\"\n        self._df_locations = pd.DataFrame(columns=['latitude', 'longitude'])\n\n    #####################   distances   #####################\n    @staticmethod\n    def ellipsoidal_distance(point1: _GeoPoint, point2: _GeoPoint) -> float:\n        \"\"\" Calculate ellipsoidal distance (in meters) between point1 \n        and point2 where each point is represented as a tuple (lat, lon)\n        \"\"\"\n        return geodesic(point1, point2).meters\n    #########################################################\n\n    @property\n    def locations(self):\n        return self._df_locations\n\n    @property\n    def num_locations(self):\n        return len(self._df_locations)\n\n    def add_locations(self, df_locations: pd.DataFrame):\n        \"\"\" Geo-location data needed for analysis.\n        Parameters\n        ----------\n        df_locations : pd.DataFrame\n            Dataframe of geographical coordinates with the first column \n            named 'latitude' and the second column named 'longitude'\n        \"\"\"\n        self._name_index = df_locations.index.name\n        df_updated = pd.concat([self._df_locations, df_locations.copy()])\n        # drop duplicates just in case the user adds repeated locations\n        self._df_locations = df_updated.drop_duplicates()\n\n    def get_distance_matrix(self, precision: int = 4) -> pd.DataFrame:\n        \"\"\" Computes the distance matrix as a dataframe based on the \n        provided location data \"\"\"\n        df_locations = self._df_locations\n        dist_metric = self.ellipsoidal_distance  # only distance available\n\n        # initialize matrix df\n        df_dist_matrix = pd.DataFrame(index=df_locations.index, \n                                      columns=df_locations.index)\n        # for each origin and destination pair, compute distance\n        for orig, orig_loc in df_locations.iterrows():\n            for dest, dest_loc in df_locations.iterrows():\n                distance = round(dist_metric(orig_loc, dest_loc), precision)\n                df_dist_matrix.at[orig, dest] = distance\n\n        # a bit of metadata doesn't hurt\n        df_dist_matrix.distance_metric = dist_metric.__name__\n        df_dist_matrix.index.name = self._name_index\n        return df_dist_matrix    \n\n    def __repr__(self):\n        \"\"\" Display number of currently considered locations \"\"\"\n        return f\"{self.__class__.__name__}(n_locs={self.num_locations})\"\n```", "```py\ngeo_analyzer = GeoAnalyzer()\ngeo_analyzer.add_locations(df_sites)\n```", "```py\ndisplay(geo_analyzer)\ndisplay(geo_analyzer.locations)\n```", "```py\ndf_distances = geo_analyzer.get_distance_matrix()\n\ndisplay(df_distances)\n```", "```py\nprint(f\"Distance metric used: {df_distances.distance_metric}\")\n# [Out]: Distance metric used: ellipsoidal_distance\n```"]