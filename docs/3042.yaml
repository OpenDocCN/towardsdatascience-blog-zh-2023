- en: 'Advanced Python: Metaclasses'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/advanced-python-metaclasses-e32d46e0ebe3?source=collection_archive---------1-----------------------#2023-10-06](https://towardsdatascience.com/advanced-python-metaclasses-e32d46e0ebe3?source=collection_archive---------1-----------------------#2023-10-06)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A brief introduction to Python class object and how it is created
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@ilija.lazarevic?source=post_page-----e32d46e0ebe3--------------------------------)[![Ilija
    Lazarevic](../Images/4a0d84af6d8fa97705ee35444d319b07.png)](https://medium.com/@ilija.lazarevic?source=post_page-----e32d46e0ebe3--------------------------------)[](https://towardsdatascience.com/?source=post_page-----e32d46e0ebe3--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----e32d46e0ebe3--------------------------------)
    [Ilija Lazarevic](https://medium.com/@ilija.lazarevic?source=post_page-----e32d46e0ebe3--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fe73ea2eae8e6&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fadvanced-python-metaclasses-e32d46e0ebe3&user=Ilija+Lazarevic&userId=e73ea2eae8e6&source=post_page-e73ea2eae8e6----e32d46e0ebe3---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----e32d46e0ebe3--------------------------------)
    ·8 min read·Oct 6, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fe32d46e0ebe3&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fadvanced-python-metaclasses-e32d46e0ebe3&user=Ilija+Lazarevic&userId=e73ea2eae8e6&source=-----e32d46e0ebe3---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fe32d46e0ebe3&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fadvanced-python-metaclasses-e32d46e0ebe3&source=-----e32d46e0ebe3---------------------bookmark_footer-----------)![](../Images/e409921158233f95efc4e3cb4cd1ba6f.png)'
  prefs: []
  type: TYPE_NORMAL
- en: As Atlas is to the heavens, metaclasses are to classes. Photo by [Alexander
    Nikitenko](https://unsplash.com/@quintonik?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
    on [Unsplash](https://unsplash.com/photos/H6obC_biCSk?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
  prefs: []
  type: TYPE_NORMAL
- en: This article continues the Advanced Python series (previous [article](https://medium.com/towards-data-science/advanced-python-functions-3be6810f92d1)
    on functions in Python). This time, I cover an introduction to metaclasses. The
    subject is rather advanced because there is rarely a need for the engineer to
    implement custom metaclasses. However, it is one of the most important constructs
    and mechanisms that every knowledgeable Python developer should know about, mainly
    because it enables the OOP paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: After getting the idea behind metaclasses and how class objects are created,
    you will be able to continue learning the OOP principles of encapsulation, abstraction,
    inheritance, and polymorphism. Then you will be able to understand how to apply
    all of it through numerous design patterns guided by some of the principles in
    software engineering (for example, *SOLID*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s start with this seemingly trivial example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Back in the days when you learned about object-oriented programming, you most
    probably came across a general idea that describes what classes and objects are,
    and it goes like this:'
  prefs: []
  type: TYPE_NORMAL
- en: “Class is like a cookie mold. And objects are cookies molded by it”.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is a very intuitive explanation and conveys the idea rather clearly. Having
    said that, our example defines two templates with little or no functionalities,
    but they work. You can play with defining the `__init__` method, set some object
    attributes, and make it more usable.
  prefs: []
  type: TYPE_NORMAL
- en: However, what is interesting **in Python** is that **even though a class is
    a “template” that is used to create objects from it, it is also an object itself.**
    Everyone learning OOP in Python would quickly go over this statement, not really
    thinking in depth. Everything in Python is an object, so what? But once you start
    thinking about this, a lot of questions pop up, and interesting Python intricacies
    unravel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before I start asking these questions for you, let’s remember that **in Python,
    everything is an object**. And I mean everything. This is probably something you
    already picked up, even if you are a newbie. The next example shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on these examples, here are some questions that you should ask yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: If a class is an object, when is it created?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Who creates class objects?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If class is an object, how come I’m able to call it when instantiating an object?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class object creation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is widely known as an interpreted language. This means there is an interpreter
    (program or process) that goes line by line and tries to translate it to machine
    code. This is opposed to compiled programming languages like C, where programming
    code is translated into machine code before you run it. This is a very simplified
    view. To be more precise, Python is both compiled and interpreted, but this is
    a subject for another time. What is important for our example is that the interpreter
    goes through the class definition, and once the class code block is finished,
    the class object is created. From then on, you are able to instantiate objects
    from it. You have to do this explicitly, of course, even though class objects
    are instantiated implicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what “process” is triggered when the interpreter finishes reading the class
    code block? We could go directly to details, but one chart speaks a thousand words:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8b234379df93408228ea4868c29df990.png)'
  prefs: []
  type: TYPE_IMG
- en: How objects, classes and metaclasses are related to each other. Image by Ilija
    Lazarevic.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are not aware, Python has `type` functions that can be used for our
    purpose(s) now. By calling `type` with object as an argument, you will get the
    object’s type. How ingenious! Take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `type` call in the example makes sense. `child` is of type `Child`. We used
    a class object to create it. So in some way, you can think of `type(child)` giving
    you the name of its “creator”. And in a way, the `Child` class is its creator
    because you called it to create a new instance. But what happens when you try
    to get the “creator” of the class object, `type(Child)`? You get the `type`. To
    sum it up, **an object is an instance of a class, and a class is an instance of
    a type**. By now, you may be wondering how a class is an instance of a function,
    and the answer is that`type` is both a function and a class. This is intentionally
    left as it is because of backward compatibility back in the old days.
  prefs: []
  type: TYPE_NORMAL
- en: What will make your head spin is the name we have for the class that is used
    to create a class object. It is called a **metaclass.** And here it is important
    to make a distinction between inheritance from the perspective of the object-oriented
    paradigm and the mechanisms of a language that enable you to practice this paradigm.
    Metaclasses provide this mechanism. What can be even more confusing is that metaclasses
    are able to inherit parent classes just like regular ones can. But this can quickly
    become “inceptional” programming, so let’s not go that deep.
  prefs: []
  type: TYPE_NORMAL
- en: Do we have to deal with these metaclasses on a daily basis? Well, no. In rare
    cases, you will probably need to define and use them, but most of the time, default
    behavior is just fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s continue with our journey, this time with a new example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Something like this should be your very first OOP step in Python. You are taught
    that `__init__` is a constructor where you set the values of your object attributes,
    and you are good to go. However, this `__init__` dunder method is exactly what
    it says: the initialization step. Isn’t it strange that you call it to initialize
    an object, and yet you get an object instance in return? There is no `return`
    there, right? So, how is this possible? Who returns the instance of a class?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Very few learn at the start of their Python journey that there is another method
    that is called implicitly and is named `__new__`. This method actually creates
    an instance before `__init__` is called to initialize it. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: What you’ll immediately see is that `__new__` returns `super().__new__(cls)`.
    This is a new instance. `super()` fetches the parent class of `Parent,` which
    is implicitly an `object` class. This class is inherited by all classes in Python.
    And it is an object in itself too. Another innovative move by the Python creators!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: But what binds `__new__` and `__init__`? There has to be something more to how
    object instantiation is performed when we call `Parent('John' ,35)`. Take a look
    at it once again. You are invoking (calling) a class object, like a function.
  prefs: []
  type: TYPE_NORMAL
- en: Python callable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python, being a structurally typed language, enables you to define specific
    methods in your class that describe a *Protocol* (a way of using its object),
    and based on this, all instances of a class will behave in the expected way. Do
    not get intimidated if you are coming from other programming languages. *Protocols*
    are something like *Interfaces* in other languages. However, here we do not explicitly
    state that we are implementing a specific interface and, therefore, specific behavior.
    We just implement methods that are described by *Protocol*, and all objects are
    going to have protocol’s behavior. One of these *Protocols* is *Callable*. By
    implementing the dunder method `__call__,` you enable your object to be called
    like a function. See the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: By implementing `__call__` in the class definition, your class instances become
    C*allable*. But what about `Parent('John', 35)`? How do you achieve the same with
    your class object? If an object’s type definition (class) specifies that the object
    is *Callable*, then the class object type (type i.e. metaclass) should specify
    that the class object is callable too, right? Invocation of the dunder methods
    `__new__` and `__init__` happens there.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, it is time to start playing with metaclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Python metaclasses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are at least two ways you can change the process of class object creation.
    One is by using class decorators; the other is by explicitly specifying a metalcass.
    I will describe the metaclass approach. Keep in mind that a metaclass looks like
    a regular class, and the only exception is that it has to inherit a `type` class.
    Why? Because `type` classes have all the implementation that is required for our
    code to still work as expected. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, `MyMeta` is the driving force behind new class object instantiation and
    also specifies how new class instances are created. Take a closer look at the
    last two lines of the example. `parent` holds nothing! But why? Because, as you
    can see, `MyMeta.__call__` just prints information and returns nothing. Explicitly,
    that is. Implicitly, that means that it returns `None`, which is of `NoneType`.
  prefs: []
  type: TYPE_NORMAL
- en: How should we fix this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: From the output, you can see what happens on `MyMeta.__call__`invocation. The
    provided implementation is just an example of how the whole thing works. You should
    be more careful if you plan to override parts of metaclasses yourself. There are
    some edge cases that you have to cover up. For example, one of the edge cases
    is that `Parent.__new__` can return an object that is not an instance of the `Parent`
    class. In that case, it is not going to be initialized by the `Parent.__init__`
    method. That is the expected behavior you have to be aware of, and it really doesn’t
    make sense to initialize an object that is not an instance of the same class.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This would conclude the brief overview of what happens when you define a class
    and make an instance of it. Of course, you could go even further and see what
    happens during the class block interpretation. All of this happens in the metaclass
    too. It’s fortunate for most of us that we probably won’t need to create and use
    specific metaclasses. Yet it is useful to understand how everything functions.
    I’d like to use a similar saying that applies to using NoSQL databases, which
    goes something like this: if you’re not sure whether you need to use Python metaclasses,
    you probably don’t.'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Python Metaclasses](https://jfreeman.dev/blog/2020/12/07/python-metaclasses/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Understanding Object Instantiation and Metaclasses in Python](https://www.honeybadger.io/blog/python-instantiation-metaclass/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
