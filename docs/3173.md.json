["```py\n// https://stackoverflow.com/questions/49599833/how-to-find-next-smaller-key-in-btreemap-btreeset\n// https://stackoverflow.com/questions/35663342/how-to-modify-partially-remove-a-range-from-a-btreemap\nfn internal_add(&mut self, range: RangeInclusive<T>) {\n    let (start, end) = range.clone().into_inner();\n    assert!(\n        end <= T::safe_max_value(),\n        \"end must be <= T::safe_max_value()\"\n    );\n    if end < start {\n        return;\n    }\n    //... code continues ...\n}\n```", "```py\nmethod InternalAdd(xs: seq<NeIntRange>, range: IntRange) returns (r: seq<NeIntRange>)\n  requires ValidSeq(xs)\n  ensures ValidSeq(r)\n  ensures SeqToSet(r) == SeqToSet(xs) + RangeToSet(range)\n{\n  var (start, end) := range;\n  if end < start {\n    r := xs;\n    return;\n  }\n //... code continues ...\n}\n```", "```py\n// code continued ...\n// FUTURE: would be nice of BTreeMap to have a partition_point function that returns two iterators\n    let mut before = self.btree_map.range_mut(..=start).rev();\n    if let Some((start_before, end_before)) = before.next() {\n        // Must check this in two parts to avoid overflow\n        if match (*end_before).checked_add(&T::one()) {\n            Some(end_before_succ) => end_before_succ < start,\n            None => false,\n        } {\n            self.internal_add2(&range);\n        } else if *end_before < end {\n            self.len += T::safe_len(&(*end_before..=end - T::one()));\n            *end_before = end;\n            let start_before = *start_before;\n            self.delete_extra(&(start_before..=end));\n        } else {\n            // completely contained, so do nothing\n        }\n    } else {\n        self.internal_add2(&range);\n    }\n}\n```", "```py\n// code continued ...\n  var beforeHi := IndexAtOrBeforePlusOne(xs, start);\n  if beforeHi > 0 { // does not go at front\n    var (startBefore, endBefore) := xs[beforeHi-1];\n    if endBefore+1 < start {\n      r := InternalAdd2(xs, range);\n    } else if endBefore < end {\n      r := xs[..beforeHi-1] + [(startBefore, end)] + xs[beforeHi..];\n      assume exists i: nat :: i < |r| && r[i] == (startBefore,end) && ValidSeq(r[..i+1]) && ValidSeq(r[i+1..]);\n      r := DeleteExtra(r, (startBefore,end));\n    } else{\n      r := xs;\n    }\n  }\n  else // goes at front\n  {\n    r := InternalAdd2(xs, range);\n  }\n}\n```", "```py\nThis postcondition might not hold: SeqToSet(r) == SeqToSet(xs) + RangeToSet(range)\n```", "```py\n// ... adding this as the last line in InternalAdd\nassert SeqToSet(r) == SeqToSet(xs) + RangeToSet(range);\n}\n```", "```py\n// ...\n      assume exists i: nat :: i < |r| && r[i] == (startBefore,end) && ValidSeq(r[..i+1]) && ValidSeq(r[i+1..]);\n      r := DeleteExtra(r, (startBefore,end));\n//...\n```", "```py\nmethod InternalAdd(xs: seq<NeIntRange>, range: IntRange) returns (r: seq<NeIntRange>)\n  requires ValidSeq(xs)\n  ensures ValidSeq(r)\n  ensures SeqToSet(r) == SeqToSet(xs) + RangeToSet(range)\n{\n  var (start, end) := range;\n  if end < start {\n    r := xs;\n    assert SeqToSet(r) == SeqToSet(xs) + RangeToSet(range); // case 0 - validates\n    return;\n  }\n\n  var beforeHi := IndexAtOrBeforePlusOne(xs, start);\n  if beforeHi > 0 { // does not go at front\n    var (startBefore, endBefore) := xs[beforeHi-1];\n    if endBefore+1 < start {\n      r := InternalAdd2(xs, range);\n      assert SeqToSet(r) == SeqToSet(xs) + RangeToSet(range); // case 1 - validates\n    } else if endBefore < end {\n      r := xs[..beforeHi-1] + [(startBefore, end)] + xs[beforeHi..];\n      assume exists i: nat :: i < |r| && r[i] == (startBefore,end) && ValidSeq(r[..i+1]) && ValidSeq(r[i+1..]);\n      r := DeleteExtra(r, (startBefore,end));\n      assert SeqToSet(r) == SeqToSet(xs) + RangeToSet(range); // case 2 - fails\n    } else{\n      r := xs;\n      assert SeqToSet(r) == SeqToSet(xs) + RangeToSet(range); // case 3 - fails\n    }\n  }\n  else // goes at front\n  {\n    r := InternalAdd2(xs, range);\n    assert SeqToSet(r) == SeqToSet(xs) + RangeToSet(range); // case 4 - validates\n  }\n}\n```", "```py\n@rem Find the location of Dafny and add it to your path\nset path=C:\\Users\\carlk\\.vscode-insiders\\extensions\\dafny-lang.ide-vscode-3.1.2\\out\\resources\\4.2.0\\github\\dafny;%path%\ndafny verify seq_of_sets_example7.dfy --verification-time-limit:30 --cores:20 --log-format csv --boogie -randomSeedIterations:10\n```", "```py\nghost function SeqToSet(sequence: seq<NeIntRange>): set<int>\n  decreases |sequence|\n  // removed: requires ValidSeq(sequence)\n{\n  if |sequence| == 0 then {}\n  else if |sequence| == 1 then RangeToSet(sequence[0])\n  else RangeToSet(sequence[0]) + SeqToSet(sequence[1..])\n}\n```", "```py\ncalc {\n    SeqToSet(xs[..indexAfter+1]) + SeqToSet(xs[indexAfter+1..]);\n  ==\n    { SeqToSetConcatLemma(xs[..indexAfter+1], xs[indexAfter+1..]); }\n    SeqToSet(xs[..indexAfter+1] + xs[indexAfter+1..]);\n  ==\n    { assert xs == xs[..indexAfter+1] + xs[indexAfter+1..]; }\n    SeqToSet(xs);\n  ==\n    { SetsEqualLemma(xs, r[indexAfter], r2, indexAfter, indexDel); }\n    SeqToSet(r2);\n  }\n```", "```py\n{ assert xs == xs[..indexAfter+1] + xs[indexAfter+1..]; }\n```", "```py\nmethod {:timeLimit 30} DeleteExtra(xs: seq<NeIntRange>, internalRange: IntRange) returns (r: seq<NeIntRange>)\n// ...\n```", "```py\n// ...\nelse\n  {\n    r := (s[..i] + [pair]) + s[i..];\n    assert r[..(i+1)] == s[..i] + [pair];\n    assert r[(i+1)..] == s[i..];\n    assert {:split_here} true; // split validation into two parts\n    calc {\n      SeqToSet(r[..(i+1)]) + SeqToSet(r[(i+1)..]);\n// ...\n```"]