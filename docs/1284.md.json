["```py\nuse range_set_blaze::RangeSetBlaze;\nlet a = RangeSetBlaze::from_iter([1..=4]);\nlet b = RangeSetBlaze::from_iter([0..=0, 3..=5, 10..=10]);\nlet union = a | b;\nassert_eq!(union, RangeSetBlaze::from_iter([0..=5, 10..=10]));\n```", "```py\nuse range_set_blaze::prelude::*;\n\nlet a = CheckSortedDisjoint::new(vec![1..=2, 5..=100].into_iter());\nlet b = CheckSortedDisjoint::from([2..=6]);\nlet union = a | b;\nassert_eq!(union.to_string(), \"1..=100\");\n```", "```py\nimpl<T: Integer> BitOr<RangeSetBlaze<T>> for RangeSetBlaze<T> {\n    type Output = RangeSetBlaze<T>;\n    fn bitor(mut self, other: Self) -> RangeSetBlaze<T> {\n      // code omitted for now\n    }\n}\n```", "```py\nimpl<T: Integer> BitOr<&RangeSetBlaze<T>> for &RangeSetBlaze<T> {...}\nimpl<T: Integer> BitOr<RangeSetBlaze<T>> for &RangeSetBlaze<T> {...}\nimpl<T: Integer> BitOr<&RangeSetBlaze<T>> for RangeSetBlaze<T> {...}\n```", "```py\nimpl<T: Integer, I> ops::Not for CheckSortedDisjoint<T, I>\nwhere\n    I: Iterator<Item = RangeInclusive<T>>,\n{\n    type Output = NotIter<T, Self>;\n\n    fn not(self) -> Self::Output {\n        self.complement()\n    }\n}\n```", "```py\nfn print_first_complement_gap() {\n    let a = CheckSortedDisjoint::from([-10i16..=0, 1000..=2000]);\n    println!(\"{:?}\", (!a).next().unwrap()); // prints -32768..=-11\n}\n```", "```py\nimpl<T: Integer> BitOr<&RangeSetBlaze<T>> for RangeSetBlaze<T> {\n    type Output = RangeSetBlaze<T>;\n    fn bitor(mut self, other: &Self) -> RangeSetBlaze<T> {\n        self |= other;\n        self\n    }\n}\n```", "```py\n(a.ranges() & b.ranges()).into_range_set_blaze()\n```", "```py\n!(self.complement() | other.into_iter().complement())\n```", "```py\nuse range_set_blaze::prelude::*;\n\nlet a = RangeSetBlaze::from_iter([1..=6, 8..=9, 11..=15]);\nlet b = RangeSetBlaze::from_iter([5..=13, 18..=29]);\nlet c = RangeSetBlaze::from_iter([-100..=100]);\n\nlet intersection = [a, b, c].intersection();\n\nassert_eq!(intersection, RangeSetBlaze::from_iter([5..=6, 8..=9, 11..=13]));\n```", "```py\npub trait MultiwayRangeSetBlaze<'a, T: Integer + 'a>:\n    IntoIterator<Item = &'a RangeSetBlaze<T>> + Sized\n{\n    fn intersection(self) -> RangeSetBlaze<T> {\n        self.into_iter()\n            .map(RangeSetBlaze::ranges)\n            .intersection()\n            .into_range_set_blaze()\n    }\n}\n```", "```py\npub trait MultiwaySortedDisjoint<T: Integer, I>: IntoIterator<Item = I> + Sized\nwhere\n    I: SortedDisjoint<T>,\n{\n    fn intersection(self) -> BitAndKMerge<T, I> {\n        self.into_iter()\n            .map(|seq| seq.into_iter().complement())\n            .union()\n            .complement()\n    }\n\n    fn union(self) -> BitOrKMerge<T, I> {\n        UnionIter::new(KMerge::new(self))\n    }\n}\n```", "```py\nlet _i0 = [a.ranges(), b.ranges(), c.ranges()].intersection();\n```", "```py\n// doesn't compile: let _i1 = [!a.ranges(), b.ranges(), c.ranges()].intersection();\n```", "```py\npub struct DynSortedDisjoint<'a, T: Integer> {\n    iter: Box<dyn SortedDisjoint<T> + 'a>,\n}\n```", "```py\nlet _i2 = [\n        DynSortedDisjoint::new(!a.ranges()),\n        DynSortedDisjoint::new(b.ranges()),\n        DynSortedDisjoint::new(c.ranges()),\n    ]\n    .intersection();\n// or\nlet _i3 = intersection_dyn!(!a.ranges(), b.ranges(), c.ranges());\n```", "```py\n[[bench]]\nname = \"bench\"\nharness = false\n```", "```py\n[profile.release]\ndebug = true\n```", "```py\n#[test]\nfn lib_coverage_6() {\n    syntactic_for! { ty in [i8, u8, isize, usize,  i16, u16, i32, u32, i64, u64, isize, usize, i128, u128] {\n        $(\n            let mut a = RangeSetBlaze::<$ty>::from_iter([1..=3, 5..=7, 9..=120]);\n            a.ranges_insert(2..=100);\n            assert_eq!(a, RangeSetBlaze::from_iter([1..=120]));\n\n        )*\n    }};\n}\n```", "```py\n /// Given two [`SortedDisjoint`] iterators, efficiently tells if they\n    /// are equal. Unlike most equality testing in Rust,\n    /// this method takes ownership of the iterators and consumes them.\n    ///\n    /// # Examples\n    ///\n    /// ```", "```py\n```", "```py\nfn is_sssu<T: Sized + Send + Sync + Unpin>() {}\nfn is_like_btreeset_iter<T: Clone + std::fmt::Debug + FusedIterator + Iterator>() {}\n// removed DoubleEndedIterator +ExactSizeIterator for now\n#[test]\nfn iter_traits() {\n    type ARangesIter<'a> = RangesIter<'a, i32>;\n    type AIter<'a> = Iter<i32, ARangesIter<'a>>;\n    is_sssu::<AIter>();\n    is_like_btreeset_iter::<AIter>();\n}\n```", "```py\n#[test]\nfn ui() {\n    let t = trybuild::TestCases::new();\n    t.compile_fail(\"tests/ui/*.rs\");\n}\n```", "```py\nuse range_set_blaze::RangeSetBlaze;\n\nfn main() {\n    let guaranteed = RangeSetBlaze::from_iter([1..=2, 3..=4, 5..=6]).into_ranges();\n    let _range_set_int = RangeSetBlaze::from_sorted_disjoint(guaranteed); // yep\n    let not_guaranteed = [5..=6, 1..=3, 3..=4].into_iter();\n    let _range_set_int = RangeSetBlaze::from_sorted_disjoint(not_guaranteed); // nope\n}\n```", "```py\ntype Element = i64;\ntype Reference = std::collections::BTreeSet<Element>;\n\n#[quickcheck]\nfn disjoint(a: Reference, b: Reference) -> bool {\n    let a_r = RangeSetBlaze::from_iter(&a);\n    let b_r = RangeSetBlaze::from_iter(&b);\n    a.is_disjoint(&b) == a_r.is_disjoint(&b_r)\n}\n```"]