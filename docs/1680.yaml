- en: Speed up your Geospatial Data Analysis with R-Trees
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/speed-up-your-geospatial-data-analysis-with-r-trees-4f75abdc6025?source=collection_archive---------0-----------------------#2023-05-21](https://towardsdatascience.com/speed-up-your-geospatial-data-analysis-with-r-trees-4f75abdc6025?source=collection_archive---------0-----------------------#2023-05-21)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/0f555f4eabbd4fbea6e260fa5f79554f.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: Photo by [Mathias Arlund](https://unsplash.com/@arlund?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Learn how to drastically boost the performance of spatial searches
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@markushubrich?source=post_page-----4f75abdc6025--------------------------------)[![Markus
    Hubrich](../Images/e741e368812d5926636d7e0934c72103.png)](https://medium.com/@markushubrich?source=post_page-----4f75abdc6025--------------------------------)[](https://towardsdatascience.com/?source=post_page-----4f75abdc6025--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----4f75abdc6025--------------------------------)
    [Markus Hubrich](https://medium.com/@markushubrich?source=post_page-----4f75abdc6025--------------------------------)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: ·
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F3b63a2f93113&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fspeed-up-your-geospatial-data-analysis-with-r-trees-4f75abdc6025&user=Markus+Hubrich&userId=3b63a2f93113&source=post_page-3b63a2f93113----4f75abdc6025---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----4f75abdc6025--------------------------------)
    ·8 min read·May 21, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F4f75abdc6025&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fspeed-up-your-geospatial-data-analysis-with-r-trees-4f75abdc6025&user=Markus+Hubrich&userId=3b63a2f93113&source=-----4f75abdc6025---------------------clap_footer-----------)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: --
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F4f75abdc6025&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fspeed-up-your-geospatial-data-analysis-with-r-trees-4f75abdc6025&source=-----4f75abdc6025---------------------bookmark_footer-----------)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: A couple of years ago, I was working on a side project. I wanted to create a
    web app that recommends local gems, such as cafés, book stores, or hidden bars.
    The idea was to display all such points of interest within the user’s reach on
    a map. With hundreds of thousands of points in my dataset, I had to be clever
    about filtering the data points that are in a given range to the user. The naive
    approach is to calculate the distance between the user and each point of interest,
    and discard all points outside the specified range. Especially for big datasets
    like mine, this approach often leads to long processing times.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Surely, there had to be a better way as response time is important in interactive
    applications. This is when I came across the data structure *R-tree*. These trees
    are used for fast spatial access and search. Using an R-tree, I was able to quickly
    isolate points of interest close to the user’s location and display them on a
    map. This gave my web app a massive boost in response time — with just **four
    additional lines of code!**
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: In this article, I explain what R-trees are and how they work. This is illustrated
    with an example of street trees in New York City in the first two sections. The
    third section demonstrates how this data structure can be used in Python to speed
    up your geospatial data processing routines, too.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Learning R-trees by analyzing trees in New York City
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Assume we were asked to analyze if there is a correlation in the neighborhoods
    of New York City and the health of its trees. The [NYC Open Data Portal](https://opendata.cityofnewyork.us/)
    offers a street tree census dataset which includes species, diameter, perception
    of health and the geographic location of each tree.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://data.cityofnewyork.us/Environment/2015-Street-Tree-Census-Tree-Data/pi5s-9p35?source=post_page-----4f75abdc6025--------------------------------)
    [## 2015 Street Tree Census - Tree Data | NYC Open Data'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Street tree data from the TreesCount! 2015 Street Tree Census, conducted by
    volunteers and staff organized by NYC Parks…
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: data.cityofnewyork.us](https://data.cityofnewyork.us/Environment/2015-Street-Tree-Census-Tree-Data/pi5s-9p35?source=post_page-----4f75abdc6025--------------------------------)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, we want to count the number of street trees in the Upper East
    Side. The pseudocode snippet below iterates through the dataset `trees` and checks
    if a tree falls within the `upper_east_side` boundary:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We discovered that there are about 9k trees in the Upper East Side. However,
    we had to test a total of 684k trees to get there. The animation below visualizes
    that we test trees which are miles away from our target neighborhood and hence
    could be easily disregarded. But how can we exclude far away trees from expensive
    computations to achieve a significant performance gain?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'One piece of information we virtually get for free is the bounding box of a
    polygon (it can be determined by the minimum and maximum values of its nodes).
    In addition, testing if a point falls within a rectangle is trivial and only requires
    four comparison operations (the point has to be greater than or equal to the bottom-left
    corner, and smaller than or equal to the top-right corner). For now, assume `bounding_box`
    is a dataset which contains all trees in a tight rectangle around the Upper East
    Side (in the next section we learn how such a rectangle can be easily obtained).
    Taking this into consideration yields:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎可以免费获得的一项信息是多边形的边界框（可以通过其节点的最小值和最大值来确定）。此外，测试一个点是否落在矩形内非常简单，只需进行四次比较操作（点必须大于或等于左下角，并且小于或等于右上角）。现在，假设
    `bounding_box` 是一个数据集，包含了上东区周围紧密矩形内的所有树木（在下一节中我们将学习如何轻松获得这样的矩形）。考虑到这一点，可以得出：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The right-hand side of the animation demonstrates that we now only test for
    *potential* candidates. Those are trees that are in immediate proximity to the
    polygon, i.e. points which fall within its bounding box. By disregarding far away
    trees we were able to reduce the number of tests from 684k to 11k — **a factor
    of 60!** In the next section we will see that R-trees make use of exactly this
    idea.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 动画的右侧演示了我们现在仅测试*潜在*候选者。这些是位于多边形附近的树，即落在其边界框内的点。通过忽略远离的树木，我们将测试数量从 684k 减少到 11k
    —— **降低了 60 倍！** 在下一节中，我们将看到 R-trees 正是利用了这一点。
- en: '![](../Images/95a1e01599121c92f29cd12289782cdc.png)![](../Images/7c542d74ca72b42dbb5f7cea89850c39.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/95a1e01599121c92f29cd12289782cdc.png)![](../Images/7c542d74ca72b42dbb5f7cea89850c39.png)'
- en: (**Left**) All trees in NYC are tested | (**Right**) Only trees within the bounding
    box of the Upper East Side are tested. Images by the author, with map data from
    © [Mapbox](https://www.mapbox.com/about/maps/) and © [OpenStreetMap](https://www.openstreetmap.org/copyright).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: (**左**) 纽约市的所有树木都经过测试 | (**右**) 仅测试位于上东区边界框内的树木。图像由作者提供，地图数据来自 © [Mapbox](https://www.mapbox.com/about/maps/)
    和 © [OpenStreetMap](https://www.openstreetmap.org/copyright)。
- en: 'A data structure for spatial searches: the R-tree'
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于空间搜索的数据结构：R-tree
- en: R-trees are tree-based data structures for creating spatial indexes in an efficient
    manner. An R-tree is often used for fast spatial queries or to accelerate nearest
    neighbor searches [1]. A common use case might be to store spatial information
    of points of interest (e.g. restaurants, gas stations, streets, etc.) With the
    help of R-trees one can quickly retrieve all points of interest within a certain
    distance to a location. In return, these results can be displayed on a map or
    in a navigation system.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: R-trees 是基于树的数据结构，用于高效地创建空间索引。R-tree 通常用于快速空间查询或加速最近邻搜索 [1]。一个常见的应用场景是存储兴趣点的空间信息（例如餐馆、加油站、街道等）。借助
    R-trees，可以快速检索到某位置一定距离内的所有兴趣点。反过来，这些结果可以在地图上或导航系统中显示。
- en: 'The basic idea of an R-tree is simple: leaf nodes of the tree hold spatial
    data, whereas a branching node corresponds to the minimum bounding box that contains
    all of its children. With this structure the R-tree partitions the space into
    rectangles which become more granular as the tree grows. This is illustrated in
    the example below.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: R-tree 的基本思想很简单：树的叶节点保存空间数据，而分支节点对应于包含所有子节点的最小边界框。通过这种结构，R-tree 将空间划分为矩形，随着树的增长这些矩形变得更为精细。以下示例对此进行了说明。
- en: '![](../Images/c3a566b3eaff867bf933abd8b304d36b.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c3a566b3eaff867bf933abd8b304d36b.png)'
- en: (**Left**) The R-tree partitions Manhattan into a number of rectangles | (**Right**)
    The corresponding tree structure. Images by the author, with map data from © [Mapbox](https://www.mapbox.com/about/maps/)
    and © [OpenStreetMap](https://www.openstreetmap.org/copyright).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: (**左**) R-tree 将曼哈顿划分为多个矩形 | (**右**) 对应的树结构。图像由作者提供，地图数据来自 © [Mapbox](https://www.mapbox.com/about/maps/)
    和 © [OpenStreetMap](https://www.openstreetmap.org/copyright)。
- en: An R-tree is queried for a rectangle, i.e. we want to retrieve all data that
    is contained in this search window. Remember that each non-leaf node corresponds
    to a bounding box that contains all of its children. To fulfill a search query
    we simply travel along the branches of the tree and follow the paths that intersect
    with the given rectangle until we reach the leaf nodes. These leaf nodes, and
    hence our data points, are contained in the search rectangle and fulfill the query.
    The animation below demonstrates that we can greatly reduce the number of search
    operations by disregarding entire branches which do not fit the search criteria.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/cc235888cd876baf7d8801926e43450b.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: (**Left**) Bounding boxes (black) which do not intersect with the search rectangle
    (red) are iteratively disregard | (**Right**) A search query is fulfilled by following
    the paths that intersect with the search rectangle. Images by the author.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: R-trees in Python
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Python package `Rtree` provides an implementation of the R-tree data structure
    and comes with a number of handy features, such as nearest neighbor searches,
    intersection searches or multi-dimensional indexes.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[## Rtree: Spatial indexing for Python - Rtree 0.9.4 documentation'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Rtree is a ctypes Python wrapper of libspatialindex that provides a number of
    advanced spatial indexing features for…
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: rtree.readthedocs.io](https://rtree.readthedocs.io/en/latest/?source=post_page-----4f75abdc6025--------------------------------)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'We can conveniently install the package with Python’s package manager [pip](https://pip.pypa.io/en/stable/):
    `pip install Rtree`.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Basics
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we handle geometries like points or polygons, we cover the basic usage
    of the `Rtree` package.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'The `index` module helps us to construct a spatial index. This index is built
    up automatically by inserting bounding boxes of our objects. The bounding boxes
    are defined by specifying their left, bottom, right and top coordinates. Note
    that we insert a bounding box together with an *identifier* (in the above example
    `0` and `1`). The ID will help us to identify the bounding box when performing
    queries:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'The index is queried for a given rectangle, again specified by its left, bottom,
    right and top coordinates. The result of the `intersection` method are the IDs
    of the objects that are contained within the search window (examples 1–3). The
    result is empty in the case that the search window is beyond the bounds of data
    we have in the index (example 4). Similarly, we use the `nearest` method to find
    the *k*-nearest objects to a given search window:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Working with points, lines and polygons
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, we saw how an index is constructed by inserting bounding
    boxes of objects. We now want to continue by using points, lines and polygons
    for these objects. The package [Shapely](https://pypi.org/project/Shapely/) provides
    an easy way of working with these kind of geometries in Python:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'Above, we first create a point, a line, and a polygon. Next, the bounding boxes
    of these objects are inserted into an index using IDs `0`, `1`, and `2`. We now
    query the index for different search windows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'The illustration below shows the geometries and search windows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/506e372dc3712acb78d9800292975b2c.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: '**Green:** Point, Line and Polygon. **Red:** Search Windows. Image by the author.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Searching all trees in the Upper East Side
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We finally have everything needed to extract all trees within the Upper East
    Side! We will go through a code snippet below, however the full version can be
    found [here](https://gist.github.com/mhubrich/da9b5cf085af7cc207ce101f54fc4b69).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/730bfcd12a2d22751b8b9e783c542e4f.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
- en: '**Green:** Trees in New York City. **Blue:** Upper East Side. **Orange:** Bounding
    box of the Upper East Side. Image by the author, with map data from © [Mapbox](https://www.mapbox.com/about/maps/)
    and © [OpenStreetMap](https://www.openstreetmap.org/copyright).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we load all required geometries using the [GeoPandas](https://pypi.org/project/geopandas/)
    package:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create an R-tree index containing all trees in New York City:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we generate a list of potential candidates, i.e. all trees that are within
    the bounding box of the Upper East Side:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we iterate through all potential candidates to extract the ones that
    are fully within the Upper East Side:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this article, we learned how R-trees organize geographic information by
    partitioning the underlaying space into rectangles. This structure makes R-trees
    extremely fast for spatial lookups. In our New York City street tree example,
    utilizing an R-tree reduced the number of operations by a factor of 60\. We also
    saw how to work with R-trees in Python. The speed-up in our example was achieved
    with just four lines of code: initializing the index (1 line), constructing the
    index (2 lines), and using the `intersection` function to find nearby candidates
    (1 line).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: So why are R-trees not used everywhere? While we gain time by reducing the number
    of search operations, we lose time by constructing the index. For the latter we
    literally have to iterate through the entire dataset. This makes R-trees not suitable
    for applications requiring only a small number of searches or applications where
    the index changes often (because of tree rebalancing).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: R-trees have come a long way since their invention by Antonin Guttman in 1984\.
    Nowadays, they are found in all sorts of applications, for example in computer
    graphics [2], video games [3], traffic control systems [4], and most prominently
    in databases for spatial data management [5]. And perhaps in your next geospatial
    data analysis, too!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '**References**'
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[1] A. Guttman, [R-Trees: A Dynamic Index Structure for Spatial Searching](http://www-db.deis.unibo.it/courses/SI-LS/papers/Gut84.pdf)
    (1984), Proceedings of the 1984 ACM SIGMOD International Conference on Management
    of Data, p. 47–57'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[2] D. Feldmann, [Accelerated Ray Tracing using R-Trees](https://www.scitepress.org/papers/2015/53048/53048.pdf)
    (2015), Proceedings of the 10th International Conference on Computer Graphics
    Theory and Applications, p. 247–257'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[3] A. Kinziabulatov, [Optimizing R-tree inserts in Unity: a Bomberman-like
    example](https://medium.com/my-games-company/optimizing-r-tree-inserts-in-unity-a-bomberman-like-example-81d2576efd75)
    (2023), Medium'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[4] Y. Manolopoulos, A. Nanopoulos, A. Papadopoulos and Y. Theodoridis, [R-Trees:
    Theory and Applications](https://link.springer.com/book/10.1007/978-1-84628-293-5)
    (2006), Springer'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[5] S. Bressan, J. Küng and R. Wagner, [Database and Expert Systems Applications](https://link.springer.com/book/10.1007/11827405)
    (2006), Springer'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '**Datasets**'
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: New York City Department of Parks & Recreation, [2015 Street Tree Census — Tree
    Data](https://data.cityofnewyork.us/Environment/2015-Street-Tree-Census-Tree-Data/pi5s-9p35)
    (2016), NYC Open Data
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: New York City Department of City Planning, [2010 Neighborhood Tabulation Areas
    (NTAs)](https://data.cityofnewyork.us/City-Government/2010-Neighborhood-Tabulation-Areas-NTAs-/cpf4-rkhq)
    (2013), NYC Open Data
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
