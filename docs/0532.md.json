["```py\nfrom mldesigner import command_component, Input, Output\nfrom pathlib import Path\n\n@command_component(\n    name=\"superpoint_and_superglue\",\n    version=\"1\",\n    display_name=\"Superpoint and Superglue\",\n    description=\"Run Superpoint and Superglue models and outputs csv with matching images\",\n    environment=dict(\n        conda_file=Path(__file__).parent / \"conda.yaml\",\n         image=\"mcr.microsoft.com/azureml/openmpi4.1.0-ubuntu20.04\",\n    ),\n)\ndef superpoint_and_superglue_component(\n    input_data: Input(type=\"uri_folder\"),\n    data_output: Output(type=\"uri_folder\"),\n):    \n    import os    \n    import pandas as pd\n    import numpy as np\n    import cv2\n    import argparse\n    import requests\n    import shutil\n\n    import os\n    os.environ[\"KMP_DUPLICATE_LIB_OK\"]=\"TRUE\"\n\n    import torch\n\n    from pathlib import Path\n    import random\n    import matplotlib.cm as cm\n\n    import models.matching\n    import models.utils       \n\n    def ranking_score(matches, match_confidence):\n        return np.sum(np.multiply(matches,match_confidence)).astype(np.float32)  \n\n    def load_models(device, nms_radius, keypoint_threshold, max_keypoints, superglue, sinkhorn_iterations, match_threshold):\n        # Load the SuperPoint and SuperGlue models.\n\n        print('Running inference on device \\\"{}\\\"'.format(device))\n        config = {\n            'superpoint': {\n                'nms_radius': nms_radius,\n                'keypoint_threshold': keypoint_threshold,\n                'max_keypoints': max_keypoints\n            },\n            'superglue': {\n                'weights': superglue,\n                'sinkhorn_iterations': sinkhorn_iterations,\n                'match_threshold': match_threshold,\n            }\n        }\n\n        matching = models.matching.Matching(config).eval().to(device)\n        return matching\n\n    def get_scores(timer, device, pairs, matching, input_dir, output_dir, viz, viz_extension, resize, resize_float, query):\n        # [...]\n\n    def main():\n        torch.set_grad_enabled(False)\n\n        input_dir = input_data\n        print('Looking for data in directory \\\"{}\\\"'.format(input_dir))\n        output_dir = Path(os.path.join(input_data, \"/superglue_outputs\"))\n        output_dir.mkdir(exist_ok=True, parents=True)\n        print('Will write matches to directory \\\"{}\\\"'.format(output_dir))\n\n        force_cpu = False\n\n        device = 'cuda' if torch.cuda.is_available() and not force_cpu else 'cpu'\n        timer = models.utils.AverageTimer(newline=True)      \n\n        pairs = [[\"query.jpg\", \"query.jpg\"],[\"query.jpg\", \"movie_poster.jpg\"]]\n\n        all_uri_files = os.listdir(input_data)\n        candidate_image_filenames = []\n        for image_name in all_uri_files:\n            if (image_name.endswith('.jpg') or image_name.endswith('.png') or image_name.endswith('.jpeg')):\n                candidate_image_filenames.append(image_name)\n\n        nms_radius = 4\n        keypoint_threshold = 0.005\n        max_keypoints = 1024\n        superglue = \"indoor\"\n        sinkhorn_iterations = 20\n        match_threshold = 0.2\n\n        matching = load_models(device, nms_radius, keypoint_threshold, max_keypoints, superglue, sinkhorn_iterations, match_threshold)\n\n        output = []       \n\n        query = (output_dir / \"query.jpg\")\n\n        for image in candidate_image_filenames:                 \n            shutil.copyfile(os.path.join(input_dir, image), query)\n\n            viz = False\n            viz_extension = \"png\"\n            resize = [1200, 900]\n            resize_float = False\n\n            _,predicted_score = get_scores(timer, device, pairs, matching, input_dir, output_dir, viz, viz_extension, resize, resize_float, query)            \n            item_output = {\"score\":predicted_score,\"image\":image}\n            output.append(item_output)\n\n        return output          \n\n    output = main()\n    pd.DataFrame(output).to_csv((Path(data_output) / \"results.csv\"), index=False)\n```", "```py\nfrom azure.identity import DefaultAzureCredential, InteractiveBrowserCredential\nfrom azure.ai.ml import MLClient, load_component\n\ntry:\n    credential = DefaultAzureCredential()\n    # Check if given credential can get token successfully.\n    credential.get_token(\"https://management.azure.com/.default\")\nexcept Exception as ex:\n    # Fall back to InteractiveBrowserCredential in case DefaultAzureCredential not work\n    credential = InteractiveBrowserCredential()\n\n# Get a handle to workspace\nml_client = MLClient.from_config(credential=credential)\n\n# IMPORTANT: here we import the method we've created previously\nfrom src.component import superpoint_and_superglue_component\n\n# Register the component\nml_client.components.create_or_update(superpoint_and_superglue_component, version=\"1.3\")\n```"]