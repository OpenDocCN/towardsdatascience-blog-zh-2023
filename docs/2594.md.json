["```py\ndef simple_pendulum(theta_0, omega, t, phi):\n    theta = theta_0*np.cos(omega*t + phi)\n    return theta\n\n#parameters of our system\ntheta_0 = np.radians(15) #degrees to radians\n\ng = 9.8 #m/s^2\nl = 1.0 #m\nomega = np.sqrt(g/l)\n\nphi = 0 #for small angle\n\ntime_span = np.linspace(0,20,300) #simulate for 20s split into 300 time intervals\ntheta = []\nfor t in time_span:\n    theta.append(simple_pendulum(theta_0, omega, t, phi))\n\n#Convert back to cartesian coordinates\nx = l*np.sin(theta)\ny = -l*np.cos(theta) #negative to make sure the pendulum is facing down\n```", "```py\ndef full_pendulum(g,l,theta,theta_velocity, time_step):\n    #Numerical Integration\n    theta_acceleration = -(g/l)*np.sin(theta) #Get acceleration\n    theta_velocity += time_step*theta_acceleration #Update velocity with acceleration\n    theta += time_step*theta_velocity #Update angle with angular velocity\n    return theta, theta_velocity\n\ng = 9.8 #m/s^2\nl = 1.0 #m\n\ntheta = [np.radians(90)] #theta_0\ntheta_velocity = 0 #Start with 0 velocity\ntime_step = 20/300 #Define a time step\n\ntime_span = np.linspace(0,20,300) #simulate for 20s split into 300 time intervals\nfor t in time_span:\n    theta_new, theta_velocity = full_pendulum(g,l,theta[-1], theta_velocity, time_step)\n    theta.append(theta_new)\n\n#Convert back to cartesian coordinates \nx = l*np.sin(theta)\ny = -l*np.cos(theta)\n```", "```py\n#Get theta1 acceleration \ndef theta1_acceleration(m1,m2,l1,l2,theta1,theta2,theta1_velocity,theta2_velocity,g):\n    mass1 = -g*(2*m1 + m2)*np.sin(theta1)\n    mass2 = -m2*g*np.sin(theta1 - 2*theta2)\n    interaction = -2*np.sin(theta1 - theta2)*m2*np.cos(theta2_velocity**2*l2 + theta1_velocity**2*l1*np.cos(theta1 - theta2))\n    normalization = l1*(2*m1 + m2 - m2*np.cos(2*theta1 - 2*theta2))\n\n    theta1_ddot = (mass1 + mass2 + interaction)/normalization\n\n    return theta1_ddot\n\n#Get theta2 acceleration\ndef theta2_acceleration(m1,m2,l1,l2,theta1,theta2,theta1_velocity,theta2_velocity,g):\n    system = 2*np.sin(theta1 - theta2)*(theta1_velocity**2*l1*(m1 + m2) + g*(m1 + m2)*np.cos(theta1) + theta2_velocity**2*l2*m2*np.cos(theta1 - theta2))\n    normalization = l1*(2*m1 + m2 - m2*np.cos(2*theta1 - 2*theta2))\n\n    theta2_ddot = system/normalization\n    return theta2_ddot\n\n#Update theta1\ndef theta1_update(m1,m2,l1,l2,theta1,theta2,theta1_velocity,theta2_velocity,g,time_step):\n    #Numerical Integration\n    theta1_velocity += time_step*theta1_acceleration(m1,m2,l1,l2,theta1,theta2,theta1_velocity,theta2_velocity,g)\n    theta1 += time_step*theta1_velocity\n    return theta1, theta1_velocity\n\n#Update theta2\ndef theta2_update(m1,m2,l1,l2,theta1,theta2,theta1_velocity,theta2_velocity,g,time_step):\n    #Numerical Integration\n    theta2_velocity += time_step*theta2_acceleration(m1,m2,l1,l2,theta1,theta2,theta1_velocity,theta2_velocity,g)\n    theta2 += time_step*theta2_velocity\n    return theta2, theta2_velocity\n\n#Run full double pendulum\ndef double_pendulum(m1,m2,l1,l2,theta1,theta2,theta1_velocity,theta2_velocity,g,time_step,time_span):\n    theta1_list = [theta1]\n    theta2_list = [theta2]\n\n    for t in time_span:\n        theta1, theta1_velocity = theta1_update(m1,m2,l1,l2,theta1,theta2,theta1_velocity,theta2_velocity,g,time_step)\n        theta2, theta2_velocity = theta2_update(m1,m2,l1,l2,theta1,theta2,theta1_velocity,theta2_velocity,g,time_step)\n\n        theta1_list.append(theta1)\n        theta2_list.append(theta2)\n\n    x1 = l1*np.sin(theta1_list) #Pendulum 1 x\n    y1 = -l1*np.cos(theta1_list) #Pendulum 1 y\n\n    x2 = l1*np.sin(theta1_list) + l2*np.sin(theta2_list) #Pendulum 2 x\n    y2 = -l1*np.cos(theta1_list) - l2*np.cos(theta2_list) #Pendulum 2 y\n\n    return x1,y1,x2,y2\n```", "```py\n#Define system parameters\ng = 9.8 #m/s^2\n\nm1 = 1 #kg\nm2 = 1 #kg\n\nl1 = 1 #m\nl2 = 1 #m\n\ntheta1 = np.radians(90)\ntheta2 = np.radians(45)\n\ntheta1_velocity = 0 #m/s\ntheta2_velocity = 0 #m/s\n\ntheta1_list = [theta1]\ntheta2_list = [theta2]\n\ntime_step = 20/300\n\ntime_span = np.linspace(0,20,300)\nx1,y1,x2,y2 = double_pendulum(m1,m2,l1,l2,theta1,theta2,theta1_velocity,theta2_velocity,g,time_step,time_span)\n```", "```py\ndef makeGif(x,y,name):\n    !mkdir frames\n\n    counter=0\n    images = []\n    for i in range(0,len(x)):\n        plt.figure(figsize = (6,6))\n\n        plt.plot([0,x[i]],[0,y[i]], \"o-\", color = \"b\", markersize = 7, linewidth=.7 )\n        plt.title(\"Pendulum\")\n        plt.xlim(-1.1,1.1)\n        plt.ylim(-1.1,1.1)\n        plt.savefig(\"frames/\" + str(counter)+ \".png\")\n        images.append(imageio.imread(\"frames/\" + str(counter)+ \".png\"))\n        counter += 1\n        plt.close()\n\n    imageio.mimsave(name, images)\n\n    !rm -r frames\n\ndef simple_pendulum(theta_0, omega, t, phi):\n    theta = theta_0*np.cos(omega*t + phi)\n    return theta\n\n#parameters of our system\ntheta_0 = np.radians(15) #degrees to radians\n\ng = 9.8 #m/s^2\nl = 1.0 #m\nomega = np.sqrt(g/l)\n\nphi = 0 #for small angle\n\ntime_span = np.linspace(0,20,300) #simulate for 20s split into 300 time intervals\ntheta = []\nfor t in time_span:\n    theta.append(simple_pendulum(theta_0, omega, t, phi))\n\nx = l*np.sin(theta)\ny = -l*np.cos(theta) #negative to make sure the pendulum is facing down\n```", "```py\ndef full_pendulum(g,l,theta,theta_velocity, time_step):\n    theta_acceleration = -(g/l)*np.sin(theta)\n    theta_velocity += time_step*theta_acceleration\n    theta += time_step*theta_velocity\n    return theta, theta_velocity\n\ng = 9.8 #m/s^2\nl = 1.0 #m\n\ntheta = [np.radians(90)] #theta_0\ntheta_velocity = 0\ntime_step = 20/300\n\ntime_span = np.linspace(0,20,300) #simulate for 20s split into 300 time intervals\nfor t in time_span:\n    theta_new, theta_velocity = full_pendulum(g,l,theta[-1], theta_velocity, time_step)\n    theta.append(theta_new)\n\n#Convert back to cartesian coordinates \nx = l*np.sin(theta)\ny = -l*np.cos(theta)\n\n#Use same function from simple pendulum\nmakeGif(x,y,\"pendulum.gif\")\n```", "```py\ndef theta1_acceleration(m1,m2,l1,l2,theta1,theta2,theta1_velocity,theta2_velocity,g):\n    mass1 = -g*(2*m1 + m2)*np.sin(theta1)\n    mass2 = -m2*g*np.sin(theta1 - 2*theta2)\n    interaction = -2*np.sin(theta1 - theta2)*m2*np.cos(theta2_velocity**2*l2 + theta1_velocity**2*l1*np.cos(theta1 - theta2))\n    normalization = l1*(2*m1 + m2 - m2*np.cos(2*theta1 - 2*theta2))\n\n    theta1_ddot = (mass1 + mass2 + interaction)/normalization\n\n    return theta1_ddot\n\ndef theta2_acceleration(m1,m2,l1,l2,theta1,theta2,theta1_velocity,theta2_velocity,g):\n    system = 2*np.sin(theta1 - theta2)*(theta1_velocity**2*l1*(m1 + m2) + g*(m1 + m2)*np.cos(theta1) + theta2_velocity**2*l2*m2*np.cos(theta1 - theta2))\n    normalization = l1*(2*m1 + m2 - m2*np.cos(2*theta1 - 2*theta2))\n\n    theta2_ddot = system/normalization\n    return theta2_ddot\n\ndef theta1_update(m1,m2,l1,l2,theta1,theta2,theta1_velocity,theta2_velocity,g,time_step):\n\n    theta1_velocity += time_step*theta1_acceleration(m1,m2,l1,l2,theta1,theta2,theta1_velocity,theta2_velocity,g)\n    theta1 += time_step*theta1_velocity\n    return theta1, theta1_velocity\n\ndef theta2_update(m1,m2,l1,l2,theta1,theta2,theta1_velocity,theta2_velocity,g,time_step):\n\n    theta2_velocity += time_step*theta2_acceleration(m1,m2,l1,l2,theta1,theta2,theta1_velocity,theta2_velocity,g)\n    theta2 += time_step*theta2_velocity\n    return theta2, theta2_velocity\n\ndef double_pendulum(m1,m2,l1,l2,theta1,theta2,theta1_velocity,theta2_velocity,g,time_step,time_span):\n    theta1_list = [theta1]\n    theta2_list = [theta2]\n\n    for t in time_span:\n        theta1, theta1_velocity = theta1_update(m1,m2,l1,l2,theta1,theta2,theta1_velocity,theta2_velocity,g,time_step)\n        theta2, theta2_velocity = theta2_update(m1,m2,l1,l2,theta1,theta2,theta1_velocity,theta2_velocity,g,time_step)\n\n        theta1_list.append(theta1)\n        theta2_list.append(theta2)\n\n    x1 = l1*np.sin(theta1_list)\n    y1 = -l1*np.cos(theta1_list)\n\n    x2 = l1*np.sin(theta1_list) + l2*np.sin(theta2_list)\n    y2 = -l1*np.cos(theta1_list) - l2*np.cos(theta2_list)\n\n    return x1,y1,x2,y2\n```", "```py\n#Define system parameters, run double pendulum\ng = 9.8 #m/s^2\n\nm1 = 1 #kg\nm2 = 1 #kg\n\nl1 = 1 #m\nl2 = 1 #m\n\ntheta1 = np.radians(90)\ntheta2 = np.radians(45)\n\ntheta1_velocity = 0 #m/s\ntheta2_velocity = 0 #m/s\n\ntheta1_list = [theta1]\ntheta2_list = [theta2]\n\ntime_step = 20/300\n\ntime_span = np.linspace(0,20,300)\nfor t in time_span:\n    theta1, theta1_velocity = theta1_update(m1,m2,l1,l2,theta1,theta2,theta1_velocity,theta2_velocity,g,time_step)\n    theta2, theta2_velocity = theta2_update(m1,m2,l1,l2,theta1,theta2,theta1_velocity,theta2_velocity,g,time_step)\n\n    theta1_list.append(theta1)\n    theta2_list.append(theta2)\n\nx1 = l1*np.sin(theta1_list)\ny1 = -l1*np.cos(theta1_list)\n\nx2 = l1*np.sin(theta1_list) + l2*np.sin(theta2_list)\ny2 = -l1*np.cos(theta1_list) - l2*np.cos(theta2_list)\n```", "```py\n#Make Gif\n!mkdir frames\n\ncounter=0\nimages = []\nfor i in range(0,len(x1)):\n    plt.figure(figsize = (6,6))\n\n    plt.figure(figsize = (6,6))\n    plt.plot([0,x1[i]],[0,y1[i]], \"o-\", color = \"b\", markersize = 7, linewidth=.7 )\n    plt.plot([x1[i],x2[i]],[y1[i],y2[i]], \"o-\", color = \"b\", markersize = 7, linewidth=.7 )\n    plt.title(\"Double Pendulum\")\n    plt.xlim(-2.1,2.1)\n    plt.ylim(-2.1,2.1)\n    plt.savefig(\"frames/\" + str(counter)+ \".png\")\n    images.append(imageio.imread(\"frames/\" + str(counter)+ \".png\"))\n    counter += 1\n    plt.close()\n\nimageio.mimsave(\"double_pendulum.gif\", images)\n\n!rm -r frames\n```"]