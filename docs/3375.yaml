- en: 'The Graph Coloring Problem: Exact and Heuristic Solutions'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/the-graph-coloring-problem-exact-and-heuristic-solutions-169dce4d88ab?source=collection_archive---------3-----------------------#2023-11-13](https://towardsdatascience.com/the-graph-coloring-problem-exact-and-heuristic-solutions-169dce4d88ab?source=collection_archive---------3-----------------------#2023-11-13)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exploring the classical discrete optimization problem through custom constructive
    heuristics and integer programming in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@bruscalia12?source=post_page-----169dce4d88ab--------------------------------)[![Bruno
    Scalia C. F. Leite](../Images/1042cd04be047c0811fef79ecd04e69c.png)](https://medium.com/@bruscalia12?source=post_page-----169dce4d88ab--------------------------------)[](https://towardsdatascience.com/?source=post_page-----169dce4d88ab--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----169dce4d88ab--------------------------------)
    [Bruno Scalia C. F. Leite](https://medium.com/@bruscalia12?source=post_page-----169dce4d88ab--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F3ce9b7482ef0&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fthe-graph-coloring-problem-exact-and-heuristic-solutions-169dce4d88ab&user=Bruno+Scalia+C.+F.+Leite&userId=3ce9b7482ef0&source=post_page-3ce9b7482ef0----169dce4d88ab---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----169dce4d88ab--------------------------------)
    ·10 min read·Nov 13, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F169dce4d88ab&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fthe-graph-coloring-problem-exact-and-heuristic-solutions-169dce4d88ab&user=Bruno+Scalia+C.+F.+Leite&userId=3ce9b7482ef0&source=-----169dce4d88ab---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F169dce4d88ab&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fthe-graph-coloring-problem-exact-and-heuristic-solutions-169dce4d88ab&source=-----169dce4d88ab---------------------bookmark_footer-----------)![](../Images/4509b47d7da81cc86ecf9f75d39735f1.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Graph coloring heuristic solution for 32 nodes instance. (Image by the author).
  prefs: []
  type: TYPE_NORMAL
- en: Graph coloring theory has a central position in discrete mathematics. It appears
    in many places with seemingly no or little connection to coloring. It deals with
    the fundamental problem of partitioning a set of objects into classes, according
    to certain rules (Jensen & Toft, 1995).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can summarize the problem as follows: given an undirected graph *G*(*V*,
    *E*), assign colors to each node (vertex) such that no two adjacent nodes share
    the same color and the number of colors used is minimized. Despite the concise
    and clear statement, this problem is notorious for its computational complexity,
    falling into the category of NP-hard problems.'
  prefs: []
  type: TYPE_NORMAL
- en: Due to its combinatorial complexity, the exact approach of Integer Linear Programming
    (ILP), might be unable to solve large instances, even when using the best available
    solvers. In such situations, heuristics and metaheuristics can be interesting
    alternatives. Although not able to prove optimality, these methods can provide
    fast and good-quality solutions.
  prefs: []
  type: TYPE_NORMAL
- en: In this article, we will solve the Graph Coloring Problem using the constructive
    heuristic *DSatur* (Brélaz, 1979) and an integer linear programming model using
    *pyomo* (Bynum et al., 2021) with the solver HiGHS. As for other stories, you
    can find the complete code in my [code repository](https://github.com/bruscalia/optimization-demo-files/tree/1fa7a3825421d0b166195d890f2629c576cfbfda/graph-coloring).
  prefs: []
  type: TYPE_NORMAL
- en: In case you are not yet familiar with *Linear Programming*, I recommend reading
    my previous article for foundational knowledge before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: '[](/linear-programming-theory-and-applications-c67600591612?source=post_page-----169dce4d88ab--------------------------------)
    [## Linear programming: Theory and applications'
  prefs: []
  type: TYPE_NORMAL
- en: Linear optimization main concepts and implementation in Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/linear-programming-theory-and-applications-c67600591612?source=post_page-----169dce4d88ab--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Now let us put some hands-on to creating amazing solutions such as this.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e6311f0269b445fe63d866bd5e512c61.png)'
  prefs: []
  type: TYPE_IMG
- en: Graph coloring heuristic solution for 32 nodes instance. (Animation by the author).
  prefs: []
  type: TYPE_NORMAL
- en: Constructive heuristic — DSatur
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us recall our problem definition:'
  prefs: []
  type: TYPE_NORMAL
- en: Consider an undirected graph *G*(*V*, *E*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign colors to each node such that no two adjacent nodes share the same color.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimize the number of colors used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A naive constructive solution can be successively choosing an empty node and
    assigning a color to it ensuring that this color was not yet used in its neighbors.
    That might not be the best strategy possible, but surely can provide an upper
    bound for the necessary number of colors. However, the *DSatur* (Brélaz, 1979)
    algorithm includes new elements to choose the next node and improve this heuristic.
  prefs: []
  type: TYPE_NORMAL
- en: '*Degree*: Number of edges connected to a given node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Saturation*: Number of different colors used in neighbors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The algorithm for *DSatur* starts from a queue of uncolored nodes and iteratively
    chooses a node with a maximal saturation degree, removes it from the queue, and
    assigns a color to it. If there is an equality in saturation, Brélaz (1979) suggests
    choosing any of maximal saturation. We will choose a slightly different approach
    by breaking ties by choosing the node with the maximal overall degree. The color
    assigned to a given node should be the one with the lowest index available. A
    pseudocode is presented below. Consider *N* the set of nodes, *Q* the queue of
    uncolored nodes referencing the same memory locations of *N* itself, and *C* the
    set of used colors.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The function `assign_color` should verify the lowest index available color and,
    if none from the current set is feasible, include a new alternative and increment
    the set.
  prefs: []
  type: TYPE_NORMAL
- en: Let us then put that into Python code. Starting with package imports. Our heuristic
    will be written in pure Python with some type-hint imports only.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us define our basic modeling elements: *Colors* and *Nodes*. The class
    *Color* is defined to be a mutable placeholder for the corresponding indexes of
    their instances. That can be memory efficient in Python as multiple variables
    can reference the same memory location. The method `add_node` should be called
    every time a new node is colored with a given color.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now the class *Node*. Each instance of *Node* has an attribute `neighbors` which
    is a list of nodes (pointers). So, every time a node is modified, we do not need
    to change any information in its neighbors. We can add a neighbor using the method
    `add_neighbor`, set its color using the method `set_color`, and access properties
    that depend on their neighbors' current states `neighbor_colors`, `saturation`,
    and `degree`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now into the *DSatur* algorithm. To implement it, a class of the same name will
    be created. The creation of a new *DSatur* instance takes as arguments the number
    of nodes `n_nodes`and `edges` of the graph. It then instantiates nodes and sets
    their neighbors based on edges.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now let us use it to solve some challenging problems! You can find several instances
    in the [OR Library](http://people.brunel.ac.uk/~mastjjb/jeb/orlib/files/). They
    are denoted as “gcolX” in there. We can extract the number of nodes and edges
    from one of those files using the following code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Then we just parse these to a new *DSatur* instance and solve the problem (or
    at least get a good-quality approximation).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The code to create that interesting visualization of results from the introduction
    might be too verbose to include here, but you can find it in my [code repository](https://github.com/bruscalia/optimization-demo-files/tree/1fa7a3825421d0b166195d890f2629c576cfbfda/graph-coloring).
    It can convey a general idea of how hard it gets when handling several nodes…
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e51268bd9c6951ed7eb7116e12f481c0.png)'
  prefs: []
  type: TYPE_IMG
- en: Graph coloring heuristic solution for 100 nodes instance. (Animation by the
    author).
  prefs: []
  type: TYPE_NORMAL
- en: Now let us see how we could handle it by an exact approach.
  prefs: []
  type: TYPE_NORMAL
- en: Integer Linear Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To refine our solutions obtained using heuristics and try to prove the optimality
    of solutions, let us formulate the Graph Coloring Problem as an ILP model. Remember
    it might be unable to handle large instances though. The model presented in this
    section and other exact algorithms are presented in *Chapter 3* of Lewis (2021).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us define the *Sets* considered in this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '*C*: Colors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*N*: Nodes (or vertices)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*E*: Edges'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A first question already comes up “How many colors should we consider?”. In
    the worst-case scenario, all nodes are connected, so one should consider *C* of
    the same size as *N*. However, this approach could make our solutions even harder
    by unnecessarily increasing the number of decision variables and worsening the
    linear relaxation of the model. A good alternative is to use a heuristic method
    (such as *DSatur*) to obtain an upper bound for the number of colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this problem, we have two groups of decision variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '*x_*{*i*, *c*}: Are binary variables indicating that node *i* is colored in
    *c*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*y_*{*c*}: Are binary variables indicating that color *c* is used'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We must also create constraints to ensure that:'
  prefs: []
  type: TYPE_NORMAL
- en: Every node must be colored
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If any node from one edge has a color, ensure that the color is being used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At most 1 node of each edge can be colored with a given color
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Break symmetry (this is not required, but might help)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, our objective should minimize the total number of colors used, which
    is the sum of *y*. Summarizing we have the following equations.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3a8f414140d6685082f65ad6ca27e856.png)'
  prefs: []
  type: TYPE_IMG
- en: Graph coloring integer programming model. (Image by the author).
  prefs: []
  type: TYPE_NORMAL
- en: Without further ado, let us import *pyomo* for the Integer Programming model.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two approaches for modeling a problem in *pyomo*: *Abstract* and
    *Concrete* models. In the first approach, the algebraic expressions of the problem
    are defined before some data values are supplied, whereas, in the second, the
    model instance is created immediately as its elements are defined. You can find
    more about these approaches in the [library documentation](https://pyomo.readthedocs.io/en/stable/pyomo_overview/abstract_concrete.html)
    or in the book by Bynum et al. (2021). Throughout this article, we will adopt
    the *Concrete* model formulation.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Then, let us instantiate our *Sets*. Parsing the iterables directly from `dsatur`
    attributes `N` and `C` is valid, so one could use them in the `initialize` keyword
    arguments. Alternatively, I will pass the original *nodes* and *edges* from our
    input data and create a range from the *DSatur* as our initialization for colors.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Next, we instantiate our decision variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: And then our constraints.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can try and include other symmetry-breaking constraints and see what works
    better with your available solver. In some experiments I performed, including
    a preference order using total nodes assigned to a given color has been worse
    than ignoring it. Possibly due to the solver’s native symmetry-breaking strategies.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: At last, the objective…
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: And our model is ready to be solved! To do that I’m using the HiGHS persistent
    solver, which is available in *pyomo* in case *highspy* is also installed in your
    Python environment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: For large instances, our solver might have a hard time trying to improve heuristic
    solutions. However, for a 32-node instance available in the [code repository](https://github.com/bruscalia/optimization-demo-files/tree/1fa7a3825421d0b166195d890f2629c576cfbfda/graph-coloring),
    the solver was able to reduce the number of used colors from 9 to 8\. Worth mentioning
    that it took 24 seconds to complete execution whereas the *DSatur* algorithm for
    the same instance took only 6 milliseconds (using pure Python, which is an interpreted
    language).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/262d463424737ab0f54c1ddb5159a143.png)'
  prefs: []
  type: TYPE_IMG
- en: Graph coloring integer programming solution for 32 nodes instance. (Image by
    the author).
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although *DSatur* is an intuitive heuristic that provides fast good quality
    solutions, others might lead to better results, especially on complex instances.
    One of the most famous metaheuristics for the Graph Coloring Problem is *Tabucol*
    (Hertz & Werra, 1987). The authors propose a method that starts from an initial
    solution with *k* colors and possibly edges connecting nodes of the same color.
    Then, local moves changing the color of a given node are performed in a sense
    that minimizes violations, using a Tabu List to escape local optima.
  prefs: []
  type: TYPE_NORMAL
- en: More efficient exact methods for the Graph Coloring Problem than the one herein
    presented rely on *Column Generation*, using an algorithm denoted as *Branch &
    Price*. The reader interested in an introduction to the subject might find a concise
    overview in my other Medium story.
  prefs: []
  type: TYPE_NORMAL
- en: '[](/column-generation-in-linear-programming-and-the-cutting-stock-problem-3c697caf4e2b?source=post_page-----169dce4d88ab--------------------------------)
    [## Column Generation in Linear Programming and the Cutting Stock Problem'
  prefs: []
  type: TYPE_NORMAL
- en: How to solve linear problems with a large number of decision variables illustrated
    with a Python example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/column-generation-in-linear-programming-and-the-cutting-stock-problem-3c697caf4e2b?source=post_page-----169dce4d88ab--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Conclusions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this article, two approaches for solving the Graph Coloring Problem were
    presented: The constructive heuristic *DSatur* (Brélaz, 1979) and an Integer Linear
    Programming (ILP) model. The heuristic was able to provide fast good quality solutions
    for a moderate size instance, of which the solution was further improved using
    the ILP model. The code implemented is available for further use in a public repository.'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Brélaz, D., 1979\. New methods to color the vertices of a graph. *Communications
    of the ACM*, *22*(4), 251–256.
  prefs: []
  type: TYPE_NORMAL
- en: Bynum, M. L. et al., 2021\. *Pyomo-optimization modeling in Python.* Springer.
  prefs: []
  type: TYPE_NORMAL
- en: Hertz, A., & Werra, D. D., 1987\. Using tabu search techniques for graph coloring.
    *Computing*, *39*(4), 345–351.
  prefs: []
  type: TYPE_NORMAL
- en: Jensen, T. R., & Toft, B., 1995\. *Graph coloring problems*. John Wiley & Sons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lewis, R.M.R., 2021\. Advanced Techniques for Graph Colouring. In: *Guide to
    Graph Colouring*. Texts in Computer Science. Springer, Cham. [https://doi.org/10.1007/978-3-030-81054-2_4](https://doi.org/10.1007/978-3-030-81054-2_4)'
  prefs: []
  type: TYPE_NORMAL
