- en: 'Pandas: apply, map or transform?'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/pandas-apply-map-or-transform-dd931659e9cf?source=collection_archive---------3-----------------------#2023-01-31](https://towardsdatascience.com/pandas-apply-map-or-transform-dd931659e9cf?source=collection_archive---------3-----------------------#2023-01-31)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A guide to Pandas’ most versatile function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://polaris000.medium.com/?source=post_page-----dd931659e9cf--------------------------------)[![Aniruddha
    Karajgi](../Images/c18d7866d393d73faa110f256a31724c.png)](https://polaris000.medium.com/?source=post_page-----dd931659e9cf--------------------------------)[](https://towardsdatascience.com/?source=post_page-----dd931659e9cf--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----dd931659e9cf--------------------------------)
    [Aniruddha Karajgi](https://polaris000.medium.com/?source=post_page-----dd931659e9cf--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fdda13b3bf503&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fpandas-apply-map-or-transform-dd931659e9cf&user=Aniruddha+Karajgi&userId=dda13b3bf503&source=post_page-dda13b3bf503----dd931659e9cf---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----dd931659e9cf--------------------------------)
    ·9 min read·Jan 31, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fdd931659e9cf&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fpandas-apply-map-or-transform-dd931659e9cf&user=Aniruddha+Karajgi&userId=dda13b3bf503&source=-----dd931659e9cf---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fdd931659e9cf&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fpandas-apply-map-or-transform-dd931659e9cf&source=-----dd931659e9cf---------------------bookmark_footer-----------)![](../Images/df9f78e2b1a64fcd26be282f5c67f91a.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Photo by [Sid Balachandran](https://unsplash.com/@itookthose?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: As someone who’s been using Pandas for a few years now, I’ve noticed how many
    people (myself included) often resort to almost always using the `**apply**`function.
    While this isn’t an issue on smaller datasets, the performance issues caused by
    this become a lot more noticeable when working with larger amounts of data. While
    `**apply**`’s flexibility makes it an easy choice, this article introduces other
    Pandas' functions as potential alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: In this post, we’ll discuss the intended use for `**apply**`, `**agg**`, `**map**`
    and `**transform**`, with a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: Table of contents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: An Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s take a data frame comprising the scores of three students in two subjects.
    We’ll work with this example as we go.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We’ll now concatenate these to create a single dataframe.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Our final dataframe looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b683eae8e31437fe7df7eaa86f47cbd6.png)'
  prefs: []
  type: TYPE_IMG
- en: The example dataframe
  prefs: []
  type: TYPE_NORMAL
- en: We’ll explore the use of each function using this dataset.
  prefs: []
  type: TYPE_NORMAL
- en: map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `**map**` method works on a `Series` and maps each value based on what is
    passed as `arg` to the function. `arg` can be a function — just like what `apply`
    could take — but it can also be a dictionary or a series.
  prefs: []
  type: TYPE_NORMAL
- en: The `na_action` essentially lets you decide what happens to `NaN` values if
    they exist in the series. When set to `"ignore”` , `arg` won’t be applied to `NaN`
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'For eg, if you wanted to replace categorical values in your series using a
    mapping, you could do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as expected: it returns a mapped value corresponding to each
    element in our original series.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/992bbf594153524a6605a5c8de908dae.png)'
  prefs: []
  type: TYPE_IMG
- en: The output of map
  prefs: []
  type: TYPE_NORMAL
- en: Though `**apply**` doesn’t accept a dictionary, this can be still be accomplished
    with it, but it's not nearly as efficient or elegant.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/992bbf594153524a6605a5c8de908dae.png)'
  prefs: []
  type: TYPE_IMG
- en: The output of apply is identical to that of map
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance**'
  prefs: []
  type: TYPE_NORMAL
- en: On a simple test of encoding a gender series with a million records, `**map**`
    was **10x faster** than `**apply**`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Since `**map**`can take functions as well, any kind of transformation that doesn’t
    depend on other elements — unlike an aggregation like mean, for example — can
    be passed.
  prefs: []
  type: TYPE_NORMAL
- en: Using things like `map(len)` or `map(upper)` can really make preprocessing much
    easier.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assign this gender encoding result back to our data frame and move on
    to `**applymap**`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/62dea9888b1557c683cad41b4d1d1e6a.png)'
  prefs: []
  type: TYPE_IMG
- en: Encoding the gender with map
  prefs: []
  type: TYPE_NORMAL
- en: '`applymap`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: I won’t spend too long on `**applymap**` since it’s very similar to `**map**`
    and is internally implemented using `**apply**`. `**applymap**`works elementwise
    on a dataframe, just like what `**map**` does, but since it’s internally implemented
    with `**apply**` , it can’t take a dictionary or a Series as input — only functions
    are allowed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`na_action` works just like it does in `**map**`**.**'
  prefs: []
  type: TYPE_NORMAL
- en: transform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: While the previous two functions worked at the element level, transform works
    at the column level. This means that you can make use of aggregating logic with
    `**transform**` **.**
  prefs: []
  type: TYPE_NORMAL
- en: Let’s continue working with the same dataframe as before.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8199ccdd5f21b75b1efb60c2bfadc502.png)'
  prefs: []
  type: TYPE_IMG
- en: Our example, with the encoded gender
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we wanted to standardize our data. We could do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: What we’re essentially doing is taking the score series from each group, and
    replacing each element with its standardized value. This can’t be done with `**map**`,
    since it requires column-wise computation while `map` only works element-wise.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re familiar with `**apply**`, you’ll know that this behavior can also
    be implemented with it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We get essentially the same thing. Then what’s the point of using `**transform**`?
  prefs: []
  type: TYPE_NORMAL
- en: '`**transform**` must return a dataframe with the same length along the axis
    that it’s applied.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Remember that `**transform**` must return a dataframe with the same length along
    the axis it's applied on. What this means is that even if `**transform**` is used
    with a `groupby` operation that returns aggregate values, it assigns those aggregate
    values to each element.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s say we wanted to know the sum of the scores of all students
    for each subject. We could do this with apply like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'But here, we’ve aggregated scores by subject lost information on how individual
    students and their scores relate. If we tried doing the same thing with `**transform**`
    , we’ll get something a lot more interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: So though we worked at a group level, we were still able to keep track of how
    group-level information relates to row-level information.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this behavior, `**transform**`throws a `ValueError` if your logic
    doesn’t return a transformed series. So any kind of aggregation wouldn’t work.
    `**apply**`‘s flexibility, however, ensures that it works just fine even with
    aggregations, as we’ll see in detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '**Performance**'
  prefs: []
  type: TYPE_NORMAL
- en: In terms of performance, there’s a **2x speedup** on switching from `**apply**`
    to `**transform**`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/4ed25e8f3954e05faa39336e0c3e2fe7.png)'
  prefs: []
  type: TYPE_IMG
- en: A 1M row dataframe for testing transform’s performance
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: agg
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `**agg**` function is a lot easier to understand since it simply returns
    an aggregate over the data that’s passed to it. So regardless of how your custom
    aggregator is implemented, the result will be a single value for each column that’s
    passed to it.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll now look at a simple aggregation — computing each group's mean over the
    `score` column. Notice how we can pass in a positional argument to `**agg**`todirectly
    name the aggregated result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/817a2bf9b509f58bba2cfad958108104.png)'
  prefs: []
  type: TYPE_IMG
- en: Mean scores by subject using agg
  prefs: []
  type: TYPE_NORMAL
- en: Multiple aggregators can be passed as a list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/c5bda0afb3b584ef861e856bf33185c3.png)'
  prefs: []
  type: TYPE_IMG
- en: Mean scores by subject using apply — identical to our previous result.
  prefs: []
  type: TYPE_NORMAL
- en: '`**agg**`offers a lot more options to perform aggregations. In the previous
    two examples, we saw that it lets you perform multiple aggregations in a list
    and even named aggregations. You can also build custom aggregators as well as
    perform multiple specific aggregations over each column, like calculating the
    mean on one column and median on another.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance**'
  prefs: []
  type: TYPE_NORMAL
- en: In terms of performance, `**agg**` is moderately faster than `**apply**` , at
    least for simple aggregations. Let’s recreate the same dataframe from the previous
    performance test.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/4ed25e8f3954e05faa39336e0c3e2fe7.png)'
  prefs: []
  type: TYPE_IMG
- en: The same dataframe as before, for performance testing
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We see an approximately 30% boost in performance when using `**agg**` over `**apply**`.
    When testing over multiple aggregations, we get similar results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: apply
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For me, this was the most confusing one out of the ones we’ve discussed, mainly
    due to how flexible it is. Each of the examples above can be replicated with `**apply**`
    as we just saw**.**
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, this flexibility comes at a cost: it''s noticeably slower, as demonstrated
    by our performance tests.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a2ef3dd4188a0a81f29b4c08993cde3c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Performance Tests: the apply function is noticeably slower, and understandably
    so.'
  prefs: []
  type: TYPE_NORMAL
- en: Unexpected behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The other issue with `**apply**` ‘s flexibility is that the result is sometimes
    surprising.
  prefs: []
  type: TYPE_NORMAL
- en: '**Processing the first group twice**'
  prefs: []
  type: TYPE_NORMAL
- en: 'One such issue, which is now resolved, was with regard to certain performance
    optimizations: `**apply**` would process the first group twice. The first time,
    it would look for optimizations, and then it would process each group, thus processing
    the first group twice.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I first noticed this while debugging a custom apply function I had written:
    when I printed out the group’s information, the first group was displayed twice.
    This behavior would lead to silent errors if there were any side effects since
    any updates would happen twice on the first group.'
  prefs: []
  type: TYPE_NORMAL
- en: '**When there’s only a single group**'
  prefs: []
  type: TYPE_NORMAL
- en: This issue has been plaguing pandas since at least 2014\. It happens when there’s
    only a single group in the entire column. In such a scenario, even though the
    `**apply**` function is expected to return a series, it ends up yielding a dataframe.
  prefs: []
  type: TYPE_NORMAL
- en: The result is similar to an additional unstacking operation. Let’s try and reproduce
    it. We’ll use our original dataframe and add a `city` column. Let’s assume that
    all of our three students, John, James, and Jennifer are from Boston.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/22ec8de50f88ccef6ec97f9854c90960.png)'
  prefs: []
  type: TYPE_IMG
- en: Our dataframe with the additional “city” column added
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s calculate the group-wise mean for two sets of groups: one based
    on the `subject` column, and the other on `city`.'
  prefs: []
  type: TYPE_NORMAL
- en: Grouping on the `subject` column, we get a multi-indexed series as we’d expect.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/06750b6e1663ead794976f588a9c2df7.png)'
  prefs: []
  type: TYPE_IMG
- en: apply returns a multi-indexed series when there are multiple groups
  prefs: []
  type: TYPE_NORMAL
- en: 'But when we group by the `city` column, which as we know has only one group
    (corresponding to `“Boston”`), we get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/f29dba40e086f13774cb83cc9e018d6b.png)'
  prefs: []
  type: TYPE_IMG
- en: apply returns an unstacked dataframe when there’s only one group
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the result is pivoted? If we `**stack**` this, we’ll get back the
    expected result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/467416b6a3ee7c32164ea5bdfc3df1de.png)'
  prefs: []
  type: TYPE_IMG
- en: Stacking our previous result yields an expected result
  prefs: []
  type: TYPE_NORMAL
- en: As of this writing, this issue still hasn’t been fixed.
  prefs: []
  type: TYPE_NORMAL
- en: Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the entire code along with the performance tests here.
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://github.com/Polaris000/BlogCode/tree/main/PandasApply?source=post_page-----dd931659e9cf--------------------------------)
    [## BlogCode/PandasApply at main · Polaris000/BlogCode'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the example code used in my blog post Pandas: apply, map, or transform?
    The blog post discusses Pandas''…'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: github.com](https://github.com/Polaris000/BlogCode/tree/main/PandasApply?source=post_page-----dd931659e9cf--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The flexibility that `**apply**`providesmakes it a very convenient choice in
    most scenarios, but as we saw, it's often more efficient to use something that’s
    been designed for what you need to accomplish. This post covers only part of `**apply**`
    ‘s story, and there’s so much more to this function. A future post will continue
    from here.
  prefs: []
  type: TYPE_NORMAL
- en: This post should have given you an idea of what’s possible with Pandas, and
    I hope this encourages you to make full use of its functionality.
  prefs: []
  type: TYPE_NORMAL
