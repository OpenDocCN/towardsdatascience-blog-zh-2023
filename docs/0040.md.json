["```py\nclass Heap:\n\n    def _swap(self, i, j):\n        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]\n\n    def _number_of_children(self, i):\n        if 2 * i + 2 < len(self.heap):\n            return 2\n        if 2 * i + 1 < len(self.heap):\n            return 1\n        return 0\n```", "```py\nclass Heap:\n\n    def insert(self, value):\n        self.heap.append(value)\n        self._heapify_up(len(self.heap) - 1)\n\n    def _heapify_up(self, i):\n        if i != 0:\n            parent_index = (i - 1) // 2\n            if self.heap[i] < self.heap[parent_index]:\n                self.swap(i, parent_index)\n                self._heapify_up(parent_index)\n\n    # ... #\n```", "```py\nclass Heap:\n\n    def build(self, array):\n        self.heap = []\n        for value in array:\n            self.insert(value)\n\n   # ... #\n```", "```py\nclass Heap:    \n\n    def extract_min(self):\n        self._swap(0, len(self.heap) - 1)\n        min_element = self.heap.pop()\n        self._heapify_down(0)\n        return min_element\n\n    def _heapify_down(self, i):\n    if self._number_of_children(i) == 2:\n        if self.heap[i] > self.heap[2 * i + 1] or self.heap[i] > self.heap[2 * i + 2]:\n            if self.heap[2 * i + 1] < self.heap[2 * i + 2]:\n                self._swap(i, 2 * i + 1)\n                self._heapify_down(2 * i + 1)\n            else:\n                self._swap(i, 2 * i + 2)\n                self._heapify_down(2 * i + 2)\n    elif self._number_of_children(i) == 1 and self.heap[i] > self.heap[2 * i + 1]:\n        self._swap(i, 2 * i + 1)\n        self._heapify_down(2 * i + 1)\n\n    # ... #\n```", "```py\nclass Heap:\n\n    def sort(self):\n        array = []\n        while len(self.heap) > 0:\n            array.append(self.extract_min())\n        return array\n\n    # ... #\n```", "```py\nclass Heap:\n\n    def __init__(self, array):\n        self.build(array)\n\n    def build(self, array):\n        self.heap = []\n        for value in array:\n            self.insert(value)\n\n    def insert(self, value):\n        self.heap.append(value)\n        self._heapify_up(len(self.heap) - 1)\n\n    def sort(self):\n        array = []\n        while len(self.heap) > 0:\n            array.append(self.extract_min())\n        return array\n\n    def extract_min(self):\n        self._swap(0, len(self.heap) - 1)\n        min_element = self.heap.pop()\n        self._heapify_down(0)\n        return min_element\n\n    def _swap(self, i, j):\n        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]\n\n    def _number_of_children(self, i):\n        if 2 * i + 2 < len(self.heap):\n            return 2\n        if 2 * i + 1 < len(self.heap):\n            return 1\n        return 0\n\n    def _heapify_down(self, i):\n        if self._number_of_children(i) == 2:\n            if self.heap[i] > self.heap[2 * i + 1] or self.heap[i] > self.heap[2 * i + 2]:\n                if self.heap[2 * i + 1] < self.heap[2 * i + 2]:\n                    self._swap(i, 2 * i + 1)\n                    self._heapify_down(2 * i + 1)\n                else:\n                    self._swap(i, 2 * i + 2)\n                    self._heapify_down(2 * i + 2)\n        elif self._number_of_children(i) == 1 and self.heap[i] > self.heap[2 * i + 1]:\n            self._swap(i, 2 * i + 1)\n            self._heapify_down(2 * i + 1)\n\n    def _heapify_up(self, i):\n        if i != 0:\n            parent_index = (i - 1) // 2\n            if self.heap[i] < self.heap[parent_index]:\n                self._swap(i, parent_index)\n                self._heapify_up(parent_index)\n```", "```py\narray = [14, 8, 1, 12, 6, 20, 7, 10, 18, 4, 5, 15]\nheap = Heap(array)\nsorted_array = heap.sort()\nprint(sorted_array) # [1, 4, 5, 6, 7, 8, 10, 12, 14, 15, 18, 20]\n```"]