["```py\nimport tensorflow as tf\n\nclass WeightedCrossEntropy(tf.keras.losses.Loss):\n    def __init__(self, weight, epsilon=1e-7, name=\"weighted_cross_entropy\", **kwargs):\n        super().__init__(name=name, **kwargs)\n        self.weight = weight\n        self.epsilon = epsilon\n\n    def call(self, y_true, y_pred):\n        y_pred = tf.clip_by_value(y_pred, self.epsilon, 1 - self.epsilon)\n        loss = -(self.weight * y_true * tf.math.log(y_pred) + (1 - y_true) * tf.math.log(1 - y_pred))\n        return tf.math.reduce_mean(loss)\n\n    def get_config(self):\n        config = {\n            'weight': self.weight,\n            'epsilon': self.epsilon\n        }\n        base_config = super().get_config()\n        return {**base_config, **config}\n```", "```py\nmodel = tf.keras.Sequential()\n# add layers to your model\n...\nmodel.compile(optimizer='adam', loss=WeightedCrossEntropy(weight=0.8), metrics=['accuracy'])\n```", "```py\nimport tensorflow as tf\n\nclass WeightedCrossEntropy(tf.keras.losses.Loss):\n    def __init__(self, weight, epsilon=1e-7, name=\"weighted_cross_entropy\", **kwargs):\n        super().__init__(name=name, **kwargs)\n        self.weight = weight\n        self.epsilon = epsilon\n\n    def call(self, y_true, y_pred):\n        y_pred = tf.clip_by_value(y_pred, self.epsilon, 1 - self.epsilon)\n        loss = -(self.weight * y_true * tf.math.log(y_pred) + (1 - y_true) * tf.math.log(1 - y_pred))\n        return tf.math.reduce_mean(loss)\n\n    def get_config(self):\n        config = {\n            'weight': self.weight,\n            'epsilon': self.epsilon\n        }\n        base_config = super().get_config()\n        return {**base_config, **config}\n\n(x_train, y_train), (x_test, y_test) = tf.keras.datasets.mnist.load_data()\n\n# Normalize data\nx_train = x_train.astype('float32') / 255\nx_test = x_test.astype('float32') / 255\n\n# one-hot encode the target variables\ny_train = tf.keras.utils.to_categorical(y_train, 10)\ny_test = tf.keras.utils.to_categorical(y_test, 10)\n\nmodel = tf.keras.Sequential([\n    tf.keras.layers.Flatten(input_shape=(28, 28)),\n    tf.keras.layers.Dense(256, activation='relu'),\n    tf.keras.layers.Dropout(0.2),\n    tf.keras.layers.Dense(10, activation='softmax')\n])\n\n# Determine the weight for the custom loss function\ny_train_integers = tf.argmax(y_train,axis=-1)\nweight = 1 - y_train_integers.numpy().tolist().count(0) / len(y_train_integers)\n\nloss_fn = WeightedCrossEntropy(weight=weight)\nmodel.compile(optimizer='adam', loss=loss_fn, metrics=['accuracy'])\n\n# Train the model\nmodel.fit(x_train, y_train, epochs=5, batch_size=64)\n```"]