- en: Learn Discrete Fourier Transform (DFT)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/learn-discrete-fourier-transform-dft-9f7a2df4bfe9?source=collection_archive---------1-----------------------#2023-02-08](https://towardsdatascience.com/learn-discrete-fourier-transform-dft-9f7a2df4bfe9?source=collection_archive---------1-----------------------#2023-02-08)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Mathematical and Coding Perspective
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@omar.ok1998?source=post_page-----9f7a2df4bfe9--------------------------------)[![Omar
    Alkousa](../Images/7598618abe8e8fa89f1d8a4bfc21f014.png)](https://medium.com/@omar.ok1998?source=post_page-----9f7a2df4bfe9--------------------------------)[](https://towardsdatascience.com/?source=post_page-----9f7a2df4bfe9--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----9f7a2df4bfe9--------------------------------)
    [Omar Alkousa](https://medium.com/@omar.ok1998?source=post_page-----9f7a2df4bfe9--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Ff8302b9534b5&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Flearn-discrete-fourier-transform-dft-9f7a2df4bfe9&user=Omar+Alkousa&userId=f8302b9534b5&source=post_page-f8302b9534b5----9f7a2df4bfe9---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----9f7a2df4bfe9--------------------------------)
    ·9 min read·Feb 8, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F9f7a2df4bfe9&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Flearn-discrete-fourier-transform-dft-9f7a2df4bfe9&user=Omar+Alkousa&userId=f8302b9534b5&source=-----9f7a2df4bfe9---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F9f7a2df4bfe9&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Flearn-discrete-fourier-transform-dft-9f7a2df4bfe9&source=-----9f7a2df4bfe9---------------------bookmark_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: Digital signal processing (DSP) is the computation of mathematical methods used
    to manipulate signal data [**[1]**](https://doi.org/10.1016/B978-0-08-097768-3.00011-8).
    One of the most important tools in digital signal processing is the Discrete Fourier
    Transform (DFT). It is usually used to produce a signal’s frequency-domain (spectral)
    representation [**[2]**](https://doi.org/10.1016/B978-0-08-099388-1.00003-0).
  prefs: []
  type: TYPE_NORMAL
- en: In this post, we will discuss how DFT works and how to implement it to output
    the spectrum of the signals.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/594f2523a70041ea1a41998107c6a17a.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Pawel Czerwinski](https://unsplash.com/@pawel_czerwinski?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Discrete Fourier Transform (DFT)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Fourier Transform is the mathematical backbone of the DFT and the main idea
    behind Spectral Decomposition which concludes that a signal is nothing but a sum
    of sinusoids of different frequency components [**[3]**](https://biblioteca.unisced.edu.mz/bitstream/123456789/1667/1/thinkdsp.pdf).
    Since all of the signal data we are working with are in digital form, a signal
    is a set of samples in the time domain. The Fourier transform on such discrete
    signals can be done using DFT, which can be used to switch back and forth between
    the time and the frequency domains. The time domain contains the samples of the
    signal, whereas the frequency domain represents the spectrum of the sinusoids
    that construct the signal [**[4]**](https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=da18cc0dc47a2e9f829bf752e86a985d0dcc22f3).
    The image below describes the relationship between time and frequency domains
    using DFT and IDFT.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/dea29cd62c42af7c9637c5322ea1417a.png)'
  prefs: []
  type: TYPE_IMG
- en: '**The relationship between time and frequency domains** [**[4]**](https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=da18cc0dc47a2e9f829bf752e86a985d0dcc22f3)**.**
    [Image by the Author]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mathematically speaking, if we have a signal (xn) with N samples, the DFT of
    this signal is defined as [**[5]**](https://pythonnumericalmethods.berkeley.edu/notebooks/chapter24.02-Discrete-Fourier-Transform.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/214d156d3d5f2f9ed97a0a8cb7ba0ebf.png)'
  prefs: []
  type: TYPE_IMG
- en: '**The DFT equation** [**[5]**](https://pythonnumericalmethods.berkeley.edu/notebooks/chapter24.02-Discrete-Fourier-Transform.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Where:**'
  prefs: []
  type: TYPE_NORMAL
- en: '***N***: Number of samples'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***n***: Current sample'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***k***: Current frequency where *k* ∈ [0, *N*−1]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***xn***: The sine value at sample n'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Xk***: The DFT which includes information on both amplitude and phase'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The output of the DFT (Xk) is an array of complex numbers that hold the information
    on the frequencies, amplitudes, and phases of sinusoids that construct the input
    signal. The first half of the DFT array (Xk) contains the positive frequency terms,
    while the second half contains the negative frequency terms. Also, when the input
    signal is only a real-valued signal, the first half is the conjugate of the second
    half of frequency terms and the spectrum is symmetric. So, we focus only on the
    first half (the positive frequency terms) in the case of real-valued signals [**[5]**](https://pythonnumericalmethods.berkeley.edu/notebooks/chapter24.02-Discrete-Fourier-Transform.html).
    The figure below represents each of the positive and the negative frequency terms
    in case the number of the input samples (N) is odd or even.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/00a15330ac0e57233632f31c7d9c8d4a.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Positive and negative frequency terms** [**[5]**](https://pythonnumericalmethods.berkeley.edu/notebooks/chapter24.02-Discrete-Fourier-Transform.html)**.**
    [Image by the Author]'
  prefs: []
  type: TYPE_NORMAL
- en: 'The amplitude and the phase of each sinusoid that adds up to construct the
    signal can be calculated from the complex array (Xk) as follows (Im, and Re, are
    for Imagery and Real parts of a complex number, respectively) [**[5]**](https://pythonnumericalmethods.berkeley.edu/notebooks/chapter24.02-Discrete-Fourier-Transform.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/236880cbf4eb467a4567a0a237e268b1.png)'
  prefs: []
  type: TYPE_IMG
- en: '**The amplitude and the phase information can be calculated from these equations**
    [**[5]**](https://pythonnumericalmethods.berkeley.edu/notebooks/chapter24.02-Discrete-Fourier-Transform.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s Code:'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will build a function that calculates DFT based on the first equation above.
    But first, we should generate the signal that we want to use as an input for DFT.
    We will generate a signal that is a sum of 3 sine waves with frequencies (1,20,10)Hz
    and amplitudes (3,1,0.5). The sampling rate will be 200 samples per second. For
    generating the signal, I used a class, Signal, that you can use as well following
    [**this GitHub gist**](https://gist.github.com/OmarAlkousa/4bd0bacb0ff976be4105777965854e06).
    You can easily generate any signal but I used this Signal class for more controllability.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**:'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The DFT and IDFT functions we will write below are released under the MIT license
    and all credits go to the authors of [**this book**](https://pythonnumericalmethods.berkeley.edu/notebooks/Index.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both of the functions we will discuss are just to understand what is the mathematics
    behind DFT and what is the output of such transform. In practical use, there are
    faster and more efficient algorithms that can calculate the Fourier Transform,
    Fast Fourier Transform (FFT), and its inverse.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Let’s get started…**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/5f8605af3acfa389493fe5d21456cf2b.png)'
  prefs: []
  type: TYPE_IMG
- en: '**The signal we generated using our class Signal.** [Image by the Author]'
  prefs: []
  type: TYPE_NORMAL
- en: Now we will build the DFT function to give us the sinusoids that construct the
    signal we generated above. Make sure to carefully read the comments on the code
    below as it helps you conduct the output of each line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/f63aa5d153d6a553676fab0bafb1a03d.png)'
  prefs: []
  type: TYPE_IMG
- en: '**The output of the DFT function is the spectrum of the signal.** [Image by
    the Author]'
  prefs: []
  type: TYPE_NORMAL
- en: The x-axis contains the frequency components that construct the signal. The
    y-axis represents the strength of each frequency component. The lowest frequency
    component in the spectrum is usually called the **Fundamental Frequency** and
    the frequency component with the largest amplitude is called the **Dominant Frequency**
    [**[3]**](https://biblioteca.unisced.edu.mz/bitstream/123456789/1667/1/thinkdsp.pdf).
    In our example above, the 1Hz frequency component is the fundamental and the dominant
    frequency.
  prefs: []
  type: TYPE_NORMAL
- en: We can notice the symmetry of the spectrum at half of the sampling rate (try
    different rates); this is usually called the **Folding Frequency**. When recording
    a real-world signal (f(t)) with FN as the highest frequency component, the folding
    frequency should never go below FN to retrieve all of the signal’s information.
    And that’s according to **Nyquist-Shannon Theorem** [**[5]**](https://pythonnumericalmethods.berkeley.edu/notebooks/chapter24.02-Discrete-Fourier-Transform.html).
  prefs: []
  type: TYPE_NORMAL
- en: We can get the actual amplitude of the spectrum by normalizing it to the number
    of input samples (N). But when we focus only on the first half of the spectrum,
    in case the input is a real-valued signal, we normalize the spectrum by N/2 [**[5]**](https://pythonnumericalmethods.berkeley.edu/notebooks/chapter24.02-Discrete-Fourier-Transform.html).
    The code below is to normalize the first half of the spectrum [0, N/2] and to
    plot the spectrum.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/3091c9f902374cc409ec68260f254e1c.png)'
  prefs: []
  type: TYPE_IMG
- en: '**The spectrum of the signal after the normalization.** [Image by the Author]'
  prefs: []
  type: TYPE_NORMAL
- en: Inverse Discrete Fourier Transform (IDFT)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similarly, as you can go from the time domain to the frequency domain, you
    can get back from the frequency domain to the time domain using the Inverse Discrete
    Fourier Transform. This process is very useful in signal processing when you want
    to filter specific frequency components from the signal using DFT and then retrieve
    the signal back to its time domain using IDFT. The IDFT can be calculated from
    the Xk sequence following the equation [**[5]**](https://pythonnumericalmethods.berkeley.edu/notebooks/chapter24.02-Discrete-Fourier-Transform.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/faab5118486d3213448af511311db326.png)'
  prefs: []
  type: TYPE_IMG
- en: '**IDFT equation** [**[5]**](https://pythonnumericalmethods.berkeley.edu/notebooks/chapter24.02-Discrete-Fourier-Transform.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s build a function that can calculate the IDFT using the equation above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/f04ce306a6163dae28c2edd44d88be8a.png)'
  prefs: []
  type: TYPE_IMG
- en: '**The signal retrieved by the IDFT function and the original signal are the
    same.** [Image by the Author]'
  prefs: []
  type: TYPE_NORMAL
- en: The limit of DFT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the case of a signal with a big number of samples, the execution time of
    the DFT function will be long to apply the Fourier Transform on all of the data
    points of the signal. Fortunately, an efficient algorithm to calculate the DFT
    of the signal has been developed, the Fast Fourier Transform (FFT). This algorithm
    reduces the execution complexity from O(N²) to only O(NlogN), where N is the size
    of the data. The significant reduction of computation complexity by using FFT
    allows the wide use of Fourier Transform in engineering, science, and mathematics
    fields [**[5]**](https://pythonnumericalmethods.berkeley.edu/notebooks/chapter24.02-Discrete-Fourier-Transform.html).
  prefs: []
  type: TYPE_NORMAL
- en: Python provides multiple functionalities that the user can use to apply Fourier
    Transform using Numpy or Scipy python packages. The code below represents the
    comparison of time execution using the DFT function we built above, the FFT using
    the Numpy package [**[6]**](https://numpy.org/doc/stable/reference/generated/numpy.fft.fft.html),
    and the FFT Scipy package [**[7]**](https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.fft.html).
    Using FFT from the Scipy package was the fastest.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve learned how useful the Fourier Transform is in the signal processing field.
    And we’ve understood the main idea behind it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ve pointed out the mathematical perspective of the Discrete Fourier Transform
    and how it can be calculated for a discrete signal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ve built a function that calculates the DFT using the mathematical equation
    and we applied the function to a signal we generated using a class Signal we’ve
    built in this previous post.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ve learned that the output of the DFT is an array of complex numbers with
    N number of elements, the same as the number of samples of the input signal. These
    complex numbers hold information on the amplitude and the phase of the spectrum.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ve seen that the output of the DFT will be symmetrical to half of the sampling
    rate if the input signal is a real-value signal. And this is why we focus only
    on the positive frequency components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An equation to calculate the Inverse Discrete Fourier Transform, IDFT, has been
    pointed out. And we’ve built a function to calculate the IDFT to retrieve the
    original signal from the spectrum.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ve discussed the limitation of the functions we’ve built and there is an
    efficient algorithm to calculate the Fourier transforms, Fast Fourier Transform.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[**[1]**](https://doi.org/10.1016/B978-0-08-097768-3.00011-8) R. Toulson, R.,
    & Wilmshurst, T. (2012). An Introduction to Digital Signal Processing. *Fast and
    Effective Embedded Systems Design* (pp. 219–242). Elsevier. [https://doi.org/10.1016/B978-0-08-097768-3.00011-8](https://doi.org/10.1016/B978-0-08-097768-3.00011-8)'
  prefs: []
  type: TYPE_NORMAL
- en: '[**[2]**](https://doi.org/10.1016/B978-0-08-099388-1.00003-0) T. Giannakopoulos,
    T., & Pikrakis, A. (2014). Signal Transforms and Filtering Essentials. *Introduction
    to Audio Analysis* (pp. 33–57). Elsevier. [https://doi.org/10.1016/B978-0-08-099388-1.00003-0](https://doi.org/10.1016/B978-0-08-099388-1.00003-0)'
  prefs: []
  type: TYPE_NORMAL
- en: '[**[3]**](https://biblioteca.unisced.edu.mz/bitstream/123456789/1667/1/thinkdsp.pdf)
    Downey, A. (2016). Sounds and Signals. *Think DSP: Digital signal processing in
    Python* (pp. 1–11). (First edition). O’Reilly Media, Inc.'
  prefs: []
  type: TYPE_NORMAL
- en: '[**[4]**](https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=da18cc0dc47a2e9f829bf752e86a985d0dcc22f3)
    Thakur, B., & Mehra, R. (2016). Discrete Fourier Transform Analysis with Different
    Window Techniques Algorithm. *International Journal of Computer Applications*,
    975, 8887.'
  prefs: []
  type: TYPE_NORMAL
- en: '[**[5]**](https://pythonnumericalmethods.berkeley.edu/notebooks/chapter24.02-Discrete-Fourier-Transform.html)
    Kong, Q., Siauw, T., & Bayen, A. (2020). Fourier Transform. *Python programming
    and numerical methods: A guide for engineers and scientists* (pp. 415–444). Academic
    Press.'
  prefs: []
  type: TYPE_NORMAL
- en: '[**[6]**](https://numpy.org/doc/stable/reference/generated/numpy.fft.fft.html)
    Numpy Documentation, API Reference, Discrete Fourier Transform (numpy.fft). [Accessed
    on 2/2/2023]'
  prefs: []
  type: TYPE_NORMAL
- en: '[**[7]**](https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.fft.html)
    Scipy Documentation, API Reference, Legacy discrete Fourier transform (scipy.fftpack).
    [Accessed on 2/2/2023]'
  prefs: []
  type: TYPE_NORMAL
