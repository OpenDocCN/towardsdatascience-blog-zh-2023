- en: Nine Rules for Creating Fast, Safe, and Compatible Data Structures in Rust (Part
    2)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/nine-rules-for-creating-fast-safe-and-compatible-data-structures-in-rust-part-2-da5e6961a0b7?source=collection_archive---------8-----------------------#2023-04-12](https://towardsdatascience.com/nine-rules-for-creating-fast-safe-and-compatible-data-structures-in-rust-part-2-da5e6961a0b7?source=collection_archive---------8-----------------------#2023-04-12)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Lessons from RangeSetBlaze
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@carlmkadie?source=post_page-----da5e6961a0b7--------------------------------)[![Carl
    M. Kadie](../Images/9dbe27c76e9567136e5a7dc587f1fb15.png)](https://medium.com/@carlmkadie?source=post_page-----da5e6961a0b7--------------------------------)[](https://towardsdatascience.com/?source=post_page-----da5e6961a0b7--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----da5e6961a0b7--------------------------------)
    [Carl M. Kadie](https://medium.com/@carlmkadie?source=post_page-----da5e6961a0b7--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: ·
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fa5e87027005f&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnine-rules-for-creating-fast-safe-and-compatible-data-structures-in-rust-part-2-da5e6961a0b7&user=Carl+M.+Kadie&userId=a5e87027005f&source=post_page-a5e87027005f----da5e6961a0b7---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----da5e6961a0b7--------------------------------)
    ·14 min read·Apr 12, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fda5e6961a0b7&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnine-rules-for-creating-fast-safe-and-compatible-data-structures-in-rust-part-2-da5e6961a0b7&user=Carl+M.+Kadie&userId=a5e87027005f&source=-----da5e6961a0b7---------------------clap_footer-----------)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fda5e6961a0b7&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnine-rules-for-creating-fast-safe-and-compatible-data-structures-in-rust-part-2-da5e6961a0b7&source=-----da5e6961a0b7---------------------bookmark_footer-----------)![](../Images/f0769b1a5bf56fdbbe9a841255f915a1.png)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'Storing numbers in a tree — Source: [Bing Image Creator](https://www.bing.com/create)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'This is Part 2 of an article about creating data structures in Rust. We’ll
    look at rules 6 to 9:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Define operators and fast operations.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7\. Follow the “Nine Rules of Good API Design” especially “write good documentation”.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8\. Optimize performance using representative data, Criterion Benchmarking,
    and profiling.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9\. Test coverage, docs, traits, compiler errors, and correctness.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [Part 1](https://medium.com/towards-data-science/nine-rules-for-creating-fast-safe-and-compatible-data-structures-in-rust-part-1-c0973092e0a3)
    for rules 1 to 5.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[第1部分](https://medium.com/towards-data-science/nine-rules-for-creating-fast-safe-and-compatible-data-structures-in-rust-part-1-c0973092e0a3)以获取规则1至5。
- en: Plagiarize your API, documentation, and even code — from the standard library.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抄袭你的API、文档，甚至代码——来自标准库。
- en: Design constructors for ease-of-use, compatibility, and speed.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计易于使用、兼容且高效的构造函数。
- en: Create more Rust iterators than you expect.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建比预期更多的Rust迭代器。
- en: Make illegal values unpresentable with traits.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用特性使非法值无法表示。
- en: Define generic iterators with guaranteed properties and useful methods.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义具有保证属性和有用方法的泛型迭代器。
- en: These rules are informed by my experience creating `[range-set-blaze](https://crates.io/crates/range-set-blaze)`,
    a new range-set crate. A range set is a data structure that represents sets of,
    for example, integers as sorted & disjoint ranges. For example, `0..=5, 10..=10`.
    Compared to other range-set crates, `range-set-blaze` offers a full collection
    of set operations and is performant.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则是根据我创建的新范围集合crate `[range-set-blaze](https://crates.io/crates/range-set-blaze)`的经验得出的。范围集合是一种数据结构，用于表示整数等集合，形式为排序且不重叠的范围。例如，`0..=5,
    10..=10`。与其他范围集合crate相比，`range-set-blaze`提供了完整的集合操作，并且性能优越。
- en: Let’s start by looking at how the crate offers set operations.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看这个crate如何提供集合操作。
- en: 'Rule 6: Define Operators and Fast Operations'
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则6：定义操作符和快速操作
- en: The standard `BTreeSet` offers set operators, for example, if `a` and `b` are
    each a `BTreeSet`, then `a | b` will be a `BTreeSet` of their union. Decide if
    operators make sense for your data structure. Operators can be logical such as
    `|`,`&`,`!` and/or arithmetic such as `+`,`-`,`*`,`/`,`^`. [This table](https://doc.rust-lang.org/book/appendix-02-operators.html)
    lists Rust’s “overloadable” operators and their method names.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的`BTreeSet`提供了集合操作符，例如，如果`a`和`b`都是`BTreeSet`，那么`a | b`将是它们并集的`BTreeSet`。决定操作符是否适合你的数据结构。操作符可以是逻辑操作符，例如`|`、`&`、`!`，和/或算术操作符，例如`+`、`-`、`*`、`/`、`^`。[这个表格](https://doc.rust-lang.org/book/appendix-02-operators.html)列出了Rust的“可重载”操作符及其方法名称。
- en: 'The `range-set-blaze` crate offers set-related operators on both the `RangeSetBlaze`
    struct:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`range-set-blaze` crate在`RangeSetBlaze`结构上提供了与集合相关的操作符：'
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'and any iterators implementing the `SortedDisjoint` trait (see Rule 5 in [Part
    1](https://medium.com/towards-data-science/nine-rules-for-creating-fast-safe-and-compatible-data-structures-in-rust-part-1-c0973092e0a3)):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以及任何实现了`SortedDisjoint`特性的迭代器（见[第1部分](https://medium.com/towards-data-science/nine-rules-for-creating-fast-safe-and-compatible-data-structures-in-rust-part-1-c0973092e0a3)中的规则5）：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`BitOr` is Rust’s method name for the `|` operator (again, see [table](https://doc.rust-lang.org/book/appendix-02-operators.html)).
    Here is the definition of the union operator on `RangeSetBlaze`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`BitOr`是Rust中`|`操作符的方法名称（再次见[表格](https://doc.rust-lang.org/book/appendix-02-operators.html)）。下面是`RangeSetBlaze`上并集操作符的定义：'
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This says that for all `RangeSetBlaze`, we define a `|` operator that takes
    a `RangeSetBlaze` as a second input and that returns a `RangeSetBlaze`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着对于所有的`RangeSetBlaze`，我们定义了一个`|`操作符，它接受一个`RangeSetBlaze`作为第二个输入，并返回一个`RangeSetBlaze`。
- en: '**Subrule #1: Support Borrowed Inputs**: The definition above lets users do
    `a | b`, but not `&a | &b`, `&a | b`, or `a | &b`. Those “borrow combinations”
    require three additional definitions of this form:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**子规则 #1：支持借用输入**：上述定义允许用户进行`a | b`操作，但不支持`&a | &b`、`&a | b`或`a | &b`。这些“借用组合”需要三个额外的定义，如下所示：'
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Alternatively, you can use the `[gen_ops](https://crates.io/crates/gen_ops)`
    crate. It lets you define all borrow combinations across multiple operators in
    one statement.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用`[gen_ops](https://crates.io/crates/gen_ops)` crate。它允许你在一个声明中定义多个操作符的所有借用组合。
- en: '**Subrule #2: Offer Operators on Traits (Kind of):** Set-related methods, such
    as `complement` and `union`, can be defined efficiently on our generic `SortedDisjoint`
    iterators. The methods run in one pass and require minimal memory. (In Rule 5
    in [Part 1](https://medium.com/towards-data-science/nine-rules-for-creating-fast-safe-and-compatible-data-structures-in-rust-part-1-c0973092e0a3),
    we saw the definition of `complement`.) Instead of `a.complement()`, however,
    we’d like to say `!a`. Can we? No and yes.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**子规则 #2：在特性上提供操作符（类似）：** 与集合相关的方法，如`complement`和`union`，可以在我们的泛型`SortedDisjoint`迭代器上高效地定义。这些方法在一次遍历中运行，并且需要的内存非常少。（在[第1部分](https://medium.com/towards-data-science/nine-rules-for-creating-fast-safe-and-compatible-data-structures-in-rust-part-1-c0973092e0a3)的规则5中，我们看到了`complement`的定义。）然而，我们希望使用`!a`来代替`a.complement()`。可以吗？可以，也不可以。'
- en: No, you can’t implement trait `ops::Not` (the `!` operator) on `SortedDisjoint`
    — [see Internet discussion](https://stackoverflow.com/questions/61108590/default-implementation-of-supertrait).
    (You could but should not make `ops::Not` a supertype of `SortedDisjoint`, because
    that would make it impossible to implement `SortedDisjoint` on outside types,
    such as `[Itertools::Tee](https://docs.rs/itertools/latest/itertools/trait.Itertools.html#method.tee)`.)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 不，你不能在`SortedDisjoint`上实现特征`ops::Not`（`!`运算符）——[参见互联网讨论](https://stackoverflow.com/questions/61108590/default-implementation-of-supertrait)。（你可以，但不应该使`ops::Not`成为`SortedDisjoint`的超类型，因为这将使在外部类型上实现`SortedDisjoint`变得不可能，例如`[Itertools::Tee](https://docs.rs/itertools/latest/itertools/trait.Itertools.html#method.tee)`。）
- en: 'You can and should, however, define the operators on as many of your own types
    as you can.For example, here is the implementation of `ops::Not` for `CheckSortedDisjoint`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以并且应该在尽可能多的自定义类型上定义这些运算符。例如，这里是`CheckSortedDisjoint`的`ops::Not`的实现：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'which lets us use `!` in this function:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们可以在这个函数中使用`!`：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Aside: This example function runs in constant time and memory.'
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 额外说明：这个示例函数运行在常量时间和内存中。
- en: '**Subrule #3: Exploit Ownership:** I originally did not support the `|=` (`BitOrAssign`)
    operator. I figured that if users wanted to union two `RangeSetBlaze` objects
    and put the results in the first, they could just write `a = a | b`.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**子规则 #3: 利用所有权：** 我最初不支持`|=`（`BitOrAssign`）运算符。我认为如果用户想将两个`RangeSetBlaze`对象进行并集并将结果放入第一个对象中，他们可以直接写`a
    = a | b`。'
- en: Later, however, I noticed a potential speed-up. Specifically, when the number
    of ranges in `b` is very small relative to `a`, we should add the ranges of `b`
    to `a`, one at a time, rather than merging together their two `ranges` iterators.
    So, I implemented the `BitOrAssign`. (I have no such speed-up for intersection,
    so I haven’t implemented `BitAndAssign`.)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，后来我发现了一个潜在的加速机会。具体来说，当`b`中的范围数量相对于`a`非常少时，我们应该一次一个地将`b`的范围添加到`a`中，而不是将它们的两个`ranges`迭代器合并在一起。因此，我实现了`BitOrAssign`。（我没有针对交集的加速方法，所以没有实现`BitAndAssign`。）
- en: 'But wait there is more! When a user calls `a | &b`, the operator owns the first
    input. This means the code can modify the first input in place (if it so desires)
    and return it as the result. Here is the definition of that operator:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等，还有更多！当用户调用`a | &b`时，运算符拥有第一个输入。这意味着代码可以在原地修改第一个输入（如果愿意的话）并将其作为结果返回。这是该运算符的定义：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: I ended up creating special, optimized implementations for `a | &b` and `a |
    b,` and `&a | b`. Rust even allowed me to optimize `&mut a |= b` both when `b`
    is smaller (as before) and when `a` is smaller (we put `a` into the owned `b`,
    one range at a time, and then assign `a` to `b`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我最终为`a | &b`和`a | b`以及`&a | b`创建了特殊的优化实现。Rust甚至允许我优化`&mut a |= b`，无论是`b`更小（如之前所述）还是`a`更小（我们将`a`放入拥有的`b`中，一次一个范围，然后将`a`赋值给`b`）。
- en: '**Subrule #4: Offer fast multiway operations:** We can define the intersection
    (operator `&`) of two `RangeSetBlaze` objects in terms the intersection of their
    `ranges:`'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**子规则 #4: 提供快速的多路操作：** 我们可以通过定义两个`RangeSetBlaze`对象的交集（运算符`&`）来实现对其`ranges`的交集。'
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And, thanks to the miracle of [Boolean algebra](https://en.wikipedia.org/wiki/Boolean_algebra),
    we can define the intersection of two `RangesIter` in terms of complement and
    union:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，得益于[布尔代数](https://en.wikipedia.org/wiki/Boolean_algebra)的奇迹，我们可以通过补集和并集来定义两个`RangesIter`的交集：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This gives us a constant-memory one-pass intersection for all `SortedDisjoint`
    iterators. (The same trick works for set difference. Symmetric difference requires
    two passes, but still only constant memory.)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这为所有`SortedDisjoint`迭代器提供了一个常量内存的一次性交集。（同样的技巧也适用于集合差异。对称差异需要两次遍历，但仍然只需要常量内存。）
- en: 'Aside: `BTreeSet` doesn’t offer `complement`. Why? Because its complement of,
    for example, `[0, 3, 4, 5, 10]` would require 4 billion entries. Range-based representations,
    however, store just 4 entries: `-2147483648..=-1, 1..=2, 6..=9, 11..=2147483647`.'
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 额外说明：`BTreeSet`不提供`complement`。为什么？因为例如`[0, 3, 4, 5, 10]`的补集将需要40亿个条目。然而，基于范围的表示法只存储4个条目：`-2147483648..=-1,
    1..=2, 6..=9, 11..=2147483647`。
- en: 'What about the intersection of more than two `RangeSetBlaze` objects? We could
    do them two at a time but that would create unnecessary intermediate objects.
    Instead, we can offer multiway intersection, so users can do this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 那么多个`RangeSetBlaze`对象的交集呢？我们可以一次做两个，但那样会产生不必要的中间对象。相反，我们可以提供多路交集功能，这样用户就可以这样做：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Multiway intersection is defined as a method on an iterator of `RangeSetBlaze`
    objects:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 多路交集被定义为对`RangeSetBlaze`对象的迭代器的一种方法：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Which calls a new multiway `SortedDisjoint` `intersection` and `union`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这调用了新的多路`SortedDisjoint` `intersection`和`union`：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Putting this all together, we get the ability to intersect any number of `RangeSetBlaze`
    objects in one-pass and with constant memory (plus the memory for the final `RangeSetBlaze`
    result).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些结合起来，我们能够在一次通过中交集任意数量的`RangeSetBlaze`对象，并且使用恒定的内存（加上最终`RangeSetBlaze`结果的内存）。
- en: '**Subrule #5: If needed, use** `**Box<dyn**` **…**`**>**` **types to offer
    multiway operations across different types:** Multiway operators on `SortedDisjoint`
    can have a problem. You can union inputs of the same type, here `RangesIter<T>`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**子规则 #5: 如有需要，使用** `**Box<dyn**` **…**`**>**` **类型在不同类型之间提供多路操作：** `SortedDisjoint`上的多路运算符可能会遇到问题。你可以对相同类型的输入进行并集，这里是`RangesIter<T>`：'
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: But not inputs of mixed type, here `NotIter<T, RangesIter<T>>` and `RangesIter<T>:`
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 但不能处理混合类型的输入，这里是`NotIter<T, RangesIter<T>>`和`RangesIter<T>`：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The fix is to wrap all the inputs in a new common type (details on [GitHub](https://github.com/CarlKCarlK/range-set-blaze/blob/main/src/dyn_sorted_disjoint.rs)):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是将所有输入封装在一个新的通用类型中（详细信息见[GitHub](https://github.com/CarlKCarlK/range-set-blaze/blob/main/src/dyn_sorted_disjoint.rs)）：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can use the new type either explicitly or via a macro.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以显式地使用新类型或通过宏来使用它。
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Rule 7: Follow the Nine Rules of Good API Design especially “Write Good Documentation”'
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '规则 7: 遵循九条良好 API 设计规则，特别是“编写良好文档”'
- en: 'All the rules from the article [Nine Rules for Elegant Rust Library APIs](/nine-rules-for-elegant-rust-library-apis-9b986a465247)
    apply. Here is a discussion of the most interesting six, starting with:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 文章[优雅的 Rust 库 API 的九条规则](/nine-rules-for-elegant-rust-library-apis-9b986a465247)中的所有规则都适用。这里讨论了最有趣的六条，首先是：
- en: Write good documentation to keep your design honest.
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写良好的文档以保持设计的诚实。
- en: Create examples that don’t embarrass you.
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 创建不会让你感到尴尬的示例。
- en: You should put `#![warn(missing_docs)]` in your `lib.rs`. This will remind you
    to write documentation for every public type, trait, and method. Include an example
    in (almost) every bit of documentation.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在你的`lib.rs`中加入`#![warn(missing_docs)]`。这将提醒你为每个公共类型、特性和方法编写文档。在（几乎）每一部分文档中包含一个示例。
- en: In one case, I got tired of writing warnings to users that some iterators should
    contain only sorted & disjoint ranges. This led me to Rule 5 and having the compiler
    enforce the needed guarantee.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个情况下，我厌倦了向用户警告某些迭代器应仅包含排序且不相交的范围。这使我回到规则5，并让编译器强制执行所需的保证。
- en: In another case, I found myself explaining in multiple places how to call union.
    Specifically, I told users to use the `extend` method with short second inputs
    and the `| (union)` operator, otherwise. I found this embarrassing to explain.
    This led me to offering a `|=` operator which always does the fastest thing.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个情况下，我发现自己在多个地方解释如何调用并集。具体来说，我告诉用户在短的第二输入和`| (union)`运算符的情况下使用`extend`方法。对此我感到解释很尴尬。这导致我提供了一个`|=`运算符，它总是做最快的事情。
- en: Use [Clippy](https://doc.rust-lang.org/stable/clippy/usage.html)
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用[Clippy](https://doc.rust-lang.org/stable/clippy/usage.html)
- en: This rule is important. I now take it for granted. So, use [Clippy](https://doc.rust-lang.org/stable/clippy/usage.html).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则很重要。我现在认为这是理所当然的。所以，使用[Clippy](https://doc.rust-lang.org/stable/clippy/usage.html)。
- en: Accept all types of types.
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 接受所有类型的类型。
- en: I mostly tried to follow this rule, but with one big exception. Although Rust
    offers [many range types](https://doc.rust-lang.org/reference/expressions/range-expr.html),
    I only accept ranges of the form `start..=end`. This not only simplifies the code,
    but I think it also simplifies the documentation and examples. (Given user requests,
    I’d revisit this.)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我主要尝试遵循这个规则，但有一个重大例外。虽然 Rust 提供了[许多范围类型](https://doc.rust-lang.org/reference/expressions/range-expr.html)，但我只接受`start..=end`形式的范围。这不仅简化了代码，而且我认为它也简化了文档和示例。（根据用户的请求，我会重新考虑这个问题。）
- en: Define and return nice errors.
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义并返回友好的错误信息。
- en: Surprisingly, this rule doesn’t come up much in many data structures. For example,
    the standard `BTreeSet` doesn’t return any results that might be errors. Likewise,
    `RangeSetBlaze` has a few places where it might panic — for example, if `CheckSortedDisjoint`
    finds a problem — but it never returns error results.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 出乎意料的是，这个规则在许多数据结构中并不常见。例如，标准的`BTreeSet`不会返回可能是错误的结果。同样，`RangeSetBlaze`在几个地方可能会引发恐慌——例如，如果`CheckSortedDisjoint`发现问题——但它从不返回错误结果。
- en: Know your users’ needs, ideally by eating your own dogfood.
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 了解用户的需求，最好通过使用自己的产品来了解。
- en: I feel bad that I didn’t follow this rule. I created `RangeSetBlaze` for fun.
    None of my current projects need it. I hope other folks will use it in their projects
    and give me feedback on what they need from it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我感到很遗憾没有遵循这个规则。我创建`RangeSetBlaze`是为了好玩。我的当前项目中没有需要它的地方。我希望其他人能够在他们的项目中使用它，并给我反馈他们需要什么。
- en: 'Rule 8: Optimize Performance using Representative Data, Criterion Benchmarking,
    and Profiling'
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 8：使用代表性数据、Criterion 基准测试和分析工具来优化性能
- en: 'Aside: The [latest version of the benchmark report](https://github.com/CarlKCarlK/range-set-blaze/blob/main/docs/bench.md)
    shows the most recent results, including comparisons with the popular Roaring
    Compressed Bitmaps.'
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附注： [基准测试报告的最新版本](https://github.com/CarlKCarlK/range-set-blaze/blob/main/docs/bench.md)显示了最新结果，包括与流行的
    Roaring 压缩位图的比较。
- en: '**Subrule #1: Use Representative Data:** On some data, `RangeSetBlaze` will
    be worse than the standard `HashSet` and `BTreeSet`. For example, its construction
    from random integers (uniform and with replacement) is about 2.5 times slower
    than `HashSet`''s. Here is a plot of construction time as a function of the number
    of random integers:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**子规则 #1：使用代表性数据：** 在某些数据上，`RangeSetBlaze`会比标准的`HashSet`和`BTreeSet`表现更差。例如，从随机整数（均匀且有替换）构造的速度大约比`HashSet`慢2.5倍。以下是构造时间与随机整数数量的关系图：'
- en: '![](../Images/09edd05de2bff783c9e533a2f9d5e3a2.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09edd05de2bff783c9e533a2f9d5e3a2.png)'
- en: But what if the integers are ‘clumpy’? For example, 12, 13, 14, 998, 999, 1000,
    1001, -333, -332, etc. To see, we’ll construct 1 million clumpy integers. We’ll
    vary the average clump size from 1 (no clumps) to 100K (ten big clumps). (For
    more details, see [Benchmarks for (some) Range-Related Rust Crate](https://github.com/CarlKCarlK/range-set-blaze/blob/main/docs/bench.md)s.)
    With this data, as clump sizes reach 100, `RangeSetBlaze` is 30 times faster than
    `HashTable` and 15 times faster than `BTreeSet`. And if we’re allowed to provide
    the clumps as ranges (instead of as individual integers), `RangeSetBlaze` is 700
    times faster than the standard data types when the clump size is 1000.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果整数是“聚集的”呢？例如，12、13、14、998、999、1000、1001、-333、-332等。为了查看，我们将构造100万个聚集的整数。我们将使平均聚集大小从1（没有聚集）变化到100K（十个大聚集）。（更多细节，请参见[（某些）范围相关的
    Rust Crate 基准测试](https://github.com/CarlKCarlK/range-set-blaze/blob/main/docs/bench.md)）。有了这些数据，当聚集大小达到100时，`RangeSetBlaze`比`HashTable`快30倍，比`BTreeSet`快15倍。如果我们可以将聚集作为范围（而不是单独的整数）提供，则当聚集大小为1000时，`RangeSetBlaze`比标准数据类型快700倍。
- en: '![](../Images/32f98d86f37b16ade7c3565eb2e6d2ed.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/32f98d86f37b16ade7c3565eb2e6d2ed.png)'
- en: 'The advice here is to test on data (either real or synthetic) that you believe
    to be interesting. For this project, I created “random clumpy integer iterators”
    with control over:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的建议是对你认为有趣的数据（无论是实际数据还是合成数据）进行测试。对于这个项目，我创建了“随机聚集整数迭代器”，并控制了以下内容：
- en: the span of the integers (for example, all integers will be in `0..=9_999_999`)
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数的范围（例如，所有整数都在`0..=9_999_999`中）
- en: number of integers (for example, 1 million)
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数的数量（例如，100万）
- en: the average clump size (for example, 100)
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平均聚集大小（例如，100）
- en: number of iterators (for example, 1)
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器的数量（例如，1）
- en: coverage, this is the fraction of the span expected to be covered by the iterators
    (unioned or intersected, if more than one) — (for example, 10% coverage).
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: coverage，这是期望由迭代器（如果有多个则取并集或交集）覆盖的范围的比例——（例如，10% coverage）。
- en: '**Subrule #2: Use the** [**Criterion crate**](https://docs.rs/criterion/latest/criterion/)
    **to benchmark programs in Rust:** Here are some tips:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**子规则 #2：使用** [**Criterion crate**](https://docs.rs/criterion/latest/criterion/)
    **在 Rust 中基准测试程序：** 以下是一些提示：'
- en: To get good HTML reports and excellent plots, put `criterion = { version = "`Current
    version`", features = ["html_reports"] }` in the `[dev-dependencies]` section
    of your `Cargo.toml`. (This instruction is currently [missing from the Criterion
    documentation](https://stackoverflow.com/questions/75808243/rust-criterion-wont-create-html-report).)
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获得良好的 HTML 报告和出色的图表，在你的`Cargo.toml`的`[dev-dependencies]`部分中加入`criterion = {
    version = "`当前版本`", features = ["html_reports"] }`。（此说明目前在[Criterion 文档中缺失](https://stackoverflow.com/questions/75808243/rust-criterion-wont-create-html-report)）。
- en: Put the following in your `Cargo.toml`. It declares a benchmark called “bench”
    with a 3rd party benchmarking harness, namely, Criterion.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的`Cargo.toml`中加入以下内容。它声明了一个名为“bench”的基准测试，使用第三方基准测试工具 Criterion。
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: At the top level of your project create folder `benches` and file `bench.rs`.
    Make the last line of the file `criterion_main!(benches);`
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在项目的顶层创建文件夹`benches`和文件`bench.rs`。文件的最后一行应为`criterion_main!(benches);`
- en: Create benchmarks as described in the [Criterion users guide](https://bheisler.github.io/criterion.rs/book/index.html).
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据 [Criterion 用户指南](https://bheisler.github.io/criterion.rs/book/index.html)
    中的描述创建基准测试。
- en: Don’t fight Criterion. It may complain that your benchmarks are too slow. If
    you can, listen to it and make them faster. This lets it generate better statistics.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要和 Criterion 抵触。它可能会抱怨你的基准测试太慢。如果可以，听取它的意见并加快速度。这将帮助它生成更好的统计数据。
- en: 'Aside: You can run Criterion experiments under a debugger and as integration
    tests. See `[fn debug_k_play](https://github.com/CarlKCarlK/range-set-blaze/blob/main/tests/integration_test.rs#L634)`
    in `[tests/integration.rs](https://github.com/CarlKCarlK/range-set-blaze/blob/main/tests/integration_test.rs)`
    for an example. The key is to put common code into its own project (for example,
    `[tests_common](https://github.com/CarlKCarlK/range-set-blaze/tree/main/tests_common)`)
    and then create a workspace in your main `[Cargo.toml](https://github.com/CarlKCarlK/range-set-blaze/blob/main/Cargo.toml#LL16C1-L18C32)`.'
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附注：你可以在调试器下和作为集成测试运行 Criterion 实验。有关示例，请参见 `[fn debug_k_play](https://github.com/CarlKCarlK/range-set-blaze/blob/main/tests/integration_test.rs#L634)`
    和 `[tests/integration.rs](https://github.com/CarlKCarlK/range-set-blaze/blob/main/tests/integration_test.rs)`。关键是将公共代码放到自己的项目中（例如，`[tests_common](https://github.com/CarlKCarlK/range-set-blaze/tree/main/tests_common)`），然后在主
    `[Cargo.toml](https://github.com/CarlKCarlK/range-set-blaze/blob/main/Cargo.toml#LL16C1-L18C32)`
    文件中创建一个工作区。
- en: '**Subrule #3: Use benchmarks to drive design decisions**: Eight years ago,
    when I created the [Python version of this data structure](https://fastlmm.github.io/PySnpTools/#util-intrangeset),
    I stored the sorted ranges in a vector. For the new version, I wondered if using
    Rust’s standard `BTreeMap` would be faster. To see, let’s compare two `BTreeMap`-based
    crates — `[rangemap](https://crates.io/crates/rangemap)` and `RangeSetBlaze —`
    to two `SmallVec`-based crates — `[Range-collections](https://crates.io/crates/range-collections)`
    and `[range-set](https://crates.io/crates/range-set)`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**子规则 #3: 使用基准测试来驱动设计决策：** 八年前，当我创建这个数据结构的 [Python 版本](https://fastlmm.github.io/PySnpTools/#util-intrangeset)时，我将排序后的范围存储在一个向量中。对于新版本，我想知道使用
    Rust 的标准 `BTreeMap` 是否会更快。为了验证，让我们将两个基于 `BTreeMap` 的库 — `[rangemap](https://crates.io/crates/rangemap)`
    和 `RangeSetBlaze` — 与两个基于 `SmallVec` 的库 — `[Range-collections](https://crates.io/crates/range-collections)`
    和 `[range-set](https://crates.io/crates/range-set)` 进行比较：'
- en: '![](../Images/7a9464c61a2b308d82806ef7d34df6e9.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7a9464c61a2b308d82806ef7d34df6e9.png)'
- en: (Please see [the benchmark report](https://github.com/CarlKCarlK/range-set-blaze/blob/main/docs/bench.md)
    for details.) In summary, the fastest vector-based method is 14 times slower than
    the slowest tree-based method. It is also 50 times slower than `RangeSetBlaze`.
    We should not be surprised because vector-based methods are not designed for the
    large numbers of inserts required by our data of interest.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: （有关详细信息，请参见 [基准测试报告](https://github.com/CarlKCarlK/range-set-blaze/blob/main/docs/bench.md)）。总结一下，最快的基于向量的方法比最慢的基于树的方法慢
    14 倍。它还比 `RangeSetBlaze` 慢 50 倍。这并不令人惊讶，因为基于向量的方法并不是为我们关注的数据的大量插入设计的。
- en: 'Here is another example. When we intersect (or union) many `RangeSet` objects
    together, is it OK to do it two-at-a-time or is multiway faster? The benchmark
    gives the answer:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个例子。当我们将多个 `RangeSet` 对象相交（或并集）时，逐个处理可以吗，还是多路处理更快？基准测试给出了答案：
- en: '![](../Images/0288dffabbcc82ca0ebc572912515a2b.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0288dffabbcc82ca0ebc572912515a2b.png)'
- en: On two sets, all methods are similar but as the number of sets increases two-at-a-time
    falls behind. At 100 sets, two-at-a-time must create about 100 intermediate sets
    and is about 14 times slower than multiway. Dynamic multiway is not used by `RangeSetBlaze`
    but is sometimes needed by `SortedDisjoint` iterators. It is 5% to 10% slower
    than static multiway. ([Details](https://github.com/CarlKCarlK/range-set-blaze/blob/main/docs/bench.md)).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个集合上，所有方法都相似，但随着集合数量的增加，逐个处理的速度就会落后。到 100 个集合时，逐个处理必须创建大约 100 个中间集合，速度比多路处理慢约
    14 倍。动态多路处理未被 `RangeSetBlaze` 使用，但 `SortedDisjoint` 迭代器有时需要。它比静态多路处理慢 5% 到 10%。（[详细信息](https://github.com/CarlKCarlK/range-set-blaze/blob/main/docs/bench.md)）。
- en: '**Subrule #4: Profile your code to find bottlenecks:** The most popular profiler
    for Rust is `[flamegraph](https://github.com/flamegraph-rs/flamegraph)`. I found
    it easy to use but I missed being able to zoom in and manipulate the results interactively.
    It turns out; however, that you can use almost any profiler with Rust.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**子规则 #4: 对代码进行分析以查找瓶颈：** 最受欢迎的 Rust 分析工具是 `[flamegraph](https://github.com/flamegraph-rs/flamegraph)`。我发现它很容易使用，但我错过了能够进行互动缩放和操作结果的功能。然而，实际上你可以使用几乎任何分析工具来配合
    Rust。'
- en: For example, I have a paid subscription to Visual Studio 2022\. I previously
    used its full-featured profiler on C++ and C# code. To use it on Rust, I just
    add this (temporarily) to my `Cargo.toml` file and recompile in release mode.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我订阅了 Visual Studio 2022 的付费版。我以前在 C++ 和 C# 代码上使用了它的全功能分析器。要在 Rust 上使用它，我只需将其（临时）添加到我的
    `Cargo.toml` 文件中，并在发布模式下重新编译。
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Other full-featured profilers that I haven’t used but look like they would work
    with Rust include [AMD μProf](https://www.amd.com/en/developer/uprof.html) and,
    on Windows, [Superluminal](https://superluminal.eu/rust/).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 其他功能全面的分析器，虽然我没有使用过，但看起来可以与 Rust 配合使用的包括 [AMD μProf](https://www.amd.com/en/developer/uprof.html)
    和在 Windows 上的 [Superluminal](https://superluminal.eu/rust/)。
- en: 'Rule 9: Test Coverage, Docs, Traits, Compiler Errors, and Correctness'
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则9：测试覆盖率、文档、特性、编译器错误和正确性
- en: Data structures typically support many methods and are used by other projects.
    They, thus, require extensive testing.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构通常支持多种方法，并被其他项目使用。因此，它们需要广泛的测试。
- en: '**Subrule #1: Combine integration and coverage tests:** Integration tests see
    only the public interface of your data structure. I put mine in `tests/integration_test.rs`.
    Each test function is prefaced with `#[test]`.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则1：结合集成测试和覆盖测试：** 集成测试只能看到数据结构的公共接口。我将我的测试放在 `tests/integration_test.rs`
    中。每个测试函数都以 `#[test]` 开头。'
- en: 'Coverage tests ensure that every line of your code is run at least once by
    your tests. Use the powerful and easy `[llvm-cov](https://github.com/taiki-e/cargo-llvm-cov#)`
    to measure coverage. Installation instructions are [here](https://github.com/taiki-e/cargo-llvm-cov#installation).
    Run it with the command: `cargo llvm-cov --open.`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '覆盖测试确保你的代码中的每一行至少被测试运行一次。使用强大且易用的 `[llvm-cov](https://github.com/taiki-e/cargo-llvm-cov#)`
    来测量覆盖率。安装说明见 [这里](https://github.com/taiki-e/cargo-llvm-cov#installation)。用命令运行它：`cargo
    llvm-cov --open.` '
- en: To get your coverage to 100%, you’ll need to add tests. I suggest that, to the
    degree possible, make these coverage tests part of your integration tests. This
    will let you experience the usability of your public interface.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要将覆盖率提升到100%，你需要添加测试。我建议尽可能将这些覆盖测试纳入你的集成测试中。这将使你能够体验到公共接口的可用性。
- en: 'To create coverage (and other) tests across the types you support, use the
    wonderful [syntactic-for](https://crates.io/crates/syntactic-for) crate:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你支持的类型之间创建覆盖（以及其他）测试，请使用神奇的 [syntactic-for](https://crates.io/crates/syntactic-for)
    crate：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Subrule #2: Put many examples in your documentation and run them as tests**:
    Here is an example from the documentation for `SortedDisjoint::equals`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则2：在文档中添加多个示例并将其作为测试运行**：以下是 `SortedDisjoint::equals` 文档中的一个示例：'
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: /// use range_set_blaze::prelude::*;
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /// use range_set_blaze::prelude::*;
- en: ///
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ///
- en: /// let a = CheckSortedDisjoint::from([1..=2]);
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /// let a = CheckSortedDisjoint::from([1..=2]);
- en: /// let b = RangeSetBlaze::from_iter([1..=2]).into_ranges();
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /// let b = RangeSetBlaze::from_iter([1..=2]).into_ranges();
- en: /// assert!(a.equal(b));
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /// assert!(a.equal(b));
- en: /// [PRE20]
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /// [PRE20]
- en: This runs with `cargo test` or `cargo test --doc`. (It doesn’t, however, run
    when measuring coverage.)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过 `cargo test` 或 `cargo test --doc` 运行。（不过，在测量覆盖率时，它不会运行。）
- en: '**Subrule #3: Test all structs and enums for missing traits:** I want `RangeSetBlaze::Iter`
    to (generally) support the same traits as the standard `BTreeSet::Iter`. Also,
    all types should, if practical, auto implement `Sized`, `Send`, `Sync`, and `Unpin`.
    (See this [Let’s Get Rusty](https://www.youtube.com/watch?v=Nzclc6MswaI&t=528s)
    video). Here is how to test traits:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则3：测试所有结构体和枚举的缺失特性：** 我希望 `RangeSetBlaze::Iter` 一般支持与标准 `BTreeSet::Iter`
    相同的特性。此外，所有类型应该在实际情况允许的情况下自动实现 `Sized`、`Send`、`Sync` 和 `Unpin`。（参见这个 [Let’s Get
    Rusty](https://www.youtube.com/watch?v=Nzclc6MswaI&t=528s) 视频）。以下是测试特性的方法：'
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When I first did this, I found that I was missing `Debug`, `FusedIterator`,
    `DoubleEndedIterator`, and `ExactSizeIterator`. I added the first two and decided
    not to add the second two for now.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我第一次做这个时，我发现我缺少 `Debug`、`FusedIterator`、`DoubleEndedIterator` 和 `ExactSizeIterator`。我添加了前两个，并决定暂时不添加后两个。
- en: Similarly, a test that compared the traits of `RangeSetBlaze` to those of the
    standard `BTreeSet` reminded me to implement `Clone`, `PartialOrd`, `Hash`, `Eq`,
    `Ord`, and `IntoIterator`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，一个将 `RangeSetBlaze` 的特性与标准 `BTreeSet` 的特性进行比较的测试提醒我实现 `Clone`、`PartialOrd`、`Hash`、`Eq`、`Ord`
    和 `IntoIterator`。
- en: '**Subrule #4: Test that Illegal Values really are Unrepresentable:** You want
    your data structure to raise a compiler error if a user applies it to the wrong
    types (for example, tries to create a set of characters rather than integers).
    Likewise, some of your methods should raise a compiler error if the user gives
    them a regular iterator rather than an iterator like `SortedDisjoint`. How do
    we test this?'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**子规则 #4: 测试非法值确实无法表示：** 你希望你的数据结构在用户应用于错误类型时（例如，尝试创建一个字符集而不是整数集）引发编译器错误。同样，如果用户给出的是普通迭代器而不是像
    `SortedDisjoint` 这样的迭代器，你的一些方法也应该引发编译器错误。我们如何测试这一点？'
- en: 'Use `[trybuild](https://docs.rs/trybuild/latest/trybuild/)` to create “ui”
    tests. First, create an integration test like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `[trybuild](https://docs.rs/trybuild/latest/trybuild/)` 创建“ui”测试。首先，创建一个像这样的集成测试：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Then in `tests/ui`, create files such as `untrusted_pairs.rs` that test the
    compiler error messages of interest.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在 `tests/ui` 中，创建如 `untrusted_pairs.rs` 这样的文件，以测试编译器错误信息。
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Set the environment variable `TRYBUILD=overwrite` to record the expected compiler
    error message. See `[trybuild](https://docs.rs/trybuild/latest/trybuild/)` for
    details. If you have touble getting the same results locally as on CI (for example,
    GitHub Action), see [this thread](https://github.com/dtolnay/trybuild/issues/236#issuecomment-1620950759).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 设置环境变量 `TRYBUILD=overwrite` 以记录预期的编译器错误信息。详细信息见 `[trybuild](https://docs.rs/trybuild/latest/trybuild/)`。如果你在本地无法得到与
    CI（例如 GitHub Action）相同的结果，请参见 [这个线程](https://github.com/dtolnay/trybuild/issues/236#issuecomment-1620950759)。
- en: '**Subrule #5: Test correctness with automatic QuickCheck tests:** As recommended
    by [Rüdiger Klaehn](https://github.com/rklaehn/sorted-iter), I implemented automatic
    `[QuickCheck](https://github.com/BurntSushi/quickcheck)` tests. Here is a test
    that checks that `RangeSetBlaze::is_disjoint` gets the same answer as `BTreeSet::is_disjoint`
    over values that `QuickCheck` generates.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**子规则 #5: 使用自动化 QuickCheck 测试验证正确性：** 根据 [Rüdiger Klaehn](https://github.com/rklaehn/sorted-iter)
    的推荐，我实现了自动化的 `[QuickCheck](https://github.com/BurntSushi/quickcheck)` 测试。这里是一个测试，它检查
    `RangeSetBlaze::is_disjoint` 是否在 `QuickCheck` 生成的值上与 `BTreeSet::is_disjoint` 得到相同的答案。'
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: So, there you have it, nine rules for creating a data structure in Rust. Creating
    a data structure in Rust took more time than I expected. Half of this was my fault
    for creating a full `SortedDisjoint` sub-library. Half was Rust’s fault for, for
    example, requiring me to define 13 public iterator structs. The payoff — in terms
    of Rust’s speed and safety — however, makes the time worthwhile. Follow these
    nine rules to create your own powerful Rust data structures.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你了解了，在 Rust 中创建数据结构的九条规则。创建 Rust 数据结构比我预期的时间要长。这一方面是因为我创建了一个完整的`SortedDisjoint`子库，另一方面则是因为
    Rust 的要求，比如需要我定义 13 个公共迭代器结构体。然而，从 Rust 的速度和安全性来看，这段时间是值得的。按照这九条规则来创建你自己的强大 Rust
    数据结构吧。
- en: '*Aside: If you’re interested in future articles, please* [*follow me on Medium*](https://medium.com/@carlmkadie)*.
    I write on scientific programming in Rust and Python, machine learning, and statistics.
    I tend to write about one article per month.*'
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*顺便提一下，如果你对未来的文章感兴趣，请* [*在 Medium 上关注我*](https://medium.com/@carlmkadie)*。我会写关于
    Rust 和 Python 的科学编程、机器学习和统计学的文章。我通常每月写一篇文章。*'
