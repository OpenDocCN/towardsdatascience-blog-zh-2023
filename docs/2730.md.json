["```py\nimport pandas as pd\n\ndef read_data_sites_to_visit() -> pd.DataFrame:\n    \"\"\" Reads in a dataframe the locations of the sites to visit \"\"\"\n    DATA_FOLDER = (\"https://raw.githubusercontent.com/carlosjuribe/\"\n                   \"traveling-tourist-problem/main/data\")\n    FILE_LOCATION_HOTEL = \"location_hotel.csv\"\n    FILE_LOCATION_SITES = \"sites_coordinates.csv\"\n\n    df_sites = pd.concat([\n        # coordinates of our hotel, the starting location\n        pd.read_csv(f\"{DATA_FOLDER}/{FILE_LOCATION_HOTEL}\", index_col='site'),\n        # coordinates of the actual places we want to visit\n        pd.read_csv(f\"{DATA_FOLDER}/{FILE_LOCATION_SITES}\", index_col='site'), \n    ])\n    return df_sites\n\ndf_sites = read_data_sites_to_visit()\n\ndf_sites\n```", "```py\nfrom geoutils import GeoAnalyzer\n\ngeo_analyzer = GeoAnalyzer()\ngeo_analyzer.add_locations(df_sites)\ndf_distances = geo_analyzer.get_distance_matrix(precision=0)\n\ndisplay(df_distances)\n```", "```py\nimport sys\n\nimport pyomo.environ as pyo\n\nclass BaseOptimizer:\n    \"\"\" Base class for common functionality shared among optimizers, \n    regarding generic handling and solving of optimization models.\n    It's not intended to be used by itself but as an abstract class \n    to be extended by actual optimizers that implement concrete Pyomo models.\n\n    Attributes\n    ----------\n    _solution_exists : bool (default=None)\n        Initially None, it takes a boolean value after a (subclass) optimizer \n        has had a fitting attempt: True if an optimal solution was found, False \n        otherwise. If the value is None, it means the optimizer hasn't been fit \n        to any data yet.\n\n    is_fitted : bool\n        True if-and-only-if the optimizer has been fitted successfully \n        and thus an optimal solution was found.\n    \"\"\"\n    def __init__(self):\n        self._solution_exists = None  # updated to True/False inside `_optimize` \n        self._setup_solver()\n\n    #######################    solver setup    #######################\n    def _setup_solver(self, solver_nickname=\"glpk\"):\n        \"\"\" Instantiates and stores a MILP solver as an internal attribute \"\"\"\n        solver = pyo.SolverFactory(solver_nickname)\n        if not solver.available(exception_flag=False):\n            raise Exception(f\"Solver '{solver_nickname}' not found. \"\n                            \"You can install it by running:\\n\"\n                            \"conda install -y -c conda-forge glpk\")\n        self._solver = solver\n\n    def _print_solver_info(self) -> None:\n        print(\"Solver info:\", \n              f\"name: {self._solver.name}\", \n              f\"version: {self._solver.version()}\", \n              sep=\"\\n - \")\n\n    ######################    model handling    ######################\n    def _optimize(self, model: pyo.ConcreteModel) -> bool:\n        \"\"\" Solve the model. If an optimal solution is found, the model\n        provided will have the solution inside and ˋTrueˋ is returned. \n        If an optimal solution isn't found, a warning is printed, the \n        results of the optimization are stored in the ˋ_resultsˋ attribute\n        (so post-mortem analysis can be done) and False is returned \"\"\"\n        res = self._solver.solve(model)\n        self._results = res  # store output of solver for inspection\n        self._solution_exists = pyo.check_optimal_termination(res)\n\n        # _solution_exists is True iff an optimal solution is found\n        if not self._solution_exists:\n            print(\"Optimal solution not found, check attribute '_results' \"\n                  \"for details\", file=sys.stderr)\n        return self._solution_exists\n\n    def _store_model(self, model: pyo.ConcreteModel) -> None:\n        \"\"\" Stores the Pyomo model as a public attribute \"\"\"\n        self.model = model\n\n    @property\n    def is_model_created(self) -> bool:\n        \"\"\" True if the (sub)class has an attribute named `model` \"\"\"\n        return hasattr(self, 'model')\n\n    @property\n    def is_fitted(self) -> bool:\n        \"\"\" Returns whether the model of the child class has been fitted \n        (i.e., solved) successfully. Returns False otherwise, i.e., \n        if model hasn't been optimized yet, or if an optimal solution \n        wasn't found \"\"\"\n        return bool(self._solution_exists)\n\n    ########################    model inspection    ########################\n    def print_model_info(self) -> None:\n        \"\"\" High-level overview of the number of components \n        (i.e., constraints, variables, etc.) in the model \"\"\"\n        if not self.is_model_created:\n            print(\"No internal model exists yet. Fit me to some data first\")\n            return\n\n        print(f\"Name: {self.model.name}\", \n              f\"Num variables: {self.model.nvariables()}\",\n              f\"Num constraints: {self.model.nconstraints()}\", \n              f\"Num objectives: {self.model.nobjectives()}\",\n              sep=\"\\n- \")\n```", "```py\nfrom typing import Tuple, List\n\nclass TravelingSalesmanOptimizer(BaseOptimizer):\n    \"\"\"Implements the Miller–Tucker–Zemlin formulation [1] of the \n    Traveling Salesman Problem (TSP) as a linear integer program. \n    The TSP can be stated like: \"Given a set of locations (and usually \n    their pair-wise distances), find the tour of minimal distance that \n    traverses all of them exactly once and ends at the same location \n    it started from. For a derivation of the mathematical model, see [2].\n\n    Parameters\n    ----------\n    name : str\n      Optional name to give to a particular TSP instance\n\n    Attributes\n    ----------\n    tour_ : list\n      List of locations sorted in visit order, obtained after fitting.\n      To avoid duplicity, the last site in the list is not the initial \n      one, but the last one before closing the tour.\n\n    tour_distance_ : float\n      Total distance of the optimal tour, obtained after fitting.\n\n    Example\n    --------\n    >>> tsp = TravelingSalesmanOptimizer()\n    >>> tsp.fit(df_sites)  # fit to a dataframe of geo-coordinates\n    >>> tsp.tour_  # list of sites sorted by visit order\n\n    References\n    ----------\n    [1] https://en.wikipedia.org/wiki/Travelling_salesman_problem\n    [2] https://towardsdatascience.com/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c\n    \"\"\"\n    def __init__(self, name=\"\"):\n        super().__init__()\n        self.name = name\n\n    def _create_model(self, df_distances: pd.DataFrame) -> pyo.ConcreteModel:\n        \"\"\" Given a pandas dataframe of a distance matrix, create a Pyomo model \n        of the TSP and populate it with that distance data \"\"\"\n        model = pyo.ConcreteModel(self.name)\n\n        # a site has to be picked as the \"initial\" one, doesn't matter which \n        # really; by lack of better criteria, take first site in dataframe \n        # as the initial one\n        model.initial_site = df_distances.iloc[0].name\n\n        #===========  sets declaration  ===========#\n        list_of_sites = df_distances.index.tolist()\n\n        model.sites = pyo.Set(initialize=list_of_sites, \n                              domain=pyo.Any, \n                              doc=\"set of all sites to be visited (𝕊)\")\n\n        def _rule_domain_arcs(model, i, j):\n            \"\"\" All possible arcs connecting the sites (𝔸) \"\"\"\n            # only create pair (i, j) if site i and site j are different\n            return (i, j) if i != j else None \n\n        rule = _rule_domain_arcs\n        model.valid_arcs = pyo.Set(\n            initialize=model.sites * model.sites,  # 𝕊 × 𝕊\n            filter=rule, doc=rule.__doc__)\n\n        model.sites_except_initial = pyo.Set(\n            initialize=model.sites - {model.initial_site}, \n            domain=model.sites,\n            doc=\"All sites except the initial site\"\n        )\n        #===========  parameters declaration  ===========#\n        def _rule_distance_between_sites(model, i, j):\n            \"\"\" Distance between site i and site j (𝐷𝑖𝑗) \"\"\"\n            return df_distances.at[i, j]  # fetch the distance from dataframe\n\n        rule = _rule_distance_between_sites\n        model.distance_ij = pyo.Param(model.valid_arcs, \n                                      initialize=rule, \n                                      doc=rule.__doc__)\n\n        model.M = pyo.Param(initialize=1 - len(model.sites_except_initial),\n                            doc=\"big M to make some constraints redundant\")\n\n        #===========  variables declaration  ===========#\n        model.delta_ij = pyo.Var(model.valid_arcs, within=pyo.Binary, \n                                 doc=\"Whether to go from site i to site j (𝛿𝑖𝑗)\")\n\n        model.rank_i = pyo.Var(model.sites_except_initial, \n                               within=pyo.NonNegativeReals, \n                               bounds=(1, len(model.sites_except_initial)), \n                               doc=(\"Rank of each site to track visit order\"))\n\n        #===========  objective declaration  ===========#\n        def _rule_total_distance_traveled(model):\n            \"\"\" total distance traveled \"\"\"\n            return pyo.summation(model.distance_ij, model.delta_ij)\n\n        rule = _rule_total_distance_traveled\n        model.objective = pyo.Objective(rule=rule, \n                                        sense=pyo.minimize, \n                                        doc=rule.__doc__)\n\n        #===========  constraints declaration  ===========#\n        def _rule_site_is_entered_once(model, j):\n            \"\"\" each site j must be visited from exactly one other site \"\"\"\n            return sum(model.delta_ij[i, j] \n                       for i in model.sites if i != j) == 1\n\n        rule = _rule_site_is_entered_once\n        model.constr_each_site_is_entered_once = pyo.Constraint(\n                                                  model.sites, \n                                                  rule=rule, \n                                                  doc=rule.__doc__)\n\n        def _rule_site_is_exited_once(model, i):\n            \"\"\" each site i must departure to exactly one other site \"\"\"\n            return sum(model.delta_ij[i, j] \n                       for j in model.sites if j != i) == 1\n\n        rule = _rule_site_is_exited_once\n        model.constr_each_site_is_exited_once = pyo.Constraint(\n                                                  model.sites, \n                                                  rule=rule, \n                                                  doc=rule.__doc__)\n\n        def _rule_path_is_single_tour(model, i, j):\n            \"\"\" For each pair of non-initial sites (i, j), \n            if site j is visited from site i, the rank of j must be \n            strictly greater than the rank of i.\n            \"\"\"\n            if i == j:  # if sites coincide, skip creating a constraint\n                return pyo.Constraint.Skip\n\n            r_i = model.rank_i[i]\n            r_j = model.rank_i[j]\n            delta_ij = model.delta_ij[i, j]\n            return r_j >= r_i + delta_ij + (1 - delta_ij) * model.M\n\n        # cross product of non-initial sites, to index the constraint\n        non_initial_site_pairs = (\n            model.sites_except_initial * model.sites_except_initial)\n\n        rule = _rule_path_is_single_tour\n        model.constr_path_is_single_tour = pyo.Constraint(\n            non_initial_site_pairs,\n            rule=rule, \n            doc=rule.__doc__)\n\n        self._store_model(model)  # method inherited from BaseOptimizer\n        return model\n\n    def _fit_to_distances(self, df_distances: pd.DataFrame) -> None:\n        self._name_index = df_distances.index.name\n        model = self._create_model(df_distances)\n        solution_exists = self._optimize(model)\n        return self\n\n    @property\n    def sites(self) -> Tuple[str]:\n        \"\"\" Return tuple of site names the optimizer considers \"\"\"\n        return self.model.sites.data() if self.is_model_created else ()\n\n    @property\n    def num_sites(self) -> int:\n        \"\"\" Number of locations to visit \"\"\"\n        return len(self.sites)\n\n    @property\n    def initial_site(self):\n        return self.model.initial_site if self.is_fitted else None\n\n    def __repr__(self) -> str:\n        name = f\"{self.name}, \" if self.name else ''\n        return f\"{self.__class__.__name__}({name}n={self.num_sites})\"\n```", "```py\ntsp = TravelingSalesmanOptimizer(\"trial 1\")\n\nprint(tsp)\n#[Out]: TravelingSalesmanOptimizer(trial 1, n=0)\nprint(tsp.is_model_created, tsp.is_fitted)\n#[Out]: (False, False)\n```", "```py\ntsp._fit_to_distances(df_distances)\n\nprint(tsp)\n#[Out]: TravelingSalesmanOptimizer(trial 1, n=9)\nprint(tsp.is_model_created, tsp.is_fitted)\n#[Out]: (True, True)\n```", "```py\ntsp.model.rank_i.get_values()\n```", "```py\n{'Sacre Coeur': 8.0,\n 'Louvre': 2.0,\n 'Montmartre': 7.0,\n 'Port de Suffren': 4.0,\n 'Arc de Triomphe': 5.0,\n 'Av. Champs Élysées': 6.0,\n 'Notre Dame': 1.0,\n 'Tour Eiffel': 3.0}\n```", "```py\nimport networkx as nx\n\n# class TravelingSalesmanOptimizer(BaseOptimizer):\n    # def __init__()\n    # def _create_model()\n    # def _fit_to_distances()\n    # def sites()\n    # def num_sites()\n    # def initial_site()\n\n    _Arc = Tuple[str, str]\n\n    def _get_selected_arcs_from_model(self, model: pyo.ConcreteModel) -> List[_Arc]:\n        \"\"\"Return the optimal arcs from the decision variable delta_{ij}\n        as an unordered list of arcs. Assumes the model has been solved\"\"\"\n        selected_arcs = [arc \n                         for arc, selected in model.delta_ij.get_values().items()\n                         if selected]\n        return selected_arcs\n\n    def _extract_solution_as_graph(self, model: pyo.ConcreteModel) -> nx.Graph:\n        \"\"\"Extracts the selected arcs from the decision variables of the model, stores \n        them in a networkX graph and returns such a graph\"\"\"\n        selected_arcs = self._get_selected_arcs_from_model(model)\n        self._G_tour = nx.DiGraph(name=model.name)\n        self._G_tour.add_edges_from(selected_arcs)\n        return self._G_tour\n\n    def _get_stops_order_list(self) -> List[str]:\n        \"\"\"Return the stops of the tour in a list **ordered** by visit order\"\"\"\n        visit_order = []\n        next_stop = self.initial_site  # by convention...\n        visit_order.append(next_stop)  # ...tour starts at initial site\n\n        G_tour = self._extract_solution_as_graph(self.model)\n        # starting at first stop, traverse the directed graph one arc at a time\n        for _ in G_tour.nodes:\n            # get consecutive stop and store it\n            next_stop = list(G_tour[next_stop])[0]\n            visit_order.append(next_stop)\n        # discard last stop in list, as it's repeated (the initial site) \n        return visit_order[:-1]\n\n    def get_tour_stops_dataframe(self) -> pd.DataFrame:\n        \"\"\"Return a dataframe of the stops along the optimal tour\"\"\"\n        if self.is_fitted:\n            ordered_stops = self._get_stops_order_list()\n            df_stops = (pd.DataFrame(ordered_stops, columns=[self._name_index])\n                          .reset_index(names='visit_order')  # from 0 to N\n                          .set_index(self._name_index)  # keep index consistent\n            )\n            return df_stops\n\n        print(\"No solution found. Fit me to some data and try again\")\n```", "```py\ntsp = TravelingSalesmanOptimizer(\"trial 2\")\ntsp._fit_to_distances(df_distances)\ntsp.get_tour_stops_dataframe()\n```", "```py\n# class TravelingSalesmanOptimizer(BaseOptimizer):\n    # def __init__()\n    # def _create_model()\n    # def _fit_to_distances()\n    # def sites()\n    # def num_sites()\n    # def initial_site()\n    # def _get_selected_arcs_from_model()\n    # def _extract_solution_as_graph()\n    # def _get_stops_order_list()\n    # def get_tour_stops_dataframe()\n\n    def _get_tour_total_distance(self) -> float:\n        \"\"\"Return the total distance of the optimal tour\"\"\"\n        if self.is_fitted:\n            # as the objective is an expression for the total distance, \n            distance_tour = self.model.objective()  # we just get its value\n            return distance_tour\n\n        print(\"Optimizer is not fitted to any data, no optimal objective exists.\")\n        return None\n```", "```py\ntsp = TravelingSalesmanOptimizer(\"trial 3\")\ntsp._fit_to_distances(df_distances)\nprint(f\"Total distance: {tsp._get_tour_total_distance()} m\")\n# [Out]: Total distance: 14931.0 m\n```", "```py\n# class TravelingSalesmanOptimizer(BaseOptimizer):\n    # def __init__()\n    # def _create_model()\n    # def sites()\n    # def num_sites()\n    # def initial_site()\n    # def _get_selected_arcs_from_model()\n    # def _extract_solution_as_graph()\n    # def _get_stops_order_list()\n    # def get_tour_stops_dataframe()\n    # def _get_tour_total_distance()\n\n    def _fit_to_distances(self, df_distances: pd.DataFrame):\n        \"\"\"Creates a model of the TSP using the distance matrix \n        provided in `df_distances`, and then optimizes it. \n        If the model has an optimal solution, it is extracted, parsed and \n        stored internally so it can be retrieved.\n\n        Parameters\n        ----------\n        df_distances : pd.DataFrame\n            Pandas dataframe where the indices and columns are the \"cities\" \n            (or any site of interest) of the problem, and the cells of the \n            dataframe contain the pair-wise distances between the cities, i.e.,\n            df_distances.at[i, j] contains the distance between i and j.\n\n        Returns\n        -------\n        self : object\n            Instance of the optimizer.\n        \"\"\"\n        model = self._create_model(df_distances)\n        solution_exists = self._optimize(model)\n\n        if solution_exists:\n            # if a solution wasn't found, the attributes won't exist\n            self._store_solution_from_model()\n\n        return self\n\n    #====================  solution handling  ====================\n    def _store_solution_from_model(self) -> None:\n        \"\"\"Extract the optimal solution from the model and create the \"fitted \n        attributes\" `tour_` and `tour_distance_`\"\"\"\n        self.tour_ = self._get_stops_order_list()\n        self.tour_distance_ = self._get_tour_total_distance()\n```", "```py\ntsp = TravelingSalesmanOptimizer(\"trial 4\")._fit_to_distances(df_distances)\n\nprint(f\"Total distance: {tsp.tour_distance_} m\")\nprint(f\"Best tour:\\n\", tsp.tour_)\n# [Out]:\n# Total distance: 14931.0 m\n# Best tour:\n# ['hotel', 'Notre Dame', 'Louvre', 'Tour Eiffel', 'Port de Suffren', 'Arc de Triomphe', 'Av. Champs Élysées', 'Montmartre', 'Sacre Coeur']\n```", "```py\n# class TravelingSalesmanOptimizer(BaseOptimizer):\n    # def __init__()\n    # def _create_model()\n    # def _fit_to_distances()\n    # def sites()\n    # def num_sites()\n    # def initial_site()\n    # def _get_selected_arcs_from_model()\n    # def _extract_solution_as_graph()\n    # def _get_stops_order_list()\n    # def get_tour_stops_dataframe()\n    # def _get_tour_total_distance()\n    # def _store_solution_from_model()\n\n    def fit(self, df_sites: pd.DataFrame):\n        \"\"\"Creates a model instance of the TSP problem using a \n        distance matrix derived (see notes) from the coordinates provided \n        in `df_sites`.\n\n        Parameters\n        ----------\n        df_sites : pd.DataFrame\n            Dataframe of locations \"the salesman\" wants to visit, having the \n            names of the locations in the index and at least one column \n            named 'latitude' and one column named 'longitude'.\n\n        Returns\n        -------\n        self : object\n            Instance of the optimizer.\n\n        Notes\n        -----\n        The distance matrix used is derived from the coordinates of `df_sites`\n        using the ellipsoidal distance between any pair of coordinates, as \n        provided by `geopy.distance.distance`.\"\"\"\n        self._validate_data(df_sites)\n\n        self._name_index = df_sites.index.name\n        self._geo_analyzer = GeoAnalyzer()\n        self._geo_analyzer.add_locations(df_sites)\n        df_distances = self._geo_analyzer.get_distance_matrix(precision=0)\n        self._fit_to_distances(df_distances)\n        return self\n\n    def _validate_data(self, df_sites):\n        \"\"\"Raises error if the input dataframe does not have the expected columns\"\"\"\n        if not ('latitude' in df_sites and 'longitude' in df_sites):\n            raise ValueError(\"dataframe must have columns 'latitude' and 'longitude'\")\n```", "```py\ntsp = TravelingSalesmanOptimizer(\"trial 5\")\ntsp.fit(df_sites)\n\nprint(f\"Total distance: {tsp.tour_distance_} m\")\ntsp.tour_\n#[Out]:\n# Total distance: 14931.0 m\n# ['hotel',\n# 'Notre Dame',\n# 'Louvre',\n# 'Tour Eiffel',\n# 'Port de Suffren',\n# 'Arc de Triomphe',\n# 'Av. Champs Élysées',\n# 'Montmartre',\n# 'Sacre Coeur']\n```", "```py\n# class TravelingSalesmanOptimizer(BaseOptimizer):\n    # def __init__()\n    # def _create_model()\n    # def sites()\n    # def num_sites()\n    # def initial_site()\n    # def _get_selected_arcs_from_model()\n    # def _extract_solution_as_graph()\n    # def _get_stops_order_list()\n    # def get_tour_stops_dataframe()\n    # def _get_tour_total_distance()\n    # def _fit_to_distances()\n    # def _store_solution_from_model()\n    # def fit()\n    # def _validate_data()\n\n    def fit_prescribe(self, df_sites: pd.DataFrame, sort=True) -> pd.DataFrame:\n        \"\"\"In one line, take in a dataframe of locations and return \n        a copy of it with a new column specifying the optimal visit order\n        that minimizes total distance.\n\n        Parameters\n        ----------\n        df_sites : pd.DataFrame\n            Dataframe with the sites in the index and the geolocation \n            information in columns (first column latitude, second longitude).\n\n        sort : bool (default=True)\n            Whether to sort the locations by visit order.\n\n        Returns\n        -------\n        df_sites_ranked : pd.DataFrame \n            Copy of input dataframe `df_sites` with a new column, 'visit_order', \n            containing the stop sequence of the optimal tour.\n\n        See Also\n        --------\n        fit : Solve a TSP from just site locations.\n\n        Examples\n        --------\n        >>> tsp = TravelingSalesmanOptimizer()\n        >>> df_sites_tour = tsp.fit_prescribe(df_sites)  # solution appended\n        \"\"\"\n        self.fit(df_sites)  # find optimal tour for the sites\n\n        if not self.is_fitted:  # unlikely to happen, but still\n            raise Exception(\"A solution could not be found. \"\n            \"Review data or inspect attribute `_results` for details.\"\n            )\n        # join input dataframe with column of solution\n        df_sites_ranked = df_sites.copy().join(self.get_tour_stops_dataframe())    \n        if sort:\n            df_sites_ranked.sort_values(by=\"visit_order\", inplace=True)\n        return df_sites_ranked\n```", "```py\ntsp = TravelingSalesmanOptimizer(\"Paris\")\n\ntsp.fit_prescribe(df_sites)\n```", "```py\ntsp.fit_prescribe(df_sites, sort=False)\n```", "```py\ntsp.print_model_info()\n#[Out]:\n# Name: Paris\n# - Num variables: 80\n# - Num constraints: 74\n# - Num objectives: 1\n```", "```py\nprint(f\"Distance: \"\n      f\"{TravelingSalesmanOptimizer().fit(df_sites).tour_distance_} m\"\n)\n#[Out]: Distance: 14931.0 m\n```", "```py\nsite_removed = 'Arc de Triomphe'\n\ndf_sites_but_one = df_sites.drop(site_removed, axis=0)\n# baseline scenario\ntsp_all = TravelingSalesmanOptimizer().fit(df_sites)\n# alternative scenario\ntsp_all_but_one = TravelingSalesmanOptimizer().fit(df_sites_but_one)\n\nprint(\n    f\"Distance tour ({tsp_all.num_sites} sites): {tsp_all.tour_distance_} m\",\n    f\"Distance tour without {site_removed}: {tsp_all_but_one.tour_distance_} m\",\n    f\"Difference: {tsp_all.tour_distance_ - tsp_all_but_one.tour_distance_} m\",\n    sep=\"\\n\"\n)\n#[Out]:\n# Distance tour (9 sites): 14931.0 m\n# Distance tour without Arc de Triomphe: 14162.0 m\n# Difference: 768 m\n```", "```py\n# make new locations dataframe with the alternative hotel\ndf_sites_hotel_2 = df_sites.copy()  # sites to visit remain the same\ndf_sites_hotel_2.loc['hotel'] = (48.828759, 2.329396)  # new hotel coordinates\n\n# solve the TSP for each \"hotel scenario\"\ntsp1 = TravelingSalesmanOptimizer(\"hotel 1\").fit(df_sites)\ntsp2 = TravelingSalesmanOptimizer(\"hotel 2\").fit(df_sites_hotel_2)\n\nprint(f\"Distance tour {tsp1.name}: {tsp1.tour_distance_} m\")\nprint(f\"Distance tour {tsp2.name}: {tsp2.tour_distance_} m\")\nprint(f\"Difference: {tsp2.tour_distance_ - tsp1.tour_distance_} m\")\n#[Out]:\n# Distance tour hotel 1: 14931 m\n# Distance tour hotel 2: 17772 m\n# Difference: 2841 m\n```"]