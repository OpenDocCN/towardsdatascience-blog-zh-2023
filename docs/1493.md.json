["```py\nlet v: Vec<i32> = Vec::new();\n```", "```py\nlet v = vec![1, 2, 3];\n```", "```py\nlet v = vec![\"apple\", \"banana\", \"cherry\", \"date\"];\n```", "```py\n// Get the second element\nlet second = &v[1];\nprintln!(\"The second element is {}\", second);\n\n// Output:\n// The second element is banana\n```", "```py\nlet v = vec![\n    (\"apple\", 3),\n    (\"banana\", 2),\n    (\"cherry\", 5),\n    (\"date\", 1),\n];\n\n// Get the quantity of cherries\nlet quantity = v.get(2).map(|(_, q)| q);\n\nmatch quantity {\n    Some(q) => println!(\"There are {} cherries\", q),\n    None => println!(\"Cherries not found\"),\n}\n\n// Output:\n// There are 5 cherries\n```", "```py\nlet fruits = vec![(\"apple\", 3), (\"banana\", 2), (\"orange\", 5), (\"peach\", 4)];\nlet mut sum = 0;\nfor (_, num) in &fruits {\n    sum += num;\n}\nlet avg = sum as f32 / fruits.len() as f32;\nprintln!(\"The average of the second elements is {}\", avg);\n\n// Output:\n// The average of the second elements is 3.5\n```", "```py\nlet mut values = vec![10, 20, 30, 40, 50];\nfor value in values.iter_mut() {\n    *value += 10;\n}\nprintln!(\"The modified vector is {:?}\", values);\n\n// Output:\n// The modified vector is [20, 30, 40, 50, 60]\n```", "```py\nlet values = vec![10, 20, 30, 40, 50];\nfor value in &values[0..3] {\n    println!(\"The value is {}\", value);\n}\n\n// Output\n// The value is 10\n// The value is 20\n// The value is 30\n```", "```py\nlet values = vec![10, 20, 30, 40, 50];\nfor (index, value) in values.iter().enumerate() {\n    println!(\"The value at index {} is {}\", index, value);\n}\n\n// Output:\n// The value at index 0 is 10\n// The value at index 1 is 20\n// The value at index 2 is 30\n// The value at index 3 is 40\n// The value at index 4 is 50\n```", "```py\nlet mut v = vec![\"apple\", \"banana\", \"orange\"];\n\nv.push(\"mango\");\n\nprintln!(\"{:?}\", v);\n\n// Output:\n// [\"apple\", \"banana\", \"orange\", \"mango\"]\n```", "```py\nlet mut v = vec![\"apple\", \"mango\", \"banana\", \"orange\"];\n\nv.insert(v.len(), \"mango\");\n\nprintln!(\"{:?}\", v);\n\n// Output:\n// [\"apple\", \"mango\", \"banana\", \"orange\", \"mango\"]\n```", "```py\nlet mut v = vec![\"apple\", \"banana\", \"orange\"];\n\nv[1] = \"pear\";\nv[2] = \"grapefruit\";\n\nprintln!(\"{:?}\", v);\n\n// Output:\n// [\"apple\", \"pear\", \"grapefruit\"]\n```", "```py\nlet mut v = vec![\"apple\", \"banana\", \"orange\", \"mango\"];\n\nlet removed_element = v.pop();\n\nprintln!(\"Removed element: {:?}\", removed_element.unwrap());\nprintln!(\"{:?}\", v);\n\n// Output:\n// Removed element: \"mango\"\n// [\"apple\", \"banana\", \"orange\"]\n```", "```py\nlet mut v = vec![\"apple\", \"banana\", \"orange\", \"mango\"];\n\nlet removed_element = v.remove(2);\n\nprintln!(\"Removed element: {}\", removed_element);\nprintln!(\"{:?}\", v);\n\n// Output\n// Removed element: orange\n// [\"apple\", \"banana\", \"mango\"]\n```", "```py\nlet mut v = vec![\"A\", \"warm\", \"fall\", \"warm\", \"day\"];\nlet elem = \"warm\"; // element to remove\nv.retain(|x| *x != elem);\nprintln!(\"{:?}\", v);\n\n// Output:\n// [\"A\", \"fall\", \"day\"]\n```", "```py\nlet mut v1 = vec![\"apple\", \"banana\"];\nlet mut v2 = vec![\"orange\", \"mango\"];\n\nv1.extend(v2);\n\nprintln!(\"{:?}\", v1);\n\n// Output:\n// [\"apple\", \"banana\", \"orange\", \"mango\"]\n```", "```py\nlet v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nlet odd_numbers: Vec<i32> = v.iter().filter(|x| *x % 2 != 0).map(|x| *x).collect();\nprintln!(\"{:?}\", odd_numbers);\n\n// Output:\n// [1, 3, 5, 7, 9]\n```", "```py\nlet v = vec![\"hello\", \"world\", \"rust\"];\nlet uppercase_strings: Vec<String> = v.iter().map(|x| x.to_uppercase()).collect();\nprintln!(\"{:?}\", uppercase_strings);\n\n// Output\n// [\"HELLO\", \"WORLD\", \"RUST\"]\n```", "```py\nlet v = vec![\"hello\", \"world\", \"rust\"];\nprintln!(\"Size: {}\", v.len());\n\n// Output\n// Size: 3\n```", "```py\nlet v = vec![\"hello\", \"world\", \"rust\"];\nprintln!(\"{}\", v.contains(&\"hello\"));\n\n// Output\n// true\n```", "```py\nlet mut v = vec![1, 2, 3, 4, 5];\nv.reverse();\nprintln!(\"{:?}\", v);\n\n// Output:\n// [5, 4, 3, 2, 1]\n```", "```py\nlet v = vec![1, 2, 3, 4, 5];\nlet max_element = *v.iter().max().unwrap();\nlet min_element = *v.iter().min().unwrap();\nprintln!(\"Max element: {}\", max_element);\nprintln!(\"Min element: {}\", min_element);\n\n// Output\n// Max element: 5\n// Min element: 1\n```", "```py\nlet days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\n```", "```py\nlet a: [i32; 5] = [1, 2, 3, 4, 5];\n```", "```py\nlet zeros = [0; 5];\n```", "```py\nlet numbers = [1, 2, 3, 4, 5];\nprintln!(\"{}\", numbers[2]);\n\n// Output:\n// 3\n```", "```py\nlet mut numbers = [1, 2, 3, 4, 5];\nnumbers[1] = 10;\nprintln!(\"{:?}\", numbers);\n\n// Output:\n// [1, 10, 3, 4, 5]\n```", "```py\nlet seasons = [\"Winter\", \"Spring\", \"Summer\", \"Fall\"];\nfor season in seasons {\n    println!(\"{season}\");\n}\n// or\nfor index in 0..seasons.len() {\n    println!(\"{}\", seasons[index]);\n}\n// or\nfor season in seasons.iter() {\n    println!(\"{}\", season);\n}\n```", "```py\nlet numbers = [1, 2, 3, 4, 5];\nlet slice = &numbers[1..4];\nprintln!(\"{:?}\", slice);\n\n// Output:\n// [2, 3, 4]\n```", "```py\nlet person = (\"Mahmoud\", 22, true, 6.6);\n```", "```py\nlet person: (&str, i32, bool, f64) = (\"Mahmoud\", 22, false, 6.6);\n```", "```py\nlet mut person = (\"Mahmoud\", 22, true);\n```", "```py\nperson.1 = 21;\n```", "```py\nlet (name, age, is_male) = (\"Mahmoud\", 22, true);\nprintln!(\"Name: {}, Age: {}, Gender: {}\", name, age, if is_male { \"Male\" } else { \"Female\" });\n\n// Output\n// Name: Mahmoud, Age: 22, Gender: Male\n```", "```py\nlet (_, _, _, height) = (\"Mahmoud\", 22, false, 6.6);\nprintln!(\"Height: {}\", height);\n\n// Output\n// Height: 6.6\n```", "```py\nlet person = (\"Mahmoud\", 3, true, 6.0);\nprintln!(\"Experience: {}\", person.1);\n\n// Output\n// Experience: 3\n```", "```py\nuse std::collections::HashSet;\nlet mut my_set: HashSet<i32> = HashSet::new();\n```", "```py\nlet my_vector = vec![1, 2, 3, 4];\nlet my_set: HashSet<i32> = my_vector.into_iter().collect();\n```", "```py\nlet a = HashSet::from([1, 2, 3]);\n```", "```py\nlet mut my_set: HashSet<i32> = HashSet::new();\nmy_set.insert(1);\nmy_set.insert(2);\nmy_set.insert(3);\n```", "```py\nlet mut my_set = HashSet::from([1, 2, 3, 4]);\nmy_set.remove(&2); // removes 2 from the set\n```", "```py\nlet my_set = HashSet::from([1, 2, 3]);\n\nfor element in &my_set {\n    println!(\"{}\", element);\n}\n\n// Output(not ordered):\n// 1\n// 3\n// 2\n```", "```py\nuse std::collections::HashSet;\n\nlet set_a = HashSet::from([1, 2, 3]);\nlet set_b = HashSet::from([4, 2, 3, 4]);\n\n// elements in set_a that are not in set_b\nlet difference_set = set_a.difference(&set_b);\n\n// elements common to both set_a and set_b\nlet intersection = set_a.intersection(&set_b);\n\n// elements in either set_a or set_b\nlet union_set = set_a.union(&set_b);\n\nfor element in difference_set {\n    println!(\"{}\", element);\n}\n\n// Output:\n// 1\n\nfor element in intersection {\n    println!(\"{}\", element);\n}\n\n// Output:\n// 3\n// 2\n\nfor element in union_set {\n    println!(\"{}\", element); \n}\n\n// Output:\n// 3\n// 2\n// 1\n// 4\n```", "```py\nuse std::collections::HashMap;\n\nlet mut employees_map = HashMap::new();\n\n// Insert elements to the HashMap\nemployees_map.insert(\"Mahmoud\", 1);\nemployees_map.insert(\"Ferris\", 2);\n\n// Print the HashMap\nprintln!(\"{:?}\", employees_map);\n\n// Output:\n// {\"Mahmoud\": 1, \"Ferris\": 2}\n```", "```py\nuse std::collections::HashMap;\n\nlet employees_map: HashMap<i32, &str> = HashMap::from([\n    (1, \"Mahmoud\"),\n    (2, \"Ferris\"),\n]);\n```", "```py\nuse std::collections::HashMap;\n\nlet mut employees_map = HashMap::new();\n\n// Insert elements to the HashMap\nemployees_map.insert(\"Mahmoud\", 1);\nemployees_map.insert(\"Ferris\", 2);\n\n// Print the HashMap\nprintln!(\"{:?}\", employees_map);\n\n// Output:\n// {\"Mahmoud\": 1, \"Ferris\": 2}\n```", "```py\nuse std::collections::HashMap;\n\nlet mut employees_map: HashMap<i32, String> = HashMap::new();\n\n// insert elements to hashmap\nemployees_map.insert(1, String::from(\"Mahmoud\"));\n\n// remove elements from hashmap\nemployees_map.remove(&1);\n```", "```py\nlet mut employees_map: HashMap<i32, String> = HashMap::new();\n\n// insert elements to hashmap\nemployees_map.insert(1, String::from(\"Mahmoud\"));\n\n// update the value of the element with key 1\nemployees_map.insert(1, String::from(\"Ferris\"));\nprintln!(\"{:?}\", employees_map);\n\n// Output:\n// {1: \"Ferris\"}\n```", "```py\nuse std::collections::HashMap;\n\nlet employees_map: HashMap<i32, &str> = HashMap::from([\n    (1, \"Mahmoud\"),\n    (2, \"Ferris\"),\n]);\n\nlet first_employee = employees_map.get(&1);\n```", "```py\nuse std::collections::HashMap;\n\nfn main() {\n    let mut employees_map: HashMap<i32, String> = HashMap::new();\n\n    employees_map.insert(1, String::from(\"Mahmoud\"));\n    employees_map.insert(2, String::from(\"Ferris\"));\n\n    // loop and print values of hashmap using values() method\n    for employee in employees_map.values() {\n        println!(\"{}\", employee)\n    }\n\n    // print the length of hashmap using len() method\n    println!(\"Length of employees_map = {}\", employees_map.len());\n}\n\n// Output:\n// Ferris\n// Mahmoud\n// Length of employees_map = 2\n```", "```py\nuse ndarray::{Array, ShapeBuilder};\nuse ndarray_rand::RandomExt;\nuse ndarray_rand::rand_distr::Uniform;\n\n// Zeros\n\nlet zeros = Array::<f64, _>::zeros((1, 4).f());\nprintln!(\"{:?}\", zeros);\n\n// Output:\n// [[0.0, 0.0, 0.0, 0.0]], shape=[1, 4], strides=[1, 1], layout=CFcf (0xf), const ndim=2\n\n// Ones\n\nlet ones = Array::<f64, _>::ones((1, 4));\nprintln!(\"{:?}\", ones); \n\n// Output:\n// [[1.0, 1.0, 1.0, 1.0]], shape=[1, 4], strides=[4, 1], layout=CFcf (0xf), const ndim=2\n\n// Range\n\nlet range = Array::<f64, _>::range(0., 5., 1.);\nprintln!(\"{:?}\", range); \n\n// Output:\n// [0.0, 1.0, 2.0, 3.0, 4.0], shape=[5], strides=[1], layout=CFcf (0xf), const ndim=1\n\n// Linspace\n\nlet linspace = Array::<f64, _>::linspace(0., 5., 5);\nprintln!(\"{:?}\", linspace); \n\n// Output:\n// [0.0, 1.25, 2.5, 3.75, 5.0], shape=[5], strides=[1], layout=CFcf (0xf), const ndim=1\n\n// Fill\n\nlet mut ones = Array::<f64, _>::ones((1, 4));\nones.fill(0.);\nprintln!(\"{:?}\", ones); \n\n// Output:\n// [[0.0, 0.0, 0.0, 0.0]], shape=[1, 4], strides=[4, 1], layout=CFcf (0xf), const ndim=2\n\n// Eye\n\nlet eye = Array::<f64, _>::eye(4);\nprintln!(\"{:?}\", eye); \n\n// Output:\n// [[1.0, 0.0, 0.0, 0.0],\n// [0.0, 1.0, 0.0, 0.0],\n// [0.0, 0.0, 1.0, 0.0],\n// [0.0, 0.0, 0.0, 1.0]], shape=[4, 4], strides=[4, 1], layout=Cc (0x5), const ndim=2\n\n// Random\n\nlet random = Array::random((2, 5), Uniform::new(0., 10.));\nprintln!(\"{:?}\", random);\n\n// Output:\n// [[9.375493735188611, 4.088737328406999, 9.778579742815943, 0.5225866490310649, 1.518053969762827],\n//  [9.860829919571666, 2.9473768443117, 7.768332993584486, 7.163926861520167, 9.814750664983297]], shape=[2, 5], strides=[5, 1], layout=Cc (0x5), const ndim=2\n```", "```py\nuse ndarray::{array, Array, Array2, Array3, ShapeBuilder};\n\n// 1D array\nlet array_d1 = Array::from_vec(vec![1., 2., 3., 4.]);\nprintln!(\"{:?}\", array_d1);\n\n// Output:\n// [1.0, 2.0, 3.0, 4.0], shape=[4], strides=[1], layout=CFcf (0xf), const ndim=1\n\n// or \n\nlet array_d11 = Array::from_shape_vec((1, 4), vec![1., 2., 3., 4.]);\nprintln!(\"{:?}\", array_d11.unwrap());\n\n// Output:\n// [[1.0, 2.0, 3.0, 4.0]], shape=[1, 4], strides=[4, 1], layout=CFcf (0xf), const ndim=2\n\n// 2D array\n\nlet array_d2 = array![\n    [-1.01,  0.86, -4.60,  3.31, -4.81],\n    [ 3.98,  0.53, -7.04,  5.29,  3.55],\n    [ 3.30,  8.26, -3.89,  8.20, -1.51],\n    [ 4.43,  4.96, -7.66, -7.33,  6.18],\n    [ 7.31, -6.43, -6.16,  2.47,  5.58],\n];\n\n// or\n\nlet array_d2 = Array::from_shape_vec((2, 2), vec![1., 2., 3., 4.]);\nprintln!(\"{:?}\", array_d2.unwrap());\n\n// Output:\n// [[1.0, 2.0],\n// [3.0, 4.0]], shape=[2, 2], strides=[2, 1], layout=Cc (0x5), const ndim=2\n\n// or\n\nlet mut data = vec![1., 2., 3., 4.];\nlet array_d21 = Array2::from_shape_vec((2, 2), data);\n\n// 3D array\n\nlet mut data = vec![1., 2., 3., 4.];\nlet array_d3 = Array3::from_shape_vec((2, 2, 1), data);\nprintln!(\"{:?}\", array_d3);\n\n// Output:\n// [[[1.0],\n//  [2.0]],\n//  [[3.0],\n//  [4.0]]], shape=[2, 2, 1], strides=[2, 1, 1], layout=Cc (0x5), const ndim=3\n```", "```py\nlet array_d1 = Array::from_vec(vec![1., 2., 3., 4.]);\narray_d1[1]\n```", "```py\nlet zeros = Array2::<f64>::zeros((2, 4).f());\narray_d1[1, 1]\n```", "```py\nlet array_d1 = Array::<i32, _>::from_vec(vec![1, 2, 3, 4]);\nlet slice = array_d1.slice(s![0..3]);\n```", "```py\nuse ndarray::{rcarr1};\nlet array_d1 = rcarr1(&[1., 2., 3., 4.]); // another way to create a 1D array\nlet array_d2 = array_d1.reshape((2, 2));\n```", "```py\nuse ndarray::{array, Array2};\nuse ndarray_linalg::convert::flatten;\n\nlet array_d2: Array2<f64> = array![[3., 2.], [2., -2.]];\nlet array_flatten = flatten(array_d2);\nprint!(\"{:?}\", array_flatten);\n\n// Output:\n// [3.0, 2.0, 2.0, -2.0], shape=[4], strides=[1], layout=CFcf (0xf), const ndim=1\n```", "```py\nlet array_d2 = Array::from_shape_vec((2, 2), vec![1., 2., 3., 4.]);\nprintln!(\"{:?}\", array_d2.unwrap());\n\n// Output\n// [[1.0, 2.0],\n//  [3.0, 4.0]], shape=[2, 2], strides=[2, 1], layout=Cc (0x5), const ndim=2)\n\nlet binding = array_d2.expect(\"Expect 2d matrix\");\n\nlet array_d2t = binding.t();\nprintln!(\"{:?}\", array_d2t);\n\n// Output\n// [[1.0, 3.0],\n//  [2.0, 4.0]], shape=[2, 2], strides=[1, 2], layout=Ff (0xa), const ndim=2\n```", "```py\nlet array_d2 = Array::from_shape_vec((2, 2), vec![1., 2., 3., 4.]);\nprintln!(\"{:?}\", array_d2.unwrap());\n\n// Output:\n// [[1.0, 2.0],\n//  [3.0, 4.0]], shape=[2, 2], strides=[2, 1], layout=Cc (0x5), const ndim=2\n\nlet mut binding = array_d2.expect(\"Expect 2d matrix\");\nbinding.swap_axes(0, 1);\nprintln!(\"{:?}\", binding);\n\n// Output:\n// [[1.0, 3.0],\n//  [2.0, 4.0]], shape=[2, 2], strides=[1, 2], layout=Ff (0xa), const ndim=2\n```", "```py\nextern crate blas_src;\nuse ndarray::{array, Array2};\n\nlet a: Array2<f64> = array![[3., 2.], [2., -2.]];\nlet b: Array2<f64> = array![[3., 2.], [2., -2.]];\nlet c = a.dot(&b);\nprint!(\"{:?}\", c);\n\n// Output\n// [[13.0, 2.0],\n//  [2.0, 8.0]], shape=[2, 2], strides=[2, 1], layout=Cc (0x5), const ndim=2\n```", "```py\nuse ndarray::Array;\nuse ndarray_linalg::solve::Inverse;\nuse std::result::Result::{Err, Ok};\n\nlet array_d2 = Array::from_shape_vec((2, 2), vec![1., 2., 2., 1.]);\n\nmatch array_d2.expect(\"Matrix must be square & symetric!\").inv() {\n    Ok(inv) => {\n        println!(\"The inverse of m1 is: {}\", inv);\n    }\n    Err(err) => {\n        println!(\"{err}\");\n    }\n}\n\n// Output:\n// The inverse of m1 is: [[-0.3333333333333333, 0.6666666666666666],\n//  [0.6666666666666666, -0.3333333333333333]]\n```", "```py\nuse ndarray::array;\nuse ndarray_linalg::Eig;\nuse std::result::Result::{Err, Ok};\n\nlet array_d2 = array![\n    [-1.01,  0.86, -4.60],\n    [ 3.98,  0.53, -7.04],\n    [ 3.98,  0.53, -7.04],\n];\nmatch array_d2.eig() {\n    Ok((eigs, vecs)) => {\n        println!(\"Eigen values: {}\", eigs);\n        println!(\"Eigen vectors: {}\", vecs);\n    }\n    Err(err) => {\n        println!(\"{err}\");\n    }\n}\n\n// Output:\n// Eigen values: [-3.759999999999999+2.706048780048134i, -3.759999999999999-2.706048780048134i, 0.00000000000000022759891370571733+0i]\n// Eigen vectors: [[0.402993672209733+0.3965529218364603i, 0.402993672209733-0.3965529218364603i, 0.13921180485702092+0i],\n//  [0.5832417510526318+0.00000000000000006939572631647882i, 0.5832417510526318-0.00000000000000006939572631647882i, 0.9784706726517249+0i],\n//  [0.583241751052632+-0i, 0.583241751052632+0i, 0.15236540338584623+0i]]\n```", "```py\nuse ndarray::array;\nuse ndarray_linalg::svd::SVD;\nuse std::result::Result::{Err, Ok};\n\nlet array_d2 = array![\n    [-1.01,  0.86, -4.60],\n    [ 3.98,  0.53, -7.04],\n    [ 3.98,  0.53, -7.04],\n];\nmatch array_d2.svd(true, true) {\n    Ok((u, sigma, v)) => {\n        println!(\"The left singular vectors are: {:?}\", u.unwrap());\n        println!(\"The right singular vectors are: {:?}\", v.unwrap());\n        println!(\"The sigma vector: {:?}\", sigma);\n    }\n    Err(err) => {\n        println!(\"{err}\");\n    }\n}\n\n// Output:\n// The left singular vectors are: [[-0.3167331446091065, -0.948514688924756, 0.0],\n//  [-0.6707011685937435, 0.22396415437963857, -0.7071067811865476],\n//  [-0.6707011685937436, 0.2239641543796386, 0.7071067811865475]], shape=[3, 3], strides=[3, 1], layout=Cc (0x5), const ndim=2\n// The right singular vectors are: [[-0.4168301381758514, -0.0816682352525302, 0.9053081990455173],\n//  [0.8982609360852509, -0.18954008048752713, 0.39648688325344433],\n//  [0.13921180485702067, 0.9784706726517249, 0.1523654033858462]], shape=[3, 3], strides=[3, 1], layout=Cc (0x5), const ndim=2\n// The sigma vector: [12.040590078046721, 3.051178554664221, 9.490164740574465e-18], shape=[3], strides=[1], layout=CFcf (0xf), const ndim=1\n```", "```py\nuse ndarray::array;\nuse ndarray_linalg::trace::Trace;\nuse std::result::Result::{Err, Ok};\n\nlet array_d2 = array![\n    [-1.01,  0.86, -4.60],\n    [ 3.98,  0.53, -7.04],\n    [ 3.98,  0.53, -7.04],\n];\nmatch array_d2.trace() {\n    Ok(value) => {\n        println!(\"The sum of diagonal elements is: {:?}\", value);\n    }\n    Err(err) => {\n        println!(\"{err}\");\n    }\n}\n\n// Output:\n// The sum of diagonal elements is: -7.52\n```", "```py\nuse ndarray::array;\nuse ndarray_linalg::solve::Determinant;\nuse std::result::Result::{Err, Ok};\n\nlet array_d2 = array![\n    [-1.01,  0.86, -4.60],\n    [ 3.98,  0.53, -7.04],\n    [ 3.98,  0.53, -7.04],\n];\nmatch array_d2.det() {\n    Ok(value) => {\n        println!(\"The determinant of this matrix is: {:?}\", value);\n    }\n    Err(err) => {\n        println!(\"{err}\");\n    }\n}\n\n// Output:\n// The determinant of this matrix is: 2.822009292913204e-15\n```", "```py\nuse ndarray::{array, Array1, Array2};\nuse ndarray_linalg::Solve;\n\n// a11x0 + a12x1 = b1    --->    3 * x0 + 2 * x1 = 1\n// a21x0 + a22x1 = b2    --->    2 * x0 - 2 * x1 = -2:\nlet a: Array2<f64> = array![[3., 2.], [2., -2.]];\nlet b: Array1<f64> = array![1., -2.];\nlet x = a.solve_into(b).unwrap();\nprint!(\"{:?}\", x);\n\n// Output:\n// [-0.2, 0.8], shape=[2], strides=[1], layout=CFcf (0xf), const ndim=1\n```"]