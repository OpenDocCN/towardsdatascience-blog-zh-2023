["```py\n# Sample rating programs dataset for each time slot.\nratings = {\n    'news': [0.1, 0.1, 0.4, 0.3, 0.5, 0.4, 0.3, 0.2, 0.1, 0.2, 0.3, 0.5, 0.5, 0.4, 0.3, 0.2, 0.1, 0.2],\n    'live_soccer': [0.0, 0.0, 0.0, 0.2, 0.1, 0.3, 0.2, 0.1, 0.4, 0.3, 0.4, 0.5, 0.4, 0.6, 0.4, 0.3, 0.4, 0.3],\n    'movie_a': [0.1, 0.1, 0.2, 0.4, 0.3, 0.2, 0.1, 0.2, 0.3, 0.4, 0.5, 0.4, 0.3, 0.4, 0.3, 0.5, 0.3, 0.4],\n    'movie_b': [0.2, 0.1, 0.1, 0.3, 0.2, 0.1, 0.2, 0.3, 0.4, 0.5, 0.4, 0.3, 0.4, 0.5, 0.4, 0.3, 0.4, 0.5],\n    'reality_show': [0.3, 0.4, 0.3, 0.4, 0.4, 0.5, 0.3, 0.4, 0.5, 0.4, 0.3, 0.2, 0.1, 0.2, 0.3, 0.2, 0.2, 0.3],\n    'tv_series_a': [0.2, 0.3, 0.2, 0.1, 0.1, 0.2, 0.2, 0.4, 0.4, 0.3, 0.3, 0.3, 0.5, 0.6, 0.4, 0.5, 0.4, 0.3],\n    'tv_series_b': [0.1, 0.2, 0.3, 0.3, 0.2, 0.3, 0.3, 0.1, 0.4, 0.3, 0.4, 0.3, 0.5, 0.3, 0.4, 0.6, 0.4, 0.3],\n    'music_program': [0.3, 0.3, 0.3, 0.2, 0.2, 0.1, 0.2, 0.4, 0.3, 0.3, 0.3, 0.3, 0.2, 0.3, 0.2, 0.3, 0.5, 0.3],\n    'documentary': [0.3, 0.3, 0.4, 0.3, 0.2, 0.2, 0.3, 0.4, 0.4, 0.3, 0.2, 0.2, 0.2, 0.1, 0.1, 0.3, 0.3, 0.2],\n    'Boxing': [0.4, 0.3, 0.3, 0.2, 0.2, 0.1, 0.1, 0.1, 0.1, 0.3, 0.3, 0.3, 0.2, 0.3, 0.4, 0.3, 0.4, 0.6]\n}\n```", "```py\nGEN = 100\nPOP = 50\nCO_R = 0.8\nMUT_R = 0.2\nEL_S = 2\n\nall_programs = list(ratings.keys()) # all programs\nall_time_slots = list(range(6, 24)) # time slots\n```", "```py\ndef initialize_pop(programs, time_slots):\n    if not programs:\n        return [[]]\n\n    all_schedules = []\n    for i in range(len(programs)):\n        for schedule in initialize_pop(programs[:i] + programs[i + 1:], time_slots):\n            all_schedules.append([programs[i]] + schedule)\n\n    return all_schedules\n```", "```py\ndef fitness_function(schedule):\n    total_rating = 0\n    for time_slot, program in enumerate(schedule):\n        total_rating += ratings[program][time_slot]\n    return total_rating\n```", "```py\ndef finding_best_schedule(all_schedules):\n    best_schedule = []\n    max_ratings = 0\n\n    for schedule in all_schedules:\n        total_ratings = fitness_function(schedule)\n        if total_ratings > max_ratings:\n            max_ratings = total_ratings\n            best_schedule = schedule\n\n    return best_schedule\n```", "```py\ndef crossover(schedule1, schedule2):\n    crossover_point = random.randint(1, len(schedule1) - 2)\n    child1 = schedule1[:crossover_point] + schedule2[crossover_point:]\n    child2 = schedule2[:crossover_point] + schedule1[crossover_point:]\n    return child1, child2\n```", "```py\ndef mutate(schedule):\n    mutation_point = random.randint(0, len(schedule) - 1)\n    new_program = random.choice(all_programs)\n    schedule[mutation_point] = new_program\n    return schedule\n```", "```py\n# calling the fitness func.\ndef evaluate_fitness(schedule):\n    return fitness_function(schedule)\n```", "```py\ndef genetic_algorithm(initial_schedule, generations=GEN, population_size=POP, crossover_rate=CO_R, mutation_rate=MUT_R, elitism_size=EL_S):\n\n    population = [initial_schedule]\n\n    for _ in range(population_size - 1):\n        random_schedule = initial_schedule.copy()\n        random.shuffle(random_schedule)\n        population.append(random_schedule)\n\n    for generation in range(generations):\n        new_population = []\n\n        # Elitism\n        population.sort(key=lambda schedule: fitness_function(schedule), reverse=True)\n        new_population.extend(population[:elitism_size])\n\n        while len(new_population) < population_size:\n            parent1, parent2 = random.choices(population, k=2)\n            if random.random() < crossover_rate:\n                child1, child2 = crossover(parent1, parent2)\n            else:\n                child1, child2 = parent1.copy(), parent2.copy()\n\n            if random.random() < mutation_rate:\n                child1 = mutate(child1)\n            if random.random() < mutation_rate:\n                child2 = mutate(child2)\n\n            new_population.extend([child1, child2])\n\n        population = new_population\n\n    return population[0]\n```", "```py\ninitial_best_schedule = finding_best_schedule(all_possible_schedules)\n\nrem_t_slots = len(all_time_slots) - len(initial_best_schedule)\ngenetic_schedule = genetic_algorithm(initial_best_schedule, generations=GEN, population_size=POP, elitism_size=EL_S)\n\nfinal_schedule = initial_best_schedule + genetic_schedule[:rem_t_slots]\n\nprint(\"\\nFinal Optimal Schedule:\")\nfor time_slot, program in enumerate(final_schedule):\n    print(f\"Time Slot {all_time_slots[time_slot]:02d}:00 - Program {program}\")\n\nprint(\"Total Ratings:\", fitness_function(final_schedule))\n```", "```py\nimport random\n\n##################################### DEFINING PARAMETERS AND DATASET ################################################################\n# Sample rating programs dataset for each time slot.\nratings = {\n    'news': [0.1, 0.1, 0.4, 0.3, 0.5, 0.4, 0.3, 0.2, 0.1, 0.2, 0.3, 0.5, 0.5, 0.4, 0.3, 0.2, 0.1, 0.2],\n    'live_soccer': [0.0, 0.0, 0.0, 0.2, 0.1, 0.3, 0.2, 0.1, 0.4, 0.3, 0.4, 0.5, 0.4, 0.6, 0.4, 0.3, 0.4, 0.3],\n    'movie_a': [0.1, 0.1, 0.2, 0.4, 0.3, 0.2, 0.1, 0.2, 0.3, 0.4, 0.5, 0.4, 0.3, 0.4, 0.3, 0.5, 0.3, 0.4],\n    'movie_b': [0.2, 0.1, 0.1, 0.3, 0.2, 0.1, 0.2, 0.3, 0.4, 0.5, 0.4, 0.3, 0.4, 0.5, 0.4, 0.3, 0.4, 0.5],\n    'reality_show': [0.3, 0.4, 0.3, 0.4, 0.4, 0.5, 0.3, 0.4, 0.5, 0.4, 0.3, 0.2, 0.1, 0.2, 0.3, 0.2, 0.2, 0.3],\n    'tv_series_a': [0.2, 0.3, 0.2, 0.1, 0.1, 0.2, 0.2, 0.4, 0.4, 0.3, 0.3, 0.3, 0.5, 0.6, 0.4, 0.5, 0.4, 0.3],\n    'tv_series_b': [0.1, 0.2, 0.3, 0.3, 0.2, 0.3, 0.3, 0.1, 0.4, 0.3, 0.4, 0.3, 0.5, 0.3, 0.4, 0.6, 0.4, 0.3],\n    'music_program': [0.3, 0.3, 0.3, 0.2, 0.2, 0.1, 0.2, 0.4, 0.3, 0.3, 0.3, 0.3, 0.2, 0.3, 0.2, 0.3, 0.5, 0.3],\n    'documentary': [0.3, 0.3, 0.4, 0.3, 0.2, 0.2, 0.3, 0.4, 0.4, 0.3, 0.2, 0.2, 0.2, 0.1, 0.1, 0.3, 0.3, 0.2],\n    'Boxing': [0.4, 0.3, 0.3, 0.2, 0.2, 0.1, 0.1, 0.1, 0.1, 0.3, 0.3, 0.3, 0.2, 0.3, 0.4, 0.3, 0.4, 0.6]\n}\n\nGEN = 100\nPOP = 50\nCO_R = 0.8\nMUT_R = 0.2\nEL_S = 2\n\nall_programs = list(ratings.keys()) # all programs\nall_time_slots = list(range(6, 24)) # time slots\n\n######################################### DEFINING FUNCTIONS ########################################################################\n# defining fitness function\ndef fitness_function(schedule):\n    total_rating = 0\n    for time_slot, program in enumerate(schedule):\n        total_rating += ratings[program][time_slot]\n    return total_rating\n\n# initializing the population\ndef initialize_pop(programs, time_slots):\n    if not programs:\n        return [[]]\n\n    all_schedules = []\n    for i in range(len(programs)):\n        for schedule in initialize_pop(programs[:i] + programs[i + 1:], time_slots):\n            all_schedules.append([programs[i]] + schedule)\n\n    return all_schedules\n\n# selection\ndef finding_best_schedule(all_schedules):\n    best_schedule = []\n    max_ratings = 0\n\n    for schedule in all_schedules:\n        total_ratings = fitness_function(schedule)\n        if total_ratings > max_ratings:\n            max_ratings = total_ratings\n            best_schedule = schedule\n\n    return best_schedule\n\n# calling the pop func.\nall_possible_schedules = initialize_pop(all_programs, all_time_slots)\n\n# callin the schedule func.\nbest_schedule = finding_best_schedule(all_possible_schedules)\n\n############################################# GENETIC ALGORITHM #############################################################################\n\n# Crossover \ndef crossover(schedule1, schedule2):\n    crossover_point = random.randint(1, len(schedule1) - 2)\n    child1 = schedule1[:crossover_point] + schedule2[crossover_point:]\n    child2 = schedule2[:crossover_point] + schedule1[crossover_point:]\n    return child1, child2\n\n# mutating\ndef mutate(schedule):\n    mutation_point = random.randint(0, len(schedule) - 1)\n    new_program = random.choice(all_programs)\n    schedule[mutation_point] = new_program\n    return schedule\n\n# calling the fitness func.\ndef evaluate_fitness(schedule):\n    return fitness_function(schedule)\n\n# genetic algorithms with parameters\n\ndef genetic_algorithm(initial_schedule, generations=GEN, population_size=POP, crossover_rate=CO_R, mutation_rate=MUT_R, elitism_size=EL_S):\n\n    population = [initial_schedule]\n\n    for _ in range(population_size - 1):\n        random_schedule = initial_schedule.copy()\n        random.shuffle(random_schedule)\n        population.append(random_schedule)\n\n    for generation in range(generations):\n        new_population = []\n\n        # Elitsm\n        population.sort(key=lambda schedule: fitness_function(schedule), reverse=True)\n        new_population.extend(population[:elitism_size])\n\n        while len(new_population) < population_size:\n            parent1, parent2 = random.choices(population, k=2)\n            if random.random() < crossover_rate:\n                child1, child2 = crossover(parent1, parent2)\n            else:\n                child1, child2 = parent1.copy(), parent2.copy()\n\n            if random.random() < mutation_rate:\n                child1 = mutate(child1)\n            if random.random() < mutation_rate:\n                child2 = mutate(child2)\n\n            new_population.extend([child1, child2])\n\n        population = new_population\n\n    return population[0]\n\n##################################################### RESULTS ###################################################################################\n\n# brute force\ninitial_best_schedule = finding_best_schedule(all_possible_schedules)\n\nrem_t_slots = len(all_time_slots) - len(initial_best_schedule)\ngenetic_schedule = genetic_algorithm(initial_best_schedule, generations=GEN, population_size=POP, elitism_size=EL_S)\n\nfinal_schedule = initial_best_schedule + genetic_schedule[:rem_t_slots]\n\nprint(\"\\nFinal Optimal Schedule:\")\nfor time_slot, program in enumerate(final_schedule):\n    print(f\"Time Slot {all_time_slots[time_slot]:02d}:00 - Program {program}\")\n\nprint(\"Total Ratings:\", fitness_function(final_schedule))\n```"]