["```py\ndef process(f: DataFrame) -> Series: ...\n```", "```py\nfrom typing import Any\nfrom static_frame import Frame, Index, TSeriesAny\n\ndef process(f: Frame[   # type of the container\n        Any,            # type of the index labels\n        Index[np.str_], # type of the column labels\n        np.int_,        # type of the first column\n        np.str_,        # type of the second column\n        np.float64,     # type of the third column\n        ]) -> TSeriesAny: ...\n```", "```py\nfrom typing import Any\nfrom static_frame import Frame, Series, Index, IndexYearMonth\n\ndef process(f: Frame[\n        Any,\n        Index[np.str_],\n        np.int_,\n        np.str_,\n        np.float64,\n        ]) -> dict[\n                int,\n                Series[                 # type of the container\n                        IndexYearMonth, # type of the index labels\n                        np.float64,     # type of the values\n                        ],\n                ]: ...\n```", "```py\nfrom typing import Any\nfrom static_frame import Frame, Series, Index, IndexYearMonth, IndexHierarchy\n\ndef process(f: Frame[\n        Any,\n        Index[np.str_],\n        np.int_,\n        np.str_,\n        np.float64,\n        ]) -> Series[                    # type of the container\n                IndexHierarchy[          # type of the index labels\n                        Index[np.int_],  # type of index depth 0\n                        IndexYearMonth], # type of index depth 1\n                np.float64,              # type of the values\n                ]: ...\n```", "```py\nfrom typing import Any\nfrom static_frame import Frame, Series, Index, IndexYearMonth, IndexHierarchy, CallGuard\n\n@CallGuard.check\ndef process(f: Frame[\n        Any,\n        Index[np.str_],\n        np.int_,\n        np.str_,\n        np.float64,\n        ]) -> Series[\n                IndexHierarchy[Index[np.int_], IndexYearMonth],\n                np.float64,\n                ]: ...\n```", "```py\nClinicError:\nIn args of (f: Frame[Any, Index[str_], int64, str_, float64]) -> Series[IndexHierarchy[Index[int64], IndexYearMonth], float64]\n└── Frame[Any, Index[str_], int64, str_, float64]\n    └── Expected Frame has 3 dtype, provided Frame has 2 dtype\nIn args of (f: Frame[Any, Index[str_], int64, str_, float64]) -> Series[IndexHierarchy[Index[int64], IndexYearMonth], float64]\n└── Frame[Any, Index[str_], int64, str_, float64]\n    └── Index[str_]\n        └── Expected str_, provided int64 invalid\n```", "```py\nfrom typing import Any, Annotated\nfrom static_frame import Frame, Series, Index, IndexYearMonth, IndexHierarchy, CallGuard, Require\n\n@CallGuard.check\ndef process(f: Frame[\n        Any,\n        Annotated[\n                Index[np.str_],\n                Require.LabelsOrder('permno', 'yyyymm', ...),\n                ],\n        np.int_,\n        np.str_,\n        np.float64,\n        ]) -> Series[\n                IndexHierarchy[Index[np.int_], IndexYearMonth],\n                np.float64,\n                ]: ...\n```", "```py\n@CallGuard.check\ndef process(f: Frame[\n        Any,\n        Annotated[\n                Index[np.str_],\n                Require.LabelsOrder('permno', 'yyyymm', ...),\n                Require.LabelsMatch({'Mom12m', 'Mom6m', 'LRreversal'}),\n                ],\n        np.int_,\n        np.str_,\n        np.float64,\n        ]) -> Series[\n                IndexHierarchy[Index[np.int_], IndexYearMonth],\n                np.float64,\n                ]: ...\n```", "```py\nfrom typing import Any, Annotated\nfrom static_frame import Frame, Series, Index, IndexYearMonth, IndexHierarchy, CallGuard, Require\n\n@CallGuard.check\ndef process(f: Frame[\n        Any,\n        Annotated[\n                Index[np.str_],\n                Require.LabelsOrder(\n                        ['permno', lambda s: (s > 0).all()],\n                        'yyyymm',\n                        ...,\n                        ),\n                Require.LabelsMatch(\n                        [{'Mom12m', 'Mom6m', 'LRreversal'}, lambda s: (s >= -1).all()],\n                        ),\n                ],\n        np.int_,\n        np.str_,\n        np.float64,\n        ]) -> Series[\n                IndexHierarchy[Index[np.int_], IndexYearMonth],\n                np.float64,\n                ]: ...\n```", "```py\nClinicError:\nIn args of (f: Frame[Any, Annotated[Index[str_], LabelsOrder(['permno', <lambda>], 'yyyymm', ...), LabelsMatch([{'Mom12m', 'LRreversal', 'Mom6m'}, <lambda>])], int64, str_, float64]) -> Series[IndexHierarchy[Index[int64], IndexYearMonth], float64]\n└── Frame[Any, Annotated[Index[str_], LabelsOrder(['permno', <lambda>], 'yyyymm', ...), LabelsMatch([{'Mom12m', 'LRreversal', 'Mom6m'}, <lambda>])], int64, str_, float64]\n    └── Annotated[Index[str_], LabelsOrder(['permno', <lambda>], 'yyyymm', ...), LabelsMatch([{'Mom12m', 'LRreversal', 'Mom6m'}, <lambda>])]\n        └── LabelsMatch([{'Mom12m', 'LRreversal', 'Mom6m'}, <lambda>])\n            └── Expected label to match frozenset({'Mom12m', 'LRreversal', 'Mom6m'}), no provided match\n```", "```py\n>>> from typing import Any\n>>> from static_frame import Frame, Index\n\n>>> f1: sf.Frame[Any, Any, np.float64, np.float64]\n>>> f2: sf.Frame[Any, Any, np.bool_, np.float64, np.int8, np.int8, np.str_, np.datetime64]\n```", "```py\n>>> from typing import Any\n>>> from static_frame import Frame, Index\n\n>>> f: sf.Frame[Index[np.datetime64], Index[np.str_], *tuple[All, ...]]\n```", "```py\n>>> from typing import Any\n>>> from static_frame import Frame\n\n>>> f: sf.Frame[Any, Any, np.bool_, np.str_, *tuple[np.float64, ...]]\n```", "```py\n>>> import static_frame as sf\n>>> f = sf.Frame.from_records(([3, '192004', 0.3], [3, '192005', -0.4]), columns=('permno', 'yyyymm', 'Mom3m'))\n\n>>> f.via_type_clinic\nFrame[Index[int64], Index[str_], int64, str_, float64]\n\n>>> f.via_type_clinic.to_hint()\nstatic_frame.core.frame.Frame[static_frame.core.index.Index[numpy.int64], static_frame.core.index.Index[numpy.str_], numpy.int64, numpy.str_, numpy.float64]\n```", "```py\n>>> f.via_type_clinic.check(sf.Frame[sf.Index[np.str_], sf.TIndexAny, *tuple[tp.Any, ...]])\nClinicError:\nIn Frame[Index[str_], Index[Any], Unpack[Tuple[Any, ...]]]\n└── Index[str_]\n    └── Expected str_, provided int64 invalid\n```", "```py\n>>> f.via_type_clinic.check(sf.TFrameAny)\n```"]