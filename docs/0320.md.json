["```py\n<html>\n  <head>\n  </head>\n<html>\n```", "```py\n<html>\n  <body>\n    <table>\n      <tr><td>Hello</td></tr>\n      <tr>\n        <td>\n          <table><tr><td>World</td></tr></table>\n        </td>\n      </tr>\n    </table>\n  </body>\n</html>\n```", "```py\n<html>\n  <body>\n    <div>Hello</div>\n  </body>\n</html>\n```", "```py\n<html>\n  <head>\n</html>\n```", "```py\n<html>\n  <head>\n  </html>\n</head>\n```", "```py\nSELECT\n  REGEXP_MATCHES(page, '</?[^>]+>', 'g') AS html_tag\nFROM html_string\n```", "```py\nSELECT\n  ROW_NUMBER() OVER () AS row_num,\n  html_tag[1],\n  REPLACE(html_tag[1], '/', '') AS root_tag,\n  CASE WHEN html_tag[1] LIKE '%/%' THEN -1 ELSE +1 END AS delta\nFROM page_as_rows\n```", "```py\nunpaired_tags(tag_name) AS (\n  -- Lets track tags that don't need a close tag and then\n  -- use this set to eliminate such tags from our list of\n  -- tags since they tags won't contribute to making the\n  -- input string invalid HTML.\n  VALUES('<br>'), ('<br/>')\n),\n\nonly_paired_tags AS (\n  -- Use the set \"unpaired_tags\" to keep only tags that\n  -- have an open and close pair.\n  SELECT\n    *\n  FROM tags_numbered\n  WHERE root_tag NOT IN (SELECT tag_name from unpaired_tags)\n),\n```", "```py\nWITH page_as_rows AS (\n  -- This returns a single row for every HTML open or close\n  -- tag in the original string. We assume an HTML tag to be\n  -- a string enclosed in angle brackets with an optional /\n  -- to indicate a close tag.\n  SELECT\n    REGEXP_MATCHES(page, '</?[^>]+>', 'g') AS html_tag\n  FROM html_string\n),\n\ntags_numbered AS (\n  -- Let's number the rows so that we know what order the tags\n  -- are present in the original input string (document). We\n  -- also replace the close tag with the open tag (by removing\n  -- the / character) so that we can later match up an open and\n  -- a close tag. We keep track of whether a tag is an open or\n  -- close tag by assigning the value +1 or -1 (in a column\n  -- named delta) along with each row. This will later help\n  -- us determine if any prefix of the input string is a\n  -- valid intermediate state for an HTML document.\n  SELECT\n    ROW_NUMBER() OVER () AS row_num,\n    html_tag[1],\n    REPLACE(html_tag[1], '/', '') AS root_tag,\n    CASE WHEN html_tag[1] LIKE '%/%' THEN -1 ELSE +1 END AS delta\n  FROM page_as_rows\n),\n\nunpaired_tags(tag_name) AS (\n  -- Lets track tags that don't need a close tag and then\n  -- use this set to eliminate such tags from our list of\n  -- tags since they tags won't contribute to making the\n  -- input string invalid HTML.\n  VALUES('<br>'), ('<br/>')\n),\n\nonly_paired_tags AS (\n  -- Use the set \"unpaired_tags\" to keep only tags that\n  -- have an open and close pair.\n  SELECT\n    *\n  FROM tags_numbered\n  WHERE root_tag NOT IN (SELECT tag_name from unpaired_tags)\n),\n\nself_joined AS (\n  -- This the main logic. We generate a prefix of the document\n  -- ending at every tag. We generate O(n^2) such prefixes and\n  -- use that to check if that prefix is a valid prefix of any\n  -- HTML document.\n  SELECT\n    rhs.row_num, lhs.html_tag, lhs.root_tag, lhs.delta\n  FROM only_paired_tags lhs INNER JOIN only_paired_tags rhs\n  ON lhs.row_num <= rhs.row_num\n  ORDER BY rhs.row_num ASC, lhs.row_num ASC\n),\n\ngrouped AS (\n  -- Do check validity, we need to first determine:\n  -- 1\\. If we have seen a close tag before its corresponding\n  --    open tag. If this happens, then nthe running sum\n  --    for one of the tag elements will become negative (<0).\n  -- 2\\. If the final row of aggregated tag running sums has\n  --    all zeros. If there is a value that is greater than 0\n  --    it indicates that we have an open tag without a\n  --    corresponding close tag. While this is a valid\n  --    \"intermediate\" state to be in, it is NOT a valid\n  --    \"final\" state to be in.\n  SELECT\n    row_num, root_tag, SUM(delta) AS delta_sum\n  FROM self_joined\n  GROUP BY 1, 2\n),\n\nmin_max_for_prefix AS (\n  -- Compute the MIN and MAX delta sums across all tags\n  -- for every prefix of the input string.\n  SELECT\n    row_num,\n    MIN(delta_sum) AS min_delta_sum,\n    MAX(delta_sum) AS max_delta_sum\n  FROM grouped\n  GROUP BY 1\n  ORDER BY row_num ASC\n),\n\noverall_min_max AS (\n  -- Then check if any of the running sums are negative OR\n  -- if the running sum for the entire document is a value\n  -- other than 0.\n  SELECT\n    MIN(min_delta_sum) AS overall_min,\n    MAX(\n      CASE WHEN row_num = (\n        SELECT MAX(row_num) FROM min_max_for_prefix\n      ) THEN max_delta_sum ELSE NULL END\n    ) AS last_row_max\n  FROM min_max_for_prefix\n)\n\nSELECT * FROM overall_min_max;\n```", "```py\n1  <html>\n2    <head>\n3    </html>\n4  </head>\n```", "```py\n<html>\n  <head>\n  </head>\n  <body>\n    <table>\n      <tr>\n        <td>\n        </td>\n      </tr>\n      <tr>\n        <td>\n        </td>\n      </tr>\n    </table>\n  </body>\n</html>\n```", "```py\n<html>\n  <body>\n    <table>\n      <tr>\n      </tr>\n    </body>\n  </table>\n</html>\n```", "```py\n-- Actual solution\nWITH RECURSIVE page_as_rows AS (\n  -- This returns a single row for every HTML open or close\n  -- tag in the original string. We assume an HTML tag to be\n  -- a string enclosed in angle brackets with an optional /\n  -- to indicate a close tag.\n  SELECT\n    REGEXP_MATCHES(page, '</?[^>]+>', 'g') AS html_tag\n  FROM html_string\n),\n\ntags_numbered AS (\n  -- Let's number the rows so that we know what order the tags\n  -- are present in the original input string (document). We\n  -- also replace the close tag with the open tag (by removing\n  -- the / character) so that we can later match up an open and\n  -- a close tag. We keep track of whether a tag is an open or\n  -- close tag by assigning the value +1 or -1 (in a column\n  -- named delta) along with each row. This will later help\n  -- us determine if any prefix of the input string is a\n  -- valid intermediate state for an HTML document.\n  SELECT\n    ROW_NUMBER() OVER () AS row_num,\n    html_tag[1] AS html_tag,\n    REPLACE(html_tag[1], '/', '') AS root_tag,\n    CASE WHEN html_tag[1] LIKE '%/%' THEN -1 ELSE +1 END AS delta\n  FROM page_as_rows\n),\n\nunpaired_tags(tag_name) AS (\n  -- Lets track tags that don't need a close tag and then\n  -- use this set to eliminate such tags from our list of\n  -- tags since they tags won't contribute to making the\n  -- input string invalid HTML.\n  VALUES('<br>'), ('<br/>')\n),\n\nonly_paired_tags AS (\n  -- Use the set \"unpaired_tags\" to keep only tags that\n  -- have an open and close pair.\n  SELECT\n    *\n  FROM tags_numbered\n  WHERE root_tag NOT IN (SELECT tag_name from unpaired_tags)\n),\n\nmax_num_rounds AS (\n  -- The maximum number of recursive rounds of paired tag\n  -- elimination that we want to run.\n  SELECT\n    COUNT(1) / 2 + 2 AS max_rounds\n  FROM only_paired_tags\n),\n\n-- This recursive query matches and eliminates paired tags in an\n-- \"inside out\" manner by locating adjacent matching paired tags\n-- and removing them.\neliminate_paired_tags AS (\n  SELECT\n    row_num,\n    html_tag,\n    root_tag,\n    delta,\n    (SELECT max_rounds FROM max_num_rounds) AS iters\n  FROM only_paired_tags\n\n  UNION ALL\n\n  (\n    WITH lead_lag AS (\n      SELECT\n        row_num,\n        html_tag,\n        root_tag,\n        delta,\n        iters - 1 AS iters,\n        LAG(root_tag) OVER(ORDER BY row_num ASC) AS lag_root_tag,\n        LAG(delta) OVER(ORDER BY row_num ASC) AS lag_delta,\n        LEAD(root_tag) OVER(ORDER BY row_num ASC) AS lead_root_tag,\n        LEAD(delta) OVER(ORDER BY row_num ASC) AS lead_delta\n      FROM eliminate_paired_tags\n      WHERE iters - 1 > -1\n    ),\n\n    truncated AS (\n      SELECT\n        row_num,\n        html_tag,\n        root_tag,\n        delta,\n        iters\n      FROM lead_lag\n      -- Eliminate correctly paired tags. We eliminate a pair of rows\n      -- independently.\n      --\n      -- 1\\. If a row contains an open tag and is followed by a\n      -- corresponding close tag, we can eliminate the row with\n      -- this open tag.\n      --\n      -- 2\\. If a row contains an close tag and is preceeded by a\n      -- corresponding open tag, we can eliminate the row with\n      -- this close tag.\n      WHERE NOT (\n        (\n          root_tag = lag_root_tag AND delta = -1 AND lag_delta = +1\n        ) OR (\n          root_tag = lead_root_tag AND delta = +1 AND lead_delta = -1\n        )\n      )\n    )\n\n    SELECT * FROM truncated\n  )\n\n),\n\nfrom_last_round AS (\n  SELECT * FROM eliminate_paired_tags\n  WHERE iters = 0\n)\n\nSELECT\n  CASE\n    WHEN COUNT(1) > 0\n      THEN 'Invalid HTML'\n      ELSE 'Valid HTML'\n    END\n  AS validation_status\nFROM from_last_round; \n```"]