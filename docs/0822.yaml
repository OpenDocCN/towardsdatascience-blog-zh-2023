- en: Memoizing DataFrame Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/memoizing-dataframe-functions-7a27dff532f7?source=collection_archive---------5-----------------------#2023-03-03](https://towardsdatascience.com/memoizing-dataframe-functions-7a27dff532f7?source=collection_archive---------5-----------------------#2023-03-03)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Using Hashable DataFrames and Message Digests to Optimize Repeated Calculations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@flexatone?source=post_page-----7a27dff532f7--------------------------------)[![Christopher
    Ariza](../Images/35208ace15080724e4cd6690e43d6502.png)](https://medium.com/@flexatone?source=post_page-----7a27dff532f7--------------------------------)[](https://towardsdatascience.com/?source=post_page-----7a27dff532f7--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----7a27dff532f7--------------------------------)
    [Christopher Ariza](https://medium.com/@flexatone?source=post_page-----7a27dff532f7--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F6a4f500b1e4f&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmemoizing-dataframe-functions-7a27dff532f7&user=Christopher+Ariza&userId=6a4f500b1e4f&source=post_page-6a4f500b1e4f----7a27dff532f7---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----7a27dff532f7--------------------------------)
    ·7 min read·Mar 3, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F7a27dff532f7&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmemoizing-dataframe-functions-7a27dff532f7&user=Christopher+Ariza&userId=6a4f500b1e4f&source=-----7a27dff532f7---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F7a27dff532f7&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmemoizing-dataframe-functions-7a27dff532f7&source=-----7a27dff532f7---------------------bookmark_footer-----------)![](../Images/9187973a594d0c3bf5dc93fa4b623095.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Photo by Author
  prefs: []
  type: TYPE_NORMAL
- en: A well-known technique for improving the run-time performance of a software
    system (in Python or any language) is function memoization. Memoization is a type
    of caching applied to a single function. If a function is called multiple times
    with the same arguments, repeating the calculation can be avoided by storing the
    results in a mapping (or on disk), keyed by the arguments. Upon subsequent calls,
    if the arguments are found, the stored result is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'This opportunity comes with tradeoffs. Memoization reduces time at the cost
    of space: previously calculated results must be stored either in memory or on
    disk. Additionally, the function memoized must be pure: the output must be determined
    exclusively by its inputs. Finally, not all types of function arguments are suitable.
    With in-memory memoization, where results are stored in a mapping, arguments must
    be hashable and immutable. With disk-based memoization, where results are stored
    in a file, arguments must be reducible to a unique file name; a message digest
    derived from a cryptographic hash function is optimal for this purpose.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another challenge of memoization is cache invalidation: to avoid excessive
    cache growth, caches must be dropped. The Python standard library provides an
    in-memory solution with the `functools.lru_cache()` decorator. This decorator
    implements memoization with a “least recently used” (LRU) cache invalidation strategy:
    after reaching a maximum count, caches that have least-recently been used are
    dropped.'
  prefs: []
  type: TYPE_NORMAL
- en: For Python programmers using Pandas DataFrames as function arguments, there
    are further challenges. As mutable containers, Pandas `DataFrame` and `Series`
    are not hashable. The `functools.lru_cache()` will fail if an argument is a Pandas
    DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[StaticFrame](https://github.com/static-frame/static-frame) is an alternative
    DataFrame library that offers efficient solutions to this problem, both for in-memory
    and disk-based memoization.'
  prefs: []
  type: TYPE_NORMAL
- en: Hash Functions and Hash Collisions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before demonstrating DataFrame memoization with StaticFrame, it is important
    to distinguish different types of hash functions.
  prefs: []
  type: TYPE_NORMAL
- en: A hashing function converts a variable-sized value into a smaller, (generally)
    fixed-sized value. A hash collision is when different inputs hash to the same
    result. For some applications, hash collisions are acceptable. Cryptographic hash
    functions aim to eliminate collisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, the built-in `hash()` function converts hashable objects into an
    integer. Arbitrary types can provide support by implementing the magic method
    `__hash__()`. Importantly, the results of `hash()` are not collision resistant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Python dictionaries use `hash()` to transform dictionary keys into storage positions
    in a low-level C array. Collisions are expected, and if found, are resolved with
    equality comparisons using `__eq__()`. Thus, for an arbitrary type to be hashable,
    it needs to implement both `__hash__()` and `__eq__()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cryptographic hashing functions are unlike `hash()`: they are designed to avoid
    collisions. Python implements a collection of cryptographic hashing functions
    in the `hashlib` library. These functions consume byte data and return, with the
    `hexdigest()` method, a message digest as a string.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In-Memory Memoization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To memoize functions that take DataFrames as arguments, an immutable and hashable
    DataFrame is required. StaticFrame offers the `FrameHE` for this purpose, where
    “HE” stands for “hash, equals,” the two required implementations for Python hashability.
    While the StaticFrame `Frame` is immutable, it is not hashable.
  prefs: []
  type: TYPE_NORMAL
- en: The `FrameHE.__hash__()` method returns the `hash()` of the labels of the index
    and columns. While this will collide with any other `FrameHE` with the same labels
    but different values, using just the labels defers the more expensive full-value
    comparison to `__eq__()`.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of `FrameHE.__eq__()` simply delegates to `Frame.equals()`,
    a method that always returns a single Boolean. This contrasts with `Frame.__eq__()`,
    which returns an element-wise comparison in a Boolean `Frame`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With a `FrameHE` as an argument, the `cube()` function, decorated with `functools.lru_cache()`,
    can be used. If lacking a `FrameHE`, the `to_frame_he()` method can be used to
    efficiently create a `FrameHE` from other StaticFrame containers. As underlying
    NumPy array data is immutable and sharable among containers, this is a light-weight,
    no-copy operation. If coming from a Pandas DataFrame, `FrameHE.from_pandas()`
    can be used.
  prefs: []
  type: TYPE_NORMAL
- en: In the example below, `cube()` is called with the `FrameHE` created above. The
    IPython `%time` utility shows that, after being called once, subsequent calls
    with the same argument are three orders of magnitude faster (from ms to µs).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: While helpful for in-memory memoization, `FrameHE` instances can also be members
    of sets, offering a novel approach to collecting unique containers.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Message Digest from a DataFrame
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While in-memory memoization offers optimal performance, caches consume system
    memory and do not persist beyond the life of the process. If function results
    are large, or caches should persist, disk-based memoization is an alternative.
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, mutability and hashability of arguments is irrelevant. Instead,
    cached results can be retrieved from a file with a name derived from the arguments.
    Applying a cryptographic hash function on the arguments is ideal for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: As such hash functions generally take byte data as input, a `Frame` and all
    of its components must be converted to a byte representation. A common approach
    is to serialize the `Frame` as JSON (or some other string representation), which
    can then be converted to bytes. As underlying NumPy array data is already stored
    in bytes, converting that data to strings is inefficient. Further, as JSON does
    not support the full range of NumPy types, the JSON input might also be insufficiently
    distinct, leading to collisions.
  prefs: []
  type: TYPE_NORMAL
- en: StaticFrame offers `via_hashlib()` to meet this need, providing an efficient
    way to provide byte input to cryptographic hash functions found in the Python
    `hashlib` module. An example using SHA-256 is given below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: First, `via_hashlib()` is called with options to determine which container components
    should be included in the input bytes. As the default `name` attribute, `None`,
    is not byte encodable, it is excluded. Second, the hash function constructor `sha256()`
    is called, returning an instance loaded with the appropriate input bytes. Third,
    the `hexdigest()` method is called to return the message digest as a string. Alternative
    cryptographic hash function constructors, such as `sha3_256`, `shake_256`, and
    `blake2b` are available.
  prefs: []
  type: TYPE_NORMAL
- en: To create the input bytes, StaticFrame concatenates all underlying byte data
    (both values and labels), optionally including container metadata (such as `name`
    and `__class__.__name__` attributes). This same byte representation is available
    with the `via_hashlib().to_bytes()` method. If necessary, this can be combined
    with other byte data to create a hash digest based on multiple components.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: StaticFrame’s built-in support for creating message digests is shown to be more
    efficient than two common approaches with Pandas. The first approach uses the
    Pandas utility function `pd.hash_pandas_object()` to derive per-column integer
    hashes. This routine uses a bespoke digest algorithm that makes no claim of cryptographic
    collision resistance. For comparison here, those per-column integer hashes are
    used as input to a `hashlib` message digest function. The second approach provides
    a JSON representation of the entire DataFrame as input to a `hashlib` message
    digest function. While this may be more collision resistant than `pd.hash_pandas_object()`,
    it is often slower. The following chart displays performance characteristics of
    these two approaches compared to `via_hashlib()`. Over a range of DataFrame shapes
    and type mixtures, `via_hashlib()` outperforms all except one.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e91a4ac7663ef6a30e0b4cf92a7340ed.png)'
  prefs: []
  type: TYPE_IMG
- en: Chart by Author
  prefs: []
  type: TYPE_NORMAL
- en: Disk-Based Memoization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given a means to convert a DataFrame into a hash digest, a disk-based caching
    routine can be implemented. The decorator below does this for the narrow case
    of a function that takes and returns a single `Frame`. In this routine, a file
    name is derived from a message digest of the argument, prefixed by the name of
    the function. If the file name does not exist, the decorated function is called
    and the result is written. If the file name does exist, it is loaded and returned.
    Here, the StaticFrame NPZ file format is used. As demonstrated in a recent PyCon
    [talk](https://youtu.be/HLH5AwF-jx4), storing a `Frame` as an NPZ is often much
    faster than Parquet and related formats, and provides complete round-trip serialization.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To demonstrate this decorator, it can be applied to a function that iterates
    over windows of ten rows, sums the columns, and then concatenates the results
    into a single `Frame`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: After first usage, performance is reduced to less than twenty percent of the
    original run time. While loading a disk-based cache is slower than retrieving
    an in-memory cache, the benefit of avoiding repeated calculations is gained without
    consuming memory and with the opportunity of persistent caches.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `via_hashlib()` interfaces can be used in other situations as a digital
    signature or checksum of all characteristics of a DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If pure functions are called multiple times with the same arguments, memoization
    can vastly improve performance. While functions that input and output DataFrames
    require special handling, StaticFrame offers convenient tools to implement both
    in-memory and disk-based memoization. While care must be taken to ensure that
    caches are properly invalidated and collisions are avoided, great performance
    benefits can be realized when repeated work is eliminated.
  prefs: []
  type: TYPE_NORMAL
