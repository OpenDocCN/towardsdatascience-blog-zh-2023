- en: 'Mixed Integer Linear Programming: Formal definition and solution space'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/mixed-integer-linear-programming-formal-definition-and-solution-space-6b3286d54892?source=collection_archive---------2-----------------------#2023-02-21](https://towardsdatascience.com/mixed-integer-linear-programming-formal-definition-and-solution-space-6b3286d54892?source=collection_archive---------2-----------------------#2023-02-21)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Theoretical foundations on how MILP is defined and how its solution space looks
    like visually
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@modosist?source=post_page-----6b3286d54892--------------------------------)[![István
    Módos](../Images/23a22dc06f5a5ae26a2ce24e6d69ddf4.png)](https://medium.com/@modosist?source=post_page-----6b3286d54892--------------------------------)[](https://towardsdatascience.com/?source=post_page-----6b3286d54892--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----6b3286d54892--------------------------------)
    [István Módos](https://medium.com/@modosist?source=post_page-----6b3286d54892--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fe14f7a362f6f&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmixed-integer-linear-programming-formal-definition-and-solution-space-6b3286d54892&user=Istv%C3%A1n+M%C3%B3dos&userId=e14f7a362f6f&source=post_page-e14f7a362f6f----6b3286d54892---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----6b3286d54892--------------------------------)
    ·10 min read·Feb 21, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F6b3286d54892&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmixed-integer-linear-programming-formal-definition-and-solution-space-6b3286d54892&user=Istv%C3%A1n+M%C3%B3dos&userId=e14f7a362f6f&source=-----6b3286d54892---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F6b3286d54892&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmixed-integer-linear-programming-formal-definition-and-solution-space-6b3286d54892&source=-----6b3286d54892---------------------bookmark_footer-----------)![](../Images/75859fc54c2dc8f3fe724ae323d022b5.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Photo by [Ivan Bandura](https://unsplash.com/@unstable_affliction?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: This post is a continuation of the series ([previous post](/mixed-integer-linear-programming-1-bc0ef201ee87))
    on the theory and applications of Mixed Integer Linear Programming (MILP). Today,
    we look at
  prefs: []
  type: TYPE_NORMAL
- en: the formal, general definition of MILP,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: how its space of feasible solutions looks like.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first part describes how MILP models look in general, what are and are not
    valid MILP expressions. The second part shows a little bit of theory behind MILP,
    which will be useful in the future posts when we will be talking about the actual
    algorithm for solving MILP.
  prefs: []
  type: TYPE_NORMAL
- en: This is quite a long post, so grab a coffee and dive in!
  prefs: []
  type: TYPE_NORMAL
- en: Formal definition of Mixed Integer Linear Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following text, I will use upper-case bold letters (e.g., ***A***, ***E***)
    for matrices and lower-case bold letters for vectors (e.g., ***x***, ***y***).
    MILP is an *optimisation problem* that can be formulated in matrix notation as
    follows
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/173ffb14d08527cfda0d96a3474f2b34.png)'
  prefs: []
  type: TYPE_IMG
- en: Lets break this monster down. We are given a *problem instance* represented
    by matrices and vectors ***A***, ***E***, ***b***, ***f***, ***c***, ***d*** from
    various domains (ℝ stands for a set of real numbers and ℤ for a set of integer
    numbers). For example, if we return to our budget problem from the first post,
    the problem instance represents assets, their costs, estimated profits and also
    the budget. We say that integer vector ***x*** and continuous vector ***y*** are
    a *feasible solution* to the given problem instance, if the following conditions
    holds
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2767e4ea01ff77949febab73a238dbd2.png)'
  prefs: []
  type: TYPE_IMG
- en: By writing these conditions component-wise, we get
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5e4e4824910d02fd570cc0214d88aee7.png)'
  prefs: []
  type: TYPE_IMG
- en: where 𝒂ᵢ are the rows of matrix ***A*** and 𝒆ᵢ are the rows of matrix ***E***.
    These inequalities are called *constraints*.
  prefs: []
  type: TYPE_NORMAL
- en: In MILP, we are looking for a feasible solution ***x***, ***y*** which minimises
    the *objective function*
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2d0f1d6a67fed19d77d334fd9aa5efff.png)'
  prefs: []
  type: TYPE_IMG
- en: If such a solution exists, we call it an *optimal* solution. In case you are
    wondering, it is possible to maximise the objective function instead; just multiply
    it with -1 and minimise the resulting expression. There is no guarantee that a
    feasible solution (let alone optimal) exists, but lets defer the discussion about
    these situations to the later section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the matrix form is a canonical way how MILP problems are defined,
    model designers usually do not use it as it is very cumbersome. Instead, in practice
    we define constraints and objective functions using simple mathematical expressions,
    which will be converted internally by the solver to the matrix form (which is
    actually very handy for a machine). To get a feel what is correct MILP formulation
    and what is not, here is a list of a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 𝑎₁𝑥₁ + 𝑎₂ + 𝑥₃ ≥ 𝑏₁ + 𝑎₄𝑥₄ is a correct MILP constraint. Notice that in comparison
    to the canonical form, the inequality is reversed, a constant is included in the
    left hand side and I added a variable to the right hand side. In a canonical form,
    this constraint would be transformed to −𝑎₁𝑥₁ − 𝑥₃ + 𝑎₄𝑥₄ ≤ −𝑏₁ + 𝑎₂ .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 𝑥₁𝑥₂ is not a correct MILP expression as it is a multiplication of two variables,
    which is not a linear expression. The same goes for |𝑥₁|, max(𝑥₁, 𝑥₂), log(𝑥₁),
    etc. All of those expressions are not linear, although some of them can be *linearised*
    through various tricks, but more on that in another post.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 𝑎₁𝑎₂ is a correct MILP expression as multiplying two fixed parameters together
    would result in a single fixed parameter in “compile” time, i.e., during building
    the matrix model but before starting the solver. Expressions where fixed parameters
    are transformed by a mathematical functions (such as logarithm) are also correct
    MILP expressions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 𝑎ₓ is not a correct MILP expression. We cannot use a variable as an index.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 𝑎₁𝑥₁ < 𝑏₁ is not a correct MILP constraint, it is not possible to force strict
    inequality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We finish this section by showing a MILP formulation of the budget problem from
    the previous post in a matrix form.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/938e6432d1271aa0fc74dd6e6d388dd2.png)'
  prefs: []
  type: TYPE_IMG
- en: The objective uses the *multiplication by -1* trick to maximise the expected
    profit. The budget constraint is encoded in the first row of the constraint matrix
    and the remaining rows correspond to constraints 0 ≤ 𝑥ᵢ, 𝑥ᵢ ≤ 1 on each variable
    𝑥ᵢ (i.e., 𝑥ᵢ is required to be binary). Many solvers allow to specify the domain
    of the variables directly, so usually there is no need create such constraints
    by hand. Also, notice that our model includes only integer variables (there is
    no **y** variable), thus it is an *integer linear program*.
  prefs: []
  type: TYPE_NORMAL
- en: Solution space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we know how the space of feasible solutions of MILP models looks like,
    we may start to reason about the general algorithm for MILP, its theoretical properties
    and possibly how to make more performant models.
  prefs: []
  type: TYPE_NORMAL
- en: Lets start with the following MILP model. For simplicity, we will consider only
    two integer variables 𝑥₁, 𝑥₂.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9abbdb5b0074ad32c418ffa2df4fdddd.png)'
  prefs: []
  type: TYPE_IMG
- en: How can we visualise this model graphically? We start by empty 2D graph representing
    a model with no constraint. Gradually, we add constraint by constraint until we
    have a full model. In the graph, the horizontal and vertical axes correspond to
    values of 𝑥₁ and 𝑥₂, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1129d4960fa52909962d650079beba7e.png)'
  prefs: []
  type: TYPE_IMG
- en: As there is currently no constraint in the model, every combination of 𝑥₁, 𝑥₂
    is a feasible solution. Lets add a first constraint 4𝑥₁ ≥ 2𝑥₂ and see what happens.
    First, draw a line 4𝑥₁ = 2𝑥₂ in the solution space.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/acfe2679fc2c9774b422db5e43b02087.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This line is a boundary between two *half-spaces* defined by the following
    inequalities: 4𝑥₁ > 2𝑥₂ and 4𝑥₁ < 2𝑥₂. All the points on one side of the line
    satisfy inequality 4𝑥₁ > 2𝑥₂ and all the points on the other side of line satisfy
    inequality 4𝑥₁ < 2𝑥₂. When I want to know which half-space represents a specific
    constraint, I will pick some random point 𝑥₁, 𝑥₂ that does not lie on the line,
    substitute it into the constraint, and check whether the constraint is satisfied.
    If yes, then the half-space containing this point is the one that corresponds
    to the constraint. If not, then the other half-space is the correct one.'
  prefs: []
  type: TYPE_NORMAL
- en: So as an example, lets pick point 𝑥₁ = 5, 𝑥₂ = 3\. Substitute the values into
    constraint
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0eb690e189fe00b1ffb98698ed39f0c7.png)'
  prefs: []
  type: TYPE_IMG
- en: and we see that the constraint is satisfied. Therefore, the half-space containing
    this point is the one where all the points satisfy this constraint. In the graphs
    I will denote the half-space satisfying a constraint by an arrow. Of course, the
    points on the line also satisfy the constraint so a constraint is represented
    by both a boundary line and a half-space.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/df7bf59eb14f3338298bcab39c566b1a.png)'
  prefs: []
  type: TYPE_IMG
- en: Lets add another constraint −2𝑥₁ + 30 ≥ 2𝑥₂. Again, we start by drawing a boundary
    line −2𝑥₁ + 30 = 2𝑥₂.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/296b7291a09da73d404d83e9bf81d263.png)'
  prefs: []
  type: TYPE_IMG
- en: Which half-space satisfies this constraint? For this test, we pick a point 𝑥₁
    = 14, 𝑥₂= 6 and substitute it into the constraint
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9533880bffa9546897e306a6308acab6.png)'
  prefs: []
  type: TYPE_IMG
- en: We see that the selected point does not satisfy the constraint −2𝑥₁ + 30 ≥ 2𝑥₂
    so the feasible half-space must be the other one then the one containing point
    𝑥₁ = 14, 𝑥₂= 6 .
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/462494ac571b28d1925fe680731d0b77.png)'
  prefs: []
  type: TYPE_IMG
- en: However, now as we have two constraints in the model, the feasible solution
    space is an *intersection* of the feasible half-spaces of each constraint. The
    reason is that we want all the constraints to be satisfied so only the solutions
    that lie in all feasible half-spaces are also feasible in the whole model.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9798bd7cbba683a5ca64c3be2862e8ff.png)'
  prefs: []
  type: TYPE_IMG
- en: Now it should be clear how to proceed with constraints 𝑥₂ ≥ 0, 0.5𝑥₁ + 3.75
    ≥ 𝑥₂, so I will just draw the new feasible solution space.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a987bfb22e8837cd7ec76e4206d66db1.png)'
  prefs: []
  type: TYPE_IMG
- en: There is one thing left and that is the integrality constraint 𝑥₁, 𝑥₂ ∈ ℤ that
    we silently ignored at the beginning. What does this constraint mean? Simply,
    not all points from the coloured region are actually feasible, but only those
    where both 𝑥₁, 𝑥₂ are integers. We can visualise them by a grid, thus, the final
    feasible solution space of the example MILP model looks like this.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b15777d54e00b520383e6d34027d8450.png)'
  prefs: []
  type: TYPE_IMG
- en: Space of the feasible solutions for the example MILP model. The feasible solutions
    are denoted by red dots, black lines represent boundary of the constraints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of those red points correspond to one feasible integer solution which
    satisfy all the constraints. Now, the last question is: which of those points
    optimise our objective function, i.e., which point gives us the smallest value
    of −2𝑥₁ − 3𝑥₂? This question is little bit more involved. We could extend our
    graph to a third dimension representing the values of the objective function,
    project the feasible solutions to a plane of our objective function and find the
    projected point that is the lowest. However, I think that it is a nice mental
    exercise to stay in 2D space and find the optimum there.'
  prefs: []
  type: TYPE_NORMAL
- en: Many of you are probably familiar with the concept of a *gradient*, as it is
    a backbone of many ML training algorithms. In short, a gradient of a function
    represents a direction of the largest increase of that function at some point.
    That is, if we move along the gradient, we will increase the function. Knowing
    the gradient of the MILP’s objective function tells us where to look for the optimal
    feasible solution. So, lets find the gradient of our objective function, which
    we obtain by taking the partial derivatives by each variable 𝑥₁, 𝑥₂
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/71c4de42e15397fbad2a7c85ba73050a.png)'
  prefs: []
  type: TYPE_IMG
- en: Since our objective function is linear, its gradient is the same for every point
    in the solution space. And since gradient is a direction, we can draw a vector
    into our solution space to show the direction of the increase in the objective
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4c8c8828827b42f866d88b2795ea82b9.png)'
  prefs: []
  type: TYPE_IMG
- en: Lets draw a contour lines of the objective (a contour line has the same objective
    value for every point on that line). It can be proven that contour lines are perpendicular
    to a gradient, so once we have the gradient, it is easy to draw the contours.
    As we move in the opposite direction of the gradient, the objective value on the
    contour lines decreases until we cannot move any further as we would be outside
    of the feasible space. You can imagine this process as moving a ruler, which is
    perpendicular to the gradient, along the direction opposite to the gradient until
    you touch the last feasible solution. In our example, the optimal solution is
    at 𝑥₁ = 8, 𝑥₂ = 7 with the objective value of −37\. Phew!
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/02b09773755504b4829369004861b919.png)'
  prefs: []
  type: TYPE_IMG
- en: If you are intersted in how to write this MILP model in Python, here is the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Optimisation outcomes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the example above, we found an optimal solution. However, this is not always
    guaranteed. In theory, the optimisation might end up with one of the following
    three outcomes: optimal solution found, infeasible model, or unbounded objective.'
  prefs: []
  type: TYPE_NORMAL
- en: Other outcomes are also possible (e.g., time-limit reached, out-of-memory, etc.)
    but they are related to practise, not theory of integer programming so I will
    not discuss them in this post.
  prefs: []
  type: TYPE_NORMAL
- en: 'Optimisation outcome: optimal solution found'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already saw a couple of examples where we found an optimal solution (e.g.,
    budget problem). I would like to highlight that there might be multiple optimal
    solutions with the same objective value. For example, if we replace the objective
    in the above defined model by 10𝑥₂, then all the points lying on line x₂ = 0 in
    the feasible solution space are optimal with objective value of 0\. Multiple runs
    of the optimisation solver with various random seeds will probably give different
    optimal solutions, so do not expect an unique solution to be returned all the
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Optimisation outcome: infeasible model'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Infeasible models are the ones for which there is no feasible solution that
    would satisfy all the constraints. An example of an infeasible model is the following.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/db1aa79553956020c3c06b9c7c22f5f9.png)'
  prefs: []
  type: TYPE_IMG
- en: There is no value of 𝑥₁ which would satisfy both 𝑥₁ ≥ 6 and 𝑥₁ ≤ 2, so the intersection
    of the feasible half-spaces of these constraints is an empty set.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b49a9ecbd2477c1ba54b3fc5d804dad8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Optimisation outcome: unbounded objective'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This one is a little bit weird, but unfortunately, it may occur. Usually in
    practise, it is a sign of an ill-defined model, e.g., when an essential constraint
    is not included in a model.
  prefs: []
  type: TYPE_NORMAL
- en: Unbounded objective means that for every feasible solution, we can find another
    feasible solution having a smaller objective value. In other words, the optimal
    objective value converges to negative infinity. Here is a model with an unbounded
    objective.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8313cb3c2128852fba51d71957be5b38.png)'
  prefs: []
  type: TYPE_IMG
- en: The feasible solution space is so unconstrained, that we increase 𝑥₂ to any
    value we want and in turn the objective will decrease.
  prefs: []
  type: TYPE_NORMAL
- en: Wrap-up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now, you should be able to solve any MILP model with two integer variables
    using just pen, paper and a ruler! Of course, the actual computer algorithms for
    solving MILPs are more complicated, but the visual understanding of the solution
    space will come handy when we study the algorithms in some future post.
  prefs: []
  type: TYPE_NORMAL
- en: '*All images unless otherwise noted are by the author.*'
  prefs: []
  type: TYPE_NORMAL
