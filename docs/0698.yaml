- en: 'Mixed Integer Linear Programming: Formal definition and solution space'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ··åˆæ•´æ•°çº¿æ€§è§„åˆ’ï¼šæ­£å¼å®šä¹‰ä¸è§£ç©ºé—´
- en: åŸæ–‡ï¼š[https://towardsdatascience.com/mixed-integer-linear-programming-formal-definition-and-solution-space-6b3286d54892?source=collection_archive---------2-----------------------#2023-02-21](https://towardsdatascience.com/mixed-integer-linear-programming-formal-definition-and-solution-space-6b3286d54892?source=collection_archive---------2-----------------------#2023-02-21)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://towardsdatascience.com/mixed-integer-linear-programming-formal-definition-and-solution-space-6b3286d54892?source=collection_archive---------2-----------------------#2023-02-21](https://towardsdatascience.com/mixed-integer-linear-programming-formal-definition-and-solution-space-6b3286d54892?source=collection_archive---------2-----------------------#2023-02-21)
- en: Theoretical foundations on how MILP is defined and how its solution space looks
    like visually
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MILP çš„ç†è®ºåŸºç¡€ä»¥åŠå…¶è§£ç©ºé—´çš„è§†è§‰è¡¨ç°
- en: '[](https://medium.com/@modosist?source=post_page-----6b3286d54892--------------------------------)[![IstvÃ¡n
    MÃ³dos](../Images/23a22dc06f5a5ae26a2ce24e6d69ddf4.png)](https://medium.com/@modosist?source=post_page-----6b3286d54892--------------------------------)[](https://towardsdatascience.com/?source=post_page-----6b3286d54892--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----6b3286d54892--------------------------------)
    [IstvÃ¡n MÃ³dos](https://medium.com/@modosist?source=post_page-----6b3286d54892--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@modosist?source=post_page-----6b3286d54892--------------------------------)[![IstvÃ¡n
    MÃ³dos](../Images/23a22dc06f5a5ae26a2ce24e6d69ddf4.png)](https://medium.com/@modosist?source=post_page-----6b3286d54892--------------------------------)[](https://towardsdatascience.com/?source=post_page-----6b3286d54892--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----6b3286d54892--------------------------------)
    [IstvÃ¡n MÃ³dos](https://medium.com/@modosist?source=post_page-----6b3286d54892--------------------------------)'
- en: Â·
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Â·
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fe14f7a362f6f&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmixed-integer-linear-programming-formal-definition-and-solution-space-6b3286d54892&user=Istv%C3%A1n+M%C3%B3dos&userId=e14f7a362f6f&source=post_page-e14f7a362f6f----6b3286d54892---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----6b3286d54892--------------------------------)
    Â·10 min readÂ·Feb 21, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F6b3286d54892&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmixed-integer-linear-programming-formal-definition-and-solution-space-6b3286d54892&user=Istv%C3%A1n+M%C3%B3dos&userId=e14f7a362f6f&source=-----6b3286d54892---------------------clap_footer-----------)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[å…³æ³¨](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fe14f7a362f6f&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmixed-integer-linear-programming-formal-definition-and-solution-space-6b3286d54892&user=Istv%C3%A1n+M%C3%B3dos&userId=e14f7a362f6f&source=post_page-e14f7a362f6f----6b3286d54892---------------------post_header-----------)
    å‘å¸ƒäº [Towards Data Science](https://towardsdatascience.com/?source=post_page-----6b3286d54892--------------------------------)
    Â· 10 åˆ†é’Ÿé˜…è¯»Â·2023å¹´2æœˆ21æ—¥[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F6b3286d54892&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmixed-integer-linear-programming-formal-definition-and-solution-space-6b3286d54892&user=Istv%C3%A1n+M%C3%B3dos&userId=e14f7a362f6f&source=-----6b3286d54892---------------------clap_footer-----------)'
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F6b3286d54892&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmixed-integer-linear-programming-formal-definition-and-solution-space-6b3286d54892&source=-----6b3286d54892---------------------bookmark_footer-----------)![](../Images/75859fc54c2dc8f3fe724ae323d022b5.png)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F6b3286d54892&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fmixed-integer-linear-programming-formal-definition-and-solution-space-6b3286d54892&source=-----6b3286d54892---------------------bookmark_footer-----------)![](../Images/75859fc54c2dc8f3fe724ae323d022b5.png)'
- en: Photo by [Ivan Bandura](https://unsplash.com/@unstable_affliction?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡ç”± [Ivan Bandura](https://unsplash.com/@unstable_affliction?utm_source=medium&utm_medium=referral)
    æä¾›ï¼Œæ¥æºäº [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: This post is a continuation of the series ([previous post](/mixed-integer-linear-programming-1-bc0ef201ee87))
    on the theory and applications of Mixed Integer Linear Programming (MILP). Today,
    we look at
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬æ–‡æ˜¯å…³äºæ··åˆæ•´æ•°çº¿æ€§è§„åˆ’ï¼ˆMILPï¼‰ç†è®ºå’Œåº”ç”¨ç³»åˆ—çš„å»¶ç»­ï¼ˆ[ä¸Šä¸€ç¯‡æ–‡ç« ](/mixed-integer-linear-programming-1-bc0ef201ee87)ï¼‰ã€‚ä»Šå¤©ï¼Œæˆ‘ä»¬å°†æ¢è®¨
- en: the formal, general definition of MILP,
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MILP çš„æ­£å¼ã€ä¸€èˆ¬å®šä¹‰ï¼Œ
- en: how its space of feasible solutions looks like.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä»¥åŠå…¶å¯è¡Œè§£ç©ºé—´çš„è§†è§‰è¡¨ç°ã€‚
- en: The first part describes how MILP models look in general, what are and are not
    valid MILP expressions. The second part shows a little bit of theory behind MILP,
    which will be useful in the future posts when we will be talking about the actual
    algorithm for solving MILP.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬ä¸€éƒ¨åˆ†æè¿°äº† MILP æ¨¡å‹çš„ä¸€èˆ¬å¤–è§‚ï¼Œå“ªäº›æ˜¯æœ‰æ•ˆçš„ MILP è¡¨è¾¾å¼ï¼Œå“ªäº›ä¸æ˜¯ã€‚ç¬¬äºŒéƒ¨åˆ†å±•ç¤ºäº† MILP èƒŒåçš„ç†è®ºï¼Œè¿™å°†åœ¨æœªæ¥çš„å¸–å­ä¸­è®¨è®ºå®é™…çš„
    MILP æ±‚è§£ç®—æ³•æ—¶éå¸¸æœ‰ç”¨ã€‚
- en: This is quite a long post, so grab a coffee and dive in!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç¯‡æ–‡ç« æ¯”è¾ƒé•¿ï¼Œæ‰€ä»¥è¯·æ‹¿æ¯å’–å•¡ï¼Œæ·±å…¥é˜…è¯»å§ï¼
- en: Formal definition of Mixed Integer Linear Programming
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ··åˆæ•´æ•°çº¿æ€§è§„åˆ’çš„æ­£å¼å®šä¹‰
- en: In the following text, I will use upper-case bold letters (e.g., ***A***, ***E***)
    for matrices and lower-case bold letters for vectors (e.g., ***x***, ***y***).
    MILP is an *optimisation problem* that can be formulated in matrix notation as
    follows
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ¥ä¸‹æ¥çš„æ–‡æœ¬ä¸­ï¼Œæˆ‘å°†ä½¿ç”¨å¤§å†™ç²—ä½“å­—æ¯ï¼ˆä¾‹å¦‚ï¼Œ***A***ã€***E***ï¼‰è¡¨ç¤ºçŸ©é˜µï¼Œä½¿ç”¨å°å†™ç²—ä½“å­—æ¯è¡¨ç¤ºå‘é‡ï¼ˆä¾‹å¦‚ï¼Œ***x***ã€***y***ï¼‰ã€‚MILP
    æ˜¯ä¸€ä¸ª*ä¼˜åŒ–é—®é¢˜*ï¼Œå¯ä»¥ç”¨çŸ©é˜µè¡¨ç¤ºæ³•å½¢å¼åŒ–å¦‚ä¸‹ï¼š
- en: '![](../Images/173ffb14d08527cfda0d96a3474f2b34.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/173ffb14d08527cfda0d96a3474f2b34.png)'
- en: Lets break this monster down. We are given a *problem instance* represented
    by matrices and vectors ***A***, ***E***, ***b***, ***f***, ***c***, ***d*** from
    various domains (â„ stands for a set of real numbers and â„¤ for a set of integer
    numbers). For example, if we return to our budget problem from the first post,
    the problem instance represents assets, their costs, estimated profits and also
    the budget. We say that integer vector ***x*** and continuous vector ***y*** are
    a *feasible solution* to the given problem instance, if the following conditions
    holds
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æŠŠè¿™ä¸ªéš¾é¢˜æ‹†è§£å¼€æ¥ã€‚æˆ‘ä»¬å¾—åˆ°ä¸€ä¸ªç”±çŸ©é˜µå’Œå‘é‡***A***ã€***E***ã€***b***ã€***f***ã€***c***ã€***d*** ä»£è¡¨çš„*é—®é¢˜å®ä¾‹*ï¼Œè¿™äº›çŸ©é˜µå’Œå‘é‡æ¥è‡ªä¸åŒé¢†åŸŸï¼ˆâ„ä»£è¡¨å®æ•°é›†åˆï¼Œâ„¤ä»£è¡¨æ•´æ•°é›†åˆï¼‰ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬å›åˆ°ç¬¬ä¸€ä¸ªå¸–å­ä¸­çš„é¢„ç®—é—®é¢˜ï¼Œè¿™ä¸ªé—®é¢˜å®ä¾‹è¡¨ç¤ºèµ„äº§ã€å®ƒä»¬çš„æˆæœ¬ã€ä¼°è®¡çš„åˆ©æ¶¦ä»¥åŠé¢„ç®—ã€‚æˆ‘ä»¬è¯´æ•´æ•°å‘é‡***x***å’Œè¿ç»­å‘é‡***y***æ˜¯ç»™å®šé—®é¢˜å®ä¾‹çš„*å¯è¡Œè§£*ï¼Œå¦‚æœæ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š
- en: '![](../Images/2767e4ea01ff77949febab73a238dbd2.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2767e4ea01ff77949febab73a238dbd2.png)'
- en: By writing these conditions component-wise, we get
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡é€é¡¹å†™å‡ºè¿™äº›æ¡ä»¶ï¼Œæˆ‘ä»¬å¾—åˆ°ï¼š
- en: '![](../Images/5e4e4824910d02fd570cc0214d88aee7.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5e4e4824910d02fd570cc0214d88aee7.png)'
- en: where ğ’‚áµ¢ are the rows of matrix ***A*** and ğ’†áµ¢ are the rows of matrix ***E***.
    These inequalities are called *constraints*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­ ğ’‚áµ¢ æ˜¯çŸ©é˜µ ***A*** çš„è¡Œï¼Œğ’†áµ¢ æ˜¯çŸ©é˜µ ***E*** çš„è¡Œã€‚è¿™äº›ä¸ç­‰å¼è¢«ç§°ä¸º*çº¦æŸ*ã€‚
- en: In MILP, we are looking for a feasible solution ***x***, ***y*** which minimises
    the *objective function*
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ MILP ä¸­ï¼Œæˆ‘ä»¬å¯»æ‰¾ä¸€ä¸ªå¯è¡Œè§£ ***x***ã€***y***ï¼Œä»¥æœ€å°åŒ–*ç›®æ ‡å‡½æ•°*ã€‚
- en: '![](../Images/2d0f1d6a67fed19d77d334fd9aa5efff.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2d0f1d6a67fed19d77d334fd9aa5efff.png)'
- en: If such a solution exists, we call it an *optimal* solution. In case you are
    wondering, it is possible to maximise the objective function instead; just multiply
    it with -1 and minimise the resulting expression. There is no guarantee that a
    feasible solution (let alone optimal) exists, but lets defer the discussion about
    these situations to the later section.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœå­˜åœ¨è¿™æ ·çš„è§£ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸º*æœ€ä¼˜è§£*ã€‚å¦‚æœä½ æƒ³çŸ¥é“ï¼Œå®é™…ä¸Šä¹Ÿå¯ä»¥æœ€å¤§åŒ–ç›®æ ‡å‡½æ•°ï¼›åªéœ€å°†å…¶ä¹˜ä»¥ -1 å¹¶æœ€å°åŒ–å¾—åˆ°çš„è¡¨è¾¾å¼ã€‚æ²¡æœ‰ä¿è¯å­˜åœ¨å¯è¡Œè§£ï¼ˆæ›´ä¸ç”¨è¯´æœ€ä¼˜è§£äº†ï¼‰ï¼Œä½†è®©æˆ‘ä»¬å°†å…³äºè¿™äº›æƒ…å†µçš„è®¨è®ºæ¨è¿Ÿåˆ°åé¢çš„éƒ¨åˆ†ã€‚
- en: 'Although the matrix form is a canonical way how MILP problems are defined,
    model designers usually do not use it as it is very cumbersome. Instead, in practice
    we define constraints and objective functions using simple mathematical expressions,
    which will be converted internally by the solver to the matrix form (which is
    actually very handy for a machine). To get a feel what is correct MILP formulation
    and what is not, here is a list of a few examples:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: å°½ç®¡çŸ©é˜µå½¢å¼æ˜¯å®šä¹‰ MILP é—®é¢˜çš„è§„èŒƒæ–¹å¼ï¼Œä½†æ¨¡å‹è®¾è®¡è€…é€šå¸¸ä¸ä½¿ç”¨å®ƒï¼Œå› ä¸ºå®ƒéå¸¸ç¹çã€‚ç›¸åï¼Œåœ¨å®é™…åº”ç”¨ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ç®€å•çš„æ•°å­¦è¡¨è¾¾å¼å®šä¹‰çº¦æŸå’Œç›®æ ‡å‡½æ•°ï¼Œè¿™äº›è¡¨è¾¾å¼ä¼šè¢«æ±‚è§£å™¨å†…éƒ¨è½¬æ¢ä¸ºçŸ©é˜µå½¢å¼ï¼ˆè¿™å¯¹æœºå™¨æ¥è¯´éå¸¸æ–¹ä¾¿ï¼‰ã€‚ä¸ºäº†äº†è§£ä»€ä¹ˆæ˜¯æ­£ç¡®çš„
    MILP è¡¨è¾¾å½¢å¼ï¼Œä»€ä¹ˆä¸æ˜¯ï¼Œè¿™é‡Œæœ‰ä¸€äº›ä¾‹å­ï¼š
- en: ğ‘â‚ğ‘¥â‚ + ğ‘â‚‚ + ğ‘¥â‚ƒ â‰¥ ğ‘â‚ + ğ‘â‚„ğ‘¥â‚„ is a correct MILP constraint. Notice that in comparison
    to the canonical form, the inequality is reversed, a constant is included in the
    left hand side and I added a variable to the right hand side. In a canonical form,
    this constraint would be transformed to âˆ’ğ‘â‚ğ‘¥â‚ âˆ’ ğ‘¥â‚ƒ + ğ‘â‚„ğ‘¥â‚„ â‰¤ âˆ’ğ‘â‚ + ğ‘â‚‚ .
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ğ‘â‚ğ‘¥â‚ + ğ‘â‚‚ + ğ‘¥â‚ƒ â‰¥ ğ‘â‚ + ğ‘â‚„ğ‘¥â‚„ æ˜¯ä¸€ä¸ªæ­£ç¡®çš„ MILP çº¦æŸã€‚æ³¨æ„ï¼Œä¸è§„èŒƒå½¢å¼ç›¸æ¯”ï¼Œä¸ç­‰å¼çš„æ–¹å‘è¢«åè½¬äº†ï¼Œä¸€ä¸ªå¸¸æ•°è¢«åŒ…å«åœ¨å·¦ä¾§ï¼Œæˆ‘è¿˜åœ¨å³ä¾§æ·»åŠ äº†ä¸€ä¸ªå˜é‡ã€‚åœ¨è§„èŒƒå½¢å¼ä¸­ï¼Œè¿™ä¸ªçº¦æŸä¼šè¢«è½¬æ¢ä¸º
    âˆ’ğ‘â‚ğ‘¥â‚ âˆ’ ğ‘¥â‚ƒ + ğ‘â‚„ğ‘¥â‚„ â‰¤ âˆ’ğ‘â‚ + ğ‘â‚‚ã€‚
- en: ğ‘¥â‚ğ‘¥â‚‚ is not a correct MILP expression as it is a multiplication of two variables,
    which is not a linear expression. The same goes for |ğ‘¥â‚|, max(ğ‘¥â‚, ğ‘¥â‚‚), log(ğ‘¥â‚),
    etc. All of those expressions are not linear, although some of them can be *linearised*
    through various tricks, but more on that in another post.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ğ‘¥â‚ğ‘¥â‚‚ ä¸æ˜¯ä¸€ä¸ªæ­£ç¡®çš„ MILP è¡¨è¾¾å¼ï¼Œå› ä¸ºå®ƒæ˜¯ä¸¤ä¸ªå˜é‡çš„ä¹˜ç§¯ï¼Œè¿™ä¸æ˜¯çº¿æ€§è¡¨è¾¾å¼ã€‚|ğ‘¥â‚|, max(ğ‘¥â‚, ğ‘¥â‚‚), log(ğ‘¥â‚) ç­‰ä¹Ÿæ˜¯å¦‚æ­¤ã€‚æ‰€æœ‰è¿™äº›è¡¨è¾¾å¼éƒ½ä¸æ˜¯çº¿æ€§çš„ï¼Œå°½ç®¡å…¶ä¸­ä¸€äº›å¯ä»¥é€šè¿‡å„ç§æŠ€å·§
    *çº¿æ€§åŒ–*ï¼Œä½†æ›´å¤šå†…å®¹å°†åœ¨å¦ä¸€ç¯‡æ–‡ç« ä¸­è®¨è®ºã€‚
- en: ğ‘â‚ğ‘â‚‚ is a correct MILP expression as multiplying two fixed parameters together
    would result in a single fixed parameter in â€œcompileâ€ time, i.e., during building
    the matrix model but before starting the solver. Expressions where fixed parameters
    are transformed by a mathematical functions (such as logarithm) are also correct
    MILP expressions.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ğ‘â‚ğ‘â‚‚ æ˜¯ä¸€ä¸ªæ­£ç¡®çš„ MILP è¡¨è¾¾å¼ï¼Œå› ä¸ºå°†ä¸¤ä¸ªå›ºå®šå‚æ•°ç›¸ä¹˜ä¼šåœ¨â€œç¼–è¯‘â€æ—¶é—´ï¼Œå³åœ¨æ„å»ºçŸ©é˜µæ¨¡å‹ä½†åœ¨å¯åŠ¨æ±‚è§£å™¨ä¹‹å‰ï¼Œå¾—åˆ°ä¸€ä¸ªå•ä¸€çš„å›ºå®šå‚æ•°ã€‚ç»è¿‡æ•°å­¦å‡½æ•°ï¼ˆå¦‚å¯¹æ•°ï¼‰è½¬æ¢çš„å›ºå®šå‚æ•°ä¹Ÿéƒ½æ˜¯æ­£ç¡®çš„
    MILP è¡¨è¾¾å¼ã€‚
- en: ğ‘â‚“ is not a correct MILP expression. We cannot use a variable as an index.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ğ‘â‚“ ä¸æ˜¯ä¸€ä¸ªæ­£ç¡®çš„ MILP è¡¨è¾¾å¼ã€‚æˆ‘ä»¬ä¸èƒ½ä½¿ç”¨å˜é‡ä½œä¸ºç´¢å¼•ã€‚
- en: ğ‘â‚ğ‘¥â‚ < ğ‘â‚ is not a correct MILP constraint, it is not possible to force strict
    inequality.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ğ‘â‚ğ‘¥â‚ < ğ‘â‚ ä¸æ˜¯ä¸€ä¸ªæ­£ç¡®çš„ MILP çº¦æŸï¼Œå› ä¸ºä¸å¯èƒ½å¼ºåˆ¶ä¸¥æ ¼ä¸ç­‰å¼ã€‚
- en: We finish this section by showing a MILP formulation of the budget problem from
    the previous post in a matrix form.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬é€šè¿‡ä»¥çŸ©é˜µå½¢å¼å±•ç¤ºå‰ä¸€ç¯‡æ–‡ç« ä¸­çš„é¢„ç®—é—®é¢˜çš„ MILP å…¬å¼æ¥ç»“æŸè¿™ä¸€éƒ¨åˆ†ã€‚
- en: '![](../Images/938e6432d1271aa0fc74dd6e6d388dd2.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/938e6432d1271aa0fc74dd6e6d388dd2.png)'
- en: The objective uses the *multiplication by -1* trick to maximise the expected
    profit. The budget constraint is encoded in the first row of the constraint matrix
    and the remaining rows correspond to constraints 0 â‰¤ ğ‘¥áµ¢, ğ‘¥áµ¢ â‰¤ 1 on each variable
    ğ‘¥áµ¢ (i.e., ğ‘¥áµ¢ is required to be binary). Many solvers allow to specify the domain
    of the variables directly, so usually there is no need create such constraints
    by hand. Also, notice that our model includes only integer variables (there is
    no **y** variable), thus it is an *integer linear program*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®æ ‡ä½¿ç”¨äº† *ä¹˜ä»¥ -1* çš„æŠ€å·§æ¥æœ€å¤§åŒ–é¢„æœŸåˆ©æ¶¦ã€‚é¢„ç®—çº¦æŸç¼–ç åœ¨çº¦æŸçŸ©é˜µçš„ç¬¬ä¸€è¡Œï¼Œå‰©ä½™çš„è¡Œå¯¹åº”äºæ¯ä¸ªå˜é‡ ğ‘¥áµ¢ ä¸Šçš„çº¦æŸ 0 â‰¤ ğ‘¥áµ¢, ğ‘¥áµ¢ â‰¤ 1ï¼ˆå³
    ğ‘¥áµ¢ è¢«è¦æ±‚ä¸ºäºŒè¿›åˆ¶ï¼‰ã€‚è®¸å¤šæ±‚è§£å™¨å…è®¸ç›´æ¥æŒ‡å®šå˜é‡çš„åŸŸï¼Œå› æ­¤é€šå¸¸ä¸éœ€è¦æ‰‹åŠ¨åˆ›å»ºè¿™äº›çº¦æŸã€‚æ­¤å¤–ï¼Œè¯·æ³¨æ„æˆ‘ä»¬çš„æ¨¡å‹ä»…åŒ…æ‹¬æ•´æ•°å˜é‡ï¼ˆæ²¡æœ‰ **y** å˜é‡ï¼‰ï¼Œå› æ­¤å®ƒæ˜¯ä¸€ä¸ª
    *æ•´æ•°çº¿æ€§è§„åˆ’*ã€‚
- en: Solution space
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: è§£å†³æ–¹æ¡ˆç©ºé—´
- en: When we know how the space of feasible solutions of MILP models looks like,
    we may start to reason about the general algorithm for MILP, its theoretical properties
    and possibly how to make more performant models.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æˆ‘ä»¬çŸ¥é“ MILP æ¨¡å‹çš„å¯è¡Œè§£ç©ºé—´æ˜¯ä»€ä¹ˆæ ·å­æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥å¼€å§‹æ¨ç†å…³äº MILP çš„é€šç”¨ç®—æ³•ã€ç†è®ºå±æ€§ä»¥åŠå¦‚ä½•ä½¿æ¨¡å‹æ›´é«˜æ•ˆã€‚
- en: Lets start with the following MILP model. For simplicity, we will consider only
    two integer variables ğ‘¥â‚, ğ‘¥â‚‚.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ä»ä»¥ä¸‹ MILP æ¨¡å‹å¼€å§‹ã€‚ä¸ºäº†ç®€åŒ–ï¼Œæˆ‘ä»¬å°†åªè€ƒè™‘ä¸¤ä¸ªæ•´æ•°å˜é‡ ğ‘¥â‚ å’Œ ğ‘¥â‚‚ã€‚
- en: '![](../Images/9abbdb5b0074ad32c418ffa2df4fdddd.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9abbdb5b0074ad32c418ffa2df4fdddd.png)'
- en: How can we visualise this model graphically? We start by empty 2D graph representing
    a model with no constraint. Gradually, we add constraint by constraint until we
    have a full model. In the graph, the horizontal and vertical axes correspond to
    values of ğ‘¥â‚ and ğ‘¥â‚‚, respectively.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¦‚ä½•å°†è¿™ä¸ªæ¨¡å‹å›¾å½¢åŒ–ï¼Ÿæˆ‘ä»¬ä»ä¸€ä¸ªç©ºçš„ 2D å›¾å¼€å§‹ï¼Œè¡¨ç¤ºæ²¡æœ‰çº¦æŸçš„æ¨¡å‹ã€‚é€æ¸åœ°ï¼Œæˆ‘ä»¬ä¸€ä¸ªä¸ªåœ°æ·»åŠ çº¦æŸï¼Œç›´åˆ°æˆ‘ä»¬æ‹¥æœ‰ä¸€ä¸ªå®Œæ•´çš„æ¨¡å‹ã€‚åœ¨å›¾ä¸­ï¼Œæ°´å¹³å’Œå‚ç›´è½´åˆ†åˆ«å¯¹åº”äº
    ğ‘¥â‚ å’Œ ğ‘¥â‚‚ çš„å€¼ã€‚
- en: '![](../Images/1129d4960fa52909962d650079beba7e.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1129d4960fa52909962d650079beba7e.png)'
- en: As there is currently no constraint in the model, every combination of ğ‘¥â‚, ğ‘¥â‚‚
    is a feasible solution. Lets add a first constraint 4ğ‘¥â‚ â‰¥ 2ğ‘¥â‚‚ and see what happens.
    First, draw a line 4ğ‘¥â‚ = 2ğ‘¥â‚‚ in the solution space.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºæ¨¡å‹ä¸­å½“å‰æ²¡æœ‰çº¦æŸï¼Œğ‘¥â‚ å’Œ ğ‘¥â‚‚ çš„æ¯ä¸€ç§ç»„åˆéƒ½æ˜¯ä¸€ä¸ªå¯è¡Œè§£ã€‚è®©æˆ‘ä»¬æ·»åŠ ç¬¬ä¸€ä¸ªçº¦æŸ 4ğ‘¥â‚ â‰¥ 2ğ‘¥â‚‚ å¹¶æŸ¥çœ‹ä¼šå‘ç”Ÿä»€ä¹ˆã€‚é¦–å…ˆï¼Œåœ¨è§£å†³æ–¹æ¡ˆç©ºé—´ä¸­ç»˜åˆ¶ä¸€æ¡ç›´çº¿
    4ğ‘¥â‚ = 2ğ‘¥â‚‚ã€‚
- en: '![](../Images/acfe2679fc2c9774b422db5e43b02087.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/acfe2679fc2c9774b422db5e43b02087.png)'
- en: 'This line is a boundary between two *half-spaces* defined by the following
    inequalities: 4ğ‘¥â‚ > 2ğ‘¥â‚‚ and 4ğ‘¥â‚ < 2ğ‘¥â‚‚. All the points on one side of the line
    satisfy inequality 4ğ‘¥â‚ > 2ğ‘¥â‚‚ and all the points on the other side of line satisfy
    inequality 4ğ‘¥â‚ < 2ğ‘¥â‚‚. When I want to know which half-space represents a specific
    constraint, I will pick some random point ğ‘¥â‚, ğ‘¥â‚‚ that does not lie on the line,
    substitute it into the constraint, and check whether the constraint is satisfied.
    If yes, then the half-space containing this point is the one that corresponds
    to the constraint. If not, then the other half-space is the correct one.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ¡çº¿æ˜¯ç”±ä»¥ä¸‹ä¸ç­‰å¼å®šä¹‰çš„ä¸¤ä¸ª*åŠç©ºé—´*ä¹‹é—´çš„è¾¹ç•Œï¼š4ğ‘¥â‚ > 2ğ‘¥â‚‚ å’Œ 4ğ‘¥â‚ < 2ğ‘¥â‚‚ã€‚çº¿çš„ä¸€ä¾§çš„æ‰€æœ‰ç‚¹æ»¡è¶³ä¸ç­‰å¼ 4ğ‘¥â‚ > 2ğ‘¥â‚‚ï¼Œè€Œå¦ä¸€ä¾§çš„æ‰€æœ‰ç‚¹æ»¡è¶³ä¸ç­‰å¼
    4ğ‘¥â‚ < 2ğ‘¥â‚‚ã€‚å½“æˆ‘æƒ³çŸ¥é“å“ªä¸ªåŠç©ºé—´è¡¨ç¤ºç‰¹å®šçº¦æŸæ¡ä»¶æ—¶ï¼Œæˆ‘ä¼šé€‰æ‹©ä¸€äº›ä¸åœ¨è¯¥çº¿ä¸Šçš„éšæœºç‚¹ ğ‘¥â‚, ğ‘¥â‚‚ï¼Œå°†å…¶ä»£å…¥çº¦æŸæ¡ä»¶ï¼Œå¹¶æ£€æŸ¥çº¦æŸæ¡ä»¶æ˜¯å¦å¾—åˆ°æ»¡è¶³ã€‚å¦‚æœæ»¡è¶³ï¼Œé‚£ä¹ˆåŒ…å«æ­¤ç‚¹çš„åŠç©ºé—´å°±æ˜¯å¯¹åº”äºè¯¥çº¦æŸæ¡ä»¶çš„åŠç©ºé—´ã€‚å¦‚æœä¸æ»¡è¶³ï¼Œé‚£ä¹ˆå¦ä¸€ä¸ªåŠç©ºé—´å°±æ˜¯æ­£ç¡®çš„ã€‚
- en: So as an example, lets pick point ğ‘¥â‚ = 5, ğ‘¥â‚‚ = 3\. Substitute the values into
    constraint
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸¾ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬é€‰æ‹©ç‚¹ ğ‘¥â‚ = 5, ğ‘¥â‚‚ = 3ã€‚å°†è¿™äº›å€¼ä»£å…¥çº¦æŸæ¡ä»¶
- en: '![](../Images/0eb690e189fe00b1ffb98698ed39f0c7.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0eb690e189fe00b1ffb98698ed39f0c7.png)'
- en: and we see that the constraint is satisfied. Therefore, the half-space containing
    this point is the one where all the points satisfy this constraint. In the graphs
    I will denote the half-space satisfying a constraint by an arrow. Of course, the
    points on the line also satisfy the constraint so a constraint is represented
    by both a boundary line and a half-space.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥çœ‹åˆ°çº¦æŸæ¡ä»¶å¾—åˆ°äº†æ»¡è¶³ã€‚å› æ­¤ï¼ŒåŒ…å«æ­¤ç‚¹çš„åŠç©ºé—´æ˜¯æ‰€æœ‰ç‚¹éƒ½æ»¡è¶³è¯¥çº¦æŸæ¡ä»¶çš„åŠç©ºé—´ã€‚åœ¨å›¾ä¸­ï¼Œæˆ‘å°†ç”¨ç®­å¤´è¡¨ç¤ºæ»¡è¶³çº¦æŸæ¡ä»¶çš„åŠç©ºé—´ã€‚å½“ç„¶ï¼Œçº¿ä¸Šçš„ç‚¹ä¹Ÿæ»¡è¶³çº¦æŸæ¡ä»¶ï¼Œæ‰€ä»¥ä¸€ä¸ªçº¦æŸæ¡ä»¶ç”±è¾¹ç•Œçº¿å’ŒåŠç©ºé—´å…±åŒè¡¨ç¤ºã€‚
- en: '![](../Images/df7bf59eb14f3338298bcab39c566b1a.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/df7bf59eb14f3338298bcab39c566b1a.png)'
- en: Lets add another constraint âˆ’2ğ‘¥â‚ + 30 â‰¥ 2ğ‘¥â‚‚. Again, we start by drawing a boundary
    line âˆ’2ğ‘¥â‚ + 30 = 2ğ‘¥â‚‚.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æ·»åŠ å¦ä¸€ä¸ªçº¦æŸæ¡ä»¶ âˆ’2ğ‘¥â‚ + 30 â‰¥ 2ğ‘¥â‚‚ã€‚æˆ‘ä»¬ä»ç»˜åˆ¶è¾¹ç•Œçº¿ âˆ’2ğ‘¥â‚ + 30 = 2ğ‘¥â‚‚ å¼€å§‹ã€‚
- en: '![](../Images/296b7291a09da73d404d83e9bf81d263.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/296b7291a09da73d404d83e9bf81d263.png)'
- en: Which half-space satisfies this constraint? For this test, we pick a point ğ‘¥â‚
    = 14, ğ‘¥â‚‚= 6 and substitute it into the constraint
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: å“ªä¸ªåŠç©ºé—´æ»¡è¶³è¿™ä¸ªçº¦æŸæ¡ä»¶ï¼Ÿå¯¹äºè¿™ä¸ªæµ‹è¯•ï¼Œæˆ‘ä»¬é€‰æ‹©ç‚¹ ğ‘¥â‚ = 14, ğ‘¥â‚‚= 6ï¼Œå¹¶å°†å…¶ä»£å…¥çº¦æŸæ¡ä»¶
- en: '![](../Images/9533880bffa9546897e306a6308acab6.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9533880bffa9546897e306a6308acab6.png)'
- en: We see that the selected point does not satisfy the constraint âˆ’2ğ‘¥â‚ + 30 â‰¥ 2ğ‘¥â‚‚
    so the feasible half-space must be the other one then the one containing point
    ğ‘¥â‚ = 14, ğ‘¥â‚‚= 6 .
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å‘ç°é€‰å®šçš„ç‚¹ä¸æ»¡è¶³çº¦æŸæ¡ä»¶ âˆ’2ğ‘¥â‚ + 30 â‰¥ 2ğ‘¥â‚‚ï¼Œå› æ­¤å¯è¡Œçš„åŠç©ºé—´å¿…é¡»æ˜¯å¦ä¸€ä¸ªï¼Œè€Œä¸æ˜¯åŒ…å«ç‚¹ ğ‘¥â‚ = 14, ğ‘¥â‚‚= 6 çš„é‚£ä¸ªã€‚
- en: '![](../Images/462494ac571b28d1925fe680731d0b77.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/462494ac571b28d1925fe680731d0b77.png)'
- en: However, now as we have two constraints in the model, the feasible solution
    space is an *intersection* of the feasible half-spaces of each constraint. The
    reason is that we want all the constraints to be satisfied so only the solutions
    that lie in all feasible half-spaces are also feasible in the whole model.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œç°åœ¨æ¨¡å‹ä¸­æœ‰ä¸¤ä¸ªçº¦æŸæ¡ä»¶ï¼Œ feasible è§£å†³æ–¹æ¡ˆç©ºé—´æ˜¯æ¯ä¸ªçº¦æŸæ¡ä»¶çš„å¯è¡ŒåŠç©ºé—´çš„*äº¤é›†*ã€‚åŸå› åœ¨äºæˆ‘ä»¬å¸Œæœ›æ‰€æœ‰çš„çº¦æŸæ¡ä»¶éƒ½å¾—åˆ°æ»¡è¶³ï¼Œå› æ­¤åªæœ‰é‚£äº›ä½äºæ‰€æœ‰å¯è¡ŒåŠç©ºé—´ä¸­çš„è§£å†³æ–¹æ¡ˆæ‰åœ¨æ•´ä¸ªæ¨¡å‹ä¸­æ˜¯å¯è¡Œçš„ã€‚
- en: '![](../Images/9798bd7cbba683a5ca64c3be2862e8ff.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9798bd7cbba683a5ca64c3be2862e8ff.png)'
- en: Now it should be clear how to proceed with constraints ğ‘¥â‚‚ â‰¥ 0, 0.5ğ‘¥â‚ + 3.75
    â‰¥ ğ‘¥â‚‚, so I will just draw the new feasible solution space.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨åº”è¯¥æ¸…æ¥šå¦‚ä½•å¤„ç†çº¦æŸæ¡ä»¶ ğ‘¥â‚‚ â‰¥ 0, 0.5ğ‘¥â‚ + 3.75 â‰¥ ğ‘¥â‚‚ï¼Œæ‰€ä»¥æˆ‘å°†ç›´æ¥ç»˜åˆ¶æ–°çš„å¯è¡Œè§£ç©ºé—´ã€‚
- en: '![](../Images/a987bfb22e8837cd7ec76e4206d66db1.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a987bfb22e8837cd7ec76e4206d66db1.png)'
- en: There is one thing left and that is the integrality constraint ğ‘¥â‚, ğ‘¥â‚‚ âˆˆ â„¤ that
    we silently ignored at the beginning. What does this constraint mean? Simply,
    not all points from the coloured region are actually feasible, but only those
    where both ğ‘¥â‚, ğ‘¥â‚‚ are integers. We can visualise them by a grid, thus, the final
    feasible solution space of the example MILP model looks like this.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: è¿˜æœ‰ä¸€ä»¶äº‹å°±æ˜¯æˆ‘ä»¬æœ€åˆé»˜é»˜å¿½ç•¥çš„æ•´æ•°çº¦æŸ ğ‘¥â‚, ğ‘¥â‚‚ âˆˆ â„¤ã€‚è¿™æ¡çº¦æŸæ„å‘³ç€ä»€ä¹ˆï¼Ÿç®€å•æ¥è¯´ï¼Œå¹¶ä¸æ˜¯æ‰€æœ‰å½©è‰²åŒºåŸŸä¸­çš„ç‚¹éƒ½æ˜¯å®é™…å¯è¡Œçš„ï¼Œåªæœ‰é‚£äº› ğ‘¥â‚ å’Œ
    ğ‘¥â‚‚ éƒ½æ˜¯æ•´æ•°çš„ç‚¹æ‰æ˜¯å¯è¡Œçš„ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡ç½‘æ ¼å°†å®ƒä»¬å¯è§†åŒ–ï¼Œå› æ­¤ï¼Œç¤ºä¾‹ MILP æ¨¡å‹çš„æœ€ç»ˆå¯è¡Œè§£ç©ºé—´å¦‚ä¸‹ã€‚
- en: '![](../Images/b15777d54e00b520383e6d34027d8450.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b15777d54e00b520383e6d34027d8450.png)'
- en: Space of the feasible solutions for the example MILP model. The feasible solutions
    are denoted by red dots, black lines represent boundary of the constraints.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ç¤ºä¾‹ MILP æ¨¡å‹çš„å¯è¡Œè§£ç©ºé—´ã€‚å¯è¡Œè§£ç”¨çº¢ç‚¹è¡¨ç¤ºï¼Œé»‘çº¿è¡¨ç¤ºçº¦æŸæ¡ä»¶çš„è¾¹ç•Œã€‚
- en: 'Each of those red points correspond to one feasible integer solution which
    satisfy all the constraints. Now, the last question is: which of those points
    optimise our objective function, i.e., which point gives us the smallest value
    of âˆ’2ğ‘¥â‚ âˆ’ 3ğ‘¥â‚‚? This question is little bit more involved. We could extend our
    graph to a third dimension representing the values of the objective function,
    project the feasible solutions to a plane of our objective function and find the
    projected point that is the lowest. However, I think that it is a nice mental
    exercise to stay in 2D space and find the optimum there.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: æ¯ä¸€ä¸ªçº¢ç‚¹éƒ½å¯¹åº”ä¸€ä¸ªæ»¡è¶³æ‰€æœ‰çº¦æŸçš„å¯è¡Œæ•´æ•°è§£ã€‚ç°åœ¨ï¼Œæœ€åä¸€ä¸ªé—®é¢˜æ˜¯ï¼šè¿™äº›ç‚¹ä¸­å“ªä¸ªä¼˜åŒ–äº†æˆ‘ä»¬çš„ç›®æ ‡å‡½æ•°ï¼Œå³å“ªä¸ªç‚¹ç»™å‡ºäº†æœ€å°çš„ -2ğ‘¥â‚ âˆ’ 3ğ‘¥â‚‚ å€¼ï¼Ÿè¿™ä¸ªé—®é¢˜ç¨å¾®å¤æ‚ä¸€ç‚¹ã€‚æˆ‘ä»¬å¯ä»¥å°†å›¾æ‰©å±•åˆ°ç¬¬ä¸‰ç»´ï¼Œä»£è¡¨ç›®æ ‡å‡½æ•°çš„å€¼ï¼Œå°†å¯è¡Œè§£æŠ•å½±åˆ°ç›®æ ‡å‡½æ•°çš„å¹³é¢ä¸Šï¼Œç„¶åæ‰¾åˆ°æŠ•å½±ç‚¹ä¸­æœ€ä½çš„ç‚¹ã€‚ç„¶è€Œï¼Œæˆ‘è®¤ä¸ºåœ¨
    2D ç©ºé—´ä¸­æ‰¾åˆ°æœ€ä¼˜è§£æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„æ€ç»´ç»ƒä¹ ã€‚
- en: Many of you are probably familiar with the concept of a *gradient*, as it is
    a backbone of many ML training algorithms. In short, a gradient of a function
    represents a direction of the largest increase of that function at some point.
    That is, if we move along the gradient, we will increase the function. Knowing
    the gradient of the MILPâ€™s objective function tells us where to look for the optimal
    feasible solution. So, lets find the gradient of our objective function, which
    we obtain by taking the partial derivatives by each variable ğ‘¥â‚, ğ‘¥â‚‚
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ ä»¬ä¸­çš„è®¸å¤šäººå¯èƒ½å¯¹*æ¢¯åº¦*è¿™ä¸ªæ¦‚å¿µå¾ˆç†Ÿæ‚‰ï¼Œå› ä¸ºå®ƒæ˜¯è®¸å¤šæœºå™¨å­¦ä¹ è®­ç»ƒç®—æ³•çš„æ ¸å¿ƒã€‚ç®€è€Œè¨€ä¹‹ï¼Œå‡½æ•°çš„æ¢¯åº¦è¡¨ç¤ºåœ¨æŸä¸€ç‚¹å‡½æ•°æœ€å¤§å¢åŠ çš„æ–¹å‘ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœæˆ‘ä»¬æ²¿æ¢¯åº¦æ–¹å‘ç§»åŠ¨ï¼Œæˆ‘ä»¬å°†å¢åŠ å‡½æ•°å€¼ã€‚çŸ¥é“
    MILP ç›®æ ‡å‡½æ•°çš„æ¢¯åº¦å¯ä»¥å‘Šè¯‰æˆ‘ä»¬å»å“ªé‡Œå¯»æ‰¾æœ€ä¼˜å¯è¡Œè§£ã€‚æ‰€ä»¥ï¼Œè®©æˆ‘ä»¬æ‰¾åˆ°ç›®æ ‡å‡½æ•°çš„æ¢¯åº¦ï¼Œæˆ‘ä»¬é€šè¿‡å¯¹æ¯ä¸ªå˜é‡ ğ‘¥â‚, ğ‘¥â‚‚ è¿›è¡Œåå¯¼æ•°æ¥è·å¾—ã€‚
- en: '![](../Images/71c4de42e15397fbad2a7c85ba73050a.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/71c4de42e15397fbad2a7c85ba73050a.png)'
- en: Since our objective function is linear, its gradient is the same for every point
    in the solution space. And since gradient is a direction, we can draw a vector
    into our solution space to show the direction of the increase in the objective
    function.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºæˆ‘ä»¬çš„ç›®æ ‡å‡½æ•°æ˜¯çº¿æ€§çš„ï¼Œå®ƒåœ¨è§£ç©ºé—´ä¸­çš„æ¯ä¸€ç‚¹æ¢¯åº¦éƒ½æ˜¯ç›¸åŒçš„ã€‚ç”±äºæ¢¯åº¦æ˜¯ä¸€ä¸ªæ–¹å‘ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨è§£ç©ºé—´ä¸­ç»˜åˆ¶ä¸€ä¸ªå‘é‡ï¼Œä»¥æ˜¾ç¤ºç›®æ ‡å‡½æ•°å¢åŠ çš„æ–¹å‘ã€‚
- en: '![](../Images/4c8c8828827b42f866d88b2795ea82b9.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4c8c8828827b42f866d88b2795ea82b9.png)'
- en: Lets draw a contour lines of the objective (a contour line has the same objective
    value for every point on that line). It can be proven that contour lines are perpendicular
    to a gradient, so once we have the gradient, it is easy to draw the contours.
    As we move in the opposite direction of the gradient, the objective value on the
    contour lines decreases until we cannot move any further as we would be outside
    of the feasible space. You can imagine this process as moving a ruler, which is
    perpendicular to the gradient, along the direction opposite to the gradient until
    you touch the last feasible solution. In our example, the optimal solution is
    at ğ‘¥â‚ = 8, ğ‘¥â‚‚ = 7 with the objective value of âˆ’37\. Phew!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ç»˜åˆ¶ç›®æ ‡çš„ç­‰é«˜çº¿ï¼ˆç­‰é«˜çº¿ä¸Šçš„æ¯ä¸€ç‚¹ç›®æ ‡å€¼ç›¸åŒï¼‰ã€‚å¯ä»¥è¯æ˜ç­‰é«˜çº¿ä¸æ¢¯åº¦å‚ç›´ï¼Œå› æ­¤ä¸€æ—¦æˆ‘ä»¬æœ‰äº†æ¢¯åº¦ï¼Œå°±å¾ˆå®¹æ˜“ç»˜åˆ¶ç­‰é«˜çº¿ã€‚éšç€æˆ‘ä»¬æ²¿æ¢¯åº¦çš„ç›¸åæ–¹å‘ç§»åŠ¨ï¼Œç­‰é«˜çº¿ä¸Šçš„ç›®æ ‡å€¼ä¼šå‡å°‘ï¼Œç›´åˆ°æˆ‘ä»¬æ— æ³•å†ç§»åŠ¨ï¼Œå› ä¸ºæˆ‘ä»¬å°†è¶…å‡ºå¯è¡Œç©ºé—´ã€‚ä½ å¯ä»¥æŠŠè¿™ä¸ªè¿‡ç¨‹æƒ³è±¡æˆå°†ä¸€æŠŠä¸æ¢¯åº¦å‚ç›´çš„å°ºå­æ²¿æ¢¯åº¦çš„ç›¸åæ–¹å‘ç§»åŠ¨ï¼Œç›´åˆ°ä½ è§¦åŠæœ€åä¸€ä¸ªå¯è¡Œè§£ã€‚åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œæœ€ä¼˜è§£æ˜¯
    ğ‘¥â‚ = 8, ğ‘¥â‚‚ = 7ï¼Œç›®æ ‡å€¼ä¸º -37ã€‚å‘¼ï¼
- en: '![](../Images/02b09773755504b4829369004861b919.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/02b09773755504b4829369004861b919.png)'
- en: If you are intersted in how to write this MILP model in Python, here is the
    code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ å¯¹å¦‚ä½•åœ¨ Python ä¸­ç¼–å†™è¿™ä¸ª MILP æ¨¡å‹æ„Ÿå…´è¶£ï¼Œè¿™é‡Œæ˜¯ä»£ç ã€‚
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Optimisation outcomes
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ä¼˜åŒ–ç»“æœ
- en: 'In the example above, we found an optimal solution. However, this is not always
    guaranteed. In theory, the optimisation might end up with one of the following
    three outcomes: optimal solution found, infeasible model, or unbounded objective.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬æ‰¾åˆ°äº†ä¸€ä¸ªæœ€ä¼˜è§£ã€‚ç„¶è€Œï¼Œè¿™å¹¶ä¸æ€»æ˜¯æœ‰ä¿è¯çš„ã€‚ç†è®ºä¸Šï¼Œä¼˜åŒ–å¯èƒ½ä¼šå¾—å‡ºä»¥ä¸‹ä¸‰ç§ç»“æœä¹‹ä¸€ï¼šæ‰¾åˆ°æœ€ä¼˜è§£ã€æ¨¡å‹ä¸å¯è¡Œæˆ–ç›®æ ‡æ— ç•Œã€‚
- en: Other outcomes are also possible (e.g., time-limit reached, out-of-memory, etc.)
    but they are related to practise, not theory of integer programming so I will
    not discuss them in this post.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä»–ç»“æœä¹Ÿæ˜¯å¯èƒ½çš„ï¼ˆä¾‹å¦‚ï¼Œè¶…æ—¶ã€å†…å­˜ä¸è¶³ç­‰ï¼‰ï¼Œä½†è¿™äº›ä¸æ•´æ•°è§„åˆ’çš„å®è·µç›¸å…³ï¼Œè€Œä¸æ˜¯ç†è®ºï¼Œæ‰€ä»¥æˆ‘ä¸ä¼šåœ¨è¿™ç¯‡æ–‡ç« ä¸­è®¨è®ºå®ƒä»¬ã€‚
- en: 'Optimisation outcome: optimal solution found'
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ä¼˜åŒ–ç»“æœï¼šæ‰¾åˆ°æœ€ä¼˜è§£
- en: We already saw a couple of examples where we found an optimal solution (e.g.,
    budget problem). I would like to highlight that there might be multiple optimal
    solutions with the same objective value. For example, if we replace the objective
    in the above defined model by 10ğ‘¥â‚‚, then all the points lying on line xâ‚‚ = 0 in
    the feasible solution space are optimal with objective value of 0\. Multiple runs
    of the optimisation solver with various random seeds will probably give different
    optimal solutions, so do not expect an unique solution to be returned all the
    time.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»çœ‹åˆ°äº†ä¸€äº›æ‰¾åˆ°æœ€ä¼˜è§£çš„ä¾‹å­ï¼ˆä¾‹å¦‚ï¼Œé¢„ç®—é—®é¢˜ï¼‰ã€‚æˆ‘æƒ³å¼ºè°ƒçš„æ˜¯ï¼Œå¯èƒ½å­˜åœ¨å¤šä¸ªå…·æœ‰ç›¸åŒç›®æ ‡å€¼çš„æœ€ä¼˜è§£ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬å°†ä¸Šé¢å®šä¹‰çš„æ¨¡å‹ä¸­çš„ç›®æ ‡æ›¿æ¢ä¸º 10ğ‘¥â‚‚ï¼Œé‚£ä¹ˆåœ¨å¯è¡Œè§£ç©ºé—´ä¸­æ‰€æœ‰ä½äº
    xâ‚‚ = 0 çº¿ä¸Šçš„ç‚¹éƒ½æ˜¯æœ€ä¼˜è§£ï¼Œç›®æ ‡å€¼ä¸º 0ã€‚å¤šæ¬¡è¿è¡Œä¼˜åŒ–æ±‚è§£å™¨å¹¶ä½¿ç”¨ä¸åŒçš„éšæœºç§å­å¯èƒ½ä¼šç»™å‡ºä¸åŒçš„æœ€ä¼˜è§£ï¼Œå› æ­¤ä¸è¦æœŸæœ›æ¯æ¬¡éƒ½è¿”å›å”¯ä¸€è§£ã€‚
- en: 'Optimisation outcome: infeasible model'
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ä¼˜åŒ–ç»“æœï¼šä¸å¯è¡Œæ¨¡å‹
- en: Infeasible models are the ones for which there is no feasible solution that
    would satisfy all the constraints. An example of an infeasible model is the following.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å¯è¡Œçš„æ¨¡å‹æ˜¯æŒ‡æ²¡æœ‰æ»¡è¶³æ‰€æœ‰çº¦æŸæ¡ä»¶çš„å¯è¡Œè§£çš„æ¨¡å‹ã€‚ä¸€ä¸ªä¸å¯è¡Œæ¨¡å‹çš„ä¾‹å­å¦‚ä¸‹ã€‚
- en: '![](../Images/db1aa79553956020c3c06b9c7c22f5f9.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/db1aa79553956020c3c06b9c7c22f5f9.png)'
- en: There is no value of ğ‘¥â‚ which would satisfy both ğ‘¥â‚ â‰¥ 6 and ğ‘¥â‚ â‰¤ 2, so the intersection
    of the feasible half-spaces of these constraints is an empty set.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: æ²¡æœ‰ä»»ä½•ä¸€ä¸ª ğ‘¥â‚ çš„å€¼å¯ä»¥åŒæ—¶æ»¡è¶³ ğ‘¥â‚ â‰¥ 6 å’Œ ğ‘¥â‚ â‰¤ 2ï¼Œå› æ­¤è¿™äº›çº¦æŸçš„å¯è¡ŒåŠç©ºé—´çš„äº¤é›†æ˜¯ä¸€ä¸ªç©ºé›†ã€‚
- en: '![](../Images/b49a9ecbd2477c1ba54b3fc5d804dad8.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b49a9ecbd2477c1ba54b3fc5d804dad8.png)'
- en: 'Optimisation outcome: unbounded objective'
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ä¼˜åŒ–ç»“æœï¼šæ— ç•Œç›®æ ‡
- en: This one is a little bit weird, but unfortunately, it may occur. Usually in
    practise, it is a sign of an ill-defined model, e.g., when an essential constraint
    is not included in a model.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æœ‰ç‚¹å¥‡æ€ªï¼Œä½†ä¸å¹¸çš„æ˜¯ï¼Œè¿™ç§æƒ…å†µå¯èƒ½ä¼šå‘ç”Ÿã€‚é€šå¸¸åœ¨å®è·µä¸­ï¼Œè¿™è¡¨æ˜æ¨¡å‹å®šä¹‰ä¸æ˜ç¡®ï¼Œä¾‹å¦‚ï¼Œå½“ä¸€ä¸ªé‡è¦çš„çº¦æŸæ²¡æœ‰åŒ…å«åœ¨æ¨¡å‹ä¸­æ—¶ã€‚
- en: Unbounded objective means that for every feasible solution, we can find another
    feasible solution having a smaller objective value. In other words, the optimal
    objective value converges to negative infinity. Here is a model with an unbounded
    objective.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: æ— ç•Œç›®æ ‡æ„å‘³ç€å¯¹äºæ¯ä¸ªå¯è¡Œè§£ï¼Œæˆ‘ä»¬å¯ä»¥æ‰¾åˆ°å¦ä¸€ä¸ªå…·æœ‰æ›´å°ç›®æ ‡å€¼çš„å¯è¡Œè§£ã€‚æ¢å¥è¯è¯´ï¼Œæœ€ä¼˜ç›®æ ‡å€¼è¶‹å‘äºè´Ÿæ— ç©·ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªå…·æœ‰æ— ç•Œç›®æ ‡çš„æ¨¡å‹ã€‚
- en: '![](../Images/8313cb3c2128852fba51d71957be5b38.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8313cb3c2128852fba51d71957be5b38.png)'
- en: The feasible solution space is so unconstrained, that we increase ğ‘¥â‚‚ to any
    value we want and in turn the objective will decrease.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: å¯è¡Œè§£ç©ºé—´æ²¡æœ‰çº¦æŸï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å°† ğ‘¥â‚‚ å¢åŠ åˆ°æˆ‘ä»¬æƒ³è¦çš„ä»»ä½•å€¼ï¼Œä»è€Œç›®æ ‡å‡½æ•°å€¼å°†å‡å°ã€‚
- en: Wrap-up
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ€»ç»“
- en: Right now, you should be able to solve any MILP model with two integer variables
    using just pen, paper and a ruler! Of course, the actual computer algorithms for
    solving MILPs are more complicated, but the visual understanding of the solution
    space will come handy when we study the algorithms in some future post.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œä½ åº”è¯¥èƒ½å¤Ÿä»…ä½¿ç”¨ç¬”ã€çº¸å’Œç›´å°ºæ¥è§£å†³ä»»ä½•å…·æœ‰ä¸¤ä¸ªæ•´æ•°å˜é‡çš„ MILP æ¨¡å‹ï¼å½“ç„¶ï¼Œè§£å†³ MILP çš„å®é™…è®¡ç®—æœºç®—æ³•è¦å¤æ‚å¾—å¤šï¼Œä½†å¯¹è§£ç©ºé—´çš„ç›´è§‚ç†è§£å°†åœ¨æˆ‘ä»¬æœªæ¥çš„æ–‡ç« ä¸­å­¦ä¹ ç®—æ³•æ—¶æ´¾ä¸Šç”¨åœºã€‚
- en: '*All images unless otherwise noted are by the author.*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*é™¤éå¦æœ‰è¯´æ˜ï¼Œæ‰€æœ‰å›¾ç‰‡å‡ç”±ä½œè€…æä¾›ã€‚*'
