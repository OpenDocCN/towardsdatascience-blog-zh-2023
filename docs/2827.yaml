- en: Use Python to Download Multiple Files (or URLs) in Parallel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/use-python-to-download-multiple-files-or-urls-in-parallel-1759da9d6535?source=collection_archive---------1-----------------------#2023-09-08](https://towardsdatascience.com/use-python-to-download-multiple-files-or-urls-in-parallel-1759da9d6535?source=collection_archive---------1-----------------------#2023-09-08)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Get more data in less time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://khafen.medium.com/?source=post_page-----1759da9d6535--------------------------------)[![Konrad
    Hafen](../Images/146548d8de62ca1d5d15c3c7c3300940.png)](https://khafen.medium.com/?source=post_page-----1759da9d6535--------------------------------)[](https://towardsdatascience.com/?source=post_page-----1759da9d6535--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----1759da9d6535--------------------------------)
    [Konrad Hafen](https://khafen.medium.com/?source=post_page-----1759da9d6535--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F56d662f7324a&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fuse-python-to-download-multiple-files-or-urls-in-parallel-1759da9d6535&user=Konrad+Hafen&userId=56d662f7324a&source=post_page-56d662f7324a----1759da9d6535---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----1759da9d6535--------------------------------)
    ·5 min read·Sep 8, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F1759da9d6535&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fuse-python-to-download-multiple-files-or-urls-in-parallel-1759da9d6535&user=Konrad+Hafen&userId=56d662f7324a&source=-----1759da9d6535---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F1759da9d6535&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fuse-python-to-download-multiple-files-or-urls-in-parallel-1759da9d6535&source=-----1759da9d6535---------------------bookmark_footer-----------)![](../Images/0c55252812a33ed88ec684dce29b169d.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Photo by [Wesley Tingey](https://unsplash.com/@wesleyphotography?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: We live in a world of big data. Often, big data is organized as a large collection
    of small datasets (i.e., one large dataset comprised of multiple files). Obtaining
    these data is often frustrating because of the download (or acquisition burden).
    Fortunately, with a little code, there are ways to automate and speed-up file
    download and acquisition.
  prefs: []
  type: TYPE_NORMAL
- en: Automating file downloads can save a lot of time. There are several ways to
    automate file downloads with Python. The easiest way to download files is using
    a simple Python loop to iterate through a list of URLs to download. This serial
    approach can work well with a few small files, but if you are downloading many
    files or large files, you’ll want to use a parallel approach to maximize your
    computational resources.
  prefs: []
  type: TYPE_NORMAL
- en: With a parallel file download routine, you can better use your computer’s resources
    to download multiple files simultaneously, saving you time. This tutorial demonstrates
    how to develop a generic file download function in Python and apply it to download
    multiple files with serial and parallel approaches. The code in this tutorial
    uses only modules available from the Python standard library, so no installations
    are required.
  prefs: []
  type: TYPE_NORMAL
- en: Import modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this example, we only need the `requests` and `multiprocessing` Python modules
    to download files in parallel. The `requests` and `multiprocessing` modules are
    both available from the Python standard library, so you won't need to perform
    any installations.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also import the `time` module to keep track of how long it takes to download
    individual files and compare performance between the serial and parallel download
    routines. The `time` module is also part of the Python standard library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Define URLs and filenames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I’ll demonstrate parallel file downloads in Python using [gridMET](https://www.climatologylab.org/gridmet.html)
    NetCDF files that contain daily precipitation data for the United States.
  prefs: []
  type: TYPE_NORMAL
- en: Here, I specify the URLs to four files in a list. In other applications, you
    may programmatically generate a list of files to download.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Each URL must be associated with its download location. Here, I’m downloading
    the files to the Windows ‘Downloads’ directory. I’ve hardcoded the filenames in
    a list for simplicity and transparency. Given your application, you may want to
    write code that will parse the input URL and download it to a specific directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Multiprocessing requires parallel functions to have only one argument (there
    are some workarounds, but we won’t get into that here). To download a file we’ll
    need to pass two arguments, a URL and a filename. So we’ll zip the `urls` and
    `fns` lists together to get a list of tuples. Each tuple in the list will contain
    two elements; a URL and the download filename for the URL. This way we can pass
    a single argument (the tuple) that contains two pieces of information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Function to download a URL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have specified the URLs to download and their associated filenames,
    we need a function to download the URLs ( `download_url`).
  prefs: []
  type: TYPE_NORMAL
- en: We’ll pass one argument ( `arg`) to `download_url`. This argument will be an
    iterable (list or tuple) where the first element is the URL to download ( `url`)
    and the second element is the filename ( `fn`). The elements are assigned to variables
    ( `url` and `fn`) for readability.
  prefs: []
  type: TYPE_NORMAL
- en: Now create a try statement in which the URL is retrieved and written to the
    file after it is created. When the file is written the URL and download time are
    returned. If an exception occurs a message is printed.
  prefs: []
  type: TYPE_NORMAL
- en: The `download_url` function is the meat of our code. It does the actual work
    of downloading and file creation. We can now use this function to download files
    in serial (using a loop) and in parallel. Let's go through those examples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Download multiple files with a Python loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To download the list of URLs to the associated files, loop through the iterable
    ( `inputs`) that we created, passing each element to `download_url`. After each
    download is complete we will print the downloaded URL and the time it took to
    download.
  prefs: []
  type: TYPE_NORMAL
- en: The total time to download all URLs will print after all downloads have been
    completed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It took between 11 and 16 seconds to download the individual files. The total
    download time was a little less than one minute. Your download times will vary
    based on your specific network connection.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s compare this serial (loop) approach to the parallel approach below.
  prefs: []
  type: TYPE_NORMAL
- en: Download multiple files in parallel with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start, create a function ( `download_parallel`) to handle the parallel download.
    The function ( `download_parallel`) will take one argument, an iterable containing
    URLs and associated filenames (the `inputs` variable we created earlier).
  prefs: []
  type: TYPE_NORMAL
- en: Next, get the number of CPUs available for processing. This will determine the
    number of threads to run in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: Now use the `multiprocessing` `ThreadPool` to map the `inputs` to the `download_url`
    function. Here we use the `imap_unordered` method of `ThreadPool` and pass it
    the `download_url` function and input arguments to `download_url` (the `inputs`
    variable). The `imap_unordered` method will run `download_url` simultaneously
    for the number of specified threads (i.e. parallel download).
  prefs: []
  type: TYPE_NORMAL
- en: Thus, if we have four files and four threads all files can be downloaded at
    the same time instead of waiting for one download to finish before the next starts.
    This can save a considerable amount of processing time.
  prefs: []
  type: TYPE_NORMAL
- en: In the final part of the `download_parallel` function the downloaded URLs and
    the time required to download each URL are printed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Once the `inputs` and `download_parallel` are defined, the files can be downloaded
    in parallel with a single line of code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Notice that it took longer to download each individual file with the approach.
    This may be a result of changing network speed, or overhead required to map the
    downloads to their respective threads. Even though the individual files took longer
    to download, the parallel method resulted in a 50% decrease in total download
    time.
  prefs: []
  type: TYPE_NORMAL
- en: You can see how parallel processing can greatly reduce processing time for multiple
    files. As the number of files increases, you will save much more time by using
    a parallel download approach.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automating file downloads in your development and analysis routines can save
    you a lot of time. As demonstrated by this tutorial implementing a parallel download
    routine can greatly decrease file acquisition time if you require many files or
    large files.
  prefs: []
  type: TYPE_NORMAL
- en: '*Originally published at* [*https://opensourceoptions.com*](https://opensourceoptions.com/blog/use-python-to-download-multiple-files-or-urls-in-parallel/)*.*'
  prefs: []
  type: TYPE_NORMAL
