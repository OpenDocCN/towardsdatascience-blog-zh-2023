- en: Building an Exercise Rep Counter Using Ideas from Signal Processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: åŽŸæ–‡ï¼š[https://towardsdatascience.com/building-an-exercise-rep-counter-using-ideas-from-signal-processing-fcdf14e76f81?source=collection_archive---------16-----------------------#2023-01-17](https://towardsdatascience.com/building-an-exercise-rep-counter-using-ideas-from-signal-processing-fcdf14e76f81?source=collection_archive---------16-----------------------#2023-01-17)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Designing a class-specific rep counter using a zero-crossing approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@aakashagrawal?source=post_page-----fcdf14e76f81--------------------------------)[![Aakash
    Agrawal](../Images/29c88586046f4b51d40cc0336f696cef.png)](https://medium.com/@aakashagrawal?source=post_page-----fcdf14e76f81--------------------------------)[](https://towardsdatascience.com/?source=post_page-----fcdf14e76f81--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----fcdf14e76f81--------------------------------)
    [Aakash Agrawal](https://medium.com/@aakashagrawal?source=post_page-----fcdf14e76f81--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: Â·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F93ce827b6548&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-an-exercise-rep-counter-using-ideas-from-signal-processing-fcdf14e76f81&user=Aakash+Agrawal&userId=93ce827b6548&source=post_page-93ce827b6548----fcdf14e76f81---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----fcdf14e76f81--------------------------------)
    Â·7 min readÂ·Jan 17, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Ffcdf14e76f81&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-an-exercise-rep-counter-using-ideas-from-signal-processing-fcdf14e76f81&user=Aakash+Agrawal&userId=93ce827b6548&source=-----fcdf14e76f81---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Ffcdf14e76f81&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-an-exercise-rep-counter-using-ideas-from-signal-processing-fcdf14e76f81&source=-----fcdf14e76f81---------------------bookmark_footer-----------)![](../Images/17dff657731d9290868db138567c9e84.png)'
  prefs: []
  type: TYPE_NORMAL
- en: photo by [Karsten Winegeart](https://unsplash.com/@karsten116) on Unsplash.com
  prefs: []
  type: TYPE_NORMAL
- en: '*In this blog post, I discuss a very new and unique approach for building a
    real-time exercise rep counter, one that employs signal processing ideas on top
    of pose estimation. This approach can be easily adapted to build rep-counters
    for other classes.*'
  prefs: []
  type: TYPE_NORMAL
- en: From engaging fitness-related activities by counting the number of times a particular
    movement was done to measuring biological events (such as heartbeat and pulse
    count), Rep counting has countless applications, and research in this field has
    garnered a lot of traction in the last few years. In this blog, I discuss one
    of the approaches to building a fast and accurate rep counter using some trivial
    concepts in the Signal Processing domain.
  prefs: []
  type: TYPE_NORMAL
- en: I will swiftly cover the basics first and then walk through the signal-based
    formula for rep-counting. Implementation of the approach can be found [here](https://github.com/aakash2016/blog-codes/tree/master/signal-rep-count).
    Letâ€™s start by discussing a few concepts from the world of signal processing which
    we could potentially leverage to build a rep-counter.
  prefs: []
  type: TYPE_NORMAL
- en: '**Zero-Crossing**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A reference point where the mathematical function or a waveform crosses an intercept
    of the axis (intercept need not be 0). The term is usually used in electronics
    when referring to points in periodic voltages and currents where there is no signal.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e4eebb9f7966da4e789da9c2b167e090.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig: Zero Crossing. Image by Author.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Peak Detection**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Detecting peaks (or positions) in a signal or a waveform where there is a sudden
    deviation (you observe spikes) from normal behavior. A technique to detect such
    deviation is by computing the **z-score**, which captures the mean and standard
    deviation of the signal to compute deviation.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8cf1a829ccb41956cd8ce4673b3ebbb1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig: z-score formula. Image by Author.'
  prefs: []
  type: TYPE_NORMAL
- en: At any position in the signal, the z-score algorithm essentially computes a
    trailing average and a trailing standard deviation of the preceding window of
    data points.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A peak in the signal can be identified by computing the range ***trailing average
    +/- (threshold * trailing standard deviation);*** if the current point has a value
    outside the range, then it's considered part of an anomaly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: More details and mathematics of the algo can be found [here](https://stackoverflow.com/a/22640362/18635156).
  prefs: []
  type: TYPE_NORMAL
- en: Rep Counting <> Signal Processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A natural question that might come to a reader''s mind is how zero-crossing
    and peak detection algorithms can be used for rep-counting. Letâ€™s see:'
  prefs: []
  type: TYPE_NORMAL
- en: Assumptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consider a human/object to be composed of some set of keypoints (points of interest).
    For example, these keypoints can be human body joints like shoulders, hips, etc.
  prefs: []
  type: TYPE_NORMAL
- en: To simplify, I limit the problem to exercise rep-counting because of the ease
    of availability of keypoints in the human body (the idea can easily be extended
    to other objects where keypoints are readily available). We can use open-source
    pose-estimation models to compute the spatial location of body keypoints. I use
    Tensorflowâ€™s [**Movenet**](https://www.tensorflow.org/hub/tutorials/movenet) pose
    estimation model for the purpose of illustration in this blog. This model is quite
    fast and accurate.
  prefs: []
  type: TYPE_NORMAL
- en: We **assume** any repetitive movement, for example, an exercise, as a set of
    sinusoidal waveforms of keypoints or functions (metrics) over keypoints. These
    Metrics include angles and distances between a combination of different body keypoints.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The underlying idea is to detect the Zero-Crossing points of these signal metrics
    in a moving temporal window in real-time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rep Counting using zero-crossing is a two-phase process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Phase 1: Reference Computation'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This phase is a **one-time** activity for a given exercise. We first find a
    zero-crossing line, aka reference line using a reference video (for exercise rep-counter,
    it can be a trainer's video). Most of the steps will be common in the rep-counting
    phase.
  prefs: []
  type: TYPE_NORMAL
- en: '**a)** We use the Movenet pose estimation model to observe human body keypoints
    in real-time. Consider the following reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/328b71d9a2c121d1e94f0ff32d5a3bd9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig: Body keypoint estimation using the Movenet model. Trainer performing Jumping
    Jacks. GIF by Author.'
  prefs: []
  type: TYPE_NORMAL
- en: '**b)** We then compute the **Metrics** using a combination of different body
    keypoints. Metric can be distances or angles between keypoints. Some metric examples:
    left shoulder to left palm distance (euclidean/y-axis), the angle subtended at
    the left shoulder, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: The idea would be to use metrics that would cover a wide range of movements.
    I usually prefer doing exercises facing the front camera; hence, choosing euclidean
    and y-axis distance metrics suffices. If you wish to build the rep counter for
    side-facing exercises as well, you might need to consider x-axis distances as
    well. I also normalize the metrics by shoulder-to-shoulder distance so that the
    rep-counting doesn't get affected by the distance from the camera.
  prefs: []
  type: TYPE_NORMAL
- en: '**c)** Frame-level pose estimation results in a jitter in body keypoints which
    results in a jitter in the computed metrics. We use a low-pass filter to make
    metrics smooth and remove the jitter in the metric distances and angles, which
    makes the reference calculation and rep counting more accurate. More details on
    the technique can be found [here](https://medium.com/towards-data-science/towards-a-more-applicative-pose-estimation-bf18bc311228).
    Ensure that the body keypoints are well within the frame before metrics computation.'
  prefs: []
  type: TYPE_NORMAL
- en: '**d)** Next, we filter out stationary metric signals. We compute the standard
    deviation of these signals and remove signals below a fixed threshold. If none
    of the metrics get filtered out, we use the top 3 metrics with the highest deviation.
    For the exercise rep counter, we consider a total of **18** metrics. For the above
    reference and a threshold standard deviation of **0.4**, we end up with **8**
    metrics that contribute most to the repetitiveness.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ed602d66069f7def06cee821799ca88d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig: Metric waveforms. Image by Author.'
  prefs: []
  type: TYPE_NORMAL
- en: '**e)** Finally, we sum all remaining non-stationary metrics temporally and
    compute the reference line using the mean of the summed-up signal. We save idâ€™s
    of these metrics and the reference line (the mean) in a ***config dictionary***
    to be later used during rep-counting. The reference line for the trainer video:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/39587bc9fa645345b11ec6fdf9c2e55e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig: Overall signal waveform for the reference video. Image by Author.'
  prefs: []
  type: TYPE_NORMAL
- en: A careful look at the reference video illustrates that there are 6 reps in total.
    These reps actually correspond to the peaks observed in the overall signal above.
  prefs: []
  type: TYPE_NORMAL
- en: 'Phase 2: Rep Counting'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the steps in this phase are common to the reference computation phase.
  prefs: []
  type: TYPE_NORMAL
- en: '**a)** Given a test video, we start by computing the keypoints and normalized
    metrics in real-time (same as the previous step).'
  prefs: []
  type: TYPE_NORMAL
- en: '**b)** We use the config dict from the reference computation phase to figure
    out the desired non-stationary metrics for this exercise and then sum up these
    metrics temporally to create a combined overall signal.'
  prefs: []
  type: TYPE_NORMAL
- en: '**c)** We create a fixed-size **moving window** in real-time and check for
    its **intersection with the reference line, aka the zero-crossing line**. For
    any repetitive movement, there are usually two states, one when going to the upstate
    of the exercise and the other when coming to the downstate, and either one of
    them is a normal state.'
  prefs: []
  type: TYPE_NORMAL
- en: Hence, for a single rep, there are two intersections of the overall signal waveform
    with the reference line. The first intersection gives the idea that the person
    has reached upstate of the exercise, and the second intersection gives us the
    idea that the person is back to the normal state and the rep is complete.
  prefs: []
  type: TYPE_NORMAL
- en: That's it!
  prefs: []
  type: TYPE_NORMAL
- en: Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Letâ€™s see the performance of the approach on a test video.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/17e5df810fad9cba9f5a07e5f88a4e01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig: Rep Counting using the zero-crossing technique. GIF by Author.'
  prefs: []
  type: TYPE_NORMAL
- en: The results look decent, right? ðŸ˜Ž. Here is the overall signal waveform for the
    above test video. Intuitively, the four peaks correspond to the four reps.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b70dc4a2e04752d4a19fba1e06bbeb70.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig: Overall signal waveform for the test video. Image by Author.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pros of the approach**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The algorithm is quite **fast** and **accurate.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The idea is **instinctive**, and the implementation is simple.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The approach is easily integrable in a production setting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Cons of the approach**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not a **generic** rep-counter (however, the idea can be adapted for other classes).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Need to calculate the zero-crossing line using a reference video for each exercise/class;
    hence, difficult to **scale** to a big corpus of exercises.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In places the background is noisy, pose estimation might work poorly and hence
    result in poor rep-count results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It might not work for exercises wherein the overall signal becomes flat due
    to different metrics eventually averaging out each other.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this blog, I highlighted the zero-crossing idea to count the reps; however,
    another technique known as **peak detection**, which we briefly discussed at the
    start, can also be employed to detect reps in real time.
  prefs: []
  type: TYPE_NORMAL
- en: Useful References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[1]. [Usage of Low pass filters to make pose estimation more effective](https://medium.com/towards-data-science/towards-a-more-applicative-pose-estimation-bf18bc311228)'
  prefs: []
  type: TYPE_NORMAL
- en: '[2]. [Robust peak detection algorithm (using z-scores)](https://stackoverflow.com/questions/22583391/peak-signal-detection-in-realtime-timeseries-data/22640362#22640362)'
  prefs: []
  type: TYPE_NORMAL
- en: '[3]. [MoveNet: Ultrafast and accurate pose detection model](https://www.tensorflow.org/hub/tutorials/movenet)'
  prefs: []
  type: TYPE_NORMAL
- en: '[4]. The implementation of the approach can be found [here](https://github.com/aakash2016/blog-codes);
    please read the instructions in the repository for usage.'
  prefs: []
  type: TYPE_NORMAL
- en: I hope you got the gist of how we can use signal-processing techniques for building
    a class-specific rep-counter. I would like to know the feedback of anyone reading
    this blog. I would be happy to answer any doubts/questions on any of the concepts
    mentioned above. Feedback is greatly welcomed. You can reach me via [Linkedin](https://www.linkedin.com/in/akash2016123/).
  prefs: []
  type: TYPE_NORMAL
- en: Thank You!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
