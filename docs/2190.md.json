["```py\ndef main(event: func.EventHubEvent, evh: func.Out[bytes]) -> None:\n  \"\"\"\n  Filter messages to only send relevant messages for our streaming flow.\n  \"\"\"\n  message = json.loads(event.get_body().decode(\"utf-8\"))\n\n  if _is_ns_operator(message):\n    message = _remove_keys(message)\n    message = _add_build_id(message)\n\n    evh.set(str.encode(json.dumps(message)))\n```", "```py\nSELECT\n batchid.batch_id,\n batchid.batch_start_time,\n event.message,\n event.message_timestamp INTO [Target]\nFROM\n [SourceData] event TIMESTAMP BY event.message_timestamp PARTITION BY PartitionId\n JOIN [BatchId] batchid TIMESTAMP BY batchid.EventEnqueuedUtcTime PARTITION BY PartitionId\n ON\n -- Join if the batch id message was received before the message (positive DATEDIFF) and\n -- when replay when a batch id message was received after the message (negative DATEDIFF),\n -- but only if the message was enqueued after the batch start time.\n -- To allow fast re-ingesting data we discard messages which are no longer valid for the batch\n  DATEDIFF(HOUR, batchid, event) BETWEEN - 24 AND 24\n  AND CAST(batchid.batch_start_time AS datetime) <= CAST(event.message_timestamp AS datetime)\n  AND CAST(event.message.valid_until AS datetime) >= CAST(batchid.batch_start_time AS datetime)\n  AND event.PartitionId = batchid.PartitionId\n```"]