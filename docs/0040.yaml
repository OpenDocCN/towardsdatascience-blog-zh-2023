- en: 'Sorting Algorithms: Heap Sort'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/heapify-with-heap-sort-5df23b5764c1?source=collection_archive---------19-----------------------#2023-01-03](https://towardsdatascience.com/heapify-with-heap-sort-5df23b5764c1?source=collection_archive---------19-----------------------#2023-01-03)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Learn about heap data structure and how it is used for sorting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@slavahead?source=post_page-----5df23b5764c1--------------------------------)[![Vyacheslav
    Efimov](../Images/db4b02e75d257063e8e9d3f1f75d9d6d.png)](https://medium.com/@slavahead?source=post_page-----5df23b5764c1--------------------------------)[](https://towardsdatascience.com/?source=post_page-----5df23b5764c1--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----5df23b5764c1--------------------------------)
    [Vyacheslav Efimov](https://medium.com/@slavahead?source=post_page-----5df23b5764c1--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fc8a0ca9d85d8&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fheapify-with-heap-sort-5df23b5764c1&user=Vyacheslav+Efimov&userId=c8a0ca9d85d8&source=post_page-c8a0ca9d85d8----5df23b5764c1---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----5df23b5764c1--------------------------------)
    ·7 min read·Jan 3, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F5df23b5764c1&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fheapify-with-heap-sort-5df23b5764c1&user=Vyacheslav+Efimov&userId=c8a0ca9d85d8&source=-----5df23b5764c1---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F5df23b5764c1&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fheapify-with-heap-sort-5df23b5764c1&source=-----5df23b5764c1---------------------bookmark_footer-----------)![](../Images/99d9ca3f43899b65860f0083b86d38d2.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Heap is a data structure that represents an array in a binary tree-based format.
    Heap imposes the following rules for its structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Completeness**. Every level of the heap is completely filled with elements.
    However, the last level may be partially filled with elements starting from the
    left.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Heap rule**. The value of any parent’s node must be less or equal to the
    values of its children. If this property is satisfied, the heap is called min-heap.
    There also exists a max-heap variation for which parents’ values must be greater
    than children’s values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples and code in this article will be provided for min heaps. The algorithm
    workflow for max heaps looks very similar. An example of a min-heap is shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5e5906b224656fbe591da0a80e519b87.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Heap is usually stored in the form of an array. *If a parent has an index i,
    then the positions of its left and right children are 2 * i + 1 and 2 * i + 2
    respectively. Inversely, if a non-root node has an index* i*, then its parent’s
    node has an index* (i - 1) // 2\. Following this principle, we get the array representation
    of the heap above:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4d80164a8184defd378f330f1263d4d6.png)'
  prefs: []
  type: TYPE_IMG
- en: Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Heap supports several operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Inserting a node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a heap from an array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting a node with the minimum value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the heap data structure has several operations, it is more practical to
    implement it as a class. For now, we are going to implement its basis. After each
    operation, a corresponding code snippet will be provided.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*heap* field stores an input array in the form of a heap (will be implemented
    later)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The _*swap()* method takes two indices of the array and swaps their values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *_number_of_children()* method returns the number of children a node has
    (0, 1 or 2)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting a node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The new element of the heap is inserted at the last position. Such insertion
    can break the heap rule if the new element is lower than the parent’s value. To
    avoid this problem, the new node is recursively propagated up until the moment
    when it does not violate the heap rule. The described procedure is called heapify(up).
  prefs: []
  type: TYPE_NORMAL
- en: From the figure above we insert a node with the value 3.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/dd988bcb480281d6a9d100c9a769c2cc.png)'
  prefs: []
  type: TYPE_IMG
- en: After the insertion, the heap rule is broken, since 3 < 15 (parent). We swap
    elements 3 and 15.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now node 3 has a new parent which has value 7\. Again, the heap rule is not
    satisfied, since 3 < 7\. As a result, we swap 3 and 7.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node 3 stands at index 2 and has a parent with the value 1\. Since 3 ≥ 1, the
    heap rule is correct. At this stage, the insertion procedure ends.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/7b9eb6f655a7ee2691ab78145f5e1947.png)'
  prefs: []
  type: TYPE_IMG
- en: Let us find out the time complexity for insertion. The worst case is possible
    when it is necessary to propagate the new node from the bottom to the top level
    of a tree. Since the height of any tree is logarithmic in relation to the total
    number of its elements *N* and each comparison takes *O(1)* time, the final estimation
    results in *O(logN)* time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The *insert()* method appends the value to the heap and then calls the method
    to heapify it up.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The _*heapify_up()* method recursively invokes itself on a parent node until
    the heap rule is correct.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a heap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For each element of an input array, an insert procedure is called. This is the
    way a heap is built.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of complexity, it might seem that building a heap requires *O(N * logN)*
    *of time because for each of N elements, we call a function that works by O(logN)
    time. However, it is possible to improve that estimation and prove mathematically
    that the total time is O(N)*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: For the passed array in the *build()* method, the heap is built through insertion
    calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting a node with the minimum value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The minimum node is located at the top of the heap. We extract the minimum
    and replace the top node with the last node of the heap. The heap rule is violated,
    so we propagate this element down. The algorithm is very similar to the previous
    one we used above (during insertion elements were propagated up): at each step,
    we swap the current element with a child who has the minimum value. This procedure
    lasts until the heap rule is no longer broken or the current element does have
    a child.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/30b0db0e5c933bb54dfcb43c7ec78b41.png)'
  prefs: []
  type: TYPE_IMG
- en: In the figure above, the node with value 1 was extracted and the last node with
    value 15 took its place.
  prefs: []
  type: TYPE_NORMAL
- en: Since node 15 violates the heap rule, we swap it with its smallest child which
    is 3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then node 15 has children 7 and 8 which are inferior. Again, we swap 15 with
    the smallest child which is 7.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After that, 15 stands at index 5 and has an only child which is 20\. Since 15
    ≤ 20, we stop the heapify procedure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/2aafb5bf033bbf6242d98e50d2c511df.png)'
  prefs: []
  type: TYPE_IMG
- en: Similar to the heapify algorithm in the insertion section, this one has the
    same asymptotics and proceeds for *O(logN)* time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Sorting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sorting is implemented via minimum node extraction. While the heap is not empty,
    we call the *extract_min()* function and append every minimum element to a new
    array. This way the array will consist of sorted elements.
  prefs: []
  type: TYPE_NORMAL
- en: Since the heap contains *N* nodes and *extract_min()* works for *O(logN)*, the
    total sorting time sorting takes *O(N ** logN).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered all four main operations for heaps. To sort an array using a
    heap data structure, it is necessary to first build a heap and then call the sort
    method on it. Building a heap requires *O(N)* time and sorting takes *O(N * logN)*
    *time which finally results in O(N * logN)* asymptotics for heap sort.
  prefs: []
  type: TYPE_NORMAL
- en: The full implementation of the Heap class is shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Execution example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*All images unless otherwise noted are by the author*'
  prefs: []
  type: TYPE_NORMAL
