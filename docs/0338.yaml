- en: 'API 101: Backdoor to Backend'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/api-101-backdoor-to-backend-8da989e1551c?source=collection_archive---------10-----------------------#2023-01-23](https://towardsdatascience.com/api-101-backdoor-to-backend-8da989e1551c?source=collection_archive---------10-----------------------#2023-01-23)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/40b9a5b9f2c72bd1a2b7365a09ef5842.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Lala Azizli](https://unsplash.com/@lazizli?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: A Quick Dive Into The World of APIs, And How APIs Drive Applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://amansharma2910.medium.com/?source=post_page-----8da989e1551c--------------------------------)[![Aman
    Sharma](../Images/337a857ff5e919b61237ce2aeeaded63.png)](https://amansharma2910.medium.com/?source=post_page-----8da989e1551c--------------------------------)[](https://towardsdatascience.com/?source=post_page-----8da989e1551c--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----8da989e1551c--------------------------------)
    [Aman Sharma](https://amansharma2910.medium.com/?source=post_page-----8da989e1551c--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F84e03a4d7261&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fapi-101-backdoor-to-backend-8da989e1551c&user=Aman+Sharma&userId=84e03a4d7261&source=post_page-84e03a4d7261----8da989e1551c---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----8da989e1551c--------------------------------)
    ·11 min read·Jan 23, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F8da989e1551c&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fapi-101-backdoor-to-backend-8da989e1551c&user=Aman+Sharma&userId=84e03a4d7261&source=-----8da989e1551c---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F8da989e1551c&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fapi-101-backdoor-to-backend-8da989e1551c&source=-----8da989e1551c---------------------bookmark_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: tl;dr — This is a very detailed introduction to APIs, application development,
    and a theoretical starter for backend development. This can be used as educational
    material on these topics.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this digital age, we are surrounded by applications that we pretty much rely
    on to facilitate almost all our day-to-day needs.
  prefs: []
  type: TYPE_NORMAL
- en: Is reading the news, and getting yourself updated with the happenings around
    the world the first thing you like to do when you wake up? Well, there are news
    applications like *Google News* and *Inshorts* for that. Running late and wanna
    grab a cab to work? You can quickly get one right at your doorstep with the *Uber*
    app! Hungry but don’t wanna cook? Just grab your phone and order your grocery
    right from the comfort of your home without having to carry those heavy grocery
    bags and roam around stores.
  prefs: []
  type: TYPE_NORMAL
- en: But why are we discussing this? The point is that today we have these very convenient
    apps that can do almost everything for us. *But that’s from the user's perspective.*
    To a software developer, there’s more to that.
  prefs: []
  type: TYPE_NORMAL
- en: While overly simplified for the user, an application like this can be pretty
    complex for the developer to make. So the first question that arises is — **How
    are these applications made?**
  prefs: []
  type: TYPE_NORMAL
- en: To answer this, we can take a look at the **3-Layer Application Architecture**.
  prefs: []
  type: TYPE_NORMAL
- en: The 3 Layer Application Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The 3-layer application architecture is a well-established software development
    architecture, that breaks down software into 3 logical and physical computation
    layers, viz.
  prefs: []
  type: TYPE_NORMAL
- en: '**Presentation Layer-***R*efers to the client-side application, i.e., the app
    that the users actually see and interact with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application layer-** Refers to the application component that handles all
    the business logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data layer-**Refers to the component that stores and handles all the data
    within the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, these three individual components work together to make a usable application.
  prefs: []
  type: TYPE_NORMAL
- en: The user interacts with the client-side (also known as the frontend) application,
    *making some sort of request.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application layer *processes this request.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If any data is *generated or altered while processing this request*, that is
    maintained on the data layer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the request is processed by the backend, a response is sent to the frontend
    application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***NOTE:*** *Often, the application and data layer combined together are referred
    to as the server-side (or backend) application.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: But now, another question arises. The one that we’re going to specifically answer
    in this guide is— **How do the different application layers (frontend and backend,
    to be more specific) communicate back and forth with each other?**
  prefs: []
  type: TYPE_NORMAL
- en: Well, here comes into play the concept of **API**s.
  prefs: []
  type: TYPE_NORMAL
- en: What is an API?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: API is an acronym for ***Application Programming Interface***. As the name suggests,
    it is an interface of some sorts.
  prefs: []
  type: TYPE_NORMAL
- en: To be more precise, APIs allow cross-platform and inter-device communications.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/275bc843831971af80adda518226813f.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: '**Software-to-software communication:** Earlier, we discussed how an application
    can be broken down into client-side and server-side components. These components
    exchange back and forth a set of requests and data responses. This communication
    interfacing is facilitated behind the scenes by APIs. The client sends an API
    request to the server, the server processes the request, and then returns an API
    response to the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Platform-independent communication:** Since APIs act as an effective communication
    mechanism between the client and the server, this means that both the client and
    the server can be based on entirely different tech stacks and yet manage to work
    together. For example, your frontend application can be written in JavaScript,
    and your backend can be written in Python. APIs generally have a standardized
    request and response structure that almost all programming languages support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reusability of code:** APIs promote code reusability. Let us understand it
    like this. Instagram has both a mobile application, as well as a website. Now,
    we have two types of clients in the case of Instagram, but only one backend that
    handles requests from both the web client as well as the mobile client. Both these
    clients make requests to the same backend server using APIs. Thus, there is no
    need to implement a separate backend for both mobile and web.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So now that we have a brief understanding of what APIs are, let us dive deeper
    and take a look at the different kinds of APIs available.
  prefs: []
  type: TYPE_NORMAL
- en: Types of APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are primarily three kinds of APIs, based on the services they provide.
    These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Local API:** These are Operating System (OS) APIs that provide services to
    the application programs, such as microphone access, camera access, or requesting
    data from DB service, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Program API:** It is based on Remote Procedure Call (RPC) technology that
    allows remote program execution from another server. In simple words, these APIs
    simply allow the execution of scripts or programs on a remote server or device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Web API:** Web APIs, also known as web services, allow applications or devices
    to communicate with each other via the World Wide Web, using HTTP architecture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When it comes to building applications that involve a client-server architecture,
    we primarily use web APIs.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now, since the focus of this article is to familiarize ourselves with how applications
    are built, we are going to focus specifically on web APIs.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE:** Web APIs can further be broken down into several classifications
    like SOAP (Simple Object Access Protocol), REST (REpresentational State Transfer)
    APIs etc. As of today, a majority of applications around the world predominantly
    use the REST API architecture for client-server interactions, due to the ease
    of implementation. Since REST has become the industry standard, in this article,
    we are going to discuss REST APIs.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are REST APIs?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST stands for REpresentational State Transfer; also known as RESTful web services.
    It is a standardized API architecture that allows cross-platform and inter-device
    communications over the HTTP network protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Again, in simple words, it allows two application components to interact with
    each other.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'A typical client-server interaction involves primarily four kinds of operations,
    namely:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create: The create operation via an API request pertains to the creation of
    a resource on the data layer of the backend. *Eg.- In a TODO list app, a create
    API request can be used to create a TODO item in the database.*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Read: The read operation can be used to fetch data from the database. This
    data can be a single resource of a type, a batch of resources of a single type,
    or a collection of resources of different types based on the client’s request
    and implementation of resource access on the backend. *Taking the example of the
    same TODO application, a read request can be used to fetch all the TODOs created
    by a user.*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update: An update operation can be performed to update the data associated
    with a particular resource in the data layer. *In our TODO application, the update
    request can be used to update the TODO task.*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Delete: As the name suggests, the delete operation can be used for the deletion
    of resources. *For our TODO app, delete requests can be used to delete a TODO
    object from the TODO list.*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These operations are collectively referred to as **CRUD** (**C**reate, **R**ead,
    **U**pdate, **D**elete) **operations**. For any application, these are some of
    the most basic operations a user can perform.
  prefs: []
  type: TYPE_NORMAL
- en: To put it in layman’s terms, when a user is interacting with an application,
    they are either accessing some data, or some data is being created or manipulated.
    REST APIs act as the intermediary step between the frontend and backend, allowing
    CRUD operations to be performed within an application.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now, we read earlier that because of how APIs are implemented as a communication
    channel between the client and the server, both the client and the server can
    be written using entirely different programming tech stacks. However, there has
    to be a standardized, *language agnostic* mechanism so that the client and the
    server can interact via the API. For this, REST APIs use **JSON**-based messaging
    protocol.
  prefs: []
  type: TYPE_NORMAL
- en: JSON stands for ***JavaScript Object Notation***. It is an open-standard file
    format and data interchange format which is human-readable in nature. Data is
    transmitted using JSON in a key-value pair and array format.
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram demonstrates a typical client-server interaction.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/63b393a0897290d8365bcd00f1bade3b.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: The client sends an API request to the server over the HTTP protocol. *This
    request is in the JSON format.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server parses this API request, processes the request, and then sends an
    API response back to the client, *which is again in the JSON format.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client can parse the JSON response object to render it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can observe, since the intermediary communication channel is standardized,
    hence the client and server can operate independently of each other in terms of
    platform and implementation. *As in, the backend can be written in one programming
    language (say, Python) and the frontend can be written in another (say, JavaScript),
    and the application will still work fine.*
  prefs: []
  type: TYPE_NORMAL
- en: Another important characteristic of REST APIs is that they are ***stateless***.
    This means that each request from the client to the server must contain all of
    the information necessary to understand and complete the request. *The subsequent
    requests aren’t dependent on the previous requests.*
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have completed some of the theoretical concepts regarding APIs
    and what are the characteristics of REST APIs. And all this brings us to the most
    important part of all.
  prefs: []
  type: TYPE_NORMAL
- en: What Does an API Request Look Like?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed earlier, *REST API calls are stateless in nature*, which simply
    means that with each API request, we need to send
  prefs: []
  type: TYPE_NORMAL
- en: all the data that is required in order to process the request. This data involves
    the type of operation to be performed,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: information regarding user authentication,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the resource to be accessed via the API,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: and some additional parameters that might be required to process the request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on these requirements, a REST API request can be broken down into 4 components:'
  prefs: []
  type: TYPE_NORMAL
- en: Resource Path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the path to the resource that is to be acted upon via the API request.
    A resource can be thought of as an object or entity within the database. The resource
    path is *a mapping to* an entity within the database. Let’s continue with our
    example of a TODO app. One of the API endpoints can be used to fetch the list
    of all the TODOs of a user. The URL of the endpoint looks like this:`https://mytodolist.com/todos/`
  prefs: []
  type: TYPE_NORMAL
- en: Here, `https://mytodolist.com` is the domain of the website. `/todos/` is the
    resource path to the TODO objects.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Verb
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we discussed earlier, an API request has to specify what kind of CRUD operation
    it is intending to perform. For this, we specify an HTTP verb within our API call.
    The simplest way to understand HTTP verbs is that these are *words* that tell
    the server what action to perform on a particular resource.
  prefs: []
  type: TYPE_NORMAL
- en: There are a bunch of predefined and standardized HTTP verbs, however, the most
    commonly used ones are as mentioned below.
  prefs: []
  type: TYPE_NORMAL
- en: '**POST:** Used to create a resource object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GET:** Used to perform the read operation on the resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PUT:** Used to perform the update operation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DELETE:** Used to perform the delete operation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request Body
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The request body can be used to specify some of the additional parameters that
    can be required to process a request. For example, in our TODO app, in order to
    create a TODO object, we have to specify the task. Similarly, in order to update
    a TODO object, we need to specify the new task that will be replacing the original
    task in the TODO list, along with the ID for the task that has to be modified.
    In our API request, we will have to send this information via the request body.
  prefs: []
  type: TYPE_NORMAL
- en: '*Generally, we need to specify a request body for POST and PUT requests. GET
    requests don’t have a request body.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE:** The request body uses JSON format to send the request data in the
    form of a key-value pair object.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Request Header
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the above 3 components are generally enough to make a REST API request,
    sometimes we need to specify some additional details along with the API request
    as well. *Take an example of user authentication.*
  prefs: []
  type: TYPE_NORMAL
- en: In our TODO app, we might have a bunch of users, each of them having their own
    TODO lists. We have to ensure that first of all, only the authorized users can
    create, read, update and delete TODOs. Then, we also need to ensure that one user
    can’t access another user’s TODOs. To guarantee these requirements, we need to
    implement some sort of authorization on the API endpoints, that determines whether
    an authorized user is making the API request, and whether the resource actually
    belongs to the user.
  prefs: []
  type: TYPE_NORMAL
- en: While we won’t go deep into the authentication strategies, however, just for
    the sake of information, we send authentication information in the request header,
    generally in the form of a unique token.
  prefs: []
  type: TYPE_NORMAL
- en: All these components come together to make an API call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at some example API calls, made using cURL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The above given is a GET API request. We specify the HTTP verb using the `--request`
    flag. The `--url` flag is used to specify the request path. Then the headers are
    specified using `--header` flag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The above given is a POST request where we can see the example of the request
    body being specified, using the `--data` flag.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of how an API request is made might differ from one programming
    language or utility tool to another. However, the critical components of the API
    request are going to remain the same, i.e., the HTTP verb, request URL or request
    path, a request body, and request headers.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what a API request looks like, there’s just a final component
    remaining in the API request-response cycle that we need to understand — the API
    response.
  prefs: []
  type: TYPE_NORMAL
- en: What Does an API Response Look Like?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The API response is the response that the backend returns to the frontend after
    the API request has been processed. A response should tell the client whether
    the request was successful or not, and if successful, it should return the requested
    data, or an appropriate acknowledgement message to the client. In case the request
    was unsuccessful, the client should receive a relevant error message.
  prefs: []
  type: TYPE_NORMAL
- en: Based on these requirements, an API response can be broken down into two parts,
    as discussed below.
  prefs: []
  type: TYPE_NORMAL
- en: Response Body
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The response body consists of the requested data (in case of a GET API request),
    or an appropriate acknowledgment message in case of other API request types. In
    case of a failed API request, the response body consists of the appropriate failure
    message that specifies why the API call to the server failed.
  prefs: []
  type: TYPE_NORMAL
- en: Response Status Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The API response contains a response status code that helps the client determine
    whether the request was a success or failure. These status codes have been standardized
    for the HTTP protocol, and can be broadly divided into 5 classes — `1xx`→ Informational,
    `2xx` → Success, `3xx` → Redirection, `4xx` → Client Error, `5xx` → Server Error
  prefs: []
  type: TYPE_NORMAL
- en: Some of the common status codes are as mentioned below.
  prefs: []
  type: TYPE_NORMAL
- en: 200 — *OK. The request was successful.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 204 — *No Content.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 301 — *Moved Permanently.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 400 — *Bad Request.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 401 — *Unauthorized.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 403 — *Forbidden.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 404 — *Not Found.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 500 — *Internal Server Error.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, the response to the GET API request we made earlier was as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The response status code was 200.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this, we come to the end of this article. Just to summarize, we understood
    what APIs are, and how they function to allow communication between devices and
    applications. Finally, we studied REST APIs in depth — how an API request-response
    cycle works.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, APIs are just a foundation, or a backdoor, into the immense world
    of software development (backend, to be more precise) as the title suggests.
  prefs: []
  type: TYPE_NORMAL
- en: You can follow me to read more such interesting concepts. In the upcoming blogs
    in this series, we will dive deeper into backend development.
  prefs: []
  type: TYPE_NORMAL
