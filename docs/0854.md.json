["```py\nclass JobSequence(list):\n\n    def prev(self, x):\n        if self.is_first(x):\n            return None\n        else:\n            i = self.index(x)\n            return self[i - 1]\n\n    def next(self, x):\n        if self.is_last(x):\n            return None\n        else:\n            i = self.index(x)\n            return self[i + 1]\n\n    def is_first(self, x):\n        return x == self[0]\n\n    def is_last(self, x):\n        return x == self[-1]\n\n    def swap(self, x, y):\n        i = self.index(x)\n        j = self.index(y)\n        self[i] = y\n        self[j] = x\n\n    def append(self, __object) -> None:\n        if __object not in self:\n            super().append(__object)\n        else:\n            pass\n```", "```py\nclass JobShopParams:\n\n    def __init__(self, machines, jobs, p_times, seq):\n        self.machines = machines\n        self.jobs = jobs\n        self.p_times = p_times\n        self.seq = seq\n```", "```py\nimport numpy as np\n\nclass JobShopRandomParams(JobShopParams):\n\n    def __init__(self, n_machines, n_jobst, t_span=(1, 20), seed=None):\n\n        self.t_span = t_span\n        self.seed = seed\n\n        machines = np.arange(n_machines, dtype=int)\n        jobs = np.arange(n_jobs, dtype=int)\n        p_times = self._random_times(machines, jobs, t_span)\n        seq = self._random_sequences(machines, jobs)\n        super().__init__(machines, jobs, p_times, seq)\n\n    def _random_times(self, machines, jobs, t_span):\n        np.random.seed(self.seed)\n        t = np.arange(t_span[0], t_span[1])\n        return {\n            (m, j): np.random.choice(t)\n            for m in machines\n            for j in jobs\n        }\n\n    def _random_sequences(self, machines, jobs):\n        np.random.seed(self.seed)\n        return {\n            j: JobSequence(np.random.permutation(machines))\n            for j in jobs\n        }\n```", "```py\nimport pyomo.environ as pyo\n\nclass JobShopModel(pyo.ConcreteModel):\n\n    def __init__(self, params, **kwargs):\n        super().__init__()\n        self.params = params\n        self._construct_sets()\n        self._construct_params()\n\n    @property\n    def seq(self):\n        return self.params.seq\n\n    def _construct_sets(self):\n        self.M = pyo.Set(initialize=self.params.machines)\n        self.J = pyo.Set(initialize=self.params.jobs)\n\n    def _construct_params(self):\n        self.p = pyo.Param(self.M, self.J, initialize=self.params.p_times)\n        self.V = sum(self.p[key] for key in self.p)\n```", "```py\nclass DisjModel(JobShopModel):\n\n    def __init__(self, params, **kwargs):\n        super().__init__(params, **kwargs)\n        self._create_vars()\n        self._create_cstr()\n        self.obj = pyo.Objective(rule=self.C, sense=pyo.minimize)\n\n    def _create_vars(self):\n        self.x = pyo.Var(self.M, self.J, within=pyo.NonNegativeReals)\n        self.z = pyo.Var(self.M, self.J, self.J, within=pyo.Binary)\n        self.C = pyo.Var(within=pyo.NonNegativeReals)\n\n    def _create_cstr(self):\n        self.cstr_seq = pyo.Constraint(self.M, self.J, rule=cstr_seq)\n        self.cstr_precede = pyo.Constraint(self.M, self.J, self.J, rule=cstr_precede)\n        self.cstr_comp_precede = pyo.Constraint(self.M, self.J, self.J, rule=cstr_comp_precede)\n        self.cstr_total_time = pyo.Constraint(self.J, rule=cstr_total_time)\n```", "```py\ndef cstr_seq(model, m, j):\n    o = model.seq[j].prev(m)\n    if o is not None:\n        return model.x[o, j] + model.p[o, j] <= model.x[m, j]\n    else:\n        return pyo.Constraint.Skip\n\ndef cstr_precede(model, m, j, k):\n    if j != k:\n        return model.x[m, j] + model.p[m, j] <= model.x[m, k] + model.V * (1 - model.z[m, j, k])\n    else:\n        return pyo.Constraint.Skip\n\ndef cstr_comp_precede(model, m, j, k):\n    if j != k:\n        return model.z[m, j, k] + model.z[m, k, j] == 1\n    else:\n        return model.z[m, j, k] == 0\n\ndef cstr_total_time(model, j):\n    m = model.seq[j][-1]\n    return model.x[m, j] + model.p[m, j] <= model.C\n```", "```py\nclass TimeModel(JobShopModel):\n\n    def __init__(self, params, **kwargs):\n        super().__init__(params, **kwargs)\n        self.T = pyo.RangeSet(self.V)\n        self._create_vars()\n        self._create_cstr()\n        self.obj = pyo.Objective(rule=self.C, sense=pyo.minimize)\n\n    def _create_vars(self):\n        self.x = pyo.Var(self.M, self.J, self.T, within=pyo.Binary)\n        self.C = pyo.Var(within=pyo.NonNegativeReals)\n\n    def _create_cstr(self):\n        self.cstr_unique_start = pyo.Constraint(self.M, self.J, rule=cstr_unique_start)\n        self.cstr_unique_machine = pyo.Constraint(self.M, self.T, rule=cstr_unique_machine)\n        self.cstr_precede = pyo.Constraint(self.M, self.J, rule=cstr_precede)\n        self.cstr_total_time = pyo.Constraint(self.J, rule=cstr_total_time)\n\n    def _get_elements(self, j):\n        machines = [x.index()[0] for x in self.x[:, j, :] if x.value == 1]\n        starts = [x.index()[2] for x in self.x[:, j, :] if x.value == 1]\n        spans = [self.p[m, j] for m in machines]\n        return machines, starts, spans\n```", "```py\ndef cstr_unique_start(model, m, j):\n    return sum(model.x[m, j, t] for t in model.T) == 1\n\ndef cstr_unique_machine(model, m, t):\n    total = 0\n    start = model.T.first()\n    for j in model.J:\n        duration = model.p[m, j]\n        t0 = max(start, t - duration + 1)\n        for t1 in range(t0, t + 1):\n            total = total + model.x[m, j, t1]\n    return total <= 1\n\ndef cstr_precede(model, m, j):\n    o = model.seq[j].prev(m)\n    if o is None:\n        prev_term = 0\n    else:\n        prev_term = sum(\n            (t + model.p[o, j]) * model.x[o, j, t]\n            for t in model.T\n        )\n    current_term = sum(\n        t * model.x[m, j, t]\n        for t in model.T\n    )\n    return prev_term <= current_term\n\ndef cstr_total_time(model, j):\n    m = model.seq[j][-1]\n    return sum((t + model.p[m, j]) * model.x[m, j, t] for t in model.T) <= model.C\n```", "```py\nparams = JobShopRandomParams(3, 4, seed=12)\ndisj_model = DisjModel(params)\ntime_model = TimeModel(params)\n```", "```py\n# Time limited in 20 seconds\nsolver = pyo.SolverFactory(\"cbc\", options=dict(cuts=\"on\", sec=20))\n\n# solve\nres_disj = solver.solve(disj_model, tee=False)\nres_time = solver.solve(time_model, tee=False)\n```"]