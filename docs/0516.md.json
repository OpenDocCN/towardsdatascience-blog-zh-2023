["```py\nimport pydantic\n\nclass RpgCharacterModel(pydantic.BaseModel):\n    DATE: datetime\n    NAME: str\n    GENDER: str\n    RACE: str\n    CLASS: str\n    HOME: str\n    GUILD: str\n    PAY: int\n```", "```py\nimport enum\n\nclass GenderEnum(enum.Enum):\n    M = 'M'\n    F = 'F'\n    NB = 'NB'\n\nclass ClassEnum(enum.Enum):\n    Druid = 'Druid'\n    Fighter = 'Fighter'\n    Warlock = 'Warlock'\n    Ranger = 'Ranger'\n    Bard = 'Bard'\n    Sorcerer = 'Sorcerer'\n    Paladin = 'Paladin'\n    Rogue = 'Rogue'\n    Wizard = 'Wizard'\n    Monk = 'Monk'\n    Barbarian = 'Barbarian'\n    Cleric = 'Cleric'\n\nclass RaceEnum(enum.Enum):\n    Human = 'Human'\n    Dwarf = 'Dwarf'\n    Halfling = 'Halfling'\n    Elf = 'Elf'\n    Dragonborn = 'Dragonborn'\n    Tiefling = 'Tiefling'\n    Half_Orc = 'Half-Orc'\n    Gnome = 'Gnome'\n    Half_Elf = 'Half-Elf'\n```", "```py\nclass RpgCharacterModel(pydantic.BaseModel):\n    DATE: datetime\n    NAME: str\n    GENDER: GenderEnum\n    RACE: RaceEnum\n    CLASS: ClassEnum\n    HOME: str\n    GUILD: str\n    PAY: int\n```", "```py\nimport pydantic\n\nclass RpgCharacterModel(pydantic.BaseModel):\n    DATE: datetime\n    NAME: str = pydantic.Field(...)\n    GENDER: GenderEnum\n    RACE: RaceEnum = pydantic.Field(...)\n    CLASS: ClassEnum = pydantic.Field(...)\n    HOME: str\n    GUILD: str\n    PAY: int = pydantic.Field(..., ge=1, le=500)\n```", "```py\nimport pandas as pd\nimport pydantic\n\ndef validate_df_data(df: pd.DataFrame, model: pydantic.BaseModel, index_offset: int = 2) -> tuple[list, list]:\n    # Python index starts at 0, excel at 1, and 1 row for the header in Excel\n\n    #capturing our good data and our bad data\n    good_data = []\n    bad_data = []\n    df_rows = df.to_dict(orient='records')\n    for index, row in enumerate(df_rows):\n        try:\n            model(**row)  #unpacks our dictionary into our keyword arguments\n            good_data.append(row)  #appends valid data to a new list of dictionaries\n        except pydantic.ValidationError as e:\n            # Adds all validation error messages associated with the error\n            # and adds them to the dictionary\n            row['Errors'] = [error_message['msg'] for error_message in e.errors()]\n\n            row['Error_row_num'] = index + index_offset\n            bad_data.append(row)  #appends bad data to a different list of dictionaries\n\n    return (good_data, bad_data)\n```", "```py\n# Standard Library imports\nfrom datetime import datetime\nimport enum\n\n# 3rd Party package imports\nimport pandas as pd\nimport pydantic\n\n# Enums for limiting string data in our model\n\nclass GenderEnum(enum.Enum):\n    M = 'M'\n    F = 'F'\n    NB = 'NB'\n\nclass ClassEnum(enum.Enum):\n    Druid = 'Druid'\n    Fighter = 'Fighter'\n    Warlock = 'Warlock'\n    Ranger = 'Ranger'\n    Bard = 'Bard'\n    Sorcerer = 'Sorcerer'\n    Paladin = 'Paladin'\n    Rogue = 'Rogue'\n    Wizard = 'Wizard'\n    Monk = 'Monk'\n    Barbarian = 'Barbarian'\n    Cleric = 'Cleric'\n\nclass RaceEnum(enum.Enum):\n    Human = 'Human'\n    Dwarf = 'Dwarf'\n    Halfling = 'Halfling'\n    Elf = 'Elf'\n    Dragonborn = 'Dragonborn'\n    Tiefling = 'Tiefling'\n    Half_Orc = 'Half-Orc'\n    Gnome = 'Gnome'\n    Half_Elf = 'Half-Elf'\n\nclass RpgCharacterModel(pydantic.BaseModel):\n    DATE: datetime\n    NAME: str = pydantic.Field(...)\n    GENDER: GenderEnum\n    RACE: RaceEnum = pydantic.Field(...)\n    CLASS: ClassEnum = pydantic.Field(...)\n    HOME: str\n    GUILD: str\n    PAY: int = pydantic.Field(..., ge=1, le=500)\n\ndef validate_df_data(df: pd.DataFrame, model: pydantic.BaseModel, index_offset: int = 2) -> tuple[list, list]:\n    # Python index starts at 0, excel at 1, and 1 row for the header in Excel\n\n    #capturing our good data and our bad data\n    good_data = []\n    bad_data = []\n    df_rows = df.to_dict(orient='records')\n    for index, row in enumerate(df_rows):\n        try:\n            model(**row)  #unpacks our dictionary into our keyword arguments\n            good_data.append(row)  #appends valid data to a new list of dictionaries\n        except pydantic.ValidationError as e:\n            # Adds all validation error messages associated with the error\n            # and adds them to the dictionary\n            row['Errors'] = [error_message['msg'] for error_message in e.errors()]\n            # Python index starts at 0, excel at 1, and 1 row for the header in excel\n            row['Error_row_num'] = index + index_offset\n            bad_data.append(row)  #appends bad data to a different list of dictionaries\n\n    return (good_data, bad_data)\n\ndf = pd.read_excel('sample_dnd_character_data.xlsx')\nvalid_data, invalid_data = validate_df_data(df, RpgCharacterModel, index_offset=2)\n```"]