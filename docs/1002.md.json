["```py\nval stateEncoder = Encoders.javaSerialization(BloomFilter.class)\n```", "```py\nval stateEncoder = Encoders.product[FluxState]\n```", "```py\ncase class FluxState(\n    var version: Long = 0,\n    var active: Int = 0,\n    var serializedBlooms: List[Array[Byte]] = List()\n) extends TagCache {\n```", "```py\nval padding = 4000\nval n = tagCapacity / NUM_BLOOMS\n// Formula taken from https://hur.st/bloomfilter\n// m = ceil( (n * log(p)) / log(1 / pow(2, log(2))))\nval mBits = Math.ceil( \n      (n * Math.log(desiredFpp)) / Math.log(1 / Math.pow(2, Math.log(2))))\nval numBytes = (mBits / 8).toInt + padding  \nval byteArrayOut = new ByteArrayOutputStream(numBytes)\nval store = new ObjectOutputStream(byteArrayOut)\nstore.writeObject(bloom)\nstore.close\nbyteArrayOut.toByteArray()\n```", "```py\noverride def put(key: UnsafeRow, value: UnsafeRow): Unit = {\n  require(value != null, \"Cannot put a null value\")\n  verify(state == UPDATING, \"Cannot put after already committed or aborted\")\n  //val keyCopy = key.copy()\n  val valueCopy = value.copy()\n\n  // Create the key to store this bloom using the bloom id (active)\n  val newRowKey = makeRowKey(key.getString(0), getActiveValue(valueCopy))\n  // Store key/value as normal\n  mapToUpdate.put(newRowKey, valueCopy)\n  writeUpdateToDeltaFile(compressedStream, newRowKey, valueCopy)\n}\n```", "```py\ndef toState(): FluxState = {\n  version += 1    \n  // we only store the active blooms, all other blooms were un-changed\n  val approxsize = tagCapacity / NUM_BLOOMS * 3\n  val byteArrayOut = new ByteArrayOutputStream(approxsize)\n  val store = new ObjectOutputStream(byteArrayOut)\n  store.writeObject(getActiveBloom())\n  store.close\n  serializedBlooms = List(byteArrayOut.toByteArray())\n}\n```", "```py\noverride def get(key: UnsafeRow): UnsafeRow = {\n      mapToUpdate.get(key)\n    }\n```", "```py\noverride def get(key: UnsafeRow): UnsafeRow = {\n  // CCCS: The list of blooms for this key are put\n  // in separate entries in the store\n  // we will find all of these entries and create a FluxState\n  val groupKey = key.getString(0)\n  val fluxStates = Range(0, NUM_BLOOMS)\n      .map(bloomIndex => mapToUpdate.get(makeRowKey(groupKey, bloomIndex)))\n      .filter(_ != null)\n      .map(value => deserializeFluxState(value))\n\n  if(fluxStates.length > 0) {\n    makeRowValue(coalesceFluxStates(fluxStates))\n  }\n  else {\n    // else we found none of the blooms\n    null\n  }\n}\n```", "```py\ndef createBloom() = {\n  val bloomCapacity: Int = tagCapacity / NUM_BLOOMS\n  val bloom = BloomFilter.create(\n                Funnels.stringFunnel(), \n                bloomCapacity, \n                desiredFpp)\n  val prep = (bloomCapacity * Math.random()).toInt\n  (1 to prep).map(\"padding\" + _).foreach(s => bloom.put(s))\n  bloom\n}\n```"]