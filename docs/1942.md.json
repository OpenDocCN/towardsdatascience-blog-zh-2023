["```py\n# Index our first two restaurants\nPOST _bulk\n{ \"index\" : { \"_index\" : \"restaurant\", \"_id\" : \"001sabichuong\" } }\n{ \"restaurant_name\": \"Sa Bi Chuong\", \"cuisine\": \"Vietnamese\", \"rating\": 5.0 }\n{ \"index\" : { \"_index\" : \"restaurant\", \"_id\" : \"002vietnamesephonoodle\" } }\n{ \"restaurant_name\": \"Vietnamese Pho Noodle\", \"cuisine\": \"Vietnamese\", \"rating\": 4.0 }\n\n# Test searching for one\n# Should return Vietnamese Pho Noodle\nGET restaurant/_search\n{\n  \"query\" : {\n    \"match\" : { \"restaurant_name\": \"vietnamese\" }\n  }\n}\n```", "```py\n# Matching multiple fields\n# Should return all 2 Vietnamese restaurant with the Vietnamese Pho Noodle on top\nGET restaurant/_search\n{\n  \"query\" : {\n    \"multi_match\" : {\n      \"query\": \"vietnamese\",\n      \"fields\": [ \"restaurant_name\", \"cuisine\" ]\n    }\n  }\n}\n```", "```py\n# Result\n\"hits\": {\n    ...\n    \"hits\": [\n      {\n        \"_index\": \"restaurant\",\n        \"_id\": \"002vietnamesephonoodle\",\n        \"_score\": 0.6931471,\n        \"_source\": {\n          \"restaurant_name\": \"Vietnamese Pho Noodle\",\n          \"cuisine\": \"Vietnamese\",\n          \"rating\": 4\n        }\n      },\n      {\n        \"_index\": \"restaurant\",\n        \"_id\": \"001sabichuong\",\n        \"_score\": 0.18232156,\n        \"_source\": {\n          \"restaurant_name\": \"Sa Bi Chuong\",\n          \"cuisine\": \"Vietnamese\",\n          \"rating\": 5\n        }\n      }\n    ]\n  }\n```", "```py\n# Let's use explain=true to see what happens under the hood\n# Vietnamese Pho Noodle is on top because of the default implementation of TFIDF that penalizes the matching at cuisine field because there are multiple restaurants with cuisine=Vietnamese while there are only one restaurant with name=Vietnamese\n# Question: But why having the name Vietnamese in its name makes it more Vietnamese than other restaurants?\nGET restaurant/_search\n{\n  \"query\" : {\n    \"multi_match\" : {\n      \"query\": \"vietnamese\",\n      \"fields\": [ \"restaurant_name\", \"cuisine\" ]\n    }\n  },\n  \"explain\": true\n}\n```", "```py\n# Result\n\"hits\": {\n    \"hits\": [\n      {\n        \"_id\": \"002vietnamesephonoodle\",\n        \"_score\": 0.6931471,\n        \"_source\": {\n          \"restaurant_name\": \"Vietnamese Pho Noodle\",\n          \"cuisine\": \"Vietnamese\",\n          \"rating\": 4\n        },\n        \"_explanation\": {\n          \"value\": 0.6931471,\n          \"description\": \"max of:\",\n          \"details\": [\n            # Matching in field `cuisine` yields score=0.18\n            # Note that by default the score is calculated by TFIDF\n            # More info about Elasticsearch TFIDF: https://www.elastic.co/guide/en/elasticsearch/reference/8.6/index-modules-similarity.html#bm25\n            {\n              \"value\": 0.18232156,\n              \"description\": \"weight(cuisine:vietnamese in 1) [PerFieldSimilarity], result of:\",\n              \"details\": [...]\n            },\n            # Matching in field `restaurant_name` yields score=0.69\n            {\n              \"value\": 0.6931471,\n              \"description\": \"weight(restaurant_name:vietnamese in 1) [PerFieldSimilarity], result of:\",\n              \"details\": [...]\n            }\n            # Because the final score is \"max of:\" those two above scores,\n            # it is equal to the matching score with `restaurant_name`\n          ]\n        }\n      },\n      {\n        \"_id\": \"001sabichuong\",\n        \"_score\": 0.18232156,\n        \"_source\": {\n          \"restaurant_name\": \"Sa Bi Chuong\",\n          \"cuisine\": \"Vietnamese\",\n          \"rating\": 5\n        },\n        # Similarly since there's no matching with `restaurant_name`,\n        # here the final score is equal to the matching score of `cuisine`\n        \"_explanation\": {\n          \"value\": 0.18232156,\n          \"description\": \"max of:\",\n          \"details\": [\n            {\n              \"value\": 0.18232156,\n              \"description\": \"weight(cuisine:vietnamese in 0) [PerFieldSimilarity], result of:\",\n              \"details\": [...]\n            }\n          ]\n        }\n      }\n    ]\n  }\n```", "```py\n# Let's add another restaurant\nPOST _bulk\n{ \"index\" : { \"_index\" : \"restaurant\", \"_id\" : \"003vietnamesepho\" } }\n{ \"restaurant_name\": \"Vietnamese Pho\", \"cuisine\": \"Vietnamese\", \"rating\": 3.0 }\n\n# In the below example we see that the new Vietnamese Pho restaurant is ranked higher...\nGET restaurant/_search\n{\n  \"query\" : {\n    \"multi_match\" : {\n      \"query\": \"vietnamese pho\",\n      \"fields\": [ \"restaurant_name\", \"cuisine\" ]\n    }\n  },\n  \"explain\": true\n}\n```", "```py\nGET restaurant/_search\n{\n  \"query\": {\n    \"function_score\": {\n      # Our main query is wrapped in a function_score clause\n      \"query\": {\n        \"multi_match\" : {\n          \"query\": \"vietnamese\",\n          \"fields\": [ \"restaurant_name\", \"cuisine\" ]\n        }\n      },\n      # We define the functions that will be applied on top of the matching scores \n      # returned by our main query\n      \"functions\": [\n        {\n          \"field_value_factor\": {\n            \"field\": \"rating\",\n            \"modifier\": \"none\",\n            \"missing\": 1\n          }\n        }\n      ],\n      # Retrieve the max boosting defined inside `functions`\n      # Above there is only one boosting so it's applied by default\n      \"score_mode\": \"max\",\n      # Multiply the matching score with the boosting calculated from functions\n      \"boost_mode\": \"multiply\"\n    }\n  }\n}\n```", "```py\n# Result\n{\n  \"hits\": {\n    \"hits\": [\n      {\n        \"_index\": \"restaurant\",\n        \"_id\": \"002vietnamesephonoodle\",\n        \"_score\": 1.7885544,\n        \"_source\": {\n          \"restaurant_name\": \"Vietnamese Pho Noodle\",\n          \"cuisine\": \"Vietnamese\",\n          \"rating\": 4\n        }\n      },\n      {\n        \"_index\": \"restaurant\",\n        \"_id\": \"003vietnamesepho\",\n        \"_score\": 1.5706451,\n        \"_source\": {\n          \"restaurant_name\": \"Vietnamese Pho\",\n          \"cuisine\": \"Vietnamese\",\n          \"rating\": 3\n        }\n      },\n      {\n        \"_index\": \"restaurant\",\n        \"_id\": \"001sabichuong\",\n        \"_score\": 0.66765696,\n        \"_source\": {\n          \"restaurant_name\": \"Sa Bi Chuong\",\n          \"cuisine\": \"Vietnamese\",\n          \"rating\": 5\n        }\n      }\n    ]\n  }\n}\n```", "```py\nGET restaurant/_search\n{\n  \"query\": {\n    \"function_score\": {\n      \"query\": {\n        \"multi_match\" : {\n          \"query\": \"vietnamese\",\n          \"fields\": [ \"restaurant_name\", \"cuisine\" ]\n        }\n      },\n      \"functions\": [\n        # Apply a non-linear function to model that\n        # a rating of 5 has much more weight than rating of 4 (not just 25% more)\n        {\n          \"filter\": {\n            \"range\": {\n              \"rating\": {\n                \"gte\": 5,\n                \"lte\": 5\n              }\n            }\n          },\n          \"weight\": 10\n        },\n        {\n          \"filter\": {\n            \"range\": {\n              \"rating\": {\n                \"gte\": 4,\n                \"lt\": 5\n              }\n            }\n          },\n          \"weight\": 2\n        }\n      ],\n      \"score_mode\": \"max\",\n      \"boost_mode\": \"multiply\"\n    }\n  }\n}\n```", "```py\n# Result\n{\n  \"hits\": {\n    \"hits\": [\n      {\n        \"_index\": \"restaurant\",\n        \"_id\": \"001sabichuong\",\n        \"_score\": 1.3353139,\n        \"_source\": {\n          \"restaurant_name\": \"Sa Bi Chuong\",\n          \"cuisine\": \"Vietnamese\",\n          \"rating\": 5\n        }\n      },\n      {\n        \"_index\": \"restaurant\",\n        \"_id\": \"002vietnamesephonoodle\",\n        \"_score\": 0.8942772,\n        \"_source\": {\n          \"restaurant_name\": \"Vietnamese Pho Noodle\",\n          \"cuisine\": \"Vietnamese\",\n          \"rating\": 4\n        }\n      },\n      {\n        \"_index\": \"restaurant\",\n        \"_id\": \"003vietnamesepho\",\n        \"_score\": 0.52354836,\n        \"_source\": {\n          \"restaurant_name\": \"Vietnamese Pho\",\n          \"cuisine\": \"Vietnamese\",\n          \"rating\": 3\n        }\n      }\n    ]\n  }\n}\n```", "```py\n# The use of `bool` query below is to implement the logic: At least one condition should match\nPUT _scripts/01-default-fuzzy-search-template\n{\n  \"script\": {\n    \"lang\": \"mustache\",\n    \"source\": {\n      \"query\": {\n        \"function_score\": {\n          \"query\": {\n            \"bool\": {\n              \"must\": [\n                {\n                  \"bool\": {\n                    \"should\": [\n                      {\n                        \"multi_match\" : {\n                          \"query\": \"{{query_string}}\",\n                          \"fields\": [ \"restaurant_name\", \"cuisine\" ]\n                        }\n                      },\n                      {\n                        \"multi_match\" : {\n                          \"query\": \"{{query_string}}\",\n                          \"fields\": [ \"restaurant_name\", \"cuisine\" ],\n                          # For the purpose of this demo, default behavior works well enough\n                          \"fuzziness\": \"AUTO\"\n                        }\n                      }\n                    ]\n                  }\n                }\n              ]\n            }\n          },\n          \"functions\": [\n            {\n              \"filter\": {\n                \"range\": {\n                  \"rating\": {\n                    \"gte\": 5,\n                    \"lte\": 5\n                  }\n                }\n              },\n              \"weight\": 10\n            },\n            {\n              \"filter\": {\n                \"range\": {\n                  \"rating\": {\n                    \"gte\": 4,\n                    \"lt\": 5\n                  }\n                }\n              },\n              \"weight\": 2\n            }\n          ],\n          \"score_mode\": \"max\",\n          \"boost_mode\": \"multiply\"\n        }\n      }\n    },\n    \"params\": {\n      \"query_string\": \"My query string\"\n    }\n  }\n}\n```", "```py\nGET /_search/template\n{\n  \"id\": \"01-default-fuzzy-search-template\",\n  \"params\": {\n    \"query_string\": \"vietnames\"\n  }\n}\n```", "```py\nPOST _bulk\n{ \"index\" : { \"_index\" : \"restaurant\", \"_id\" : \"004parkhangseokbbq\" } }\n{ \"restaurant_name\": \"Park Hang-seo's KBBQ\", \"cuisine\": \"Korean\", \"rating\": 2.0 }\n{ \"index\" : { \"_index\" : \"restaurant\", \"_id\" : \"005bestbbqintown\" } }\n{ \"restaurant_name\": \"Best BBQ in town\", \"cuisine\": \"Japanese\", \"rating\": 5.0 }\n```", "```py\n{\n  \"id\": \"01-default-fuzzy-search-template\",\n  \"params\": {\n    \"query_string\": \"kbbq\"\n  }\n}\n```", "```py\n{\n  \"hits\": {\n    \"hits\": [\n      {\n        \"_index\": \"restaurant\",\n        \"_id\": \"005bestbbqintown\",\n        \"_score\": 8.384459,\n        \"_source\": {\n          \"restaurant_name\": \"Best BBQ in town\",\n          \"cuisine\": \"Japanese\",\n          \"rating\": 5\n        }\n      },\n      {\n        \"_index\": \"restaurant\",\n        \"_id\": \"004parkhangseokbbq\",\n        \"_score\": 2.5153382,\n        \"_source\": {\n          \"restaurant_name\": \"Park Hang-seo's KBBQ\",\n          \"cuisine\": \"Korean\",\n          \"rating\": 2\n        }\n      }\n    ]\n  }\n}\n```", "```py\nGET restaurant/_rank_eval\n{\n  # Query template comes in really handy when used in conjunction with _rank_eval\n  \"templates\": [\n     {\n        \"id\": \"01-default-fuzzy-search-template\",\n        \"template\": { \n            \"id\": \"01-default-fuzzy-search-template\"\n        }\n     }\n  ],\n  \"requests\": [\n    {\n     \"id\": \"kbbq_query\",\n     # Here we manually define the true positives with rating >= 1.0\n     # The actual rating number helps when using metrics that takes into account\n     # the ranking of the search results\n     \"ratings\": [\n        { \"_index\": \"restaurant\", \"_id\": \"004parkhangseokbbq\", \"rating\": 3 },\n        { \"_index\": \"restaurant\", \"_id\": \"005bestbbqintown\", \"rating\": 1 }\n      ],\n     \"template_id\": \"01-default-fuzzy-search-template\",\n     \"params\": { \n        \"query_string\": \"kbbq\"\n      }\n    },\n    {\n     \"id\": \"vietnamese_query\",\n     \"ratings\": [\n        { \"_index\": \"restaurant\", \"_id\": \"001sabichuong\", \"rating\": 3 },\n        { \"_index\": \"restaurant\", \"_id\": \"002vietnamesephonoodle\", \"rating\": 3 },\n        { \"_index\": \"restaurant\", \"_id\": \"003vietnamesepho\", \"rating\": 3 }\n      ],\n     \"template_id\": \"01-default-fuzzy-search-template\", \n     \"params\": { \n        \"query_string\": \"vietnamese\"\n      }\n    }\n  ],\n  \"metric\": {\n    \"dcg\": {\n      \"k\": 5,\n      \"normalize\": true\n    }\n  }\n}\n```", "```py\n{\n  \"metric_score\": 0.8549048706984328,  # This is the overall metric score, best is 1.0, worst is 0.0\n  \"details\": {\n    \"kbbq_query\": {\n      # This kbbq_query has a imperfect score because it ranks the more relevant result lower\n      \"metric_score\": 0.7098097413968655,\n      \"unrated_docs\": [],\n      \"hits\": [\n        {\n          \"hit\": {\n            \"_index\": \"restaurant\",\n            \"_id\": \"005bestbbqintown\",\n            \"_score\": 8.384459\n          },\n          \"rating\": 1\n        },\n        {\n          \"hit\": {\n            \"_index\": \"restaurant\",\n            \"_id\": \"004parkhangseokbbq\",\n            \"_score\": 2.5153382\n          },\n          \"rating\": 3\n        }\n      ],\n      \"metric_details\": {\n        ...\n      }\n    },\n    \"vietnamese_query\": {\n      \"metric_score\": 1,\n      \"unrated_docs\": [],\n      \"hits\": [\n        ...\n      ],\n      \"metric_details\": {\n        ...\n      }\n    }\n  },\n  \"failures\": {}\n}\n```", "```py\nPUT _scripts/02-constant-score-search-template\n{\n  \"script\": {\n    \"lang\": \"mustache\",\n    \"source\": {\n      \"query\": {\n        \"function_score\": {\n          \"query\": {\n            \"bool\": {\n              \"must\": [\n                {\n                  \"bool\": {\n                    \"should\": [\n                      {\n                        # `dis_max` query gets the max score of an array of clauses\n                        \"dis_max\": {\n                          \"queries\": [\n                            {\n                              # `constant_score` says that if matches, return a constant score\n                              \"constant_score\": {\n                                \"filter\": {\n                                  \"multi_match\" : {\n                                    \"query\": \"{{query_string}}\",\n                                    \"fields\": [ \"restaurant_name\", \"cuisine\" ]\n                                  }\n                                },\n                                # This is the constant that is returned as score\n                                # Note that the exact number is chosen intentionally\n                                # Here the upper level will be twice the lower level\n                                # and we will restrict the modifiers to be only\n                                # able to boost by at most 100% the base score\n                                # so that the lower level can not exceed the upper\n                                \"boost\": 2\n                              }\n                            },\n                            {\n                              \"constant_score\": {\n                                \"filter\": {\n                                  \"multi_match\" : {\n                                    \"query\": \"{{query_string}}\",\n                                    \"fields\": [ \"restaurant_name\", \"cuisine\" ],\n                                    \"fuzziness\": \"AUTO\"\n                                  }\n                                },\n                                \"boost\": 1\n                              }\n                            }\n                          ]\n                        }\n                      }\n                    ]\n                  }\n                }\n              ]\n            }\n          },\n          \"functions\": [\n            # Design the modifiers to be multiplier of maximum 1.9999 the base score\n            {\n              \"weight\": 1\n            },\n            {\n              \"field_value_factor\": {\n                \"field\": \"rating\",\n                \"modifier\": \"ln\",\n                \"missing\": 1\n              },\n              \"weight\": 0.1\n            }\n          ],\n          \"score_mode\": \"sum\",\n          \"boost_mode\": \"multiply\"\n        }\n      }\n    },\n    \"params\": {\n      \"query_string\": \"My query string\"\n    }\n  }\n}\n```", "```py\n# Result\n{\n  \"hits\": {\n    \"hits\": [\n      {\n        \"_id\": \"003vietnamesepho\",\n        \"_score\": 1.0470967,\n        \"_source\": {\n          \"restaurant_name\": \"Vietnamese Pho\",\n          \"cuisine\": \"Vietnamese\",\n          \"rating\": 3\n        },\n        \"_explanation\": {\n          \"value\": 1.0470967,\n          \"description\": \"max of:\",\n          \"details\": [\n            {\n              \"value\": 0.13353139,\n              \"description\": \"sum of:\",\n              \"details\": [\n                {\n                  \"value\": 0.13353139,\n                  \"description\": \"weight(cuisine:vietnamese in 0) [PerFieldSimilarity], result of:\",\n                  \"details\": [...]\n                }\n              ]\n            },\n            {\n              \"value\": 1.0470967,\n              \"description\": \"sum of:\",\n              \"details\": [\n                # Matching score with \"vietnamese\"\n                {\n                  \"value\": 0.52354836,\n                  \"description\": \"weight(restaurant_name:vietnamese in 0) [PerFieldSimilarity], result of:\",\n                  \"details\": [\n                    {\n                      \"value\": 0.52354836,\n                      \"description\": \"score(freq=1.0), computed as boost * idf * tf from:\",\n                      \"details\": [\n                        {\n                          \"value\": 2.2,\n                          \"description\": \"boost\",\n                          \"details\": []\n                        },\n                        {\n                          \"value\": 0.47000363,\n                          \"description\": \"idf, computed as log(1 + (N - n + 0.5) / (n + 0.5)) from:\",\n                          ...\n                        },\n                        {\n                          \"value\": 0.50632906,\n                          \"description\": \"tf, computed as freq / (freq + k1 * (1 - b + b * dl / avgdl)) from:\",\n                          \"details\": [\n                            {\n                              \"value\": 1,\n                              \"description\": \"freq, occurrences of term within document\",\n                              \"details\": []\n                            },\n                            {\n                              \"value\": 1.2,\n                              \"description\": \"k1, term saturation parameter\",\n                              \"details\": []\n                            },\n                            {\n                              \"value\": 0.75,\n                              \"description\": \"b, length normalization parameter\",\n                              \"details\": []\n                            },\n                            # Notice the length=2 here is in the denominator,\n                            # which means that the higher the length the less\n                            # the score\n                            {\n                              \"value\": 2,\n                              \"description\": \"dl, length of field\",\n                              \"details\": []\n                            },\n                            {\n                              \"value\": 2.6666667,\n                              \"description\": \"avgdl, average length of field\",\n                              \"details\": []\n                            }\n                          ]\n                        }\n                      ]\n                    }\n                  ]\n                },\n                # Matching score with \"pho\"\n                {\n                  \"value\": 0.52354836,\n                  \"description\": \"weight(restaurant_name:pho in 0) [PerFieldSimilarity], result of:\",\n                  # Details are exactly like above\n                  \"details\": [...]\n                }\n              ]\n            }\n          ]\n        }\n      },\n      {\n        \"_id\": \"002vietnamesephonoodle\",\n        \"_score\": 0.8942772,\n        \"_source\": {\n          \"restaurant_name\": \"Vietnamese Pho Noodle\",\n          \"cuisine\": \"Vietnamese\",\n          \"rating\": 4\n        },\n        \"_explanation\": {\n          \"value\": 0.8942772,\n          \"description\": \"max of:\",\n          \"details\": [\n            {\n              \"value\": 0.13353139,\n              \"description\": \"sum of:\",\n              \"details\": [...]\n            },\n            {\n              \"value\": 0.8942772,\n              \"description\": \"sum of:\",\n              \"details\": [\n                {\n                  \"value\": 0.4471386,\n                  \"description\": \"weight(restaurant_name:vietnamese in 1) [PerFieldSimilarity], result of:\",\n                  \"details\": [\n                    {\n                      \"value\": 0.4471386,\n                      \"description\": \"score(freq=1.0), computed as boost * idf * tf from:\",\n                      \"details\": [\n                        ...,\n                        {\n                          \"value\": 0.4324324,\n                          \"description\": \"tf, computed as freq / (freq + k1 * (1 - b + b * dl / avgdl)) from:\",\n                          \"details\": [\n                            ...,\n                            # Here the length=3 (greater than length=2 of the\n                            # above restaurant)\n                            {\n                              \"value\": 3,\n                              \"description\": \"dl, length of field\",\n                              \"details\": []\n                            },\n                            ...\n                          ]\n                        }\n                      ]\n                    }\n                  ]\n                },\n                {\n                  \"value\": 0.4471386,\n                  \"description\": \"weight(restaurant_name:pho in 1) [PerFieldSimilarity], result of:\",\n                  \"details\": [...]\n                }\n              ]\n            }\n          ]\n        }\n      }\n    ]\n  }\n}\n```"]