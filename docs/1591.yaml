- en: 'Rust Polars: Unlocking High-Performance Data Analysis — Part 1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/rust-polars-unlocking-high-performance-data-analysis-part-1-ce42af370ece?source=collection_archive---------0-----------------------#2023-05-11](https://towardsdatascience.com/rust-polars-unlocking-high-performance-data-analysis-part-1-ce42af370ece?source=collection_archive---------0-----------------------#2023-05-11)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exploring The World of Rust’s Polars, Series, and Beyond
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://wiseai.medium.com/?source=post_page-----ce42af370ece--------------------------------)[![Mahmoud
    Harmouch](../Images/d61617549d25565399975debaad5908f.png)](https://wiseai.medium.com/?source=post_page-----ce42af370ece--------------------------------)[](https://towardsdatascience.com/?source=post_page-----ce42af370ece--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----ce42af370ece--------------------------------)
    [Mahmoud Harmouch](https://wiseai.medium.com/?source=post_page-----ce42af370ece--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fb15db3da5667&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Frust-polars-unlocking-high-performance-data-analysis-part-1-ce42af370ece&user=Mahmoud+Harmouch&userId=b15db3da5667&source=post_page-b15db3da5667----ce42af370ece---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----ce42af370ece--------------------------------)
    ·32 min read·May 11, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fce42af370ece&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Frust-polars-unlocking-high-performance-data-analysis-part-1-ce42af370ece&user=Mahmoud+Harmouch&userId=b15db3da5667&source=-----ce42af370ece---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fce42af370ece&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Frust-polars-unlocking-high-performance-data-analysis-part-1-ce42af370ece&source=-----ce42af370ece---------------------bookmark_footer-----------)![](../Images/04aed287279a73e0ed116a7c5a65c6f7.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Photo by [Kaiwen Sun](https://unsplash.com/@ksun?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: TL;DR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the fast-paced world of data science, it can be daunting to keep up with
    new advancements. However, Rust has proven itself as a reliable and crucial tool
    in this industry. Presently, Polars is among the most popular libraries for manipulating
    data in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: This write-up acts as an intensive course on the various tasks related to data
    analysis which can be performed on Series in Polars. Through hands-on exercises
    and code snippets, you’ll acquire crucial skills such as executing diverse operations
    on Series along with working with time series among other things. The ultimate
    goal is to equip readers like yourself with adequate knowledge so that performing
    preprocessing activities becomes second nature!
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** This article assumes that you have a fairly basic understanding of
    the Rust programming language.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The notebook named [**3-polars-tutorial-part-1.ipynb**](https://github.com/wiseaidev/rust-data-analysis/blob/main/3-polars-tutorial-part-1.ipynb)wasdeveloped
    for this article which can be found in the following repository:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[](https://github.com/wiseaidev/rust-data-analysis?source=post_page-----ce42af370ece--------------------------------)
    [## GitHub - wiseaidev/rust-data-analysis: The ultimate data analysis with Rust
    course.'
  prefs: []
  type: TYPE_NORMAL
- en: This repository is a collection of Jupyter notebooks, all powered by a Rust
    kernel. With these notebooks, you'll be…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: github.com](https://github.com/wiseaidev/rust-data-analysis?source=post_page-----ce42af370ece--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Table of Contents(TOC)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ∘ [Introduction](#7211)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Bit of History](#c89a)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Core Components](#318c)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Use Cases](#a837)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Architecture](#b9a9)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Core Objects](#d579)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Series Object](#4f0d)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Descriptive Statistics](#40fb)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Measures of Central Tendency](#bb49)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Measures of Spread](#58c9)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Conclusion](#6902)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Closing Note](#7e8f)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Resources](#7546)
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/5c361426a8faf1e9703b452f815c31bf.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Raimond Klavins](https://unsplash.com/@raimondklavins?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: '[**Polars**](https://github.com/pola-rs/polars) is an incredibly popular open-source
    library in the data science and machine learning community, serving as a powerful
    tool for data manipulation, preparation, and analysis. Not only is it not tied
    to a specific programming language (e.g. It can be used with [**Python**](https://pola-rs.github.io/polars/py-polars/html/reference/index.html),[**Rust**](https://pola-rs.github.io/polars/polars/index.html),
    [**Node.JS**](https://pola-rs.github.io/nodejs-polars/index.html), and even [**R**](https://rpolars.github.io/index.html)),
    but it also comes with various functionalities, such as loading different formats
    of data alongside manipulating complex datasets, making it the go-to standard
    when performing any form of complex analytical tasks. To fully appreciate its
    significance today, we must delve into its origins to understand how it has evolved
    over time.'
  prefs: []
  type: TYPE_NORMAL
- en: Bit of History
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/d23a15f013520880b845196dd7c14355.png)'
  prefs: []
  type: TYPE_IMG
- en: Polars Star History (Image generated from [star-history.com](https://star-history.com/)
    by author)
  prefs: []
  type: TYPE_NORMAL
- en: '[In 2020](https://github.com/pola-rs/polars/commit/2714893dd8061644a7aa0fe0e983c2faf17d18c1),
    Ritchie Vink, a visionary [who transitioned from structural engineering to data
    engineering](https://www.ritchievink.com/about/), identified an unfulfilled need
    in the market for better data science tools. Dissatisfied with what was available,
    he set out on a mission to create something truly exceptional: [Polars](https://github.com/ritchie46/polars).'
  prefs: []
  type: TYPE_NORMAL
- en: This remarkable tool is not only elegant and intuitive but also requires minimal
    code while delivering maximum performance. Since its inception, it has become
    nothing short of revolutionary within the data science community due to its unparalleled
    ability to handle complex analytical tasks and manipulate large amounts of data
    effortlessly.
  prefs: []
  type: TYPE_NORMAL
- en: It’s no wonder Polars have quickly risen as one of today’s most popular data
    science tools worldwide. We can argue that this Library somehow contributed to
    the Rust programming language gaining more popularity!
  prefs: []
  type: TYPE_NORMAL
- en: Polars delivers proficiency in handling diverse categories of data such as “Tabular
    data”, “ordered data”, “observational statistics”, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Tabular data stands out as one such type of data that contains rows and columns
    filled with different kinds of numerical, text-based or categorical values. Another
    form comes in the shape of ordered or unordered series data; essentially a list
    containing numbers arranged either sequentially or randomly.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-dimensional matrices are yet another kind to be considered; these can
    have three dimensions, four dimensions…or even more! They’re often used for scientific
    computations and image processing purposes. Last but not least, come observational
    statistics from multiple sources like SQL databases; all contributing their unique
    perspectives on complex issues within our society today.
  prefs: []
  type: TYPE_NORMAL
- en: Core Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Polars is an effective asset for the manipulation and analysis of data. To make
    efficient use of it, comprehending its structure holds the utmost significance.
    Therefore, let’s delve deeper into the various components that form part of this
    Polars library.
  prefs: []
  type: TYPE_NORMAL
- en: '`[**Polars/algo**](https://github.com/pola-rs/polars/tree/main/polars/polars-algo)`:
    The functionalities offered by this module are truly remarkable, including qcut,
    cut, and hist. These functions empower users to conduct complex calculations with
    utmost ease while also producing comprehensive statistics for series as well as
    data frames.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[**Polars/arrow**](https://github.com/pola-rs/polars/tree/main/polars/polars-arrow)`:
    The arrow component of Polars contains the implementations of array conversion,
    data types, and kernels. This component makes it easier to convert data between
    different formats, such as Polars data frames and Apache Arrow arrays.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[**Polars/core**](https://github.com/pola-rs/polars/tree/main/polars/polars-core)`:
    This component implements the foundational data structures of Polars, which consists
    of Series and DataFrames. These data structures are crucial for effective handling
    of data with ease by providing a variety of capabilities such as filtering, grouping,
    and merging operations to support diverse analytical tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[**Polars/io**](https://github.com/pola-rs/polars/tree/main/polars/polars-io)`:
    This module includes components for input and output of files and data, streamlining
    the process. They enable us to effortlessly import data from various sources,
    including CSVs and text documents while allowing easy export into formats such
    as text or CSV. This functionality simplifies reading and writing data across
    multiple platforms resulting in increased efficiency when processing large amounts
    of data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[**Polars/lazy**](https://github.com/pola-rs/polars/tree/main/polars/polars-lazy)`:
    The lazy API in Polars offers an efficient approach to data analysis, supporting
    a subset of the eager API. This feature resembles Apache Spark’s query language,
    where domain-specific queries translate into logical plans that outline each step
    taken during execution. Before running these plans, they are optimized for maximum
    performance by rearranging operations if necessary and adding implicit type casts
    to prevent any potential errors from occurring during runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[**Polars/ops**](https://github.com/pola-rs/polars/tree/main/polars/polars-ops)`:
    This Polars module provides robust tools to handle complex operations on DataFrames
    and Series. These advanced functionalities enable us to easily extract unique
    values, perform floor division, calculate logarithms, pivot tables, and join DataFrames.
    Moreover, these operations are optimized for lightning-fast performance, perfect
    when working with large datasets! The capabilities within the Polars/ops component
    make data manipulation an absolute breeze, allowing analysts to analyze their
    data to draw valuable insights from it seamlessly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[**Polars/row**](https://github.com/pola-rs/polars/tree/main/polars/polars-row)`:
    This module has a remarkable feature that includes algorithms, which offer extra
    utilities to the existing polars’ library. These added functionalities include
    diverse encoding techniques like integer, float, and dictionary encodings to reduce
    the storage space required for large datasets. Additionally, ordering mechanisms
    such as the nulls-ordering algorithm or reverse column sorting facilitates efficient
    organization and classification of data, especially when working with massive
    amounts of information. Utilizing this component can significantly enhance effectiveness
    in manipulating and analyzing data sets effortlessly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[**Polars/SQL**](https://github.com/pola-rs/polars/tree/main/polars/polars-sql)`:
    This module contains many algorithms that facilitate the interaction between SQL
    databases and Polars functions. Among these methods are select queries, join operations,
    and other data retrieval techniques that simplify working with SQL databases.
    This feature is especially beneficial for data scientists who require access to
    information stored in such systems as they can easily integrate it into their
    analysis using Polars/sql functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[**Polars/time**](https://github.com/pola-rs/polars/tree/main/polars/polars-time)`:
    This component of Polars contains functionalities for handling time records and
    time-series data. Time-series data is indexed based on time, such as stock prices
    or weather data. Polars/time provides functionalities for handling time-based
    data, such as converting between different time formats, performing time-series
    arithmetic, and resampling time-series data. This component of Polars is essential
    for any data scientist who works with time-series data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**p**[**olars/util**](https://github.com/pola-rs/polars/tree/main/polars/polars-utils)`:
    This module contains tools that facilitate debugging. This module offers an array
    of functions and techniques to track down errors, display debug data, and evaluate
    code performance. The utilities available in this module prove beneficial for
    resolving any problems encountered while working with Polars and enhancing code
    efficiency toward more effective manipulation and data analysis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding these components will allow you to efficiently manipulate and
    analyze your data.
  prefs: []
  type: TYPE_NORMAL
- en: Use Cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/3d1e35e08ea16797c19848d8aeb76c93.png)'
  prefs: []
  type: TYPE_IMG
- en: Polars Use-Cases (Image by author)
  prefs: []
  type: TYPE_NORMAL
- en: 'Polars hold the potential to be utilized across various domains. It facilitates
    experts in obtaining valuable perspectives and arriving at informed conclusions
    based on data analysis. Below are some of the sectors where Polars find their
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Recommendation Systems**: Recommendation systems are a powerful tool for
    companies like Netflix and Amazon, as they leverage data to provide personalized
    recommendations to users. Through analyzing user behavior and preferences, Polars
    can assist in making tailored recommendations that increase engagement while driving
    revenue. This makes recommendation systems essential to any company’s strategy
    to deliver exceptional customer experiences through customized content suggestions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Marketing**: Implementing Polars in marketing can aid in analyzing consumer
    actions, preferences, and purchase patterns. This allows companies to understand
    their intended audience better, enabling them to make informed decisions about
    their advertising efforts. Businesses can enhance campaign efficacy by utilizing
    data-driven insights for optimization purposes while increasing(ROI).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stock Predictions**: The finance sector can employ Polars to analyze past
    and present financial data, enabling them to forecast stock prices and monitor
    market trends. By detecting patterns in this information, investors are empowered
    with the knowledge needed for informed decisions on whether or not to invest in
    stocks — a move that could result in significant monetary rewards.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Neuroscience**: Polars possess potential in the field of neuroscience for
    examining and presenting complex neural information. Researchers can utilize the
    special data analysis functions of Polars to extract significant knowledge regarding
    brain function and behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Natural Language Processing**: NLP is an impressive tool that can effectively
    analyze and preprocess text data. Polars provides businesses with the ability
    to process extensive amounts of customer sentiment information, leading to informed
    decisions in product development and service delivery. The tasks accomplished
    through NLP include sentiment analysis, topic modeling, and text classification
    which provide valuable insights into customers’ needs while guiding companies
    towards making data-driven improvements for better quality offerings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given the above use cases, you can see that Polars has a wide range of applications
    that significantly affect our daily lives. By mastering this library, you can
    invest in your analytics career and unlock numerous opportunities across various
    industries. This will give you the competitive edge to thrive in today’s data-driven
    world.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Polars is an incredibly powerful data processing tool that utilizes [**Apache
    Arrow**](https://arrow.apache.org/) as its core to deliver lightning-fast computational
    performance. Specifically designed for handling large datasets and performing
    complex operations with effortless efficiency. Unlike other libraries that utilize
    Arrow solely for reading **Parquet files**, Polars has strong integration. It
    employs a Rust-based implementation of the Arrow memory format to store data column-wise,
    which enables Polars to take advantage of highly optimized and efficient Arrow
    data structures while concentrating on manipulating the stored information.
  prefs: []
  type: TYPE_NORMAL
- en: Looking ahead toward future developments, Polars is actively working on expanding
    its distribution system capabilities through [**DataFusion**](https://arrow.apache.org/datafusion/)
    — a new platform aimed at becoming one of the most advanced systems available
    today! While there may be some overlap between this innovative technology and
    [**Apache Spark**](https://spark.apache.org/) or other competing products out
    there already, rest assured that the team behind Polars remains committed to utilizing
    every possible advantage provided via integration into existing frameworks such
    as those powered by Arrows back-end architecture- ensuring maximum peformance
    behind each computation performed within your projects!
  prefs: []
  type: TYPE_NORMAL
- en: Core Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/5c5f389d66946e656134d5c3116f0147.png)'
  prefs: []
  type: TYPE_IMG
- en: Polars dataframe and series representations (Image by author)
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will explore the fundamental concepts of Polars. As always,
    to enhance your learning experience, [**a Jupyter Notebook**](https://github.com/wiseaidev/rust-data-analysis/blob/main/3-polars-tutorial-part-1.ipynb)
    was utilized for executing code snippets in this article. As many are aware, [**Jupyter**](https://jupyter.org/)
    is an interactive computing platform accessible through any web browser, enabling
    us to create and share documents containing live codes along with visualizations
    and explanatory text, making learning more engaging than ever before!
  prefs: []
  type: TYPE_NORMAL
- en: Series Object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0c275c81f2cbd43ed938fe6a3ece353b.png)'
  prefs: []
  type: TYPE_IMG
- en: Series object representation (Image by author)
  prefs: []
  type: TYPE_NORMAL
- en: To gain a comprehensive understanding of **data wrangling** using Polars, it
    is necessary to begin with the basics. This includes working with one-dimensional
    data, best represented using **Series** **objects** in Polars.
  prefs: []
  type: TYPE_NORMAL
- en: The **Series object** is a crucial data structure in Polars, representing one-dimensional,
    or 1-D for short, information. It combines the features of both a [**vector**](https://doc.rust-lang.org/std/vec/struct.Vec.html)
    and [**HashMap**](https://doc.rust-lang.org/std/collections/struct.HashMap.html)
    by having an **ordered sequence** with **labels** for easy retrieval. A simple
    analogy would be to imagine one column that stores actual data values with a label.
    This makes managing large amounts of structured data more accessible and effective
    within your codebase.
  prefs: []
  type: TYPE_NORMAL
- en: To create a Series object in Polars, initialize it using the `[**Series::new**](https://docs.rs/polars/latest/polars/prelude/struct.Series.html#method.new-37)`
    method. This powerful function allows for creating custom Series objects with
    specified values and inferred data types to suit your needs. This process can
    be demonstrated by examining the following code. By utilizing the `[**Series::new**](https://docs.rs/polars/latest/polars/prelude/struct.Series.html#method.new-37)`
    method, we can create a Series object denoted as `**series**` and assign it values
    `**[1, 2, 3]**`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the above code in a Jupyter notebook cell will produce the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The output of a Series object created using the `**Series::new**` method displays
    the representation of one-dimensional data in Polars. The Series object contains
    an ordered sequence of values indexed with a label to facilitate easy retrieval.
    The indices are integers by default, beginning with 0 and incrementing by 1 for
    each value in the Series.
  prefs: []
  type: TYPE_NORMAL
- en: It is crucial to note that the Series objects have a remarkable advantage over
    other data structures in terms of customization. Column names are utilized for
    better comprehension of data. Think of them as labels to better comprehend each
    column/feature.
  prefs: []
  type: TYPE_NORMAL
- en: Polars’s series objects are highly adaptable and support various data types,
    such as integers, strings, booleans, or datetime values. To create a new Series
    object with strings only in it named `**series**`, use the `**Series::new**` method
    while passing a vector of `**string**` objects for storing them as strings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this snippet will result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The result is a Series object which is nicely rendered on the terminal. We can
    see here that Polars has automatically identified the type of data in this Series
    as `**str**` and set the `**dtype**` attribute as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: In **Python**, when working with data, it’s common to come across missing or
    null values denoted by the None type. However, when dealing with typed lists like
    those found in the Python pandas series object, we must handle these missing values
    differently. In such scenarios, [**Pandas**](https://pandas.pydata.org/getting_started.html)
    automatically transforms the list into an object-type array and inserts a placeholder
    value of `**None**`.
  prefs: []
  type: TYPE_NORMAL
- en: To better understand this concept, let us consider a scenario where we have
    a list of seasons, but one season is without a name; for which we can use `**None**`
    as our representation of missing information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When creating strings within **Pandas** containing at least one instance of
    `**None**`, the resulting series will be converted into an object-type array while
    inserting `**None**` as its designated substitute value, thereby maintaining consistency
    among other elements’ datatype throughout your dataset.
  prefs: []
  type: TYPE_NORMAL
- en: The following example showcases how **Pandas** handles **null values** in a
    list of integer numbers. In such a case, **Pandas** will convert the data type
    to a floating point number and produces a `**NaN**` value. This functionality
    proves beneficial as it ensures uniformity when representing missing information
    across all data types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It is crucial to acknowledge that `**NaN**` constitutes a legitimate floating
    point number and conforms with the [**IEEE-754 standards**](https://en.wikipedia.org/wiki/IEEE_754).
    As such, it can be utilized in mathematical computations and comparisons without
    triggering errors.
  prefs: []
  type: TYPE_NORMAL
- en: In **Rust**, however, `**None**` values are transformed into `**Null**` when
    dealing with integers. Although this may seem like an insignificant variation
    at first glance, its ramifications could prove substantial while handling large
    datasets or conducting complex analysis while maintaining the data type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned, and upon closer inspection of the process of creating a Series
    object in **Rust Polars**, several noticeable differences exist compared to **Python
    Pandas**. Firstly, the representation of missing data in Rust Polars is accomplished
    by using the null value instead of the **NaN** value in **Python Pandas**. Secondly,
    **Rust Polars** sets the data type of the Series to **32-bit integer numbers**
    instead of automatically converting it to a **floating-point number** as in **Python
    Pandas**. This difference in behaviour can be attributed to Rust’s explicit typing
    system, which implicitly assign the data type. As a result, assigning the dtype
    to `**int**` is appropriate because 1 and 2 are integers. On the other hand, in
    **Python pandas**, missing data is represented by converting the **None** value
    to **NaN**, a **floating-point number**, and **integers** can be **cast** to **float**.
  prefs: []
  type: TYPE_NORMAL
- en: It is crucial to highlight the difference between the representations of **None**
    and **NaN** in scientific computing with **Rust**. Although data scientists may
    use them interchangeably to denote missing data, they are not represented similarly
    beneath the surface. One critical point to note is that **NaN** is not equivalent
    to **None**, and an equality test between them will always result in **False**.
  prefs: []
  type: TYPE_NORMAL
- en: In Rust, **NaN** cannot be compared to itself. Hence, attempting to do so will
    yield a **False** result. This underscores the fact that **NaN** is not equivalent
    to any value, including itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As a result, when performing operations on data that includes `**NaN**` values,
    it is essential to handle them appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: It is essential to note that **Rust Polars** counts null values as zero and
    dropping them will not eliminate them. This occurs because the null value in **Rust
    Polars** differs from `**NaN**`, representing missing data with a distinct value.
    Therefore, comprehending how missing information appears in your dataset is crucial
    for the precise analysis and manipulation of your data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It is undoubtedly possible to convert the elements of a series from one data
    type to another. For instance, consider our previous example and its conversion
    into integer values. The code snippet below effectively demonstrates this conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `[**cast**](https://docs.rs/polars/latest/polars/prelude/struct.Series.html#method.cast)`
    function is employed to transform the initial `**s**` series into a new **64-bit
    integer** type sequence. The return value can be displayed using `**println!**`
    macro, but it’s worth mentioning that `**NaN**` value will become null after conversion.
  prefs: []
  type: TYPE_NORMAL
- en: It is crucial to keep in mind that converting a series from one data type to
    another can lead to the loss or modification of certain values. For instance,
    if you cast a **floating point series** into an **integer** **series**, all decimal
    points will be **truncated**. Additionally, trying to convert **non-numeric**
    data within a series into **numeric** types will result in errors. Hence, it’s
    imperative that you weigh up the consequences of any potential conversions before
    executing them thoroughly and with caution.
  prefs: []
  type: TYPE_NORMAL
- en: Series Creation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/edfb5affe1f7c53c8fb4283743cdbaa1.png)'
  prefs: []
  type: TYPE_IMG
- en: series object (image by author)
  prefs: []
  type: TYPE_NORMAL
- en: This section centers around creating a series of data using Polars. **AFAIK**,
    Polars provides **four distinct methods** to create a series, each catering to
    specific needs. The primary reason for creating a series is to work with **labeled**
    **data**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial approach entails creating an array from scratch by utilizing the
    `[**new_empty**](https://docs.rs/polars/latest/polars/prelude/struct.Series.html#method.new_empty)`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: A second technique for generating a Series is available by **utilising an array
    of data**. This process involves constructing the Series straight from the given
    collection and determining its resulting data type based on the values contained
    within it. If its values are strings, `**str**` will be designated as the resultant
    data type for that particular Series instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The output indicates that due to the string data type, Polars has designated
    `**str**` as the series’ data type. After creating the series, we can retrieve
    its name object using the name function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You can create a Series using the vector approach as well. By utilizing the
    `[**vec!**](https://doc.rust-lang.org/std/macro.vec.html)` macro, we can create
    a vector and obtain a corresponding Series with an identical data type to the
    original vector. This technique proves helpful when one already possesses data
    in the form of vectors, allowing for easy conversion into a Series format.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The output of this operation is the same as the previous method.
  prefs: []
  type: TYPE_NORMAL
- en: By utilizing a chunked type like `[**UInt32Chunked**](https://docs.rs/polars/latest/polars/prelude/type.UInt32Chunked.html)`,
    the fourth approach to creating a Series can be implemented. This technique is
    especially advantageous when working with extensive datasets, enabling you to
    create a Series from such data types. Upon conversion of the chunked type into
    a Series, its resulting data format will remain identical to the original one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The output of this operation displays the data elements of the series as expected.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, this section highlights four techniques for creating a data series
    using **Polars**. These techniques include creating a series straight from an
    array of data, utilizing the `**vec!**` macro for vector creation, and utilizing
    chunked types like `**UInt32Chunked**` to produce sequences. The usefulness of
    each method depends on the nature and structure of your data set. Hence, we can
    leverage these methods when working with Series in Polars.
  prefs: []
  type: TYPE_NORMAL
- en: Datetime Type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `[**chrono**](https://docs.rs/chrono/latest/chrono/)` crate in Rust is a
    robust resource for managing dates and times. With its offering, we can effortlessly
    create **DateTime** data fields that are applicable to various use cases. The
    given code snippet demonstrates how the created **DateTime** data fields can be
    integrated into a Series for additional manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Utilizing the `[**with_ymd_and_hms**](https://docs.rs/chrono/latest/chrono/offset/trait.TimeZone.html#method.with_ymd_and_hms)`
    function in this code snippet empowers us to create a **DateTime** object that
    meets our requirements for year, month, day, hour, minute, and second values.
    This function returns the Result type, which can be easily unwrapped to obtain
    the **DateTime** object. This resultant **DateTime** object serves as an input
    parameter while creating another Series by employing the Series::new method featuring
    only one data point.
  prefs: []
  type: TYPE_NORMAL
- en: By calling the `[**date_naive**](https://docs.rs/chrono/latest/chrono/struct.DateTime.html#method.date_naive)`
    function on the **DateTime** object, we can create a Series with the data type
    of date. This nifty function extracts relevant information from a given object
    and converts it into **NaiveDate** format. To observe this resulting Series in
    all its glory — shape, name, data type, and points included — simply utilize `**println!**`
    macro.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, the **Chrono** package is a valuable tool for creating adaptable
    **DateTime** data that is easily integrated within any given series to facilitate
    further analysis or manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing & Slicing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/107e202c024059b5048def4d3d1153f3.png)'
  prefs: []
  type: TYPE_IMG
- en: series get and slice methods (image by author)
  prefs: []
  type: TYPE_NORMAL
- en: So far, you have seen operations that let you create objects like **Series**
    from **predefined** **data**. Once a data object such as a series has been initialized,
    extracting relevant data from that object using some of the intuitive functionalities
    **Polars** provides is possible. One such functionality is **indexing**.
  prefs: []
  type: TYPE_NORMAL
- en: The process of **indexing** or **subsetting** is a widely employed technique
    in data analysis to extract specific segments from a series. This approach enables
    precise manipulation and examination of data, which proves crucial for comprehending
    complex datasets. Rust’s `[**Series**](https://docs.rs/polars/latest/polars/prelude/struct.Series.html#)`
    struct offers numerous indexing approaches that can be utilized to retrieve specific
    elements from the series.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The code snippet showcased illustrates the efficient utilization of the get
    method to index a particular value from a series. This function retrieves and
    returns its corresponding data point within the series by providing an index value
    as input. In our example, we extract and display the first element (index 0) via
    `**println!**` macro usage.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to indexing individual values, using slicing, we can extract a subset
    of data from a series by specifying an offset and length. This method allows for
    the efficient extraction of large datasets as it returns a zero-copy view. The
    offset parameter determines the starting index, while the number of values to
    be extracted is specified using the length parameter. In our code snippet example,
    we use slice to retrieve only one value — specifically, the first element in our
    series with an offset set at 0 and extracting just one value (length=1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Length
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/c510311c23cf4ac33f7bd240092e4b1c.png)'
  prefs: []
  type: TYPE_IMG
- en: series len method (image by author)
  prefs: []
  type: TYPE_NORMAL
- en: In data analysis, it’s frequently imperative to determine the number of elements
    within a sequence. Fortunately, an effortless and effective method exists — the
    `[**len**](https://docs.rs/polars/latest/polars/prelude/trait.SeriesTrait.html#tymethod.len)`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax for using this method is typically straightforward, usually appearing
    as `**fn len(&self) -> usize**` . Once called on your desired series, this function
    will return an integer value representing its total elements count.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Reverse
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/4a66986c691a8c1578ce61d71e1aa25b.png)'
  prefs: []
  type: TYPE_IMG
- en: series reverse method (image by author)
  prefs: []
  type: TYPE_NORMAL
- en: The `[**reverse**](https://docs.rs/polars/latest/polars/prelude/trait.SeriesTrait.html#tymethod.reverse)`
    function is a powerful method that can help you manipulate data in specific ways.
    You can utilize this method If you’ve ever needed to change the order of elements
    within a series.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax for this method is typically straightforward — invoke the function
    on a series object. Once called on your original series, it will create a new
    one identical but flipped around.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Empty Check
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `[**is_empty**](https://docs.rs/polars/latest/polars/prelude/trait.SeriesTrait.html#method.is_empty)`
    method is a method that can be called on a Polars Series object. It returns a
    boolean value indicating whether the Series is empty or not. If the Series is
    empty, it returns True; otherwise, it returns False.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Drop Nulls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/ce24d473de70d541d320239c6b8b25d4.png)'
  prefs: []
  type: TYPE_IMG
- en: Series drop_nulls function visualized (Image by author)
  prefs: []
  type: TYPE_NORMAL
- en: The analysis of data involves a critical aspect, which is handling missing information.
    Polars’ `[**drop_nulls**](https://docs.rs/polars/latest/polars/prelude/trait.SeriesTrait.html#method.drop_nulls)`
    method offers an efficient solution to this issue. This function helps remove
    rows from the Series that contain null values and helps eliminate disparities
    caused by incomplete datasets effectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Summarization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a data analyst or scientist, you probably deal with large datasets regularly.
    Two of the most powerful methods for querying data in Polars are Head and Tail.
    The `[**head**](https://docs.rs/polars/latest/polars/series/struct.Series.html#method.head)`
    method is a helpful tool for quickly previewing the initial rows of your dataset.
    It displays the first ten rows by default but can be customized to show more or
    fewer by passing an argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, the `[**tail**](https://docs.rs/polars/latest/polars/series/struct.Series.html#method.tail)`
    method allows you to examine trends and patterns in data toward its end. It also
    defaults to displaying the ten last rows but can also be adjusted with arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Append
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/e87bf9af623aea3e586c508b41f520f2.png)'
  prefs: []
  type: TYPE_IMG
- en: Series append function visualized (Image by author)
  prefs: []
  type: TYPE_NORMAL
- en: By utilizing the `[**append**](https://docs.rs/polars/latest/polars/series/struct.Series.html#method.append)`
    method, you can merge two different series. This function combines chunks of one
    series with another, and it should be noted that both must possess identical data
    types. It is essential to keep in mind that for this process to occur successfully,
    it requires a mutable caller capable of modifying a given series.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Cast
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/802a79c3ab543dd484c5a8649f2f1397.png)'
  prefs: []
  type: TYPE_IMG
- en: Series cast function visualized (Image by author)
  prefs: []
  type: TYPE_NORMAL
- en: The act of **casting** is an important technique that transforms one data type
    into another. In **Polars**, this method proves particularly useful when altering
    column data type within a **Se**ries. For instance, you may need to change a column’s
    string values into integers or floats instead. Luckily enough, with `[**cast**](https://docs.rs/polars/latest/polars/series/struct.Series.html#method.cast)`
    methods, such conversions become effortless.
  prefs: []
  type: TYPE_NORMAL
- en: Using the cast function effectively entails selecting which columns require
    conversion first and foremostly before proceeding further by invoking the method
    whilst passing through desired target datatype as an argument — **Float32** for
    floating point numbers-based transformations being just one example among many
    other available options.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: It is important to keep in mind that certain forms may encounter errors during
    transformation due to the presence of non-numeric characters, which are incompatible
    with both float and int formats. In such cases, it would be important to ensure
    relevant datasets undergo a thorough cleanup beforehand so they can be more effectively
    cast for future use without any issues arising.
  prefs: []
  type: TYPE_NORMAL
- en: Fill Nulls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a data analyst or scientist, you’re no stranger to the challenge of dealing
    with **null values**. Fortunately, **Polars** offers an exceptional solution for
    handling **missing information** in your datasets. With its `[**fill_null**](https://docs.rs/polars/latest/polars/series/struct.Series.html#method.fill_null)`
    method, you can easily replace those nulls with specific values that make sense
    for your analysis. This function gives you [**nine different strategies**](https://docs.rs/polars/latest/polars/prelude/enum.FillNullStrategy.html)
    to choose from when replacing nulls:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Forward Fill** (replace **None** with the **previous** value):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/82b0f038e440e9de2ec49f35329e47d4.png)'
  prefs: []
  type: TYPE_IMG
- en: series forward fill strategy (image by author)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '**Backward Fill** (replace **None** with the **next** value):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/07715eab280f9741cee8bcfd8192b165.png)'
  prefs: []
  type: TYPE_IMG
- en: series backward fill strategy (image by author)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '**Mean Fill** (replace **None** with the **mean** of the whole array):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/46607c1981fe60dc45abcce0f08b7035.png)'
  prefs: []
  type: TYPE_IMG
- en: series mean fill strategy (image by author)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '**Min Fill** (replace **None** with the **minimum** of the whole array):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/3bd2ffd3a142a27aa934e32cee391169.png)'
  prefs: []
  type: TYPE_IMG
- en: series min fill strategy (image by author)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '**Max Fill** (replace **None** with the **maximum** of the whole array):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/42217122b301e0030586a1df0268ce51.png)'
  prefs: []
  type: TYPE_IMG
- en: series max fill strategy (image by author)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Sampling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/6f8c89e9f258368674147813ba1c6d6e.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Testalize.me](https://unsplash.com/@testalizeme?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Before diving into any analysis, it’s crucial to remember that our **sample**
    must be **random** and **representative**. This means we need **unbiased data**
    collection methods (e.g., not just asking fans of a certain sports team if they
    like the team). Ideally, members from **all distinct groups** within the **population**
    should be included in our **sample**.
  prefs: []
  type: TYPE_NORMAL
- en: Different sampling methods may be necessary to achieve this, depending on the
    **data type** at hand. A simple **random sample** is often best for general cases
    where no distinct groupings are present; here, we use a random number generator
    to **select rows randomly**. However, random sampling should be employed for datasets
    with clear subgroups, as it preserves each subgroup’s proportionality within the
    overall dataset.
  prefs: []
  type: TYPE_NORMAL
- en: In situations where sufficient amounts of relevant data aren’t available through
    these traditional techniques alone, such as when dealing with small or imbalanced
    samples, [**bootstrapping**](https://en.wikipedia.org/wiki/Bootstrapping_(statistics))
    can provide an alternative solution by generating additional randomized subsets
    using replacement selection strategies until desired levels have been reached
    without introducing bias into estimators due to convenience-based selections made
    during initial rounds which could skew results towards more prevalent values found
    early-on rather than accurately representing actual populations over time!
  prefs: []
  type: TYPE_NORMAL
- en: To sample a portion of a Polars series object, we can use the `[**sample_n**](https://docs.rs/polars/latest/polars/series/struct.Series.html#method.sample_n)`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Descriptive Statistics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/479132a5255f39e0cc303f997be8db4f.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Stephen Dawson](https://unsplash.com/@dawson2406?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: The importance of **descriptive statistics** in data analysis cannot be overstated,
    as it enables researchers to understand the data they have gathered. **Univariate
    statistics** is an integral component within this field, allowing **individual**
    **variables** to be analyzed and assessed independently. By utilizing statistical
    measures such as **mean**, **mode**, **median**, and **standard deviation** on
    each **variable** separately, we can uncover **valuable insights** into the distribution
    patterns present within our dataset.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if presented with **100 observations** detailing speed and distance
    pairs, **univariate stats** would enable us to calculate both **average** speeds
    & distances individually so that any **correlation** or **independence** between
    them could become apparent. Furthermore, by identifying **outliers** through these
    calculations, we can **minimize** their impact on overall results during further
    analyses undertaken later down the line!
  prefs: []
  type: TYPE_NORMAL
- en: The initial step towards analyzing data is determining its **central tendency**,
    which can be assessed through the mean, median, or mode. This measure helps understand
    where most data points are situated and serve as a reference point for comparison
    purposes. Additionally, it’s crucial to identify **how far apart values** lie
    from each other by determining their **spread** or **dispersion** using **range**,
    **variance**, or **standard deviation** measures. Such an analysis provides valuable
    insights into the variability present within your dataset.
  prefs: []
  type: TYPE_NORMAL
- en: As a researcher/analyst, descriptive statistics provide powerful tools that
    enable **comprehensive** **overviewing** of datasets leading to informed decision-making
    based on findings obtained during statistical analyses.
  prefs: []
  type: TYPE_NORMAL
- en: Measures of Central Tendency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/130b02dbc258924711b90447b9131d4c.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Stephen Phillips - Hostreviews.co.uk](https://unsplash.com/@hostreviews?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: In any statistical analysis, it is crucial to focus on the **center** of our
    data. **Descriptive statistics** offer us tools that help us comprehend the distribution
    and measures of **central tendency** for a better understanding. The most common
    ones are **mean**, **median**, and **mode**, each with its own advantages depending
    on dataset characteristics such as **normality** or **skewness**.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that these measures only provide an **overview** rather
    than complete insight into variability or distribution. Therefore we must also
    include other descriptive stats like **dispersion** **measurements** to gain a
    more comprehensive perspective on our data set.
  prefs: []
  type: TYPE_NORMAL
- en: Mean
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **mean** is a commonly used statistical function to **summarize data** in
    an easily interpretable way. It gives us insight into the **central tendency**
    of our dataset, whether it be for an entire population or just **a sample of observations**.
    The symbol **μ**(pronounced “**mu**”) represents the population means, while **𝑥𝑥̅**
    signifies the sample average. In mathematical terms, the formula for the mean
    is **Σxi/n**. Here, **Σ** (the Greek capital letter sigma) represents a summation
    from **1 to n**, where **n** is the number of observations. The variable as a
    whole is represented with a capital letter, while the specific observation is
    lowercase. Calculating this value involves **adding up all values and dividing
    by their total number**, simple as that! For example, if we have numbers **0,
    4, 3, 2, and 5**, their **sum** (**14**) divided by **five** equals approximately
    two point eight (**2.8**).
  prefs: []
  type: TYPE_NORMAL
- en: However, it’s imperative to recognize that **outliers** can significantly impact
    the accuracy of this measure. As you may know, outliers are values generated by
    an entirely **different process** than those in the rest of the distribution and
    have the potential to **skew** results significantly; for example, one value much
    larger or smaller than others may pull up or down on average, respectively rendering
    it an inaccurate representation dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, being aware of the presence of outliers is crucial when analyzing data.
    [**As discussed in a previous article**](/17-clustering-algorithms-used-in-data-science-mining-49dbfa5bf69a),
    one alternative method accounting for them involves using a median instead measuring
    central tendency because less sensitive towards such anomalies while still representing
    the middle points within set numbers accurately, even amidst their influence upon
    the overall result.
  prefs: []
  type: TYPE_NORMAL
- en: When working with data sets in Polars, it’s not uncommon to encounter missing
    or null values. In such cases, the `[**mean**](https://docs.rs/polars/latest/polars/prelude/trait.SeriesTrait.html#method.mean)`
    function can prove quite helpful. However, since there may be absent entries within
    the set of figures being analyzed, this particular function returns an optional
    value whose type is denoted by `**Option<f64>**`. Essentially, that means that
    the returned value could potentially be a null value and thus requires careful
    handling on the part of its user.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: It should also be noted that when calculating averages using this method, only
    **non-null** values are taken into account; if **ten** numbers are present in
    your dataset, but two happen to have been omitted for some reason, then only eight
    will factor into any resulting calculations made via the use of the `**mean**`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Median
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When analyzing data, selecting the appropriate measure of central tendency is
    essential. The **mean** is frequently favored since it considers all data points
    and provides a reasonable approximation of the **average**. However, **outliers**
    can easily influence the mean’s accuracy and **distort** overall findings. This
    is where using the **median** becomes crucial.
  prefs: []
  type: TYPE_NORMAL
- en: The **median** is a powerful function in statistics that accurately represents
    the central tendency of data, even when outliers are present. Selecting the **middle
    value** from an **ordered list** of data points provides a precise and reliable
    measure for analysis. Taking the average between two middle values ensures accuracy
    in cases with an even number of values. This makes it particularly useful for
    datasets with extreme or skewed values, such as [**income distribution in America**](https://www.statista.com/statistics/203183/percentage-distribution-of-household-income-in-the-us/).
    The **top 11.6%** of earners have significantly higher incomes than most Americans,
    which can distort the mean value.
  prefs: []
  type: TYPE_NORMAL
- en: However, by using **median** calculations, we get more accurate results because
    they represent what separates **half** **(50%)** high-earners from low-income
    individuals on either side, providing us with valuable insights into real-world
    economic trends without being influenced by statistical anomalies caused by extremely
    wealthy people’s earnings alone!
  prefs: []
  type: TYPE_NORMAL
- en: '**Polars** offers [this function](https://docs.rs/polars/latest/polars/prelude/trait.SeriesTrait.html#method.median)
    to both **DataFrame** and **Series** objects with ease. Let’s consider the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **mode** is a fundamental statistical concept that plays an important role
    in data analysis. It represents the most frequently occurring value within a data
    set and can **unveil patterns and trends**, especially when dealing with **vast
    or complicated datasets**. In cases where two modes are present, such as **bimodal**
    **distributions**, it may indicate distinct subgroups within the dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Although seemingly simple to comprehend at first glance, understanding how the
    mode fits into broader analytical frameworks alongside measures like mean and
    the median is crucial for drawing accurate conclusions from your findings.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding **categorical data**, the **mode** reigns supreme as the go-to measure
    of central tendency. This powerful tool represents the value that appears most
    frequently in a dataset and is ideal for pinpointing common categories or responses
    within your data set. For instance, when analyzing **survey results**, this method
    can help identify which response participants chose with **greater frequency**.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, **numerical datasets** require different measures, such as
    **mean** or **median** values, to determine their central tendencies accurately.
    The **average** value of a given dataset is represented by its mean. At the same
    time, its **middle point** corresponds to its **median**, both commonly used methods
    for identifying trends in these types of datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Although not typically utilized during analysis involving continuous sets due
    to differences between them and c**ategorical ones**; however, it still holds
    relevance since it helps describe **recurring patterns** found among **similar
    variables** present throughout any particular study’s findings!
  prefs: []
  type: TYPE_NORMAL
- en: '**Polars** offer a powerful method called the `[**mode**](https://docs.rs/polars/latest/polars/prelude/trait.SeriesTrait.html#method.mode)`
    function that can help achieve this goal. Although only available on `**mode**`
    crate features, when accessible, it provides valuable insights into a data set.
    The `**mode**` function returns a result value usually presented as a Series containing
    the most common elements within the dataset.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: To effectively analyze our data, it is essential to comprehend the strengths
    of each measure. This knowledge will enable us to make informed decisions about
    measuring central tendency based on specific requirements in unique situations.
    The accurate and efficient analysis depends on this understanding.
  prefs: []
  type: TYPE_NORMAL
- en: Measures of Spread
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0d4b7c074818d57a17f1a4fae87ed608.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Martin Sanchez](https://unsplash.com/@martinsanchez?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: When analyzing data, simply knowing the **central point of distribution** won’t
    cut it. It’s equally essential to comprehend how **widely** **dispersed** that
    data is. This is where measures of spread come into play; they help us **gauge**
    just how far apart values are from one another and summarize our findings more
    effectively overall. **The wider the dispersion, the broader your range**; conversely,
    **a narrower distribution will yield tighter results**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can describe this kind of spread in various ways in statistical terms: for
    instance, through **interquartile ranges** or **standard deviations** (each with
    its pros and cons). Knowing which measure best suits each situation depends on
    the context and available information; if you’re dealing with extreme outlier
    values, the range might be most helpful, whereas normally distributed datasets
    may benefit more from using standard deviation as an indicator.'
  prefs: []
  type: TYPE_NORMAL
- en: Interquartile Range
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/b03f54329f6c4a94e5b14dd65a2537ed.png)'
  prefs: []
  type: TYPE_IMG
- en: a box plot (image by author)
  prefs: []
  type: TYPE_NORMAL
- en: The `[**quantile_as_series**](https://docs.rs/polars/latest/polars/prelude/trait.SeriesTrait.html#method.quantile_as_series)`function
    is a powerful tool for calculating statistical measures, with one of the most
    important being the **interquartile range** (**IQR**). This measure represents
    the middle **50**% of data variability and is determined by subtracting **Q1 from
    Q3**. Essentially, **IQR** shows **how widely distributed** data points are around
    their **median** value. **IQR** is used to identify potential outliers, as any
    data point falling **outside** the **Q1–1.5 × IQR and Q3 + 1.5 × IQR** is considered
    an **outlier**.
  prefs: []
  type: TYPE_NORMAL
- en: In Polars, the `[**quantile_as_series**](https://docs.rs/polars/latest/polars/prelude/trait.SeriesTrait.html#method.quantile_as_series)`
    method can be used to obtain the quartiles of a `**ChunkedArray**` as a new series
    of length 1\. By specifying the quantile argument, like **0.25** or **0.75**,
    we can get **Q1** and **Q3**, respectively. The interpolation argument can be
    set to **Nearest**, for instance, to specify how to calculate the quantile when
    the value is not exact.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '**Box plots** often use this metric to visualize potential **outliers** in
    datasets while accurately representing their distribution. For researchers and
    scientists looking to make informed decisions based on sound statistics rather
    than guesswork alone, using quantiles as series calculations will provide them
    with more comprehensive insights into their research findings’ underlying trends
    beyond just standard deviation ranges or simple min-max comparisons.'
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this section, our attention was drawn to one of the most fundamental
    data types offered by the Polars library — **the Series**. You have been enlightened
    on the art of Series creation, indexing, and more where the powerful **get** and
    **slice** operations have been unlocked for your use, in addition to gaining the
    know-how on Series creation.
  prefs: []
  type: TYPE_NORMAL
- en: Granted, **Series** presents an excellent solution for **one-dimensional data**
    management, but the real challenge emerges with multi-dimensional data. That’s
    where **DataFrames** come in handy. In Part 2, we will briefly explain **DataFrames**
    — the go-to multi-dimensional data structure wielded to great effect across numerous
    domains.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/7cde1be2f7dd1a7aee2afb38359a3d48.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Saurav Mahto](https://unsplash.com/@sauravmahto?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: This article has familiarized you with a fundamental data structure in Polars
    — Series. Additionally, we have explored basic concepts of querying and modifying
    series in Polars. As a result, this should give you ample confidence when working
    with Series going forward. It will be an integral component throughout the rest
    of this series of articles. In particular, our next focus is learning about Polars’s
    data frames, and how Polars facilitates efficient data input/output operations
    crucial for any successful analysis project!
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout this article, we have covered the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the world of Polars.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the history and evolution of Polars.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components and applications of Polars.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the basic concepts of Polars such as Series.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And much more. As we progress through the upcoming articles, your knowledge
    of Polars will expand to encompass more advanced features and techniques. In part
    2 specifically, we will delve into the powerful world of DataFrames! These powerful
    structures are used in a wide range of fields to manage and analyze multi-dimensional
    data with ease. We’ll provide a clear and concise explanation of what DataFrames
    are, aggregation functions, and much more. By mastering this library, you’ll gain
    rock-solid and valuable skills that empower you to easily tackle complex data
    analysis tasks while handling massive datasets effortlessly.
  prefs: []
  type: TYPE_NORMAL
- en: Closing Note
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/c732ae653e11e63222cc5fd9bc49b0e4.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Aaron Burden](https://unsplash.com/@aaronburden?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: As we conclude this tutorial, I would like to express my sincere appreciation
    to all those who have dedicated their time and energy to completing it. It has
    been an absolute pleasure to demonstrate the extraordinary capabilities of Rust
    programming language with you.
  prefs: []
  type: TYPE_NORMAL
- en: As always, being passionate about data science, I promise you that I will keep
    writing at least one comprehensive article every week or so on related topics
    from now on. If staying updated with my work interests you, consider connecting
    with me on various social media platforms or reach out directly if anything else
    needs assistance.
  prefs: []
  type: TYPE_NORMAL
- en: Thank You!
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://github.com/wiseaidev/rust-data-analysis?source=post_page-----ce42af370ece--------------------------------)
    [## GitHub - wiseaidev/rust-data-analysis: The ultimate data analysis with Rust
    course.'
  prefs: []
  type: TYPE_NORMAL
- en: This repository is a collection of Jupyter notebooks, all powered by a Rust
    kernel. With these notebooks, you'll be…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: github.com](https://github.com/wiseaidev/rust-data-analysis?source=post_page-----ce42af370ece--------------------------------)  [##
    SeriesTrait in polars::prelude - Rust
  prefs: []
  type: TYPE_NORMAL
- en: API documentation for the Rust `SeriesTrait` trait in crate `polars`.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: docs.rs](https://docs.rs/polars/latest/polars/prelude/trait.SeriesTrait.html?source=post_page-----ce42af370ece--------------------------------)  [##
    Series in polars::series - Rust
  prefs: []
  type: TYPE_NORMAL
- en: Series
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: in polars::series - Rust Seriesdocs.rs](https://docs.rs/polars/latest/polars/series/struct.Series.html?source=post_page-----ce42af370ece--------------------------------)  [##
    DateTime in chrono - Rust
  prefs: []
  type: TYPE_NORMAL
- en: pub struct DateTime { /* private fields */ } Expand description ISO 8601 combined
    date and time with time zone. There…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: docs.rs](https://docs.rs/chrono/latest/chrono/struct.DateTime.html?source=post_page-----ce42af370ece--------------------------------#)
    [](https://doc.rust-lang.org/std/index.html?source=post_page-----ce42af370ece--------------------------------)
    [## std - Rust
  prefs: []
  type: TYPE_NORMAL
- en: The Rust Standard Library is the foundation of portable Rust software, a set
    of minimal and battle-tested shared…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: doc.rust-lang.org](https://doc.rust-lang.org/std/index.html?source=post_page-----ce42af370ece--------------------------------)  [##
    Rust By Example
  prefs: []
  type: TYPE_NORMAL
- en: Rust is a modern systems programming language focusing on safety, speed, and
    concurrency. It accomplishes these goals…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: doc.rust-lang.org](https://doc.rust-lang.org/rust-by-example/?source=post_page-----ce42af370ece--------------------------------)  [##
    The Rust Programming Language
  prefs: []
  type: TYPE_NORMAL
- en: by Steve Klabnik and Carol Nichols, with contributions from the Rust Community
    This version of the text assumes you're…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: doc.rust-lang.org](https://doc.rust-lang.org/book/?source=post_page-----ce42af370ece--------------------------------)
  prefs: []
  type: TYPE_NORMAL
