- en: Hacking MySQLâ€™s JSON_ARRAYAGG Function to Create Dynamic, Multi-Value Dimensions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: åŸæ–‡ï¼š[https://towardsdatascience.com/hacking-mysqls-json-arrayagg-function-to-create-dynamic-multi-value-dimensions-211074115d28?source=collection_archive---------9-----------------------#2023-07-25](https://towardsdatascience.com/hacking-mysqls-json-arrayagg-function-to-create-dynamic-multi-value-dimensions-211074115d28?source=collection_archive---------9-----------------------#2023-07-25)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Making up for one of MySQLâ€™s lesser-known shortcomings
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@dakotasmithdata?source=post_page-----211074115d28--------------------------------)[![Dakota
    Smith](../Images/df345239ca070910365d2b6c7fb3e5e7.png)](https://medium.com/@dakotasmithdata?source=post_page-----211074115d28--------------------------------)[](https://towardsdatascience.com/?source=post_page-----211074115d28--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----211074115d28--------------------------------)
    [Dakota Smith](https://medium.com/@dakotasmithdata?source=post_page-----211074115d28--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Â·
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fdcadf2cebe12&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhacking-mysqls-json-arrayagg-function-to-create-dynamic-multi-value-dimensions-211074115d28&user=Dakota+Smith&userId=dcadf2cebe12&source=post_page-dcadf2cebe12----211074115d28---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----211074115d28--------------------------------)
    Â·9 min readÂ·Jul 25, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F211074115d28&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhacking-mysqls-json-arrayagg-function-to-create-dynamic-multi-value-dimensions-211074115d28&user=Dakota+Smith&userId=dcadf2cebe12&source=-----211074115d28---------------------clap_footer-----------)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F211074115d28&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhacking-mysqls-json-arrayagg-function-to-create-dynamic-multi-value-dimensions-211074115d28&source=-----211074115d28---------------------bookmark_footer-----------)![](../Images/fe765b373fc96e7eb057ae81d622a993.png)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Photo by [Azamat E](https://unsplash.com/fr/@esen_aza?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral). Thanks,
    Azamat!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Letâ€™s imagine that weâ€™re members on the Data team at a subscription box company.
    In a MySQL database, transaction records of purchases are written to table named
    `subscriptions`. Metadata excluded, the table contains a `customer_id` and `subscription`
    field, and looks something like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å‡è®¾æˆ‘ä»¬æ˜¯ä¸€ä¸ªè®¢é˜…ç›’å­å…¬å¸çš„æ•°æ®å›¢é˜Ÿæˆå‘˜ã€‚åœ¨ MySQL æ•°æ®åº“ä¸­ï¼Œè´­ä¹°çš„äº‹åŠ¡è®°å½•è¢«å†™å…¥åä¸º `subscriptions` çš„è¡¨ä¸­ã€‚é™¤äº†å…ƒæ•°æ®ä¹‹å¤–ï¼Œè¯¥è¡¨åŒ…å«ä¸€ä¸ª
    `customer_id` å’Œ `subscription` å­—æ®µï¼Œç±»ä¼¼äºè¿™æ ·ï¼š
- en: '![](../Images/8c82c2a747ec45b2f33645f1c8853035.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8c82c2a747ec45b2f33645f1c8853035.png)'
- en: 'The subscriptions table. (Note: All images, unless otherwise noted, are by
    the author)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: è®¢é˜…è¡¨ã€‚ï¼ˆæ³¨æ„ï¼šæ‰€æœ‰å›¾åƒï¼Œé™¤éå¦æœ‰è¯´æ˜ï¼Œå‡ç”±ä½œè€…æä¾›ï¼‰
- en: '*Note that in this example scenario, a customer can have multiple subscriptions.
    The uniqueness of each record is in defined by both the customer ID and a subscription,
    i.e., no customer can have the same subscription twice. If you want to load this
    test data into your own database, you can find the code to do so* [*here*](https://github.com/dakotaleesmith/pyProjects/blob/main/tutorials/mysql_json_arrayagg_tutorial/create_table.sql)*.*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*è¯·æ³¨æ„ï¼Œåœ¨è¿™ä¸ªç¤ºä¾‹åœºæ™¯ä¸­ï¼Œä¸€ä¸ªå®¢æˆ·å¯ä»¥æœ‰å¤šä¸ªè®¢é˜…ã€‚æ¯æ¡è®°å½•çš„å”¯ä¸€æ€§ç”±å®¢æˆ· ID å’Œè®¢é˜…å…±åŒå®šä¹‰ï¼Œå³æ²¡æœ‰å®¢æˆ·å¯ä»¥æ‹¥æœ‰ç›¸åŒçš„è®¢é˜…ä¸¤æ¬¡ã€‚å¦‚æœä½ æƒ³å°†è¿™äº›æµ‹è¯•æ•°æ®åŠ è½½åˆ°è‡ªå·±çš„æ•°æ®åº“ä¸­ï¼Œä½ å¯ä»¥åœ¨*
    [*è¿™é‡Œ*](https://github.com/dakotaleesmith/pyProjects/blob/main/tutorials/mysql_json_arrayagg_tutorial/create_table.sql)*æ‰¾åˆ°ç›¸åº”çš„ä»£ç ã€‚*'
- en: As a subscription box company, our goal is to sell more subscription boxes.
    To that end, the Product team recently pointed out that all of our current customers
    have more than one subscription. Theyâ€™re curious what this says about customer
    behavior. They ask our team for a data model showing combinations of subscriptions
    purchased by user, as well as which combinations are most common.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºä¸€ä¸ªè®¢é˜…ç›’å­å…¬å¸ï¼Œæˆ‘ä»¬çš„ç›®æ ‡æ˜¯é”€å”®æ›´å¤šçš„è®¢é˜…ç›’å­ã€‚ä¸ºæ­¤ï¼Œäº§å“å›¢é˜Ÿæœ€è¿‘æŒ‡å‡ºæˆ‘ä»¬å½“å‰çš„æ‰€æœ‰å®¢æˆ·éƒ½æ‹¥æœ‰ä¸æ­¢ä¸€ä¸ªè®¢é˜…ã€‚ä»–ä»¬å¯¹è¿™è¡¨æ˜çš„å®¢æˆ·è¡Œä¸ºæ„Ÿåˆ°å¥½å¥‡ã€‚ä»–ä»¬è¦æ±‚æˆ‘ä»¬çš„å›¢é˜Ÿæä¾›ä¸€ä¸ªæ•°æ®æ¨¡å‹ï¼Œå±•ç¤ºç”¨æˆ·è´­ä¹°çš„è®¢é˜…ç»„åˆï¼Œä»¥åŠå“ªäº›ç»„åˆæœ€ä¸ºå¸¸è§ã€‚
- en: The Marketing team has also showed interested in this model. They believe the
    results might be useful for marketing bundled product promotions, profiling customers,
    and targeting email campaigns. For these same reasons, theyâ€™re also asking to
    see the most common total *number* of subscriptions purchased by each customer.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: å¸‚åœºè¥é”€å›¢é˜Ÿå¯¹è¿™ä¸ªæ¨¡å‹ä¹Ÿè¡¨ç°å‡ºäº†å…´è¶£ã€‚ä»–ä»¬è®¤ä¸ºè¿™äº›ç»“æœå¯èƒ½å¯¹å¸‚åœºè¥é”€æ†ç»‘äº§å“ä¿ƒé”€ã€å®¢æˆ·ç”»åƒä»¥åŠå®šå‘ç”µå­é‚®ä»¶æ´»åŠ¨æœ‰ç”¨ã€‚å‡ºäºè¿™äº›ç›¸åŒçš„åŸå› ï¼Œä»–ä»¬è¿˜å¸Œæœ›æŸ¥çœ‹æ¯ä¸ªå®¢æˆ·è´­ä¹°çš„æœ€å¸¸è§*è®¢é˜…æ•°é‡*ã€‚
- en: In short, the requested data model hopes to answer some important questions
    thatâ€™ll ideally end in higher subscription box sales. The question is, how exactly
    should we execute it?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ç®€è€Œè¨€ä¹‹ï¼Œè¯·æ±‚çš„æ•°æ®æ¨¡å‹å¸Œæœ›å›ç­”ä¸€äº›é‡è¦çš„é—®é¢˜ï¼Œç†æƒ³æƒ…å†µä¸‹è¿™äº›é—®é¢˜å°†æœ€ç»ˆå¯¼è‡´æ›´é«˜çš„è®¢é˜…ç›’å­é”€å”®ã€‚é—®é¢˜æ˜¯ï¼Œæˆ‘ä»¬åº”è¯¥å¦‚ä½•å‡†ç¡®æ‰§è¡Œï¼Ÿ
- en: In this article, weâ€™re going to tackle a unique data modeling challenge by making
    up for one of MySQLâ€™s lesser-known shortcomings. Weâ€™re going to go over qualitative
    aggregation, the JSON data type, and how to force MySQL to order a list of values
    in a way that produces distinct, multi-value dimensions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬å°†è§£å†³ä¸€ä¸ªç‹¬ç‰¹çš„æ•°æ®å»ºæ¨¡æŒ‘æˆ˜ï¼Œä»¥å¼¥è¡¥ MySQL çš„ä¸€ä¸ªä¸å¤ªä¸ºäººæ‰€çŸ¥çš„ç¼ºé™·ã€‚æˆ‘ä»¬å°†è®¨è®ºå®šæ€§èšåˆã€JSON æ•°æ®ç±»å‹ï¼Œä»¥åŠå¦‚ä½•å¼ºåˆ¶ MySQL
    ä»¥ä¸€ç§äº§ç”Ÿç‹¬ç‰¹ã€å¤šå€¼ç»´åº¦çš„æ–¹å¼å¯¹å€¼è¿›è¡Œæ’åºã€‚
- en: Table of Contents
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[Aggregations as Dimensions](#0c85)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[èšåˆä½œä¸ºç»´åº¦](#0c85)'
- en: '[A brief overview of the JSON datatype in MySQL](#3a1b)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[MySQL ä¸­ JSON æ•°æ®ç±»å‹çš„ç®€è¦æ¦‚è¿°](#3a1b)'
- en: '[JSON_ARRAYAGG](#5b60)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[JSON_ARRAYAGG](#5b60)'
- en: '[Using ROW_NUMBER to force the ordering of values](#0793)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ä½¿ç”¨ ROW_NUMBER å¼ºåˆ¶å€¼çš„æ’åº](#0793)'
- en: '[To recap](#c0e9)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[å›é¡¾](#c0e9)'
- en: Aggregations as Dimensions
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: èšåˆä½œä¸ºç»´åº¦
- en: 'Conceptually, what we need to do is relatively simple: We need to bundle (group)
    our subscriptions by customer. Then we need to take a look at these bundles and
    see which are the most common and how many subscriptions are in them.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ä»æ¦‚å¿µä¸Šè®²ï¼Œæˆ‘ä»¬éœ€è¦åšçš„äº‹æƒ…ç›¸å¯¹ç®€å•ï¼šæˆ‘ä»¬éœ€è¦æŒ‰å®¢æˆ·å¯¹è®¢é˜…è¿›è¡Œæ†ç»‘ï¼ˆåˆ†ç»„ï¼‰ã€‚ç„¶åï¼Œæˆ‘ä»¬éœ€è¦æŸ¥çœ‹è¿™äº›æ†ç»‘ï¼Œçœ‹çœ‹å“ªäº›æœ€ä¸ºå¸¸è§ï¼Œä»¥åŠå®ƒä»¬åŒ…å«äº†å¤šå°‘è®¢é˜…ã€‚
- en: 'In data modeling terms, weâ€™re looking at some form of aggregation: specifically,
    aggregating subscriptions by customer.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ•°æ®å»ºæ¨¡æœ¯è¯­ä¸­ï¼Œæˆ‘ä»¬å…³æ³¨çš„æ˜¯æŸç§å½¢å¼çš„èšåˆï¼šå…·ä½“æ¥è¯´ï¼Œæ˜¯æŒ‰å®¢æˆ·å¯¹è®¢é˜…è¿›è¡Œèšåˆã€‚
- en: Itâ€™s normal to think of aggregate functions in the quantitative sense (`SUM`,
    `COUNT`, etc.), and this is largely because this is what most aggregate functions
    do in SQL. But we can also aggregate concatenated string values into longer, list-like
    strings.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: é€šå¸¸ä¼šæƒ³åˆ°å®šé‡æ„ä¹‰ä¸Šçš„èšåˆå‡½æ•°ï¼ˆ`SUM`ã€`COUNT`ç­‰ï¼‰ï¼Œè¿™ä¸»è¦æ˜¯å› ä¸º SQL ä¸­å¤§å¤šæ•°èšåˆå‡½æ•°çš„åŠŸèƒ½ã€‚ä½†æˆ‘ä»¬ä¹Ÿå¯ä»¥å°†æ‹¼æ¥çš„å­—ç¬¦ä¸²å€¼èšåˆæˆæ›´é•¿çš„ã€ç±»ä¼¼åˆ—è¡¨çš„å­—ç¬¦ä¸²ã€‚
- en: The challenge with this though is lies in accessing, manipulating, or otherwise
    evaluating the values within these concatenated strings. MySQL is going to treat
    the value `foo, bar, hello, world` not as a list, but as text.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œè¿™ä¸ªæŒ‘æˆ˜åœ¨äºè®¿é—®ã€æ“æ§æˆ–è¯„ä¼°è¿™äº›è¿æ¥å­—ç¬¦ä¸²ä¸­çš„å€¼ã€‚MySQLä¼šå°†`foo, bar, hello, world`çš„å€¼è§†ä¸ºæ–‡æœ¬ï¼Œè€Œä¸æ˜¯åˆ—è¡¨ã€‚
- en: Why is this relevant? Primarily because in our hypothetical scenario, we want
    to count the number of subscriptions in each combination. We donâ€™t want a long
    comma-delimited string, we want something more truly list-like.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æœ‰ä»€ä¹ˆç›¸å…³æ€§ï¼Ÿä¸»è¦æ˜¯å› ä¸ºåœ¨æˆ‘ä»¬çš„å‡è®¾åœºæ™¯ä¸­ï¼Œæˆ‘ä»¬æƒ³è¦è®¡ç®—æ¯ä¸ªç»„åˆä¸­çš„è®¢é˜…æ•°é‡ã€‚æˆ‘ä»¬ä¸å¸Œæœ›å¾—åˆ°ä¸€ä¸ªé•¿çš„ä»¥é€—å·åˆ†éš”çš„å­—ç¬¦ä¸²ï¼Œæˆ‘ä»¬å¸Œæœ›å¾—åˆ°ä¸€ä¸ªæ›´çœŸæ­£çš„åˆ—è¡¨å½¢å¼ã€‚
- en: Solving this in Python would be simpleâ€”using pandas, maybe polars, or even just
    Python-native data structures. But there are many cases where this isnâ€™t an option.
    Maybe the Data team is a strictly dbt-only shop; or, perhaps more commonplace,
    you work at a company where the IT department has local environments severely
    locked down.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨Pythonä¸­è§£å†³è¿™ä¸ªé—®é¢˜ä¼šå¾ˆç®€å•â€”â€”ä½¿ç”¨pandasï¼Œä¹Ÿè®¸æ˜¯polarsï¼Œç”šè‡³åªæ˜¯Pythonæœ¬èº«çš„æ•°æ®ç»“æ„ã€‚ä½†æœ‰è®¸å¤šæƒ…å†µä¸‹è¿™ä¸æ˜¯ä¸€ä¸ªé€‰é¡¹ã€‚ä¹Ÿè®¸æ•°æ®å›¢é˜Ÿåªä½¿ç”¨dbtï¼›æˆ–è€…æ›´å¸¸è§çš„æ˜¯ï¼Œä½ åœ¨ä¸€ä¸ªITéƒ¨é—¨ä¸¥å¯†é”å®šæœ¬åœ°ç¯å¢ƒçš„å…¬å¸å·¥ä½œã€‚
- en: 'Whatever the case, if you have only SQL at your disposal, you need a solution
    that will provide you the most readable code and the most flexible results. Achieving
    this is not intuitive. For example, my first instinct when encountering this problem
    was to use `GROUP_CONCAT`, the function that concatenates strings according to
    your defined grouping:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: æ— è®ºå¦‚ä½•ï¼Œå¦‚æœä½ åªæœ‰SQLå¯ä»¥ä½¿ç”¨ï¼Œä½ éœ€è¦ä¸€ä¸ªèƒ½å¤Ÿæä¾›æœ€å¯è¯»ä»£ç å’Œæœ€çµæ´»ç»“æœçš„è§£å†³æ–¹æ¡ˆã€‚å®ç°è¿™ä¸€ç‚¹å¹¶ä¸ç›´è§‚ã€‚ä¾‹å¦‚ï¼Œæˆ‘é‡åˆ°è¿™ä¸ªé—®é¢˜æ—¶çš„ç¬¬ä¸€ååº”æ˜¯ä½¿ç”¨`GROUP_CONCAT`ï¼Œè¿™æ˜¯ä¸€ä¸ªæ ¹æ®ä½ å®šä¹‰çš„åˆ†ç»„è¿æ¥å­—ç¬¦ä¸²çš„å‡½æ•°ï¼š
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![](../Images/a6f7a07836f586894a21825cbb0eb247.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a6f7a07836f586894a21825cbb0eb247.png)'
- en: Query results
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: æŸ¥è¯¢ç»“æœ
- en: As you can see, the aggregation *worked*, technically, but it didnâ€™t work along
    the lines of our business logic. See the first and last rows. The subscriptions
    combination of â€œinternational_snacks, self_careâ€ is the same combination as â€œself_care,
    international_snacksâ€. (The same is true of the 2nd and 4th rows.)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚ä½ æ‰€çœ‹åˆ°çš„ï¼Œèšåˆ*æœ‰æ•ˆ*ï¼Œä»æŠ€æœ¯ä¸Šè®²ï¼Œä½†å®ƒå¹¶æ²¡æœ‰æŒ‰ç…§æˆ‘ä»¬çš„ä¸šåŠ¡é€»è¾‘å·¥ä½œã€‚è¯·æŸ¥çœ‹ç¬¬ä¸€è¡Œå’Œæœ€åä¸€è¡Œã€‚ç»„åˆâ€œinternational_snacks, self_careâ€çš„è®¢é˜…ä¸â€œself_care,
    international_snacksâ€æ˜¯ç›¸åŒçš„ç»„åˆã€‚ï¼ˆç¬¬äºŒè¡Œå’Œç¬¬å››è¡Œä¹Ÿæ˜¯å¦‚æ­¤ã€‚ï¼‰
- en: 'We can use an `ORDER BY` clause within `GROUP_CONCAT` to solve this particular
    issue:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥åœ¨`GROUP_CONCAT`ä¸­ä½¿ç”¨`ORDER BY`å­å¥æ¥è§£å†³è¿™ä¸ªç‰¹å®šé—®é¢˜ï¼š
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![](../Images/d600ce04441f86029ced24389ca10d45.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d600ce04441f86029ced24389ca10d45.png)'
- en: Query results
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: æŸ¥è¯¢ç»“æœ
- en: But this still leaves up with the problem of counting how many subscriptions
    are in each combination.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†è¿™ä»ç„¶ç•™ä¸‹äº†ä¸€ä¸ªé—®é¢˜ï¼šå¦‚ä½•è®¡ç®—æ¯ä¸ªç»„åˆä¸­çš„è®¢é˜…æ•°é‡ã€‚
- en: There is a way to do it. But not only is it needlessly complex and not very
    readable, in my opinion, but it also comes with some not-so-obvious pitfalls.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ ·åšæ˜¯å¯è¡Œçš„ã€‚ä½†æˆ‘è®¤ä¸ºä¸ä»…å¤æ‚ä¸”ä¸å¤ªæ˜“è¯»ï¼Œè€Œä¸”è¿˜ä¼´éšç€ä¸€äº›ä¸å¤ªæ˜æ˜¾çš„é™·é˜±ã€‚
- en: 'A quick search on how to count the number of values in a comma-delimited string
    in MySQL turns up a [solution](https://stackoverflow.com/a/7020024/16018746) from
    StackOverflow that, translated for our purposes, amounts to this (`subscriptions_grouped`
    CTE excluded):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: å…³äºå¦‚ä½•è®¡ç®—MySQLä¸­ä»¥é€—å·åˆ†éš”çš„å­—ç¬¦ä¸²ä¸­çš„å€¼æ•°é‡çš„å¿«é€Ÿæœç´¢æ‰¾åˆ°äº†ä¸€ä¸ª[è§£å†³æ–¹æ¡ˆ](https://stackoverflow.com/a/7020024/16018746)ï¼Œå¯¹æˆ‘ä»¬æ¥è¯´ï¼Œç›¸å½“äºè¿™ä¸ªï¼ˆ`subscriptions_grouped`
    CTEé™¤å¤–ï¼‰ï¼š
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Which is essentially counting the number of commas and then adding 1 to the
    result. This works. But not only is this answer difficult to understand at a glance,
    it also introduces a potential mistake: the `LENGTH` and `CHAR_LENGTH` function
    [donâ€™t count the same thing](https://stackoverflow.com/a/1734340/16018746).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æœ¬è´¨ä¸Šæ˜¯è®¡ç®—é€—å·çš„æ•°é‡ï¼Œç„¶åå°†ç»“æœåŠ 1ã€‚è¿™æ˜¯å¯è¡Œçš„ã€‚ä½†è¿™ä¸ªç­”æ¡ˆä¸ä»…éš¾ä»¥ä¸€çœ¼ç†è§£ï¼Œè¿˜å¼•å…¥äº†ä¸€ä¸ªæ½œåœ¨çš„é”™è¯¯ï¼š`LENGTH`å’Œ`CHAR_LENGTH`å‡½æ•°[è®¡ç®—çš„å†…å®¹ä¸åŒ](https://stackoverflow.com/a/1734340/16018746)ã€‚
- en: As you can probably guess, this article details obstacles I ran into at work
    when I found myself in a similar situation.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚ä½ å¯èƒ½çŒœåˆ°çš„ï¼Œè¿™ç¯‡æ–‡ç« è¯¦ç»†æè¿°äº†æˆ‘åœ¨å·¥ä½œä¸­é‡åˆ°çš„éšœç¢ï¼Œå½“æ—¶æˆ‘å‘ç°è‡ªå·±å¤„äºç±»ä¼¼çš„æƒ…å†µã€‚
- en: Ultimately, the solution was in a somewhat hack-y, but remarkably comprehensible,
    workaround using the native MySQL JSON data type.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€ç»ˆï¼Œè§£å†³æ–¹æ¡ˆæ˜¯ä½¿ç”¨æœ¬åœ°MySQL JSONæ•°æ®ç±»å‹çš„æŸç§é»‘å®¢å¼ä½†éå¸¸æ˜“æ‡‚çš„å˜é€šæ–¹æ³•ã€‚
- en: A brief overview of the JSON data type in MySQL
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MySQLä¸­JSONæ•°æ®ç±»å‹çš„ç®€è¦æ¦‚è¿°
- en: The JSON data type in MySQL was added in version 5.7.8, and provides a lot of
    useful utility for both storage and modeling.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: MySQLä¸­çš„JSONæ•°æ®ç±»å‹æ˜¯åœ¨5.7.8ç‰ˆæœ¬ä¸­æ–°å¢çš„ï¼Œæä¾›äº†è®¸å¤šå¯¹å­˜å‚¨å’Œå»ºæ¨¡éå¸¸æœ‰ç”¨çš„åŠŸèƒ½ã€‚
- en: 'Under the JSON data type umbrella (officially called â€œJSON documentsâ€) are
    two different data structures: JSON arrays and JSON objects.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ JSON æ•°æ®ç±»å‹çš„ä¼ä¸‹ï¼ˆå®˜æ–¹ç§°ä¸ºâ€œJSON æ–‡æ¡£â€ï¼‰æœ‰ä¸¤ç§ä¸åŒçš„æ•°æ®ç»“æ„ï¼šJSON æ•°ç»„å’Œ JSON å¯¹è±¡ã€‚
- en: 'A JSON array can simply be thought of as an array (a list, if youâ€™re a Pythonista):
    values enclosed by square brackets `[ ]` and separated by commas.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: JSON æ•°ç»„å¯ä»¥ç®€å•åœ°è¢«çœ‹ä½œæ˜¯ä¸€ä¸ªæ•°ç»„ï¼ˆå¦‚æœä½ æ˜¯ Python çˆ±å¥½è€…çš„è¯ï¼Œå°±æ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼‰ï¼šå€¼ç”¨æ–¹æ‹¬å· `[ ]` æ‹¬èµ·æ¥ï¼Œå¹¶ç”¨é€—å·åˆ†éš”ã€‚
- en: 'An example MySQL JSON array value: `[â€œfooâ€, â€œbarâ€, 1, 2]`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€ä¸ª MySQL JSON æ•°ç»„å€¼çš„ç¤ºä¾‹ï¼š`[â€œfooâ€, â€œbarâ€, 1, 2]`
- en: 'A JSON object can be thought of as a hash table (or, again in Python terms,
    a dictionary): key-value pairs, separated by commas, and enclosed by curly brackets
    `{ }`.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: JSON å¯¹è±¡å¯ä»¥è¢«çœ‹ä½œæ˜¯ä¸€ä¸ªå“ˆå¸Œè¡¨ï¼ˆæˆ–è€…ç”¨ Python çš„æœ¯è¯­è¯´ï¼Œå°±æ˜¯ä¸€ä¸ªå­—å…¸ï¼‰ï¼šé”®å€¼å¯¹ï¼Œç”¨é€—å·åˆ†éš”ï¼Œå¹¶ç”¨èŠ±æ‹¬å· `{ }` æ‹¬èµ·æ¥ã€‚
- en: 'An example of a MySQL JSON object value: `{â€œfooâ€: â€œbarâ€, 1: 2}`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'ä¸€ä¸ª MySQL JSON å¯¹è±¡å€¼çš„ç¤ºä¾‹ï¼š`{â€œfooâ€: â€œbarâ€, 1: 2}`'
- en: '[MySQL has a number of functions that can be used to deal with both of these
    formats](https://dev.mysql.com/doc/refman/5.7/en/json-function-reference.html)â€”almost
    none of which perform any sort of aggregation.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[MySQL æä¾›äº†è®¸å¤šå‡½æ•°æ¥å¤„ç†è¿™ä¸¤ç§æ ¼å¼](https://dev.mysql.com/doc/refman/5.7/en/json-function-reference.html)â€”å‡ ä¹æ²¡æœ‰å‡½æ•°æ‰§è¡Œä»»ä½•å½¢å¼çš„èšåˆã€‚'
- en: Thankfully, though, there are two that do. And they both return JSON documents,
    which means we can use MySQLâ€™s built-in functions to access the values therein.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸è¿‡å¹¸è¿çš„æ˜¯ï¼Œæœ‰ä¸¤ä¸ªå‡½æ•°æ˜¯å¯ä»¥çš„ã€‚å®ƒä»¬éƒ½è¿”å› JSON æ–‡æ¡£ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ MySQL å†…ç½®çš„å‡½æ•°æ¥è®¿é—®å…¶ä¸­çš„å€¼ã€‚
- en: JSON_ARRAYAGG
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON_ARRAYAGG
- en: The MySQL function `JSON_ARRAYAGG` acts a lot like `GROUP_CONCAT`. The biggest
    difference is that it returns a JSON array, which, again, comes with several helpful
    built-in functions linked above.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL å‡½æ•° `JSON_ARRAYAGG` å¾ˆåƒ `GROUP_CONCAT`ã€‚æœ€å¤§çš„åŒºåˆ«æ˜¯å®ƒè¿”å›ä¸€ä¸ª JSON æ•°ç»„ï¼Œè€Œè¿™ä¸ª JSON æ•°ç»„å¸¦æœ‰å¤šä¸ªæœ‰ç”¨çš„å†…ç½®å‡½æ•°ï¼Œå¦‚ä¸Šæ‰€è¿°ã€‚
- en: 'The JSON array data type solves one of our two problems with astounding simplicity:
    the problem of reliably counting the number of subscriptions in a combination.
    This is accomplished using the `[JSON_LENGTH](https://dev.mysql.com/doc/refman/5.7/en/json-attribute-functions.html#function_json-length)`
    function. The syntax is wonderfully straightforward:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: JSON æ•°ç»„æ•°æ®ç±»å‹ä»¥æƒŠäººçš„ç®€å•æ€§è§£å†³äº†æˆ‘ä»¬é¢ä¸´çš„ä¸¤ä¸ªé—®é¢˜ä¸­çš„ä¸€ä¸ªï¼šå¯é è®¡ç®—ç»„åˆä¸­è®¢é˜…æ•°é‡çš„é—®é¢˜ã€‚è¿™æ˜¯é€šè¿‡ä½¿ç”¨ `[JSON_LENGTH](https://dev.mysql.com/doc/refman/5.7/en/json-attribute-functions.html#function_json-length)`
    å‡½æ•°å®Œæˆçš„ã€‚è¯­æ³•éå¸¸ç®€å•ï¼š
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The result of this statement is 4, since there are 4 values in the generated
    JSON array.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªè¯­å¥çš„ç»“æœæ˜¯ 4ï¼Œå› ä¸ºç”Ÿæˆçš„ JSON æ•°ç»„ä¸­æœ‰ 4 ä¸ªå€¼ã€‚
- en: 'But letâ€™s return to the combination of subscriptions. Unfortunately, `JSON_ARRAYAGG`
    doesnâ€™t come with the ordering functionality that `GROUP_CONCAT` has. Ordering
    the `subscription` values, even in a CTE before the base query, doesnâ€™t return
    the desired results:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†è®©æˆ‘ä»¬å›åˆ°è®¢é˜…çš„ç»„åˆã€‚ä¸å¹¸çš„æ˜¯ï¼Œ`JSON_ARRAYAGG` ä¸å…·å¤‡ `GROUP_CONCAT` çš„æ’åºåŠŸèƒ½ã€‚åœ¨åŸºæŸ¥è¯¢ä¹‹å‰å³ä½¿åœ¨ CTE ä¸­æ’åº
    `subscription` å€¼ï¼Œä¹Ÿæ— æ³•è¿”å›æœŸæœ›çš„ç»“æœï¼š
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![](../Images/e43f5434827139bfa31f28338ec75ec2.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e43f5434827139bfa31f28338ec75ec2.png)'
- en: Query results
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: æŸ¥è¯¢ç»“æœ
- en: The number of subscriptions in each combination is there, thanks to the `JSON_LENGTH`
    functionâ€”but combinations that are effectively the same are once again mischaracterized
    as distinct because of their order.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: æ¯ä¸ªç»„åˆä¸­çš„è®¢é˜…æ•°é‡æ˜¯å­˜åœ¨çš„ï¼Œè¿™è¦å½’åŠŸäº `JSON_LENGTH` å‡½æ•°â€”â€”ä½†ç”±äºå®ƒä»¬çš„é¡ºåºï¼Œç›¸åŒçš„ç»„åˆå†æ¬¡è¢«é”™è¯¯åœ°æ ‡è®°ä¸ºä¸åŒçš„ã€‚
- en: Using ROW_NUMBER to force the ordering of values
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ ROW_NUMBER å¼ºåˆ¶å€¼çš„æ’åº
- en: '`ROW_NUMBER` is a window function that creates an index. The index has to be
    defined; that is, you have to tell it where to start, how to increment (directionally),
    and where to end.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`ROW_NUMBER` æ˜¯ä¸€ä¸ªçª—å£å‡½æ•°ï¼Œç”¨äºåˆ›å»ºç´¢å¼•ã€‚ç´¢å¼•å¿…é¡»è¢«å®šä¹‰ï¼›ä¹Ÿå°±æ˜¯è¯´ï¼Œä½ éœ€è¦å‘Šè¯‰å®ƒä»å“ªé‡Œå¼€å§‹ï¼Œå¦‚ä½•é€’å¢ï¼ˆæ–¹å‘ï¼‰ï¼Œä»¥åŠåœ¨å“ªé‡Œç»“æŸã€‚'
- en: 'We can see a quick example of this by applying the `ROW_NUMBER` function and
    telling it to order by the `subscription` field:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥é€šè¿‡åº”ç”¨ `ROW_NUMBER` å‡½æ•°å¹¶å‘Šè¯‰å®ƒæŒ‰ `subscription` å­—æ®µæ’åºæ¥å¿«é€ŸæŸ¥çœ‹ä¸€ä¸ªä¾‹å­ï¼š
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](../Images/1066d24e9f6e4a4671f414253647015d.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1066d24e9f6e4a4671f414253647015d.png)'
- en: Query results
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: æŸ¥è¯¢ç»“æœ
- en: Look closely at the results. ***Even though we didnâ€™t use an*** `ORDER BY` ***statement
    at the end of our query, the data is nonetheless ordered according to the*** `ORDER
    BY` ***in the*** `OVER` ***clause.***
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ä»”ç»†æŸ¥çœ‹ç»“æœã€‚***å°½ç®¡æˆ‘ä»¬åœ¨æŸ¥è¯¢çš„æœ€åæ²¡æœ‰ä½¿ç”¨*** `ORDER BY` ***è¯­å¥ï¼Œä½†æ•°æ®è¿˜æ˜¯æ ¹æ®*** `ORDER BY` ***åœ¨*** `OVER`
    ***å­å¥ä¸­çš„é¡ºåºè¿›è¡Œäº†æ’åºã€‚***
- en: 'But of course this still isnâ€™t exactly what we want. What we need to do next
    is add a `PARTITION BY` clause to our window function, so that the ordering of
    the results are related to (and in fact bounded by) each customer ID. Like so:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![](../Images/4537a7c2f58735eb1c1b44276cf9c635.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
- en: Query results
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: You can probably see where this is going.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'If we execute the `JSON_ARRAYAGG` function against these results in a CTE,
    we see that the duplicate combinations now look exactly the same, thanks to the
    subscriptions being forced into an alphabetical order by the `ROW_NUMBER` function:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](../Images/eac71aa011199f26abb7c391f7a0382e.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
- en: Query results
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we need to do is add in the grouping CTE following the one executing
    `ROW_NUMBER`, and alter the base query:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This gives not only accurately distinct combinations of subscriptions, but
    also the number of customers whoâ€™ve purchased those combinations, and how many
    subscriptions comprise each of them:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5154dd8a5b6457e69f1cbcdeb57b20ae.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
- en: Query results
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Voila!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: To recap
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We wanted to know how many customers purchased different combination of subscriptions,
    and how many subscriptions were in each of those combinations. This presented
    two problems: how best to obtain the latter, and how to generate accurately distinct
    subscription combinations.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To obtain the number of subscriptions in each combination, we chose to go with
    one of MySQLâ€™s JSON functions, `JSON_ARRAYAGG`. The resulting aggregation was
    returned to us as a JSON data type, allowing us to use the `JSON_LENGTH` function.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then needed to force the ordering of values inside the JSON array so that
    duplicate combinations didnâ€™t mistakenly appear distinct. To do this, we used
    the window function `ROW_NUMBER` in a CTE prior to the base query, partitioning
    by customer ID and ordering the subscriptions alphabetically (in ascending order).
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This ultimately allowed us to aggregate up to accurately distinct combinations
    of subscriptions; and with this we were able to use a simple `COUNT` function
    to see how many customers had purchased each combination.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thanks for reading! ğŸ¤“
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*I hope this was helpful! If you know of any other clever tricks/workarounds
    in SQL (regardless of dialect), Iâ€™d love to hear about them. SQL has long been
    the de facto lingua franca for transforming structured data, but itâ€™s not perfect.
    I always enjoy learning about innovative and/or clever solutions to real-world
    challenges. ğŸ”¥*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '*I write semi-regularly about data engineering and analytics topicsâ€”the goal
    always being to write as clearly and simply as possible. If anything in this article
    confused you, please let me know in the comments. And if youâ€™re interested in
    reading more articles like this, feel free to* [*follow me*](https://medium.com/@dakotasmithdata)
    *and/or* [*connect on LinkedIn*](https://www.linkedin.com/in/dakotaleesmith/)*.*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
