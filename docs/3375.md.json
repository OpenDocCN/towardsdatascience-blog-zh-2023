["```py\ndsatur(N)\n  Q = [&n for n in N]\n  C = {}\n  while |Q| > 0:\n    sort(Q) // descending order by saturation and degree\n    n = Q.pop(0)\n    assign_color(n, C)\n```", "```py\nfrom typing import List, Tuple\n```", "```py\nclass Color:\n\n    index: int\n    n_nodes: int\n\n    def __init__(self, index) -> None:\n        self.index = index\n        self.n_nodes = 0\n\n    def __repr__(self):\n        return f\"C{self.index}\"\n\n    def add_node(self):\n        self.n_nodes = self.n_nodes + 1\n```", "```py\nclass Node:\n\n    neighbors: List['Node']\n    index: int\n    color: Color\n\n    def __init__(self, index):\n        self.index = index\n        self.neighbors = []\n        self.color = None\n\n    def __repr__(self) -> str:\n        return f\"N{self.index}|{self.color}\"\n\n    def add_neighbor(self, node: 'Node'):\n        if node not in self.neighbors:\n            self.neighbors.append(node)\n\n    def set_color(self, color: Color):\n        self.color = color\n        color.add_node()\n\n    @property\n    def neighbor_colors(self):\n        return [n.color for n in self.neighbors if n.color is not None]\n\n    @property\n    def saturation(self):\n        return len(set((n.color for n in self.neighbors if n.color is not None)))\n\n    @property\n    def degree(self):\n        return len(self.neighbors)\n```", "```py\nclass DSatur:\n\n    N: List[Node]\n    C: List[Color]\n    history: List[Node]\n\n    def __init__(self, nodes: List[int], edges: List[Tuple[int, int]]):\n        N = [Node(i) for i in nodes]\n        for e in edges:\n            i, j = e\n            N[i].add_neighbor(N[j])\n            N[j].add_neighbor(N[i])\n        self.N = N\n        self.C = []\n        self.history = []\n\n    def find_next_color(self, node: Node) -> Color:\n        next_color = None\n        for c in self.C:\n            if c not in node.neighbor_colors:\n                next_color = c\n                break\n        if next_color is None:\n            next_color = Color(len(self.C) + 1)\n            self.C.append(next_color)\n        return next_color\n\n    def solve(self, save_history=False):\n        Q = [n for n in self.N]  # Pool of uncolored nodes\n        while len(Q) > 0:\n            Q.sort(key=lambda x: (x.saturation, x.degree), reverse=True)\n            n: Node = Q.pop(0)\n            next_color = self.find_next_color(n)\n            n.set_color(next_color)\n            if save_history:\n                self.history.append(n)\n        self.C.sort(key=lambda x: x.n_nodes, reverse=True)\n\n    @property\n    def cost(self):\n        return len(self.C)\n```", "```py\n# Open and read file\nwith open($YOUR_FILE_PATH, mode=\"r\") as file:\n    lines = file.readlines()\n    header = lines[0].strip().split()\n    n_nodes = int(header[2])\n    edges = []\n    node_set = set()\n    for line in lines[1:]:\n        if line.startswith('e'):\n            _, i, j = line.strip().split()\n            edges.append((int(i), int(j)))\n            node_set.add(int(i))\n            node_set.add(int(j))\nnodes = sorted(node_set)\nassert len(nodes) == n_nodes, \"Wrong number of nodes specified\"\n```", "```py\ndsatur = DSatur(nodes, edges)\ndsatur.solve()\n```", "```py\nimport pyomo.environ as pyo\n```", "```py\nmodel = pyo.ConcreteModel()\n```", "```py\nmodel.C = pyo.Set(initialize=range(len(dsatur.C)))  # Colors\nmodel.N = pyo.Set(initialize=nodes)  # Nodes\nmodel.E = pyo.Set(initialize=edges])  # Edges\n```", "```py\nmodel.x = pyo.Var(model.N, model.C, within=pyo.Binary)\nmodel.y = pyo.Var(model.C, within=pyo.Binary)\n```", "```py\n# Fill every node with some color\ndef fill_cstr(model, i):\n    return sum(model.x[i, :]) == 1\n\n# Do not repeat colors on edges and indicator that color is used\ndef edge_cstr(model, i, j, c):\n    return model.x[i, c] + model.x[j, c] <= model.y[c]\n\n# Break symmetry by setting a preference order (not required)\ndef break_symmetry(model, c):\n    if model.C.first() == c:\n        return 0 <= model.y[c]\n    else:\n        c_prev = model.C.prev(c)\n        return model.y[c] <= model.y[c_prev]\n\nmodel.fill_cstr = pyo.Constraint(model.N, rule=fill_cstr)\nmodel.edge_cstr = pyo.Constraint(model.E, model.C, rule=edge_cstr)\nmodel.break_symmetry = pyo.Constraint(model.C, rule=break_symmetry)\n```", "```py\n# Break symmetry by setting a preference order with total assignments\ndef break_symmetry_agg(model, c):\n    if model.C.first() == c:\n        return 0 <= sum(model.x[:, c])\n    else:\n        c_prev = model.C.prev(c)\n        return sum(model.x[:, c]) <= sum(model.x[:, c_prev])\n```", "```py\n# Total number of colors used\ndef obj(model):\n    return sum(model.y[:])\n\nmodel.obj = pyo.Objective(rule=obj)\n```", "```py\nsolver = pyo.SolverFactory(\"appsi_highs\")\nsolver.highs_options[\"time_limit\"] = 120\nres = solver.solve(model)\nprint(res)\n```"]