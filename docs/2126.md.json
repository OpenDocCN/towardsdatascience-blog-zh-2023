["```py\nfrom typing import Tuple\n\nfrom numpy.core.multiarray import normalize_axis_index\nfrom numpy.typing import NDArray\n\ndef sobel(arr: NDArray, axes: Tuple[int, int] = (-2, -1)) -> NDArray:\n    \"\"\"Compute the Sobel filter of an image\n\n    Parameters\n    ----------\n    arr : NDArray\n        Input image\n    axes : Tuple[int, int], optional\n        Axes over which to compute the filter, by default (-2, -1)\n\n    Returns\n    -------\n    NDArray\n        Output\n    \"\"\"\n    # Only accepts 2D arrays\n    if arr.ndim != 2:\n        raise NotImplementedError\n\n    # Ensure that the axis[0] is the first axis, and axis[1] is the second\n    # axis. The obscure `normalize_axis_index` converts negative indices to\n    # indices between 0 and arr.ndim - 1.\n    if any(\n        normalize_axis_index(ax, arr.ndim) != i\n        for i, ax in zip(range(2), axes)\n    ):\n        raise NotImplementedError\n    pass\n```", "```py\n# test_zero_constant.py\n\nimport numpy as np\nimport pytest\n\n# Test multiple dtypes at once\n@pytest.mark.parametrize(\n    \"dtype\",\n    [\"float16\", \"float32\", \"float64\", \"float128\"],\n)\ndef test_zero(dtype):\n    # Set random seed\n    seed = int(np.random.rand() * (2**32 - 1))\n    np.random.seed(seed)\n\n    # Create a 2D array of random shape and fill with zeros\n    nx, ny = np.random.randint(3, 100, size=(2,))\n    arr = np.zeros((nx, ny), dtype=dtype)\n\n    # Apply sobel function\n    arr_sob = sobel(arr)\n\n    # `assert_array_equal` should fail most of the times.\n    # It will only work when `arr_sob` is identically zero,\n    # which is usually not the case.\n    # DO NOT USE!\n    # np.testing.assert_array_equal(\n    #     arr_sob, 0.0, err_msg=f\"{seed=} {nx=}, {ny=}\"\n    # )\n\n    # `assert_almost_equal` can fail when used with high decimals.\n    # It also relies on float64 checking, which might fail for\n    # float128 types.\n    # DO NOT USE!\n    # np.testing.assert_almost_equal(\n    #     arr_sob,\n    #     np.zeros_like(arr),\n    #     err_msg=f\"{seed=} {nx=}, {ny=}\",\n    #     decimal=4,\n    # )\n\n    # `assert_allclose` with custom tolerance is my preferred method\n    # The 10 is arbitrary and depends on the problem. If a method\n    # which you know to be correct does not pass, increase to 100, etc.\n    # If the tolerance needed to make the tests pass is too high, make\n    # sure the method is actually correct.\n    tol = 10 * np.finfo(arr.dtype).eps\n    err_msg = f\"{seed=} {nx=}, {ny=} {tol=}\"  # Log seeds and other info\n    np.testing.assert_allclose(\n        arr_sob,\n        np.zeros_like(arr),\n        err_msg=err_msg,\n        atol=tol,  # rtol is useless for desired=zeros\n    )\n\n@pytest.mark.parametrize(\n    \"dtype\", [\"float16\", \"float32\", \"float64\", \"float128\"]\n)\ndef test_constant(dtype):\n    seed = int(np.random.rand() * (2**32 - 1))\n    np.random.seed(seed)\n\n    nx, ny = np.random.randint(3, 100, size=(2,))\n    constant = np.random.randn(1).item()\n    arr = np.full((nx, ny), fill_value=constant, dtype=dtype)\n    arr_sob = sobel(arr)\n\n    tol = 10 * np.finfo(arr.dtype).eps\n    err_msg = f\"{seed=} {nx=}, {ny=} {tol=}\"\n    np.testing.assert_allclose(\n        arr_sob,\n        np.zeros_like(arr),\n        err_msg=err_msg,\n        atol=tol,  # rtol is useless for desired=zeros\n    )\n```", "```py\n$ pytest -qq -s -x -vv --durations=0 test_zero_constant.py\n```", "```py\nfrom typing import Tuple\n\nimport numpy as np\nfrom numpy.core.multiarray import normalize_axis_index\nfrom numpy.typing import NDArray\n\ndef sobel(arr: NDArray, axes: Tuple[int, int] = (-2, -1)) -> NDArray:\n    if arr.ndim != 2:\n        raise NotImplementedError\n    if any(\n        normalize_axis_index(ax, arr.ndim) != i\n        for i, ax in zip(range(2), axes)\n    ):\n        raise NotImplementedError\n\n    # Define our filter kernels. Notice they inherit the input type, so\n    # that a float32 input never has to be cast to float64 for computation.\n    # But can you see where using another dtype for Gx and Gy might make\n    # sense for some input dtypes?\n    Gx = np.array(\n        [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]],\n        dtype=arr.dtype,\n    )\n    Gy = np.array(\n        [[-1, -2, -1], [0, 0, 0], [1, 2, 1]],\n        dtype=arr.dtype,\n    )\n\n    # Create the output array and fill with zeroes\n    s = np.zeros_like(arr)\n    for ix in range(1, arr.shape[0] - 1):\n        for iy in range(1, arr.shape[1] - 1):\n            # Pointwise multiplication followed by sum, aka convolution\n            s1 = (Gx * arr[ix - 1 : ix + 2, iy - 1 : iy + 2]).sum()\n            s2 = (Gy * arr[ix - 1 : ix + 2, iy - 1 : iy + 2]).sum()\n            s[ix, iy] = np.hypot(s1, s2)  # np.sqrt(s1**2 + s2**2)\n    return s\n```", "```py\n$ pytest -qq -s -x -vv --durations=0 test_zero_constant.py\n........\n======================================== slowest durations =========================================\n0.09s call     t_049988eae7f94139a7067f142bf2852f.py::test_constant[float16]\n0.08s call     t_049988eae7f94139a7067f142bf2852f.py::test_zero[float64]\n0.06s call     t_049988eae7f94139a7067f142bf2852f.py::test_constant[float128]\n0.04s call     t_049988eae7f94139a7067f142bf2852f.py::test_zero[float128]\n0.04s call     t_049988eae7f94139a7067f142bf2852f.py::test_constant[float64]\n0.02s call     t_049988eae7f94139a7067f142bf2852f.py::test_constant[float32]\n0.01s call     t_049988eae7f94139a7067f142bf2852f.py::test_zero[float16]\n\n(17 durations < 0.005s hidden.  Use -vv to show these durations.)\n8 passed in 0.35s\n```", "```py\n# !pip installscikit-image pooch\nfrom typing import Dict, Callable\n\nimport numpy as np\nimport skimage.data\n\nbwimages: Dict[str, np.ndarray] = {}\nfor attrname in skimage.data.__all__:\n    attr = getattr(skimage.data, attrname)\n    # Data are obtained via function calls\n    if isinstance(attr, Callable):\n        try:\n            # Download the data\n            data = attr()\n            # Ensure it is a 2D array\n            if isinstance(data, np.ndarray) and data.ndim == 2:\n                # Convert from various int types to float32 to better\n                # assess precision\n                bwimages[attrname] = data.astype(np.float32)\n        except:\n            continue\n\n# Apply sobel to images\nbwimages_sobel = {k: sobel(v) for k, v in bwimages.items()}\n```", "```py\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\n\ndef create_colorbar(im, ax):\n    divider = make_axes_locatable(ax)\n    cax = divider.append_axes(\"right\", size=\"5%\", pad=0.1)\n    cb = ax.get_figure().colorbar(im, cax=cax, orientation=\"vertical\")\n    return cax, cb\n\nfor name, data in bwimages.items():\n    fig, axs = plt.subplots(\n        1, 2, figsize=(10, 4), sharex=True, sharey=True\n    )\n    im = axs[0].imshow(data, aspect=\"equal\", cmap=\"gray\")\n    create_colorbar(im, axs[0])\n    axs[0].set(title=name)\n\n    im = axs[1].imshow(bwimages_sobel[name], aspect=\"equal\", cmap=\"gray\")\n    create_colorbar(im, axs[1])\n    axs[1].set(title=f\"{name} sobel\")\n```", "```py\noracle_library = [(k, v, bwimages_sobel[k]) for k, v in bwimages.items()]\n# save_to_disk(oracle_library, ...)\n```", "```py\n# test_oracle.py\nimport numpy as np\nimport pytest\nfrom numpy.typing import NDArray\n\n# oracle_library = read_from_disk(...)\n\n@pytest.mark.parametrize(\"name,input,output\", oracle_library)\ndef test_oracles(name: str, input: NDArray, output: NDArray):\n    output_new = sobel(input)\n    tol = 10 * np.finfo(input.dtype).eps\n    mean_avg_error = np.abs(output_new - output).mean()\n    np.testing.assert_allclose(\n        output_new,\n        output,\n        err_msg=f\"{name=} {tol=} {mean_avg_error=}\",\n        atol=tol,\n        rtol=tol,\n    )\n```", "```py\nimport time\nfrom functools import wraps\nfrom typing import Callable, Optional\n\ndef sizeof_fmt(num, suffix=\"s\"):\n    for unit in [\"n\", \"μ\", \"m\"]:\n        if abs(num) < 1000:\n            return f\"{num:3.1f} {unit}{suffix}\"\n        num /= 1000\n    return f\"{num:.1f}{suffix}\"\n\ndef timeit(\n    func_or_number: Optional[Callable] = None,\n    number: int = 10,\n) -> Callable:\n    \"\"\"Apply to a function to time its executions.\n\n    Parameters\n    ----------\n    func_or_number : Optional[Callable], optional\n        Function to be decorated or `number` argument (see below), by\n        default None\n    number : int, optional\n        Number of times the function will run to obtain statistics, by\n        default 10\n\n    Returns\n    -------\n    Callable\n        When fed a function, returns the decorated function. Otherwise\n        returns a decorator.\n\n    Examples\n    --------\n\n    .. code-block:: python\n\n        @timeit\n        def my_fun():\n            pass\n\n        @timeit(100)\n        def my_fun():\n            pass\n\n        @timeit(number=3)\n        def my_fun():\n            pass\n\n    \"\"\"\n    if isinstance(func_or_number, Callable):\n        func = func_or_number\n        number = number\n    elif isinstance(func_or_number, int):\n        func = None\n        number = func_or_number\n    else:\n        func = None\n        number = number\n\n    def decorator(f):\n        @wraps(f)\n        def wrapper(*args, **kwargs):\n            runs_ns = np.empty((number,))\n\n            # Run first and measure store the result\n            start_time = time.perf_counter_ns()\n            result = f(*args, **kwargs)\n            runs_ns[0] = time.perf_counter_ns() - start_time\n            for i in range(1, number):\n                start_time = time.perf_counter_ns()\n                f(*args, **kwargs)  # Without storage, faster\n                runs_ns[i] = time.perf_counter_ns() - start_time\n            time_msg = f\"{sizeof_fmt(runs_ns.mean())} ± \"\n            time_msg += f\"{sizeof_fmt(runs_ns.std())}\"\n            print(\n                f\"{time_msg} per run (mean ± std. dev. of {number} runs)\"\n            )\n            return result\n\n        return wrapper\n\n    if func is not None:\n        return decorator(func)\n    return decorator\n```", "```py\narr_test = np.random.randn(500, 500)\nsobel_timed = timeit(sobel)\nsobel_timed(arr_test);\n# 3.9s ± 848.9 ms per run (mean ± std. dev. of 10 runs)\n```", "```py\nfrom line_profiler import LineProfiler\n\nlp = LineProfiler()\nlp_wrapper = lp(sobel)\nlp_wrapper(arr_test)\nlp.print_stats(output_unit=1)  # 1 for seconds, 1e-3 for milliseconds, etc.\n```", "```py\nTimer unit: 1 s\n\nTotal time: 4.27197 s\nFile: /tmp/ipykernel_521529/1313985340.py\nFunction: sobel at line 8\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n     8                                           def sobel(arr: NDArray, axes: Tuple[int, int] = (-2, -1)) -> NDArray:\n     9                                               # Only accepts 2D arrays\n    10         1          0.0      0.0      0.0      if arr.ndim != 2:\n    11                                                   raise NotImplementedError\n    12                                           \n    13                                               # Ensure that the axis[0] is the first axis, and axis[1] is the second\n    14                                               # axis. The obscure `normalize_axis_index` converts negative indices to\n    15                                               # indices between 0 and arr.ndim - 1.\n    16         1          0.0      0.0      0.0      if any(\n    17                                                   normalize_axis_index(ax, arr.ndim) != i\n    18         1          0.0      0.0      0.0          for i, ax in zip(range(2), axes)\n    19                                               ):\n    20                                                   raise NotImplementedError\n    21                                           \n    22         1          0.0      0.0      0.0      Gx = np.array(\n    23         1          0.0      0.0      0.0          [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]],\n    24         1          0.0      0.0      0.0          dtype=arr.dtype,\n    25                                               )\n    26         1          0.0      0.0      0.0      Gy = np.array(\n    27         1          0.0      0.0      0.0          [[-1, -2, -1], [0, 0, 0], [1, 2, 1]],\n    28         1          0.0      0.0      0.0          dtype=arr.dtype,\n    29                                               )\n    30         1          0.0      0.0      0.0      s = np.zeros_like(arr)\n    31       498          0.0      0.0      0.0      for ix in range(1, arr.shape[0] - 1):\n    32    248004          0.1      0.0      2.2          for iy in range(1, arr.shape[1] - 1):\n    33    248004          1.8      0.0     41.5              s1 = (Gx * arr[ix - 1 : ix + 2, iy - 1 : iy + 2]).sum()\n    34    248004          1.7      0.0     39.5              s2 = (Gy * arr[ix - 1 : ix + 2, iy - 1 : iy + 2]).sum()\n    35    248004          0.7      0.0     16.8              s[ix, iy] = np.hypot(s1, s2)\n    36         1          0.0      0.0      0.0      return s\n```", "```py\n$ # Create sobel.bin which holds the profiling information\n$ memray run -fo sobel.bin --trace-python-allocators sobel_run.py\nWriting profile results into sobel.bin\nMemray WARNING: Correcting symbol for aligned_alloc from 0x7fc5c984d8f0 to 0x7fc5ca4a5ce0\n[memray] Successfully generated profile results.\n\nYou can now generate reports from the stored allocation records.\nSome example commands to generate reports:\n\npython3 -m memray flamegraph sobel.bin\n```", "```py\n$ # Generate flame graph\n$ memray flamegraph -fo sobel_flamegraph.html --temporary-allocations sobel.bin\n⠙ Calculating high watermark... ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╸  99% 0:00:0100:01\n⠏ Processing allocation records... ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╸  98% 0:00:0100:01\nWrote sobel_flamegraph.html\n```", "```py\n$ # Show memory tree\n$ memray tree --temporary-allocations sobel.bin\n\n⠧ Calculating high watermark... ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╸ 100% 0:00:0100:01\n⠧ Processing allocation records... ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╸ 100% 0:00:0100:01\n\nAllocation metadata\n-------------------\nCommand line arguments: \n'memray run -fo sobel.bin --trace-python-allocators sobel_run.py'\nPeak memory size: 11.719MB\nNumber of allocations: 15332714\n\nBiggest 10 allocations:\n-----------------------\n📂 123.755MB (100.00 %) <ROOT>  \n└── [[3 frames hidden in 2 file(s)]]\n    └── 📂 123.755MB (100.00 %) _run_code  /usr/lib/python3.10/runpy.py:86\n        ├── 📂 122.988MB (99.38 %) <module>  sobel_run.py:40\n        │   ├── 📄 51.087MB (41.28 %) sobel  sobel_run.py:35\n        │   ├── [[1 frames hidden in 1 file(s)]]\n        │   │   └── 📄 18.922MB (15.29 %) _sum  \n        │   │       lib/python3.10/site-packages/numpy/core/_methods.py:49\n        │   └── [[1 frames hidden in 1 file(s)]]\n        │       └── 📄 18.921MB (15.29 %) _sum  \n        │           lib/python3.10/site-packages/numpy/core/_methods.py:49\n...\n```", "```py\nfrom typing import Tuple\n\nimport numpy as np\nfrom numpy.core.multiarray import normalize_axis_index\nfrom numpy.typing import NDArray\nfrom scipy.signal import convolve2d\n\ndef sobel_conv2d(\n    arr: NDArray, axes: Tuple[int, int] = (-2, -1)\n) -> NDArray:\n    if arr.ndim != 2:\n        raise NotImplementedError\n    if any(\n        normalize_axis_index(ax, arr.ndim) != i\n        for i, ax in zip(range(2), axes)\n    ):\n        raise NotImplementedError\n\n    # Create the kernels as a single, complex array. Allows us to use\n    # np.abs instead of np.hypot to calculate the magnitude.\n    G = np.array(\n        [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]],\n        dtype=arr.dtype,\n    )\n    G = G + 1j * np.array(\n        [[-1, -2, -1], [0, 0, 0], [1, 2, 1]],\n        dtype=arr.dtype,\n    )\n    s = convolve2d(arr, G, mode=\"same\")\n    np.absolute(s, out=s)  # In-place abs\n    return s.real\n```", "```py\nsobel_timed = timeit(sobel_conv2d)\nsobel_timed(arr_test)\n# 14.3 ms ± 1.71 ms per loop (mean ± std. dev. of 10 runs)\n```", "```py\ndef sobel_v2(arr: NDArray, axes: Tuple[int, int] = (-2, -1)) -> NDArray:\n    # ...\n    arr = np.pad(arr, (1,))  # After padding, it is shaped (nx + 2, ny + 2)\n    s = np.zeros_like(arr)\n    for ix in range(1, arr.shape[0] - 1):\n        for iy in range(1, arr.shape[1] - 1):\n            s1 = (Gx * arr[ix - 1 : ix + 2, iy - 1 : iy + 2]).sum()\n            s2 = (Gy * arr[ix - 1 : ix + 2, iy - 1 : iy + 2]).sum()\n            s[ix - 1, iy - 1] = np.hypot(s1, s2)  # Adjust indices\n    return s\n```"]