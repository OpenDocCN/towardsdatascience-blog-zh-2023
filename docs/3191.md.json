["```py\nimport numpy as np\nfrom sklearn.decomposition import FastICA\nimport matplotlib.pyplot as plt\n\nrng = np.random.default_rng(8675309)\nt = np.linspace(0, 10, 10000)\nx = np.array([\n    np.sin(2 * np.pi * t), \n    np.sin(2 * np.pi / 2 * t + 1), \n    np.sin(2 * np.pi / 2 * 2 * t + 2)])\nmixing = rng.uniform(-1, 1, [3, 3])\n# check that our randomly generated mixing is invertible\nassert np.linalg.matrix_rank(mixing) == 3\ndemixing_true = np.linalg.inv(mixing)\n\ny = np.matmul(mixing, x)\n\nfica = FastICA(3)\nz = fica.fit_transform(np.transpose(y))\nz = np.transpose(z)\nz /= np.reshape(np.max(z, 1), (3, 1))\nfig, ax = plt.subplots(3, 1, figsize = (8, 5))\nfor ii in range(3):\n    ax[0].plot(t, x[ii])\n    ax[1].plot(t, y[ii])\n    ax[2].plot(t, z[ii])\nax[0].set_title(\"Independent Sources\")\nax[1].set_title(\"Randomly, Linearly, Instaneously Mixed Signals\")\nax[2].set_title(\"ICA Components (Match up to Sign and Linear Scaling)\")\nplt.tight_layout()\n```", "```py\nrng = np.random.default_rng(8675309)\nt = np.linspace(0, 11, 11000)\nx = np.array([\n    np.sin(2 * np.pi * t), \n    np.sin(2 * np.pi / 2 * t + 1), \n    np.sin(2 * np.pi / 2 * 2 * t + 2)])\nmixing = rng.uniform(-1, 1, [3, 3])\n# check that our randomly generated mixing is invertible\nassert np.linalg.matrix_rank(mixing) == 3\ndemixing_true = np.linalg.inv(mixing)\n\ndelays = rng.integers(100, 500, (3, 3))\ny = np.zeros(x.shape)\nfor source_i in range(3):\n    for signal_j in range(3):\n        x_ = x[source_i, delays[source_i, signal_j]:]\n        y[signal_j, :len(x_)] += mixing[source_i, signal_j] * x_\nt = t[:10000]\nx = x[:, :10000]\ny = y[:, :10000]\n\nfica = FastICA(3)\nz = fica.fit_transform(np.transpose(y))\nz = np.transpose(z)\nz /= np.reshape(np.max(z, 1), (3, 1))\nfig, ax = plt.subplots(3, 1, figsize = (8, 5))\nfor ii in range(3):\n    ax[0].plot(t, x[ii])\n    ax[1].plot(t, y[ii])\n    ax[2].plot(t, z[ii])\nax[0].set_title(\"Independent Sources\")\nax[1].set_title(\"Randomly, Linearly, Time-Delayed Mixed Signals\")\nax[2].set_title(\"ICA Components (Match up to Sign and Linear Scaling)\")\nplt.tight_layout()\n```", "```py\nrng = np.random.default_rng(8675309)\nt = np.linspace(0, 11, 11000)\nx = np.array([\n    np.sin(2 * np.pi * t), \n    np.sin(2 * np.pi / 2 * t + 1), \n    np.sin(2 * np.pi / 2 * 2 * t + 2)])\nmixing = rng.uniform(-1, 1, [3, 3])\n# check that our randomly generated mixing is invertible\nassert np.linalg.matrix_rank(mixing) == 3\ndemixing_true = np.linalg.inv(mixing)\n\ndelays = rng.integers(100, 500, (3, 3))\nimpulse_lengths = rng.integers(200, 400, (3, 3))\ny = np.zeros(x.shape)\nfor source_i in range(3):\n    for signal_j in range(3):\n        impulse_length = impulse_lengths[source_i, signal_j]\n        impulse_shape = np.sqrt(np.arange(impulse_length).astype(float))\n        impulse_shape /= np.sum(impulse_shape)\n        delay = delays[source_i, signal_j]\n        for impulse_k in range(impulse_length):\n            x_ = x[source_i, (delay + impulse_k):]\n            y[signal_j, :len(x_)] += (\n                mixing[source_i, signal_j] \n                * x_ * impulse_shape[impulse_k]\n            )\nt = t[:10000]\nx = x[:, :10000]\ny = y[:, :10000]\n\nfica = FastICA(3)\nz = fica.fit_transform(np.transpose(y))\nz = np.transpose(z)\nz /= np.reshape(np.max(z, 1), (3, 1))\nfig, ax = plt.subplots(3, 1, figsize = (8, 5))\nfor ii in range(3):\n    ax[0].plot(t, x[ii])\n    ax[1].plot(t, y[ii])\n    ax[2].plot(t, z[ii])\nax[0].set_title(\"Independent Sources\")\nax[1].set_title(\"Randomly Convolved Signals\")\nax[2].set_title(\"ICA Components (Match up to Sign and Linear Scaling)\")\nplt.tight_layout()\n```"]