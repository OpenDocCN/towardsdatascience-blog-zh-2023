["```py\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom tqdm import tqdm\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.datasets import load_diabetes, load_iris\nfrom sklearn.ensemble import RandomForestRegressor, RandomForestClassifier\nfrom sklearn.metrics import accuracy_score, r2_score\n```", "```py\nX, y = load_iris(return_X_y=True)\nX_train, X_test, y_train, y_test = train_test_split(\n  X, y, test_size=0.3, random_state=12, shuffle=True\n)\n\nrf = RandomForestClassifier(\n  n_estimators=3, random_state=32\n).fit(X_train, y_train)\n```", "```py\nprint(accuracy_score(rf.predict(X_train), y_train))\nprint(accuracy_score(rf.predict(X_test), y_test))\n```", "```py\noriginal_error_train = 1 - accuracy_score(rf.predict(X_train), y_train)\noriginal_error_test = 1 - accuracy_score(rf.predict(X_test), y_test)\n```", "```py\nn_steps = 10\n\nfeature_values = {}\nfor feature in range(X.shape[1]):\n  # We will save each new performance point for each feature\n    errors_permuted_train = []\n    errors_permuted_test = []\n\n    for step in range(n_steps):\n        # We grab the data again because the np.random.shuffle function shuffles in place\n        X, y = load_iris(return_X_y=True)\n        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=12, shuffle=True)\n        np.random.shuffle(X_train[:, feature])\n        np.random.shuffle(X_test[:, feature])\n\n    # Apply our previously fitted model on the new data to get the performance\n        errors_permuted_train.append(1 - accuracy_score(rf.predict(X_train), y_train))\n        errors_permuted_test.append(1 - accuracy_score(rf.predict(X_test), y_test))\n\n    feature_values[f'{feature}_train'] = errors_permuted_train\n    feature_values[f'{feature}_test'] = errors_permuted_test\n```", "```py\nPFI = pd.DataFrame()\nfor feature in feature_values:\n    if 'train' in feature:\n        aux = feature_values[feature] / original_error_train\n        fold = 'train'\n    elif 'test' in feature:\n        aux = feature_values[feature] / original_error_test\n        fold = 'test'\n\n    PFI = PFI.append({\n        'feature': feature.replace(f'_{fold}', ''),\n        'pfold': fold,\n        'mean':np.mean(aux),\n        'std':np.std(aux),\n    }, ignore_index=True)\n\nPFI = PFI.pivot(index='feature', columns='fold', values=['mean', 'std']).reset_index().sort_values(('mean', 'test'), ascending=False)\n```"]