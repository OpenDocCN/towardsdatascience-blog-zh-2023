- en: Hands on Otsu Thresholding Algorithm for Image Background Segmentation, using
    Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://towardsdatascience.com/hands-on-otsu-thresholding-algorithm-for-image-background-segmentation-using-python-9fa0575ac3d2?source=collection_archive---------7-----------------------#2023-03-20](https://towardsdatascience.com/hands-on-otsu-thresholding-algorithm-for-image-background-segmentation-using-python-9fa0575ac3d2?source=collection_archive---------7-----------------------#2023-03-20)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: From theory to practice with the Otsu thresholding algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://piero-paialunga.medium.com/?source=post_page-----9fa0575ac3d2--------------------------------)[![Piero
    Paialunga](../Images/de2185596a49484698733e85114dd1ff.png)](https://piero-paialunga.medium.com/?source=post_page-----9fa0575ac3d2--------------------------------)[](https://towardsdatascience.com/?source=post_page-----9fa0575ac3d2--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----9fa0575ac3d2--------------------------------)
    [Piero Paialunga](https://piero-paialunga.medium.com/?source=post_page-----9fa0575ac3d2--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ¬∑
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F254e653181d2&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhands-on-otsu-thresholding-algorithm-for-image-background-segmentation-using-python-9fa0575ac3d2&user=Piero+Paialunga&userId=254e653181d2&source=post_page-254e653181d2----9fa0575ac3d2---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----9fa0575ac3d2--------------------------------)
    ¬∑8 min read¬∑Mar 20, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F9fa0575ac3d2&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhands-on-otsu-thresholding-algorithm-for-image-background-segmentation-using-python-9fa0575ac3d2&user=Piero+Paialunga&userId=254e653181d2&source=-----9fa0575ac3d2---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F9fa0575ac3d2&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhands-on-otsu-thresholding-algorithm-for-image-background-segmentation-using-python-9fa0575ac3d2&source=-----9fa0575ac3d2---------------------bookmark_footer-----------)![](../Images/ec82b49b11dfd1d2e3831de232497bc8.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Photo by [Luke Porter](https://unsplash.com/@lukeporter?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
    on [Unsplash](https://unsplash.com/photos/SZOfKAaQYLI?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me start with a very technical concept:'
  prefs: []
  type: TYPE_NORMAL
- en: An Image will be viewed, treated, analyzed, and processed as a 2D signal.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'And some proper definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: A **signal** is a quantity that changes over space or time and can be used to
    transmit a form of information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **image** is nothing but a quantity of light that hits an optical system,
    that is the camera or the canvas where you are painting it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this sense, an image is nothing but a 2D signal, an electromagnetic signal
    that carries some information that is retrieved by a physical system.
  prefs: []
  type: TYPE_NORMAL
- en: So as we have established that an image is indeed a signal, we can think of
    applying a **signal processing** technique to an **image processing** task. We
    can thus stop discussing **philosophy** and start with the **nerd** part.
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking of philosophy. Let‚Äôs take this **image**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/882ffc2b413c45538c86ed4defa87a06.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Tingey Injury Law Firm](https://unsplash.com/it/@tingeyinjurylawfirm?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
    on [Unsplash](https://unsplash.com/photos/9SKhDFnw4c4?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
  prefs: []
  type: TYPE_NORMAL
- en: 'There is the philosopher in the image doing his job: thinking. And then there
    is this very white background, that we really don‚Äôt care about. **Can we get rid
    of it?** Can we get something like that?'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1d7edaaeca7c602dea43e254b947997a.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: If I‚Äôm asking you, it means that we can. üòÖ
  prefs: []
  type: TYPE_NORMAL
- en: Every person who knows a little bit of ***photoshop*** can do that, but how
    can you do that automatically and with Python? Again, yes.
  prefs: []
  type: TYPE_NORMAL
- en: Let me show you how üöÄ
  prefs: []
  type: TYPE_NORMAL
- en: 0\. The Idea
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So let‚Äôs take a straightforward case.
  prefs: []
  type: TYPE_NORMAL
- en: Yep. A small square inside a bigger square. This is an extremely simple case.
    What we want to do is to set all the values in the smaller square to 1 and everything
    that is outside to 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can extract the two values with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'And then do something like:'
  prefs: []
  type: TYPE_NORMAL
- en: This converts the image from two values to 1 and 0.
  prefs: []
  type: TYPE_NORMAL
- en: This is extremely simple, right? Let‚Äôs make it a little bit harder.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will do the little square inside the bigger square **but both the squares
    have some noise.**
  prefs: []
  type: TYPE_NORMAL
- en: What I mean is that we don‚Äôt have only 2 values but we can theoretically have
    **all the values between 0 and 255** which is the whole range of values in the
    encoding.
  prefs: []
  type: TYPE_NORMAL
- en: How do we deal with this?
  prefs: []
  type: TYPE_NORMAL
- en: Well, the first thing we want to do is to **flatten** the image (2D signal)
    and change it into a 1D one.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/132122519b5885a6e93186b7916ec191.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: The image was a 50x50 image and we have a ‚Äúraveled‚Äù 50x50=2500 long 1D signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now if we study the distribution of our 1D Signal we got something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5cc87aec378dd846951541988b138150.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, we have **two normal distributions**. This is **exactly** where
    the Otsu algorithm performs best. The underlying idea is that the **background**
    and the **subject** of the image have two different natures and two different
    **domains**. For example, in this case, the first gaussian bell is the one related
    to the background (let‚Äôs say from 0 to 50), while the second Gaussian bell is
    the one of the smaller square (from 150 to 250).
  prefs: []
  type: TYPE_NORMAL
- en: 'So let‚Äôs say that we decide that we set everything that is larger than 100
    as 1 and everything that is smaller as 0:'
  prefs: []
  type: TYPE_NORMAL
- en: And the result is the following mask between the **background** and the **subject:**
  prefs: []
  type: TYPE_NORMAL
- en: 'This is it. This is the whole idea of the Otsu algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Import/Read** the image as a 2D signal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flatten** the image into a 1D vector'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose a **threshold**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Set** everything that is below that threshold as 0 and everything that is
    above as 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Very easy right?
  prefs: []
  type: TYPE_NORMAL
- en: But how do we choose the proper threshold? What is the best one? Let‚Äôs talk
    about **math**.
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Theoretical Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let‚Äôs formalize this concept a little bit.
  prefs: []
  type: TYPE_NORMAL
- en: We have a **domain** of pixels in an image. The full domain goes from 0 to 255
    (white to black) but it doesn‚Äôt have to be that wide (it can be from 20 to 200
    for example).
  prefs: []
  type: TYPE_NORMAL
- en: Now, multiple points can have the same pixel intensity of course (we can have
    two black pixels in the same image). Let‚Äôs say that we have 3 pixels with an intensity
    of 255 in an image that has 100 pixels. Now the probability of having intensity
    255 in that image is 3/100.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, we can say that the probability of having pixel i in an image is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b879d59f443db2c1db2239ab874f99c1.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Now let‚Äôs say that the pixel on which we are doing the split is pixel k (in
    our previous example k was 100). This **classifies** the data points. All the
    points **before k belong to class 0** and all the points **after k belong to class
    1.**
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that the probability of picking a point from class 0 is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/269e994475d0e500da0c16f16cfdf65c.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: 'While the probability of picking a point from class 1 is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/baee39159ae78f3af2735c3fac1c14e7.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, both probabilities are obviously dependent on k.
  prefs: []
  type: TYPE_NORMAL
- en: Now, another thing that we can compute is the **variance for each class:**
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/51c36a80173951098f5a0dd8a5fc42cb.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e1009db6a01810f246e1c6387e0956da.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: 'Where:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/72e0b9a5bc808a383db17f593aaba2ec.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: And
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6383eb59617b9e87ddd063a1f0ebd8dd.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: The sigma value is the **variance** of each class aka how much the class is
    **spread** around the mean values that are mu_0 and mu_1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now theoretically the idea is to find the value that creates that little **valley**
    that we saw in this picture earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5cc87aec378dd846951541988b138150.png)'
  prefs: []
  type: TYPE_IMG
- en: But the approach that we use is slightly different and more rigorous. By using
    the same idea of the [Linear discriminant analysis](https://en.wikipedia.org/wiki/Linear_discriminant_analysis#Fisher's_linear_discriminant)
    (LDA). In the (Fisher) LDA we want to find a hyperplane that splits the two distributions
    in a way that the variance **between** classes is as big as possible (so that
    the two means are the furthest away from each other) and the variance **within**
    the classes is as small as possible (so that we don‚Äôt have too much overlap between
    the two classes data points).
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we don‚Äôt have any hyperplane and the threshold that we set (our
    k) is not even a line, but it is more of a probability value that we use to discriminate
    data points and classify them.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be proven (full proof here in the original [paper](https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=4310076))
    that the **best split** between the **background** and **subject** (is given the
    assumption that the domain of the background is different from the domain of the
    subject) is obtained by minimizing this quantity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/201fa4937a409c6adc3af5410dcfd0db.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: This means that we can try all different ks and just pick the one with the lowest
    k.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Hands On implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The theory might look complex and difficult to understand, but the implementation
    is extremely easy and it is made of three blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: 2.1 Importing the libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing that we want to do is to import 4 basic libraries that we will
    need.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2 The threshold function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you find the perfect threshold, this is how to apply it to your image:'
  prefs: []
  type: TYPE_NORMAL
- en: 2.3 The Otsu criterion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The function that will compute this quantity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/201fa4937a409c6adc3af5410dcfd0db.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: 'Is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 2.4 Best threshold computation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This other function just runs all over the possible ks and finds the best one
    according to the criterion above:'
  prefs: []
  type: TYPE_NORMAL
- en: 2.5 The whole process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So the image we are using is the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/bb682b7a3df65e2c7a6a3ed1ad6619aa.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Ben Dumond](https://unsplash.com/@bendumond?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
    on [Unsplash](https://unsplash.com/photos/VedK8_UlmkY?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
  prefs: []
  type: TYPE_NORMAL
- en: 'If we save that image in a path and we apply the Otsu algorithm we get:'
  prefs: []
  type: TYPE_NORMAL
- en: 'And if we compare im (the original image) and im_otsu (the one after the algorithm)
    we get:'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the black part of the right upper part of the picture is misinterpreted
    as the subject because it has the same tone as some of the subjects. People are
    not perfect and neither are the algorithms üôÉ
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Wrapping it up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thank you for being here with me throughout the whole path of this Otsu algorithm
    tutorial.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this brief article, we saw:'
  prefs: []
  type: TYPE_NORMAL
- en: That an **Image** can be treated as a **2D signal** and can then be analyzed
    using Signal Processing technique
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The assumption of the **Otsu algorithm,** that is the **background** and the
    **subject** of an image have two, continuous, non-overlapping, distinguished domains
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to find the **best** discrimination between the background and subject of
    an image given the Otsu algorithm. How we can interpret the Otsu algorithm as
    a Fisher Linear Discriminant.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to implement the Otsu algorithm using **Python**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to **apply** this algorithm in a real **image**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 4\. Conclusions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you liked the article and you want to know more about machine learning,
    or you just want to ask me something, you can:'
  prefs: []
  type: TYPE_NORMAL
- en: A. Follow me on [**Linkedin**](https://www.linkedin.com/in/pieropaialunga/),
    where I publish all my stories
  prefs: []
  type: TYPE_NORMAL
- en: B. Subscribe to my [**newsletter**](https://piero-paialunga.medium.com/subscribe).
    It will keep you updated about new stories and give you the chance to text me
    to receive all the corrections or doubts you may have.
  prefs: []
  type: TYPE_NORMAL
- en: C. Become a [**referred member**](https://piero-paialunga.medium.com/membership),
    so you won‚Äôt have any ‚Äúmaximum number of stories for the month‚Äù and you can read
    whatever I (and thousands of other Machine Learning and Data Science top writers)
    write about the newest technology available.
  prefs: []
  type: TYPE_NORMAL
