- en: 'Advanced Python: Dot Operator'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/advanced-python-dot-operator-809d0eb5d841?source=collection_archive---------0-----------------------#2023-10-20](https://towardsdatascience.com/advanced-python-dot-operator-809d0eb5d841?source=collection_archive---------0-----------------------#2023-10-20)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The operator that enables the object-oriented paradigm in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@ilija.lazarevic?source=post_page-----809d0eb5d841--------------------------------)[![Ilija
    Lazarevic](../Images/4a0d84af6d8fa97705ee35444d319b07.png)](https://medium.com/@ilija.lazarevic?source=post_page-----809d0eb5d841--------------------------------)[](https://towardsdatascience.com/?source=post_page-----809d0eb5d841--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----809d0eb5d841--------------------------------)
    [Ilija Lazarevic](https://medium.com/@ilija.lazarevic?source=post_page-----809d0eb5d841--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fe73ea2eae8e6&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fadvanced-python-dot-operator-809d0eb5d841&user=Ilija+Lazarevic&userId=e73ea2eae8e6&source=post_page-e73ea2eae8e6----809d0eb5d841---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----809d0eb5d841--------------------------------)
    ·13 min read·Oct 20, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F809d0eb5d841&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fadvanced-python-dot-operator-809d0eb5d841&user=Ilija+Lazarevic&userId=e73ea2eae8e6&source=-----809d0eb5d841---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F809d0eb5d841&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fadvanced-python-dot-operator-809d0eb5d841&source=-----809d0eb5d841---------------------bookmark_footer-----------)![](../Images/841c96a738ad1ab6ce24a4c82866859e.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Dot operator is one of the pillars of object oriented paradigm in Python. Photo
    by [Madeline Pere](https://unsplash.com/@mpere?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash)
    on [Unsplash](https://unsplash.com/photos/r37QcATSbD4?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash)
  prefs: []
  type: TYPE_NORMAL
- en: This time, I will write about something seemingly trivial. It is the “dot operator.”
    Most of you have already used this operator many times, without knowing or questioning
    what happens behind the scenes. And in comparison to the concept of [metaclasses](https://medium.com/towards-data-science/advanced-python-metaclasses-e32d46e0ebe3)
    that I talked about last time, this one is a bit more usable for daily tasks.
    Just kidding, you are practically using it each time you use Python for something
    more than a “Hello World.” This is precisely the reason why I thought you might
    want to dig deeper, and I want to be your guide. Let’s start the journey!
  prefs: []
  type: TYPE_NORMAL
- en: 'I will start with one trivial question: “What is a “dot operator?”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, this is surely a “Hello World” example, but I can hardly imagine someone
    starting to teach you Python exactly like this. Anyway, the “dot operator” is
    the “.” part of the`hello.upper()`. Let’s try giving a more verbose example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few places where you use the “dot operator”. To make it easier
    to see the bigger picture, let’s summarize the way you use it in two cases:'
  prefs: []
  type: TYPE_NORMAL
- en: use it to access attributes of an object or class,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: use it to access functions defined in the class definition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Obviously, we have all of this in our example, and this seems intuitive and
    as expected. But there is more to this than meets the eye! Take a closer look
    at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Somehow, `p.shout` is not referencing the same function as `Person.shout` although
    it should. At least you would expect it, right? And `p.shout` is not even a function!
    Let’s go over the next example before we start discussing what is happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For those unaware of the `vars` function, it returns the dictionary that holds
    attributes of an instance. If you run `vars(Person)` you will get a bit different
    response, but you will get the picture. There will be both attributes with their
    values and variables that hold class function definitions. There is obviously
    a difference between an object that is an instance of a class and the class object
    itself, and so there will be a difference in `vars` function response for these
    two.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is perfectly valid to additionally define a function after an object
    is created. This is the line `p.shout_v2 = shout_v2`. This does introduce another
    key-value pair in the instance dictionary. Seemingly everything is good, and we
    will be able to run smoothly, as if `shout_v2` were specified in the class definition.
    But alas! Something is truly wrong. We are not able to call it the same way as
    we did the `shout` method.
  prefs: []
  type: TYPE_NORMAL
- en: Astute readers should have noticed by now how carefully I use the terms *function*
    and *method*. After all, there is a difference in how Python prints these as well.
    Take a look at the previous examples. `shout` is a method, `shout_v2` is a function.
    At least if we look at these from the perspective of the object `p`. If we look
    at these from the perspective of the `Person` class, `shout` is a function, and
    `shout_v2` doesn’t exist. It is defined only in the object’s dictionary (namespace).
    So if you are really going to rely on object-oriented paradigms and mechanisms
    like encapsulation, inheritance, abstraction, and polymorphism, you will not define
    functions on objects, like `p` is in our example. You will make sure you are defining
    functions in a class definition (body).
  prefs: []
  type: TYPE_NORMAL
- en: So why are these two different, and why do we get the error? Well, the fastest
    answer is because of how the “dot operator” works. The longer answer is that there
    is a mechanism behind the scenes that does the (attribute) name resolution for
    you. This mechanism consists of `__getattribute__` and `__getattr__` dunder methods.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At first, this will probably sound unintuitive and rather unnecessarily complicated,
    but bear with me. Essentially, there are two scenarios that can happen when you
    try to access an attribute of an object in Python: either there is an attribute
    or there is not. Simply. In both cases, `__getattribute__` is called, or to make
    it easier for you, it is **being called always**. This method:'
  prefs: []
  type: TYPE_NORMAL
- en: returns computed attribute value,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: explicitly calls `__getattr__`, or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: raises `AttributeError` in which case `__getattr__` is called by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to intercept the mechanism that resolves attribute names, this is
    the place to hijack. You just have to be careful, because it is really easy to
    end up in an infinite loop or to mess up the whole mechanism of name resolution,
    especially in the scenario of object-oriented inheritance. It is not as simple
    as it may appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to handle cases where there is no attribute in the object’s dictionary,
    you can straight away implement the `__getattr__` method. This one gets called
    when `__getattribute__` fails to access the attribute name. If this method can’t
    find an attribute or deal with a missing one after all, it raises an `AttributeError`
    exception as well. Here is how you can play around with these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It is very important to call `super().__getattribute__(...)` in your implementation
    of `__getattribute__`, and the reason, like I wrote earlier, is that there is
    a lot going on in Python’s default implementation. And this is exactly the place
    where “dot operator” gets its magic from. Well, at least half of the magic is
    there. The other part is in how a class object is created after interpreting the
    class definition.
  prefs: []
  type: TYPE_NORMAL
- en: Class functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The term I use here is purposeful. Class does contain only *functions*, and
    we saw this in one of the first examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When looking from the object’s perspective, these are called methods. The process
    of transforming the function of a class into a method of an object is called bounding,
    and the result is what you see in the previous example, a *bound method*. What
    makes it *bound*, and to what? Well, once you have an instance of a class and
    start calling its methods, you are, in essence, passing the object reference to
    each of its methods. Remember the `self` argument? So, how does this happen, and
    who does it?
  prefs: []
  type: TYPE_NORMAL
- en: Well, the first part happens when the class body is being interpreted. There
    are quite a few things that happen in this process, like defining a class namespace,
    adding attribute values to it, defining (class) functions, and binding them to
    their names. Now, as these functions are being defined, they are being wrapped
    in a way. Wrapped in an object conceptually called ***descriptor***. This *descriptor*
    is enabling this change in the identification and behavior of class functions
    that we saw previously. I’ll make sure to write a separate blog post about *descriptors*,
    but for now, know that this object is an instance of a class that implements a
    predefined set of dunder methods. This is also called a *Protocol*. Once these
    are implemented, it is said that objects of this class *follow* the specific protocol
    and therefore behave in the expected way. There is a difference between the **data**
    and **non-data** descriptors. Former implements `__get__`, `__set__`, and/or `__delete__`
    dunder methods. Later, implement only the `__get__` method. Anyway, each function
    in a class ends up being wrapped in a so-called **non-data** descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you initiate attribute lookup by using the “dot operator”, the `__getattribute__`
    method is called, and the whole process of name resolution starts. This process
    stops when resolution is successful, and it goes something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: return the data descriptor that has the desired name (class level), or
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: return instance attribute with the desired name (instance level), or
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: return non-data descriptor with the desired name (class level), or
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: return class attribute with the desired name (class level), or
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: raise `AttributeError` that essentially calls the `__getattr__` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: My initial idea was to leave you with a reference to the official documentation
    on how this mechanism is implemented, at least a Python mockup, for learning purposes,
    but I have decided to help you out with that part as well. However, I highly advise
    you to go and read the whole page of official documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in the next code snippet, I’ll put some of the descriptions in the comments,
    so it is easier to read and understand the code. Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that this implementation is in Python for the sake of documenting
    and describing the logic implemented in the `__getattribute__` method. In reality,
    it is implemented in C. Just by looking at it, you can imagine that it is better
    not to play around with re-implementing the whole thing. The best way is to try
    doing part of the resolution by yourself and then fall back on the CPython implementation
    with `return super().__getattribute__(name)` as shown in the example above.
  prefs: []
  type: TYPE_NORMAL
- en: 'The important thing here is that each class function (which is an object) gets
    wrapped in a non-data descriptor (which is a `function` class object), and this
    means that this wrapper object has the `__get__` dunder method defined. What this
    dunder method does is return a new callable (think of it as a new function), where
    the first argument is the reference to the object on which we are performing the
    “dot operator”. I said to think about it as a new function since it is a *callable*.
    In essence, it is another object called `MethodType`. Check it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: One interesting thing certainly is this `function` class. This one is exactly
    the wrapper object that defines the `__get__` method. However, once we try to
    access it as method `shout` by “dot operator”, `__getattribute__` iterates through
    the list and stops at the third case (return non-data descriptor). This `__get__`
    method contains additional logic that takes the object’s reference and creates
    `MethodType` with reference to the `function` and object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the official documentation mockup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Disregard the difference in class name. I have been using `function` instead
    of `Function` to make it easier for grasping, but I’ll use the `Function` name
    from now on so it follows the official documentation explanation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Anyway, just by looking at this mockup, it may be enough to understand how
    this `function` class fits the picture, but let me add a couple of lines of code
    that are missing, which will probably make things even clearer. I’ll add two more
    class functions in this example, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Why did I add these functions? Well, now you can easily imagine how the `Function`
    object plays its role in this whole scenario of method bounding. This new `Function`
    object stores the original function as an attribute. This object is also *callable*
    which means that we can invoke it as a function. In that case, it works just as
    the function it wraps. Remember, everything in Python is an object, even functions.
    And `MethodType` ‘wraps’ `Function` object along with the reference to the object
    on which we are calling method (in our case `shout`).
  prefs: []
  type: TYPE_NORMAL
- en: 'How does `MethodType` do this? Well, it keeps these references and implements
    a callable protocol. Here is the official documentation mockup for the `MethodType`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Again, for brevity’s sake, `func` ends up referencing our initial class function
    (`shout`), `obj` references instance (`p`), and then we have arguments and keyword
    arguments that are passed along. `self` in the `shout` declaration ends up referencing
    this ‘obj’, which is essentially `p` in our example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the end, it should be clear why we make a distinction between functions
    and methods and how functions get bound once they are accessed through objects
    by using the “dot operator”. If you think about it, we would be perfectly okay
    with invoking class functions in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Yet, this really is not the advised way and is just plain ugly. Usually, you
    will not have to do this in your code.
  prefs: []
  type: TYPE_NORMAL
- en: So, before I conclude, I want to go over a couple of examples of attribute resolution
    just to make this easier to grasp. Let’s use the previous example and figure out
    how the dot operator works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If reading this article in one go was not an easy endeavor, do not fret! The
    whole mechanism behind the “dot operator” is not something you grasp that easily.
    There are at least two reasons, one being how `__getattribute__` does the name
    resolution, and the other being how class functions get wrapped upon class body
    interpretation. So, make sure you go over the article a couple of times and play
    with the examples. Experimenting is really what drove me to start a series called
    Advanced Python.
  prefs: []
  type: TYPE_NORMAL
- en: One more thing! If you like the way I explain things and there is something
    advanced in the world of Python that you would like to read about, shout out!
  prefs: []
  type: TYPE_NORMAL
- en: 'Previous articles in Advanced Python series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/advanced-python-functions-3be6810f92d1?source=post_page-----809d0eb5d841--------------------------------)
    [## Advanced Python: Functions'
  prefs: []
  type: TYPE_NORMAL
- en: After reading the title, you probably ask yourself something along the lines
    of, “Functions in Python are an advanced…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'towardsdatascience.com](/advanced-python-functions-3be6810f92d1?source=post_page-----809d0eb5d841--------------------------------)
    [](/advanced-python-metaclasses-e32d46e0ebe3?source=post_page-----809d0eb5d841--------------------------------)
    [## Advanced Python: Metaclasses'
  prefs: []
  type: TYPE_NORMAL
- en: A brief introduction to Python class object and how it is created
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/advanced-python-metaclasses-e32d46e0ebe3?source=post_page-----809d0eb5d841--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Invocation from an instance](https://docs.python.org/3/howto/descriptor.html#invocation-from-an-instance)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Functions and methods](https://docs.python.org/3/howto/descriptor.html#id25)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
