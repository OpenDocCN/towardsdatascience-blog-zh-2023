- en: 'Designing Operations Research Solutions: A User-friendly Routing Application
    with Streamlit'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/designing-operations-research-solutions-a-user-friendly-routing-application-with-streamlit-17212553861d?source=collection_archive---------2-----------------------#2023-09-30](https://towardsdatascience.com/designing-operations-research-solutions-a-user-friendly-routing-application-with-streamlit-17212553861d?source=collection_archive---------2-----------------------#2023-09-30)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: From mathematical models to software engineering in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@bruscalia12?source=post_page-----17212553861d--------------------------------)[![Bruno
    Scalia C. F. Leite](../Images/1042cd04be047c0811fef79ecd04e69c.png)](https://medium.com/@bruscalia12?source=post_page-----17212553861d--------------------------------)[](https://towardsdatascience.com/?source=post_page-----17212553861d--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----17212553861d--------------------------------)
    [Bruno Scalia C. F. Leite](https://medium.com/@bruscalia12?source=post_page-----17212553861d--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F3ce9b7482ef0&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fdesigning-operations-research-solutions-a-user-friendly-routing-application-with-streamlit-17212553861d&user=Bruno+Scalia+C.+F.+Leite&userId=3ce9b7482ef0&source=post_page-3ce9b7482ef0----17212553861d---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----17212553861d--------------------------------)
    ·12 min read·Sep 30, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F17212553861d&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fdesigning-operations-research-solutions-a-user-friendly-routing-application-with-streamlit-17212553861d&user=Bruno+Scalia+C.+F.+Leite&userId=3ce9b7482ef0&source=-----17212553861d---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F17212553861d&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fdesigning-operations-research-solutions-a-user-friendly-routing-application-with-streamlit-17212553861d&source=-----17212553861d---------------------bookmark_footer-----------)![](../Images/6f8bc76917461608408820ef00925fab.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Photo by [Caspar Camille Rubin](https://unsplash.com/@casparrubin?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Bridging the gap between theory and applications is essential in Operations
    Research and Data Science. Whereas theoretical foundations form the core of optimization
    solutions as they provide the means to solving complex problems, we should also
    be concerned with how to make these concepts accessible and actionable for practical
    use.
  prefs: []
  type: TYPE_NORMAL
- en: The traveling salesman problem (TSP) is undoubtedly the most extensively studied
    problem in combinatorial optimization (Rego et al., 2011). It is easy to describe
    (verbally at least) and can be used to show some possible components of modern
    routing APIs. Therefore, I just could not think of a better alternative to use
    in this story.
  prefs: []
  type: TYPE_NORMAL
- en: In this tutorial, you’ll learn how to use the Python library *Streamlit* to
    build a web application to solve the TSP based on user-provided input data. As
    we are concerned with real-world applications, the solution goes beyond just Euclidean
    distances. It should be able to extract actual road driving distances between
    points using their coordinates and incorporate these distances into the optimization
    process. To do so the OpenStreetMap API will be used.
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in understanding better theoretical aspects of numerical
    optimization, you might want to check my stories on [*Linear Programming*](/linear-programming-theory-and-applications-c67600591612)
    and the [*Vehicle Routing Problem*](https://medium.com/towards-data-science/the-vehicle-routing-problem-exact-and-heuristic-solutions-c411c0f4d734)
    (which is a generalization of the TSP).
  prefs: []
  type: TYPE_NORMAL
- en: Are you ready for some hands-on? Have a glimpse at our final results…
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/32127326f034bc751079e6edc3782952.png)'
  prefs: []
  type: TYPE_IMG
- en: Screen capture of the final application. (Animation by the author).
  prefs: []
  type: TYPE_NORMAL
- en: As the entire code might be too long to include in this story, part was just
    referenced but omitted. You can check the complete code in [this repository](https://github.com/bruscalia/tsp-app/tree/main)
    though.
  prefs: []
  type: TYPE_NORMAL
- en: The Traveling Salesman Problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The TSP consists of finding the shortest tour connecting *N* points. As the
    number of points considered increases, due to the combinatorial nature of the
    problem, finding an optimal or near-optimal solution can become very challenging.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4c59efcdeda1e2ef5f4f28f99e63ac43.png)'
  prefs: []
  type: TYPE_IMG
- en: Good quality solution for TSP with 1000 locations obtained using custom heuristics.
    (Image by the author).
  prefs: []
  type: TYPE_NORMAL
- en: 'From exact methods to heuristics and meta-heuristics, the techniques to solve
    the TSP must consider pairwise distances between elements to obtain a solution.
    Although, in this article, I will not dive into details of solution methods, consider
    a generic function to solve the TSP has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can find how to implement some solution strategies in the original [code
    repository](https://github.com/bruscalia/tsp-app). Here, however, we will focus
    on how something like `solve_tsp` can be seen as a component in software development.
  prefs: []
  type: TYPE_NORMAL
- en: Repository folder structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout this tutorial, a simple flat folder structure will be adopted with
    the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '*.streamlit*: This folder is where general Streamlit settings will be placed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*data*: The folder that stores datasets used throughout development and that
    might be regular examples.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*assets*: This folder stores elements referenced in the main app script, such
    as images, logos, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*optimizer*: An internal Python package used in the app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*app.py*: The main Streamlit script.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Dockerfile*: The instructions to build a Docker image for the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*requirements.txt*: Python dependencies to run the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*README.md*: Project description.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*.dockerignore* and *.gitignore*: As their names suggest, files ignored by
    Docker build and by Git respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: More complex applications might create a separate package for utility functions
    of the Streamlit interface itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Just be careful and ensure that you define paths in your project based on their
    relative position to the directory from where you run the script or launch the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: First, make sure you have all your dependencies installed in your Python environment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the case of the TSP app, we might face some dependency conflicts, so I suggest
    you install ortools separately with the `--no-deps` option.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the flat structure proposed, you can run the application from the root
    of the directory by running the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Or you can build a docker image using the [Dockerfile](https://github.com/bruscalia/tsp-app/blob/main/Dockerfile)
    provided in my code repository using the following command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can replace `tsp_app` by any repository name you would like and `latest`
    by any version.
  prefs: []
  type: TYPE_NORMAL
- en: Then you can execute your app by running
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let us understand better how to use the `app.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: General structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A general structure of the `app.py` script can be summarized by the following
    pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Although it might look simple, some points of this pseudocode are crucial:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When pressing a *button*, Streamlit runs the code conditioned to it and resets
    its state. So follow *Streamlit* guidelines andavoid keeping these elements inside
    the conditions of a button:'
  prefs: []
  type: TYPE_NORMAL
- en: Displayed items that should persist as the user continues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other widgets which cause the script to rerun when used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processes that neither modify session state nor write to a file/database.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And that’s why we will explore as much as possible `session_state` attributes.
    After finishing the optimization, we want to keep exploring the map even if we
    press the download button or change some configuration without pressing the “execute”
    button. Therefore, displaying the solution is conditional only to its existence
    in session_state, not to the “execute” button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, some operations might be expensive, and it is useful to cache
    their results to avoid wasting time with re-runs. Remember: *Streamlit runs your
    script from top to bottom at every user interaction or code change.*'
  prefs: []
  type: TYPE_NORMAL
- en: Basic configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As previously described, we can define general Streamlit settings in the `config.toml`
    file inside the `.streamlit` folder. In the TSP example, I used it to define colors
    and font. This is kind of a light purple layout, but you can try different colors.
    Just make sure to define them in [Hex color codes](https://htmlcolorcodes.com/).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let us start filling the content of `app.py` with the Python imports. The package
    *os* will be used to manage file paths in our operating system; *BytesIO* will
    be used to emulate an output downloadable file kept in memory instead of disk;
    *json* will be used to serialize our output solution; *List* is just a typehint.
  prefs: []
  type: TYPE_NORMAL
- en: To work with dataframes, *pandas* will be used; the solver *Highs* is imported
    from *pyomo* to solve our problem (in case of a MIP); *streamlit* is the base
    of the interface; and *streamlit_folium* will be used to insert a *folium* Map
    into the app. Additional custom functions defined in the internal package are
    also imported.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `session_state` attributes will store the *tour* of a current solution,
    the *pandas* dataframe of a given input file, the value of that solution, and
    the route coordinate path (obtained from OpenStreetMap).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Some of the utility functions used are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'driving_distances: To obtain the distance matrix from OpenStreetMap provided
    a dataframe (important to cache results here).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'upload_callback: Resets `session_state` attributes when a new input file is
    loaded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'update_path: Given a tour, obtain map coordinates of the correspoinding driving
    path to plot results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: And then let us configure the page layout. In the following script, we include
    an icon and a title for the web page; then we include the same icon on the sidebar
    and write an introduction in markdown style. I suggest you run `streamlit run
    app.py` and check the results so far.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: One of the utility functions I defined reads content from the `README.md` file
    and display this content if the user selects this option. As I want to keep the
    conditional to display the content independent of a possible re-run, I used a
    *selectbox* instead of a *button* to do so.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: And then let us define solver parameters and upload an input file…
  prefs: []
  type: TYPE_NORMAL
- en: Input data and solver parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example I included two options for input type:'
  prefs: []
  type: TYPE_NORMAL
- en: '‘xy’: Uses euclidean distances, and input data must have columns ‘x’ and ‘y’.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '‘lat-long’: Uses road driving distances, and input data must have columns ‘lat’
    and ‘long’.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I also included two solver options:'
  prefs: []
  type: TYPE_NORMAL
- en: '‘MIP’: Uses models created with *pyomo* and solved with HiGHS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '‘Heuristic’: Uses Google OR-Tools routing algorithms based on constructive
    + local search heuristics with multi-start.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These parameters as well as a solver time limit will be placed on the app sidebar
    by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To upload the file, the `file_uploader` function will be used. Notice that our
    function to reset `session_state` attributes is called on change of input.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In case the input file is not empty (None), we should read it and prepare the
    distance matrix to be ready for the optimization…
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice that previously `FORMATS` had been defined as a dictionary with functions
    that return a distance matrix given a dataframe and a problem type. These functions
    were defined in the internal module and imported into the app.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now the execution relies on pressing the “Execute” button. This is the case
    of a once-per-click process. Based on this condition, the optimizer will be executed,
    and the results will be stored in `session_state` attributes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You can include additional widgets during these function calls. For instance,
    a *spinner* or a *progress bar* might look well during execution.
  prefs: []
  type: TYPE_NORMAL
- en: And then, outside the execution conditional to the button, we can make our output
    available depending only on its own existence.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In this simple example, we are making available a *json* file with the sequence
    of points visited in the tour. If we were supposed to write a more complex output,
    such as an Excel file, *BytesIO* could have been an interesting alternative. Suppose
    you want to create a download button that makes available a dictionary of *pandas*
    dataframes. You could use something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Detailed routes with OpenStreetMap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier in the app, we used the function `request_matrix` defined in the internal
    package to obtain the distance matrix of the problem using OpenStreetMap API and
    the *Python* library *requests*. In this function, behind the scenes, we are doing
    a request like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In which:'
  prefs: []
  type: TYPE_NORMAL
- en: 'points: A string joining pairs of *longitude* and *latitude* separating coordinates
    of the same pair using “,” and different pairs using “;”.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'sources: A list of integers corresponding to sources (from) nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'destinations: Analogous to sources, but with destinations (to) nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'annotations: ‘distance’, ‘duration’, or ‘duration,distance’.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we want to obtain the detailed coordinates of the solution tour to visualize
    results. To do so, we will use a different request. Consider two functions that
    receive as an input a dataframe of elements from the tour already ordered. From
    the outputs retrieved by the API, we will create a list of tuples *latitude*,
    *longitude* and it will be passed to *folium* to create the map.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Plotting results with Folium
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now consider we have the list of tuples previously obtained by our function
    `get_coord_path`. We now must use it to create our *folium* map.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: And finally, we can combine this map with the *streamlit_folium* library to
    create an amazing visualization of results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Using the input file available in my [code repository](https://github.com/bruscalia/tsp-app)
    you can find and visualize the shortest driving route passing in all US continental
    state capitals.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/fc16f439b8452dc192af6ad452477f04.png)'
  prefs: []
  type: TYPE_IMG
- en: Shortest driving tour between all continental US state capitals. (Image by the
    author).
  prefs: []
  type: TYPE_NORMAL
- en: Deploy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, our solution runs smoothly on local execution. However, it is probable
    that you would like to share your applications with a wider audience. This is
    where deployment becomes crucial. You can access the deployed TSP app [HERE](https://tsp-app-p7zrnpfj5q-uc.a.run.app).
  prefs: []
  type: TYPE_NORMAL
- en: For this project, I chose to deploy the app using [Google Cloud Run](https://cloud.google.com/run),
    as my idea was to deploy a containerized application (using Docker) and I was
    familiar with the enviroment. A concise yet useful tutorial to do similarly is
    available in this [other story](https://medium.com/google-cloud/deploying-containers-to-cloud-run-in-5mins-b03f1d8d4a64).
    Streamlit also offers a quick guide on this topic “[How to deploy Streamlit using
    Docke](https://docs.streamlit.io/knowledge-base/tutorials/deploy/docker)r”.
  prefs: []
  type: TYPE_NORMAL
- en: For the TSP app, I addressed the dependency conflict between `ortools` and `streamlit`
    within the Dockerfile. Other deployment methods lean heavily on the `requirements.txt`
    file, which might make it harder for this specific case. However, it is worth
    checking these “[3 Easy Ways to Deploy your Streamlit Web App Online](/3-easy-ways-to-deploy-your-streamlit-web-app-online-7c88bb1024b1)”.
  prefs: []
  type: TYPE_NORMAL
- en: I wish you all the best on your journey deploying your own Operations Research
    solutions!
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike my previous Medium stories, this one emphasizes optimization and operations
    research as components in software development, exploring how they can be integrated
    with other tools to create straightforward yet impactful applications. For those
    eager to go deeper into the mechanics of numerical optimization, I recommend exploring
    my comprehensive list about it, where you can find several classical problems,
    modeling strategies, use of solvers, and theoretical aspects.
  prefs: []
  type: TYPE_NORMAL
- en: '![Bruno Scalia C. F. Leite](../Images/0c7396e41d4b598be2349eaea982c984.png)'
  prefs: []
  type: TYPE_IMG
- en: '[Bruno Scalia C. F. Leite](https://medium.com/@bruscalia12?source=post_page-----17212553861d--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: Tales of the Optimization Age
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[View list](https://medium.com/@bruscalia12/list/tales-of-the-optimization-age-c15faf64a6ca?source=post_page-----17212553861d--------------------------------)15
    stories![](../Images/848ca03a7d7366b8a040f720f5d51f5c.png)![](../Images/b79fd62ce301f6295199d983f7633588.png)![](../Images/a6e8cbe0e088f4e7b1edcf27c524b072.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this story, the convergence of optimization and software development was
    explored using the simple yet effective web development framework *Streamlit*
    and the open-source routing API *OpenStreetMap*. By combining the core concepts
    of operations research with the ease of use of a web application, it is possible
    to create amazing tools to guide decision-making processes.
  prefs: []
  type: TYPE_NORMAL
- en: Reference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rego, C., Gamboa, D., Glover, F., & Osterman, C., 2011\. Traveling salesman
    problem heuristics: Leading methods, implementations and latest advances. *European
    Journal of Operational Research*, *211*(3), 427–441.'
  prefs: []
  type: TYPE_NORMAL
