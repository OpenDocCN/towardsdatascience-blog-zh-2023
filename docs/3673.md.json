["```py\nGroup,Id,Parameter,Mean(ns),StdErr(ns)\nvector,regular,avx2,256,i16,16,16,1024,291.47,0.080141\nvector,regular,avx2,256,i16,16,16,10240,2821.6,3.3949\nvector,regular,avx2,256,i16,16,16,102400,28224,7.8341\nvector,regular,avx2,256,i16,16,16,1024000,287220,67.067\nvector,regular,avx2,256,i16,16,32,1024,285.89,0.59509\n...\n```", "```py\nlet a = RangeSetBlaze::from_iter([1, 2, 3]);\n```", "```py\n#[inline]\n    pub fn from_slice(slice: impl AsRef<[T]>) -> Self {\n        T::from_slice(slice)\n    }\n```", "```py\nlet (prefix, middle, suffix) = slice.as_simd();\n```", "```py\n[features]\nfrom_slice = []\n```", "```py\n#![cfg_attr(feature = \"from_slice\", feature(portable_simd))]\n```", "```py\n/// Creates a [`RangeSetBlaze`] from a collection of integers. It is typically many\n/// times faster than [`from_iter`][1]/[`collect`][1].\n/// On a representative benchmark, the speed up was 6Ã—.\n///\n/// **Warning: Requires the nightly compiler. Also, you must enable the `from_slice`\n/// feature in your `Cargo.toml`. For example, with the command:**\n/// ```", "```py\n///\n/// **Caution**: Compiling with `-C target-cpu=native` optimizes the binary for your current CPU architecture,\n/// which may lead to compatibility issues on other machines with different architectures.\n/// This is particularly important for distributing the binary or running it in varied environments.\n/// [1]: struct.RangeSetBlaze.html#impl-FromIterator<T>-for-RangeSetBlaze<T>\n#[cfg(feature = \"from_slice\")]\n#[inline]\npub fn from_slice(slice: impl AsRef<[T]>) -> Self {\n    T::from_slice(slice)\n}\n```", "```py\ncargo check --features from_slice\ncargo test --features from_slice\n```", "```py\ncargo test --all-features --doc\ncargo doc --no-deps --all-features --open\ncargo publish --all-features --dry-run\n```"]