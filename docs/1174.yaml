- en: 'Understanding SQL: Order of Execution'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç†è§£ SQLï¼šæ‰§è¡Œé¡ºåº
- en: åŸæ–‡ï¼š[https://towardsdatascience.com/understanding-sql-order-of-execution-ba2b4e558828?source=collection_archive---------13-----------------------#2023-04-03](https://towardsdatascience.com/understanding-sql-order-of-execution-ba2b4e558828?source=collection_archive---------13-----------------------#2023-04-03)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://towardsdatascience.com/understanding-sql-order-of-execution-ba2b4e558828?source=collection_archive---------13-----------------------#2023-04-03](https://towardsdatascience.com/understanding-sql-order-of-execution-ba2b4e558828?source=collection_archive---------13-----------------------#2023-04-03)
- en: A brief guide on how databases interpret your SQL queries
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å…³äºæ•°æ®åº“å¦‚ä½•è§£é‡Šä½ çš„ SQL æŸ¥è¯¢çš„ç®€è¦æŒ‡å—
- en: '[](https://medium.com/@dataforyou?source=post_page-----ba2b4e558828--------------------------------)[![Rob
    Taylor, PhD](../Images/5e4e86da7b77404ed42d00a60ea5eacf.png)](https://medium.com/@dataforyou?source=post_page-----ba2b4e558828--------------------------------)[](https://towardsdatascience.com/?source=post_page-----ba2b4e558828--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----ba2b4e558828--------------------------------)
    [Rob Taylor, PhD](https://medium.com/@dataforyou?source=post_page-----ba2b4e558828--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@dataforyou?source=post_page-----ba2b4e558828--------------------------------)[![Rob
    Taylor, PhD](../Images/5e4e86da7b77404ed42d00a60ea5eacf.png)](https://medium.com/@dataforyou?source=post_page-----ba2b4e558828--------------------------------)[](https://towardsdatascience.com/?source=post_page-----ba2b4e558828--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----ba2b4e558828--------------------------------)
    [Rob Taylor, PhD](https://medium.com/@dataforyou?source=post_page-----ba2b4e558828--------------------------------)'
- en: Â·
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Â·
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F98de080592fc&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funderstanding-sql-order-of-execution-ba2b4e558828&user=Rob+Taylor%2C+PhD&userId=98de080592fc&source=post_page-98de080592fc----ba2b4e558828---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----ba2b4e558828--------------------------------)
    Â·7 min readÂ·Apr 3, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fba2b4e558828&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funderstanding-sql-order-of-execution-ba2b4e558828&user=Rob+Taylor%2C+PhD&userId=98de080592fc&source=-----ba2b4e558828---------------------clap_footer-----------)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[å…³æ³¨](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F98de080592fc&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funderstanding-sql-order-of-execution-ba2b4e558828&user=Rob+Taylor%2C+PhD&userId=98de080592fc&source=post_page-98de080592fc----ba2b4e558828---------------------post_header-----------)
    å‘è¡¨åœ¨ [Towards Data Science](https://towardsdatascience.com/?source=post_page-----ba2b4e558828--------------------------------)
    Â·7 min é˜…è¯»Â·2023å¹´4æœˆ3æ—¥[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fba2b4e558828&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funderstanding-sql-order-of-execution-ba2b4e558828&user=Rob+Taylor%2C+PhD&userId=98de080592fc&source=-----ba2b4e558828---------------------clap_footer-----------)'
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fba2b4e558828&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funderstanding-sql-order-of-execution-ba2b4e558828&source=-----ba2b4e558828---------------------bookmark_footer-----------)![](../Images/ece046668873e9586d438d6fc8a35928.png)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fba2b4e558828&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funderstanding-sql-order-of-execution-ba2b4e558828&source=-----ba2b4e558828---------------------bookmark_footer-----------)![](../Images/ece046668873e9586d438d6fc8a35928.png)'
- en: Photo by [Wengang Zhai](https://unsplash.com/@wgzhai?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡ç”± [Wengang Zhai](https://unsplash.com/@wgzhai?utm_source=medium&utm_medium=referral)
    æä¾›ï¼Œæ¥æºäº [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ä»‹ç»
- en: Writing efficient SQL queries is an essential skill for any data analyst working
    with large volumes of data. Iâ€™m sure many of us have endured the pain of having
    developed a query that runs well on small scales, only to have it slowly grind
    out the results when applied to a much larger dataset.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: ç¼–å†™é«˜æ•ˆçš„ SQL æŸ¥è¯¢æ˜¯å¤„ç†å¤§æ•°æ®é‡çš„ä»»ä½•æ•°æ®åˆ†æå¸ˆå¿…å¤‡çš„æŠ€èƒ½ã€‚æˆ‘ç›¸ä¿¡æˆ‘ä»¬ä¸­çš„è®¸å¤šäººéƒ½ç»å†è¿‡è¿™æ ·çš„ç—›è‹¦ï¼šåœ¨å°è§„æ¨¡æ•°æ®ä¸Šè¿è¡Œè‰¯å¥½çš„æŸ¥è¯¢ï¼Œåº”ç”¨åˆ°å¤§è§„æ¨¡æ•°æ®é›†æ—¶å´æ…¢å¾—ä»¤äººæŠ“ç‹‚ã€‚
- en: Oftentimes, query performance can be significantly improved by simply understanding
    how a database *interprets* the query. Not only will this help you optimize queries
    for speed and performance, but it will also help debug and troubleshoot erroneous
    scripts.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: é€šå¸¸ï¼Œé€šè¿‡ç®€å•äº†è§£æ•°æ®åº“æ˜¯å¦‚ä½•*è§£æ*æŸ¥è¯¢çš„ï¼Œå¯ä»¥æ˜¾è‘—æé«˜æŸ¥è¯¢æ€§èƒ½ã€‚è¿™ä¸ä»…æœ‰åŠ©äºä¼˜åŒ–æŸ¥è¯¢é€Ÿåº¦å’Œæ€§èƒ½ï¼Œè¿˜èƒ½å¸®åŠ©è°ƒè¯•å’Œè§£å†³é”™è¯¯çš„è„šæœ¬ã€‚
- en: So today, Iâ€™m going to step you through the order in which a SQL query is executed
    and touch on some common errors that arise when building queries.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥ä»Šå¤©ï¼Œæˆ‘å°†å¸¦ä½ äº†è§£ SQL æŸ¥è¯¢çš„æ‰§è¡Œé¡ºåºï¼Œå¹¶è®¨è®ºæ„å»ºæŸ¥è¯¢æ—¶å‡ºç°çš„ä¸€äº›å¸¸è§é”™è¯¯ã€‚
- en: Declarative vs. Procedural Languages
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å£°æ˜å¼ä¸è¿‡ç¨‹å¼è¯­è¨€
- en: First, itâ€™s important to understand that SQL is a *declarative* programming
    language. This means that we define the result we want but provide no instruction
    on *how* it is achieved. This contrasts with *imperative*, or *procedural*, languages
    that require each step to produce the output to be explicitly defined. The implication
    of working with a declarative language like SQL is that, while SQL expects statements
    to be written in a specified order, the sequence in which the statements are evaluated
    *differs*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œé‡è¦çš„æ˜¯è¦äº†è§£ SQL æ˜¯ä¸€ç§*å£°æ˜å¼*ç¼–ç¨‹è¯­è¨€ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬å®šä¹‰æ‰€éœ€çš„ç»“æœï¼Œä½†ä¸æä¾›*å¦‚ä½•*å®ç°å®ƒçš„æŒ‡ä»¤ã€‚è¿™ä¸*å‘½ä»¤å¼*æˆ–*è¿‡ç¨‹å¼*è¯­è¨€å½¢æˆå¯¹æ¯”ï¼Œè¿™äº›è¯­è¨€è¦æ±‚æ¯ä¸€æ­¥äº§ç”Ÿè¾“å‡ºçš„è¿‡ç¨‹éƒ½å¿…é¡»æ˜ç¡®æŒ‡å®šã€‚ä½¿ç”¨åƒ
    SQL è¿™æ ·çš„å£°æ˜å¼è¯­è¨€çš„å«ä¹‰æ˜¯ï¼Œè™½ç„¶ SQL æœŸæœ›è¯­å¥æŒ‰ç…§ç‰¹å®šé¡ºåºç¼–å†™ï¼Œä½†è¯­å¥çš„è¯„ä¼°*é¡ºåº*ä¼šæœ‰æ‰€ä¸åŒã€‚
- en: 'To demonstrate, here is the list of the seven common clauses used when building
    SQL queries and the order they should be used in:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†æ¼”ç¤ºï¼Œä»¥ä¸‹æ˜¯æ„å»º SQL æŸ¥è¯¢æ—¶å¸¸ç”¨çš„ä¸ƒä¸ªå­å¥åŠå…¶ä½¿ç”¨é¡ºåºçš„åˆ—è¡¨ï¼š
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now compare this with the *order of execution*:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨å°†å…¶ä¸*æ‰§è¡Œé¡ºåº*è¿›è¡Œæ¯”è¾ƒï¼š
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, the statements have been shuffled around a bit. For example,
    note that while the SELECT clause is *written* first it is much lower down the
    list when it comes to execution. As weâ€™ll see shortly, itâ€™s the order of execution
    that matters most and is something an analyst must be keenly aware of.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚ä½ æ‰€è§ï¼Œè¯­å¥å·²ç»æœ‰äº›æ‰“ä¹±ã€‚ä¾‹å¦‚ï¼Œæ³¨æ„åˆ°è™½ç„¶ SELECT å­å¥*å†™åœ¨*ç¬¬ä¸€ä½ï¼Œä½†åœ¨æ‰§è¡Œæ—¶å®ƒçš„ä½ç½®è¦ä½å¾—å¤šã€‚æ­£å¦‚æˆ‘ä»¬å°†å¾ˆå¿«çœ‹åˆ°çš„ï¼Œæ‰§è¡Œé¡ºåºæ˜¯æœ€é‡è¦çš„ï¼Œè¿™æ˜¯åˆ†æå¸ˆå¿…é¡»ç‰¹åˆ«æ³¨æ„çš„ã€‚
- en: The FROM Clause
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FROM å­å¥
- en: Naturally, the database needs to know where data is coming from so this is a
    logical first step. While simpler queries might only reference a single table,
    more often the information you need exists across several tables. Accordingly,
    the JOIN statement is used in conjunction with FROM to combine source tables.
    If a join is required then the first thing the database will do is bring everything
    together.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: è‡ªç„¶ï¼Œæ•°æ®åº“éœ€è¦çŸ¥é“æ•°æ®çš„æ¥æºï¼Œå› æ­¤è¿™æ˜¯ä¸€ä¸ªé€»è¾‘ä¸Šçš„ç¬¬ä¸€æ­¥ã€‚è™½ç„¶è¾ƒç®€å•çš„æŸ¥è¯¢å¯èƒ½åªæ¶‰åŠä¸€ä¸ªè¡¨ï¼Œä½†é€šå¸¸æƒ…å†µä¸‹ï¼Œæ‰€éœ€çš„ä¿¡æ¯å­˜åœ¨äºå¤šä¸ªè¡¨ä¸­ã€‚å› æ­¤ï¼ŒJOIN è¯­å¥ä¸
    FROM è¯­å¥ä¸€èµ·ä½¿ç”¨ï¼Œä»¥åˆå¹¶æºè¡¨ã€‚å¦‚æœéœ€è¦è¿›è¡Œè”æ¥ï¼Œåˆ™æ•°æ®åº“é¦–å…ˆä¼šå°†æ‰€æœ‰å†…å®¹æ±‡é›†åœ¨ä¸€èµ·ã€‚
- en: This means that you should think about the size of the source tables, the type
    of join used, and the number of predicates used in the join. For example, reducing
    the size of source tables by selecting only the necessary columns, filtering out
    unnecessary rows, and ensuring there are common identifiers to complete the join,
    will all improve efficiency. Additionally, INNER JOINs should be preferred over
    OUTER JOINs as the former are generally faster.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ„å‘³ç€ä½ åº”è¯¥è€ƒè™‘æºè¡¨çš„å¤§å°ã€ä½¿ç”¨çš„è”æ¥ç±»å‹ä»¥åŠè”æ¥ä¸­ä½¿ç”¨çš„è°“è¯æ•°é‡ã€‚ä¾‹å¦‚ï¼Œé€šè¿‡ä»…é€‰æ‹©å¿…è¦çš„åˆ—ã€ç­›é€‰æ‰ä¸å¿…è¦çš„è¡Œï¼Œå¹¶ç¡®ä¿æœ‰å…±åŒçš„æ ‡è¯†ç¬¦ä»¥å®Œæˆè”æ¥ï¼Œæ¥å‡å°‘æºè¡¨çš„å¤§å°ï¼Œè¿™å°†æé«˜æ•ˆç‡ã€‚æ­¤å¤–ï¼ŒINNER
    JOIN åº”ä¼˜å…ˆäº OUTER JOINï¼Œå› ä¸ºå‰è€…é€šå¸¸æ›´å¿«ã€‚
- en: Ultimately, you donâ€™t want to process data that isnâ€™t needed so minimizing the
    set to work with should be a primary objective, as much as possible.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€ç»ˆï¼Œä½ ä¸å¸Œæœ›å¤„ç†ä¸å¿…è¦çš„æ•°æ®ï¼Œå› æ­¤å°†å¤„ç†çš„æ•°æ®é›†æœ€å°åŒ–åº”è¯¥æ˜¯ä¸»è¦ç›®æ ‡ï¼Œå°½å¯èƒ½åšåˆ°è¿™ä¸€ç‚¹ã€‚
- en: The WHERE Clause
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WHERE å­å¥
- en: 'This clause is used to filter a base table, or joined output, by retuning only
    those rows that meet a given condition. Any supported data type can be used to
    filter records. For example, consider the table below which lists a small number
    of Commonwealth cities, along with their populations:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: è¯¥å­å¥ç”¨äºé€šè¿‡ä»…è¿”å›æ»¡è¶³ç»™å®šæ¡ä»¶çš„è¡Œæ¥ç­›é€‰åŸºæœ¬è¡¨æˆ–è”æ¥è¾“å‡ºã€‚å¯ä»¥ä½¿ç”¨ä»»ä½•æ”¯æŒçš„æ•°æ®ç±»å‹æ¥è¿‡æ»¤è®°å½•ã€‚ä¾‹å¦‚ï¼Œè€ƒè™‘ä¸‹è¡¨ï¼Œå®ƒåˆ—å‡ºäº†å°‘é‡è‹±è”é‚¦åŸå¸‚åŠå…¶äººå£ï¼š
- en: '![](../Images/04f1f103d0beeb10dc6ede0f9113a6ff.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04f1f103d0beeb10dc6ede0f9113a6ff.png)'
- en: A small example table called â€˜citiesâ€™ (image by author).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªåä¸ºâ€˜citiesâ€™çš„å°ç¤ºä¾‹è¡¨ï¼ˆä½œè€…å›¾ç‰‡ï¼‰ã€‚
- en: 'If we were to filter this table down to only those cities in New Zealand we
    could write the following query, for example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬è¦å°†è¿™ä¸ªè¡¨è¿‡æ»¤åˆ°åªåŒ…å«æ–°è¥¿å…°çš„åŸå¸‚ï¼Œæˆ‘ä»¬å¯ä»¥å†™å‡ºå¦‚ä¸‹æŸ¥è¯¢ï¼š
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'which would return the rows containing Auckland, Christchurch, and Wellington.
    Alternatively, if we wanted to return all cities that have a population larger
    than half a million then the query would look like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°†è¿”å›åŒ…å«å¥¥å…‹å…°ã€åŸºç£åŸå’Œæƒ çµé¡¿çš„è¡Œã€‚æˆ–è€…ï¼Œå¦‚æœæˆ‘ä»¬æƒ³è¿”å›æ‰€æœ‰äººå£è¶…è¿‡äº”åä¸‡çš„åŸå¸‚ï¼Œé‚£ä¹ˆæŸ¥è¯¢å°†æ˜¯è¿™æ ·çš„ï¼š
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We could also combine these filters using the AND operator, which would return
    Auckland only:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿˜å¯ä»¥ä½¿ç”¨ AND æ“ä½œç¬¦ç»„åˆè¿™äº›è¿‡æ»¤æ¡ä»¶ï¼Œè¿™æ ·åªä¼šè¿”å›å¥¥å…‹å…°ï¼š
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'One important thing to remember about the WHERE clause is that it *cannot*
    be used to filter aggregated columns. For example, take a look at the modified
    query below:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: å…³äº WHERE å­å¥ï¼Œæœ‰ä¸€ä¸ªé‡è¦çš„äº‹æƒ…éœ€è¦è®°ä½ï¼Œé‚£å°±æ˜¯å®ƒ*ä¸èƒ½*ç”¨äºè¿‡æ»¤èšåˆåˆ—ã€‚ä¾‹å¦‚ï¼Œçœ‹çœ‹ä¸‹é¢ä¿®æ”¹åçš„æŸ¥è¯¢ï¼š
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The intent of the above query is to obtain all countries where the combined
    city population is larger than 5 million. Unfortunately, this query will fail
    because an aggregation function has been used in the WHERE statement. The issue
    is that aggregation functions require the GROUP BY clause which is executed *after*
    the WHERE clause. This means the WHERE condition cannot be evaluated because the
    database is not yet aware of any aggregated variables.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸Šè¿°æŸ¥è¯¢çš„æ„å›¾æ˜¯è·å–æ‰€æœ‰åŸå¸‚æ€»äººå£è¶…è¿‡ 500 ä¸‡çš„å›½å®¶ã€‚ä¸å¹¸çš„æ˜¯ï¼Œè¿™ä¸ªæŸ¥è¯¢ä¼šå¤±è´¥ï¼Œå› ä¸ºåœ¨ WHERE è¯­å¥ä¸­ä½¿ç”¨äº†èšåˆå‡½æ•°ã€‚é—®é¢˜åœ¨äºèšåˆå‡½æ•°éœ€è¦ GROUP
    BY å­å¥ï¼Œè€Œ GROUP BY å­å¥æ˜¯åœ¨ WHERE å­å¥*ä¹‹å*æ‰§è¡Œçš„ã€‚è¿™æ„å‘³ç€ WHERE æ¡ä»¶æ— æ³•è¢«è¯„ä¼°ï¼Œå› ä¸ºæ•°æ®åº“å°šæœªçŸ¥é“ä»»ä½•èšåˆå˜é‡ã€‚
- en: Weâ€™ll see how to remedy this shortly, but before we do letâ€™s quickly touch on
    the GROUP BY clause.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†å¾ˆå¿«çœ‹åˆ°å¦‚ä½•è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä½†åœ¨æ­¤ä¹‹å‰ï¼Œè®©æˆ‘ä»¬å¿«é€Ÿäº†è§£ä¸€ä¸‹ GROUP BY å­å¥ã€‚
- en: The GROUP BY Clause
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GROUP BY å­å¥
- en: 'As youâ€™ve probably recognized, this clause allows us to aggregate, or summarise,
    a quantity and is used in combination with functions such as COUNT(), SUM(), MIN(),
    MAX(), and the like. In effect, GROUP BY collapses the variable, or variables,
    and returns a single value for each distinct element, or combination of elements.
    For example, if we wanted to tally the city populations for each country, we can
    group them by country like so:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚ä½ å¯èƒ½å·²ç»è¯†åˆ«çš„ï¼Œè¿™ä¸ªå­å¥å…è®¸æˆ‘ä»¬èšåˆæˆ–æ±‡æ€»æ•°é‡ï¼Œå¹¶ä¸ COUNT()ã€SUM()ã€MIN()ã€MAX() ç­‰å‡½æ•°ç»“åˆä½¿ç”¨ã€‚å®é™…ä¸Šï¼ŒGROUP BY
    å°†å˜é‡æˆ–å˜é‡ç»„æŠ˜å ï¼Œå¹¶ä¸ºæ¯ä¸ªä¸åŒçš„å…ƒç´ æˆ–å…ƒç´ ç»„åˆè¿”å›ä¸€ä¸ªå•ä¸€çš„å€¼ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬æƒ³ç»Ÿè®¡æ¯ä¸ªå›½å®¶çš„åŸå¸‚äººå£ï¼Œæˆ‘ä»¬å¯ä»¥æŒ‰å›½å®¶åˆ†ç»„ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The output will then return four rows â€” one for each country â€” along with the
    aggregated population for each country listed in the table.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: è¾“å‡ºå°†è¿”å›å››è¡Œ â€”â€” æ¯ä¸ªå›½å®¶ä¸€è¡Œ â€”â€” ä»¥åŠè¡¨ä¸­åˆ—å‡ºçš„æ¯ä¸ªå›½å®¶çš„èšåˆäººå£ã€‚
- en: The HAVING Clause
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HAVING å­å¥
- en: 'This clause solves the problem encountered earlier when trying to filter using
    an aggregation function with the WHERE clause. The HAVING clause allows us to
    filter results using grouped and aggregated data because it is executed *after*
    the GROUP BY statement. The database is now aware of the aggregations meaning
    they can be used in all statements that follow. We can now amend the earlier query
    like so:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªå­å¥è§£å†³äº†ä¹‹å‰å°è¯•ä½¿ç”¨èšåˆå‡½æ•°è¿›è¡Œè¿‡æ»¤æ—¶é‡åˆ°çš„é—®é¢˜ï¼Œå³ WHERE å­å¥ã€‚HAVING å­å¥å…è®¸æˆ‘ä»¬ä½¿ç”¨åˆ†ç»„å’Œèšåˆçš„æ•°æ®è¿›è¡Œç»“æœè¿‡æ»¤ï¼Œå› ä¸ºå®ƒæ˜¯åœ¨ GROUP
    BY è¯­å¥*ä¹‹å*æ‰§è¡Œçš„ã€‚æ•°æ®åº“ç°åœ¨å·²ç»çŸ¥é“äº†è¿™äº›èšåˆï¼Œè¿™æ„å‘³ç€å®ƒä»¬å¯ä»¥åœ¨æ‰€æœ‰åç»­çš„è¯­å¥ä¸­ä½¿ç”¨ã€‚æˆ‘ä»¬ç°åœ¨å¯ä»¥åƒè¿™æ ·ä¿®æ”¹ä¹‹å‰çš„æŸ¥è¯¢ï¼š
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will return just two countries: Australia and England.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°†åªè¿”å›ä¸¤ä¸ªå›½å®¶ï¼šæ¾³å¤§åˆ©äºšå’Œè‹±å›½ã€‚
- en: The SELECT Clause
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SELECT å­å¥
- en: The SELECT clause is where we define the columns we want in our table, along
    with any grouped and aggregated fields. This is also where we can apply *column
    aliases* using the AS operator. Now, while the select statement comes first when
    building our queries, it isnâ€™t executed until the data have been sourced and filtered.
    This is important to recognize because what this means is that aggregated variables
    and aliases *cannot* be used in WHERE, GROUP BY, or HAVING statements.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT å­å¥æ˜¯æˆ‘ä»¬å®šä¹‰æ‰€éœ€åˆ—çš„åœ°æ–¹ï¼ŒåŒæ—¶è¿˜åŒ…æ‹¬ä»»ä½•åˆ†ç»„å’Œèšåˆå­—æ®µã€‚è¿™ä¹Ÿæ˜¯æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ AS æ“ä½œç¬¦åº”ç”¨*åˆ—åˆ«å*çš„åœ°æ–¹ã€‚ç°åœ¨ï¼Œè™½ç„¶ select
    è¯­å¥åœ¨æ„å»ºæŸ¥è¯¢æ—¶æ’åœ¨é¦–ä½ï¼Œä½†å®ƒä¸ä¼šåœ¨æ•°æ®è¢«æºåŒ–å’Œè¿‡æ»¤åæ‰§è¡Œã€‚è¿™ä¸€ç‚¹å¾ˆé‡è¦ï¼Œå› ä¸ºè¿™æ„å‘³ç€èšåˆå˜é‡å’Œåˆ«å*ä¸èƒ½*åœ¨ WHEREã€GROUP BY æˆ– HAVING
    è¯­å¥ä¸­ä½¿ç”¨ã€‚
- en: For example, consider the following query that creates a column alias **total_pop**
    which is then used with the HAVING clause. This query will throw an error because
    the alias has not yet been created. The HAVING clause *precedes* the SELECT clause
    so there is nothing called **total_pop** toreference**.**
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œè€ƒè™‘ä»¥ä¸‹æŸ¥è¯¢ï¼Œå®ƒåˆ›å»ºäº†ä¸€ä¸ªåˆ—åˆ«å**total_pop**ï¼Œç„¶ååœ¨HAVINGå­å¥ä¸­ä½¿ç”¨ã€‚è¿™ä¸ªæŸ¥è¯¢ä¼šæŠ›å‡ºé”™è¯¯ï¼Œå› ä¸ºåˆ«åå°šæœªåˆ›å»ºã€‚HAVINGå­å¥*ä½äº*
    SELECTå­å¥ä¹‹å‰ï¼Œå› æ­¤æ²¡æœ‰åä¸º**total_pop**çš„å¼•ç”¨**ã€‚
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: I wonâ€™t go into detail on these, but the DISTINCT and UNION statements are executed
    *after* SELECT and *before* the ORDER BY clause, with DISTINCT executed before
    UNION.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä¸ä¼šè¯¦ç»†è®²è§£è¿™äº›å†…å®¹ï¼Œä½†DISTINCTå’ŒUNIONè¯­å¥æ˜¯åœ¨SELECTä¹‹å*æ‰§è¡Œ*ï¼Œåœ¨ORDER BYå­å¥ä¹‹å‰æ‰§è¡Œï¼Œå…¶ä¸­DISTINCTåœ¨UNIONä¹‹å‰æ‰§è¡Œã€‚
- en: The ORDER BY Clause
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ORDER BY å­å¥
- en: Weâ€™re now reaching the end and much of the heavy lifting has been done. We have
    sourced (and possibly joined) tables, applied some filtering, grouped and aggregated
    some fields, and specified the columns we want to be included in our final table.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç°åœ¨æ¥è¿‘å°¾å£°ï¼Œè®¸å¤šé‡è¦çš„å·¥ä½œå·²ç»å®Œæˆã€‚æˆ‘ä»¬å·²ç»æ¥æºï¼ˆå¹¶å¯èƒ½è”æ¥ï¼‰äº†è¡¨ï¼Œåº”ç”¨äº†ä¸€äº›è¿‡æ»¤ï¼Œåˆ†ç»„å¹¶æ±‡æ€»äº†ä¸€äº›å­—æ®µï¼Œå¹¶æŒ‡å®šäº†æˆ‘ä»¬å¸Œæœ›åœ¨æœ€ç»ˆè¡¨ä¸­åŒ…å«çš„åˆ—ã€‚
- en: At this point, youâ€™re likely thinking about how you want the data arranged in
    the target table. For example, you might have rows ordered chronologically, or
    perhaps ordered based on some ranking value. This is precisely what the ORDER
    BY clause does.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªé˜¶æ®µï¼Œä½ å¯èƒ½ä¼šè€ƒè™‘ä½ å¸Œæœ›ç›®æ ‡è¡¨ä¸­æ•°æ®çš„æ’åˆ—æ–¹å¼ã€‚ä¾‹å¦‚ï¼Œä½ å¯èƒ½å¸Œæœ›æŒ‰æ—¶é—´é¡ºåºæ’åˆ—è¡Œï¼Œæˆ–è€…åŸºäºæŸäº›æ’åå€¼è¿›è¡Œæ’åºã€‚è¿™æ­£æ˜¯ORDER BYå­å¥çš„ä½œç”¨ã€‚
- en: 'The nice about this statement is that, because itâ€™s at the backend of the order,
    we can use aggregations and column aliases in our GROUP BY statements. For example,
    suppose we wanted to order country by total city population. We could write a
    query like the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªè¯­å¥çš„å¥½å¤„åœ¨äºï¼Œå› ä¸ºå®ƒä½äºæ’åºçš„åç«¯ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨GROUP BYè¯­å¥ä¸­ä½¿ç”¨èšåˆå’Œåˆ—åˆ«åã€‚ä¾‹å¦‚ï¼Œå‡è®¾æˆ‘ä»¬æƒ³æŒ‰åŸå¸‚æ€»äººå£å¯¹å›½å®¶è¿›è¡Œæ’åºã€‚æˆ‘ä»¬å¯ä»¥ç¼–å†™å¦‚ä¸‹æŸ¥è¯¢ï¼š
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note here that we can use the column alias **total_pop** in the ORDER BY statement.
    By default, this will return records in ascending order (i.e., smallest to largest).
    To return the rows in descending order we can use the DESC operator like so:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·æ³¨æ„ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ORDER BYè¯­å¥ä¸­ä½¿ç”¨åˆ—åˆ«å**total_pop**ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œè¿™å°†æŒ‰å‡åºè¿”å›è®°å½•ï¼ˆå³ä»å°åˆ°å¤§ï¼‰ã€‚è¦æŒ‰é™åºè¿”å›è¡Œï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨DESCè¿ç®—ç¬¦ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The LIMIT Clause
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LIMIT å­å¥
- en: 'When dealing with large tables itâ€™s often not optimal to have the query return
    all rows, particularly when youâ€™re only developing and testing. The LIMIT clause
    is exceedingly useful here and allows us to define the number of rows we want
    back. Itâ€™s also used in combination with the ORDER BY clause to return the *n*-top
    or *n*-bottom records. For example, suppose we wanted the top three most populous
    cities in the table. We could use the ORDER BY and LIMIT clauses as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å¤„ç†å¤§å‹è¡¨æ—¶ï¼Œé€šå¸¸ä¸å»ºè®®è®©æŸ¥è¯¢è¿”å›æ‰€æœ‰è¡Œï¼Œç‰¹åˆ«æ˜¯åœ¨ä½ ä»…è¿›è¡Œå¼€å‘å’Œæµ‹è¯•æ—¶ã€‚LIMITå­å¥åœ¨è¿™é‡Œéå¸¸æœ‰ç”¨ï¼Œå…è®¸æˆ‘ä»¬å®šä¹‰å¸Œæœ›è¿”å›çš„è¡Œæ•°ã€‚å®ƒä¹Ÿå¯ä»¥ä¸ORDER
    BYå­å¥ç»“åˆä½¿ç”¨ï¼Œä»¥è¿”å›*å‰n*æˆ–*ån*æ¡è®°å½•ã€‚ä¾‹å¦‚ï¼Œå‡è®¾æˆ‘ä»¬æƒ³è¦è¡¨ä¸­äººå£æœ€å¤šçš„å‰ä¸‰ä¸ªåŸå¸‚ã€‚æˆ‘ä»¬å¯ä»¥å¦‚ä¸‹ä½¿ç”¨ORDER BYå’ŒLIMITå­å¥ï¼š
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that not all databases support the LIMIT statement, but they will have
    equivalents that perform a similar function.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·æ³¨æ„ï¼Œå¹¶éæ‰€æœ‰æ•°æ®åº“éƒ½æ”¯æŒLIMITè¯­å¥ï¼Œä½†å®ƒä»¬ä¼šæœ‰æ‰§è¡Œç±»ä¼¼åŠŸèƒ½çš„ç­‰æ•ˆè¯­å¥ã€‚
- en: Wrapping Up
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: æ€»ç»“
- en: The order in which statements are executed is an important concept to grasp
    when building SQL queries, and weâ€™ve touched on some common gotchas that can occur.
    Though I havenâ€™t provided in-depth examples I hope this brief little primer gets
    you thinking about how to improve your query performance, and if youâ€™re just starting
    out with SQL, I hope this article helps you along your journey.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: è¯­å¥æ‰§è¡Œçš„é¡ºåºæ˜¯æ„å»ºSQLæŸ¥è¯¢æ—¶éœ€è¦æŒæ¡çš„é‡è¦æ¦‚å¿µï¼Œæˆ‘ä»¬å·²ç»è§¦åŠäº†ä¸€äº›å¸¸è§çš„é™·é˜±ã€‚è™½ç„¶æˆ‘æ²¡æœ‰æä¾›è¯¦ç»†çš„ç¤ºä¾‹ï¼Œä½†æˆ‘å¸Œæœ›è¿™ä¸ªç®€çŸ­çš„å…¥é—¨ä»‹ç»èƒ½è®©ä½ æ€è€ƒå¦‚ä½•æé«˜æŸ¥è¯¢æ€§èƒ½ã€‚å¦‚æœä½ åˆšåˆšå¼€å§‹æ¥è§¦SQLï¼Œå¸Œæœ›è¿™ç¯‡æ–‡ç« èƒ½å¸®åŠ©ä½ åœ¨å­¦ä¹ çš„æ—…ç¨‹ä¸­å‰è¿›ã€‚
- en: Thanks for reading!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: æ„Ÿè°¢é˜…è¯»ï¼
- en: If you enjoyed this post and would like to stay up to date then please consider
    [following me on Medium.](https://medium.com/@dataforyou) This will ensure you
    donâ€™t miss out on any new content.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ å–œæ¬¢è¿™ç¯‡æ–‡ç« å¹¶å¸Œæœ›ä¿æŒæ›´æ–°ï¼Œè¯·è€ƒè™‘[å…³æ³¨æˆ‘åœ¨Mediumä¸Šçš„è´¦å·ã€‚](https://medium.com/@dataforyou) è¿™å°†ç¡®ä¿ä½ ä¸ä¼šé”™è¿‡ä»»ä½•æ–°å†…å®¹ã€‚
- en: To get unlimited access to all content consider signing up for a [Medium subscription](https://medium.com/membership).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: è¦è·å¾—æ‰€æœ‰å†…å®¹çš„æ— é™è®¿é—®æƒï¼Œè¯·è€ƒè™‘è®¢é˜…[Medium](https://medium.com/membership)ã€‚
- en: You can also follow me on [Twitter](https://twitter.com/dataforyounz), [LinkedIn](https://www.linkedin.com/in/dataforyou/),
    or check out my [GitHub](https://github.com/dataforyounz) if thatâ€™s more your
    thing ğŸ˜‰
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ è¿˜å¯ä»¥åœ¨ [Twitter](https://twitter.com/dataforyounz)ã€[LinkedIn](https://www.linkedin.com/in/dataforyou/)
    ä¸Šå…³æ³¨æˆ‘ï¼Œæˆ–è€…æŸ¥çœ‹æˆ‘çš„ [GitHub](https://github.com/dataforyounz)ï¼Œå¦‚æœä½ æ›´å–œæ¬¢è¿™æ ·çš„è¯ ğŸ˜‰
