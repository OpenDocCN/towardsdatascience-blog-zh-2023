- en: 'Understanding SQL: Order of Execution'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: åŽŸæ–‡ï¼š[https://towardsdatascience.com/understanding-sql-order-of-execution-ba2b4e558828?source=collection_archive---------13-----------------------#2023-04-03](https://towardsdatascience.com/understanding-sql-order-of-execution-ba2b4e558828?source=collection_archive---------13-----------------------#2023-04-03)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A brief guide on how databases interpret your SQL queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@dataforyou?source=post_page-----ba2b4e558828--------------------------------)[![Rob
    Taylor, PhD](../Images/5e4e86da7b77404ed42d00a60ea5eacf.png)](https://medium.com/@dataforyou?source=post_page-----ba2b4e558828--------------------------------)[](https://towardsdatascience.com/?source=post_page-----ba2b4e558828--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----ba2b4e558828--------------------------------)
    [Rob Taylor, PhD](https://medium.com/@dataforyou?source=post_page-----ba2b4e558828--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: Â·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F98de080592fc&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funderstanding-sql-order-of-execution-ba2b4e558828&user=Rob+Taylor%2C+PhD&userId=98de080592fc&source=post_page-98de080592fc----ba2b4e558828---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----ba2b4e558828--------------------------------)
    Â·7 min readÂ·Apr 3, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fba2b4e558828&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funderstanding-sql-order-of-execution-ba2b4e558828&user=Rob+Taylor%2C+PhD&userId=98de080592fc&source=-----ba2b4e558828---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fba2b4e558828&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funderstanding-sql-order-of-execution-ba2b4e558828&source=-----ba2b4e558828---------------------bookmark_footer-----------)![](../Images/ece046668873e9586d438d6fc8a35928.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Photo by [Wengang Zhai](https://unsplash.com/@wgzhai?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing efficient SQL queries is an essential skill for any data analyst working
    with large volumes of data. Iâ€™m sure many of us have endured the pain of having
    developed a query that runs well on small scales, only to have it slowly grind
    out the results when applied to a much larger dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Oftentimes, query performance can be significantly improved by simply understanding
    how a database *interprets* the query. Not only will this help you optimize queries
    for speed and performance, but it will also help debug and troubleshoot erroneous
    scripts.
  prefs: []
  type: TYPE_NORMAL
- en: So today, Iâ€™m going to step you through the order in which a SQL query is executed
    and touch on some common errors that arise when building queries.
  prefs: []
  type: TYPE_NORMAL
- en: Declarative vs. Procedural Languages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, itâ€™s important to understand that SQL is a *declarative* programming
    language. This means that we define the result we want but provide no instruction
    on *how* it is achieved. This contrasts with *imperative*, or *procedural*, languages
    that require each step to produce the output to be explicitly defined. The implication
    of working with a declarative language like SQL is that, while SQL expects statements
    to be written in a specified order, the sequence in which the statements are evaluated
    *differs*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate, here is the list of the seven common clauses used when building
    SQL queries and the order they should be used in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now compare this with the *order of execution*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the statements have been shuffled around a bit. For example,
    note that while the SELECT clause is *written* first it is much lower down the
    list when it comes to execution. As weâ€™ll see shortly, itâ€™s the order of execution
    that matters most and is something an analyst must be keenly aware of.
  prefs: []
  type: TYPE_NORMAL
- en: The FROM Clause
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Naturally, the database needs to know where data is coming from so this is a
    logical first step. While simpler queries might only reference a single table,
    more often the information you need exists across several tables. Accordingly,
    the JOIN statement is used in conjunction with FROM to combine source tables.
    If a join is required then the first thing the database will do is bring everything
    together.
  prefs: []
  type: TYPE_NORMAL
- en: This means that you should think about the size of the source tables, the type
    of join used, and the number of predicates used in the join. For example, reducing
    the size of source tables by selecting only the necessary columns, filtering out
    unnecessary rows, and ensuring there are common identifiers to complete the join,
    will all improve efficiency. Additionally, INNER JOINs should be preferred over
    OUTER JOINs as the former are generally faster.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, you donâ€™t want to process data that isnâ€™t needed so minimizing the
    set to work with should be a primary objective, as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: The WHERE Clause
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This clause is used to filter a base table, or joined output, by retuning only
    those rows that meet a given condition. Any supported data type can be used to
    filter records. For example, consider the table below which lists a small number
    of Commonwealth cities, along with their populations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/04f1f103d0beeb10dc6ede0f9113a6ff.png)'
  prefs: []
  type: TYPE_IMG
- en: A small example table called â€˜citiesâ€™ (image by author).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to filter this table down to only those cities in New Zealand we
    could write the following query, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'which would return the rows containing Auckland, Christchurch, and Wellington.
    Alternatively, if we wanted to return all cities that have a population larger
    than half a million then the query would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We could also combine these filters using the AND operator, which would return
    Auckland only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'One important thing to remember about the WHERE clause is that it *cannot*
    be used to filter aggregated columns. For example, take a look at the modified
    query below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The intent of the above query is to obtain all countries where the combined
    city population is larger than 5 million. Unfortunately, this query will fail
    because an aggregation function has been used in the WHERE statement. The issue
    is that aggregation functions require the GROUP BY clause which is executed *after*
    the WHERE clause. This means the WHERE condition cannot be evaluated because the
    database is not yet aware of any aggregated variables.
  prefs: []
  type: TYPE_NORMAL
- en: Weâ€™ll see how to remedy this shortly, but before we do letâ€™s quickly touch on
    the GROUP BY clause.
  prefs: []
  type: TYPE_NORMAL
- en: The GROUP BY Clause
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As youâ€™ve probably recognized, this clause allows us to aggregate, or summarise,
    a quantity and is used in combination with functions such as COUNT(), SUM(), MIN(),
    MAX(), and the like. In effect, GROUP BY collapses the variable, or variables,
    and returns a single value for each distinct element, or combination of elements.
    For example, if we wanted to tally the city populations for each country, we can
    group them by country like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The output will then return four rows â€” one for each country â€” along with the
    aggregated population for each country listed in the table.
  prefs: []
  type: TYPE_NORMAL
- en: The HAVING Clause
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This clause solves the problem encountered earlier when trying to filter using
    an aggregation function with the WHERE clause. The HAVING clause allows us to
    filter results using grouped and aggregated data because it is executed *after*
    the GROUP BY statement. The database is now aware of the aggregations meaning
    they can be used in all statements that follow. We can now amend the earlier query
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return just two countries: Australia and England.'
  prefs: []
  type: TYPE_NORMAL
- en: The SELECT Clause
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SELECT clause is where we define the columns we want in our table, along
    with any grouped and aggregated fields. This is also where we can apply *column
    aliases* using the AS operator. Now, while the select statement comes first when
    building our queries, it isnâ€™t executed until the data have been sourced and filtered.
    This is important to recognize because what this means is that aggregated variables
    and aliases *cannot* be used in WHERE, GROUP BY, or HAVING statements.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider the following query that creates a column alias **total_pop**
    which is then used with the HAVING clause. This query will throw an error because
    the alias has not yet been created. The HAVING clause *precedes* the SELECT clause
    so there is nothing called **total_pop** toreference**.**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: I wonâ€™t go into detail on these, but the DISTINCT and UNION statements are executed
    *after* SELECT and *before* the ORDER BY clause, with DISTINCT executed before
    UNION.
  prefs: []
  type: TYPE_NORMAL
- en: The ORDER BY Clause
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Weâ€™re now reaching the end and much of the heavy lifting has been done. We have
    sourced (and possibly joined) tables, applied some filtering, grouped and aggregated
    some fields, and specified the columns we want to be included in our final table.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, youâ€™re likely thinking about how you want the data arranged in
    the target table. For example, you might have rows ordered chronologically, or
    perhaps ordered based on some ranking value. This is precisely what the ORDER
    BY clause does.
  prefs: []
  type: TYPE_NORMAL
- en: 'The nice about this statement is that, because itâ€™s at the backend of the order,
    we can use aggregations and column aliases in our GROUP BY statements. For example,
    suppose we wanted to order country by total city population. We could write a
    query like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Note here that we can use the column alias **total_pop** in the ORDER BY statement.
    By default, this will return records in ascending order (i.e., smallest to largest).
    To return the rows in descending order we can use the DESC operator like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The LIMIT Clause
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When dealing with large tables itâ€™s often not optimal to have the query return
    all rows, particularly when youâ€™re only developing and testing. The LIMIT clause
    is exceedingly useful here and allows us to define the number of rows we want
    back. Itâ€™s also used in combination with the ORDER BY clause to return the *n*-top
    or *n*-bottom records. For example, suppose we wanted the top three most populous
    cities in the table. We could use the ORDER BY and LIMIT clauses as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that not all databases support the LIMIT statement, but they will have
    equivalents that perform a similar function.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The order in which statements are executed is an important concept to grasp
    when building SQL queries, and weâ€™ve touched on some common gotchas that can occur.
    Though I havenâ€™t provided in-depth examples I hope this brief little primer gets
    you thinking about how to improve your query performance, and if youâ€™re just starting
    out with SQL, I hope this article helps you along your journey.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks for reading!
  prefs: []
  type: TYPE_NORMAL
- en: If you enjoyed this post and would like to stay up to date then please consider
    [following me on Medium.](https://medium.com/@dataforyou) This will ensure you
    donâ€™t miss out on any new content.
  prefs: []
  type: TYPE_NORMAL
- en: To get unlimited access to all content consider signing up for a [Medium subscription](https://medium.com/membership).
  prefs: []
  type: TYPE_NORMAL
- en: You can also follow me on [Twitter](https://twitter.com/dataforyounz), [LinkedIn](https://www.linkedin.com/in/dataforyou/),
    or check out my [GitHub](https://github.com/dataforyounz) if thatâ€™s more your
    thing ðŸ˜‰
  prefs: []
  type: TYPE_NORMAL
