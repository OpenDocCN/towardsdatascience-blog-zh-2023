- en: 'The Vehicle Routing Problem: Exact and Heuristic Solutions'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: è½¦è¾†è·¯å¾„é—®é¢˜ï¼šç²¾ç¡®ä¸å¯å‘å¼è§£å†³æ–¹æ¡ˆ
- en: åŸæ–‡ï¼š[https://towardsdatascience.com/the-vehicle-routing-problem-exact-and-heuristic-solutions-c411c0f4d734?source=collection_archive---------0-----------------------#2023-08-04](https://towardsdatascience.com/the-vehicle-routing-problem-exact-and-heuristic-solutions-c411c0f4d734?source=collection_archive---------0-----------------------#2023-08-04)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[åŸæ–‡](https://towardsdatascience.com/the-vehicle-routing-problem-exact-and-heuristic-solutions-c411c0f4d734?source=collection_archive---------0-----------------------#2023-08-04)'
- en: Understand how to solve complex routing problems with Python
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: äº†è§£å¦‚ä½•ç”¨Pythonè§£å†³å¤æ‚çš„è·¯ç”±é—®é¢˜
- en: '[](https://medium.com/@bruscalia12?source=post_page-----c411c0f4d734--------------------------------)[![Bruno
    Scalia C. F. Leite](../Images/1042cd04be047c0811fef79ecd04e69c.png)](https://medium.com/@bruscalia12?source=post_page-----c411c0f4d734--------------------------------)[](https://towardsdatascience.com/?source=post_page-----c411c0f4d734--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----c411c0f4d734--------------------------------)
    [Bruno Scalia C. F. Leite](https://medium.com/@bruscalia12?source=post_page-----c411c0f4d734--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@bruscalia12?source=post_page-----c411c0f4d734--------------------------------)[![å¸ƒé²è¯ºÂ·æ–¯å¡åˆ©äºš
    C. F. è±ç‰¹](../Images/1042cd04be047c0811fef79ecd04e69c.png)](https://medium.com/@bruscalia12?source=post_page-----c411c0f4d734--------------------------------)[](https://towardsdatascience.com/?source=post_page-----c411c0f4d734--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----c411c0f4d734--------------------------------)
    [å¸ƒé²è¯ºÂ·æ–¯å¡åˆ©äºš C. F. è±ç‰¹](https://medium.com/@bruscalia12?source=post_page-----c411c0f4d734--------------------------------)'
- en: Â·
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Â·
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F3ce9b7482ef0&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fthe-vehicle-routing-problem-exact-and-heuristic-solutions-c411c0f4d734&user=Bruno+Scalia+C.+F.+Leite&userId=3ce9b7482ef0&source=post_page-3ce9b7482ef0----c411c0f4d734---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----c411c0f4d734--------------------------------)
    Â·13 min readÂ·Aug 4, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fc411c0f4d734&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fthe-vehicle-routing-problem-exact-and-heuristic-solutions-c411c0f4d734&user=Bruno+Scalia+C.+F.+Leite&userId=3ce9b7482ef0&source=-----c411c0f4d734---------------------clap_footer-----------)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[å…³æ³¨](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F3ce9b7482ef0&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fthe-vehicle-routing-problem-exact-and-heuristic-solutions-c411c0f4d734&user=Bruno+Scalia+C.+F.+Leite&userId=3ce9b7482ef0&source=post_page-3ce9b7482ef0----c411c0f4d734---------------------post_header-----------)
    å‘è¡¨åœ¨ [Towards Data Science](https://towardsdatascience.com/?source=post_page-----c411c0f4d734--------------------------------)
    Â·13åˆ†é’Ÿé˜…è¯»Â·2023å¹´8æœˆ4æ—¥[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fc411c0f4d734&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fthe-vehicle-routing-problem-exact-and-heuristic-solutions-c411c0f4d734&user=Bruno+Scalia+C.+F.+Leite&userId=3ce9b7482ef0&source=-----c411c0f4d734---------------------clap_footer-----------)'
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fc411c0f4d734&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fthe-vehicle-routing-problem-exact-and-heuristic-solutions-c411c0f4d734&source=-----c411c0f4d734---------------------bookmark_footer-----------)![](../Images/f93bccab1e4c779b83d2245412c6d584.png)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fc411c0f4d734&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fthe-vehicle-routing-problem-exact-and-heuristic-solutions-c411c0f4d734&source=-----c411c0f4d734---------------------bookmark_footer-----------)![](../Images/f93bccab1e4c779b83d2245412c6d584.png)'
- en: Photo by [Nik Shuliahin ğŸ’›ğŸ’™](https://unsplash.com/@tjump?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ç…§ç‰‡ç”± [Nik Shuliahin ğŸ’›ğŸ’™](https://unsplash.com/@tjump?utm_source=medium&utm_medium=referral)
    æä¾›ï¼Œæ¥æºäº [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: The Vehicle Routing Problem (VRP) aims to determine the best set of routes to
    be performed by a fleet of vehicles to serve a given set of customers. Due to
    its several applications and challenging combinatorial aspects, it is one of the
    most studied problems in Operations Research and Numerical Optimization.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: è½¦è¾†è·¯å¾„é—®é¢˜ï¼ˆVRPï¼‰çš„ç›®æ ‡æ˜¯ç¡®å®šç”±ä¸€ç»„è½¦è¾†æ‰§è¡Œçš„æœ€ä½³è·¯å¾„é›†åˆï¼Œä»¥æœåŠ¡äºä¸€ç»„æŒ‡å®šçš„å®¢æˆ·ã€‚ç”±äºå…¶å¤šç§åº”ç”¨å’Œå…·æœ‰æŒ‘æˆ˜æ€§çš„ç»„åˆç‰¹æ€§ï¼Œå®ƒæ˜¯è¿ç­¹å­¦å’Œæ•°å€¼ä¼˜åŒ–ä¸­ç ”ç©¶æœ€å¤šçš„é—®é¢˜ä¹‹ä¸€ã€‚
- en: The Capacitated Vehicle Routing Problem (CVRP) is one of the most common variants,
    as it introduces vehicles with limited load capacity and possibly duration/distance
    constraints. Other usual variants also introduce multiple depots, heterogeneous
    fleets, pickup and deliveries, and time-window constraints.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: å…·æœ‰è´Ÿè½½ï¼ˆå’ŒæŒç»­æ—¶é—´ï¼‰çº¦æŸçš„å®¹é‡è½¦è¾†è·¯å¾„é—®é¢˜ï¼ˆCVRPï¼‰æ˜¯æœ€å¸¸è§çš„å˜ç§ä¹‹ä¸€ï¼Œå› ä¸ºå®ƒå¼•å…¥äº†è´Ÿè½½å®¹é‡æœ‰é™çš„è½¦è¾†ä»¥åŠå¯èƒ½çš„æŒç»­æ—¶é—´/è·ç¦»çº¦æŸã€‚å…¶ä»–å¸¸è§çš„å˜ç§è¿˜å¼•å…¥äº†å¤šä¸ªä»“åº“ã€å¼‚è´¨è½¦é˜Ÿã€å–è´§å’Œé…é€ä»¥åŠæ—¶é—´çª—çº¦æŸã€‚
- en: Combinatorial aspects of these problems are such that considering a simple set
    of 15 points, there are 6 Ã— 10Â¹Â¹ possible routes connecting them (Dantzig & Ramser,
    1959). Therefore, some real-world applications would remain impractical until
    computational and algorithm research advances over the last couple of decades.
    Branch-Cut-and-Price algorithms have been able to prove the optimality of CVRP
    instances with a few hundred customers (Fukasawa et al., 2006; Pecin et al., 2017),
    and state-of-the-art metaheuristics combined with local search techniques can
    provide good quality (sometimes optimal) solutions to these instances within a
    few seconds (Vidal et al., 2012; Vidal, 2022).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›é—®é¢˜çš„ç»„åˆæ–¹é¢ä½¿å¾—è€ƒè™‘ä¸€ä¸ªç®€å•çš„15ç‚¹é›†åˆæ—¶ï¼Œæœ‰6 Ã— 10Â¹Â¹æ¡å¯èƒ½çš„è·¯çº¿å°†å…¶è¿æ¥èµ·æ¥ï¼ˆDantzig & Ramser, 1959ï¼‰ã€‚å› æ­¤ï¼ŒæŸäº›ç°å®ä¸–ç•Œçš„åº”ç”¨åœ¨è¿‡å»å‡ åå¹´ä¸­è®¡ç®—å’Œç®—æ³•ç ”ç©¶è¿›å±•ä¹‹å‰å¯èƒ½ä»ä¸åˆ‡å®é™…ã€‚Branch-Cut-and-Priceç®—æ³•å·²èƒ½å¤Ÿè¯æ˜å…·æœ‰æ•°ç™¾åå®¢æˆ·çš„CVRPå®ä¾‹çš„æœ€ä¼˜æ€§ï¼ˆFukasawa
    et al., 2006; Pecin et al., 2017ï¼‰ï¼Œè€Œæœ€å…ˆè¿›çš„å…ƒå¯å‘å¼ç®—æ³•ç»“åˆå±€éƒ¨æœç´¢æŠ€æœ¯å¯ä»¥åœ¨å‡ ç§’é’Ÿå†…ä¸ºè¿™äº›å®ä¾‹æä¾›é«˜è´¨é‡ï¼ˆæœ‰æ—¶æœ€ä¼˜ï¼‰çš„è§£ï¼ˆVidal
    et al., 2012; Vidal, 2022ï¼‰ã€‚
- en: Throughout this article, we will introduce the Capacitated Vehicle Routing Problem
    with load (and duration) constraints and solve it using Mixed-Integer Programming
    (MIP) and specialized (meta)heuristic algorithms. In the first part, we will use
    the Python AML *Pyomo*, with the HiGHS solver, whereas in the second part, we
    will use the Google *OR Tools* package.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬å°†ä»‹ç»å…·æœ‰è´Ÿè½½ï¼ˆå’ŒæŒç»­æ—¶é—´ï¼‰çº¦æŸçš„å®¹é‡è½¦è¾†è·¯å¾„é—®é¢˜ï¼Œå¹¶ä½¿ç”¨æ··åˆæ•´æ•°è§„åˆ’ï¼ˆMIPï¼‰å’Œä¸“é—¨çš„ï¼ˆå…ƒï¼‰å¯å‘å¼ç®—æ³•è¿›è¡Œæ±‚è§£ã€‚åœ¨ç¬¬ä¸€éƒ¨åˆ†ä¸­ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨Python
    AML *Pyomo*ï¼Œé…åˆHiGHSæ±‚è§£å™¨ï¼Œè€Œåœ¨ç¬¬äºŒéƒ¨åˆ†ä¸­ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨Google *OR Tools* åŒ…ã€‚
- en: The reader who is more interested in real-world applications than in theoretical
    aspects of the problem might quickly skim through the *MIP* section and pay more
    interest to the [*Specialized (Meta)Heuristics*](#45ff)and [*Useful Extensions*](#cb69)sections.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: é‚£äº›å¯¹é—®é¢˜çš„ç°å®ä¸–ç•Œåº”ç”¨æ›´æ„Ÿå…´è¶£è€Œä¸æ˜¯ç†è®ºæ–¹é¢çš„è¯»è€…å¯èƒ½ä¼šå¿«é€Ÿæµè§ˆ*MIP*éƒ¨åˆ†ï¼Œå¹¶å¯¹[*ä¸“é—¨ï¼ˆå…ƒï¼‰å¯å‘å¼*](#45ff)å’Œ[*æœ‰ç”¨æ‰©å±•*](#cb69)éƒ¨åˆ†æ›´æ„Ÿå…´è¶£ã€‚
- en: Those interested in understanding in detail the MIP formulation but not yet
    familiar with numerical optimization might find it useful to take a look at my
    previous stories about[*Linear Programming*](https://medium.com/towards-data-science/linear-programming-theory-and-applications-c67600591612)and
    the [*Branch & Bound*](/a-gentle-introduction-to-branch-bound-d00a4ee1cad) method
    before proceeding with this one.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: é‚£äº›å¯¹MIPå…¬å¼æ„Ÿå…´è¶£ä½†å°šä¸ç†Ÿæ‚‰æ•°å€¼ä¼˜åŒ–çš„äººå¯èƒ½ä¼šå‘ç°æŸ¥çœ‹æˆ‘ä¹‹å‰å…³äº[*çº¿æ€§è§„åˆ’*](https://medium.com/towards-data-science/linear-programming-theory-and-applications-c67600591612)å’Œ[*åˆ†æ”¯å®šç•Œ*](/a-gentle-introduction-to-branch-bound-d00a4ee1cad)æ–¹æ³•çš„æ•…äº‹ä¼šå¾ˆæœ‰å¸®åŠ©ï¼Œç„¶åå†ç»§ç»­é˜…è¯»æœ¬æ–‡ã€‚
- en: As usual, you can find the complete code in this [git repository](https://github.com/bruscalia/optimization-demo-files/tree/27ccb5d2fc9e85e07436d1120f5c3f4073960448/vrp).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å¾€å¸¸ä¸€æ ·ï¼Œä½ å¯ä»¥åœ¨è¿™ä¸ª [git ä»“åº“](https://github.com/bruscalia/optimization-demo-files/tree/27ccb5d2fc9e85e07436d1120f5c3f4073960448/vrp)
    ä¸­æ‰¾åˆ°å®Œæ•´çš„ä»£ç ã€‚
- en: Now, let us dive in!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬æ·±å…¥äº†è§£å§ï¼
- en: Mixed-Integer Programming
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ··åˆæ•´æ•°è§„åˆ’
- en: The mathematical formulation presented in this section will use the same equations
    presented by Toth & Vigo (2002) in the model therein referred to as the â€œthree-index
    vehicle flow formulationâ€.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬èŠ‚ä¸­æå‡ºçš„æ•°å­¦å…¬å¼å°†ä½¿ç”¨Toth & Vigo (2002)ä¸­æ‰€å±•ç¤ºçš„ç›¸åŒæ–¹ç¨‹ï¼Œè¯¥æ¨¡å‹è¢«ç§°ä¸ºâ€œä¸‰æŒ‡æ•°è½¦è¾†æµé‡å…¬å¼â€ã€‚
- en: 'Consider a set *V* of nodes (demands and depot) and a set *K* of vehicles.
    We will use lowercase *i* and *j* to indicate node indexes and lowercase *k* to
    indicate vehicle indexes. As this model is valid for the asymmetric case, let
    us assume the nodes are part of a complete directed graph *G*(*V*, *A*) with arcs
    *A*. In this problem, there is a single depot node indexed by 0 and all vehicles
    have the same capacity *Q*. Consider two groups of decision variables:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: è€ƒè™‘ä¸€ä¸ªèŠ‚ç‚¹é›†åˆ*V*ï¼ˆéœ€æ±‚å’Œä»“åº“ï¼‰å’Œä¸€ä¸ªè½¦è¾†é›†åˆ*K*ã€‚æˆ‘ä»¬å°†ä½¿ç”¨å°å†™çš„*i*å’Œ*j*æ¥è¡¨ç¤ºèŠ‚ç‚¹ç´¢å¼•ï¼Œå°å†™çš„*k*æ¥è¡¨ç¤ºè½¦è¾†ç´¢å¼•ã€‚ç”±äºè¯¥æ¨¡å‹é€‚ç”¨äºä¸å¯¹ç§°æƒ…å†µï¼Œå‡è®¾èŠ‚ç‚¹æ˜¯ä¸€ä¸ªå®Œæ•´çš„æœ‰å‘å›¾*G*(*V*,
    *A*)çš„ä¸€éƒ¨åˆ†ï¼Œå…¶ä¸­*A*æ˜¯å¼§ã€‚åœ¨è¿™ä¸ªé—®é¢˜ä¸­ï¼Œæœ‰ä¸€ä¸ªå•ä¸€çš„ä»“åº“èŠ‚ç‚¹ï¼Œç´¢å¼•ä¸º0ï¼Œæ‰€æœ‰è½¦è¾†çš„å®¹é‡éƒ½æ˜¯*Q*ã€‚è€ƒè™‘ä¸¤ä¸ªå†³ç­–å˜é‡ç»„ï¼š
- en: '*x*_{*i, j, k*}: Is a binary variable that indicates an active arc from node
    *i* to node *j* performed by vehicle *k*.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*x*_{*i, j, k*}: æ˜¯ä¸€ä¸ªäºŒè¿›åˆ¶å˜é‡ï¼Œè¡¨ç¤ºç”±è½¦è¾† *k* æ‰§è¡Œçš„ä»èŠ‚ç‚¹ *i* åˆ°èŠ‚ç‚¹ *j* çš„æ´»è·ƒå¼§ã€‚'
- en: '*y*_{*i, k*}: Is a binary variable that indicates that the demand from node
    *i* is fulfilled by vehicle *k*.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*y*_{*i, k*}: æ˜¯ä¸€ä¸ªäºŒè¿›åˆ¶å˜é‡ï¼Œè¡¨ç¤ºèŠ‚ç‚¹ *i* çš„éœ€æ±‚ç”±è½¦è¾† *k* æ»¡è¶³ã€‚'
- en: Consider our objective to minimize the cost value associated with active arcs.
    Total duration or distance are usual examples. Say the cost of traversing the
    arc *i*, *j* is *cáµ¢â±¼*. The objective function can be stated as the following.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çš„ç›®æ ‡æ˜¯æœ€å°åŒ–ä¸æ´»è·ƒå¼§ç›¸å…³çš„æˆæœ¬å€¼ã€‚æ€»æŒç»­æ—¶é—´æˆ–è·ç¦»æ˜¯å¸¸è§çš„ä¾‹å­ã€‚å‡è®¾å¼§ *i*ï¼Œ*j* çš„æˆæœ¬æ˜¯ *cáµ¢â±¼*ã€‚ç›®æ ‡å‡½æ•°å¯ä»¥è¡¨ç¤ºä¸ºå¦‚ä¸‹ã€‚
- en: '![](../Images/6edb8e70ffd7f3b0b7621fcc56c702c8.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6edb8e70ffd7f3b0b7621fcc56c702c8.png)'
- en: Objective function of CVRP. (Image by the author).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: CVRP çš„ç›®æ ‡å‡½æ•°ã€‚ï¼ˆä½œè€…æä¾›çš„å›¾åƒï¼‰ã€‚
- en: 'We also need to include constraints that ensure:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿˜éœ€è¦åŒ…æ‹¬ç¡®ä¿ä»¥ä¸‹æ¡ä»¶çš„çº¦æŸï¼š
- en: Each customer *i* is visited once, therefore has one active arc which starts
    from it and one that arrives on it.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ¯ä¸ªå®¢æˆ· *i* åªè¢«è®¿é—®ä¸€æ¬¡ï¼Œå› æ­¤æœ‰ä¸€ä¸ªä»å®ƒå‡ºå‘çš„æ´»è·ƒå¼§å’Œä¸€ä¸ªåˆ°è¾¾å®ƒçš„æ´»è·ƒå¼§ã€‚
- en: If any arc variable indexed by vehicle *k* goes into one node *i* or out of
    it, the demand *q* of this node is assigned to vehicle *k*.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœä»»ä½•ç”±è½¦è¾† *k* ç´¢å¼•çš„å¼§å˜é‡è¿›å…¥ä¸€ä¸ªèŠ‚ç‚¹ *i* æˆ–ä»ä¸­å‡ºå»ï¼Œåˆ™è¯¥èŠ‚ç‚¹çš„éœ€æ±‚ *q* åˆ†é…ç»™è½¦è¾† *k*ã€‚
- en: The total demand assigned to a vehicle must not exceed its capacity *Q*.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åˆ†é…ç»™ä¸€è¾†è½¦çš„æ€»éœ€æ±‚ä¸èƒ½è¶…è¿‡å…¶å®¹é‡ *Q*ã€‚
- en: Exactly |*K*| nodes start at the depot and arrive at the depot.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ°å¥½ |*K*| ä¸ªèŠ‚ç‚¹ä»ä»“åº“å‡ºå‘å¹¶åˆ°è¾¾ä»“åº“ã€‚
- en: There are no subtoursâ€¦ However, the number of subtours is potentially too large
    to be enumerated from the start. We will dive into more detail about how to do
    it.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ²¡æœ‰å­å›è·¯â€¦â€¦ç„¶è€Œï¼Œå­å›è·¯çš„æ•°é‡å¯èƒ½å¤ªå¤§ï¼Œæ— æ³•ä»ä¸€å¼€å§‹å°±æšä¸¾å‡ºæ¥ã€‚æˆ‘ä»¬å°†è¯¦ç»†è®¨è®ºå¦‚ä½•è¿›è¡Œå¤„ç†ã€‚
- en: '![](../Images/27107a239f4062abd402f7f61d187d3d.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/27107a239f4062abd402f7f61d187d3d.png)'
- en: Constraints of CVRP. (Image by the author).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: CVRP çš„çº¦æŸã€‚ï¼ˆä½œè€…æä¾›çš„å›¾åƒï¼‰ã€‚
- en: 'As usual for Python tutorials, let us start our *hands-on* part by importing
    the libraries used in this section:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: å’Œå¾€å¸¸ä¸€æ ·ï¼Œåœ¨ Python æ•™ç¨‹ä¸­ï¼Œè®©æˆ‘ä»¬é€šè¿‡å¯¼å…¥æœ¬èŠ‚ä¸­ä½¿ç”¨çš„åº“å¼€å§‹æˆ‘ä»¬çš„ *åŠ¨æ‰‹* éƒ¨åˆ†ï¼š
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: And now let us instantiate a random problem with *N* demand nodes. In this example,
    the *depot* node is assumed to be the first node (index 0), so we ensure its corresponding
    demand is also zero.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è®©æˆ‘ä»¬å®ä¾‹åŒ–ä¸€ä¸ªå…·æœ‰ *N* ä¸ªéœ€æ±‚èŠ‚ç‚¹çš„éšæœºé—®é¢˜ã€‚åœ¨æ­¤ç¤ºä¾‹ä¸­ï¼Œ*depot* èŠ‚ç‚¹è¢«å‡è®¾ä¸ºç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆç´¢å¼• 0ï¼‰ï¼Œå› æ­¤æˆ‘ä»¬ç¡®ä¿å…¶å¯¹åº”çš„éœ€æ±‚ä¹Ÿä¸ºé›¶ã€‚
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The number of necessary vehicles can be calculated by using a Bin Packing Problem.
    An example of how to perform it is also included in the [complete source code](https://github.com/bruscalia/optimization-demo-files/tree/27ccb5d2fc9e85e07436d1120f5c3f4073960448/vrp).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: å¿…è¦çš„è½¦è¾†æ•°é‡å¯ä»¥é€šè¿‡ä½¿ç”¨äºŒè¿›åˆ¶è£…ç®±é—®é¢˜æ¥è®¡ç®—ã€‚å¦‚ä½•æ‰§è¡Œçš„ç¤ºä¾‹ä¹ŸåŒ…å«åœ¨ [å®Œæ•´æºä»£ç ](https://github.com/bruscalia/optimization-demo-files/tree/27ccb5d2fc9e85e07436d1120f5c3f4073960448/vrp)
    ä¸­ã€‚
- en: 'There are two approaches for modeling a problem in *pyomo*: *Abstract* and
    *Concrete* models. In the first approach, the algebraic expressions of the problem
    are defined before some data values are supplied, whereas, in the second, the
    model instance is created immediately as its elements are defined. You can find
    more about these approaches in the [library documentation](https://pyomo.readthedocs.io/en/stable/pyomo_overview/abstract_concrete.html)
    or in the book by Bynum et al. (2021). Throughout this article, we will adopt
    the *Concrete* model formulation.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ *pyomo* ä¸­å»ºæ¨¡é—®é¢˜æœ‰ä¸¤ç§æ–¹æ³•ï¼š*Abstract* å’Œ *Concrete* æ¨¡å‹ã€‚åœ¨ç¬¬ä¸€ç§æ–¹æ³•ä¸­ï¼Œé—®é¢˜çš„ä»£æ•°è¡¨è¾¾å¼åœ¨æä¾›ä¸€äº›æ•°æ®å€¼ä¹‹å‰è¢«å®šä¹‰ï¼Œè€Œåœ¨ç¬¬äºŒç§æ–¹æ³•ä¸­ï¼Œæ¨¡å‹å®ä¾‹åœ¨å®šä¹‰å…¶å…ƒç´ æ—¶ç«‹å³åˆ›å»ºã€‚ä½ å¯ä»¥åœ¨
    [åº“æ–‡æ¡£](https://pyomo.readthedocs.io/en/stable/pyomo_overview/abstract_concrete.html)
    æˆ– Bynum ç­‰äººï¼ˆ2021ï¼‰çš„ä¹¦ä¸­æ‰¾åˆ°æ›´å¤šå…³äºè¿™äº›æ–¹æ³•çš„ä¿¡æ¯ã€‚æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬å°†é‡‡ç”¨ *Concrete* æ¨¡å‹çš„è¡¨è¿°ã€‚
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let us instantiate the sets of demand nodes *V*, arcs *A*, and vehicles *K*.
    Notice that the depot node is included in the set of nodes *V* as in the original
    mathematical formulation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å®ä¾‹åŒ–éœ€æ±‚èŠ‚ç‚¹ *V*ã€å¼§ *A* å’Œè½¦è¾† *K* çš„é›†åˆã€‚æ³¨æ„ï¼Œä»“åº“èŠ‚ç‚¹åŒ…å«åœ¨èŠ‚ç‚¹ *V* é›†åˆä¸­ï¼Œå¦‚åŸå§‹æ•°å­¦å…¬å¼æ‰€ç¤ºã€‚
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now our parameters for capacity, demand load, and arc costs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬è®¾ç½®å®¹é‡ã€éœ€æ±‚è´Ÿè·å’Œå¼§æˆæœ¬çš„å‚æ•°ã€‚
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: And the decision variables indicating active arcs in a given vehicle and that
    a node visited by the vehicle.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥åŠæŒ‡ç¤ºç»™å®šè½¦è¾†ä¸­çš„æ´»è·ƒå¼§å’Œè½¦è¾†è®¿é—®çš„èŠ‚ç‚¹çš„å†³ç­–å˜é‡ã€‚
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Before including the constraints, I will create our objective that computes
    the total cost of active arcs.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨åŒ…å«çº¦æŸä¹‹å‰ï¼Œæˆ‘å°†åˆ›å»ºæˆ‘ä»¬çš„ç›®æ ‡ï¼Œè®¡ç®—æ´»è·ƒå¼§çš„æ€»æˆæœ¬ã€‚
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We also must include constraints previously listed. First let us implement
    them using the usual *Pyomo* signature: *function(model, *domain)*.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿˜å¿…é¡»åŒ…æ‹¬ä¹‹å‰åˆ—å‡ºçš„çº¦æŸæ¡ä»¶ã€‚é¦–å…ˆï¼Œè®©æˆ‘ä»¬ä½¿ç”¨å¸¸è§çš„*Pyomo*ç­¾åæ¥å®ç°å®ƒä»¬ï¼š*function(model, *domain)*ã€‚
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: And then incorporate them into our model.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åå°†å®ƒä»¬çº³å…¥æˆ‘ä»¬çš„æ¨¡å‹ä¸­ã€‚
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that I didnâ€™t include the subtour elimination constraints yet. We should
    consider all possible permutations of the *N* nodes taking *k* at a time and these
    could be prohibitively large to enumerate even for moderate size instances. Alternatively,
    in our solution procedure, we will recursively include subtour elimination constraints
    each time a new solution is found if we verify that this solution produces subtours.
    In some commercial solvers, these are called â€œ*lazy constraints*â€ and can be incorporated
    directly into the solver via callback.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·æ³¨æ„ï¼Œæˆ‘è¿˜æ²¡æœ‰åŒ…æ‹¬å­æ—…è¡Œæ¶ˆé™¤çº¦æŸã€‚æˆ‘ä»¬åº”è¯¥è€ƒè™‘æ‰€æœ‰å¯èƒ½çš„*N*ä¸ªèŠ‚ç‚¹çš„æ’åˆ—ï¼Œæ¯æ¬¡å–*k*ä¸ªï¼Œè¿™å¯èƒ½ä¼šå˜å¾—éå¸¸åºå¤§ï¼Œå³ä½¿å¯¹äºä¸­ç­‰è§„æ¨¡çš„å®ä¾‹ä¹Ÿå¾ˆéš¾æšä¸¾ã€‚æˆ–è€…ï¼Œåœ¨æˆ‘ä»¬çš„è§£å†³è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬å°†é€’å½’åœ°åœ¨æ¯æ¬¡æ‰¾åˆ°æ–°è§£æ—¶åŒ…æ‹¬å­æ—…è¡Œæ¶ˆé™¤çº¦æŸï¼Œå¦‚æœæˆ‘ä»¬éªŒè¯è¿™ä¸ªè§£äº§ç”Ÿäº†å­æ—…è¡Œçš„è¯ã€‚åœ¨ä¸€äº›å•†ä¸šæ±‚è§£å™¨ä¸­ï¼Œè¿™äº›ç§°ä¸ºâ€œ*æ‡’æƒ°çº¦æŸ*â€ï¼Œå¯ä»¥é€šè¿‡å›è°ƒç›´æ¥çº³å…¥æ±‚è§£å™¨ã€‚
- en: First let us create a function that, given a subtour, all remaining nodes, a
    node from the subtour, and a vehicle, returns a *Pyomo* expression corresponding
    to the mathematical formulation previously stated. Also, let us include a *ConstraintList*
    to which we will include new elements as we proceed with the solution.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œè®©æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªå‡½æ•°ï¼Œç»™å®šä¸€ä¸ªå­æ—…è¡Œã€æ‰€æœ‰å‰©ä½™èŠ‚ç‚¹ã€ä¸€ä¸ªå­æ—…è¡Œä¸­çš„èŠ‚ç‚¹å’Œä¸€è¾†è½¦ï¼Œè¿”å›ä¸€ä¸ª*Pyomo*è¡¨è¾¾å¼ï¼Œå¯¹åº”äºä¹‹å‰é™ˆè¿°çš„æ•°å­¦å…¬å¼ã€‚æ­¤å¤–ï¼Œè®©æˆ‘ä»¬åŒ…æ‹¬ä¸€ä¸ª*ConstraintList*ï¼Œåœ¨è§£å†³è¿‡ç¨‹ä¸­æˆ‘ä»¬å°†å‘å…¶ä¸­æ·»åŠ æ–°çš„å…ƒç´ ã€‚
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We must create some functions that will, given a solution, return subtours created
    (if they exist). To do so, we will first create a list of active arcs in the model
    using the *find_arcs* function. This list will be used to create an incomplete
    directed graph using the *Networkx* *DiGraph* class. And the *find_subtours* function
    should return a *list* of *sets* of connected components.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¿…é¡»åˆ›å»ºä¸€äº›å‡½æ•°ï¼Œç»™å®šä¸€ä¸ªè§£ï¼Œè¿”å›åˆ›å»ºçš„å­æ—…è¡Œï¼ˆå¦‚æœå­˜åœ¨ï¼‰ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬å°†é¦–å…ˆä½¿ç”¨*find_arcs*å‡½æ•°åˆ›å»ºä¸€ä¸ªæ´»åŠ¨å¼§çš„åˆ—è¡¨ã€‚è¿™ä¸ªåˆ—è¡¨å°†ç”¨äºåˆ›å»ºä¸€ä¸ªä¸å®Œæ•´çš„æœ‰å‘å›¾ï¼Œä½¿ç”¨*Networkx*çš„*DiGraph*ç±»ã€‚*find_subtours*å‡½æ•°åº”è¯¥è¿”å›ä¸€ä¸ª*list*çš„*sets*ï¼Œè¡¨ç¤ºè¿æ¥ç»„ä»¶ã€‚
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Our goal is to eliminate groups of connected components that do not include
    the depot node. So in the next step, we will create functions that iterate over
    the list of sets, and include new constraints if the set of components does not
    include the depot node. This will use the method *add* of the *ConstraintList*
    class.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çš„ç›®æ ‡æ˜¯æ¶ˆé™¤ä¸åŒ…å«ä»“åº“èŠ‚ç‚¹çš„è¿æ¥ç»„ä»¶ç»„ã€‚å› æ­¤ï¼Œåœ¨ä¸‹ä¸€æ­¥ä¸­ï¼Œæˆ‘ä»¬å°†åˆ›å»ºå‡½æ•°ï¼Œéå†é›†åˆåˆ—è¡¨ï¼Œå¹¶åŒ…æ‹¬æ–°çš„çº¦æŸæ¡ä»¶ï¼Œå¦‚æœç»„ä»¶é›†åˆä¸åŒ…æ‹¬ä»“åº“èŠ‚ç‚¹çš„è¯ã€‚è¿™å°†ä½¿ç”¨*ConstraintList*ç±»çš„*add*æ–¹æ³•ã€‚
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: And now we have everything ready to propose a solution procedure that iteratively
    solves the MIP, verifies if the current solution has subtours, and, if so, includes
    new constraints to eliminate them. Otherwise, the solution found is optimal.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å·²å‡†å¤‡å¥½æå‡ºä¸€ä¸ªè§£å†³ç¨‹åºï¼Œå®ƒè¿­ä»£åœ°æ±‚è§£MIPï¼ŒéªŒè¯å½“å‰è§£æ˜¯å¦æœ‰å­æ—…è¡Œï¼Œå¦‚æœæœ‰ï¼Œåˆ™åŒ…æ‹¬æ–°çš„çº¦æŸä»¥æ¶ˆé™¤å®ƒä»¬ã€‚å¦åˆ™ï¼Œæ‰¾åˆ°çš„è§£å°±æ˜¯æœ€ä¼˜çš„ã€‚
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now let us instantiate the solver and solve our model. The *Highs* solver is
    available in *Pyomo* (check the imports) if the *highspy* package is installed.
    So make sure to run a `pip install highspy` .
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è®©æˆ‘ä»¬å®ä¾‹åŒ–æ±‚è§£å™¨å¹¶æ±‚è§£æˆ‘ä»¬çš„æ¨¡å‹ã€‚å¦‚æœå®‰è£…äº†*highspy*åŒ…ï¼Œ*Highs*æ±‚è§£å™¨å¯ä»¥åœ¨*Pyomo*ä¸­ä½¿ç”¨ï¼ˆæ£€æŸ¥å¯¼å…¥ï¼‰ã€‚æ‰€ä»¥ç¡®ä¿è¿è¡Œ`pip
    install highspy`ã€‚
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: One more function to find the tours created and we are ready to plot results.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: è¿˜éœ€è¦ä¸€ä¸ªå‡½æ•°æ¥æ‰¾åˆ°åˆ›å»ºçš„è·¯å¾„ï¼Œç„¶åæˆ‘ä»¬å°±å‡†å¤‡å¥½ç»˜åˆ¶ç»“æœäº†ã€‚
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![](../Images/6fb03fe9219dd011aed7342e92b71ae5.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6fb03fe9219dd011aed7342e92b71ae5.png)'
- en: Tours produced in CVRP using MIP. (Image by the author).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨MIPäº§ç”Ÿçš„CVRPè·¯å¾„ã€‚ï¼ˆä½œè€…æä¾›çš„å›¾åƒï¼‰ã€‚
- en: Amazing results for the small instance with a total of 10 nodes. However, even
    for this small instance, the solver took almost half a minute to obtain the solution
    and the complexity increases significantly with more demand points. Fortunately,
    there are specialized algorithms publicly available to find good quality solutions
    for much larger instances in a short computational time. Let us take a look at
    them in the next section.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºæ€»å…±æœ‰10ä¸ªèŠ‚ç‚¹çš„å°è§„æ¨¡å®ä¾‹ï¼Œç»“æœä»¤äººæƒŠè®¶ã€‚ç„¶è€Œï¼Œå³ä½¿å¯¹äºè¿™ä¸ªå°è§„æ¨¡å®ä¾‹ï¼Œæ±‚è§£å™¨ä¹ŸèŠ±è´¹äº†å°†è¿‘åŠåˆ†é’Ÿæ¥è·å¾—è§£ï¼Œè€Œä¸”éšç€éœ€æ±‚ç‚¹å¢åŠ ï¼Œå¤æ‚æ€§æ˜¾è‘—å¢åŠ ã€‚å¹¸è¿çš„æ˜¯ï¼Œæœ‰ä¸“é—¨çš„ç®—æ³•å…¬å¼€å¯ç”¨ï¼Œç”¨äºåœ¨çŸ­æ—¶é—´å†…æ‰¾åˆ°æ›´å¤§å®ä¾‹çš„ä¼˜è´¨è§£ã€‚è®©æˆ‘ä»¬åœ¨ä¸‹ä¸€èŠ‚ä¸­æŸ¥çœ‹å®ƒä»¬ã€‚
- en: Specialized (Meta)Heuristics
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ä¸“é—¨çš„ï¼ˆå…ƒï¼‰å¯å‘å¼ç®—æ³•
- en: Throughout the years several specialized (meta)heuristics have been proposed
    for variants of the VRP. Most of them strongly rely on local search algorithms
    so that, given a solution, different perturbations are tried in order to sequentially
    improve its cost until no further improvement is possible in the given neighborhood.
    When using Google *Or Tools*, we will too use local search methods associated
    with constructive algorithms.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: å¤šå¹´æ¥ï¼Œå·²ç»æå‡ºäº†å‡ ç§é’ˆå¯¹ VRP å˜ä½“çš„ä¸“é—¨ï¼ˆå…ƒï¼‰å¯å‘å¼ç®—æ³•ã€‚å®ƒä»¬å¤§å¤šä¾èµ–äºå±€éƒ¨æœç´¢ç®—æ³•ï¼Œä»¥ä¾¿åœ¨ç»™å®šçš„è§£ä¸­å°è¯•ä¸åŒçš„æ‰°åŠ¨ï¼Œä»è€Œé¡ºåºåœ°æ”¹è¿›å…¶æˆæœ¬ï¼Œç›´åˆ°åœ¨ç»™å®šçš„é‚»åŸŸä¸­æ— æ³•è¿›ä¸€æ­¥æ”¹è¿›ã€‚ä½¿ç”¨
    Google *Or Tools* æ—¶ï¼Œæˆ‘ä»¬ä¹Ÿå°†ä½¿ç”¨ä¸æ„é€ ç®—æ³•ç›¸å…³çš„å±€éƒ¨æœç´¢æ–¹æ³•ã€‚
- en: In this section, instance 150d from Rochat and Taillard (1995) will be used.
    Its data was obtained from the [CVRPLIB](http://vrp.atd-lab.inf.puc-rio.br/index.php/en/plotted-instances?data=tai150d).
    This instance has 150 customers and one depot node, so we surely wouldn't be able
    to solve it using the MIP strategy previously presented.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸€éƒ¨åˆ†ä¸­ï¼Œå°†ä½¿ç”¨ Rochat å’Œ Taillard (1995) çš„å®ä¾‹ 150dã€‚å…¶æ•°æ®æ¥æºäº [CVRPLIB](http://vrp.atd-lab.inf.puc-rio.br/index.php/en/plotted-instances?data=tai150d)ã€‚è¯¥å®ä¾‹æœ‰
    150 ä¸ªå®¢æˆ·å’Œä¸€ä¸ªä»“åº“èŠ‚ç‚¹ï¼Œå› æ­¤æˆ‘ä»¬è‚¯å®šæ— æ³•ä½¿ç”¨ä¹‹å‰å±•ç¤ºçš„ MIP ç­–ç•¥æ¥è§£å†³å®ƒã€‚
- en: Let us once again start by importing the libraries used.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å†æ¬¡ä»å¯¼å…¥æ‰€ä½¿ç”¨çš„åº“å¼€å§‹ã€‚
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: And let us load the problem data from a file that includes the coordinates and
    demand of each node.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ä»ä¸€ä¸ªåŒ…å«æ¯ä¸ªèŠ‚ç‚¹åæ ‡å’Œéœ€æ±‚çš„æ•°æ®æ–‡ä»¶ä¸­åŠ è½½é—®é¢˜æ•°æ®ã€‚
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first step to using *OR Tools* VRP solver is to instantiate a routing manager
    and a model.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ *OR Tools* VRP æ±‚è§£å™¨çš„ç¬¬ä¸€æ­¥æ˜¯å®ä¾‹åŒ–ä¸€ä¸ªè·¯ç”±ç®¡ç†å™¨å’Œä¸€ä¸ªæ¨¡å‹ã€‚
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Next, we will include callbacks to quantify dimensions related to arcs/edges
    and nodes. The method *RegisterTransitCallback* of our *routing* instance can
    be used to quantify any dimension related to arcs/edges whereas the method *RegisterUnaryTransitCallback*
    can quantify values related to nodes. It might be important to re-scale your parameters
    depending on their original magnitude because *ortools* considers only integer
    values in dimensions.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†æ·»åŠ å›è°ƒå‡½æ•°ä»¥é‡åŒ–ä¸å¼§/è¾¹å’ŒèŠ‚ç‚¹ç›¸å…³çš„ç»´åº¦ã€‚æˆ‘ä»¬ *routing* å®ä¾‹çš„ *RegisterTransitCallback* æ–¹æ³•å¯ä»¥ç”¨æ¥é‡åŒ–ä¸å¼§/è¾¹ç›¸å…³çš„ä»»ä½•ç»´åº¦ï¼Œè€Œ
    *RegisterUnaryTransitCallback* æ–¹æ³•å¯ä»¥é‡åŒ–ä¸èŠ‚ç‚¹ç›¸å…³çš„å€¼ã€‚æ ¹æ®å‚æ•°çš„åŸå§‹å¤§å°ï¼Œå¯èƒ½éœ€è¦é‡æ–°ç¼©æ”¾ä½ çš„å‚æ•°ï¼Œå› ä¸º *ortools*
    åªè€ƒè™‘ç»´åº¦ä¸­çš„æ•´æ•°å€¼ã€‚
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, we will include a capacity constraint using the *demand_callback_index*
    previously defined. Notice that duration constraints could have been defined using
    the same syntax just passing instances of *RegisterTransitCallback* as the first
    argument. Furthermore, it is important to remark that the *routing* model handles
    heterogeneous fleets, so we must pass a list of values in the third argument.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ä¹‹å‰å®šä¹‰çš„ *demand_callback_index* æ¥åŠ å…¥å®¹é‡çº¦æŸã€‚è¯·æ³¨æ„ï¼ŒæŒç»­æ—¶é—´çº¦æŸä¹Ÿå¯ä»¥ä½¿ç”¨ç›¸åŒçš„è¯­æ³•å®šä¹‰ï¼Œåªéœ€å°† *RegisterTransitCallback*
    çš„å®ä¾‹ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°ä¼ é€’ã€‚æ­¤å¤–ï¼Œéœ€è¦å¼ºè°ƒçš„æ˜¯ï¼Œ*routing* æ¨¡å‹å¤„ç†å¼‚è´¨è½¦é˜Ÿï¼Œå› æ­¤æˆ‘ä»¬å¿…é¡»åœ¨ç¬¬ä¸‰ä¸ªå‚æ•°ä¸­ä¼ é€’ä¸€ä¸ªå€¼çš„åˆ—è¡¨ã€‚
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Similarly, the definition of the objective also takes a *callback* as the main
    argument. In this example, let us minimize the distances defined in the *transit_callback_index*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: åŒæ ·ï¼Œç›®æ ‡çš„å®šä¹‰ä¹Ÿå°† *callback* ä½œä¸ºä¸»è¦å‚æ•°ã€‚åœ¨è¿™ä¸ªç¤ºä¾‹ä¸­ï¼Œè®©æˆ‘ä»¬æœ€å°åŒ–åœ¨ *transit_callback_index* ä¸­å®šä¹‰çš„è·ç¦»ã€‚
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: At last, we must define solver parameters and solve our model.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œæˆ‘ä»¬å¿…é¡»å®šä¹‰æ±‚è§£å™¨å‚æ•°å¹¶è§£å†³æˆ‘ä»¬çš„æ¨¡å‹ã€‚
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The following piece of code can be used to extract the routes used in our solution.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹ä»£ç ç‰‡æ®µå¯ç”¨äºæå–æˆ‘ä»¬è§£å†³æ–¹æ¡ˆä¸­ä½¿ç”¨çš„è·¯çº¿ã€‚
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: And one can access the objective value by running the simple line `solution.ObjectiveValue()`
    . Using the configuration presented, I got an objective of 2679, which is quite
    close to the proven optimal value of 2645 (1.2% gap). The routes obtained are
    represented below.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: å¯ä»¥é€šè¿‡è¿è¡Œç®€å•çš„ä»£ç  `solution.ObjectiveValue()` æ¥è®¿é—®ç›®æ ‡å€¼ã€‚ä½¿ç”¨æ‰€æä¾›çš„é…ç½®ï¼Œæˆ‘å¾—åˆ°çš„ç›®æ ‡å€¼ä¸º 2679ï¼Œè¿™ä¸è¯æ˜çš„æœ€ä¼˜å€¼
    2645 éå¸¸æ¥è¿‘ï¼ˆ1.2% çš„å·®è·ï¼‰ã€‚è·å¾—çš„è·¯çº¿å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚
- en: '![](../Images/8b71961f6789302f5c15f3eb698c493f.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8b71961f6789302f5c15f3eb698c493f.png)'
- en: Routes obtained in instance tai150d using ortools. (Image by the author).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ ortools åœ¨å®ä¾‹ tai150d ä¸­è·å¾—çš„è·¯çº¿ã€‚ï¼ˆå›¾ç‰‡æ¥æºäºä½œè€…ï¼‰ã€‚
- en: The complete code (plots included) is available in this [git repository](https://github.com/bruscalia/optimization-demo-files/tree/27ccb5d2fc9e85e07436d1120f5c3f4073960448/vrp).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: å®Œæ•´çš„ä»£ç ï¼ˆåŒ…æ‹¬å›¾è¡¨ï¼‰å¯ä»¥åœ¨è¿™ä¸ª [git ä»“åº“](https://github.com/bruscalia/optimization-demo-files/tree/27ccb5d2fc9e85e07436d1120f5c3f4073960448/vrp)
    ä¸­æ‰¾åˆ°ã€‚
- en: Useful Extensions
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æœ‰ç”¨çš„æ‰©å±•
- en: The *OR Tools* library is fantastic as a general solver for routing problems
    for it handles several variants of the VRP, such as time windows, heterogeneous
    fleets, and multiple depots. However, algorithms fit for the canonical CVRP can
    perform even better. It is totally worth taking a look at the [*HGS-CVRP*](https://github.com/vidalt/HGS-CVRP)package
    (Vidal, 2022) that combines a state-of-the-art genetic algorithm with several
    local search moves. The algorithm finds the optimal solution for the instance
    *tai150d* within less than 20 seconds.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*OR Tools* åº“ä½œä¸ºè·¯ç”±é—®é¢˜çš„ä¸€èˆ¬æ±‚è§£å™¨éå¸¸å‡ºè‰²ï¼Œå› ä¸ºå®ƒå¤„ç†äº†å¤šç§å˜ä½“çš„ VRPï¼Œä¾‹å¦‚æ—¶é—´çª—ã€å¼‚æ„è½¦é˜Ÿå’Œå¤šä¸ªä»“åº“ã€‚ç„¶è€Œï¼Œé€‚ç”¨äºç»å…¸ CVRP
    çš„ç®—æ³•è¡¨ç°å¯èƒ½æ›´ä½³ã€‚å®Œå…¨å€¼å¾—æŸ¥çœ‹ä¸€ä¸‹ [*HGS-CVRP*](https://github.com/vidalt/HGS-CVRP) åŒ…ï¼ˆVidal, 2022ï¼‰ï¼Œå®ƒç»“åˆäº†æœ€å…ˆè¿›çš„é—ä¼ ç®—æ³•å’Œå‡ ç§å±€éƒ¨æœç´¢ç­–ç•¥ã€‚è¯¥ç®—æ³•èƒ½åœ¨ä¸åˆ°
    20 ç§’çš„æ—¶é—´å†…æ‰¾åˆ°å®ä¾‹ *tai150d* çš„æœ€ä¼˜è§£ã€‚'
- en: 'Regarding some real-world applications, it is likely that one should rely on
    road distances (or durations) rather than Euclidean distances to connect locations.
    Google provides a nice paid interface to do so, which you can check in [this tutorial](https://developers.google.com/optimization/routing/google_direction).
    However, if you are looking for open-source alternatives it is worth checking
    out the [OpenStreetMap API](https://wiki.openstreetmap.org/wiki/Main_Page). Some
    useful requests are:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: å…³äºä¸€äº›å®é™…åº”ç”¨ï¼Œå¯èƒ½éœ€è¦ä¾èµ–äºé“è·¯è·ç¦»ï¼ˆæˆ–æŒç»­æ—¶é—´ï¼‰è€Œéæ¬§å‡ é‡Œå¾—è·ç¦»æ¥è¿æ¥ä½ç½®ã€‚è°·æ­Œæä¾›äº†ä¸€ä¸ªå¾ˆå¥½çš„ä»˜è´¹æ¥å£ï¼Œä½ å¯ä»¥åœ¨ [è¿™ä¸ªæ•™ç¨‹](https://developers.google.com/optimization/routing/google_direction)
    ä¸­æŸ¥çœ‹ã€‚ç„¶è€Œï¼Œå¦‚æœä½ åœ¨å¯»æ‰¾å¼€æºæ›¿ä»£æ–¹æ¡ˆï¼Œå€¼å¾—æŸ¥çœ‹ [OpenStreetMap API](https://wiki.openstreetmap.org/wiki/Main_Page)ã€‚ä¸€äº›æœ‰ç”¨çš„è¯·æ±‚åŒ…æ‹¬ï¼š
- en: https://router.project-osrm.org/table/v1/driving/<LOCATIONS>
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: https://router.project-osrm.org/table/v1/driving/<LOCATIONS>
- en: http://router.project-osrm.org/route/v1/car/<LOCATIONS>?overview=false&steps=true
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: http://router.project-osrm.org/route/v1/car/<LOCATIONS>?overview=false&steps=true
- en: In which *<LOCATIONS>* should be a list of longitude and latitude pairs separated
    by commas within the pairs and by semicolons between different pairs. You can
    also specify sources and destinations in the *table* request, which is useful
    in case the complete table is too large to handle in a single request.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ *<LOCATIONS>* ä¸­åº”è¯¥æ˜¯ä»¥é€—å·åˆ†éš”çš„ç»çº¬åº¦å¯¹çš„åˆ—è¡¨ï¼Œåœ¨ä¸åŒå¯¹ä¹‹é—´ç”¨åˆ†å·åˆ†éš”ã€‚ä½ è¿˜å¯ä»¥åœ¨ *table* è¯·æ±‚ä¸­æŒ‡å®šèµ·ç‚¹å’Œç»ˆç‚¹ï¼Œè¿™åœ¨å®Œæ•´è¡¨æ ¼å¤ªå¤§è€Œæ— æ³•åœ¨å•ä¸ªè¯·æ±‚ä¸­å¤„ç†æ—¶å¾ˆæœ‰ç”¨ã€‚
- en: Besides doing precise routing calculations, visualization can be an important
    tool. The *Python* library [*folium*](https://python-visualization.github.io/folium/)
    can be quite useful to do it. It is definitely worth taking a look at it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: é™¤äº†è¿›è¡Œç²¾ç¡®çš„è·¯ç”±è®¡ç®—å¤–ï¼Œæ•°æ®å¯è§†åŒ–ä¹Ÿæ˜¯ä¸€ä¸ªé‡è¦å·¥å…·ã€‚*Python* åº“ [*folium*](https://python-visualization.github.io/folium/)
    å¯ä»¥éå¸¸æœ‰ç”¨ã€‚ç»å¯¹å€¼å¾—æŸ¥çœ‹ä¸€ä¸‹ã€‚
- en: Further Reading
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: è¿›ä¸€æ­¥é˜…è¯»
- en: Earlier in this article we implemented an exact MIP model for the CVRP, which
    is not suitable for moderate-size instances. However, algorithms that combine
    *column generation* to *Branch and Cut* have been successful in solving instances
    with up to a few hundred customers. It is worth taking a look at the research
    papers of Fukasawa et al. (2006) and Pecin et al. (2017).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ¬æ–‡æ—©äº›æ—¶å€™ï¼Œæˆ‘ä»¬å®ç°äº†ä¸€ä¸ªç²¾ç¡®çš„ MIP æ¨¡å‹ç”¨äº CVRPï¼Œè¿™å¯¹äºä¸­ç­‰è§„æ¨¡çš„å®ä¾‹å¹¶ä¸é€‚ç”¨ã€‚ç„¶è€Œï¼Œç»“åˆ *åˆ—ç”Ÿæˆ* å’Œ *åˆ†æ”¯å®šç•Œ* çš„ç®—æ³•åœ¨è§£å†³ä¸Šç™¾å®¢æˆ·çš„å®ä¾‹æ—¶è¡¨ç°æˆåŠŸã€‚å€¼å¾—æŸ¥çœ‹
    Fukasawa ç­‰äººï¼ˆ2006ï¼‰å’Œ Pecin ç­‰äººï¼ˆ2017ï¼‰çš„ç ”ç©¶è®ºæ–‡ã€‚
- en: Those interested in a previous introduction to column generation might find
    it in my previous [Medium article](https://medium.com/towards-data-science/column-generation-in-linear-programming-and-the-cutting-stock-problem-3c697caf4e2b).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºæ„Ÿå…´è¶£çš„åˆ—ç”Ÿæˆä»‹ç»ï¼Œå¯ä»¥åœ¨æˆ‘ä¹‹å‰çš„ [Medium æ–‡ç« ](https://medium.com/towards-data-science/column-generation-in-linear-programming-and-the-cutting-stock-problem-3c697caf4e2b)
    ä¸­æ‰¾åˆ°ã€‚
- en: Regarding *meta-heuristics*, the papers of Vidal et al. (2012) and Vidal (2022)
    are fantastic. Both are also available in the form of technical reports, with
    links available in the [*HGS-CVRP*](https://github.com/vidalt/HGS-CVRP) repository.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: å…³äº *å…ƒå¯å‘å¼ç®—æ³•*ï¼ŒVidal ç­‰äººï¼ˆ2012ï¼‰å’Œ Vidalï¼ˆ2022ï¼‰çš„è®ºæ–‡éå¸¸å‡ºè‰²ã€‚ä¸¤è€…ä¹Ÿä»¥æŠ€æœ¯æŠ¥å‘Šçš„å½¢å¼æä¾›ï¼Œé“¾æ¥å¯ä»¥åœ¨ [*HGS-CVRP*](https://github.com/vidalt/HGS-CVRP)
    ä»“åº“ä¸­æ‰¾åˆ°ã€‚
- en: Conclusions
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç»“è®º
- en: 'In this article, two approaches for solving the Capacitated Vehicle Routing
    Problem (CVRP) were presented: Mixed-Integer Programming and (Meta)Heuristics.
    The first alternative was used to solve a small instance in which it has been
    successful, although it is not able to handle moderate-size or large instances.
    The second approach was used to solve a challenging problem from the literature
    with 150 customers to which the solver found a good quality solution with a 1.2%
    gap to the known optimal within 300s.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ç¯‡æ–‡ç« ä¸­ï¼Œä»‹ç»äº†ä¸¤ç§è§£å†³å®¹é‡å—é™è½¦è¾†è·¯å¾„é—®é¢˜ï¼ˆCVRPï¼‰çš„æ–¹æ³•ï¼šæ··åˆæ•´æ•°è§„åˆ’å’Œï¼ˆå…ƒï¼‰å¯å‘å¼æ–¹æ³•ã€‚ç¬¬ä¸€ç§æ–¹æ³•ç”¨äºè§£å†³ä¸€ä¸ªå°è§„æ¨¡å®ä¾‹ï¼Œå¹¶ä¸”æˆåŠŸè§£å†³äº†è¯¥é—®é¢˜ï¼Œä½†æ— æ³•å¤„ç†ä¸­ç­‰è§„æ¨¡æˆ–å¤§å‹å®ä¾‹ã€‚ç¬¬äºŒç§æ–¹æ³•åˆ™ç”¨äºè§£å†³æ–‡çŒ®ä¸­çš„ä¸€ä¸ªå…·æœ‰æŒ‘æˆ˜æ€§çš„é—®é¢˜ï¼Œè¯¥é—®é¢˜æœ‰150ä¸ªå®¢æˆ·ï¼Œè§£ç®—å™¨åœ¨300ç§’å†…æ‰¾åˆ°äº†ä¸€ä¸ªä¸å·²çŸ¥æœ€ä¼˜è§£ç›¸å·®1.2%çš„é«˜è´¨é‡è§£ã€‚
- en: References
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å‚è€ƒæ–‡çŒ®
- en: Bynum, M. L. et al., 2021\. *Pyomo-optimization modeling in python.* Springer.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Bynum, M. L. ç­‰, 2021\. *Pyomo-optimization modeling in python.* Springer.
- en: Dantzig, G. B., & Ramser, J. H., 1959\. The truck dispatching problem. *Management
    science*, *6*(1), 80â€“91.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Dantzig, G. B., & Ramser, J. H., 1959\. The truck dispatching problem. *ç®¡ç†ç§‘å­¦*,
    *6*(1), 80â€“91.
- en: Fukasawa, R., Longo, H., Lysgaard, J., AragÃ£o, M. P. D., Reis, M., Uchoa, E.,
    & Werneck, R. F., 2006\. Robust branch-and-cut-and-price for the capacitated vehicle
    routing problem. *Mathematical programming*, *106*, 491â€“511.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Fukasawa, R., Longo, H., Lysgaard, J., AragÃ£o, M. P. D., Reis, M., Uchoa, E.,
    & Werneck, R. F., 2006\. é’ˆå¯¹å®¹é‡å—é™è½¦è¾†è·¯å¾„é—®é¢˜çš„é²æ£’åˆ†æ”¯å®šç•Œä¸å®šä»·æ–¹æ³•. *æ•°å­¦è§„åˆ’*, *106*, 491â€“511.
- en: Pecin, D., Pessoa, A., Poggi, M., & Uchoa, E., 2017\. Improved branch-cut-and-price
    for capacitated vehicle routing. *Mathematical Programming Computation*, *9*,
    61â€“100.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Pecin, D., Pessoa, A., Poggi, M., & Uchoa, E., 2017\. æ”¹è¿›çš„åˆ†æ”¯å®šç•Œä¸å®šä»·æ–¹æ³•ç”¨äºå®¹é‡å—é™è½¦è¾†è·¯å¾„é—®é¢˜.
    *æ•°å­¦è§„åˆ’è®¡ç®—*, *9*, 61â€“100.
- en: Rochat, Y., & Taillard, Ã‰. D., 1995\. Probabilistic diversification and intensification
    in local search for vehicle routing. *Journal of heuristics*, *1*, 147â€“167.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Rochat, Y., & Taillard, Ã‰. D., 1995\. åœ¨è½¦è¾†è·¯å¾„é—®é¢˜çš„å±€éƒ¨æœç´¢ä¸­è¿›è¡Œæ¦‚ç‡æ€§å¤šæ ·åŒ–å’Œå¼ºåŒ–. *å¯å‘å¼æœŸåˆŠ*, *1*,
    147â€“167.
- en: Toth, P., & Vigo, D., 2002\. An overview of vehicle routing problems. *The vehicle
    routing problem*, 1â€“26.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Toth, P., & Vigo, D., 2002\. è½¦è¾†è·¯å¾„é—®é¢˜æ¦‚è¿°. *è½¦è¾†è·¯å¾„é—®é¢˜*, 1â€“26.
- en: 'Vidal, T., 2022\. Hybrid genetic search for the CVRP: Open-source implementation
    and SWAP* neighborhood. *Computers & Operations Research*, *140*, 105643.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Vidal, T., 2022\. é’ˆå¯¹CVRPçš„æ··åˆé—ä¼ æœç´¢ï¼šå¼€æºå®ç°å’ŒSWAP*é‚»åŸŸ. *è®¡ç®—æœºä¸è¿ç­¹ç ”ç©¶*, *140*, 105643.
- en: Vidal, T., Crainic, T. G., Gendreau, M., Lahrichi, N., & Rei, W., 2012\. A hybrid
    genetic algorithm for multidepot and periodic vehicle routing problems. *Operations
    Research*, *60*(3), 611â€“624.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Vidal, T., Crainic, T. G., Gendreau, M., Lahrichi, N., & Rei, W., 2012\. ä¸€ç§ç”¨äºå¤šè½¦åº“å’Œå‘¨æœŸæ€§è½¦è¾†è·¯å¾„é—®é¢˜çš„æ··åˆé—ä¼ ç®—æ³•.
    *è¿ç­¹å­¦*, *60*(3), 611â€“624.
