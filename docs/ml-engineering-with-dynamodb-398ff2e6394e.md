# 使用 DynamoDB 进行 ML 工程

> 原文：[`towardsdatascience.com/ml-engineering-with-dynamodb-398ff2e6394e`](https://towardsdatascience.com/ml-engineering-with-dynamodb-398ff2e6394e)

## 如何利用这个强大的 NoSQL 数据库进行在线推理

[](https://medium.com/@achad?source=post_page-----398ff2e6394e--------------------------------)![Avi Chad-Friedman](https://medium.com/@achad?source=post_page-----398ff2e6394e--------------------------------)[](https://towardsdatascience.com/?source=post_page-----398ff2e6394e--------------------------------)![Towards Data Science](https://towardsdatascience.com/?source=post_page-----398ff2e6394e--------------------------------) [Avi Chad-Friedman](https://medium.com/@achad?source=post_page-----398ff2e6394e--------------------------------)

·发布在 [Towards Data Science](https://towardsdatascience.com/?source=post_page-----398ff2e6394e--------------------------------) ·5 分钟阅读·2023 年 2 月 7 日

--

## 为什么考虑 DynamoDB？

在处理离线批量 ML 系统时，基于 SQL 的数据仓库工作流程如 Snowflake 构成了业务分析、描述性统计和预测建模的核心。这是一种理想状态，其中复杂的转换可以推送到分布式数据库引擎，而特征则在用于推理的相同语言中定义。

避免离开这个乐园，除非你被（真实的）实时推理需求推出来。如果你发现自己处于这个新的、混乱的世界，尤其是当相关特征高频变动时，并且你需要低延迟的读取和写入，你可能需要 NoSQL。

AWS DynamoDB 是一个 [极具扩展性](https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf) 的托管 NoSQL 数据库。像其他 NoSQL 数据库一样，它用一致性换取可用性，使其成为构建低延迟 ML 预测器的理想数据存储。本文的目标是展示一些设计模式，帮助你构建足够灵活的生产工作流程，以处理常见的 ML 访问模式。

![](img/509e98e06ba6dc121d8d2fc4b316fb54.png)

作者生成的图片来自 [`imgflip.com/`](https://imgflip.com/)

## **DynamoDB 中的索引简介**

键值存储系统速度很快，因为访问模式很简单。集合中的元素通过主键进行访问。在 Dynamo 中，这是一组分区键和排序键的组合，每行必须唯一。分区键和排序键共同构成一个复合主键，分别直观地确定了数据存储的位置和顺序。

本地二级索引在单个分区的范围内操作。在你想要以多种方式对分区进行排序或过滤的情况下，它们很有用。

全局二级索引不需要与主索引共享相同的分区键。它们可以帮助在单个表中创建灵活且高效的访问模式，正如我们将在 ML 产品场景的第二部分中看到的那样。

GSI（全局二级索引）是以最终一致性的方式更新的，这意味着写入操作可能在所有索引更新之前成功写入 DynamoDB。这是一个有意的设计权衡，也是 DynamoDB 如此强大的部分原因。当存储高吞吐量的数据（例如遥测数据、大量交易）时，快速且可能不完全干净的写入是一个好的权衡。

## 使用时间序列特征对单个客户进行推断

假设你有一个模型，它预测客户是否会在过去 30 天的历史记录的基础上进行购买。你的产品经理要求你使用这个模型来决定是否在浏览器上展示促销横幅（为什么不呢；我不是产品经理）。

DynamoDB 如何支持这个预测管道？

1.  我们设计一个表，支持每个客户所需特征的高效访问。

1.  我们实时地（可能通过某种队列服务）将购买记录写入表中。

1.  推断应用在接收到来自网站的请求时查询这个表。

首先，让我们在一个更熟悉的关系模型中展示数据和特征工程的样子。在推断时，模型需要访问客户过去 30 天的购买记录。

你如何在 DynamoDB 中高效地复制这个设置？模型在客户层面进行预测，使用该客户的特征，因此一个自然（且高效）的起点是按 customer_id 分区数据。DynamoDB 将为每个客户 ID 连续存储数据；在每个主键分区内，我们希望高效地获取与预测相关的购买数据。一个本地二级索引可以让我们做到这一点。

让我们在一个实时推断应用中使用这个表中的值。这里模拟的模型是一个逻辑回归，具有单一且易于理解的特征*total_purchase_volume_30d*。我们通过 FastAPI 端点将预测结果提供给前端，FastAPI 从 DynamoDB 中获取数据，并将其输入到预测模型中。

## 将其扩展到同时进行多个预测

到目前为止，一切顺利。我们能够用一个客户 ID 命中一个 API 端点，并以低延迟访问该客户的预测。事实上，你的产品经理对促销活动的表现非常满意，她希望将其扩展到邮件群发。她希望每次群发都针对可能在接下来的 30 天内购买的客户，并根据在特定类别中进行过购买的客户进行细分。一封邮件群发可能针对珠宝购物者，另一封则可能针对有趣的衬衫（这里随便说说）。

目前，机器学习管道需要支持为每个类别中所有已购买的客户返回预测。问题在于客户数量庞大；假设有数千万个客户。此外，大多数客户在过去 30 天内没有进行购买。我们当前的数据设计要求对所有客户进行*扫描*，过滤出我们关心的类别中的交易。这种对大型表格进行扫描的操作代价极其高昂，因为它需要读取表格中的每一项；同时也极其麻烦，因为你需要分页浏览大量结果。

幸运的是，我们可以通过扩展表格并添加全局二级索引（GSI）来有效支持这种用例。GSI 数据与主索引独立存储，因此*不需要共享相同的分区*。这对于支持我们的用例至关重要：我们的策略是查询表中某一特定类别下的所有项，筛选出相关客户，然后利用主索引进行预测。*注意：我们利用“ProjectionType”属性来限制存储在二级索引中的数据量（在这种情况下，我们只需要客户 ID）。这将降低成本并加快读写速度。*

下面的预测循环实现了上述策略。针对 GSI 的简单查询可以快速返回表中由 API 参数 `category_name` 指定的类别中的所有购买记录。我们去重返回的客户 ID，然后利用这些 ID 发起一个 `BatchGetItem` 请求（这可以减少网络往返时间），以获取这些客户的所有购买记录，使用主键和本地二级索引。特征数据的封送处理和预测可以完全在内存中进行。

## 结论

通过两个机器学习产品用例，我们已了解如何利用 DynamoDB 中的本地和全局索引来高效存储和访问特征数据。你甚至可以更进一步，[通过二级索引模拟一整套关系](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-relational-modeling.html)。

在 SQL 中进行特征工程更直观且冗余较少，因此尽可能使用它。然而，DynamoDB 的低延迟、最终一致性模型使其成为高量在线推断的有吸引力的选项。
