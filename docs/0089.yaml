- en: Understand Polars’ Lack of Indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/understand-polars-lack-of-indexes-526ea75e413?source=collection_archive---------1-----------------------#2023-01-06](https://towardsdatascience.com/understand-polars-lack-of-indexes-526ea75e413?source=collection_archive---------1-----------------------#2023-01-06)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Switch from Pandas to Polars and forget about indexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@carlmkadie?source=post_page-----526ea75e413--------------------------------)[![Carl
    M. Kadie](../Images/9dbe27c76e9567136e5a7dc587f1fb15.png)](https://medium.com/@carlmkadie?source=post_page-----526ea75e413--------------------------------)[](https://towardsdatascience.com/?source=post_page-----526ea75e413--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----526ea75e413--------------------------------)
    [Carl M. Kadie](https://medium.com/@carlmkadie?source=post_page-----526ea75e413--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fa5e87027005f&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funderstand-polars-lack-of-indexes-526ea75e413&user=Carl+M.+Kadie&userId=a5e87027005f&source=post_page-a5e87027005f----526ea75e413---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----526ea75e413--------------------------------)
    ·7 min read·Jan 6, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F526ea75e413&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funderstand-polars-lack-of-indexes-526ea75e413&user=Carl+M.+Kadie&userId=a5e87027005f&source=-----526ea75e413---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F526ea75e413&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funderstand-polars-lack-of-indexes-526ea75e413&source=-----526ea75e413---------------------bookmark_footer-----------)![](../Images/e747b30f039731b4dff5b5663f6733be.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'A Polar Bear racing a Panda — Source: [https://openai.com/dall-e-2](https://openai.com/dall-e-2/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pandas and Polars are two dataframe libraries for Python. In a [previous article](https://medium.com/towards-data-science/understand-pandas-indexes-1b94f5c078c6),
    I wrote this about Pandas and indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: To efficiently use Pandas, ignore its documentation and learn the [complicated]
    truth about indexes.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In contrast, the original [Polars book](https://web.archive.org/web/20230117102825/https://pola-rs.github.io/polars-book/user-guide/coming_from_pandas.html)
    said this about Polars and indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: Indexes are not needed! Not having them makes things easier — convince us otherwise!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Can we really forget about indexes? Let’s put Polars’ claim to the test. We’ll
    port all the examples in my previous article from Pandas to Polars. That will
    give us insight into the practicality of working without indexes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the end, we’ll see that:'
  prefs: []
  type: TYPE_NORMAL
- en: “Indexes are not needed! Not having them makes things easier.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you think you *really* need an index, you *really* need a dictionary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To reach that end, let’s start by creating a dataframe and retrieving a simple
    row.
  prefs: []
  type: TYPE_NORMAL
- en: Construction and Simple Row Retrieval
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Pandas, we construct a dataframe and set an index like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/fd9bea2dbf3fd94e7eb1fd86561270df.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We turn key `b` into the row of interest with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/709e72abb7fea9431964ae1127392bd3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In Polars, we could construct a dataframe from rows like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'However, Polars is column-centric, so a better way to construct the same dataframe
    is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/ad4ad59cb36ab7ce4315f568fb1a8a97.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We don’t need to set an index. We turn key `b` into the row of interest with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `filter` method finds rows of interest. The expression `pl.col("alpha")=='b'`
    tells `filter` which rows to find. Compared to Pandas, I find the Polars approach
    both simpler and more general. (We’ll discuss performance in a bit.)
  prefs: []
  type: TYPE_NORMAL
- en: We move next from finding a simple row to finding the number of a row.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Row Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Pandas, you can see the numbers for rows of interest via `index.get_loc(...):`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/0c60b62f4d6fe3a4ab8c4e84e3d06402.png)'
  prefs: []
  type: TYPE_IMG
- en: As the example shows, the function will only return a number when a single item
    matches. When multiple items match, it returns a Boolean array.
  prefs: []
  type: TYPE_NORMAL
- en: In Polars, you should first ask yourself if you really need to find row numbers.
    The answer is usually “no”. If, however, you answer “yes”, you may use `arg_where`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/35757dd75125a7b196997d939a3b65c3.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/22da937716a2ecdda97225f4acfba5c9.png)'
  prefs: []
  type: TYPE_IMG
- en: The result is a Polars `series`. In Polars, a `series` represents one column
    of values, here row numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Pandas to Polars with respect to finding row numbers, I find the complexity
    similar. Polars may win, however, by making row numbers less important.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look next at complex row access.
  prefs: []
  type: TYPE_NORMAL
- en: Row Access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Pandas, the main way to access indexed rows is `.loc[…]`, where the input
    can be a: single element, list of elements, or slice of elements. The rows will
    be output in the order they appear in the input. These examples show each kind
    of input.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/8f1fc3e1f1d6a710d0f6348c41847ccb.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/f3ba64f9f1e6e6e11cbe774a0a4e5281.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/5c9a45ec87cc7576cace6a0b954ebe55.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that unlike the rest of Python, with Pandas the *start:stop* slice is inclusive
    of the *stop* value. Also, note that Panda excluded the second ‘j’ row because
    it came after the (first) ‘k’ row.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Polars, we use `filter` and expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/449c25bc8904e8368a897ec8fda838b1.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/51ff038fa8e5f8c76bf7ed8c3b874f34.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/c107fc43b43143c324e399651127a532.png)'
  prefs: []
  type: TYPE_IMG
- en: By default, Polars’ `is_between` will not include its bounds, but either or
    both bound can optionally be included. Also, note that Polars included the second
    ‘j’ row. Polars looks at `in_between` (on string values) based on alphabetical
    order, not row order.
  prefs: []
  type: TYPE_NORMAL
- en: Because it doesn’t require an index, I find Polars simpler than Pandas for these
    more complex row retrievals.
  prefs: []
  type: TYPE_NORMAL
- en: For our last basic task, let’s look at joining rows.
  prefs: []
  type: TYPE_NORMAL
- en: Joining Rows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Pandas, the rules for left joins are:'
  prefs: []
  type: TYPE_NORMAL
- en: The left dataframe need not be indexed, but the right one does.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Give the left column(s) of interest in the join’s `on` input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, we will use `join` to add a “score” column to a dataframe.
    Here is the left dataframe. It isn't indexed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In Pandas, the right dataframe needs an index, but it can be named anything.
    Here we call it `any_name`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We combine the two dataframes with a left join. We use column `alpha` from the
    first dataframe and whatever is indexed in the second dataframe. The result is
    a new dataframe with a score column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/b8212a06ef0fe6d4bbd1a5d3c0e1ffa4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In Polars, everything is similar, but a little simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/3398575e61dd0ff3d9fc379c52ae0b7f.png)'
  prefs: []
  type: TYPE_IMG
- en: The difference is that we don’t need to index the right dataframe. If the columns
    of interest have the same name (as here), we use `on`. If not, we use `left_on`
    and `right_on`.
  prefs: []
  type: TYPE_NORMAL
- en: So, Polars is again simpler to use than Pandas, but at what cost?
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Surely, the lack of indexes makes Polars slower. Amazingly, no. Over a wide
    range of benchmarks, [Polars is much faster](https://www.ritchievink.com/blog/2021/02/28/i-wrote-one-of-the-fastest-dataframe-libraries/)
    than Pandas [[Vink, 2021]](https://www.ritchievink.com/blog/2021/02/28/i-wrote-one-of-the-fastest-dataframe-libraries/).
    It achieves this via optimizations including good memory layout and automatic
    vectorization/parallelization.
  prefs: []
  type: TYPE_NORMAL
- en: Can we construct a case in which Pandas is faster than Polars? Yes, if we use
    a dataframe as a dictionary, Pandas can be 20 times faster than Polars. However…
  prefs: []
  type: TYPE_NORMAL
- en: 'Guess what is 300 times faster than using Pandas as a dictionary? Answer: using
    a dictionary as a dictionary.'
  prefs: []
  type: TYPE_NORMAL
- en: In this test, we construct a dataframe with two columns, filled with the numbers
    0 to 999,999\. We then look for the number 500,000.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the average results over many runs on my 4-core laptop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5267869dca5627d013a1d95a0b1aeab5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To summarize performance: according to other benchmarks, for typical use, Polars
    is faster than Pandas. For special cases — for example, when you should really
    use a dictionary —Polars gives tools to create a dictionary for the fastest performance.'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In my opinion, eliminating indexes makes Polars much easier to use than Pandas.
  prefs: []
  type: TYPE_NORMAL
- en: You would expect this simplification to cause slower performance. Benchmarks,
    however, show Polars is generally much faster than Pandas. It achieves this via
    optimizations including good memory layout and automatic vectorization/parallelization.
    There may still be cases where an index-like data structure is needed. For those
    cases, Polars provides tools to create, for example, dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: So, should you switch from Pandas to Polars? It depends.
  prefs: []
  type: TYPE_NORMAL
- en: Our genomics project, [FaST-LMM](https://fastlmm.github.io/) uses Pandas to
    output tables of statistical results. FaST-LMM does almost all its computational
    work with custom code, outside of Pandas. It only uses Pandas to share final results
    with our users, who we can assume understand Pandas. Given this, we have no reason
    to switch from Pandas.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if I start a new project that involves interesting data analytics,
    I’ll do it in Polars. Polars gives me the speed and simplicity that I’ve always
    wanted from Pandas.
  prefs: []
  type: TYPE_NORMAL
- en: '*Please* [*follow me on Medium*](https://medium.com/@carlmkadie)*. I write
    on scientific programming in Rust and Python, machine learning, and statistics.
    I tend to write about one article per month.*'
  prefs: []
  type: TYPE_NORMAL
