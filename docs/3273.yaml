- en: Lagrange Multipliers, KKT Conditions, and Duality — Intuitively Explained
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拉格朗日乘子、KKT 条件和对偶性——直观解释
- en: 原文：[https://towardsdatascience.com/lagrange-multipliers-kkt-conditions-duality-intuitively-explained-de09f645b068?source=collection_archive---------3-----------------------#2023-11-03](https://towardsdatascience.com/lagrange-multipliers-kkt-conditions-duality-intuitively-explained-de09f645b068?source=collection_archive---------3-----------------------#2023-11-03)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/lagrange-multipliers-kkt-conditions-duality-intuitively-explained-de09f645b068?source=collection_archive---------3-----------------------#2023-11-03](https://towardsdatascience.com/lagrange-multipliers-kkt-conditions-duality-intuitively-explained-de09f645b068?source=collection_archive---------3-----------------------#2023-11-03)
- en: Your key to understanding SVMs, Regularization, PCA, and many other machine
    learning concepts
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 SVM、正则化、PCA 以及许多其他机器学习概念的关键
- en: '[](https://essamwissam.medium.com/?source=post_page-----de09f645b068--------------------------------)[![Essam
    Wisam](../Images/6320ce88ba2e5d56d70ce3e0f97ceb1d.png)](https://essamwissam.medium.com/?source=post_page-----de09f645b068--------------------------------)[](https://towardsdatascience.com/?source=post_page-----de09f645b068--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----de09f645b068--------------------------------)
    [Essam Wisam](https://essamwissam.medium.com/?source=post_page-----de09f645b068--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://essamwissam.medium.com/?source=post_page-----de09f645b068--------------------------------)[![Essam
    Wisam](../Images/6320ce88ba2e5d56d70ce3e0f97ceb1d.png)](https://essamwissam.medium.com/?source=post_page-----de09f645b068--------------------------------)[](https://towardsdatascience.com/?source=post_page-----de09f645b068--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----de09f645b068--------------------------------)
    [Essam Wisam](https://essamwissam.medium.com/?source=post_page-----de09f645b068--------------------------------)'
- en: ·
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fccb82b9f3b87&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Flagrange-multipliers-kkt-conditions-duality-intuitively-explained-de09f645b068&user=Essam+Wisam&userId=ccb82b9f3b87&source=post_page-ccb82b9f3b87----de09f645b068---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----de09f645b068--------------------------------)
    ·13 min read·Nov 3, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fde09f645b068&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Flagrange-multipliers-kkt-conditions-duality-intuitively-explained-de09f645b068&user=Essam+Wisam&userId=ccb82b9f3b87&source=-----de09f645b068---------------------clap_footer-----------)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[关注](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fccb82b9f3b87&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Flagrange-multipliers-kkt-conditions-duality-intuitively-explained-de09f645b068&user=Essam+Wisam&userId=ccb82b9f3b87&source=post_page-ccb82b9f3b87----de09f645b068---------------------post_header-----------)
    发表在 [Towards Data Science](https://towardsdatascience.com/?source=post_page-----de09f645b068--------------------------------)
    ·13 min read·Nov 3, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fde09f645b068&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Flagrange-multipliers-kkt-conditions-duality-intuitively-explained-de09f645b068&user=Essam+Wisam&userId=ccb82b9f3b87&source=-----de09f645b068---------------------clap_footer-----------)'
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fde09f645b068&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Flagrange-multipliers-kkt-conditions-duality-intuitively-explained-de09f645b068&source=-----de09f645b068---------------------bookmark_footer-----------)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fde09f645b068&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Flagrange-multipliers-kkt-conditions-duality-intuitively-explained-de09f645b068&source=-----de09f645b068---------------------bookmark_footer-----------)'
- en: In this story, we will explore a clear and insightful grasp of three related
    concepts in mathematical optimization. These concepts required substantial time
    and effort for me to fully grasp, so I’ve aimed to present them in an intuitive
    way for all readers. Our journey will commence with a refresher on unconstrained
    optimization, followed by a consideration for constrained optimization, where
    we’ll utilize Lagrange Multipliers and KKT conditions. We also delve into the
    interplay between these ideas and their connections to the concept of duality.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个故事中，我们将深入探索数学优化中的三个相关概念。这些概念曾让我花费大量时间和精力才完全掌握，因此我旨在以直观的方式向所有读者展示它们。我们的旅程将从对无约束优化的回顾开始，随后考虑有约束优化，我们将利用拉格朗日乘子和
    KKT 条件。我们还将深入探讨这些概念之间的相互作用及其与对偶性概念的联系。
- en: Thus, by the end of this story you will understand how to solve constrained
    and unconstrained optimization problems as well as be able to intuitively derive
    why such methods work.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本故事结束时，你将了解如何解决约束和无约束优化问题，并能够直观地推导出这些方法为何有效。
- en: '![](../Images/85a9dfa76b0f8b0c73ad39b85daf60f0.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/85a9dfa76b0f8b0c73ad39b85daf60f0.png)'
- en: Photo by [Filip Mroz](https://unsplash.com/@mroz?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 照片由 [Filip Mroz](https://unsplash.com/@mroz?utm_source=medium&utm_medium=referral)
    提供，来自 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: Unconstrained Optimization
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无约束优化
- en: '![](../Images/71be8bc42c3c9753a19ba5f9874dc427.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/71be8bc42c3c9753a19ba5f9874dc427.png)'
- en: Plot of a Multivariable Function by Cdang on [Wikimedia](https://commons.wikimedia.org/wiki/File:Surface3D_sinFoisSin_python_matplotlib.svg)
    CC BY-SA 4.0.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Cdang 绘制的多变量函数图，来源于 [Wikimedia](https://commons.wikimedia.org/wiki/File:Surface3D_sinFoisSin_python_matplotlib.svg)
    CC BY-SA 4.0。
- en: In unconstrained optimization, we are given a multivariable function *f(u)*
    and we want to find the value for the vector *u** where the value of the function
    *f(u*)* is optimum (maximum or minimum).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在无约束优化中，我们给定一个多变量函数 *f(u)*，并希望找到向量 *u** 的值，使得函数 *f(u*)* 的值最优（最大值或最小值）。
- en: 'A function in general can have multiple maxima and minima as shown above. In
    classical machine learning and throughout this story, we will be mostly interested
    in convex functions (that are also sufficiently smooth). Being [convex](https://en.wikipedia.org/wiki/Convex_function)
    implies that the function has at most one optimum value (which is one minimum
    when the function at hand is a loss function) as shown below:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，函数可能有多个极大值和极小值，如上所示。在经典机器学习中以及本故事中，我们主要关注的是凸函数（这些函数也足够光滑）。[凸](https://en.wikipedia.org/wiki/Convex_function)
    函数意味着该函数至多有一个最优值（当函数是损失函数时，这个最优值是一个最小值），如下所示：
- en: '![](../Images/694e1583a1664b47a985863d7cd250ea.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/694e1583a1664b47a985863d7cd250ea.png)'
- en: Graph for a 3D Surface by [Andrebis](https://commons.wikimedia.org/wiki/User:Andrebis)
    on [Wikipedia](https://en.wikipedia.org/wiki/Lagrange_multiplier#/media/File:As_wiki_lgm_parab.svg)
    CC BY-SA 3.0.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由 [Andrebis](https://commons.wikimedia.org/wiki/User:Andrebis) 绘制的 3D 表面图，来源于
    [Wikipedia](https://en.wikipedia.org/wiki/Lagrange_multiplier#/media/File:As_wiki_lgm_parab.svg)
    CC BY-SA 3.0。
- en: It’s much easier to deal with convex functions since otherwise it can be really
    hard to tell whether the minimum found is the lowest of all (i.e., the global
    minimum) and not just some local minimum. In general, even when there is one minimum
    value there can be many points that satisfy it (e.g., if it’s flat) we will pretend
    that this case doesn’t happen to simplify the explanation; assuming that it happens
    won’t change anything we derive whatsoever.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 处理凸函数要容易得多，因为否则很难判断找到的最小值是否是所有值中的最低点（即全局最小值），而不仅仅是某个局部最小值。一般来说，即使存在一个最小值，也可能有多个点满足它（例如，如果函数是平的），我们将假设这种情况不会发生以简化解释；假设它发生也不会改变我们得出的任何结论。
- en: 'Performing unconstrained optimization on a given multivariable function *f(u)*
    is possible by solving *∇ᵤf(u) = 0\.* If *f(u)* is a function in *n* variables
    *(u***₁***, u*₂*,…,u*ₙ*)* then this is a system of *n* equations:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对给定的多变量函数 *f(u)* 进行无约束优化可以通过解 *∇ᵤf(u) = 0* 来实现。如果 *f(u)* 是一个 *n* 变量的函数 *(u***₁***,
    u*₂*,…,u*ₙ*)*，那么这就是一个 *n* 方程的系统：
- en: '![](../Images/7ce5c143b36a8b273112ca1909d33633.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7ce5c143b36a8b273112ca1909d33633.png)'
- en: Which once solved returns the optimal solution *u*=(u****₁***,u**₂*,…,u**ₙ*)*
    which is where the optimal value (e.g., minimum) occurs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 解出这些方程后，会得到最优解 *u*=(u****₁***,u**₂*,…,u**ₙ*)*，即最优值（例如最小值）所在的位置。
- en: '![](../Images/8aab1194bce59f3a1becb388975da237.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8aab1194bce59f3a1becb388975da237.png)'
- en: Tangent Plane on a Surface by Mike Run on [Wikimedia](https://commons.wikimedia.org/wiki/File:Law-of-reflection-for-curved-surfaces.svg)
    CC BY-SA 4.0.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Mike Run 绘制的表面上的切平面，来源于 [Wikimedia](https://commons.wikimedia.org/wiki/File:Law-of-reflection-for-curved-surfaces.svg)
    CC BY-SA 4.0。
- en: 'To see where this comes from, recall that:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这点，请回忆一下：
- en: The normal vector to the tangent plane at any point *u* takes the form *(∂f(u)/∂u₁,
    ∂f(u)/∂u*₂, …, *∂f(u)/∂u*ₙ, *f(u))*
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任意点 *u* 处，切平面的法向量形式为 *(∂f(u)/∂u₁, ∂f(u)/∂u*₂, …, *∂f(u)/∂u*ₙ, *f(u))*
- en: The tangent plane at any minimum or maximum is horizontal (visually obvious)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何最小值或最大值处，切平面都是水平的（视觉上明显）
- en: Hence, whenever *∇ᵤf(u) = 0* holds, there is a horizontal tangent plane at that
    point and thus, must be the minimum we are looking for.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，每当 *∇ᵤf(u) = 0* 成立时，该点处必定存在水平切平面，因此，它一定是我们寻找的最小值。
- en: Another way to rationalize this which will be useful shortly, is to observe
    that the gradient points towards the direction of greatest increase (AND opposite
    to the direction of greatest decrease). Thus, when *∇ᵤf(u) = 0* holds, it must
    either be not possible to (there is no direction that would) increase the function
    from that point (i.e., at maximum) or decrease the function from that point (i.e.,
    at a minimum).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种即将有用的合理化方法是观察梯度指向最大增加的方向（以及与最大减少的方向相反）。因此，当 *∇ᵤf(u) = 0* 时，必须要么无法（没有方向能）从该点增加函数（即，处于最大值），要么从该点减少函数（即，处于最小值）。
- en: '**Unconstrained Optimization Summary**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**无约束优化总结**'
- en: '**Given:** *f(u)*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**给定：** *f(u)*'
- en: '**Wanted:** *u where f(u) is minimum*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标：** *u，其中 f(u) 最小*'
- en: '**Approach:** Solve *∇ᵤf(u)* = 0 since that holds at the minimum'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法：** 求解 *∇ᵤf(u)* = 0，因为在最小值处成立'
- en: '![](../Images/501d8eb69a61133d8c17584aa8e7b288.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/501d8eb69a61133d8c17584aa8e7b288.png)'
- en: Photo by [Jorge Reyna](https://unsplash.com/@jorgereyna?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图片来源于 [Jorge Reyna](https://unsplash.com/@jorgereyna?utm_source=medium&utm_medium=referral)
    在 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: Constrained Optimization
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 受限优化
- en: In this type of optimization, we are given an equality constraint of the form
    *g(u)=0* or g(u)≤0 (else we can put it in this form by rearranging terms or multiplying
    by a negative) and we want to optimize **over only all the points satisfying the
    constraint**.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种类型的优化中，我们给定形式为 *g(u)=0* 或 g(u)≤0 的等式约束（否则我们可以通过重新排列项或乘以负数将其转化为这种形式），并且我们希望**仅在满足约束的所有点上进行优化**。
- en: We typically assume that equality constraints *g(u)=0* are affine (generalization
    of linear) and that inequality constraints g(u)≤0 involve convex functions so
    that the whole optimization problem is [convex](https://en.wikipedia.org/wiki/Convex_optimization)
    (otherwise, the fact that *f(u)* is convex alone may not be sufficient to guarantee
    one optimal value).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常假设等式约束 *g(u)=0* 是仿射的（线性的一般化），而不等式约束 g(u)≤0 涉及凸函数，以便整个优化问题是 [凸的](https://en.wikipedia.org/wiki/Convex_optimization)（否则，仅
    *f(u)* 是凸的可能不足以保证唯一最优值）。
- en: '**Constraint Optimization with Equality Constraints**'
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**带有等式约束的优化**'
- en: In this, we are given a multivariable function *f(u)* and a constraint *g(u)=0*
    and we want to find the point *u** where *g(u*)=0* and *f(u*)* is minimum (i.e.,
    lowest possible point while satisfying the constraint).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在此问题中，我们给定一个多变量函数 *f(u)* 和一个约束 *g(u)=0*，我们希望找到点 *u**，使得 *g(u*)=0* 且 *f(u*)*
    最小（即，满足约束的情况下的最低点）。
- en: '![](../Images/5da79d58c0d542dd0b841c58611ef0f3.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5da79d58c0d542dd0b841c58611ef0f3.png)'
- en: Constrained Optimization by [Jacobmelgrad](https://commons.wikimedia.org/w/index.php?title=User%3AJacobmelgaard&action=edit&redlink=1)
    on [Wikipedia](https://en.wikipedia.org/wiki/Lagrange_multiplier#/media/File:Lagrange_very_simple.svg)
    CC BY-SA 3.0.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 受限优化由 [Jacobmelgrad](https://commons.wikimedia.org/w/index.php?title=User%3AJacobmelgaard&action=edit&redlink=1)
    在 [维基百科](https://en.wikipedia.org/wiki/Lagrange_multiplier#/media/File:Lagrange_very_simple.svg)
    CC BY-SA 3.0.
- en: For instance, in the example shown the objective function is *f(u₁,u*₂*) = u₁+
    u*₂ (3D plane) and the constraint is *u*²*₁+ u*²₂=1 (2D circle). The goal is to
    find the point (*u₁, u*₂) corresponding to the lowest point on the planewhere
    *u*²*₁+ u*²₂=1 holds *(*i.e., the (*u₁, u*₂) where the lowest point on the circle
    projected onto the plane occurs).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在所示的示例中，目标函数为 *f(u₁,u*₂*) = u₁+ u*₂（3D平面），约束为 *u*²*₁+ u*²₂=1（2D圆）。目标是找到点（*u₁,
    u*₂），使得在满足 *u*²*₁+ u*²₂=1 的情况下，该点对应于平面上的最低点（即，圆在平面上的投影最低点）。
- en: 'One approach to solve this type of constrained optimization problems is to
    use the method of Lagrange multipliers. In simple terms, the Lagrange multiplier
    theorem states that any solution *u** to an optimization problem of the form:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这种类型的受限优化问题的一种方法是使用拉格朗日乘子法。简单来说，拉格朗日乘子定理表明，任何优化问题的解 *u** 形式为：
- en: '**Minimize** *f(u)* **such that** *g(u)=0*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**最小化** *f(u)* **使得** *g(u)=0*'
- en: must satisfy the equation*∇ᵤL(u*,λ)=0* forsome *λ*∈R *(*and trivially, *g(u*)=0)*
    where *L* is the Lagrangianfunction which is given by *L(u,λ)=f(u)+λg(u).* It
    assumes that *∇ᵤg(u*)≠0.*
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 必须满足方程*∇ᵤL(u*,λ)=0*，对于某些 *λ*∈R *（并且显然，*g(u*)=0）*，其中 *L* 是拉格朗日函数，定义为 *L(u,λ)=f(u)+λg(u)*。这假设
    *∇ᵤg(u*)≠0*。
- en: It follows from this that we can solve constrained optimization problems with
    equality constraints as follows (assuming *∇ᵤg(u*)≠0):*
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由此可得，我们可以按照以下方法求解带有等式约束的受限优化问题（假设 *∇ᵤg(u*)≠0*）：
- en: Write the Lagrangian function *L(u,λ)=f(u)+λg(u).*
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Solve *n+1* equations resulting from *∇ᵤL(u,λ)* = 0 (*n* equations) with *g(u)=0*
    to find the *n+1* unknowns *u****₁***,u**₂*,…,u**ₙ,*λ*
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The solution is *u*=(u****₁***,u**₂*,…,u**ₙ*)*
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*λ* is called a Lagrange multiplier. We only need to find it because it’s part
    of the system that yields the solution *u*.*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'You can work out the example corresponding to the figure above [here](https://en.wikipedia.org/wiki/Lagrange_multiplier#Example_1).
    In this example, the problem is not convex and solving should yield any minimum
    or maximum present. Notice that steps (1) and (2) above are equivalent to performing
    unconstrained optimization on *L(u,λ)=f(u)+λg(u).* That is, setting:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '*∇ L(u,λ)* =*(∂L(u)/∂u₁, ∂L(u)/∂u*₂, …, *∂L(u)/∂u*ₙ, *∂L(u)/∂λ)=* 0'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: In this sense, this method of Lagrange multipliers is powerful in that it casts
    a constrained optimization problem into an unconstrained optimization problem
    which we can solve by simply setting the gradient as zero.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5da79d58c0d542dd0b841c58611ef0f3.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
- en: Constrained Optimization by [Jacobmelgrad](https://commons.wikimedia.org/w/index.php?title=User%3AJacobmelgaard&action=edit&redlink=1)
    on [Wikipedia](https://en.wikipedia.org/wiki/Lagrange_multiplier#/media/File:Lagrange_very_simple.svg)
    CC BY-SA 3.0.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '**Rationale**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: It’s not hard to derive with intuition why this works. The **feasible region**
    is the set of points that satisfy the problem’s constraints (e.g., those on the
    circle above); we want to find, among such points, the point where the objective
    function is optimum.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: We know that *∇ f(u)* points opposite to the direction of the greatest decrease
    (along the direction of the greatest increase). However, in our case, we are only
    allowed to move in the feasible region (points satisfying the constraint); thus,
    to minimize the function under the constraint, we should want to move in the direction
    of greatest decrease *along* the constraint curve (so we never exit the feasible
    region and reach the min).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose the direction of the tangent at point *u* on the constraint curve is
    given by *r(u)*, then recalling the formula for [vector projection](https://en.wikipedia.org/wiki/Vector_projection),
    we want to move opposite to the following direction (*∇ f(u)* projection on *r(u))*:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2b29b634b577eb5476a6c9008e40d3c1.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
- en: Similar to the unconstrained case above, it should dawn on you that whenever
    this is 0, we can’t move in any direction along the constraint to further increase
    *f(u)* (if at a maximum) or decrease it (if at a minimum).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: It’s obvious that for this to be zero, we need *r(u)≠0* (so the denominator
    isn’t zero) and *∇ f(u) ⋅ r(u)=0\.* For the latter,We know that the normal vector
    on the constraint curve*∇ g(u)* is perpendicular to the tangent *r(u).* Hence,
    all we need is*∇ f(u)* to be parallel to *∇ g(u).*
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'Thereby, it must hold at the optimal point *u** that:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'The normal to the constraint is nonzero: *∇ g(u*)≠0* (so that *r(u*)≠0)*'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The constraint is satisfied: *g(u*)=0* (trivial requirement)'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 约束满足：*g(u*)=0*（简单要求）
- en: '*∇ f(u*)* ∥*∇ g(u*)*: there exists some real β where*∇ f(u*) =* β*∇ g(u*)*'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*∇ f(u*)* ∥*∇ g(u*)*：存在一个实数β，使得*∇ f(u*) =* β*∇ g(u*)*'
- en: Notice that by rearranging terms and renaming -β, (3) is equivalent to “there
    exists some real *λ* where *∇ f(u)+λ∇ g(u)=0”.* In other words, *∇ᵤL(u,λ)* = 0,
    and by that, we have intuitively derived the Lagrange multipliers theorem for
    one constraint (scroll up if needed).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通过重新排列项和重新命名 -β，（3）等价于“存在一个实数 *λ* 使得 *∇ f(u)+λ∇ g(u)=0*”。换句话说，*∇ᵤL(u,λ)*
    = 0，借此我们直观地推导出了一个约束的拉格朗日乘子定理（如有需要，请向上滚动查看）。
- en: Notice that the first condition is called a constraint qualification. If it
    isn’t satisfied by the constraint at a point where (2) and (3) are satisfied,
    then there are no guarantees that this point is optimal as the projection is not
    defined there.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第一个条件称为约束资格。如果约束在满足（2）和（3）的点上不满足该条件，则没有保证该点是最优的，因为在该点上投影未定义。
- en: '**Multiple Equality Constraints**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**多个等式约束**'
- en: 'When multiple constraints g*₁(u), g*₂*(u),…,g*ₖ*(u)* are present, the method
    smoothly generalizes to the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在多个约束*g*₁(u), g*₂*(u),…,g*ₖ*(u)*时，该方法可以顺利推广到以下情况：
- en: Write the Lagrangian *L(u,λ₁,λ*₂*,…,λ*ₖ*) = f(u) + λ₁*g*₁(u) + λ*₂g₂*(u) +…+λ*ₖgₖ*(u)*
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写出拉格朗日函数 *L(u,λ₁,λ*₂*,…,λ*ₖ*) = f(u) + λ₁*g*₁(u) + λ*₂g₂*(u) +…+λ*ₖgₖ*(u)*
- en: Solve *n+k* equations by setting*∇ᵤL(u,λ₁,λ*₂*,…,λ*ₖ*)* = 0 (*n* equations)
    with *g₁(u)=0, g*₂*(u)=0, …, g*ₖ*(u)=0* to find *n+k* unknowns *u****₁***,u**₂*,…,u**ₙ,
    *λ₁,λ*₂*,…,λ*ₖ
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过设置*∇ᵤL(u,λ₁,λ*₂*,…,λ*ₖ*)* = 0（*n*个方程）和 *g₁(u)=0, g*₂*(u)=0, …, g*ₖ*(u)=0*
    来求解 *n+k* 个方程，以找到 *n+k* 个未知数 *u****₁***,u**₂*,…,u**ₙ, *λ₁,λ*₂*,…,λ*ₖ
- en: The solution is *u*=(u****₁***,u**₂*,…,u**ₙ*)*
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解为 *u*=(u****₁***,u**₂*,…,u**ₙ*)*
- en: The assumption*∇ g(u*)*≠*0* generalizes to that *∇* g*₁(u), ∇ g*₂*(u),…,∇ g*ₖ*(u)*
    must be linearly independent. This is called LICQ (linear independence constraint
    qualification).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 假设*∇ g(u*)*≠*0* 可以推广为 *∇* g*₁(u), ∇ g*₂*(u),…,∇ g*ₖ*(u)* 必须线性无关。这称为LICQ（线性独立约束资格）。
- en: '![](../Images/32bacc9722a73cdd828171b12bfcfa6d.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/32bacc9722a73cdd828171b12bfcfa6d.png)'
- en: Photo by [Jairph](https://unsplash.com/@jairph?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 照片由[Jairph](https://unsplash.com/@jairph?utm_source=medium&utm_medium=referral)在[Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)提供
- en: Constraint Optimization with Inequality Constraints
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有不等式约束的约束优化
- en: Matters don’t get much more complex when we are rather dealing with an inequality
    constraint of the form *g(u)≤0*. In this case, we want the optimum point of *f(u)*
    that satisfies *g(u)≤0.*
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理形式为*g(u)≤0*的不等式约束时，问题不会变得更复杂。在这种情况下，我们希望找到满足*g(u)≤0*的*f(u)*的最优点。
- en: For the problem above, this means that the feasible region is not just the points
    on the circle, it’s also the points inside it. It should be obvious that for that
    particular problem (and not generally), this does not change the solution.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述问题，这意味着可行区域不仅仅是圆上的点，还包括圆内的点。对于特定问题（而不是一般情况），这显然不会改变解决方案。
- en: '![](../Images/26889ebcefeed62886e273e6efe884d3.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/26889ebcefeed62886e273e6efe884d3.png)'
- en: Constrained Optimization by [Jacobmelgrad](https://commons.wikimedia.org/w/index.php?title=User%3AJacobmelgaard&action=edit&redlink=1)
    on [Wikipedia](https://en.wikipedia.org/wiki/Lagrange_multiplier#/media/File:Lagrange_very_simple.svg)
    CC BY-SA 3.0\. Modified by Shading.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 受约束的优化由[Jacobmelgrad](https://commons.wikimedia.org/w/index.php?title=User%3AJacobmelgaard&action=edit&redlink=1)在[维基百科](https://en.wikipedia.org/wiki/Lagrange_multiplier#/media/File:Lagrange_very_simple.svg)上提供，CC
    BY-SA 3.0。经Shading修改。
- en: 'Instead of solving the two conditions of Lagrange multipliers (2, 3) we solve
    a set of four conditions called KKT conditions that generalize the Lagrange multipliers
    case. We can derive them as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不解决拉格朗日乘子条件（2, 3），而是解决一组称为KKT条件的四个条件，这些条件是拉格朗日乘子情况的一般化。我们可以如下推导这些条件：
- en: '![](../Images/6650ca453c20451a371f2b4e1249283e.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6650ca453c20451a371f2b4e1249283e.png)'
- en: Inequality constraint diagram for optimization problems by [Onmyphd](https://commons.wikimedia.org/w/index.php?title=User%3AOnmyphd&action=edit&redlink=1)
    on [Wikipedia](https://en.wikipedia.org/wiki/Karush%E2%80%93Kuhn%E2%80%93Tucker_conditions#/media/File:Inequality_constraint_diagram.svg)
    CC BY-SA 3.0.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 优化问题的不等式约束图由[Onmyphd](https://commons.wikimedia.org/w/index.php?title=User%3AOnmyphd&action=edit&redlink=1)在[维基百科](https://en.wikipedia.org/wiki/Karush%E2%80%93Kuhn%E2%80%93Tucker_conditions#/media/File:Inequality_constraint_diagram.svg)上提供，CC
    BY-SA 3.0。
- en: 'Observe that with an arbitrary hypersurface *f(u)* and constraint *g(u)≤0,*
    there are exactly two possibilities assuming a convex smooth function with one
    optimum:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于一个任意的超曲面 *f(u)* 和约束 *g(u)≤0,* 假设是一个凸平滑函数且有一个最优点，那么有两种可能：
- en: The optimum point *uᴾ* lies inside the feasible region.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最优点 *uᴾ* 位于可行区域内。
- en: In this case, the solution to the optimization problem *u** must be *uᴾ* and
    *g(u*)<0* must hold (left image).
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，优化问题的解 *u** 必须是 *uᴾ* 且 *g(u*)<0* 必须成立（左侧图像）。
- en: It’s impossible to find a more optimum point in the feasible region because
    *uᴾ* is the most optimal point (e.g., minimum) over the entire region (domain)
    of *f(u).*
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可行区域中不可能找到更优的点，因为 *uᴾ* 是 *f(u)* 的整个区域（领域）上的最优点（例如最小值）。
- en: 2\. The optimum point *uᴾ* lies outside the feasible region.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 最优点 *uᴾ* 位于可行区域外。
- en: In this case, *f(u)* must be only decreasing in the feasible region if that
    point is a maximum (can’t increase again else creates another optimal point)
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，如果点是最大值，*f(u)* 在可行区域中必须只是减少（不能再增加，否则会产生另一个最优点）
- en: '*f(u)* must be only increasing in the feasible region if that point is a minimum
    (can’t decrease again else creates another optimal point)'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果点是最小值，*f(u)* 在可行区域中必须只是增加（不能再减少，否则会产生另一个最优点）
- en: Thus, the optimum point *u** must be at the edge of the feasible region as it
    never gets better inside (*g(u*) = 0* must hold)
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，最优点 *u** 必须位于可行区域的边缘，因为在内部不会变得更好（*g(u*) = 0* 必须成立）
- en: In the first case, it’s obvious that solving the optimization problem is equivalent
    to solving the unconstrained version of it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，显然求解优化问题等同于求解无约束版本的问题。
- en: '*∇ᵤf(u) = 0*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*∇ᵤf(u) = 0*'
- en: We say that the constraint is “inactive because” it doesn’t make a difference
    in the optimization problem.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称约束为“非活跃的”是因为它在优化问题中没有影响。
- en: In the second case, it’s obvious that solving the optimization problem is equivalent
    to solving the equality constraint version of it (Lagrange multipliers).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，显然求解优化问题等同于求解等式约束版本的问题（拉格朗日乘数法）。
- en: The only catch for that case is that *λ* must be ≥ 0 for minimization and must
    be ≤ 0 for maximization. For minimization, this implies that *∇ᵤf(u)* and *∇ᵤg(u)*
    point in opposite directions (i.e., β in*∇ᵤ f(u) =* β*∇ ᵤg(u)* is ≤0) which has
    to hold because *∇ᵤg(u)* points towards the positive side of the constraint *g(u)≥0*
    (basic property)*;* meanwhile, *∇ᵤ f(u)* points to the negative side of the constraint
    because that’s where *f(u)* is increasing. A similar argument can be easily constructed
    for the case of maximization.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况唯一需要注意的是，*λ* 对于最小化必须 ≥ 0，对最大化必须 ≤ 0。对于最小化，这意味着 *∇ᵤf(u)* 和 *∇ᵤg(u)* 指向相反方向（即，β
    在 *∇ᵤ f(u) =* β*∇ᵤg(u)* 是 ≤0），这必须成立，因为 *∇ᵤg(u)* 指向约束 *g(u)≥0* 的正侧（基本属性）；与此同时，*∇ᵤ
    f(u)* 指向约束的负侧，因为 *f(u)* 在那里增加。对于最大化情况，可以轻松构造类似的论证。
- en: 'But we don’t know beforehand which of these two cases applies. We can merge
    their methods as follows (assuming minimization):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们事先不知道这两种情况中的哪一种适用。我们可以按照以下方法合并它们（假设最小化）：
- en: Write the Lagrangian function *L(u,λ)=f(u)+λg(u)*
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写出拉格朗日函数 *L(u,λ)=f(u)+λg(u)*
- en: Set *∇ᵤL(u,λ)* = 0 (*n* equations) and *g(u)≤0*
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 *∇ᵤL(u,λ)* = 0（*n* 个方程）和 *g(u)≤0*
- en: 'Solve for the solution (*u****₁***,u**₂*,…,u**ₙ,*λ.*) where one of the cases
    above applies:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 求解解 (*u**₁***,u**₂*,…,u**ₙ,*λ.*) 其中一个以上情况适用：
- en: '*λ=0* and *g(u*)<0 (*first case as *λ=0* means that *∇ᵤL(u,λ)* = *∇ᵤf(u) =
    0* so steps 1,2 are equivalent to solving *∇ᵤf(u) = 0*)'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*λ=0* 和 *g(u*)<0*（*λ=0* 的第一个情况意味着 *∇ᵤL(u,λ)* = *∇ᵤf(u) = 0*，因此步骤 1,2 等同于求解
    *∇ᵤf(u) = 0*）'
- en: '*g(u*)=0* and *λ≥0 (*second case as *g(u)=0* means that applying Lagrange is
    correct and that’s what we did)'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*g(u*)=0* 和 *λ≥0*（第二种情况，因为 *g(u)=0* 意味着拉格朗日方法是正确的，这就是我们所做的）'
- en: 'We can summarize these two bullets in that *g(u*)≤0* and *λ≥0* must hold and
    that *λg(u*)=0* must hold (one of *λ* or *g(u*)* must be zero). This implies that
    given an optimization problem of the form:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以总结这两点，即 *g(u*)≤0* 和 *λ≥0* 必须成立，并且 *λg(u*)=0* 必须成立（*λ* 或 *g(u*)* 之一必须为零）。这意味着给定一个形式的优化问题：
- en: '**Minimize** *f(u)* **such that** *g(u)≤0*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**最小化** *f(u)* **使得** *g(u)≤0*'
- en: We expect the following four conditions to be satisfied for the optimal point
    *u*:*
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望最优点 *u* 满足以下四个条件：
- en: 'Stationarity: *∇ᵤL(u*,λ)* = 0'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 稳定性：*∇ᵤL(u*,λ)* = 0
- en: 'Primal Feasibility: *g(u*)≤0*'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始可行性：*g(u*)≤0*
- en: 'Dual Feasibility: *λ≥0*'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双重可行性：*λ≥0*
- en: 'Complementary Slackness: *λg(u*)=0*'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 互补松弛性：*λg(u*)=0*
- en: and that solving these conditions together yields the optimal point u*. In reality
    for [convex problems](https://en.wikipedia.org/wiki/Convex_optimization), these
    conditions are sufficient but not necessary for optimality. That is,
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 并且解决这些条件一起产生最优点*u*。实际上，对于[凸优化问题](https://en.wikipedia.org/wiki/Convex_optimization)，这些条件是充分但不是必要的。也就是说，
- en: If a point satisfies these conditions (e.g., found by solving them together)
    then that suffices to prove that the point is optimal (no need to look further
    for convex problems).
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个点满足这些条件（例如，通过一起解决它们找到），那么这足以证明该点是最优的（对于凸问题无需进一步寻找）。
- en: Meanwhile, these conditions are not necessary for a point to be optimal. It
    is possible that solving the conditions gives no solution when in reality there
    is an optimal point that doesn’t satisfy them. For example, consider *f(x) = x*
    and the constraint *x² ≤ 0* (both [this and another KKT example](https://drive.google.com/drive/u/1/folders/1uQ9iiadmIY-hg2DnjQaYfE3xNHgMdWrN)
    are solved in this document)
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与此同时，这些条件并非点必须为最优点的必要条件。有可能解决这些条件却没有解时，在现实中存在一个满足条件但不满足它们的最优点。例如，考虑*f(x) = x*和约束*x²
    ≤ 0*（此外，[这里和另一个KKT示例](https://drive.google.com/drive/u/1/folders/1uQ9iiadmIY-hg2DnjQaYfE3xNHgMdWrN)在本文档中解决）。
- en: Once we enforce a constraint qualification such as LICQ (stated earlier), we
    can guarantee that KKT conditions are both sufficient and necessary. An alternative
    constraint qualification that is easier to check is Slater’s condition which guarantees
    that KKT is necessary and sufficient for convex problems.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们强制执行诸如LICQ（前述）的约束条件，我们可以保证KKT条件既充分又必要。一个更易于检查的替代约束条件是Slater的条件，它保证了对于凸问题，KKT是充分且必要的。
- en: Slater’s condition simply states that the feasible region must have an interior
    point. That is, for a constraint *g(u)≤0* the function must have point(s) in the
    domain of *f(u)* satisfying *g(u)<0\.* This is a basic condition that is almost
    always satisfied in real-life problems (but not the counterexample above), and
    this means that KKT will rarely ever miss finding an optimal solution.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Slater的条件简单地表明可行域必须有一个内点。也就是说，对于约束*g(u)≤0*，函数必须有域*f(u)*内满足*g(u)<0*的点。这是一个基本条件，在现实生活中几乎总是满足的（但不包括上述反例），这意味着KKT很少会错过寻找最优解。
- en: '**Multiple Constraints**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**多重约束**'
- en: 'When multiple equality constraints h*₁(u), h*₂*(u),…,h*ₖ*(u)* are present along
    with multiple inequality constraints g*₁(u), g*₂*(u),…,g*ₚ*(u)*, the method smoothly
    generalizes by writing the full Lagrangian and checking the KKT conditions only
    for inequality constraints and their multipliers (which we will call α):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在多个等式约束*h*₁(u), h*₂*(u),…,h*ₖ*(u)*以及多个不等式约束*g*₁(u), g*₂*(u),…,g*ₚ*(u)*时，该方法通过编写完整的拉格朗日函数并仅对不等式约束及其乘子（我们称之为α）检查KKT条件来平滑地推广：
- en: 0\. Write the Lagrangian
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 0\. 写出拉格朗日函数
- en: '![](../Images/7529d8b5c057f5fd95356441a226b6f4.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7529d8b5c057f5fd95356441a226b6f4.png)'
- en: Set*∇ᵤL(u,λ₁,λ*₂*,…,λ*ₖ, α*₁*, α₂, …, αₚ*)* = 0 (n equations)
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置*∇ᵤL(u,λ₁,λ*₂*,…,λ*ₖ, α*₁*, α₂, …, αₚ*)* = 0（n个方程）
- en: 2\. Set h*₁(u)=0, h*₂*(u)=0, …, h*ₖ*(u)=0 (k* equations) and set
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 设置*h*₁(u)=0, h*₂*(u)=0, …, h*ₖ*(u)=0（k*个方程），并设置
- en: g*₁(u)≤0, g*₂*(u)≤0, …, g*ₚ*(u)≤0* (*p* inequalities)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: g*₁(u)≤0, g*₂*(u)≤0, …, g*ₚ*(u)≤0*（*p*个不等式）
- en: 3\. Set α*₁≥0*, α₂≥0, …, αₚ≥0 (*p* inequalities)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 设置α*₁≥0*, α₂≥0, …, αₚ≥0（*p*个不等式）
- en: 4\. Set α*₁*g*₁(u) =* α₂*g*₂*(u) =* αₚ*g*ₖ*(u) = 0* (*p* equations)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 设置α*₁*g*₁(u) =* α₂*g*₂*(u) =* αₚ*g*ₖ*(u) = 0（*p*个方程）
- en: In total, you have *n+k+p* equations and *2p* inequalities that you will solve
    together to find *n+k+p* variables *(u****₁***,u**₂*,…,u**ₙ,*λ₁,λ*₂*,…,λ*ₖ,α*₁*,
    α₂, …, αₚ *)* which would yield the solution *u*=(u****₁***,u**₂*,…,u**ₙ*)* that
    minimizes the function while satisfying the *k+p* constraints.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 总共，您有*n+k+p*个方程和*2p*个不等式，您将一起解决以找到*n+k+p*个变量*(u****₁***,u**₂*,…,u**ₙ,*λ₁,λ*₂*,…,λ*ₖ,α*₁*,
    α₂, …, αₚ *)*，这将产生最小化函数并满足*k+p*个约束的解*u*=(u****₁***,u**₂*,…,u**ₙ*)*。
- en: '![](../Images/f4abf591968faa51746f8c2305eb5988.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f4abf591968faa51746f8c2305eb5988.png)'
- en: Photo by [SpaceX](https://unsplash.com/@spacex?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 照片由[SpaceX](https://unsplash.com/@spacex?utm_source=medium&utm_medium=referral)提供的
    [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral) 上获取
- en: The Duality Principle
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对偶原理
- en: The duality principle simply states that for any optimization problem, we can
    write a dual optimization problem that when solved either tells us something about
    the original problem (called primal) or solves it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对偶原理简单地说明，对于任何优化问题，我们可以写出一个对偶优化问题，解决它可以告诉我们原始问题（称为原始问题）的某些内容或者直接解决它。
- en: 'For any optimization problem of the form:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何形式的优化问题：
- en: '![](../Images/e18b1d046a18f6de01955a0da13db128.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e18b1d046a18f6de01955a0da13db128.png)'
- en: 'The dual optimization problem takes the form:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对偶优化问题的形式是：
- en: '![](../Images/a6e209be534cbc88f290fa80842e2d55.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a6e209be534cbc88f290fa80842e2d55.png)'
- en: Yes, what’s minimized takes the same form as the Lagrangian
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，最小化的形式与拉格朗日函数相同
- en: and vice versa if it is maximization.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 反之亦然，如果是最大化。
- en: '**Example**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**'
- en: 'For instance, the constrained optimization problem that we discussed earlier:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们之前讨论的受约束优化问题：
- en: '![](../Images/00f3d920a058f61dfc08cee96350b8ae.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/00f3d920a058f61dfc08cee96350b8ae.png)'
- en: 'Has the corresponding dual problem:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 具有相应的对偶问题：
- en: '![](../Images/c467f002fc40352291fe47889beb5986.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c467f002fc40352291fe47889beb5986.png)'
- en: As basic calculus suggests, to carry on the minimization first we do
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如基本微积分所示，要进行最小化，我们首先做
- en: '![](../Images/2cfd493b0d031b1d57d9e2d56a771614.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2cfd493b0d031b1d57d9e2d56a771614.png)'
- en: which implies
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着
- en: '![](../Images/a26caebb7ae806f60f9abca6d8c2fa8c.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a26caebb7ae806f60f9abca6d8c2fa8c.png)'
- en: and thereby, the optimization problem becomes
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，优化问题变成
- en: '![](../Images/84309110d276e7589f29470011a95b29.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/84309110d276e7589f29470011a95b29.png)'
- en: and all it takes now is to differentiate this and equate to zero to get λ =
    1/√2 which implies that *(x*, y*)* = (−1/√2, −1/√2) and which is the same solution
    that we had by solving the primal problem via KKT.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所需的只是对其进行微分并使其等于零，从而得到 λ = 1/√2，这意味着 *(x*, y*)* = (−1/√2, −1/√2)，这与通过 KKT
    解决原始问题所得到的解相同。
- en: '**Deriving the Dual**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**推导对偶**'
- en: The primal (original) problem is
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 原始（原始）问题是
- en: '![](../Images/f01b58c1873fac972a959be472e5b2fd.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f01b58c1873fac972a959be472e5b2fd.png)'
- en: 'Suppose we define a function that returns infinity whenever *u* is not in the
    feasible region (doesn’t satisfy the constraint), and zero otherwise:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们定义一个函数，当 *u* 不在可行区域内（不满足约束）时返回无穷大，否则返回零：
- en: '![](../Images/850a15a476043605c867247c376fb50b.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/850a15a476043605c867247c376fb50b.png)'
- en: In this case, the primal problem is equivalent to
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，原始问题等价于
- en: '![](../Images/3907fd374957f9da31adb34a672209be.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3907fd374957f9da31adb34a672209be.png)'
- en: This should make sense because *f(u)+P(u)* sets anything outside of the feasible
    region to infinity and leaves the feasible region as is. The minimum of this sum
    must occur in the feasible region even though the constraint is enforced explicitly
    because infinity is greater than anything.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该是合理的，因为 *f(u)+P(u)* 将可行区域之外的值设为无穷大，并保持可行区域不变。这个和的最小值必须发生在可行区域内，即使约束是明确强制的，因为无穷大大于任何东西。
- en: 'Observe that we can claim that:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到我们可以声明：
- en: '![](../Images/112ce6363f6219b8ee7073e4ef6f1a6d.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/112ce6363f6219b8ee7073e4ef6f1a6d.png)'
- en: 'Because with this, if:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 因为有了这个，如果：
- en: '*g(u)<0* then *P(u)=0* as defined earlier since *λ=0* must hold to maximize
    the quantity *λg(u)* (else it’s negative due to *g(u)<0*)'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*g(u)<0* 时 *P(u)=0*，如之前定义，因为要最大化 *λg(u)* 必须满足 *λ=0*（否则由于 *g(u)<0* 它是负值）'
- en: '*g(u)=0* then *P(u)=0* as defined earlier as *λg(u)* will be zero (*λ* can
    be anything)'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*g(u)=0* 时 *P(u)=0*，如之前定义，因为 *λg(u)* 将为零（*λ* 可以是任何值）'
- en: '*g(u)>0* then *P(u)=*∞ as defined earlier as *λ=*∞ is what would maximize *λg(u)*'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*g(u)>0* 时 *P(u)=*∞，如之前定义，*λ=*∞ 是最大化 *λg(u)* 的值'
- en: Thereby, the primal problem is equivalent to
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，原始问题等价于
- en: '![](../Images/0873677c905f0b22d8e443aa4709e91e.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0873677c905f0b22d8e443aa4709e91e.png)'
- en: It’s okay to introduce f to the Max since it isn’t an explicit function in *λ*
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 f 到最大值是可以的，因为它不是 *λ* 的显式函数
- en: The difference between this and the dial problem is that in the dual the Max
    and Min are swapped.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个和对偶问题的区别在于，在对偶中最大值和最小值被交换了。
- en: '![](../Images/f8f418d86b425be55e95b7913751c435.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f8f418d86b425be55e95b7913751c435.png)'
- en: Thus, because in general *MinMax(…) ≥ MaxMin(…)* a solution to the dual would
    be a lower bound to the solution of the primal. This is called weak duality.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，因为一般来说 *MinMax(…) ≥ MaxMin(…)*，对偶的解将是原始问题解的下界。这被称为弱对偶性。
- en: A more interesting case is when *MinMax(…) = MaxMin(…)* where a solution to
    the dual would be exactly the solution to the primal as well (as in the example).
    This is called strong duality. You can moderatily easily [prove that](https://or.stackexchange.com/questions/3117/is-there-any-relationship-between-kkt-and-duality)
    the equality holds (and hence strong duality) when KKT is both necessary and sufficient.
    In other words, strong duality will hold for convex problems whenever Slater’s
    condition holds!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更有趣的情况是，当*MinMax(…) = MaxMin(…)*时，双重问题的解恰好也是原始问题的解（如例子中所示）。这被称为强对偶性。你可以适度容易地[证明](https://or.stackexchange.com/questions/3117/is-there-any-relationship-between-kkt-and-duality)当KKT条件既必要又充分时，该等式成立（因此强对偶性）。换句话说，强对偶性将在Slater条件成立的情况下适用于凸问题！
- en: '**So What?**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**那又怎么样？**'
- en: If you think about it, solving the dual problem is akin to only applying the
    stationarity and dual feasibility conditions of KKT on the primal problem. Instead
    of applying primal feasibility and complementary slackness you get to deal with
    an extra minimization over dual variables. In many cases, this is much easier
    than solving KKT on the primal problem. The extra minimization can be for instance
    tackled with linear or quadratic programming.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑一下，解决对偶问题相当于仅在原始问题上应用KKT的平稳性和对偶可行性条件。你不再需要应用原始可行性和互补松弛条件，而是需要处理额外的对偶变量的最小化。在许多情况下，这比在原始问题上解决KKT要简单得多。这个额外的最小化可以通过线性或二次规划来处理。
- en: '**Multiple Constraints?**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**多个约束？**'
- en: In generalizing to multiple constraints, the Lagrangian changes just as you
    would expect (similar to what we have seen) and we only add α≥0 conditions in
    maximization to multipliers associated with inequality constraints.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在推广到多个约束时，拉格朗日函数的变化正如你所预期的那样（类似于我们所见），我们只需在最大化中为与不等式约束相关的乘子添加α≥0条件。
- en: '![](../Images/c17f9f792aabbe00b5ba338c1a4fcbdb.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c17f9f792aabbe00b5ba338c1a4fcbdb.png)'
- en: Photo by [Hyundai Motor Group](https://unsplash.com/@hyundaimotorgroup?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由[现代汽车集团](https://unsplash.com/@hyundaimotorgroup?utm_source=medium&utm_medium=referral)拍摄，刊登在[Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: Hope this story has helped you truly understand unconstrained optimization,
    Lagrange Mulipliers, KKT and duality. Till next time, au revoir!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这个故事帮助你真正理解了无约束优化、拉格朗日乘子、KKT和对偶性。下次见，再见！
