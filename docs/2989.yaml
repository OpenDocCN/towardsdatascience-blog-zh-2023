- en: Deep Dive into Pandas Copy-on-Write Mode — Part III
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/deep-dive-into-pandas-copy-on-write-mode-part-iii-c024eaa16ed4?source=collection_archive---------10-----------------------#2023-09-29](https://towardsdatascience.com/deep-dive-into-pandas-copy-on-write-mode-part-iii-c024eaa16ed4?source=collection_archive---------10-----------------------#2023-09-29)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Explaining the migration path for Copy-on-Write*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@patrick_hoefler?source=post_page-----c024eaa16ed4--------------------------------)[![Patrick
    Hoefler](../Images/35ca9ef1100d8c93dbadd374f0569fe1.png)](https://medium.com/@patrick_hoefler?source=post_page-----c024eaa16ed4--------------------------------)[](https://towardsdatascience.com/?source=post_page-----c024eaa16ed4--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----c024eaa16ed4--------------------------------)
    [Patrick Hoefler](https://medium.com/@patrick_hoefler?source=post_page-----c024eaa16ed4--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F103b3417e0f5&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fdeep-dive-into-pandas-copy-on-write-mode-part-iii-c024eaa16ed4&user=Patrick+Hoefler&userId=103b3417e0f5&source=post_page-103b3417e0f5----c024eaa16ed4---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----c024eaa16ed4--------------------------------)
    ·4 min read·Sep 29, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fc024eaa16ed4&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fdeep-dive-into-pandas-copy-on-write-mode-part-iii-c024eaa16ed4&user=Patrick+Hoefler&userId=103b3417e0f5&source=-----c024eaa16ed4---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fc024eaa16ed4&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fdeep-dive-into-pandas-copy-on-write-mode-part-iii-c024eaa16ed4&source=-----c024eaa16ed4---------------------bookmark_footer-----------)![](../Images/4c3dc59cff33a2049e06fcb3cf63d410.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Photo by [Zoe Nicolaou](https://unsplash.com/@lekneuro?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
    on [Unsplash](https://unsplash.com/photos/44g_jwn3JzY?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The introduction of Copy-on-Write (CoW) is a breaking change that will have
    some impact on existing pandas code. We will investigate how we can adapt our
    code to avoid errors when CoW will be enabled by default. This is currently planned
    for the pandas 3.0 release, which is scheduled for April 2024\. [The first post](https://medium.com/towards-data-science/deep-dive-into-pandas-copy-on-write-mode-part-i-26982e7408c6)
    in this series explained the behavior of Copy-on-Write while [the second post](https://medium.com/towards-data-science/deep-dive-into-pandas-copy-on-write-mode-part-ii-b023432a5334)
    dove into performance optimizations that are related to Copy-on-Write.
  prefs: []
  type: TYPE_NORMAL
- en: We are planning on adding a warning mode that will warn for all operations that
    will change behavior with CoW. The warning will be very noisy for users and thus
    has to be treated with some care. This post explains common cases and how you
    can adapt your code to avoid changes in behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Chained assignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Chained assignment is a technique where one object is updated through 2 subsequent
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first operation selects the column `"x"` while the second operation restricts
    the number of rows. There are many different combinations of these operations
    (e.g. combined with `loc` or `iloc`). None of these combinations will work under
    CoW. Instead, they will raise a warning `ChainedAssignmentError` to remove these
    patterns instead of silently doing nothing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, you can use `loc` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first dimension of `loc` always corresponds to the `row-indexer`. This means
    that you are able to select a subset of rows. The second dimension corresponds
    to the `column-indexer`, which enables you to select a subset of columns.
  prefs: []
  type: TYPE_NORMAL
- en: It is generally faster using `loc` when you want to set values into a subset
    of rows, so this will clean up your code and provide a performance improvement.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the obvious case where CoW will have an impact. It will also impact
    chained inplace operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The pattern is the same as above. The column selection is the first operation.
    The `replace` method tries to operate on the temporary object, which will fail
    to update the initial object. You can also remove these patterns pretty easily
    through specifying the columns you want to operate on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Patterns to avoid
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[My previous post](https://medium.com/towards-data-science/deep-dive-into-pandas-copy-on-write-mode-part-i-26982e7408c6)
    explains how the CoW mechanism works and how DataFrames share the underlying data.
    A defensiv copy will be performed if two objects share the same data while you
    are modifying one object inplace.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `reset_index` operation will create a view of the underlying data. The result
    is assigned to a new variable `df2`, this means that two objects share the same
    data. This holds true until `df` is garbage collected. The `setitem` operation
    will thus trigger a copy. This is completely unnecessary if you don't need the
    initial object `df` anymore. Simply reassigning to the same variable will invalidate
    the reference that is held by the object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Summarizing, creating multiple references in the same method keeps unnecessary
    references alive.
  prefs: []
  type: TYPE_NORMAL
- en: Temporary references that are created when chaining different methods together
    are fine.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will only keep one reference alive.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the underlying NumPy array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'pandas currently gives us access to the underlying NumPy array through `to_numpy`
    or `.values`. The returned array is a copy, if your DataFrame consists of different
    dtypes, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The DataFrame is backed by two arrays which have to be combined into one. This
    triggers the copy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other case is a DataFrame that is only backed by a single NumPy array,
    e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can directly access the array and get a view instead of a copy. This is much
    faster than copying all data. We can now operate on the NumPy array and potentially
    modify it inplace, which will also update the DataFrame and potentially all other
    DataFrames that share data. This becomes much more complicated with Copy-on-Write,
    since we removed many defensive copies. Many more DataFrames will now share memory
    with each other.
  prefs: []
  type: TYPE_NORMAL
- en: '`to_numpy` and `.values` will return a read-only array because of this. This
    means that the resulting array is not writeable.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will trigger a `ValueError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can avoid this in two different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Trigger a copy manually if you want to avoid updating DataFrames that share
    memory with your array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the array writeable. This is a more performant solution but circumvents
    Copy-on-Write rules, so it should be used with caution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'There are cases where this is not possible. One common occurrence is, if you
    are accessing a single column which was backed by PyArrow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns a `ValueError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Arrow arrays are immutable, hence it is not possible to make the NumPy array
    writeable. The conversion from Arrow to NumPy is zero-copy in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve looked at the most invasive Copy-on-Write related changes. These changes
    will become the default behavior in pandas 3.0\. We’ve also investigated how we
    can adapt our code to avoid breaking our code when Copy-on-Write is enabled. The
    upgrade process should be pretty smooth if you can avoid these patterns.
  prefs: []
  type: TYPE_NORMAL
