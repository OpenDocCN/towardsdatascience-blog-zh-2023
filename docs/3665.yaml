- en: Building A Cross-Platform TFIDF Text Summarizer In Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/building-a-cross-platform-tfidf-text-summarizer-in-rust-7b05938f4507?source=collection_archive---------4-----------------------#2023-12-14](https://towardsdatascience.com/building-a-cross-platform-tfidf-text-summarizer-in-rust-7b05938f4507?source=collection_archive---------4-----------------------#2023-12-14)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Cross Platform NLP in Rust
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Optimization with Rayon and support for C/C++, Android, Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://equipintelligence.medium.com/?source=post_page-----7b05938f4507--------------------------------)[![Shubham
    Panchal](../Images/d48aecd8b1ed27ab68fc2e7ff6716606.png)](https://equipintelligence.medium.com/?source=post_page-----7b05938f4507--------------------------------)[](https://towardsdatascience.com/?source=post_page-----7b05938f4507--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----7b05938f4507--------------------------------)
    [Shubham Panchal](https://equipintelligence.medium.com/?source=post_page-----7b05938f4507--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fd45a9465f044&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-a-cross-platform-tfidf-text-summarizer-in-rust-7b05938f4507&user=Shubham+Panchal&userId=d45a9465f044&source=post_page-d45a9465f044----7b05938f4507---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----7b05938f4507--------------------------------)
    ·12 min read·Dec 14, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F7b05938f4507&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-a-cross-platform-tfidf-text-summarizer-in-rust-7b05938f4507&user=Shubham+Panchal&userId=d45a9465f044&source=-----7b05938f4507---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F7b05938f4507&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fbuilding-a-cross-platform-tfidf-text-summarizer-in-rust-7b05938f4507&source=-----7b05938f4507---------------------bookmark_footer-----------)![](../Images/365e0c70171e5e7e57f27dd3eba968f8.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Photo by [Patrick Tomasso](https://unsplash.com/@impatrickt?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: NLP tools and utilities have grown largely in the Python ecosystem, enabling
    developers from all levels to build high-quality language apps at scale. Rust
    is a newer introduction to NLP, with organizations like [HuggingFace](https://huggingface.co/)
    adopting it to build packages for machine learning.
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/@Aaron0928/hugging-face-has-written-a-new-ml-framework-in-rust-now-open-sourced-1afea2113410?source=post_page-----7b05938f4507--------------------------------)
    [## Hugging Face has written a new ML framework in Rust, now open-sourced!'
  prefs: []
  type: TYPE_NORMAL
- en: Recently, Hugging Face open sourced a heavyweight ML framework, Candle, which
    is a departure from the usual Python…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/@Aaron0928/hugging-face-has-written-a-new-ml-framework-in-rust-now-open-sourced-1afea2113410?source=post_page-----7b05938f4507--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: In this blog, we’ll explore how we can build a text summarizer using the concept
    of TFIDF. We’ll first have an intuition on how TFIDF summarization works, and
    why Rust could be a good language to implement NLP pipelines and how we can use
    our Rust code on other platforms like C/C++, Android and Python. Moreover, we
    discuss how we can optimize the summarization task with parallel computing with
    [Rayon](https://github.com/rayon-rs/rayon).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the GitHub project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://github.com/shubham0204/tfidf-summarizer.rs?source=post_page-----7b05938f4507--------------------------------)
    [## GitHub - shubham0204/tfidf-summarizer.rs: Simple, efficient and cross-platform
    TFIDF-based text…'
  prefs: []
  type: TYPE_NORMAL
- en: Simple, efficient and cross-platform TFIDF-based text summarizer in Rust - GitHub
    - shubham0204/tfidf-summarizer.rs…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: github.com](https://github.com/shubham0204/tfidf-summarizer.rs?source=post_page-----7b05938f4507--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started ➡️
  prefs: []
  type: TYPE_NORMAL
- en: Contents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extractive and Abstractive Text Summarization
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understanding Text Summarization with TFIDF
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rust Implementation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Usage with C
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Future Scope
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I had built a text summarizer using the same technique, back in 2019, with Kotlin
    and called in [Text2Summary](https://github.com/shubham0204/Text2Summary-Android).
    It was primarily designed for Android apps, as a side project and used Kotlin
    for all computations. Fast-forward to 2023, I am now working with C, C++ and Rust
    codebases and have used modules built in these *native* languages in Android and
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: I chose to re-implement `Text2Summary` in Rust, as it would serve as a great
    learning experience and also as a small, efficient, handy text summarization which
    can handle large texts easily. Rust is a compiled language with intelligent borrow
    and reference checkers that helps developers write bug-free code. Code written
    in Rust can be integrated with Java codebases through `jni` and converted to C
    headers/libraries for use in C/C++ and Python.
  prefs: []
  type: TYPE_NORMAL
- en: Extractive and Abstractive Text Summarization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Text summarization has been a long-studied problem in natural language processing
    (NLP). Extracting important information from the text and generating a summary
    of the given text is the core problem that text summarizers need to solve. The
    solutions belong to two categories, namely, extractive summarization and abstractive
    summarization.
  prefs: []
  type: TYPE_NORMAL
- en: '[](/understanding-automatic-text-summarization-1-extractive-methods-8eb512b21ecc?source=post_page-----7b05938f4507--------------------------------)
    [## Understanding Automatic Text Summarization-1: Extractive Methods'
  prefs: []
  type: TYPE_NORMAL
- en: How can we summarize our documents automatically?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/understanding-automatic-text-summarization-1-extractive-methods-8eb512b21ecc?source=post_page-----7b05938f4507--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: In extractive text summarization, phrases or sentences are derived from the
    sentence directly. We can rank sentences using a scoring function and pick the
    most suitable sentences from the text considering their scores. Instead of generating
    new text, as in abstractive summarization, the summary is a collection of selected
    sentences from the text, hence avoiding problems which generative models exhibit.
  prefs: []
  type: TYPE_NORMAL
- en: Precision of the text is maintained in extractive summarization, but there is
    a high chance that some information is lost as the granularity of the selecting
    text is only limited to sentences. If a piece of information is spread across
    multiple sentences, the scoring function must take care of the relation which
    contains those sentences.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstractive text summarization requires larger deep learning model to capture
    the semantics of the language and to build an appropriate document-to-summary
    mapping. Training such models requires huge datasets and a longer training time
    which in-turn overloads computing resources heavily. Pretrained models might solve
    the problem of longer training times and data demands, but are still inherently
    biased towards the domain of the text on which they trained.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extractive methods may have scoring functions which are free of parameters and
    do not require any learning. They fall in the unsupervised learning regime of
    ML, and are useful as they require lesser computation and are not biased towards
    the domain of the text. Summarization may be equally efficient on news articles
    as well as novel excerpts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With our TFIDF-based technique, we do not require any training dataset or deep
    learning models. Our scoring function is based on the relative frequencies of
    words across different sentences.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Text Summarization with TFIDF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to rank each sentence, we need to calculate a score that would quantify
    the amount of information present within the sentence. TF-IDF comprises of two
    terms — TF, which stands for *Term Frequency* and IDF which denotes *Inverse Document
    Frequency*.
  prefs: []
  type: TYPE_NORMAL
- en: '[](/tf-term-frequency-idf-inverse-document-frequency-from-scratch-in-python-6c2b61b78558?source=post_page-----7b05938f4507--------------------------------)
    [## TF(Term Frequency)-IDF(Inverse Document Frequency) from scratch in python
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Creating TF-IDF Model from Scratch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/tf-term-frequency-idf-inverse-document-frequency-from-scratch-in-python-6c2b61b78558?source=post_page-----7b05938f4507--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: We consider that each sentence is made of tokens (words),
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/77cc36115e5ea49e623258f47ef15379.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Expr 1: Sentence S represented as tuple of words'
  prefs: []
  type: TYPE_NORMAL
- en: The term-frequency of each word, in the sentence ***S***, is defined as,
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/deb6a9d8f062561288e5162ea31ed4a8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Expr 2: **k** represents the total number of words in the sentence.'
  prefs: []
  type: TYPE_NORMAL
- en: The inverse-document frequency of each word, in the sentence S, is defined as,
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7832e14d2e755df5096faa8f03b12204.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Expr 3: The inverse-document frequency quantifies the occurrence of the word
    in other sentences.'
  prefs: []
  type: TYPE_NORMAL
- en: The score of each sentence is the sum of TFIDF scores of all words in that sentence,
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5b1505063fcac53c1960f43e34c209b2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Expr 4: The score of each sentence **S** which determines its inclusion in
    the final summary.'
  prefs: []
  type: TYPE_NORMAL
- en: Significance and Intuition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The term frequency, as you may have observed, would be lesser for words which
    are rarer in the sentence. If the same word has less presence in other sentences,
    then the IDF score is also higher. Hence, a sentence which contains repeated words
    (higher TF) which are more exclusive only to that sentence (higher IDF) will have
    a higher TFIDF score.
  prefs: []
  type: TYPE_NORMAL
- en: Rust Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We start implementing our technique by creating functions which convert a given
    text into a `Vec` of sentences. This problem is referred as sentence tokenization
    which identifies sentence boundaries within a text. With Python packages like
    `nltk` , the `punkt` sentence tokenizer is available for this task, and there
    exists a Rust port of [Punkt](https://www.askpython.com/python-modules/nltk-punkt)
    as well. `[rust-punkt](https://github.com/ferristseng/rust-punkt)` is no longer
    being maintained, but we still use it here. Another function which splits the
    sentence into words is also written,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the above snippet, we remove stop-words, which are commonly occurring words
    in a language and have no significant contribution to the text’s information content.
  prefs: []
  type: TYPE_NORMAL
- en: '[](/text-pre-processing-stop-words-removal-using-different-libraries-f20bac19929a?source=post_page-----7b05938f4507--------------------------------)
    [## Text pre-processing: Stop words removal using different libraries'
  prefs: []
  type: TYPE_NORMAL
- en: A handy guide about English stop words removal in Python!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/text-pre-processing-stop-words-removal-using-different-libraries-f20bac19929a?source=post_page-----7b05938f4507--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a function which computes the frequency of each word present
    in the corpus. This method will be used to compute the term frequency of each
    word present in a sentence. The `(word, freq)` pair is stored in a `[Hashmap](https://doc.rust-lang.org/std/collections/struct.HashMap.html)`
    for faster retrieval in later stages
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Next, we write the function which computes the term frequency of words present
    in a sentence,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Another function which computes the IDF, inverse document frequency, for words
    in a tokenized sentence,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We’ve now added functions to compute TF and IDF scores of each word present
    in a sentence. In order to compute a final score for each sentence, which would
    also determine its rank, we have to compute the sum of TFIDF-scores of all words
    present in a sentence.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Using Rayon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For larger texts, we can perform some operations in parallel i.e. on multiple
    CPU threads using a popular Rust crate `[rayon-rs](https://github.com/rayon-rs/rayon)`
    . In the `compute` function above, we can perform the following tasks parallelly,
  prefs: []
  type: TYPE_NORMAL
- en: Converting each sentence to tokens and removing stop-words
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computing the sum of TFIDF scores for each sentence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These tasks can be performed independently on each sentence, and have no dependence
    on other sentences, hence, they can be parallelized. To ensure mutual exclusion
    while different threads access a shared container, we use `[Arc](https://doc.rust-lang.org/rust-by-example/std/arc.html)`
    [(Atomic reference counted pointer)](https://doc.rust-lang.org/rust-by-example/std/arc.html)
    and `[Mutex](https://fongyoong.github.io/easy_rust/Chapter_43.html)` which is
    basic synchronization primitive for ensuring atomic access.
  prefs: []
  type: TYPE_NORMAL
- en: '`Arc` ensures that the referred `Mutex` is accessible to all threads, and the
    `Mutex` itself allows only a single thread to access the object wrapped in it.
    Here’s another function `par_compute` , which uses Rayon and performs the above-mentioned
    tasks in-parallel,'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Cross-Platform Usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C and C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use Rust structs and functions in C, we can use `cbindgen` to generate C-style
    headers containing the struct/function prototypes. On generating the headers,
    we can compile the Rust code to C-based [dynamic or static libraries](https://domiyanyue.medium.com/c-development-tutorial-4-static-and-dynamic-libraries-7b537656163e#:~:text=At%20runtime%2C%20the%20dynamic%20library,library%20code%20to%20the%20memory.)
    which contain the implementation of the functions declared in the header files.
    To generate C-based static library, we need to set the `[crate_type](https://doc.rust-lang.org/cargo/reference/cargo-targets.html)`
    parameter in `Cargo.toml` to `staticlib`,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Next, we add FFIs to expose the summarizer’s functions in the ABI ([application
    binary interface](https://en.wikipedia.org/wiki/Application_binary_interface))
    in `src/lib.rs` ,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can build the static library with `cargo build` and `libsummarizer.a` will
    be generated in the `target` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Android
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With [Android’s Native Development Kit (NDK)](https://developer.android.com/ndk),
    we can compile the Rust program for `armeabi-v7a` and `arm64-v8a` targets. We
    need to write special interface functions with Java Native Interface (JNI), which
    can be found in the `android` module in `src/lib.rs` .
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://matt-moore.medium.com/kotlin-jni-for-native-code-835e93af7ddf?source=post_page-----7b05938f4507--------------------------------)
    [## Kotlin JNI for Native Code'
  prefs: []
  type: TYPE_NORMAL
- en: How to call native code from Kotlin.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: matt-moore.medium.com](https://matt-moore.medium.com/kotlin-jni-for-native-code-835e93af7ddf?source=post_page-----7b05938f4507--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With Python’s `ctypes` module, we can load a shared library ( `.so` or `.dll`
    ) and use the C-compatible datatypes to execute the functions defined in the library.
    The code isn’t available on the GitHub project, but will be soon available.
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://realpython.com/python-bindings-overview/?source=post_page-----7b05938f4507--------------------------------)
    [## Python Bindings: Calling C or C++ From Python - Real Python'
  prefs: []
  type: TYPE_NORMAL
- en: What are Python bindings? Should you use ctypes, CFFI, or a different tool?
    In this step-by-step tutorial, you'll get…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: realpython.com](https://realpython.com/python-bindings-overview/?source=post_page-----7b05938f4507--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Future Scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The project can be extended and improved in many ways, which we’ll discuss
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: The current implementation requires the `[nightly](https://doc.rust-lang.org/book/appendix-07-nightly-rust.html)`
    [build of Rust](https://doc.rust-lang.org/book/appendix-07-nightly-rust.html),
    only because of a single dependency `punkt` . `punkt` is a sentence tokenizer
    which is required to determine sentence boundaries in the text, following which
    other computations are made. If `punkt` can be built with stable Rust, the current
    implementation will no more require `nightly` Rust.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding newer metrics to rank sentences, especially which capture inter-sentence
    dependencies. TFIDF is not the most accurate scoring function and has its own
    limitations. Building sentence graphs and using them for scoring sentences has
    greatly enhance the overall quality of the extracted summary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The summarizer has not been benchmarked against a known dataset. [Rouge scores](https://en.wikipedia.org/wiki/ROUGE_(metric))
    `[R1](https://en.wikipedia.org/wiki/ROUGE_(metric))` [,](https://en.wikipedia.org/wiki/ROUGE_(metric))
    `[R2](https://en.wikipedia.org/wiki/ROUGE_(metric))` [and](https://en.wikipedia.org/wiki/ROUGE_(metric))
    `[RL](https://en.wikipedia.org/wiki/ROUGE_(metric))` are frequently used to assess
    the quality of the generated summary against standard datasets like the [New York
    Times dataset](https://paperswithcode.com/dataset/new-york-times-annotated-corpus)
    or the [CNN Daily mail dataset](https://paperswithcode.com/dataset/cnn-daily-mail-1).
    Measuring performance against standard benchmarks will provide developers more
    clarity and reliability towards the implementation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Building NLP utilities with Rust has significant advantages, considering the
    increasing popularity of the language amongst developers due to its performance
    and future promises. I hope the article was knowledgeable. Do have a look at the
    GitHub project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://github.com/shubham0204/tfidf-summarizer.rs?source=post_page-----7b05938f4507--------------------------------)
    [## GitHub - shubham0204/tfidf-summarizer.rs: Simple, efficient and cross-platform
    TFIDF-based text…'
  prefs: []
  type: TYPE_NORMAL
- en: Simple, efficient and cross-platform TFIDF-based text summarizer in Rust - GitHub
    - shubham0204/tfidf-summarizer.rs…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: github.com](https://github.com/shubham0204/tfidf-summarizer.rs?source=post_page-----7b05938f4507--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: You may consider opening an issue or a pull request if you feel something can
    be improved! Keep learning and have a nice day ahead.
  prefs: []
  type: TYPE_NORMAL
