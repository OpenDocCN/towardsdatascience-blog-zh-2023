["```py\nnormalized_a = torch.nn.functional.normalize(features, dim=1, p=2)\nnormalized_b = torch.nn.functional.normalize(features, dim=1, p=2)\nnormalized_b = torch.conj(normalized_b).T\nproduct = torch.matmul(normalized_a, normalized_b)\ndistance_matrix = torch.sub(torch.tensor(1.0), product)\n```", "```py\ntensor([[ 1.0999, -0.9438,  0.7996, -0.4247],\n        [ 1.2150, -0.2953,  0.0417, -1.2913],\n        [ 1.3218,  0.4214, -0.1541,  0.0961],\n        [-0.7253,  1.1685, -0.1070,  1.3683]])\n```", "```py\ntensor([[ 0.0000e+00,  2.8502e-01,  6.2687e-01,  1.7732e+00],\n        [ 2.8502e-01,  0.0000e+00,  4.6293e-01,  1.8581e+00],\n        [ 6.2687e-01,  4.6293e-01, -1.1921e-07,  1.1171e+00],\n        [ 1.7732e+00,  1.8581e+00,  1.1171e+00, -1.1921e-07]])\n```", "```py\npairwise_distance_matrix = torch.exp(\n    -(distance_matrix / temperature)\n) - torch.eye(features.shape[0]).to(model.device)\n```", "```py\ntensor([[1.0000, 0.7520, 0.5343, 0.1698],\n        [0.7520, 1.0000, 0.6294, 0.1560],\n        [0.5343, 0.6294, 1.0000, 0.3272],\n        [0.1698, 0.1560, 0.3272, 1.0000]])\n```", "```py\npick_probability = pairwise_distance_matrix / (\n    torch.sum(pairwise_distance_matrix, 1).view(-1, 1)\n    + stability_epsilon\n)\n```", "```py\nmasking_matrix = torch.squeeze(\n    torch.eq(labels, labels.unsqueeze(1)).float()\n)\n```", "```py\nmasked_pick_probability = pick_probability * masking_matrix\n```", "```py\nsummed_masked_pick_probability = torch.sum(masked_pick_probability, dim=1)\n```", "```py\nsnnl = torch.mean(\n    -torch.log(summed_masked_pick_probability + stability_epsilon\n)\n```", "```py\ndef forward(\n    self,\n    model: torch.nn.Module,\n    features: torch.Tensor,\n    labels: torch.Tensor,\n    outputs: torch.Tensor,\n    epoch: int,\n) -> Tuple:\n    if self.use_annealing:\n        self.temperature = 1.0 / ((1.0 + epoch) ** 0.55)\n\n    primary_loss = self.primary_criterion(\n        outputs, features if self.unsupervised else labels\n    )\n\n    activations = self.compute_activations(model=model, features=features)\n\n    layers_snnl = []\n    for key, value in activations.items():\n        value = value[:, : self.code_units]\n        distance_matrix = self.pairwise_cosine_distance(features=value)\n        pairwise_distance_matrix = self.normalize_distance_matrix(\n            features=value, distance_matrix=distance_matrix\n        )\n        pick_probability = self.compute_sampling_probability(\n            pairwise_distance_matrix\n        )\n        summed_masked_pick_probability = self.mask_sampling_probability(\n            labels, pick_probability\n        )\n        snnl = torch.mean(\n            -torch.log(self.stability_epsilon + summed_masked_pick_probability)\n        )\n        layers_snnl.append(snnl)\n\n    snn_loss = torch.stack(layers_snnl).sum()\n\n    train_loss = torch.add(primary_loss, torch.mul(self.factor, snn_loss))\n\n    return train_loss, primary_loss, snn_loss\n```"]