- en: LangChain has added Cypher Search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/langchain-has-added-cypher-search-cb9d821120d5?source=collection_archive---------1-----------------------#2023-05-24](https://towardsdatascience.com/langchain-has-added-cypher-search-cb9d821120d5?source=collection_archive---------1-----------------------#2023-05-24)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: With the LangChain library, you can conveniently generate Cypher queries, enabling
    an efficient retrieval of information from Neo4j.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://bratanic-tomaz.medium.com/?source=post_page-----cb9d821120d5--------------------------------)[![Tomaz
    Bratanic](../Images/d5821aa70918fcb3fc1ff0013497b3d5.png)](https://bratanic-tomaz.medium.com/?source=post_page-----cb9d821120d5--------------------------------)[](https://towardsdatascience.com/?source=post_page-----cb9d821120d5--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----cb9d821120d5--------------------------------)
    [Tomaz Bratanic](https://bratanic-tomaz.medium.com/?source=post_page-----cb9d821120d5--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F57f13c0ea39a&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Flangchain-has-added-cypher-search-cb9d821120d5&user=Tomaz+Bratanic&userId=57f13c0ea39a&source=post_page-57f13c0ea39a----cb9d821120d5---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----cb9d821120d5--------------------------------)
    ·8 min read·May 24, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fcb9d821120d5&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Flangchain-has-added-cypher-search-cb9d821120d5&user=Tomaz+Bratanic&userId=57f13c0ea39a&source=-----cb9d821120d5---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fcb9d821120d5&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Flangchain-has-added-cypher-search-cb9d821120d5&source=-----cb9d821120d5---------------------bookmark_footer-----------)![](../Images/4a327bfd5a51c910e0ac40a24bbff57d.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Image generated by Midjourney paid subscription. [Midjourney ToS](https://docs.midjourney.com/docs/terms-of-service).
  prefs: []
  type: TYPE_NORMAL
- en: If you have developed or plan to implement any solution that uses Large Language
    Models, you have most likely heard of the [LangChain library](https://python.langchain.com/en/latest/index.html).
    LangChain library is the most widely known Python library used to develop applications
    that use LLMs in one or another capabilities. It is designed to be modular, allowing
    us to use any LLM in any available modules, such as chains, tools, memory, or
    agents.
  prefs: []
  type: TYPE_NORMAL
- en: A month ago, I spent a week researching and implementing a solution allowing
    anyone to retrieve information from [Neo4j](https://neo4j.com/) directly from
    the LangChain library and use it in their LLM applications. I learned quite a
    lot about the internals of LangChain library and wrote up my experience in a [blog
    post](/integrating-neo4j-into-the-langchain-ecosystem-df0e988344d2).
  prefs: []
  type: TYPE_NORMAL
- en: A colleague of mine showed me a LangChain feature request, where the user requested
    that my work of having the option to retrieve information from the Neo4j database
    would be added as a module directly to the LangChain library so that no additional
    code or external modules would be needed to integrate Neo4j into LangChain applications.
    Since I was already familiar with LangChain internals, I decided to try and implement
    Cypher searching capabilities myself. I spent a weekend researching and coding
    the solution and ensuring it would conform to the contribution standards for it
    to be added to the library. Luckily, the maintainers of LangChain are very responsive
    and open to new ideas, and the Cypher Search has been added in the latest release
    of the LangChain library. Thanks to [Harrison Chase](https://medium.com/u/bbfa018ac706?source=post_page-----cb9d821120d5--------------------------------)
    for maintaining such a great library and also being very responsive to new ideas.
  prefs: []
  type: TYPE_NORMAL
- en: In this blog post, I will show you how you can use the newly added Cypher Search
    in the LangChain library to retrieve information from a Neo4j database.
  prefs: []
  type: TYPE_NORMAL
- en: The code is available on [GitHub](https://github.com/tomasonjo/blogs/blob/master/llm/langchain_neo4j.ipynb).
  prefs: []
  type: TYPE_NORMAL
- en: What is a knowledge graph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LangChain has already integrations with Vector and SQL databases, so why do
    we need an integration with a Graph Database like Neo4j?
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/fc7b909b07a0cfe91479086bff8ccf91.png)'
  prefs: []
  type: TYPE_IMG
- en: '[WikiData Knowledge graph. Image licensed under CC BY-SA 4.0.](https://www.wikidata.org/wiki/Q33002955#/media/File:Wikidata_knowledge_graph_-_Christine_Choy.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge graphs are ideal for storing heterogeneous and highly connected data.
    For instance, the above image contains information about people, organizations,
    movies, websites, etc. While the ability to intuitively model and store diverse
    sets of data is incredible, I think the main benefit of using graphs is the ability
    to analyze data points through their relationships. Graphs enable us to uncover
    connections and correlations that might otherwise remain unnoticed with traditional
    database and analytics approaches as they often overlook the context surrounding
    individual data points.
  prefs: []
  type: TYPE_NORMAL
- en: The power of graph databases truly shines when dealing with complex systems
    where interdependencies and interactions are vital in understanding the system.
  prefs: []
  type: TYPE_NORMAL
- en: They enable us to see beyond individual data points and delve into the intricate
    relationships that define their context. This provides a deeper, more holistic
    view of the data, facilitating better decision-making and knowledge discovery.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Neo4j environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have an existing Neo4j database, you can use it to try the newly added
    Cypher Search. The Cypher Search module uses graph schema information to generate
    Cypher statements, meaning you can plug it into any Neo4j database.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t have any Neo4j database yet, you can use [Neo4j Sandbox](https://neo4j.com/sandbox/),
    which offers a free cloud instance of a Neo4j database. You need to register and
    instantiate any of the available pre-populated databases. I will be using the
    [**ICIJ Paradise Papers** dataset](https://sandbox.neo4j.com/?usecase=icij-paradise-papers)
    in this blog post, but you can use any other if you want. The dataset has been
    made available by [International Consortium of Investigative Journalists](https://www.icij.org/)
    as part of their [Offshore Leaks Database](https://offshoreleaks.icij.org/pages/database).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/89fed8d3e032975331f4a222209f0fc5.png)'
  prefs: []
  type: TYPE_IMG
- en: Paradise Papers dataset graph schema. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: 'The graph contains four types of nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**Entity**` - The offshore legal entity. This could be a company, trust, foundation,
    or other legal entity created in a low-tax jurisdiction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**Officer**` - A person or company who plays a role in an offshore entity,
    such as beneficiary, director, or shareholder. The relationships shown in the
    diagram are just a sample of all the existing ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**Intermediary**` - A go-between for someone seeking an offshore corporation
    and an offshore service provider — usually a law-firm or a middleman that asks
    an offshore service provider to create an offshore firm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**Address**` - The registered address as it appears in the original databases
    obtained by ICIJ.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowledge Graph Cypher Search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The name Cypher Search comes from Cypher, which is a query language used to
    interact with graph databases like Neo4j.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7e9d4ec8b6a7974e5904bc5e443260f2.png)'
  prefs: []
  type: TYPE_IMG
- en: Knowledge graph Cypher chain workflow. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: In order to allow LangChain to retrieve information from graph databases, I
    implemented a module that can convert the natural language to a Cypher statement,
    use it to retrieve data from Neo4j and return the retrieved information to the
    user in a natural language form. This two-way conversion process between natural
    language and database language not only enhances the overall accessibility of
    data retrieval but also greatly improves the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: The beauty of the LangChain library is in its simplicity. We only need a couple
    of lines of code and we can retrieve information from Neo4j using natural language.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using the **gpt-3.5-turbo** model from OpenAI to generate Cypher
    statements. The Cypher statements are generated based on the graph schema, which
    means that, in theory, you can plug the Cypher chain into any Neo4j instance,
    and it should be able to answer natural language answers. Unfortunately, I haven’t
    yet tested other LLM providers in their ability to generate Cypher statements
    since I don’t have access to any of them. Still, I would love to hear your evaluation
    of other LLMs generating Cypher statements if you will give it a go. Of course,
    if you want to break the dependency on LLM cloud providers, you can [always fine-tune
    an open-source LLM to generate Cypher statements](/fine-tuning-an-llm-model-with-h2o-llm-studio-to-generate-cypher-statements-3f34822ad5).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with a simple test.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Results*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a7015803caa34f67ea96a440067ce01a.png)'
  prefs: []
  type: TYPE_IMG
- en: Generated answer. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: We can observe the generated Cypher statement and the retrieved information
    from Neo4j used to form the answer. That is as easy a setup as it gets. Let’s
    move on to the next example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Results*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ea7c4cfdbe32c1f36026cff5bd7c9093.png)'
  prefs: []
  type: TYPE_IMG
- en: Generated answer. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are using a graph, let’s construct a question that would utilize the
    power of graph databases.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The generated Cypher statement looks fine at first glance. However, there is
    a problem as the Cypher statements used the variable-length path finding syntax
    and also treated relationships as undirected. As a result, this type of query
    is highly unoptimized and would explode in the number of rows.
  prefs: []
  type: TYPE_NORMAL
- en: The nice thing about gpt-3.5-turbo is that it follows hints and instructions
    we drop in the input. For example, we can ask it to find only the shortest path.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/ec99f25f8d358965e67cc7269b1b4073.png)'
  prefs: []
  type: TYPE_IMG
- en: Generated answer. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we dropped a hint that only the shortest path should be retrieved,
    we don’t run into cardinality explosion troubles anymore. However, one thing I
    noticed is that the LLM sometimes doesn’t provide the best results if a path object
    is returned. The generated Cypher statement returns the following visualization
    in Neo4j Browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2d1dcdd2ce07e0f8564e60101dec422e.png)'
  prefs: []
  type: TYPE_IMG
- en: Graph visualization of the answer. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: The generated natural language response didn’t really mention that the two companies
    are registered at the same address, but made it its own shortest path based on
    the node properties. However, we can also fix that by instructing the model what
    information to use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Results*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9c225b05215012338afdc382473c497c.png)'
  prefs: []
  type: TYPE_IMG
- en: Generated answer. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can a better response and more appropriate response. The more hints you
    drop to an LLM, the better results you can expect. For example, you can also instruct
    it which relationships it can traverse.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Results*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/510392f2207ab79a80e1507e1bb32378.png)'
  prefs: []
  type: TYPE_IMG
- en: Generated answer. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the generated Cypher statements allows the traversal of only
    **OFFICER_OF**, **INTERMEDIARY_OF**, and **CONNECTED_TO** relationships. The same
    Cypher statement produces the following graph visualization.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/78a18b1af5a6fc1f286c787361feae4e.png)'
  prefs: []
  type: TYPE_IMG
- en: Graph visualization of the answer. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Graph databases are an excellent tool for retrieving or analyzing the connections
    between various entities like people and organizations. In this blog post, we
    looked at a simple shortest path use case, where the number of relationships and
    the sequence of relationship types is unknown beforehand. These types of queries
    are virtually impossible in a vector database and could also be quite complicated
    in a SQL database.
  prefs: []
  type: TYPE_NORMAL
- en: I am thrilled about the addition of Cypher Search to the LangChain library.
    Please test it out, and let me know how it works for you, especially if you are
    testing it on other LLM models or have exciting use cases. Also, remember to subscribe,
    as I have a couple of blog posts lined up to explore the Cypher Search in the
    LangChain library.
  prefs: []
  type: TYPE_NORMAL
- en: As always, the code is available on [GitHub](https://github.com/tomasonjo/blogs/blob/master/llm/langchain_neo4j.ipynb).
  prefs: []
  type: TYPE_NORMAL
