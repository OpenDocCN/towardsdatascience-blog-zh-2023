["```py\npip install --upgrade scalecast\n```", "```py\ntransformer = Transformer(\n    transformers = [\n        ('DetrendTransform',{'poly_order':2}),\n        'DeseasonTransform',\n    ],\n)\n```", "```py\nreverter = Reverter(\n    reverters = [\n        'DeseasonRevert',\n        'DetrendRevert',\n    ],\n    base_transformer = transformer,\n)\n```", "```py\ndef forecaster(f):\n    f.set_estimator('rnn')\n    f.manual_forecast(\n        lags = 18,\n        layers_struct = [\n            ('LSTM',{'units':36,'activation':'tanh'}),\n        ],\n        epochs=200,\n        call_me = 'lstm',\n    )\n```", "```py\npipeline = Pipeline(\n    steps = [\n        ('Transform',transformer),\n        ('Forecast',forecaster),\n        ('Revert',reverter),\n    ]\n)\n\nf = pipeline.fit_predict(f)\n\nf.plot()\nplt.show()\n```", "```py\ndata = pd.read_csv('avocado.csv')\n\n# demand\nvol = data.groupby('Date')['Total Volume'].sum()\n# price\nprice = data.groupby('Date')['AveragePrice'].sum()\n\nfvol = Forecaster(\n    y = vol,\n    current_dates = vol.index,\n    test_length = 13,\n    validation_length = 13,\n    future_dates = 13,\n    metrics = ['rmse','r2'],\n)\n\ntransformer, reverter = find_optimal_transformation(\n    fvol,\n    set_aside_test_set=True, # prevents leakage so we can benchmark the resulting models fairly\n    return_train_only = True, # prevents leakage so we can benchmark the resulting models fairly\n    verbose=True,\n    detrend_kwargs=[\n        {'loess':True},\n        {'poly_order':1},\n        {'ln_trend':True},\n    ],\n    m = 52, # what makes one seasonal cycle?\n    test_length = 4,\n)\n```", "```py\nrnn_grid = gen_rnn_grid(\n    layer_tries = 10,\n    min_layer_size = 3,\n    max_layer_size = 5,\n    units_pool = [100],\n    epochs = [25,50],\n    dropout_pool = [0,0.05],\n    callbacks=EarlyStopping(\n      monitor='val_loss',\n      patience=3,\n    ),\n    random_seed = 20,\n) # creates a grid of hyperparameter values to tune the LSTM model\n```", "```py\nfvol.add_ar_terms(13) # the model will use 13 series lags\nfvol.set_estimator('rnn')\nfvol.ingest_grid(rnn_grid)\nfvol.tune() # uses a 13-period validation set\nfvol.auto_forecast(call_me='lstm_univariate')\n```", "```py\nfprice = Forecaster(\n    y = price,\n    current_dates = price.index,\n    future_dates = 13,\n)\n\nfprice = transformer.fit_transform(fprice)\n\nfvol.add_series(fprice.y,called='price')\nfvol.add_lagged_terms('price',lags=13,drop=True)\nfvol.ingest_grid(rnn_grid)\nfvol.tune()\nfvol.auto_forecast(call_me='lstm_multivariate')\n```", "```py\n# naive forecast for benchmarking\nfvol.set_estimator('naive')\nfvol.manual_forecast()\n\nfvol = reverter.fit_transform(fvol)\n\nfvol.plot_test_set(order_by='TestSetRMSE')\nplt.show()\n```", "```py\ntransformer, reverter = find_optimal_transformation(\n    f,\n    estimator = 'lstm',\n    epochs = 10,\n    set_aside_test_set=True, # prevents leakage so we can benchmark the resulting models fairly\n    return_train_only = True, # prevents leakage so we can benchmark the resulting models fairly\n    verbose=True,\n    m = 52, # what makes one seasonal cycle?\n    test_length = 24,\n    num_test_sets = 3,\n    space_between_sets = 12,\n    detrend_kwargs=[\n        {'loess':True},\n        {'poly_order':1},\n        {'ln_trend':True},\n    ],\n)\n```", "```py\nrnn_grid = gen_rnn_grid(\n    layer_tries = 100,\n    min_layer_size = 1,\n    max_layer_size = 5,\n    units_pool = [100],\n    epochs = [100],\n    dropout_pool = [0,0.05],\n    validation_split=.2,\n    callbacks=EarlyStopping(\n      monitor='val_loss',\n      patience=3,\n    ),\n    random_seed = 20,\n) # make a really big grid and limit it manually\n```", "```py\ndef forecaster(f,grid):\n    f.auto_Xvar_select(\n        try_trend=False,\n        try_seasonalities=False,\n        max_ar=100\n    )\n    f.set_estimator('rnn')\n    f.ingest_grid(grid)\n    f.limit_grid_size(10) # randomly reduce the big grid to 10\n    f.cross_validate(k=3,test_length=24) # three-fold cross-validation\n    f.auto_forecast()\n\npipeline = Pipeline(\n    steps = [\n        ('Transform',transformer),\n        ('Forecast',forecaster),\n        ('Revert',reverter),\n    ]\n)\n\nf = pipeline.fit_predict(f,grid=rnn_grid)\n```", "```py\nf.plot(ci=True)\nplt.show()\n```", "```py\nbacktest_results = backtest_for_resid_matrix(\n    f,\n    pipeline=pipeline,\n    alpha = .1,\n    jump_back = 12,\n    params = f.best_params,\n)\n\nbacktest_resid_matrix = get_backtest_resid_matrix(backtest_results)\n```", "```py\noverwrite_forecast_intervals(\n    f,\n    backtest_resid_matrix=backtest_resid_matrix,\n    alpha=.1, # 90% intervals\n)\nf.plot(ci=True)\nplt.show()\n```", "```py\ndf = pdr.get_data_fred(\n    'CANWSCNDW01STSAM',\n    start = '2010-01-01',\n    end = '2023-06-30',\n)\n\nf_new = Forecaster(\n    y = df.iloc[:,0],\n    current_dates = df.index,\n    future_dates = 24, # 2-year forecast horizon\n)\n```", "```py\ndef transfer_forecast(f_new,transfer_from):\n    f_new = infer_apply_Xvar_selection(infer_from=transfer_from,apply_to=f_new)\n    f_new.transfer_predict(transfer_from=transfer_from,model='rnn',model_type='tf')\n\npipeline_can = Pipeline(\n    steps = [\n        ('Transform',transformer),\n        ('Transfer Forecast',transfer_forecast),\n        ('Revert',reverter),\n    ]\n)\n\nf_new = pipeline_can.fit_predict(f_new,transfer_from=f)\n```", "```py\nf_new.plot()\nplt.show('Housing Starts Forecast with Actuals Through June, 2023')\nplt.show()\n```", "```py\ndf = pdr.get_data_fred(\n    'CANWSCNDW01STSAM',\n    start = '2010-01-01',\n    end = '2023-06-30',\n)\n\nf_new = Forecaster(\n    y = df.iloc[:,0],\n    current_dates = df.index,\n    future_dates = 24, # 2-year forecast horizon\n)\n\ndef transfer_forecast(f_new,transfer_from):\n    f_new = infer_apply_Xvar_selection(infer_from=transfer_from,apply_to=f_new)\n    f_new.transfer_predict(transfer_from=transfer_from,model='rnn',model_type='tf')\n\npipeline_can = Pipeline(\n    steps = [\n        ('Transform',transformer),\n        ('Transfer Forecast',transfer_forecast),\n        ('Revert',reverter),\n    ]\n)\n\nf_new = pipeline_can.fit_predict(f_new,transfer_from=f)\n\nf_new.plot()\nplt.show('Candian Housing Starts Forecast')\nplt.show()\n```"]