- en: Effective coding with dates and times in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/effective-coding-with-dates-and-times-in-python-3be13a77b45b?source=collection_archive---------5-----------------------#2023-08-26](https://towardsdatascience.com/effective-coding-with-dates-and-times-in-python-3be13a77b45b?source=collection_archive---------5-----------------------#2023-08-26)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Making use of datetime, zoneinfo, dateutil and pandas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://aliciahorsch.medium.com/?source=post_page-----3be13a77b45b--------------------------------)[![Alicia
    Horsch](../Images/1e3c5dcafb062d0aa710934c6382cb32.png)](https://aliciahorsch.medium.com/?source=post_page-----3be13a77b45b--------------------------------)[](https://towardsdatascience.com/?source=post_page-----3be13a77b45b--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----3be13a77b45b--------------------------------)
    [Alicia Horsch](https://aliciahorsch.medium.com/?source=post_page-----3be13a77b45b--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fba4ebbd0afd2&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Feffective-coding-with-dates-and-times-in-python-3be13a77b45b&user=Alicia+Horsch&userId=ba4ebbd0afd2&source=post_page-ba4ebbd0afd2----3be13a77b45b---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----3be13a77b45b--------------------------------)
    ·5 min read·Aug 26, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F3be13a77b45b&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Feffective-coding-with-dates-and-times-in-python-3be13a77b45b&user=Alicia+Horsch&userId=ba4ebbd0afd2&source=-----3be13a77b45b---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F3be13a77b45b&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Feffective-coding-with-dates-and-times-in-python-3be13a77b45b&source=-----3be13a77b45b---------------------bookmark_footer-----------)![](../Images/43a2f0db3816eb12fffff9e553ce47db.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Photo by [Jordan Benton](https://www.pexels.com/@bentonphotocinema/) from [Pexels](https://www.pexels.com/photo/shallow-focus-of-clear-hourglass-1095601/)
  prefs: []
  type: TYPE_NORMAL
- en: I have been working extensively with time series data lately and have dealt
    with date and time objects in Python. For this, I have learned some useful tricks
    for working with *datetime* objects in Python that removed complexity from my
    code. In this article, I would like to share and summarise the most valuable tips
    and tricks I learned.
  prefs: []
  type: TYPE_NORMAL
- en: For demonstration, I will use two Kaggle datasets, which I will link when I
    use them. If you want to follow along, you can import the following libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Datetime, zoneinfo, dateutil and pytz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Commonly used packages that deal with dates and times in Python are *datetime,
    dateutil, pytz* and the [recent *zoneinfo*](https://docs.python.org/3/library/zoneinfo.html).
    *Datetime* is the built-in module for working with times and dates in Python and
    lets you do most of the basics. *Dateutil* and *pytz* are third-party modules
    and powerful extensions to *datetime* when dealing with more complex manipulations
    like relative time deltas, time zones, and parsing of strings.
  prefs: []
  type: TYPE_NORMAL
- en: However, since Python version 3.9, [*zoneinfo*](https://docs.python.org/3/library/zoneinfo.html),
    is incorporated in the Python Standard Library and, therefore, is considered “more
    convenient” for **timezone support** compared to other third-party modules like
    *dateutil* or [*pytz*](https://docs.python.org/3/library/zoneinfo.html).
  prefs: []
  type: TYPE_NORMAL
- en: '*So, depending on the Python version you are working with, the Python built-in
    modules might be already sufficient and no third-party modules (*dateutil *and*
    pytz*) are needed when dealing with* ***different timezones****!*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In the remainder of the article, I will focus mostly on handling dates and
    times with *datetime* but will also mention potential options for *zoneinfo* or
    *dateutil*. The article will first focus on single *datetime* objects, followed
    by dealing with dates in arrays and data frames using *numpy* and *pandas*:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a date or datetime from scratch
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Converting to and parsing strings: strftime(), strptime() and dateutil'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dates and times in *numpy* — numPy’s datetime64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dates and times in *pandas*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating features from dates and times
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 1\. Creating a date or datetime from scratch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *datetime* package lets you create date and datetime objects easily from
    scratch that can be used, for example, as thresholds for filtering (try printing
    the created objects below and their types to better understand their format).
  prefs: []
  type: TYPE_NORMAL
- en: Also, *datetime* lets you create date and time objects that refer to today or
    now.
  prefs: []
  type: TYPE_NORMAL
- en: '*Be careful here, as* datetime *objects are usually “timezone naive” and do
    not refer to a specific time zone, which may get you into trouble when working
    with international colleagues!*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: With the help of the *zoneinfo* module (built-in since Python version 3.9),
    you can set the timezone with the *tz* parameter of *astimezone().*
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Converting to and parsing strings: strftime(), strptime() and dateutil'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might find yourself in a situation where you want to display your *datetime*
    object as a string or convert a string into a *datetime* object. Here, the functions
    *strftime()* and *strptime()* are helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Converting a datetime object (or parts of it) to a string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Commonly used format codes for describing datetime objects can be found [here](https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes).
  prefs: []
  type: TYPE_NORMAL
- en: Converting a string into a datetime object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Parsing complex strings using dateutil
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 3\. Dates and times in numpy - numPy's datetime64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are handling large datasets, *numpy’s* datetime64 may come in handy as,
    due to its design, it can be much faster than working with *datetime* and *dateutil*
    objects. The datetime64 data type in *numpy* encodes dates and times as 64-bit
    integers.
  prefs: []
  type: TYPE_NORMAL
- en: This stores dates and times compactly and allows vectorized operations (repeated
    operations applied to each element of a numpy array).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see when running the code above, with a *datetime* or *dateutil*
    object, vectorized operations will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Dates and times in pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Pandas* can be a good choice when working on a time series data project.'
  prefs: []
  type: TYPE_NORMAL
- en: '*The famous data-wrangling library* pandas *combines the convenience of* datetime
    *and* dateutil *with the effective storing and manipulation possibility from*
    numpy*.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Create a pandas dataframe (from CSV) parsing a date column
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we have a basic understanding of handling dates and times in Python using
    *numpy* and *pandas*. However, often, we do not create dates and times ourselves,
    but they are already part of the dataset we are dealing with. Let’s create a *pandas*
    data frame with a date column ([Kaggle dataset NFL](https://www.kaggle.com/c/nfl-big-data-bowl-2022/data?select=games.csv)).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, when loading from a CSV, the column that holds a date is turned
    into a string format if not specified anywhere precisely. To receive the date
    format, you could create an extra column called “gameDate_dateformat” or directly
    pass the date column through the parameter *parse_dates* in pd.read_csv().
  prefs: []
  type: TYPE_NORMAL
- en: 'Another handy manipulation when working with time series data is to be able
    to filter by date/time or subsetting a data frame using date/time. There are two
    methods to do this: filtering/subsetting or indexing.'
  prefs: []
  type: TYPE_NORMAL
- en: Filtering pandas data frames by time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Make sure that the threshold date you use for subsetting has the same format
    as the column!*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If the column you want to filter by has the format datetime (like in the example),
    the comparison date cannot be a date but needs to have a datetime format!
  prefs: []
  type: TYPE_NORMAL
- en: Indexing pandas data frames by time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even more powerful is indexing a *pandas* data frame by date or time.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing can be especially useful when working with time series, as there are
    methods like rolling windows and time-shifting.
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Creating features from dates and times
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, we are not interested in the date itself but maybe the duration, the
    weekday, or just a part of the datetime, e.g. the year. For this, *datetime* but
    also *pandas* provide some useful manipulations.
  prefs: []
  type: TYPE_NORMAL
- en: Timedelta
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With *pandas*, you can calculate, for example, the difference between two datetimes.
    For this, we will look at a different dataset of Uber trips ([Kaggle dataset Uber](https://www.kaggle.com/datasets/zusmani/uberdrives/code?resource=download))
    with a start and an end timestamp. Some preprocessing is needed (delete the Total
    Row) to start looking into timedelta.
  prefs: []
  type: TYPE_NORMAL
- en: Extract the weekday or the month
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This works slightly differently for the single *datetime* versus the *pandas*
    Series. While the weekday or the month of the single *datetime* object can be
    directly accessed by adding an attribute (e.g., *.month*) or method (e.g., *weekday()*),
    the *pandas* Series always needs the *.dt* accessor.
  prefs: []
  type: TYPE_NORMAL
- en: '*The* dt. accessor *allows you to access datetime-specific attributes and methods
    from a* datetime *Series.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Create a date/time lag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another helpful manipulation for time series data could be to add an extra column
    that adds a lag of a date or datetime.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To work with date or time objects in Python, knowing the basics of the built-in
    package *datetime* (e.g. *date()* or *strftime()* and *strptime()*) are beneficial.
    *Zoneinfo* is a new built-in package (since version 3.9) which is more convenient
    than third-party modules when working with different time zones. *Dateutil* is
    a valuable library for more advanced date and time manipulations when working
    with single date objects, e.g., parsing complex strings. When working with dates
    and times in data frames, Series, or arrays, *pandas* combines the benefits of
    *datetime*, *dateutil*, and *numpy* and serves as a convenient library.
  prefs: []
  type: TYPE_NORMAL
- en: Sources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modern Python Standard Library — Cookbook by Alessandro Molina (2018)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python Data Science Handbook by Jake VanderPlas (2017)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Datacamp course: Working with Dates and Times in Python (2022)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://dateutil.readthedocs.io/en/stable/](https://dateutil.readthedocs.io/en/stable/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/library/datetime.html](https://docs.python.org/3/library/datetime.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/library/zoneinfo.html](https://docs.python.org/3/library/zoneinfo.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://peps.python.org/pep-0615/](https://peps.python.org/pep-0615/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/stub42/pytz/blob/master/src/README.rst#issues--limitations](https://github.com/stub42/pytz/blob/master/src/README.rst#issues--limitations)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
