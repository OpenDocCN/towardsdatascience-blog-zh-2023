- en: 'The Data Scientist’s Toolbox: Parsing'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/the-data-scientists-toolbox-parsing-86ae196a9db5?source=collection_archive---------7-----------------------#2023-11-11](https://towardsdatascience.com/the-data-scientists-toolbox-parsing-86ae196a9db5?source=collection_archive---------7-----------------------#2023-11-11)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Parsing complex documents can be easy if you have the rights tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@doug.blank?source=post_page-----86ae196a9db5--------------------------------)[![Douglas
    Blank, PhD](../Images/b2fa86b9fe63a8bcb4f218ef5a6791e9.png)](https://medium.com/@doug.blank?source=post_page-----86ae196a9db5--------------------------------)[](https://towardsdatascience.com/?source=post_page-----86ae196a9db5--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----86ae196a9db5--------------------------------)
    [Douglas Blank, PhD](https://medium.com/@doug.blank?source=post_page-----86ae196a9db5--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F66e2bac7e7d8&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fthe-data-scientists-toolbox-parsing-86ae196a9db5&user=Douglas+Blank%2C+PhD&userId=66e2bac7e7d8&source=post_page-66e2bac7e7d8----86ae196a9db5---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----86ae196a9db5--------------------------------)
    ·9 min read·Nov 11, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F86ae196a9db5&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fthe-data-scientists-toolbox-parsing-86ae196a9db5&user=Douglas+Blank%2C+PhD&userId=66e2bac7e7d8&source=-----86ae196a9db5---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F86ae196a9db5&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fthe-data-scientists-toolbox-parsing-86ae196a9db5&source=-----86ae196a9db5---------------------bookmark_footer-----------)![](../Images/38272ce6f7419e699fcc02d3a16f4b5c.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Source code of the new Python-based rd2md parser and transformer discussed in
    this article. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: For many Data Scientists, converting complex documents into usable data is a
    common problem. Let’s look at a complex document, and explore different methods
    of transforming the data.
  prefs: []
  type: TYPE_NORMAL
- en: '**TLDR;**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll explore these rules as we develop a complex parser:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 1: Be lazy; don’t do any more than is what is needed'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rule 2: Start with the easy parts of the problem.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rule 3: Don’t be afraid to throw away code and start over!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rule 4: Use the simplest method possible to get the job done.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Problem**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the Head of Research at an ML company, I am often faced with a variety of
    problems that need to be explored and solutions designed. Last week an interesting
    little problem arose: we needed a way to generate markdown documentation for our
    [open source R SDK](https://github.com/comet-ml/cometr) that allows ML experiments
    to log important details. And we needed a solution quickly without spending a
    lot of time on it.'
  prefs: []
  type: TYPE_NORMAL
- en: This problem may be a little more complex than what a Data Scientist would encounter
    on a daily basis, but it will serve as a nice example of how to use different
    methods of parsing. And as a bonus, we’ll end up with a [new open source project](https://github.com/comet-ml/rd2md/)
    that fills a particular niche. Let’s dive in!
  prefs: []
  type: TYPE_NORMAL
- en: 'On hearing of the problem, my first rule of Research and Design (R&D) kicked
    in:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 1: Be lazy; don’t do any more than is what is needed** (Laziness was
    identified by Larry Wall as one of the [Three Great Virtues of a Programmer](https://thethreevirtues.com/)).'
  prefs: []
  type: TYPE_NORMAL
- en: So I started looking to see if converting R code to markdown was a solved problem.
    It appear that it was! However, after trying all of the available programs I could
    find (such as R’s old [Rd2md](https://cran.r-project.org/web/packages/Rd2md/index.html))
    they just didn’t work and the git repositories were no longer active. Okay, so
    I was on my own. If I were a better R programmer, I probably would have tried
    to fix the existing solutions. But I enjoy Python more, and thought it would make
    an nice parsing example. So, yes, we’ll be parsing R documentation in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, I started to write some code. And that reminded me of my next R&D rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 2: Start with the easy parts of the problem.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rule 2 is probably just my way of satisfying my need to have some instantaneous
    feedback. But it does also solve a more important role: if you start with the
    easy parts, maybe the hard parts won’t turn out to be so hard. It also serves
    as a warm-up to start working on a problem. I typically have one or two false
    starts in coding a solution. Which leads to my next rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 3: Don’t be afraid to throw away code and start over!**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, when you are on the right track, the last rule is:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 4: Use the simplest method possible to get the job done.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ok, so what is the easiest method to convert R documentation files into markdown?
    First, what is an R documentation file? R documentation is converted directly
    from the R code into something that looks a lot like [LaTeX](https://en.wikipedia.org/wiki/LaTeX).
    Here is an example (files end in .Rd):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The goal is to convert the LaTeX into markdown that looks something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'which renders like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/97565b6721fff6562a8d318ea6f63f61.png)'
  prefs: []
  type: TYPE_IMG
- en: Example markdown output. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ok, let’s start with something very simple. We’ll go through line-by-line of
    the Rd file with something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we look to see if a line starts with “%” and if it does, we skip
    it (it is just a comment in the Rd file). Likewise, if it starts with “\name”
    then we set the current doc name. Note that we need to escape the backslash if
    we don’t use “raw” Python strings. The code **re.search(“{(.*)}”, line)** assumes
    that the line will contain the ending curly brace. This assumption holds true
    in all of the examples in our SDK, so I won’t make this code any more complicated
    than it needs to be, as per Rule 3.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we construct a **Documentation()** instance before processing the
    lines in the file. We do this to collect all of the parts, and then call **doc.generate()**
    at the end. We do that (rather than generating the markdown on the fly) because
    some of the items that we parse will be in a different order in the markdown.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can handle some of the R code in exactly this fashion: look for a pattern
    on a line from the Rd file, and immediately process it. However, let’s look at
    the next easiest part that can’t be handled this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The usage section always starts with a line that is **\usage{**, and ends with
    a line that is a single **}**. As this is the case, we can use these facts to
    create a slightly more complicated parser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This will read line-by-line, gathering up all of the text in the **\usage{}**
    section.
  prefs: []
  type: TYPE_NORMAL
- en: As we move on to the next most-complicated part, we have to start being a bit
    clever, and, for the first time, use the idea of “state.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this LaTeX code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is tricky. The top-level format is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'However, DESCRIPTION can itself have curly braced items inside it. If you had
    this section of code as a string (even with newlines), you could use Python’s
    re (Regular Expression) module, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can get NAME and DESCRIPTION as **matches.groups()**. The parentheses in
    the re pattern **“{(.*)}{(.*)}”** indicate to match two groups: the first group
    between the first set of curly braces, and the second group between the next set.
    This works great, assuming that **text** is only that section. To be able to parse
    this without first breaking out this section we’ll actually have to parse the
    text, character by character. But this isn’t hard.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a little function that will get a number of curly-brace sections given
    a file pointer (also known as a “file-like” in modern Python parlance):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the function **get_curly_contents()** you would pass in the number of curly-braced
    sections, and a file pointer. So, to get 2 curly braced sections from a file,
    you can do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**get_curly_contents()** is almost as complicated as it gets in this project.
    It has three state variables: **retval**, **count**, and **current**. **retval**
    is a list of parsed sections. **count** is the depth of the current curly-braced
    items. **current** is what is currently being processed. This function is actually
    useful in a few places, as we will see.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, there is one more level of complexity. The problem area is the **Method**
    subsection of a R class definition. Here is a stripped-down example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is complicated because we have nested sections: **Usage** and **Arguments**
    are inside **Method**. We’re going to bring out the full parsing arsenal for this
    one.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this somewhat easier on ourselves, the first thing we’ll do is “tokenize”
    the **Method** subsection. That is a fancy word for breaking text into relevant
    strings. For example, consider this LaTeX text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'It could be tokenized into a list of strings, like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'A list of tokenized string gives you the ability to easily process it into
    its sub-parts. In addition, you can easily “look-ahead” one or more tokens to
    see what is coming. This can be hard to do with Regular Expressions, or if you
    are dealing with individual characters rather than tokens. Here is an example
    of parsing a tokenized section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s it! To see the finished project, checkout the new Python-based [rd2md](https://github.com/comet-ml/rd2md/).
    It is a [pip-installable](https://pypi.org/project/rd2md/), open source Python
    library for generating markdown from R’s Rd files. We’ve used it on our own R
    documentation here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.comet.com/docs/v2/api-and-sdk/r-sdk/overview/](https://www.comet.com/docs/v2/api-and-sdk/r-sdk/overview/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Is this a bit of an afternoon hack? Yes. It is composed of no less than 4 different
    methods of parsing. But it gets the job done, and is the only working Rd to markdown
    converter that works that I know of. If I were to refactor it, I’d probably tokenize
    the entire file first, and then process it using the last method shown above.
    Remember Rule 3: **Don’t be afraid to throw away code and start over!**'
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to contribute to the github repo, please do. If you have questions,
    please let us know in the [Issues](https://github.com/comet-ml/rd2md/issues).
  prefs: []
  type: TYPE_NORMAL
- en: '***Interested in Artificial Intelligence, Machine Learning, and Data Science?
    Consider a clap and a follow. Doug is Head of Research at*** [***comet.com***](https://www.comet.com/)***,
    an ML experiment-tracking and model-monitoring company.***'
  prefs: []
  type: TYPE_NORMAL
