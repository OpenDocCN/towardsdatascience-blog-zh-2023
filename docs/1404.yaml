- en: 'Rust: The Next Big Thing in Data Science'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/rust-the-next-big-thing-in-data-science-319a03305883?source=collection_archive---------0-----------------------#2023-04-24](https://towardsdatascience.com/rust-the-next-big-thing-in-data-science-319a03305883?source=collection_archive---------0-----------------------#2023-04-24)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A Contextual Guide for Data Scientists and Analysts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://wiseai.medium.com/?source=post_page-----319a03305883--------------------------------)[![Mahmoud
    Harmouch](../Images/d61617549d25565399975debaad5908f.png)](https://wiseai.medium.com/?source=post_page-----319a03305883--------------------------------)[](https://towardsdatascience.com/?source=post_page-----319a03305883--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----319a03305883--------------------------------)
    [Mahmoud Harmouch](https://wiseai.medium.com/?source=post_page-----319a03305883--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fb15db3da5667&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Frust-the-next-big-thing-in-data-science-319a03305883&user=Mahmoud+Harmouch&userId=b15db3da5667&source=post_page-b15db3da5667----319a03305883---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----319a03305883--------------------------------)
    ·25 min read·Apr 24, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F319a03305883&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Frust-the-next-big-thing-in-data-science-319a03305883&user=Mahmoud+Harmouch&userId=b15db3da5667&source=-----319a03305883---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F319a03305883&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Frust-the-next-big-thing-in-data-science-319a03305883&source=-----319a03305883---------------------bookmark_footer-----------)![](../Images/f70c77e0e50bd4fba3d37f016cf86374.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Image by [Yvette W](https://pixabay.com/users/wallusy-7300500/?utm_source=link-attribution&amp%3Butm_medium=referral&amp%3Butm_campaign=image&amp%3Butm_content=6246450)
    from [Pixabay](https://pixabay.com//?utm_source=link-attribution&amp%3Butm_medium=referral&amp%3Butm_campaign=image&amp%3Butm_content=6246450)
  prefs: []
  type: TYPE_NORMAL
- en: '**TL**;**DR**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust stands out as a practical choice in data science due to its exceptional
    performance and persistent security features. While it may not possess all the
    bells and whistles that Python does, Rust offers outstanding efficiency when handling
    large datasets. Additionally, developers can use an array of libraries explicitly
    designed for data analysis to streamline their workflow further. With proper mastery
    of this language’s complexities, those working within the field can gain significant
    advantages by incorporating Rust into their toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: This article will delve into the vast array of Rust tools and their application
    in analyzing [**the iris dataset**](https://www.kaggle.com/datasets/uciml/iris).
    The power of Rust as a language for data science projects is evident, despite
    its lesser popularity than Python or R. Its potential and capabilities are boundless,
    making it an excellent option for those seeking to elevate their data science
    endeavors beyond conventional means.
  prefs: []
  type: TYPE_NORMAL
- en: '***Note****: This article assumes you are familiar with Rust and its ecosystem.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You can find the notebook developed for this article in the following repo:*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[](https://github.com/wiseaidev/rust-data-analysis?source=post_page-----319a03305883--------------------------------)
    [## GitHub - wiseaidev/rust-data-analysis: Performing data analysis on the iris
    dataset in a Rust…'
  prefs: []
  type: TYPE_NORMAL
- en: Performing data analysis on the iris dataset in a Rust kernel. curl --proto
    '=https' --tlsv1\. 2 -sSf https…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: github.com](https://github.com/wiseaidev/rust-data-analysis?source=post_page-----319a03305883--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Table of Contents(TOC)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ∘ [Who Is This Article For?](#d61d)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Why Rust?](#82d6)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Rust Advantages.](#1886)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Rusty Notebooks](#784b)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [About the DataSet](#43a5)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Read CSV files](#8699)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Loading a CSV file into Data Frame](#50ae)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Convert To ndarray](#1e06)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Numpy Equivalent](#e6b1)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Shared Similarities](#b5b5)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Key Differences](#8fa8)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Why ndarray?](#4cab)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Plotters](#4b63)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Scatter Plot](#b86d)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Conclusion](#5524)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Closing Note](#157d)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [References](#0aad)
  prefs: []
  type: TYPE_NORMAL
- en: Who Is This Article For?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/bd20329b4e0e174eb670fe5a024a33d6.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Sigmund](https://unsplash.com/fr/@sigmund?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: This article was written for developers who prefer Rust as their primary programming
    language and want to kick off their data science journey. Its purpose is to equip
    them with the essential tools for exploratory data analysis, including loading,
    transforming, and visualizing data. Whether you are a beginner seeking to learn
    more about Rust or an experienced data scientist or analyst eager to employ Rust
    for your projects, this article will be a valuable resource.
  prefs: []
  type: TYPE_NORMAL
- en: Why Rust?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/02a47eda7418650cc4b785b58a3548ff.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Brett Jordan](https://unsplash.com/@brett_jordan?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Over decades, computer scientists have committed themselves to tackle security
    concerns stemming from programming languages like C and C++. Their endeavors have
    given rise to a novel class of systems programming languages called “memory-safe”
    languages. These cutting-edge coding practices are explicitly designed to prevent
    memory-related errors that may pave the way for malicious cyber attacks. Rust
    is undoubtedly an advanced tool among these options; it enjoys widespread usage
    and recognition in contemporary times.
  prefs: []
  type: TYPE_NORMAL
- en: For those not in the know, memory-safety concerns refer to a category of vulnerabilities
    that stem from programming mistakes linked with the misappropriation of memory.
    These issues can result in security breaches, data degradation, and system failures.
    Consequently, there has been an augmented emphasis on utilizing programming languages
    specifically crafted to ensure optimal levels of memory safety.
  prefs: []
  type: TYPE_NORMAL
- en: Tech giants like Google have recognized the outsized impact that memory-related
    problems can have on software security, emphasizing the absolute necessity of
    utilizing these languages to safeguard against such vulnerabilities¹. This recognition
    is a powerful testament to the importance of taking proactive steps to protect
    software from potential threats. It highlights these languages’ role in ensuring
    a more secure future for software development.
  prefs: []
  type: TYPE_NORMAL
- en: Meta is embracing Rust because of its benefits in terms of performance and security,
    signaling a new era in software engineering. By leveraging Rust’s modern features
    and capabilities, Meta has ensured robust product security while achieving greater
    efficiency and scalability².
  prefs: []
  type: TYPE_NORMAL
- en: The open-source community has warmly welcomed Rust, as evidenced by the Linux
    kernel’s adoption³. This development allows developers to utilize Rust for crafting
    dependable and secure software on systems based on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Rust is a remarkably adaptable programming language that provides extensive
    applications. Whether crafting low-level system code or constructing an OS kernel,
    Rust can create high-performance, secure software solutions. Unsurprisingly, IEEE
    Spectrum recently ranked Rust 20th in their top programming languages for 2022⁴!
    It is also no wonder why it is ranked 14th in the recent Stackoverflow as the
    most popular language⁵!
  prefs: []
  type: TYPE_NORMAL
- en: As a prominent computer technology company, Microsoft has expressed the need
    for a programming language surpassing current security standards⁶. As an open-source
    programming language, it appears to be one of the most viable solutions for this
    issue. Amongst these options, Rust stands out as it is worth choosing for development
    and has remarkable achievements in terms of safety and speed.
  prefs: []
  type: TYPE_NORMAL
- en: Mozilla partnered with Samsung to create a web browser called Servo because
    of Rust’s aptitude for crafting secure web browsers⁷. The objective of Servo was
    to develop a pioneering browser engine in Rust, merging Mozilla’s proficiency
    with web browsers and Samsung’s adeptness in hardware. This initiative aimed at
    manufacturing an innovative web engine that could be utilized for desktop computers
    and mobile devices. By capitalizing on the strong points of both corporations,
    Servo had the potential to deliver unparalleled performance when compared to other
    existing web browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Tragically, what was once a promising collaboration came to an abrupt halt as
    Mozilla unveiled its restructuring strategy in response to the pandemic of 2020⁸.
    With the disbandment of the Servo crew, many became anxious about the potential
    impact on Rust’s forward momentum, as the language has become such a critical
    component in developing secure and resilient applications.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, despite this setback, Rust has emerged as one of today’s most
    sought-after programming languages and continues to garner more acclaim among
    developers worldwide. By prioritizing dependability, safety, and efficiency, it
    is undeniable that Rust will remain a reliable language for crafting secure web
    applications well into the future.
  prefs: []
  type: TYPE_NORMAL
- en: Pydantic, a well-known open source project, has rewritten its core implementation
    in Rust, resulting in a significant increase in performance⁹. Pydantic V2 is between
    4x and 50x faster than its predecessor, Pydantic V1.9.1, with around a 17x improvement
    when validating a model with common fields¹⁰.
  prefs: []
  type: TYPE_NORMAL
- en: In a recent announcement, Microsoft revealed its plans to rewrite the Windows
    kernel using Rust after successfully porting the `[**dwrite**](https://learn.microsoft.com/en-us/windows/win32/directwrite/dwritecore-overview)`
    font parsing library to Rust¹¹. This bold move by Microsoft signifies a shift
    towards programming practices that prioritize safety and efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: As Rust continues to assert its dominance as the language of choice for crafting
    robust and secure applications across various industries, we can confidently expect
    a significant reduction in security issues going forward.
  prefs: []
  type: TYPE_NORMAL
- en: So, in short, The primary purpose of using Rust is enhanced safety, speed, and
    concurrency, or the ability to run multiple computations simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Rust Advantages.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/dece0fdd1ee1d3b9bd150136d1545d64.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Den Harrson](https://unsplash.com/@harrson?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: '**1\. C-like Speed.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rust has been developed to offer lightning-fast performance similar to the
    C programming language. In addition, it provides the added advantages of memory
    and thread safety. This makes Rust an ideal option for high-performance gaming,
    data processing, or networking applications. To illustrate this point further,
    consider the following code snippet, which efficiently calculates the Fibonacci
    sequence using Rust:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The above code snippet calculates the **40th number** in the Fibonacci sequence
    using recursion. It executes in **less than a second**, much faster than equivalent
    code in many other languages. Consider Python, for example. It took approximately
    **22.2 seconds** in Python to calculate the same Fibonacci sequence, which is
    way slower than the Rust version.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**2\. Type Safety.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rust is designed to catch many errors at compile time rather than runtime,
    reducing the likelihood of bugs in the final product. Take the following example
    of Rust code that demonstrates its type safety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The above code snippet attempts to add an integer and a string together, which
    is not allowed in Rust due to type safety. The code fails to compile with a helpful
    error message that points to the problem.
  prefs: []
  type: TYPE_NORMAL
- en: '**3\. Memory safety.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rust has been meticulously developed to prevent prevalent memory errors, including
    buffer overflows and null pointer dereferences, thereby reducing the probability
    of security vulnerabilities. This is exemplified by the following scenario that
    showcases Rust’s memory safety measures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The above code attempts to append an element to a vector while holding an immutable
    reference to its first element. This is not allowed in Rust due to memory safety,
    and the code fails to compile with a helpful error message.
  prefs: []
  type: TYPE_NORMAL
- en: '**4\. True and safe parallelism.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ownership model of Rust provides a secure and proficient means of parallelism,
    eliminating data races and other bugs related to concurrency. An illustrative
    example of Rust’s parallelism is presented below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The above code creates ten threads that print messages to the console. Rust’s
    ownership model guarantees that each thread has exclusive access to the necessary
    resources, effectively preventing data races and other concurrency-related bugs.
  prefs: []
  type: TYPE_NORMAL
- en: '**5\. Rich Ecosystem.**'
  prefs: []
  type: TYPE_NORMAL
- en: Rust offers a thriving and dynamic ecosystem with diverse libraries and tools
    catering to a wide range of domains. For instance, Rust provides powerful data
    analysis tools such as `[**ndarray**](https://docs.rs/ndarray/latest/ndarray/)`
    and `[**polors**](https://www.pola.rs/)`, and its `[**serde**](https://serde.rs/)`
    library outperforms any **JSON** library written in Python.
  prefs: []
  type: TYPE_NORMAL
- en: These advantages and others make Rust an attractive option for developers such
    as data scientists seeking a convenient programming language that equips them
    with an extensive list of tools.
  prefs: []
  type: TYPE_NORMAL
- en: Now, with that in mind, let’s explore different data analysis tools that can
    be leveraged in Rust and help you efficiently perform Exploratory data analysis
    (**EDA**).
  prefs: []
  type: TYPE_NORMAL
- en: Rusty Notebooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/911d5df96cd7e2fa6e15d36a691890b5.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Christopher Gower](https://unsplash.com/@cgower?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: 'Programming enthusiasts will agree that Rust has become a top-tier programming
    language for several reasons, such as its blazing speed, reliability, and unparalleled
    flexibility. Nonetheless, novice Rust developers have faced a daunting challenge
    for a long time: the absence of an easily accessible development environment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, with sheer perseverance and determination, Rust developers have
    broken through this barrier by providing a groundbreaking solution: accessing
    Rust through **Jupyter Notebook**. This is made possible by a phenomenal open-source
    project known as `[**evcxr_jupyter**](https://github.com/evcxr/evcxr/blob/main/evcxr_jupyter/README.md)`.
    It equips developers with the ability to write and execute Rust code in the J**upyter
    Notebook** environment, elevating their programming experience to the next level.'
  prefs: []
  type: TYPE_NORMAL
- en: To install `[**evcxr_jupyter**](https://github.com/evcxr/evcxr/blob/main/evcxr_jupyter/README.md)`,
    you must first install [**Jupyter**](https://jupyter.org/install). Once done,
    you can run the following to Install the **Rust Jupyter Kernel**. But first, you
    need to install Rust on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: With **Jupyter** installed, the next step is to install the **Rust Jupyter Kernel**.
    However, you must ensure that Rust is installed on your machine before installing.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step is to set up and install rust on your machine. To do so, head
    over to [the rustup website](https://rustup.rs/) and follow the instructions,
    or run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Once Rust is installed, executing the following commands will install the Rust
    Jupyter Kernel, and you will be on your way to unleashing the full potential of
    Rust on Jupyter Notebook.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once done, run the following command to start a jupyter notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, it is time for exploratory data analysis (**EDA**).
  prefs: []
  type: TYPE_NORMAL
- en: Required Dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are familiar with Python kernel and its remarkable flexibility in installing
    libraries using `!pip`. In that case, you will be glad that a similar feature
    is available in **Rust Jupyter Kernel**. Here, you can use `:dep` to install the
    required crates to facilitate **EDA**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The installation process is a breeze, as demonstrated by the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This crate offers an array of capabilities, including loading and transforming
    data, among many other functionalities. Now that you have installed the necessary
    tools, it’s time to select a dataset that will showcase the true power of Rust
    in EDA. For simplicity reasons, I have opted for the Iris dataset, a popular and
    easily accessible dataset that will provide a solid foundation for demonstrating
    Rust’s data manipulation capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: About the DataSet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/1b7b67321b66ee3a7561743d810a3d72.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Pawel Czerwinski](https://unsplash.com/@pawel_czerwinski?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: The Iris dataset is essential in data science due to its extensive usage across
    diverse applications, from statistical analyses to machine learning. With six
    columns full of information, it is an ideal dataset for exploratory data analysis.
    Every column offers unique insights into various aspects of the Iris flower’s
    characteristics and helps gain profound knowledge about this magnificent plant.
  prefs: []
  type: TYPE_NORMAL
- en: '`**Id**`: A unique row identifier. Although it may be significant, we do not
    need it for our upcoming analyses. Thus, this column will be eliminated from the
    dataset to streamline our research process effectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**SepalLengthCm**`, `**SepalWidthCm**`, `**PetalLengthCm**`, and `**PetalWidthCm**`:
    The dimensions of each flower sample’s sepals and petals are described by the
    multivariate data in columns. These values may include fractional parts, making
    it necessary to store them as a floating-point data type like f32 for precise
    calculations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**Species**`: This column holds the specific type of Iris flower being gathered.
    These values are categorical and need to be treated differently in our analysis.
    We can convert them into numerical (integer) values, like `u32`, or leave them
    as strings for more accessible handling purposes. For now, we will use the String
    type to keep things simple.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the Iris dataset helps us unravel the distinctive characteristics
    of the Iris flower, and its potential for providing us with valuable insights
    is boundless. Our subsequent analyses will harness Rust’s capabilities and those
    of `Polars` crate to conduct data manipulations that yield significant findings.
  prefs: []
  type: TYPE_NORMAL
- en: Read CSV files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/ffc89244f6017c9c29159c1d199a7113.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Mika Baumeister](https://unsplash.com/@mbaumi?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, we need to import the essential modules by utilizing Rust’s remarkable
    feature of selectively importing necessary components. The following code snippet
    accomplishes such a task with ease.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have everything set up, it’s time to take charge and handle our
    dataset with precision and effectiveness. Thanks to the comprehensive tools provided
    by `polars`, working on data have never been easier; all necessary components
    are included in its `prelude` which can be imported seamlessly using a single
    line of code. Let us begin by importing and processing our data through this powerful
    tool!
  prefs: []
  type: TYPE_NORMAL
- en: Loading a CSV file into Data Frame
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/fa8f1969ea89dc654520e7fb1810fd61.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Markus Spiske](https://unsplash.com/@markusspiske?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s dive into the process of loading our CSV file into Polars’ DataFrame
    through the following snippet of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The code first defines a function `**read_data_frame_from_csv**` that takes
    in the `**CSV**` file path and returns a `**DataFrame**`. The code creates a `**CsvReader**`object
    within this function using the `**from_path**` method. It then checks if the file
    exists and has a header using `**expect**` and `**has_header**`, respectively.
    Finally, it loads the `**CSV**` file using the finish and returns the resulting
    `**DataFrame**`, which is unwrapped from a `**PolarsResult**`.
  prefs: []
  type: TYPE_NORMAL
- en: This code can effortlessly load our `**CSV**` dataset into a `**Polars**` `**DataFrame**`
    and begin our exploratory data analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Dataset Dimensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/1105b0e3d44cf32700bcdaf624b33420.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Lewis Guapo](https://unsplash.com/@lewisguapo?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Once we have loaded it into a `**DataFrame**`, we can utilize the `**shape()**`
    method to promptly obtain information about its rows and columns. This enables
    us to determine the number of samples (`**rows**`) and features (`**columns**`),
    which is a basis for further investigation and modeling.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We can see that it’s returned a tuple, where the ﬁrst element indicates the
    number of rows and the second element indicates the number of columns. If you
    have prior knowledge of the dataset, this may be a good indicator of whether your
    dataset has loaded correctly. This information will be helpful later when we’re
    initializing a new array.
  prefs: []
  type: TYPE_NORMAL
- en: Head
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Statement:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Tail
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Statement:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Describe
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Statement:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Columns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Statement:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Drop Species Column
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Statement:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Max
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Statement:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Convert To ndarray
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Statement**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the following sections, we will explore the `**ndarray**` crate and use its
    different methods on our dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Numpy Equivalent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/ee98cf79a28850ddfe0146668498d39a.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Nick Hillier](https://unsplash.com/@nhillier?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: In Rust, there is a robust crate, or a package as you call it in Python, equivalent
    to `**Numpy**` that allows us to store and manipulate data easily. It is called
    `**ndarray**` and provides a multidimensional container containing categorical
    or numerical elements.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that in Rust, packages are called crates based on the registry
    name in which the package is stored. The `**ndarray**` crate can be found on [**crate.io**](https://crates.io/crates/ndarray),
    similar to **Pypi** in Python.
  prefs: []
  type: TYPE_NORMAL
- en: With `**ndarray**`, we can create n-dimensional arrays, perform slicing and
    views, conduct mathematical operations, and more. These features will be essential
    when we load our datasets into containers that we can operate on and conduct our
    analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Shared Similarities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/50dc303d754d9eb34361df8abb5d2cfd.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Jonny Clow](https://unsplash.com/ja/@jonnyclow?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: The `[**ArrayBase**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html)`
    type from the `**ndarray**` crate is an essential tool for data manipulation in
    Rust, equipped with plenty of powerful features. It shares similarities with `**NumPy’s**`
    array type, the `**numpy.ndarray**`, in its particular element type, limitless
    dimensions, and arbitrary strides. If you want to work with large amounts of data
    with unparalleled efficiency, `**ndarray**` is the way to go.
  prefs: []
  type: TYPE_NORMAL
- en: One cannot overstate the fundamental likeness shared by `**ndarray**` and `**NumPy**`’s
    array type; that is the initiation of indexing from zero, not one. Do not underestimate
    the magnitude of this seemingly trivial characteristic, as it can have a considerable
    impact when manipulating extensive datasets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us not overlook another significant similarity: the default memory layout
    of `**ndarray**` and `**NumPy**`’s array type, which is row-major. In other words,
    the default iterators follow the logical order of rows. This feature is precious
    when dealing with arrays surpassing memory capacity and cannot be loaded entirely
    simultaneously.'
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic operators operate on each element individually in both `**ndarray**`
    and `**NumPy**`’s array types. In simpler terms, performing `**a * b**` leads
    to element-wise multiplication, not matrix multiplication. The beauty of this
    functionality is that one can effortlessly execute computations on relatively
    large arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Owned arrays are contiguous in memory in both `**ndarray**` and `**NumPy**`’s
    array type. This means that they are stored in a single block of memory, which
    can improve performance when accessing elements of the array.
  prefs: []
  type: TYPE_NORMAL
- en: Many operations, such as slicing and arithmetic operations, are also supported
    by both `**ndarray**` and `**NumPy**`’s array type. This makes switching between
    the two array types easy, depending on your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Efficiently performing operations is a crucial aspect that significantly affects
    processing time and resource usage in the computational data manipulation domain.
    Slicing, one such operation, is an excellent example due to its low cost — returning
    only a view of an array instead of duplicating the entire dataset.
  prefs: []
  type: TYPE_NORMAL
- en: When writing this article, some essential functionalities in `**NumPy**` cannot
    be found within `**ndarray**`. In particular, when it comes to binary operations
    involving broadcasting functionality between left-hand and right-hand arrays simultaneously,
    this capability can only currently be achieved using `**numpy**` rather than through
    `**ndarray**` alone.
  prefs: []
  type: TYPE_NORMAL
- en: Key Differences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/6072cc3586e2d46dc3f9ea34377afca3.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Eric Prouzet](https://unsplash.com/@eprouzet?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: There are many critical differences between `**Numpy**` and `**ndarray**`. For
    one, In `**NumPy**`, there is no distinction between owned arrays, views, and
    mutable views. Multiple arrays (instances of `**numpy. ndarray**`) can mutably
    reference the same data. On the other hand, In ndarray, all arrays are instances
    of `**ArrayBase**`, but `**ArrayBase**` is generic over the ownership of the data.
    Array owns its data; `**ArrayView**` is a view; `**ArrayViewMut**` is a mutable
    view; `**CowArray**` either owns its data or is a view (with copy-on-write mutation
    of the view variant); and `**ArcArray**` has a reference-counted pointer to its
    data (with copy-on-write mutation). Arrays and views follow Rust’s aliasing rules.
  prefs: []
  type: TYPE_NORMAL
- en: Another essential feature of `**NumPy**` is that all arrays are flexible in
    dimensions. However, with `**ndarray**`, you can create fixed-dimension arrays
    like Array2, which allows for more accurate results and eliminates unnecessary
    heap allocations related to shape and strides.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, When slicing in `**NumPy**`, the indices start, `**start + step, start
    + 2 * step, …**` until the end (exclusive). When slicing in `**ndarray**`, the
    axis is first sliced with a start..end. Then if the step is positive, the first
    index is the front of the slice; if the step is negative, the first index is the
    back of the slice. This means the behavior is the same as `**NumPy**` except when
    `**step < -1**`. Refer to the docs for [**the s! macro**](https://docs.rs/ndarray/latest/ndarray/macro.s.html)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Why ndarray?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For seasoned Rust developers, the argument could be made that the language already
    has an array of data structures, such as vectors, rendering the need for a third-party
    crate to handle data. However, this assertion fails to recognize the specialized
    nature of `**ndarray**`, designed to handle n-dimensional arrays with a mathematical
    focus.
  prefs: []
  type: TYPE_NORMAL
- en: Rust is undoubtedly a strong programming language that can tackle diverse coding
    challenges effortlessly. However, regarding complex operations on multidimensional
    arrays, `**ndarray**` is the ultimate solution. Its specialized design enables
    the seamless execution of advanced data manipulation tasks in scientific computing
    and analytical contexts, making it an essential tool for any programmer seeking
    optimal results.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate this point, consider an example where a researcher needs to manipulate
    a large amount of multidimensional data from a scientific experiment. Rust’s built-in
    data structures, such as [**vectors**](https://doc.rust-lang.org/rust-by-example/std/vec.html),
    may not be optimal for this task, as they lack the advanced features necessary
    for complex array manipulations. In contrast, `**ndarray**` provides an extensive
    range of functionalities, including slicing, broadcasting, and element-wise operations,
    that can simplify and expedite data manipulation tasks when analyzing data, as
    we will explore in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: '**Array creation**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section provides plenty of techniques for creating arrays from scratch,
    enabling users to generate arrays tailored to their specific needs. However, it
    is worth noting that there are other means of creating arrays beyond this section.
    For example, arrays can also be generated by performing arithmetic operations
    on pre-existing arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s explore the different functionalities provided by `**ndarray**`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**2rows × 3columns** Floating Point Array Literal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '**1-D Range** Of Values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`**1-D array**` with n elements within a range:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '**3×4×5** Ones Array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '**3×4×5** Zeros Array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '**3×3** Identity Matrix:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Indexing and slicing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Last Element:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Row 1, Column 4:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'First 5 rows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Last 5 rows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Mathematics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sum:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Sum Along Axis:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Mean:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Transpose:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '**2-D matrix** multiply:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Square Root:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Arithmetic:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In this section, we have explored various functionalities that `**ndarray**`
    provides; A robust tool that works on multidimensional containers and provides
    an array of functions for streamlined data handling. Our exploration has encompassed
    critical elements in utilizing `**ndarray**`: creating arrays, determining their
    dimensions, accessing them via indexing techniques, and executing basic mathematical
    operations efficiently.'
  prefs: []
  type: TYPE_NORMAL
- en: To sum up, `**ndarray**` is a valuable asset for developers and data analysts.
    It offers plenty of methods that efficiently handle multidimensional arrays with
    ease and accuracy. By mastering the techniques discussed in this section and harnessing
    the potential of `**ndarray**`, users can carry out complex data processing tasks
    effortlessly while generating faster yet precise insights based on their findings.
  prefs: []
  type: TYPE_NORMAL
- en: Plotters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/184bc187368b06488376fef7750a8546.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Lukas Blazek](https://unsplash.com/@goumbik?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Having processed and manipulated our data using `**ndarray**`, the next logical
    step is to gain valuable insights by visualizing it using the `[**Plotters**](https://docs.rs/plotters/latest/plotters/)`
    library. This powerful library enables us to create stunning and informative visualizations
    of our data with ease and precision.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the most of the Plotters library alongside `**jupyter-evcxr**`, it
    is necessary to import it beforehand by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'As `**evcxr**` solely relies on SVG images and supports all series types, there
    is no need for any additional backend. Therefore, it would be great to incorporate
    its usage into our system using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: After importing the library, we can utilize its extensive visualization tools
    to craft captivating and enlightening visuals such as graphs, charts, and other
    forms. With these visualizations in place, we can easily detect patterns, trends,
    or insights. This enables data-based decision-making, which yields valuable results.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first start by drawing a scatter plot of the sepal features.
  prefs: []
  type: TYPE_NORMAL
- en: Scatter Plot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s divide the scatter plot code into chunks for easier reading. Take the
    following as an instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This code block creates a vector of tuples called `**sepal_samples**`, where
    each tuple represents a sample of sepal length and sepal width measurements from
    the iris dataset. Now, Let’s go over what each line of the code does:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**let sepal_samples: Vec<(f64,f64)> = {…}**`: A variable named `**sepal_samples**`
    is defined and assigned a code block enclosed in curly brackets `**{…}**`. The
    `**Vec<(f64,f64)>**` datatype annotation indicates that the vector contains tuples
    consisting of two **64-bit** floating-point numbers. This declaration empowers
    Rust to effectively identify and handle each tuple within the given dataset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**let sepal_length_cm: DataFrame = iris_df.select(vec![“SepalLengthCm”]).unwrap();**`:
    To extract the **SepalLengthCm** column from the **iris_df** DataFrame, we utilize
    a `**select**` function and store it in a new `**DataFrame**` object named `**sepal_length_cm**`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**let mut sepal_length = sepal_length_cm.to_ndarray::<Float64Type>().unwrap().into_raw_vec().into_iter();**`:
    With the `**to_ndarray**` method, we can transform the `**DataFrame**` object
    for `**sepal_length_cm**` into a `**ndarray**` of type `**Float64Type**`. From
    there, using the `**into_raw_vec**` method allows us to convert this new array
    into a raw vector format. By calling upon the iterator generated from running
    through our now-raw vector with `**into_iter**`, we can consume and utilize each
    element in turn; exciting stuff!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**let sepal_width_cm: DataFrame = iris_df.select(vec![“SepalWidthCm”]).unwrap();**`:
    selects the `**SepalWidthCm**` column from the `**iris_df**` DataFrame and stores
    the resulting `**DataFrame**` object in a new variable called `**sepal_width_cm**`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**let mut sepal_width = sepal_width_cm.to_ndarray::<Float64Type>().unwrap().into_raw_vec().into_iter();**`:
    With the `**to_ndarray**` method, the `**DataFrame**` object named `**sepal_width_cm**`
    is converted into a `**ndarray**` object with a data type of `**Float64Type**`.
    The resulting `**ndarray**` is then transformed into a raw vector through the
    application of `**into_raw_vec**` and finally generates an iterator that can be
    utilized for consuming its elements by calling on it via `**.into_iter()**`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**sepal_width.zip(sepal_length).collect()**`: A new iterator is generated
    by invoking the `**zip**` function on `**sepal_width**`, with `**sepal_length**`
    passed as an argument. The resulting iterator yields tuples, each comprising one
    element from sepal width and another from sepal length. These tuples are then
    gathered using the collect method to form a new vector — a type `**Vec<(f64,f64)>**`-
    stored in a variable named `**sepal_samples**`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code block looks like the next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '`**evcxr_figure((640, 480), |root| {**`: A new Evcxr figure is initiated with
    dimensions of 640 pixels in width and 480 pixels in height. Additionally, a closure
    that accepts the root parameter which signifies the fundamental drawing region
    of the declared figure is also passed along.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**let mut chart = ChartBuilder::on(&root)**`: This creates a new chart builder
    object using the root drawing area as the base.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**.caption(“Iris Dataset”, (“Arial”, 30).into_font())**`: This adds a caption
    to the chart with the text `**Iris Dataset**` and a font `**Arial**` with a size
    of `**30**`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**.x_label_area_size(40)**`: This sets the size of the `**X-axis**` label
    area to `**40**` pixels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**.y_label_area_size(40)**`: This sets the size of the `**Y-axis**` label
    area to `**40**` pixels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**.build_cartesian_2d(1f64..5f64, 3f64..9f64)?;**`: This line of code builds
    a 2D Cartesian chart with the `**X-axis**` ranging from `**1 to 5**` and the `**Y-axis**`
    ranging from `**3 to 9**`, and returns a Result type which is unwrapped with the
    `**?**` operator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**chart.configure_mesh()**`: This configures the chart’s mesh, which is the
    grid lines and ticks of the chart'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**.x_desc(“Sepal Length (cm)”)**`: This sets the `**X-axis**` description
    to `**Sepal Length (cm)**`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**.y_desc(“Sepal Width (cm)”)**`: This sets the `**Y-axis**` description to
    `**Sepal Width (cm)**`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**.draw()?;**`: This draws the mesh and returns a Result type which is unwrapped
    with the `**?**`operator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**chart.draw_series(sepal_samples.iter().map(|(x, y)| Circle::new((*x,*y),
    3, BLUE.filled())));**`: Using the `**sepal_samples**` vector as input, a sequence
    of data points is plotted on the chart. The `**iter()**` function is invoked to
    iterate over each element in `**sepal_samples**` and `**map()**` methods creates
    an iterator that transforms every point into a `**Circle**` object with blue fill
    color and radius 3\. Finally, this series of Circle objects are passed onto `**chart.draw_series()**`,
    which renders them beautifully onto the graph canvas.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Running the above code chunks will result in the following being drawn in your
    notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e1281a8fc0052b6b1f757cbd2c3b952e.png)'
  prefs: []
  type: TYPE_IMG
- en: Iris dataset Sepal scatter plot (Image by author)
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/52ec672772fd60552bccf21434500155.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Aaron Burden](https://unsplash.com/it/@aaronburden?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this article, we have delved into three tools in Rust and applied
    them to analyze data from the iris dataset. Our findings reveal that Rust is a
    robust language with immense potential for executing data science projects effortlessly.
    Although not as prevalent as Python or R, its capabilities make it an excellent
    option for individuals seeking to significantly elevate their data science endeavors.
  prefs: []
  type: TYPE_NORMAL
- en: It has been confirmed that Rust is a fast and efficient language, with its type
    system that makes debugging relatively easy. Furthermore, numerous libraries and
    frameworks are tailored to data science tasks available in Rust, like `[**Polars**](https://docs.rs/polars/latest/polars/)`
    and `[**ndarray**](https://docs.rs/ndarray/latest/ndarray/)`, which enable the
    seamless handling of massive datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, Rust is an exceptional programming language for data science projects
    as it provides remarkable performance and is relatively easy to manage complex
    datasets. Aspiring developers in data science must consider Rust among their choices
    to embark on a successful journey in this domain.
  prefs: []
  type: TYPE_NORMAL
- en: Closing Note
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we conclude this tutorial, I would like to express my sincere appreciation
    to all those who have dedicated their time and energy to completing it. It has
    been an absolute pleasure to demonstrate the extraordinary capabilities of Rust
    programming language with you.
  prefs: []
  type: TYPE_NORMAL
- en: Being passionate about data science, I promise you that I am going to write
    at least one comprehensive article every week or so on related topics from now
    on. If staying updated with my work interests you, consider connecting with me
    on various social media platforms or reach out directly if anything else needs
    assistance.
  prefs: []
  type: TYPE_NORMAL
- en: Thank You!
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[1] Queue the Hardening Enhancements. (2019, May 09). In Google Security Blog.
    [https://security.googleblog.com/2019/05/queue-hardening-enhancements.html](https://security.googleblog.com/2019/05/queue-hardening-enhancements.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] A brief history of Rust at Facebook. (2021, April 29). In Engineering.fb
    Blog. [https://engineering.fb.com/2021/04/29/developer-tools/rust](https://engineering.fb.com/2021/04/29/developer-tools/rust)'
  prefs: []
  type: TYPE_NORMAL
- en: '[3] Linux 6.1 Officially Adds Support for Rust in the Kernel. (2022, Dec 20).
    In infoq.com. [https://www.infoq.com/news/2022/12/linux-6-1-rust](https://www.infoq.com/news/2022/12/linux-6-1-rust)'
  prefs: []
  type: TYPE_NORMAL
- en: '[4] Top Programming Languages 2022\. (2022, Aug 23). In spectrum.ieee.com [https://spectrum.ieee.org/top-programming-languages-2022](https://spectrum.ieee.org/top-programming-languages-2022)'
  prefs: []
  type: TYPE_NORMAL
- en: '[5] Programming, scripting, and markup languages. (2022, May). In StackOverflow
    Developer Survey 2022\. [https://survey.stackoverflow.co/2022/#programming-scripting-and-markup-languages](https://survey.stackoverflow.co/2022/#programming-scripting-and-markup-languages)'
  prefs: []
  type: TYPE_NORMAL
- en: '[6] We need a safer systems programming language. (2019, July 18). In Microsoft
    security response center blog. [https://msrc.microsoft.com/blog/2019/07/we-need-a-safer-systems-programming-language/](https://msrc.microsoft.com/blog/2019/07/we-need-a-safer-systems-programming-language/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[7] Mozilla and Samsung Collaborate on Next Generation Web Browser Engine.
    (2013, April 3). In Mozilla blog. [https://blog.mozillarr.org/en/mozilla/mozilla-and-samsung-collaborate-on-next-generation-web-browser-engine/](https://blog.mozillarr.org/en/mozilla/mozilla-and-samsung-collaborate-on-next-generation-web-browser-engine/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[8] Mozilla lays off 250 employees due to the pandemic. (2020, Aug 11). In
    Engadget. [https://www.engadget.com/mozilla-firefox-250-employees-layoffs-151324924.html](https://www.engadget.com/mozilla-firefox-250-employees-layoffs-151324924.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[9] How Pydantic V2 leverages Rust’s Superpowers. (2023, Feb 4 & 5). In fosdem.org.
    [https://fosdem.org/2023/schedule/event/rust_how_pydantic_v2_leverages_rusts_superpowers/](https://fosdem.org/2023/schedule/event/rust_how_pydantic_v2_leverages_rusts_superpowers/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[10] pydantic-v2 Performance. (2022, Dec 23). In docs.pydantic.dev. [https://docs.pydantic.dev/blog/pydantic-v2/#performance](https://docs.pydantic.dev/blog/pydantic-v2/#performance)'
  prefs: []
  type: TYPE_NORMAL
- en: '[11] BlueHat IL 2023 - David Weston-Default Security. (2023, Apr 19). On youtube.com.
    [https://www.youtube.com/watch?v=8T6ClX-y2AE&t=2703s](https://www.youtube.com/watch?v=8T6ClX-y2AE&t=2703s)'
  prefs: []
  type: TYPE_NORMAL
