- en: 'Rust: The Next Big Thing in Data Science'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'Rust: 数据科学中的下一个大事'
- en: 原文：[https://towardsdatascience.com/rust-the-next-big-thing-in-data-science-319a03305883?source=collection_archive---------0-----------------------#2023-04-24](https://towardsdatascience.com/rust-the-next-big-thing-in-data-science-319a03305883?source=collection_archive---------0-----------------------#2023-04-24)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/rust-the-next-big-thing-in-data-science-319a03305883?source=collection_archive---------0-----------------------#2023-04-24](https://towardsdatascience.com/rust-the-next-big-thing-in-data-science-319a03305883?source=collection_archive---------0-----------------------#2023-04-24)
- en: A Contextual Guide for Data Scientists and Analysts
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据科学家和分析师的上下文指南
- en: '[](https://wiseai.medium.com/?source=post_page-----319a03305883--------------------------------)[![Mahmoud
    Harmouch](../Images/d61617549d25565399975debaad5908f.png)](https://wiseai.medium.com/?source=post_page-----319a03305883--------------------------------)[](https://towardsdatascience.com/?source=post_page-----319a03305883--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----319a03305883--------------------------------)
    [Mahmoud Harmouch](https://wiseai.medium.com/?source=post_page-----319a03305883--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://wiseai.medium.com/?source=post_page-----319a03305883--------------------------------)[![Mahmoud
    Harmouch](../Images/d61617549d25565399975debaad5908f.png)](https://wiseai.medium.com/?source=post_page-----319a03305883--------------------------------)[](https://towardsdatascience.com/?source=post_page-----319a03305883--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----319a03305883--------------------------------)
    [Mahmoud Harmouch](https://wiseai.medium.com/?source=post_page-----319a03305883--------------------------------)'
- en: ·
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fb15db3da5667&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Frust-the-next-big-thing-in-data-science-319a03305883&user=Mahmoud+Harmouch&userId=b15db3da5667&source=post_page-b15db3da5667----319a03305883---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----319a03305883--------------------------------)
    ·25 min read·Apr 24, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F319a03305883&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Frust-the-next-big-thing-in-data-science-319a03305883&user=Mahmoud+Harmouch&userId=b15db3da5667&source=-----319a03305883---------------------clap_footer-----------)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[关注](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fb15db3da5667&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Frust-the-next-big-thing-in-data-science-319a03305883&user=Mahmoud+Harmouch&userId=b15db3da5667&source=post_page-b15db3da5667----319a03305883---------------------post_header-----------)
    发表在 [Towards Data Science](https://towardsdatascience.com/?source=post_page-----319a03305883--------------------------------)
    · 25 分钟阅读 · 2023年4月24日 [](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F319a03305883&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Frust-the-next-big-thing-in-data-science-319a03305883&user=Mahmoud+Harmouch&userId=b15db3da5667&source=-----319a03305883---------------------clap_footer-----------)'
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F319a03305883&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Frust-the-next-big-thing-in-data-science-319a03305883&source=-----319a03305883---------------------bookmark_footer-----------)![](../Images/f70c77e0e50bd4fba3d37f016cf86374.png)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F319a03305883&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Frust-the-next-big-thing-in-data-science-319a03305883&source=-----319a03305883---------------------bookmark_footer-----------)![](../Images/f70c77e0e50bd4fba3d37f016cf86374.png)'
- en: Image by [Yvette W](https://pixabay.com/users/wallusy-7300500/?utm_source=link-attribution&amp%3Butm_medium=referral&amp%3Butm_campaign=image&amp%3Butm_content=6246450)
    from [Pixabay](https://pixabay.com//?utm_source=link-attribution&amp%3Butm_medium=referral&amp%3Butm_campaign=image&amp%3Butm_content=6246450)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图片来源 [Yvette W](https://pixabay.com/users/wallusy-7300500/?utm_source=link-attribution&amp%3Butm_medium=referral&amp%3Butm_campaign=image&amp%3Butm_content=6246450)
    来自 [Pixabay](https://pixabay.com//?utm_source=link-attribution&amp%3Butm_medium=referral&amp%3Butm_campaign=image&amp%3Butm_content=6246450)
- en: '**TL**;**DR**'
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**TL**;**DR**'
- en: Rust stands out as a practical choice in data science due to its exceptional
    performance and persistent security features. While it may not possess all the
    bells and whistles that Python does, Rust offers outstanding efficiency when handling
    large datasets. Additionally, developers can use an array of libraries explicitly
    designed for data analysis to streamline their workflow further. With proper mastery
    of this language’s complexities, those working within the field can gain significant
    advantages by incorporating Rust into their toolkit.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 在数据科学中脱颖而出，因其卓越的性能和持续的安全特性。尽管它可能没有 Python 的所有功能，但在处理大型数据集时，Rust 提供了出色的效率。此外，开发者可以使用专门设计用于数据分析的各种库，以进一步简化工作流程。通过对该语言复杂性的正确掌握，从业人员可以通过将
    Rust 纳入工具箱获得显著优势。
- en: This article will delve into the vast array of Rust tools and their application
    in analyzing [**the iris dataset**](https://www.kaggle.com/datasets/uciml/iris).
    The power of Rust as a language for data science projects is evident, despite
    its lesser popularity than Python or R. Its potential and capabilities are boundless,
    making it an excellent option for those seeking to elevate their data science
    endeavors beyond conventional means.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本文将**深入探讨** Rust 工具的广泛应用及其在分析[**鸢尾花数据集**](https://www.kaggle.com/datasets/uciml/iris)中的应用。尽管
    Rust 在数据科学项目中的受欢迎程度不及 Python 或 R，但其作为数据科学语言的力量显而易见。其潜力和能力是无尽的，使其成为那些希望将数据科学工作提升到常规手段之外的优秀选择。
- en: '***Note****: This article assumes you are familiar with Rust and its ecosystem.*'
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '***注意***: 本文假设你对 Rust 及其生态系统有所了解。*'
- en: ''
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You can find the notebook developed for this article in the following repo:*'
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*你可以在以下仓库中找到为这篇文章开发的笔记本：*'
- en: '[](https://github.com/wiseaidev/rust-data-analysis?source=post_page-----319a03305883--------------------------------)
    [## GitHub - wiseaidev/rust-data-analysis: Performing data analysis on the iris
    dataset in a Rust…'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://github.com/wiseaidev/rust-data-analysis?source=post_page-----319a03305883--------------------------------)
    [## GitHub - wiseaidev/rust-data-analysis: 在 Rust 中对鸢尾花数据集进行数据分析…'
- en: Performing data analysis on the iris dataset in a Rust kernel. curl --proto
    '=https' --tlsv1\. 2 -sSf https…
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Rust 内核中进行鸢尾花数据集的数据分析。 curl --proto '=https' --tlsv1\. 2 -sSf https…
- en: github.com](https://github.com/wiseaidev/rust-data-analysis?source=post_page-----319a03305883--------------------------------)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: github.com](https://github.com/wiseaidev/rust-data-analysis?source=post_page-----319a03305883--------------------------------)
- en: Table of Contents(TOC)
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目录(TOC)
- en: ∘ [Who Is This Article For?](#d61d)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [这篇文章适合谁?](#d61d)
- en: ∘ [Why Rust?](#82d6)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [为什么选择 Rust?](#82d6)
- en: ∘ [Rust Advantages.](#1886)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [Rust 的优势](#1886)
- en: ∘ [Rusty Notebooks](#784b)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [生锈的笔记本](#784b)
- en: ∘ [About the DataSet](#43a5)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [关于数据集](#43a5)
- en: ∘ [Read CSV files](#8699)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [读取 CSV 文件](#8699)
- en: ∘ [Loading a CSV file into Data Frame](#50ae)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [将 CSV 文件加载到数据框](#50ae)
- en: ∘ [Convert To ndarray](#1e06)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [转换为 ndarray](#1e06)
- en: ∘ [Numpy Equivalent](#e6b1)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [Numpy 等效](#e6b1)
- en: ∘ [Shared Similarities](#b5b5)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [共享相似性](#b5b5)
- en: ∘ [Key Differences](#8fa8)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [关键差异](#8fa8)
- en: ∘ [Why ndarray?](#4cab)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [为什么选择 ndarray?](#4cab)
- en: ∘ [Plotters](#4b63)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [绘图工具](#4b63)
- en: ∘ [Scatter Plot](#b86d)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [散点图](#b86d)
- en: ∘ [Conclusion](#5524)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [结论](#5524)
- en: ∘ [Closing Note](#157d)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [结束语](#157d)
- en: ∘ [References](#0aad)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [参考文献](#0aad)
- en: Who Is This Article For?
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这篇文章适合谁?
- en: '![](../Images/bd20329b4e0e174eb670fe5a024a33d6.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/bd20329b4e0e174eb670fe5a024a33d6.png)'
- en: Photo by [Sigmund](https://unsplash.com/fr/@sigmund?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 照片由 [Sigmund](https://unsplash.com/fr/@sigmund?utm_source=medium&utm_medium=referral)
    提供，来源于 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: This article was written for developers who prefer Rust as their primary programming
    language and want to kick off their data science journey. Its purpose is to equip
    them with the essential tools for exploratory data analysis, including loading,
    transforming, and visualizing data. Whether you are a beginner seeking to learn
    more about Rust or an experienced data scientist or analyst eager to employ Rust
    for your projects, this article will be a valuable resource.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 本文为那些将 Rust 作为主要编程语言的开发者撰写，并希望开始他们的数据科学之旅。其目的是为他们提供探索性数据分析所需的基本工具，包括加载、转换和可视化数据。无论你是希望了解更多关于
    Rust 的初学者，还是希望在项目中使用 Rust 的经验丰富的数据科学家或分析师，这篇文章都将是一个宝贵的资源。
- en: Why Rust?
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么选择 Rust?
- en: '![](../Images/02a47eda7418650cc4b785b58a3548ff.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/02a47eda7418650cc4b785b58a3548ff.png)'
- en: Photo by [Brett Jordan](https://unsplash.com/@brett_jordan?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[Brett Jordan](https://unsplash.com/@brett_jordan?utm_source=medium&utm_medium=referral)
    拍摄于 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)'
- en: Over decades, computer scientists have committed themselves to tackle security
    concerns stemming from programming languages like C and C++. Their endeavors have
    given rise to a novel class of systems programming languages called “memory-safe”
    languages. These cutting-edge coding practices are explicitly designed to prevent
    memory-related errors that may pave the way for malicious cyber attacks. Rust
    is undoubtedly an advanced tool among these options; it enjoys widespread usage
    and recognition in contemporary times.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 数十年来，计算机科学家们致力于解决源自C和C++等编程语言的安全问题。他们的努力催生了一类新的系统编程语言，称为“内存安全”语言。这些前沿的编码实践明确旨在防止可能导致恶意网络攻击的内存相关错误。Rust无疑是这些选项中的先进工具；在当代享有广泛使用和认可。
- en: For those not in the know, memory-safety concerns refer to a category of vulnerabilities
    that stem from programming mistakes linked with the misappropriation of memory.
    These issues can result in security breaches, data degradation, and system failures.
    Consequently, there has been an augmented emphasis on utilizing programming languages
    specifically crafted to ensure optimal levels of memory safety.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不了解的人来说，内存安全问题指的是源自编程错误的漏洞，这些错误与内存的不当使用有关。这些问题可能导致安全漏洞、数据退化和系统故障。因此，越来越强调使用专门设计以确保最佳内存安全水平的编程语言。
- en: Tech giants like Google have recognized the outsized impact that memory-related
    problems can have on software security, emphasizing the absolute necessity of
    utilizing these languages to safeguard against such vulnerabilities¹. This recognition
    is a powerful testament to the importance of taking proactive steps to protect
    software from potential threats. It highlights these languages’ role in ensuring
    a more secure future for software development.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 像谷歌这样的科技巨头已经认识到与内存相关的问题对软件安全的巨大影响，强调了使用这些语言以防范此类漏洞的绝对必要性¹。这样的认可强有力地证明了采取主动措施保护软件免受潜在威胁的重要性。它突显了这些语言在确保软件开发未来更安全方面的作用。
- en: Meta is embracing Rust because of its benefits in terms of performance and security,
    signaling a new era in software engineering. By leveraging Rust’s modern features
    and capabilities, Meta has ensured robust product security while achieving greater
    efficiency and scalability².
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Meta正在采用Rust，因为它在性能和安全性方面的好处，标志着软件工程的新纪元。通过利用Rust的现代特性和功能，Meta确保了强大的产品安全性，同时实现了更高的效率和可扩展性²。
- en: The open-source community has warmly welcomed Rust, as evidenced by the Linux
    kernel’s adoption³. This development allows developers to utilize Rust for crafting
    dependable and secure software on systems based on Linux.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 开源社区热烈欢迎Rust，正如Linux内核的采用所证明的那样³。这一发展使得开发者可以利用Rust在基于Linux的系统上打造可靠和安全的软件。
- en: Rust is a remarkably adaptable programming language that provides extensive
    applications. Whether crafting low-level system code or constructing an OS kernel,
    Rust can create high-performance, secure software solutions. Unsurprisingly, IEEE
    Spectrum recently ranked Rust 20th in their top programming languages for 2022⁴!
    It is also no wonder why it is ranked 14th in the recent Stackoverflow as the
    most popular language⁵!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Rust是一种极具适应性的编程语言，提供广泛的应用。不论是编写低级系统代码还是构建操作系统内核，Rust都能创建高性能、安全的软件解决方案。毫不奇怪，IEEE
    Spectrum最近将Rust排在2022年顶级编程语言的第20位⁴！最近在Stackoverflow中排名第14的最受欢迎语言也不足为奇⁵！
- en: As a prominent computer technology company, Microsoft has expressed the need
    for a programming language surpassing current security standards⁶. As an open-source
    programming language, it appears to be one of the most viable solutions for this
    issue. Amongst these options, Rust stands out as it is worth choosing for development
    and has remarkable achievements in terms of safety and speed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一家杰出的计算机技术公司，微软已表达了对一种超越当前安全标准的编程语言的需求⁶。作为一种开源编程语言，它似乎是解决这个问题的最可行解决方案之一。在这些选项中，Rust脱颖而出，因为它在安全性和速度方面表现卓越，是开发中的值得选择。
- en: Mozilla partnered with Samsung to create a web browser called Servo because
    of Rust’s aptitude for crafting secure web browsers⁷. The objective of Servo was
    to develop a pioneering browser engine in Rust, merging Mozilla’s proficiency
    with web browsers and Samsung’s adeptness in hardware. This initiative aimed at
    manufacturing an innovative web engine that could be utilized for desktop computers
    and mobile devices. By capitalizing on the strong points of both corporations,
    Servo had the potential to deliver unparalleled performance when compared to other
    existing web browsers.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Mozilla 与三星合作创建了名为 Servo 的网页浏览器，因为 Rust 在构建安全网页浏览器方面表现出色。Servo 的目标是开发一个开创性的
    Rust 浏览器引擎，将 Mozilla 在网页浏览器方面的专业技能与三星在硬件方面的专长相结合。该倡议旨在制造一个可以用于桌面电脑和移动设备的创新网页引擎。通过利用两家公司的强项，Servo
    有潜力在性能上超越其他现有的网页浏览器。
- en: Tragically, what was once a promising collaboration came to an abrupt halt as
    Mozilla unveiled its restructuring strategy in response to the pandemic of 2020⁸.
    With the disbandment of the Servo crew, many became anxious about the potential
    impact on Rust’s forward momentum, as the language has become such a critical
    component in developing secure and resilient applications.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 可悲的是，曾经充满希望的合作突然终止，因为 Mozilla 在响应 2020 年疫情时公布了其重组战略。随着 Servo 团队的解散，许多人对 Rust
    的前进势头产生了焦虑，因为该语言已成为开发安全和可靠应用程序的重要组成部分。
- en: Nevertheless, despite this setback, Rust has emerged as one of today’s most
    sought-after programming languages and continues to garner more acclaim among
    developers worldwide. By prioritizing dependability, safety, and efficiency, it
    is undeniable that Rust will remain a reliable language for crafting secure web
    applications well into the future.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，尽管经历了这一挫折，Rust 仍然成为当今最受欢迎的编程语言之一，并且在全球开发者中继续获得更多的赞誉。通过优先考虑可靠性、安全性和效率，毫无疑问，Rust
    将继续成为未来构建安全网页应用程序的可靠语言。
- en: Pydantic, a well-known open source project, has rewritten its core implementation
    in Rust, resulting in a significant increase in performance⁹. Pydantic V2 is between
    4x and 50x faster than its predecessor, Pydantic V1.9.1, with around a 17x improvement
    when validating a model with common fields¹⁰.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic，一个著名的开源项目，已经将其核心实现重写为 Rust，从而显著提高了性能。Pydantic V2 比其前身 Pydantic V1.9.1
    快 4 倍到 50 倍，在验证包含常见字段的模型时，性能提高了大约 17 倍。
- en: In a recent announcement, Microsoft revealed its plans to rewrite the Windows
    kernel using Rust after successfully porting the `[**dwrite**](https://learn.microsoft.com/en-us/windows/win32/directwrite/dwritecore-overview)`
    font parsing library to Rust¹¹. This bold move by Microsoft signifies a shift
    towards programming practices that prioritize safety and efficiency.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在最近的一次公告中，微软透露了其计划在成功将 `[**dwrite**](https://learn.microsoft.com/en-us/windows/win32/directwrite/dwritecore-overview)`
    字体解析库移植到 Rust 之后，重写 Windows 内核的计划。微软这一大胆举动标志着编程实践向优先考虑安全性和效率的方向转变。
- en: As Rust continues to assert its dominance as the language of choice for crafting
    robust and secure applications across various industries, we can confidently expect
    a significant reduction in security issues going forward.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Rust 在各个行业中继续巩固其作为构建强健和安全应用程序的首选语言的地位，我们可以自信地期待未来安全问题的显著减少。
- en: So, in short, The primary purpose of using Rust is enhanced safety, speed, and
    concurrency, or the ability to run multiple computations simultaneously.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，使用 Rust 的主要目的是增强安全性、速度和并发性，即同时运行多个计算的能力。
- en: Rust Advantages.
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust 的优势。
- en: '![](../Images/dece0fdd1ee1d3b9bd150136d1545d64.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/dece0fdd1ee1d3b9bd150136d1545d64.png)'
- en: Photo by [Den Harrson](https://unsplash.com/@harrson?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由[Den Harrson](https://unsplash.com/@harrson?utm_source=medium&utm_medium=referral)拍摄，来源于[Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: '**1\. C-like Speed.**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**1\. 类 C 的速度。**'
- en: 'Rust has been developed to offer lightning-fast performance similar to the
    C programming language. In addition, it provides the added advantages of memory
    and thread safety. This makes Rust an ideal option for high-performance gaming,
    data processing, or networking applications. To illustrate this point further,
    consider the following code snippet, which efficiently calculates the Fibonacci
    sequence using Rust:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 被开发以提供类似于 C 编程语言的闪电般的性能。此外，它还提供了内存和线程安全的附加优势。这使得 Rust 成为高性能游戏、数据处理或网络应用程序的理想选择。为进一步说明这一点，请考虑以下代码片段，该代码片段使用
    Rust 高效地计算了斐波那契数列：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The above code snippet calculates the **40th number** in the Fibonacci sequence
    using recursion. It executes in **less than a second**, much faster than equivalent
    code in many other languages. Consider Python, for example. It took approximately
    **22.2 seconds** in Python to calculate the same Fibonacci sequence, which is
    way slower than the Rust version.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码片段使用递归计算了斐波那契数列中的 **第40个数字**。它的执行时间为 **不到一秒**，比许多其他语言中的等效代码要快得多。例如，Python
    中计算相同斐波那契数列需要大约 **22.2秒**，这比 Rust 版本慢得多。
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**2\. Type Safety.**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**2\. 类型安全。**'
- en: 'Rust is designed to catch many errors at compile time rather than runtime,
    reducing the likelihood of bugs in the final product. Take the following example
    of Rust code that demonstrates its type safety:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 旨在在编译时捕获许多错误，而不是在运行时，从而减少最终产品中出现错误的可能性。以下是一个展示 Rust 类型安全性的代码示例：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The above code snippet attempts to add an integer and a string together, which
    is not allowed in Rust due to type safety. The code fails to compile with a helpful
    error message that points to the problem.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码片段试图将一个整数和一个字符串相加，由于类型安全的原因，Rust 不允许这样做。代码无法编译，并且提供了一个有用的错误信息，指明了问题所在。
- en: '**3\. Memory safety.**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**3\. 内存安全。**'
- en: 'Rust has been meticulously developed to prevent prevalent memory errors, including
    buffer overflows and null pointer dereferences, thereby reducing the probability
    of security vulnerabilities. This is exemplified by the following scenario that
    showcases Rust’s memory safety measures:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 已被精心开发以防止常见的内存错误，包括缓冲区溢出和空指针解引用，从而减少安全漏洞的可能性。以下是一个展示 Rust 内存安全措施的场景：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The above code attempts to append an element to a vector while holding an immutable
    reference to its first element. This is not allowed in Rust due to memory safety,
    and the code fails to compile with a helpful error message.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码尝试在持有对其第一个元素的不可变引用的同时向向量中追加一个元素。由于内存安全原因，这在 Rust 中是不允许的，代码无法编译，并且提供了一个有用的错误信息。
- en: '**4\. True and safe parallelism.**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**4\. 真实且安全的并行性。**'
- en: 'The ownership model of Rust provides a secure and proficient means of parallelism,
    eliminating data races and other bugs related to concurrency. An illustrative
    example of Rust’s parallelism is presented below:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 的所有权模型提供了一种安全而高效的并行性方式，消除了数据竞争和其他与并发相关的错误。以下是一个展示 Rust 并行性的示例：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The above code creates ten threads that print messages to the console. Rust’s
    ownership model guarantees that each thread has exclusive access to the necessary
    resources, effectively preventing data races and other concurrency-related bugs.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码创建了十个线程，这些线程向控制台打印消息。Rust 的所有权模型保证每个线程对所需资源具有独占访问权，有效地防止了数据竞争和其他与并发相关的错误。
- en: '**5\. Rich Ecosystem.**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**5\. 丰富的生态系统。**'
- en: Rust offers a thriving and dynamic ecosystem with diverse libraries and tools
    catering to a wide range of domains. For instance, Rust provides powerful data
    analysis tools such as `[**ndarray**](https://docs.rs/ndarray/latest/ndarray/)`
    and `[**polors**](https://www.pola.rs/)`, and its `[**serde**](https://serde.rs/)`
    library outperforms any **JSON** library written in Python.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 提供了一个蓬勃发展的动态生态系统，拥有各种适用于广泛领域的库和工具。例如，Rust 提供了强大的数据分析工具，如 `[**ndarray**](https://docs.rs/ndarray/latest/ndarray/)`
    和 `[**polors**](https://www.pola.rs/)`，而其 `[**serde**](https://serde.rs/)` 库的性能优于任何用
    Python 编写的 **JSON** 库。
- en: These advantages and others make Rust an attractive option for developers such
    as data scientists seeking a convenient programming language that equips them
    with an extensive list of tools.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些优势以及其他优势使得 Rust 成为像数据科学家这样的开发者的一个有吸引力的选择，他们寻找一种方便的编程语言，该语言提供了丰富的工具列表。
- en: Now, with that in mind, let’s explore different data analysis tools that can
    be leveraged in Rust and help you efficiently perform Exploratory data analysis
    (**EDA**).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了这些认识，让我们探索在 Rust 中可以利用的不同数据分析工具，帮助你高效地进行探索性数据分析 (**EDA**)。
- en: Rusty Notebooks
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rusty Notebooks
- en: '![](../Images/911d5df96cd7e2fa6e15d36a691890b5.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/911d5df96cd7e2fa6e15d36a691890b5.png)'
- en: Photo by [Christopher Gower](https://unsplash.com/@cgower?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由 [Christopher Gower](https://unsplash.com/@cgower?utm_source=medium&utm_medium=referral)
    提供，来源于 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: 'Programming enthusiasts will agree that Rust has become a top-tier programming
    language for several reasons, such as its blazing speed, reliability, and unparalleled
    flexibility. Nonetheless, novice Rust developers have faced a daunting challenge
    for a long time: the absence of an easily accessible development environment.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 编程爱好者会同意，Rust 由于其极快的速度、可靠性和无与伦比的灵活性，已成为顶级编程语言。然而，新手 Rust 开发者长期面临一个令人生畏的挑战：缺乏一个易于访问的开发环境。
- en: 'Fortunately, with sheer perseverance and determination, Rust developers have
    broken through this barrier by providing a groundbreaking solution: accessing
    Rust through **Jupyter Notebook**. This is made possible by a phenomenal open-source
    project known as `[**evcxr_jupyter**](https://github.com/evcxr/evcxr/blob/main/evcxr_jupyter/README.md)`.
    It equips developers with the ability to write and execute Rust code in the J**upyter
    Notebook** environment, elevating their programming experience to the next level.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，通过不懈的坚持和决心，Rust 开发者突破了这一障碍，提供了一个突破性的解决方案：通过**Jupyter Notebook**访问 Rust。这是通过一个称为
    `[**evcxr_jupyter**](https://github.com/evcxr/evcxr/blob/main/evcxr_jupyter/README.md)`
    的卓越开源项目实现的。它使开发者能够在 J**upyter Notebook** 环境中编写和执行 Rust 代码，将他们的编程体验提升到一个新的水平。
- en: To install `[**evcxr_jupyter**](https://github.com/evcxr/evcxr/blob/main/evcxr_jupyter/README.md)`,
    you must first install [**Jupyter**](https://jupyter.org/install). Once done,
    you can run the following to Install the **Rust Jupyter Kernel**. But first, you
    need to install Rust on your machine.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 `[**evcxr_jupyter**](https://github.com/evcxr/evcxr/blob/main/evcxr_jupyter/README.md)`，你首先需要安装
    [**Jupyter**](https://jupyter.org/install)。完成后，你可以运行以下命令安装**Rust Jupyter Kernel**。但首先，你需要在机器上安装
    Rust。
- en: With **Jupyter** installed, the next step is to install the **Rust Jupyter Kernel**.
    However, you must ensure that Rust is installed on your machine before installing.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了**Jupyter**后，下一步是安装**Rust Jupyter Kernel**。但在安装之前，你必须确保机器上已经安装了 Rust。
- en: Getting Started.
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用。
- en: 'The first step is to set up and install rust on your machine. To do so, head
    over to [the rustup website](https://rustup.rs/) and follow the instructions,
    or run the following command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是设置并安装 Rust。为此，请访问 [rustup 网站](https://rustup.rs/) 并按照说明进行操作，或者运行以下命令：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once Rust is installed, executing the following commands will install the Rust
    Jupyter Kernel, and you will be on your way to unleashing the full potential of
    Rust on Jupyter Notebook.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Rust 后，执行以下命令将安装 Rust Jupyter Kernel，之后你将能够在 Jupyter Notebook 上释放 Rust 的全部潜力。
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once done, run the following command to start a jupyter notebook:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，运行以下命令以启动 Jupyter Notebook：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, it is time for exploratory data analysis (**EDA**).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候进行探索性数据分析 (**EDA**) 了。
- en: Required Dependencies
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 所需依赖
- en: If you are familiar with Python kernel and its remarkable flexibility in installing
    libraries using `!pip`. In that case, you will be glad that a similar feature
    is available in **Rust Jupyter Kernel**. Here, you can use `:dep` to install the
    required crates to facilitate **EDA**.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 Python 内核及其使用 `!pip` 安装库的卓越灵活性，那么你会高兴地发现，**Rust Jupyter Kernel** 中也提供了类似的功能。在这里，你可以使用
    `:dep` 安装所需的 crates 以支持**EDA**。
- en: 'The installation process is a breeze, as demonstrated by the following code
    snippet:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 安装过程非常简单，如下代码片段所示：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This crate offers an array of capabilities, including loading and transforming
    data, among many other functionalities. Now that you have installed the necessary
    tools, it’s time to select a dataset that will showcase the true power of Rust
    in EDA. For simplicity reasons, I have opted for the Iris dataset, a popular and
    easily accessible dataset that will provide a solid foundation for demonstrating
    Rust’s data manipulation capabilities.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 crate 提供了一系列功能，包括加载和转换数据等。现在你已经安装了必要的工具，是时候选择一个数据集，以展示 Rust 在 EDA 中的真正力量。为了简单起见，我选择了
    Iris 数据集，一个流行且易于访问的数据集，将为展示 Rust 的数据处理能力提供坚实的基础。
- en: About the DataSet
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于数据集
- en: '![](../Images/1b7b67321b66ee3a7561743d810a3d72.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1b7b67321b66ee3a7561743d810a3d72.png)'
- en: Photo by [Pawel Czerwinski](https://unsplash.com/@pawel_czerwinski?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 照片由 [Pawel Czerwinski](https://unsplash.com/@pawel_czerwinski?utm_source=medium&utm_medium=referral)
    提供，来源于 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: The Iris dataset is essential in data science due to its extensive usage across
    diverse applications, from statistical analyses to machine learning. With six
    columns full of information, it is an ideal dataset for exploratory data analysis.
    Every column offers unique insights into various aspects of the Iris flower’s
    characteristics and helps gain profound knowledge about this magnificent plant.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Iris 数据集在数据科学中至关重要，因为它在各种应用中被广泛使用，从统计分析到机器学习。拥有六列信息，它是进行探索性数据分析的理想数据集。每一列都提供了对
    Iris 花卉特征的独特见解，并帮助我们深入了解这一壮丽植物。
- en: '`**Id**`: A unique row identifier. Although it may be significant, we do not
    need it for our upcoming analyses. Thus, this column will be eliminated from the
    dataset to streamline our research process effectively.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**Id**`：一个唯一的行标识符。虽然它可能很重要，但在我们接下来的分析中不需要。因此，这一列将从数据集中删除，以有效简化我们的研究过程。'
- en: '`**SepalLengthCm**`, `**SepalWidthCm**`, `**PetalLengthCm**`, and `**PetalWidthCm**`:
    The dimensions of each flower sample’s sepals and petals are described by the
    multivariate data in columns. These values may include fractional parts, making
    it necessary to store them as a floating-point data type like f32 for precise
    calculations.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**SepalLengthCm**`、`**SepalWidthCm**`、`**PetalLengthCm**` 和 `**PetalWidthCm**`：每个花样本的萼片和花瓣的尺寸由列中的多变量数据描述。这些值可能包含小数部分，因此需要将其存储为浮点数据类型，如
    f32，以进行精确计算。'
- en: '`**Species**`: This column holds the specific type of Iris flower being gathered.
    These values are categorical and need to be treated differently in our analysis.
    We can convert them into numerical (integer) values, like `u32`, or leave them
    as strings for more accessible handling purposes. For now, we will use the String
    type to keep things simple.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**Species**`：此列包含被收集的 Iris 花卉的具体类型。这些值是类别型的，在分析中需要以不同的方式处理。我们可以将它们转换为数值（整数）值，如
    `u32`，或者保留为字符串以便更方便地处理。现在，我们将使用 String 类型以保持简单。'
- en: As you can see, the Iris dataset helps us unravel the distinctive characteristics
    of the Iris flower, and its potential for providing us with valuable insights
    is boundless. Our subsequent analyses will harness Rust’s capabilities and those
    of `Polars` crate to conduct data manipulations that yield significant findings.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Iris 数据集帮助我们揭示了 Iris 花卉的独特特征，它提供有价值见解的潜力是无限的。我们的后续分析将利用 Rust 的能力和 `Polars`
    crate 进行数据操作，以获得重要的发现。
- en: Read CSV files
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取 CSV 文件
- en: '![](../Images/ffc89244f6017c9c29159c1d199a7113.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ffc89244f6017c9c29159c1d199a7113.png)'
- en: Photo by [Mika Baumeister](https://unsplash.com/@mbaumi?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 照片由 [Mika Baumeister](https://unsplash.com/@mbaumi?utm_source=medium&utm_medium=referral)
    提供，来源于 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: To begin with, we need to import the essential modules by utilizing Rust’s remarkable
    feature of selectively importing necessary components. The following code snippet
    accomplishes such a task with ease.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要通过利用 Rust 出色的特性，选择性地导入必要的组件来导入必需的模块。以下代码片段轻松完成了这一任务。
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that we have everything set up, it’s time to take charge and handle our
    dataset with precision and effectiveness. Thanks to the comprehensive tools provided
    by `polars`, working on data have never been easier; all necessary components
    are included in its `prelude` which can be imported seamlessly using a single
    line of code. Let us begin by importing and processing our data through this powerful
    tool!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们一切就绪，时机已到，掌控数据集并以精准有效的方式处理它。得益于 `polars` 提供的全面工具，处理数据从未如此轻松；所有必要的组件都包含在其
    `prelude` 中，可以通过一行代码无缝导入。让我们通过这个强大的工具开始导入和处理数据吧！
- en: Loading a CSV file into Data Frame
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 CSV 文件加载到数据框中
- en: '![](../Images/fa8f1969ea89dc654520e7fb1810fd61.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/fa8f1969ea89dc654520e7fb1810fd61.png)'
- en: Photo by [Markus Spiske](https://unsplash.com/@markusspiske?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 照片由 [Markus Spiske](https://unsplash.com/@markusspiske?utm_source=medium&utm_medium=referral)
    提供，来源于 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: 'Let’s dive into the process of loading our CSV file into Polars’ DataFrame
    through the following snippet of code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下代码片段深入了解将 CSV 文件加载到 Polars 的 DataFrame 的过程：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The code first defines a function `**read_data_frame_from_csv**` that takes
    in the `**CSV**` file path and returns a `**DataFrame**`. The code creates a `**CsvReader**`object
    within this function using the `**from_path**` method. It then checks if the file
    exists and has a header using `**expect**` and `**has_header**`, respectively.
    Finally, it loads the `**CSV**` file using the finish and returns the resulting
    `**DataFrame**`, which is unwrapped from a `**PolarsResult**`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先定义了一个函数 `**read_data_frame_from_csv**`，它接受 `**CSV**` 文件路径并返回一个 `**DataFrame**`。代码在该函数中创建了一个
    `**CsvReader**` 对象，使用 `**from_path**` 方法。然后，它使用 `**expect**` 和 `**has_header**`
    分别检查文件是否存在和是否有标题。最后，它使用 finish 加载 `**CSV**` 文件并返回结果 `**DataFrame**`，该 `**DataFrame**`
    从 `**PolarsResult**` 中解包。
- en: This code can effortlessly load our `**CSV**` dataset into a `**Polars**` `**DataFrame**`
    and begin our exploratory data analysis.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以轻松地将我们的 `**CSV**` 数据集加载到 `**Polars**` `**DataFrame**` 中，并开始我们的探索性数据分析。
- en: Dataset Dimensions
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据集维度
- en: '![](../Images/1105b0e3d44cf32700bcdaf624b33420.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1105b0e3d44cf32700bcdaf624b33420.png)'
- en: Photo by [Lewis Guapo](https://unsplash.com/@lewisguapo?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[Lewis Guapo](https://unsplash.com/@lewisguapo?utm_source=medium&utm_medium=referral)
    通过 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral) 提供的照片'
- en: Once we have loaded it into a `**DataFrame**`, we can utilize the `**shape()**`
    method to promptly obtain information about its rows and columns. This enables
    us to determine the number of samples (`**rows**`) and features (`**columns**`),
    which is a basis for further investigation and modeling.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将其加载到 `**DataFrame**` 中，我们可以利用 `**shape()**` 方法迅速获得关于行和列的信息。这使我们能够确定样本的数量（`**rows**`）和特征（`**columns**`），这是进一步研究和建模的基础。
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We can see that it’s returned a tuple, where the ﬁrst element indicates the
    number of rows and the second element indicates the number of columns. If you
    have prior knowledge of the dataset, this may be a good indicator of whether your
    dataset has loaded correctly. This information will be helpful later when we’re
    initializing a new array.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到它返回了一个元组，其中第一个元素表示行数，第二个元素表示列数。如果你对数据集有先验知识，这可能是一个很好的指示，说明你的数据集是否正确加载。这些信息在我们初始化新数组时将会很有帮助。
- en: Head
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 头部
- en: '**Statement:**'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明：**'
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Output:**'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tail
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尾部
- en: '**Statement:**'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明：**'
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Output:**'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Describe
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: '**Statement:**'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明：**'
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Output:**'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Columns
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列
- en: '**Statement:**'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明：**'
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Output:**'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Drop Species Column
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除物种列
- en: '**Statement:**'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明：**'
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Output:**'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Max
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最大
- en: '**Statement:**'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明：**'
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Output:**'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Convert To ndarray
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换为 ndarray
- en: '**Statement**'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明**'
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Output:**'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the following sections, we will explore the `**ndarray**` crate and use its
    different methods on our dataset.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将深入探讨 `**ndarray**` crate 并在我们的数据集上使用其不同的方法。
- en: Numpy Equivalent
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Numpy 等效
- en: '![](../Images/ee98cf79a28850ddfe0146668498d39a.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ee98cf79a28850ddfe0146668498d39a.png)'
- en: Photo by [Nick Hillier](https://unsplash.com/@nhillier?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[Nick Hillier](https://unsplash.com/@nhillier?utm_source=medium&utm_medium=referral)
    通过 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral) 提供的照片'
- en: In Rust, there is a robust crate, or a package as you call it in Python, equivalent
    to `**Numpy**` that allows us to store and manipulate data easily. It is called
    `**ndarray**` and provides a multidimensional container containing categorical
    or numerical elements.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，有一个强大的 crate，或你在 Python 中称之为包，相当于 `**Numpy**`，它允许我们轻松存储和操控数据。它叫做 `**ndarray**`，提供了一个多维容器，包含分类或数值元素。
- en: It’s worth noting that in Rust, packages are called crates based on the registry
    name in which the package is stored. The `**ndarray**` crate can be found on [**crate.io**](https://crates.io/crates/ndarray),
    similar to **Pypi** in Python.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在 Rust 中，包被称为 crates，这取决于存储包的注册表名称。`**ndarray**` crate 可以在 [**crate.io**](https://crates.io/crates/ndarray)
    上找到，类似于 Python 中的 **Pypi**。
- en: With `**ndarray**`, we can create n-dimensional arrays, perform slicing and
    views, conduct mathematical operations, and more. These features will be essential
    when we load our datasets into containers that we can operate on and conduct our
    analysis.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `**ndarray**`，我们可以创建 n 维数组，进行切片和视图，进行数学运算等。这些功能在我们将数据集加载到可以操作的容器并进行分析时将是必不可少的。
- en: Shared Similarities
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享相似性
- en: '![](../Images/50dc303d754d9eb34361df8abb5d2cfd.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/50dc303d754d9eb34361df8abb5d2cfd.png)'
- en: Photo by [Jonny Clow](https://unsplash.com/ja/@jonnyclow?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[Jonny Clow](https://unsplash.com/ja/@jonnyclow?utm_source=medium&utm_medium=referral)在[Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)上的照片'
- en: The `[**ArrayBase**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html)`
    type from the `**ndarray**` crate is an essential tool for data manipulation in
    Rust, equipped with plenty of powerful features. It shares similarities with `**NumPy’s**`
    array type, the `**numpy.ndarray**`, in its particular element type, limitless
    dimensions, and arbitrary strides. If you want to work with large amounts of data
    with unparalleled efficiency, `**ndarray**` is the way to go.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 来自`**ndarray**` crate的`[**ArrayBase**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html)`类型是Rust中数据操作的一个重要工具，配备了许多强大的功能。它在特定元素类型、无限维度和任意步幅方面与`**NumPy**`的数组类型`**numpy.ndarray**`类似。如果你希望以无与伦比的效率处理大量数据，`**ndarray**`是最佳选择。
- en: One cannot overstate the fundamental likeness shared by `**ndarray**` and `**NumPy**`’s
    array type; that is the initiation of indexing from zero, not one. Do not underestimate
    the magnitude of this seemingly trivial characteristic, as it can have a considerable
    impact when manipulating extensive datasets.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 不能过分强调`**ndarray**`和`**NumPy**`数组类型之间的根本相似性；即从零开始的索引，而非从一开始。不要低估这个看似微不足道的特性，因为它在处理大型数据集时可能会产生显著影响。
- en: 'Let us not overlook another significant similarity: the default memory layout
    of `**ndarray**` and `**NumPy**`’s array type, which is row-major. In other words,
    the default iterators follow the logical order of rows. This feature is precious
    when dealing with arrays surpassing memory capacity and cannot be loaded entirely
    simultaneously.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的相似点是`**ndarray**`和`**NumPy**`数组类型的默认内存布局，即行优先。换句话说，默认迭代器遵循行的逻辑顺序。这个特性在处理超出内存容量且无法同时完全加载的数组时非常宝贵。
- en: Arithmetic operators operate on each element individually in both `**ndarray**`
    and `**NumPy**`’s array types. In simpler terms, performing `**a * b**` leads
    to element-wise multiplication, not matrix multiplication. The beauty of this
    functionality is that one can effortlessly execute computations on relatively
    large arrays.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 算术运算符在`**ndarray**`和`**NumPy**`的数组类型中分别作用于每个元素。简单来说，执行`**a * b**`会进行逐元素相乘，而不是矩阵乘法。这一功能的优点在于可以轻松地对相对较大的数组进行计算。
- en: Owned arrays are contiguous in memory in both `**ndarray**` and `**NumPy**`’s
    array type. This means that they are stored in a single block of memory, which
    can improve performance when accessing elements of the array.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`**ndarray**`和`**NumPy**`的数组类型中的拥有数组在内存中是连续的。这意味着它们存储在一个单独的内存块中，这可以提高访问数组元素时的性能。'
- en: Many operations, such as slicing and arithmetic operations, are also supported
    by both `**ndarray**` and `**NumPy**`’s array type. This makes switching between
    the two array types easy, depending on your needs.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 许多操作，如切片和算术运算，也被`**ndarray**`和`**NumPy**`的数组类型所支持。这使得根据需要在这两种数组类型之间切换变得简单。
- en: Efficiently performing operations is a crucial aspect that significantly affects
    processing time and resource usage in the computational data manipulation domain.
    Slicing, one such operation, is an excellent example due to its low cost — returning
    only a view of an array instead of duplicating the entire dataset.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 高效执行操作是计算数据处理领域中显著影响处理时间和资源使用的关键方面。切片就是一个很好的例子，因为它的成本很低——只返回数组的视图，而不是重复整个数据集。
- en: When writing this article, some essential functionalities in `**NumPy**` cannot
    be found within `**ndarray**`. In particular, when it comes to binary operations
    involving broadcasting functionality between left-hand and right-hand arrays simultaneously,
    this capability can only currently be achieved using `**numpy**` rather than through
    `**ndarray**` alone.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，`**ndarray**`中缺少一些`**NumPy**`的重要功能。特别是，当涉及到左侧和右侧数组同时进行广播功能的二进制操作时，这一能力目前只能通过`**numpy**`实现，而不是仅通过`**ndarray**`。
- en: Key Differences
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主要区别
- en: '![](../Images/6072cc3586e2d46dc3f9ea34377afca3.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6072cc3586e2d46dc3f9ea34377afca3.png)'
- en: Photo by [Eric Prouzet](https://unsplash.com/@eprouzet?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由[Eric Prouzet](https://unsplash.com/@eprouzet?utm_source=medium&utm_medium=referral)拍摄，来源于[Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: There are many critical differences between `**Numpy**` and `**ndarray**`. For
    one, In `**NumPy**`, there is no distinction between owned arrays, views, and
    mutable views. Multiple arrays (instances of `**numpy. ndarray**`) can mutably
    reference the same data. On the other hand, In ndarray, all arrays are instances
    of `**ArrayBase**`, but `**ArrayBase**` is generic over the ownership of the data.
    Array owns its data; `**ArrayView**` is a view; `**ArrayViewMut**` is a mutable
    view; `**CowArray**` either owns its data or is a view (with copy-on-write mutation
    of the view variant); and `**ArcArray**` has a reference-counted pointer to its
    data (with copy-on-write mutation). Arrays and views follow Rust’s aliasing rules.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`**Numpy**`和`**ndarray**`之间有许多关键差异。例如，在`**NumPy**`中，没有对拥有的数组、视图和可变视图的区分。多个数组（`**numpy.
    ndarray**`的实例）可以可变地引用相同的数据。另一方面，在ndarray中，所有数组都是`**ArrayBase**`的实例，但`**ArrayBase**`是对数据所有权的泛型。Array拥有其数据；`**ArrayView**`是一个视图；`**ArrayViewMut**`是一个可变视图；`**CowArray**`要么拥有其数据，要么是视图（带有视图变体的写时复制变更）；`**ArcArray**`有一个对其数据的引用计数指针（带有写时复制变更）。数组和视图遵循Rust的别名规则。'
- en: Another essential feature of `**NumPy**` is that all arrays are flexible in
    dimensions. However, with `**ndarray**`, you can create fixed-dimension arrays
    like Array2, which allows for more accurate results and eliminates unnecessary
    heap allocations related to shape and strides.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`**NumPy**`的另一个重要特性是所有数组的维度是灵活的。然而，使用`**ndarray**`，你可以创建像Array2这样的固定维度数组，这可以提供更准确的结果，并消除与形状和步幅相关的多余堆分配。'
- en: Finally, When slicing in `**NumPy**`, the indices start, `**start + step, start
    + 2 * step, …**` until the end (exclusive). When slicing in `**ndarray**`, the
    axis is first sliced with a start..end. Then if the step is positive, the first
    index is the front of the slice; if the step is negative, the first index is the
    back of the slice. This means the behavior is the same as `**NumPy**` except when
    `**step < -1**`. Refer to the docs for [**the s! macro**](https://docs.rs/ndarray/latest/ndarray/macro.s.html)
    for more details.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当在`**NumPy**`中进行切片时，索引从`**start + step, start + 2 * step, …**`开始，一直到结束（不包括结束）。在`**ndarray**`中，首先对轴进行`start..end`切片。如果步长为正，则第一个索引是切片的前端；如果步长为负，则第一个索引是切片的后端。这意味着，行为与`**NumPy**`相同，除非`**step
    < -1**`。有关更多详细信息，请参阅[**s!宏**](https://docs.rs/ndarray/latest/ndarray/macro.s.html)的文档。
- en: Why ndarray?
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么选择ndarray？
- en: For seasoned Rust developers, the argument could be made that the language already
    has an array of data structures, such as vectors, rendering the need for a third-party
    crate to handle data. However, this assertion fails to recognize the specialized
    nature of `**ndarray**`, designed to handle n-dimensional arrays with a mathematical
    focus.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于经验丰富的Rust开发者，可以提出这样一个观点，即语言已经拥有了许多数据结构，例如向量，因此不需要第三方库来处理数据。然而，这一论断未能认识到`**ndarray**`的专门性质，它旨在处理具有数学重点的n维数组。
- en: Rust is undoubtedly a strong programming language that can tackle diverse coding
    challenges effortlessly. However, regarding complex operations on multidimensional
    arrays, `**ndarray**` is the ultimate solution. Its specialized design enables
    the seamless execution of advanced data manipulation tasks in scientific computing
    and analytical contexts, making it an essential tool for any programmer seeking
    optimal results.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Rust无疑是一种强大的编程语言，可以轻松应对各种编程挑战。然而，对于多维数组的复杂操作，`**ndarray**`是终极解决方案。它的专门设计使得在科学计算和分析环境中能够无缝执行高级数据操作任务，使其成为任何寻求最佳结果的程序员的必备工具。
- en: To illustrate this point, consider an example where a researcher needs to manipulate
    a large amount of multidimensional data from a scientific experiment. Rust’s built-in
    data structures, such as [**vectors**](https://doc.rust-lang.org/rust-by-example/std/vec.html),
    may not be optimal for this task, as they lack the advanced features necessary
    for complex array manipulations. In contrast, `**ndarray**` provides an extensive
    range of functionalities, including slicing, broadcasting, and element-wise operations,
    that can simplify and expedite data manipulation tasks when analyzing data, as
    we will explore in the following sections.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，考虑一个例子，其中研究人员需要操作来自科学实验的大量多维数据。Rust的内置数据结构，如[**向量**](https://doc.rust-lang.org/rust-by-example/std/vec.html)，可能不适合这一任务，因为它们缺乏复杂数组操作所需的高级特性。相比之下，`**ndarray**`提供了广泛的功能，包括切片、广播和逐元素操作，可以在分析数据时简化和加速数据操作任务，正如我们将在以下部分中探索的那样。
- en: '**Array creation**'
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**数组创建**'
- en: This section provides plenty of techniques for creating arrays from scratch,
    enabling users to generate arrays tailored to their specific needs. However, it
    is worth noting that there are other means of creating arrays beyond this section.
    For example, arrays can also be generated by performing arithmetic operations
    on pre-existing arrays.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了许多从头创建数组的技巧，使用户能够生成适合其特定需求的数组。然而，值得注意的是，除了本节之外，还有其他创建数组的方法。例如，通过对现有数组执行算术运算，也可以生成数组。
- en: 'Now, let’s explore the different functionalities provided by `**ndarray**`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索`**ndarray**`提供的不同功能：
- en: '**2rows × 3columns** Floating Point Array Literal:'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2行 × 3列** 浮点数组字面量：'
- en: '[PRE27]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**1-D Range** Of Values:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1-D范围** 的值：'
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`**1-D array**` with n elements within a range:'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**1-D数组**`，范围内的n个元素：'
- en: '[PRE29]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**3×4×5** Ones Array:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3×4×5** 的数组：'
- en: '[PRE30]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**3×4×5** Zeros Array:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3×4×5** 的零数组：'
- en: '[PRE31]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**3×3** Identity Matrix:'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3×3** 单位矩阵：'
- en: '[PRE32]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Indexing and slicing
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 索引和切片
- en: 'Last Element:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个元素：
- en: '[PRE33]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Row 1, Column 4:'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第1行，第4列：
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'First 5 rows:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前5行：
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Last 5 rows:'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后5行：
- en: '[PRE36]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Mathematics
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数学
- en: 'Sum:'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 求和：
- en: '[PRE37]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Sum Along Axis:'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沿轴求和：
- en: '[PRE38]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Mean:'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平均值：
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Transpose:'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转置：
- en: '[PRE40]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**2-D matrix** multiply:'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2-D矩阵** 乘法：'
- en: '[PRE41]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Square Root:'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平方根：
- en: '[PRE42]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Arithmetic:'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术：
- en: '[PRE43]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In this section, we have explored various functionalities that `**ndarray**`
    provides; A robust tool that works on multidimensional containers and provides
    an array of functions for streamlined data handling. Our exploration has encompassed
    critical elements in utilizing `**ndarray**`: creating arrays, determining their
    dimensions, accessing them via indexing techniques, and executing basic mathematical
    operations efficiently.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探索了`**ndarray**`提供的各种功能；这是一个强大的工具，适用于多维容器，并提供了一系列用于简化数据处理的功能。我们的探索涵盖了使用`**ndarray**`的关键要素：创建数组、确定数组维度、通过索引技术访问数组以及高效执行基本数学操作。
- en: To sum up, `**ndarray**` is a valuable asset for developers and data analysts.
    It offers plenty of methods that efficiently handle multidimensional arrays with
    ease and accuracy. By mastering the techniques discussed in this section and harnessing
    the potential of `**ndarray**`, users can carry out complex data processing tasks
    effortlessly while generating faster yet precise insights based on their findings.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`**ndarray**`是开发人员和数据分析师的宝贵资产。它提供了许多方法，能够高效地处理多维数组，既方便又准确。通过掌握本节讨论的技巧，并利用`**ndarray**`的潜力，用户可以轻松执行复杂的数据处理任务，同时根据其发现生成更快速且准确的见解。
- en: Plotters
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Plotters
- en: '![](../Images/184bc187368b06488376fef7750a8546.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/184bc187368b06488376fef7750a8546.png)'
- en: Photo by [Lukas Blazek](https://unsplash.com/@goumbik?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 由[Lukas Blazek](https://unsplash.com/@goumbik?utm_source=medium&utm_medium=referral)拍摄，来源于[Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: Having processed and manipulated our data using `**ndarray**`, the next logical
    step is to gain valuable insights by visualizing it using the `[**Plotters**](https://docs.rs/plotters/latest/plotters/)`
    library. This powerful library enables us to create stunning and informative visualizations
    of our data with ease and precision.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`**ndarray**`处理和操作数据之后，下一步逻辑是通过使用`[**Plotters**](https://docs.rs/plotters/latest/plotters/)`库来获得有价值的见解。这个强大的库使我们能够轻松而精准地创建令人惊叹且信息丰富的数据可视化。
- en: 'To make the most of the Plotters library alongside `**jupyter-evcxr**`, it
    is necessary to import it beforehand by executing the following command:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用`**jupyter-evcxr**`和Plotters库，需要在执行以下命令之前先导入它：
- en: '[PRE44]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As `**evcxr**` solely relies on SVG images and supports all series types, there
    is no need for any additional backend. Therefore, it would be great to incorporate
    its usage into our system using the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`**evcxr**`仅依赖于SVG图像并支持所有系列类型，因此不需要额外的后端。因此，将其用法融入我们的系统中是非常好的，使用如下：
- en: '[PRE45]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: After importing the library, we can utilize its extensive visualization tools
    to craft captivating and enlightening visuals such as graphs, charts, and other
    forms. With these visualizations in place, we can easily detect patterns, trends,
    or insights. This enables data-based decision-making, which yields valuable results.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入库之后，我们可以利用其丰富的可视化工具来制作引人注目且富有启发性的视觉效果，如图表、图形和其他形式。通过这些可视化，我们可以轻松地检测模式、趋势或洞察力。这使得基于数据的决策成为可能，从而产生有价值的结果。
- en: Let’s first start by drawing a scatter plot of the sepal features.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们开始绘制花萼特征的散点图。
- en: Scatter Plot
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 散点图
- en: 'Let’s divide the scatter plot code into chunks for easier reading. Take the
    following as an instance:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将散点图代码分成几个部分以便于阅读。以下是一个示例：
- en: '[PRE46]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This code block creates a vector of tuples called `**sepal_samples**`, where
    each tuple represents a sample of sepal length and sepal width measurements from
    the iris dataset. Now, Let’s go over what each line of the code does:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个名为`**sepal_samples**`的元组向量，其中每个元组表示来自鸢尾花数据集的花萼长度和花萼宽度的样本。现在，让我们逐行分析代码的功能：
- en: '`**let sepal_samples: Vec<(f64,f64)> = {…}**`: A variable named `**sepal_samples**`
    is defined and assigned a code block enclosed in curly brackets `**{…}**`. The
    `**Vec<(f64,f64)>**` datatype annotation indicates that the vector contains tuples
    consisting of two **64-bit** floating-point numbers. This declaration empowers
    Rust to effectively identify and handle each tuple within the given dataset.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**let sepal_samples: Vec<(f64,f64)> = {…}**`：定义了一个名为`**sepal_samples**`的变量，并将一个用大括号`**{…}**`括起来的代码块赋值给它。`**Vec<(f64,f64)>**`数据类型注释表明该向量包含由两个**64位**浮点数组成的元组。这一声明使Rust能够有效地识别和处理数据集中每个元组。'
- en: '`**let sepal_length_cm: DataFrame = iris_df.select(vec![“SepalLengthCm”]).unwrap();**`:
    To extract the **SepalLengthCm** column from the **iris_df** DataFrame, we utilize
    a `**select**` function and store it in a new `**DataFrame**` object named `**sepal_length_cm**`.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**let sepal_length_cm: DataFrame = iris_df.select(vec![“SepalLengthCm”]).unwrap();**`：为了从`**iris_df**`
    DataFrame中提取`**SepalLengthCm**`列，我们使用`**select**`函数，并将其存储在一个名为`**sepal_length_cm**`的新`**DataFrame**`对象中。'
- en: '`**let mut sepal_length = sepal_length_cm.to_ndarray::<Float64Type>().unwrap().into_raw_vec().into_iter();**`:
    With the `**to_ndarray**` method, we can transform the `**DataFrame**` object
    for `**sepal_length_cm**` into a `**ndarray**` of type `**Float64Type**`. From
    there, using the `**into_raw_vec**` method allows us to convert this new array
    into a raw vector format. By calling upon the iterator generated from running
    through our now-raw vector with `**into_iter**`, we can consume and utilize each
    element in turn; exciting stuff!'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**let mut sepal_length = sepal_length_cm.to_ndarray::<Float64Type>().unwrap().into_raw_vec().into_iter();**`：通过`**to_ndarray**`方法，我们可以将`**sepal_length_cm**`的`**DataFrame**`对象转换为`**Float64Type**`类型的`**ndarray**`。接着，使用`**into_raw_vec**`方法可以将这个新数组转换为原始向量格式。通过调用`**into_iter**`生成的迭代器，我们可以逐个消费和利用每个元素；这非常有趣！'
- en: '`**let sepal_width_cm: DataFrame = iris_df.select(vec![“SepalWidthCm”]).unwrap();**`:
    selects the `**SepalWidthCm**` column from the `**iris_df**` DataFrame and stores
    the resulting `**DataFrame**` object in a new variable called `**sepal_width_cm**`.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**let sepal_width_cm: DataFrame = iris_df.select(vec![“SepalWidthCm”]).unwrap();**`：从`**iris_df**`
    DataFrame中选择`**SepalWidthCm**`列，并将结果存储在一个名为`**sepal_width_cm**`的新`**DataFrame**`对象中。'
- en: '`**let mut sepal_width = sepal_width_cm.to_ndarray::<Float64Type>().unwrap().into_raw_vec().into_iter();**`:
    With the `**to_ndarray**` method, the `**DataFrame**` object named `**sepal_width_cm**`
    is converted into a `**ndarray**` object with a data type of `**Float64Type**`.
    The resulting `**ndarray**` is then transformed into a raw vector through the
    application of `**into_raw_vec**` and finally generates an iterator that can be
    utilized for consuming its elements by calling on it via `**.into_iter()**`.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**let mut sepal_width = sepal_width_cm.to_ndarray::<Float64Type>().unwrap().into_raw_vec().into_iter();**`：通过`**to_ndarray**`方法，将名为`**sepal_width_cm**`的`**DataFrame**`对象转换为数据类型为`**Float64Type**`的`**ndarray**`对象。然后，通过应用`**into_raw_vec**`将结果`**ndarray**`转换为原始向量，最终通过调用`**.into_iter()**`生成一个迭代器，以便逐个消费其元素。'
- en: '`**sepal_width.zip(sepal_length).collect()**`: A new iterator is generated
    by invoking the `**zip**` function on `**sepal_width**`, with `**sepal_length**`
    passed as an argument. The resulting iterator yields tuples, each comprising one
    element from sepal width and another from sepal length. These tuples are then
    gathered using the collect method to form a new vector — a type `**Vec<(f64,f64)>**`-
    stored in a variable named `**sepal_samples**`.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**sepal_width.zip(sepal_length).collect()**`：通过对`**sepal_width**`调用`**zip**`函数，并将`**sepal_length**`作为参数传递，生成一个新的迭代器。该迭代器产生包含一个萼片宽度元素和一个萼片长度元素的元组。这些元组随后使用`collect`方法收集，形成一个新向量——类型为`**Vec<(f64,f64)>**`——并存储在名为`**sepal_samples**`的变量中。'
- en: 'The following code block looks like the next:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块看起来如下：
- en: '[PRE47]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`**evcxr_figure((640, 480), |root| {**`: A new Evcxr figure is initiated with
    dimensions of 640 pixels in width and 480 pixels in height. Additionally, a closure
    that accepts the root parameter which signifies the fundamental drawing region
    of the declared figure is also passed along.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**evcxr_figure((640, 480), |root| {**`：使用640像素宽和480像素高的尺寸初始化了一个新的Evcxr图形。此外，还传递了一个接受根参数的闭包，该参数表示声明图形的基本绘图区域。'
- en: '`**let mut chart = ChartBuilder::on(&root)**`: This creates a new chart builder
    object using the root drawing area as the base.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**let mut chart = ChartBuilder::on(&root)**`：这使用根绘图区域作为基础创建了一个新的图表构建对象。'
- en: '`**.caption(“Iris Dataset”, (“Arial”, 30).into_font())**`: This adds a caption
    to the chart with the text `**Iris Dataset**` and a font `**Arial**` with a size
    of `**30**`.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**.caption(“Iris Dataset”, (“Arial”, 30).into_font())**`：这为图表添加了标题，文本为`**Iris
    Dataset**`，字体为`**Arial**`，大小为`**30**`。'
- en: '`**.x_label_area_size(40)**`: This sets the size of the `**X-axis**` label
    area to `**40**` pixels.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**.x_label_area_size(40)**`：这将`**X轴**`标签区域的大小设置为`**40**`像素。'
- en: '`**.y_label_area_size(40)**`: This sets the size of the `**Y-axis**` label
    area to `**40**` pixels.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**.y_label_area_size(40)**`：这将`**Y轴**`标签区域的大小设置为`**40**`像素。'
- en: '`**.build_cartesian_2d(1f64..5f64, 3f64..9f64)?;**`: This line of code builds
    a 2D Cartesian chart with the `**X-axis**` ranging from `**1 to 5**` and the `**Y-axis**`
    ranging from `**3 to 9**`, and returns a Result type which is unwrapped with the
    `**?**` operator.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**.build_cartesian_2d(1f64..5f64, 3f64..9f64)?;**`：这一行代码构建了一个2D笛卡尔图表，`**X轴**`的范围从`**1到5**`，`**Y轴**`的范围从`**3到9**`，并返回一个`Result`类型，该类型用`**?**`运算符进行解包。'
- en: '`**chart.configure_mesh()**`: This configures the chart’s mesh, which is the
    grid lines and ticks of the chart'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**chart.configure_mesh()**`：这配置了图表的网格，即图表的网格线和刻度线。'
- en: '`**.x_desc(“Sepal Length (cm)”)**`: This sets the `**X-axis**` description
    to `**Sepal Length (cm)**`.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**.x_desc(“Sepal Length (cm)”)**`：这将`**X轴**`的描述设置为`**Sepal Length (cm)**`。'
- en: '`**.y_desc(“Sepal Width (cm)”)**`: This sets the `**Y-axis**` description to
    `**Sepal Width (cm)**`.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**.y_desc(“Sepal Width (cm)”)**`：这将`**Y轴**`的描述设置为`**Sepal Width (cm)**`。'
- en: '`**.draw()?;**`: This draws the mesh and returns a Result type which is unwrapped
    with the `**?**`operator.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**.draw()?;**`：这绘制了网格并返回一个`Result`类型，该类型用`**?**`运算符进行解包。'
- en: '`**chart.draw_series(sepal_samples.iter().map(|(x, y)| Circle::new((*x,*y),
    3, BLUE.filled())));**`: Using the `**sepal_samples**` vector as input, a sequence
    of data points is plotted on the chart. The `**iter()**` function is invoked to
    iterate over each element in `**sepal_samples**` and `**map()**` methods creates
    an iterator that transforms every point into a `**Circle**` object with blue fill
    color and radius 3\. Finally, this series of Circle objects are passed onto `**chart.draw_series()**`,
    which renders them beautifully onto the graph canvas.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**chart.draw_series(sepal_samples.iter().map(|(x, y)| Circle::new((*x,*y),
    3, BLUE.filled())));**`：使用`**sepal_samples**`向量作为输入，在图表上绘制了一系列数据点。调用`**iter()**`函数以遍历`**sepal_samples**`中的每个元素，并使用`**map()**`方法创建一个迭代器，将每个点转换为一个填充蓝色且半径为3的`**Circle**`对象。最后，将这些`Circle`对象的系列传递给`**chart.draw_series()**`，将它们美丽地呈现在图表画布上。'
- en: 'Running the above code chunks will result in the following being drawn in your
    notebook:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码块将在你的笔记本中绘制以下内容：
- en: '![](../Images/e1281a8fc0052b6b1f757cbd2c3b952e.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e1281a8fc0052b6b1f757cbd2c3b952e.png)'
- en: Iris dataset Sepal scatter plot (Image by author)
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Iris 数据集萼片散点图（图片来源：作者）
- en: Conclusion
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: '![](../Images/52ec672772fd60552bccf21434500155.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/52ec672772fd60552bccf21434500155.png)'
- en: Photo by [Aaron Burden](https://unsplash.com/it/@aaronburden?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由[Aaron Burden](https://unsplash.com/it/@aaronburden?utm_source=medium&utm_medium=referral)拍摄，来源于[Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: Throughout this article, we have delved into three tools in Rust and applied
    them to analyze data from the iris dataset. Our findings reveal that Rust is a
    robust language with immense potential for executing data science projects effortlessly.
    Although not as prevalent as Python or R, its capabilities make it an excellent
    option for individuals seeking to significantly elevate their data science endeavors.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们深入探讨了Rust中的三个工具，并应用它们来分析鸢尾花数据集的数据。我们的发现表明，Rust 是一种强大的语言，具有巨大的潜力，可以轻松执行数据科学项目。尽管它的普及程度不及
    Python 或 R，但其能力使其成为那些希望显著提升数据科学工作的人的绝佳选择。
- en: It has been confirmed that Rust is a fast and efficient language, with its type
    system that makes debugging relatively easy. Furthermore, numerous libraries and
    frameworks are tailored to data science tasks available in Rust, like `[**Polars**](https://docs.rs/polars/latest/polars/)`
    and `[**ndarray**](https://docs.rs/ndarray/latest/ndarray/)`, which enable the
    seamless handling of massive datasets.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 已确认 Rust 是一种快速高效的语言，其类型系统使调试相对容易。此外，Rust 中有许多专门针对数据科学任务的库和框架，例如 `[**Polars**](https://docs.rs/polars/latest/polars/)`
    和 `[**ndarray**](https://docs.rs/ndarray/latest/ndarray/)`，它们能够无缝处理大量数据集。
- en: Overall, Rust is an exceptional programming language for data science projects
    as it provides remarkable performance and is relatively easy to manage complex
    datasets. Aspiring developers in data science must consider Rust among their choices
    to embark on a successful journey in this domain.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，Rust 是一个出色的编程语言，适合数据科学项目，因为它提供了卓越的性能，并且相对容易管理复杂的数据集。数据科学领域的有志开发者应考虑将 Rust
    作为他们的选择之一，以便在这一领域开启成功的旅程。
- en: Closing Note
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结束语
- en: As we conclude this tutorial, I would like to express my sincere appreciation
    to all those who have dedicated their time and energy to completing it. It has
    been an absolute pleasure to demonstrate the extraordinary capabilities of Rust
    programming language with you.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本教程时，我想对所有那些投入时间和精力完成本教程的人表示诚挚的感谢。能够与你们一起展示Rust编程语言的卓越能力，我感到非常高兴。
- en: Being passionate about data science, I promise you that I am going to write
    at least one comprehensive article every week or so on related topics from now
    on. If staying updated with my work interests you, consider connecting with me
    on various social media platforms or reach out directly if anything else needs
    assistance.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 对数据科学充满热情的我承诺，从现在开始，我每周至少会写一篇关于相关主题的综合性文章。如果你对我的工作感兴趣，考虑通过各种社交媒体平台与我联系，或者直接联系我寻求其他帮助。
- en: Thank You!
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢！
- en: References
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[1] Queue the Hardening Enhancements. (2019, May 09). In Google Security Blog.
    [https://security.googleblog.com/2019/05/queue-hardening-enhancements.html](https://security.googleblog.com/2019/05/queue-hardening-enhancements.html)'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 队列的硬化增强。 (2019年5月9日)。发表于 Google 安全博客。[https://security.googleblog.com/2019/05/queue-hardening-enhancements.html](https://security.googleblog.com/2019/05/queue-hardening-enhancements.html)'
- en: '[2] A brief history of Rust at Facebook. (2021, April 29). In Engineering.fb
    Blog. [https://engineering.fb.com/2021/04/29/developer-tools/rust](https://engineering.fb.com/2021/04/29/developer-tools/rust)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[2] Rust 在 Facebook 的简要历史。 (2021年4月29日)。发表于 Engineering.fb 博客。[https://engineering.fb.com/2021/04/29/developer-tools/rust](https://engineering.fb.com/2021/04/29/developer-tools/rust)'
- en: '[3] Linux 6.1 Officially Adds Support for Rust in the Kernel. (2022, Dec 20).
    In infoq.com. [https://www.infoq.com/news/2022/12/linux-6-1-rust](https://www.infoq.com/news/2022/12/linux-6-1-rust)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '[3] Linux 6.1 正式在内核中添加对 Rust 的支持。 (2022年12月20日)。发表于 infoq.com。[https://www.infoq.com/news/2022/12/linux-6-1-rust](https://www.infoq.com/news/2022/12/linux-6-1-rust)'
- en: '[4] Top Programming Languages 2022\. (2022, Aug 23). In spectrum.ieee.com [https://spectrum.ieee.org/top-programming-languages-2022](https://spectrum.ieee.org/top-programming-languages-2022)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '[4] 2022年顶级编程语言。 (2022年8月23日)。发表于 spectrum.ieee.com。[https://spectrum.ieee.org/top-programming-languages-2022](https://spectrum.ieee.org/top-programming-languages-2022)'
- en: '[5] Programming, scripting, and markup languages. (2022, May). In StackOverflow
    Developer Survey 2022\. [https://survey.stackoverflow.co/2022/#programming-scripting-and-markup-languages](https://survey.stackoverflow.co/2022/#programming-scripting-and-markup-languages)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '[5] 编程、脚本和标记语言。 (2022年5月)。发表于 StackOverflow 开发者调查 2022。[https://survey.stackoverflow.co/2022/#programming-scripting-and-markup-languages](https://survey.stackoverflow.co/2022/#programming-scripting-and-markup-languages)'
- en: '[6] We need a safer systems programming language. (2019, July 18). In Microsoft
    security response center blog. [https://msrc.microsoft.com/blog/2019/07/we-need-a-safer-systems-programming-language/](https://msrc.microsoft.com/blog/2019/07/we-need-a-safer-systems-programming-language/)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '[6] 我们需要一种更安全的系统编程语言。（2019年7月18日）。在Microsoft安全响应中心博客上。 [https://msrc.microsoft.com/blog/2019/07/we-need-a-safer-systems-programming-language/](https://msrc.microsoft.com/blog/2019/07/we-need-a-safer-systems-programming-language/)'
- en: '[7] Mozilla and Samsung Collaborate on Next Generation Web Browser Engine.
    (2013, April 3). In Mozilla blog. [https://blog.mozillarr.org/en/mozilla/mozilla-and-samsung-collaborate-on-next-generation-web-browser-engine/](https://blog.mozillarr.org/en/mozilla/mozilla-and-samsung-collaborate-on-next-generation-web-browser-engine/)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '[7] Mozilla和三星合作开发下一代网页浏览器引擎。（2013年4月3日）。在Mozilla博客上。 [https://blog.mozillarr.org/en/mozilla/mozilla-and-samsung-collaborate-on-next-generation-web-browser-engine/](https://blog.mozillarr.org/en/mozilla/mozilla-and-samsung-collaborate-on-next-generation-web-browser-engine/)'
- en: '[8] Mozilla lays off 250 employees due to the pandemic. (2020, Aug 11). In
    Engadget. [https://www.engadget.com/mozilla-firefox-250-employees-layoffs-151324924.html](https://www.engadget.com/mozilla-firefox-250-employees-layoffs-151324924.html)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '[8] 由于疫情，Mozilla裁员250人。（2020年8月11日）。在Engadget上。 [https://www.engadget.com/mozilla-firefox-250-employees-layoffs-151324924.html](https://www.engadget.com/mozilla-firefox-250-employees-layoffs-151324924.html)'
- en: '[9] How Pydantic V2 leverages Rust’s Superpowers. (2023, Feb 4 & 5). In fosdem.org.
    [https://fosdem.org/2023/schedule/event/rust_how_pydantic_v2_leverages_rusts_superpowers/](https://fosdem.org/2023/schedule/event/rust_how_pydantic_v2_leverages_rusts_superpowers/)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '[9] Pydantic V2如何利用Rust的超级力量。（2023年2月4日和5日）。在fosdem.org上。 [https://fosdem.org/2023/schedule/event/rust_how_pydantic_v2_leverages_rusts_superpowers/](https://fosdem.org/2023/schedule/event/rust_how_pydantic_v2_leverages_rusts_superpowers/)'
- en: '[10] pydantic-v2 Performance. (2022, Dec 23). In docs.pydantic.dev. [https://docs.pydantic.dev/blog/pydantic-v2/#performance](https://docs.pydantic.dev/blog/pydantic-v2/#performance)'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '[10] pydantic-v2 性能。（2022年12月23日）。在docs.pydantic.dev上。 [https://docs.pydantic.dev/blog/pydantic-v2/#performance](https://docs.pydantic.dev/blog/pydantic-v2/#performance)'
- en: '[11] BlueHat IL 2023 - David Weston-Default Security. (2023, Apr 19). On youtube.com.
    [https://www.youtube.com/watch?v=8T6ClX-y2AE&t=2703s](https://www.youtube.com/watch?v=8T6ClX-y2AE&t=2703s)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '[11] BlueHat IL 2023 - David Weston-默认安全。（2023年4月19日）。在youtube.com上。 [https://www.youtube.com/watch?v=8T6ClX-y2AE&t=2703s](https://www.youtube.com/watch?v=8T6ClX-y2AE&t=2703s)'
