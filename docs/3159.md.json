["```py\nhello = 'Hello world!'\n\nprint(hello.upper())\n# HELLO WORLD!\n```", "```py\nclass Person:\n\n    num_of_persons = 0\n\n    def __init__(self, name):\n        self.name = name\n\n    def shout(self):\n        print(f\"Hey! I'm {self.name}\")\n\np = Person('John')\np.shout()\n# Hey I'm John.\n\np.num_of_persons\n# 0\n\np.name\n# 'John'\n```", "```py\np.shout\n# <bound method Person.shout of <__main__.Person object at 0x1037d3a60>>\n\nid(p.shout)\n# 4363645248\n\nPerson.shout\n# <function __main__.Person.shout(self)>\n\nid(Person.shout)\n# 4364388816\n```", "```py\nclass Person:\n\n    num_of_persons = 0\n\n    def __init__(self, name):\n        self.name = name\n\n    def shout(self):\n        print(f\"Hey! I'm {self.name}.\")\n\np = Person('John')\n\nvars(p)\n# {'name': 'John'}\n\ndef shout_v2(self):\n    print(\"Hey, what's up?\")\n\np.shout_v2 = shout_v2\n\nvars(p)\n# {'name': 'John', 'shout_v2': <function __main__.shout_v2(self)>}\n\np.shout()\n# Hey, I'm John.\n\np.shout_v2()\n# TypeError: shout_v2() missing 1 required positional argument: 'self'\n```", "```py\nclass Person:\n\n    num_of_persons = 0\n\n    def __init__(self, name):\n        self.name = name\n\n    def shout(self):\n        print(f\"Hey! I'm {self.name}.\")\n\n    def __getattribute__(self, name):\n        print(f'getting the attribute name: {name}')\n        return super().__getattribute__(name)\n\n    def __getattr__(self, name):\n        print(f'this attribute doesn\\'t exist: {name}')\n        raise AttributeError()\n\np = Person('John')\n\np.name\n# getting the attribute name: name\n# 'John'\n\np.name1\n# getting the attribute name: name1\n# this attribute doesn't exist: name1\n#\n# ... exception stack trace\n# AttributeError:\n```", "```py\np.shout\n# <bound method Person.shout of <__main__.Person object at 0x1037d3a60>>\n\nPerson.shout\n# <function __main__.Person.shout(self)>\n```", "```py\ndef object_getattribute(obj, name):\n    \"Emulate PyObject_GenericGetAttr() in Objects/object.c\"\n    # Create vanilla object for later use.\n    null = object()\n\n    \"\"\"\n    obj is an object instantiated from our custom class. Here we try \n    to find the name of the class it was instantiated from.\n    \"\"\"\n    objtype = type(obj) \n\n    \"\"\"\n    name represents the name of the class function, instance attribute, \n    or any class attribute. Here, we try to find it and keep a \n    reference to it. MRO is short for Method Resolution Order, and it \n    has to do with class inheritance. Not really that important at \n    this point. Let's say that this mechanism optimally finds name\n    through all parent classes.\n    \"\"\"\n    cls_var = find_name_in_mro(objtype, name, null)\n\n    \"\"\"\n    Here we check if this class attribute is an object that has the \n    __get__ method implemented. If it does,  it is a non-data \n    descriptor. This is important for further steps.\n    \"\"\"\n    descr_get = getattr(type(cls_var), '__get__', null)\n\n    \"\"\"\n    So now it's either our class attribute references a descriptor, in\n    which case we test to see if it is a data descriptor and we \n    return reference to the descriptor's __get__ method, or we go to \n    the next if code block.\n    \"\"\"\n    if descr_get is not null:\n        if (hasattr(type(cls_var), '__set__')\n            or hasattr(type(cls_var), '__delete__')):\n            return descr_get(cls_var, obj, objtype)  # data descriptor\n\n    \"\"\"\n    In cases where the name doesn't reference a data descriptor, we \n    check to see if it references the variable in the object's \n    dictionary, and if so, we return its value.\n    \"\"\"\n    if hasattr(obj, '__dict__') and name in vars(obj):\n        return vars(obj)[name]  # instance variable\n\n    \"\"\"\n    In cases where the name does not reference the variable in the \n    object's dictionary, we try to see if it references a non-data \n    descriptor and return a reference to it.    \n    \"\"\"\n    if descr_get is not null:\n        return descr_get(cls_var, obj, objtype)  # non-data descriptor\n\n    \"\"\"\n    In case name did not reference anything from above, we try to see \n    if it references a class attribute and return its value.\n    \"\"\"\n    if cls_var is not null:\n        return cls_var                                  # class variable\n\n    \"\"\"\n    If name resolution was unsuccessful, we throw an AttriuteError \n    exception, and __getattr__ is being invoked.\n    \"\"\"\n    raise AttributeError(name)\n```", "```py\ntype(p.shout)\n# getting the attribute name: shout\n# method\n\ntype(Person.shout)\n# function\n```", "```py\nclass Function:\n    ...\n\n    def __get__(self, obj, objtype=None):\n        if obj is None:\n            return self\n        return MethodType(self, obj)\n```", "```py\nclass Function:\n    ...\n\n    def __init__(self, fun, *args, **kwargs):\n        ...\n        self.fun = fun\n\n    def __get__(self, obj, objtype=None):\n        if obj is None:\n            return self\n        return MethodType(self, obj)\n\n    def __call__(self, *args, **kwargs):\n        ...\n        return self.fun(*args, **kwargs)\n```", "```py\nclass MethodType:\n\n    def __init__(self, func, obj):\n        self.__func__ = func\n        self.__self__ = obj\n\n    def __call__(self, *args, **kwargs):\n        func = self.__func__\n        obj = self.__self__\n        return func(obj, *args, **kwargs)\n```", "```py\nclass Person:\n\n    num_of_persons = 0\n\n    def __init__(self, name):\n        self.name = name\n\n    def shout(self):\n        print(f\"Hey! I'm {self.name}.\")\n\np = Person('John')\n\nPerson.shout(p)\n# Hey! I'm John.\n```", "```py\np.name\n\"\"\"\n1\\. __getattribute__ is invoked with p and \"name\" arguments.\n\n2\\. objtype is Person.\n\n3\\. descr_get is null because the Person class doesn't have \n   \"name\" in its dictionary (namespace).\n\n4\\. Since there is no descr_get at all, we skip the first if block.\n\n5\\. \"name\" does exist in the object's dictionary so we get the value.\n\"\"\"\n\np.shout('Hey')\n\"\"\"\nBefore we go into name resolution steps, keep in mind that \nPerson.shout is an instance of a function class. Essentially, it gets \nwrapped in it. And this object is callable, so you can invoke it with \nPerson.shout(...). From a developer perspective, everything works just\nas if it were defined in the class body. But in the background, it \nmost certainly is not.\n\n1\\. __getattribute__ is invoked with p and \"shout\" arguments.\n\n2\\. objtype is Person.\n\n3\\. Person.shout is actually wrapped and is a non-data descriptor.\nSo this wrapper does have the __get__ method implemented, and it\ngets referenced by descr_get.\n\n4\\. The wrapper object is a non-data descriptor, so the first if block \n   is skipped.\n\n5\\. \"shout\" doesn't exist in the object's dictionary because it is part \n   of class definition. Second if block is skipped.\n\n6\\. \"shout\" is a non-data descriptor, and its __get__ method is returned\n   from the third if code block.\n\nNow, here we tried accessing p.shout('Hey'), but what we did get is\np.shout.__get__ method. This one returns a MethodType object. Because\nof this p.shout(...) works, but what ends up being called is an \ninstance of the MethodType class. This object is essentially a wrapper\naround the `Function` wrapper, and it holds reference to the `Function`\nwrapper and our object p. In the end, when you invoke p.shout('Hey'), \nwhat ends up being invoked is `Function` wrapper with p object, and \n'Hey' as one of the positional arguments.\n\"\"\"\n\nPerson.shout(p)\n\"\"\"\nBefore we go into name resolution steps, keep in mind that \nPerson.shout is an instance of a function class. Essentially, it gets \nwrapped in it. And this object is callable, so you can invoke it with \nPerson.shout(...). From a developer perspective, everything works just\nas if it were defined in the class body. But in the background, it \nmost certainly is not.\n\nThis part is the same. The following steps are different. Check\nit out.\n\n1\\. __getattribute__ is invoked with Person and \"shout\" arguments.\n\n2\\. objtype is a type. This mechanism is described in my post on\nmetaclasses.\n\n3\\. Person.shout is actually wrapped and is a non-data descriptor,\nso this wrapper does have the __get__ method implemented, and it\ngets referenced by descr_get.\n\n4\\. The wrapper object is a non-data descriptor, so first if block is \n   skipped.\n\n5\\. \"shout\" does exist in an object's dictionary because Person is\n   object after all. So the \"shout\" function is returned.\n\nWhen Person.shout is invoked, what actually gets invoked is an instance\nof the `Function` class, which is also callable and wrapper around the\noriginal function defined in the class body. This way, the original \nfunction gets called with all positional and keyword arguments.\n\"\"\"\n```"]