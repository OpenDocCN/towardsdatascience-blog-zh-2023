["```py\nfrom pyomo.environ import *\n\nmodel = ConcreteModel()\n\n# Define parameters regions and cell sites\nmodel.I = Set(initialize=[1,2,3,4]) # regions/demands\nmodel.J = Set(initialize=[1,2,3,4]) # cell sites\nmodel.a = Param(model.I, model.J, initialize={(1,1):1, (1,2):1, (1,3):0, (1,4):0, (2,1):1,(2,2):1,(2,3):1, (2,4):0, (3,1):0,(3,2):0,(3,3):1,(3,4):1,(4,1):0,(4,2):1,(4,3):0, (4,4):1})\n\n# Define variables\nmodel.x = Var(model.J, within=Binary)\n\n# Define objective function\ndef objective(model):\n    return sum(model.x[j] for j in model.J)\n\nmodel.obj = Objective(rule=objective, sense=minimize)\n\n# Define constraints (sumproduct), for each Region i, we look at all cell sites, and see whether this cell site covers region i or not. sum must be greator than equal to 1\ndef demand_rule(model, i):\n    return sum(model.a[i,j]*model.x[j] for j in model.J) >= 1\n\nmodel.demand_constraint = Constraint(model.I, rule=demand_rule)\n\n# Solve the model\nsolver = SolverFactory('glpk')\nresults = solver.solve(model)\n\n# Print the solution\nprint(\"Optimal solution:\")\nfor j in model.J:\n    if model.x[j].value == 1:\n        print(f\"Location {j} is open\")\nprint(f\"Number of open locations: {model.obj()}\")\n```", "```py\nfrom pyomo.environ import *\n\nmodel = ConcreteModel()\n# Define parameters regions and cell sites\nmodel.I = Set(initialize=[1,2,3,4]) # regions/demands\nmodel.J = Set(initialize=[1,2,3,4]) # cell sites\nmodel.a = Param(model.I, model.J, initialize={(1,1):1, (1,2):1, (1,3):0, (1,4):0, (2,1):1,(2,2):1,(2,3):1, (2,4):0, (3,1):0,(3,2):0,(3,3):1,(3,4):1,(4,1):0,(4,2):1,(4,3):0, (4,4):1})\n\nmodel.p = Param(initialize=1)\nmodel.x = Var(model.J, within=Binary)\nmodel.y = Var(model.I, within=Binary)\n\ndef objective(model):\n    return sum(model.y[i] for i in model.I)\n\nmodel.obj = Objective(rule=objective, sense=maximize)\n\n##constraint\ndef coverage_rule(model, i):\n    return sum(model.a[i,j]*model.x[j] for j in model.J) >= model.y[i]\n\nmodel.coverage_constraint = Constraint(model.I, rule=coverage_rule)\n\ndef cellsitelocation_rule(model):\n    return sum(model.x[j] for j in model.J) <= model.p\n\nmodel.cellsite_constraint = Constraint(rule=cellsitelocation_rule)\n\nopt = SolverFactory(\"glpk\")\nresults = opt.solve(model)\n\nprint(\"Optimal solution:\")\nfor j in model.J:\n    if model.x[j].value == 1:\n        print(f\"Cellsite {j} is on\")\n\nprint(\"Optimal solution:\")\nfor i in model.I:\n    if model.y[i].value == 1:\n        print(f\"Region {i} is covered\")\nprint(f\"Number of regions covered: {model.obj()}\")\n```"]