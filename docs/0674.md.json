["```py\n##Further data cleaning ##\n\nwhich = rep(TRUE, nrow(wage))\nwhich = which & (wage$age >= 17)\nwhich = which & (wage$weeks_worked > 48)\nwhich = which & (wage$hours_worked > 16)\nwhich = which & (wage$employment_status == 'employed')\nwhich = which & (wage$employer != 'self-employed')\nwhich[is.na(which)] = FALSE\n\ndata = wage[which, ]\nsum(is.na(data))\ncolSums(is.na(data))\nrownames(data) = 1:nrow(data)\n#data = na.omit(data)\n\ndata$log_wage = log(data$salary / (data$weeks_worked * data$hours_worked))\n\n## Prepare data and fit drf\n## Define X and Y\nX = data[,c(\n  'age',\n  'race',\n  'hispanic_origin',\n  'citizenship',\n  'nativity', \n  'marital',\n  'family_size',\n  'children',\n  'education_level',\n  'english_level',\n  'economic_region'\n)]\nX$occupation = unlist(lapply(as.character(data$occupation), function(s){return(substr(s, 1, 2))}))\nX$occupation = as.factor(X$occupation)\nX$industry = unlist(lapply(as.character(data$industry), function(s){return(substr(s, 1, 2))}))\nX$industry[X$industry %in% c('32', '33', '3M')] = '31'\nX$industry[X$industry %in% c('42')] = '41'\nX$industry[X$industry %in% c('45', '4M')] = '44'\nX$industry[X$industry %in% c('49')] = '48'\nX$industry[X$industry %in% c('92')] = '91'\nX$industry = as.factor(X$industry)\nX=dummy_cols(X, remove_selected_columns = TRUE)\nX = as.matrix(X)\n\nY = data[,c('sex', 'log_wage')]\nY$sex = (Y$sex == 'male')\nY = as.matrix(Y)\n```", "```py\ntrain_idx = sample(1:nrow(data), 4000, replace = FALSE)\n\n## Focus on training data\nYtrain=Y[train_idx,]\nXtrain=X[train_idx,]\n```", "```py\n## Plot the test data without adjustment\nplotdfunadj = data[train_idx, ]\nplotdfunadj$weight=1\nplotdfunadj$plotweight[plotdfunadj$sex=='female'] = plotdfunadj$weight[plotdfunadj$sex=='female']/sum(plotdfunadj$weight[plotdfunadj$sex=='female'])\nplotdfunadj$plotweight[plotdfunadj$sex=='male'] = plotdfunadj$weight[plotdfunadj$sex=='male']/sum(plotdfunadj$weight[plotdfunadj$sex=='male'])\n\n#pooled data\nggplot(plotdfunadj, aes(log_wage)) +\n  geom_density(adjust=2.5, alpha = 0.3, show.legend = TRUE,  aes(fill=sex, weight=plotweight)) +\n  theme_light()+\n  scale_fill_discrete(name = \"gender\", labels = c('female', \"male\"))+\n  theme(legend.position = c(0.83, 0.66),\n        legend.text=element_text(size=18),\n        legend.title=element_text(size=20),\n        legend.background = element_rect(fill=alpha('white', 0.5)),\n        axis.text.x = element_text(size=14),\n        axis.text.y = element_text(size=14),\n        axis.title.x = element_text(size=19),\n        axis.title.y = element_text(size=19))+\n  labs(x='log(hourly_wage)')\n```", "```py\n## Median Difference before adjustment!\nquantile_maleunadj = wtd.quantile(x=plotdfunadj$log_wage, weights=plotdfunadj$plotweight*(plotdfunadj$sex=='male'), normwt=TRUE, probs=0.5)\nquantile_femaleunadj = wtd.quantile(x=plotdfunadj$log_wage, weights=plotdfunadj$plotweight*(plotdfunadj$sex=='female'), normwt=TRUE, probs=0.5)\n(1-exp(quantile_femaleunadj)/exp(quantile_maleunadj))\n```", "```py\ni<-47\n\n# Important: Test point needs to be a matrix\ntest_point<-X[i,, drop=F]\n```", "```py\n# Load all relevant functions (the CIdrf.R file can be found at the end of this \n# article\nsource('CIdrf.R')\n\n# predict with the new framework\nDRF = predictdrf(drf_fit, x=x)\nweights <- DRF$weights\n\n## Conditional Density Plotting\nplotdfx = data[train_idx, ]\n\npropensity = sum(weights[plotdfx$sex=='female'])\nplotdfx$plotweight = 0\nplotdfx$plotweight[plotdfx$sex=='female'] = weights[plotdfx$sex=='female']/propensity\nplotdfx$plotweight[plotdfx$sex=='male'] = weights[plotdfx$sex=='male']/(1-propensity)\n\ngg = ggplot(plotdfx, aes(log_wage)) +\n  geom_density(adjust=5, alpha = 0.3, show.legend=TRUE,  aes(fill=sex, weight=plotweight)) +\n  labs(x='log(hourly wage)')+\n  theme_light()+\n  scale_fill_discrete(name = \"gender\", labels = c(sprintf(\"F: %g%%\", round(100*propensity, 1)), sprintf(\"M: %g%%\", round(100*(1-propensity), 1))))+\n  theme(legend.position = c(0.9, 0.65),\n        legend.text=element_text(size=18),\n        legend.title=element_text(size=20),\n        legend.background = element_rect(fill=alpha('white', 0)),\n        axis.text.x = element_text(size=14),\n        axis.text.y = element_text(size=14),\n        axis.title.x = element_text(size=19),\n        axis.title.y = element_text(size=19))+\n  annotate(\"text\", x=-1, y=Inf, hjust=0, vjust=1, size=5, label = point_description(data[i,]))\nplot(gg)\n```", "```py\n## Getting the respective weights\nweightsmale<-weights*(Ytrain[, \"sex\"]==1)/sum(weights*(Ytrain[, \"sex\"]==1))\nweightsfemale<-weights*(Ytrain[, \"sex\"]==0)/sum(weights*(Ytrain[, \"sex\"]==0))\n\n## Choosing alpha:\nalpha<-0.05\n\n# Step 1: Doing Median comparison for fixed x\n\nquantile_male = wtd.quantile(x=data$log_wage[train_idx], weights=matrix(weightsmale), normwt=TRUE, probs=0.5)\nquantile_female = wtd.quantile(x=data$log_wage[train_idx], weights=matrix(weightsfemale), normwt=TRUE, probs=0.5)\n\n(medianx<-unname(1-exp(quantile_female)/exp(quantile_male)))\n\nmediandist <- sapply(DRF$weightsb, function(wb) {\n\n  wbmale<-wb*(Ytrain[, \"sex\"]==1)/sum(wb*(Ytrain[, \"sex\"]==1))\n  wbfemale<-wb*(Ytrain[, \"sex\"]==0)/sum(wb*(Ytrain[, \"sex\"]==0))\n\n  quantile_maleb = wtd.quantile(x=data$log_wage[train_idx], weights=matrix(wbmale), normwt=TRUE, probs=0.5)\n  quantile_femaleb = wtd.quantile(x=data$log_wage[train_idx], weights=matrix(wbfemale), normwt=TRUE, probs=0.5)\n\n  return( unname(1-exp(quantile_femaleb)/exp(quantile_maleb)) ) \n})\n\nvarx<-var(mediandist)\n\n## Use Gaussian CI:\n(upper<-medianx + qnorm(1-alpha/2)*sqrt(varx))\n(lower<-medianx - qnorm(1-alpha/2)*sqrt(varx)) \n```", "```py\n Witobj<-Witdrf(drf_fit, x=test_point, groupingvar=\"sex\", alpha=0.05)\n\nhatmun<-function(y,Witobj){\n\n  c<-Witobj$c\n  k_Y<-Witobj$k_Y\n  Y<-Witobj$Y\n  weightsall1<-Witobj$weightsall1\n  weightsall0<-Witobj$weightsall0\n  Ky=t(kernelMatrix(k_Y, Y , y = y))\n\n  out<-list()\n  out$val <- tcrossprod(Ky, weightsall1  ) - tcrossprod(Ky, weightsall0  )\n  out$upper<-  out$val+sqrt(c)\n  out$lower<-  out$val-sqrt(c)\n\n  return( out )\n\n}\n\nall<-hatmun(sort(Witobj$Y),Witobj)\n\nplot(sort(Witobj$Y),all$val , type=\"l\", col=\"darkblue\", lwd=2, ylim=c(min(all$lower), max(all$upper)),\n     xlab=\"log(wage)\", ylab=\"witness function\")\nlines(sort(Witobj$Y),all$upper , type=\"l\", col=\"darkgreen\", lwd=2 )\nlines(sort(Witobj$Y),all$lower , type=\"l\", col=\"darkgreen\", lwd=2 )\nabline(h=0)\n```", "```py\n## Add code\n\n## Male is 1, Female is 0\n\n# obtain all X from the female test population\nXtestf<-Xtest[Ytest[,\"sex\"]==0,]\n\n# Obtain the conditional distribution of W | G=male, X=x, for x in the female\n# population.\n\n# These weights correspond to P(W, G=male | X=x  )\nweightsf<-predictdrf(drf_fit, x=Xtestf)$weights*(Ytrain[, \"sex\"]==1)\nweightsf<-weightsf/rowSums(weightsf)\n\n# The counterfactual distribution is the average over those weights/distributions \ncounterfactualw<-colMeans(weightsf)\n```", "```py\nplotdfc<-rbind(plotdfc, plotdfunadj[plotdfunadj$sex=='female',])\nplotdfc$sex2<-c(rep(1, length(train_idx)), rep(0,nrow(plotdfunadj[plotdfunadj$sex=='female',])))\n\nplotdfc$sex2<-factor(plotdfc$sex2)\n\n#interventional distribution\nggplot(plotdfc, aes(log_wage)) +\n  geom_density(adjust=2.5, alpha = 0.3, show.legend=TRUE,  aes(fill=sex2, weight=plotweight)) +\n  theme_light()+\n  scale_fill_discrete(name = \"\", labels = c(\"observed women's wages\", \"wages if treated as men\"))+\n  theme(legend.position = c(0.2, 0.98),\n        legend.text=element_text(size=16),\n        legend.title=element_text(size=20),\n        legend.background = element_rect(fill=alpha('white', 0)),\n        axis.text.x = element_text(size=14),\n        axis.text.y = element_text(size=14),\n        axis.title.x = element_text(size=19),\n        axis.title.y = element_text(size=19))+\n  labs(x='log(hourly wage)')\n```", "```py\nquantile_male = wtd.quantile(x=plotdfc$log_wage[plotdfc$sex2==1], weights=counterfactualw, normwt=TRUE, probs=0.5)\nquantile_female = wtd.quantile(x=plotdfunadj$log_wage, weights=plotdfunadj$plotweight*(plotdfunadj$sex=='female'), normwt=TRUE, probs=0.5)\n(1-exp(quantile_female)/exp(quantile_male)) \n```", "```py\n## Functions in CIdrf.R that is loaded above ##\n\ndrfCI <- function(X, Y, B, sampling = \"binomial\",...) {\n\n### Function that uses DRF with subsampling to obtain confidence regions as\n### as described in https://arxiv.org/pdf/2302.05761.pdf\n### X: Matrix of predictors\n### Y: Matrix of variables of interest\n### B: Number of half-samples/mini-forests\n\n  n <- dim(X)[1]\n\n  # compute point estimator and DRF per halfsample S\n  # weightsb: B times n matrix of weights\n  DRFlist <- lapply(seq_len(B), function(b) {\n\n    # half-sample index\n    indexb <- if (sampling == \"binomial\") {\n      seq_len(n)[as.logical(rbinom(n, size = 1, prob = 0.5))]\n    } else {\n      sample(seq_len(n), floor(n / 2), replace = FALSE)\n    }\n\n    ## Using refitting DRF on S\n    DRFb <- \n      drf(X = X[indexb, , drop = F], Y = Y[indexb, , drop = F],\n          ci.group.size = 1, ...)\n\n    return(list(DRF = DRFb, indices = indexb))\n  })\n\n  return(list(DRFlist = DRFlist, X = X, Y = Y) )\n}\n\npredictdrf<- function(DRF, x, ...) {\n\n### Function to predict from DRF with Confidence Bands\n### DRF: DRF object\n### x: Testpoint\n\n  ntest <- nrow(x)\n  n <- nrow(DRF$Y)\n\n  ## extract the weights w^S(x)\n  weightsb <- lapply(DRF$DRFlist, function(l) {\n\n    weightsbfinal <- Matrix(0, nrow = ntest, ncol = n , sparse = TRUE)\n\n    weightsbfinal[, l$indices] <- predict(l$DRF, x)$weights \n\n    return(weightsbfinal)\n  })\n\n  ## obtain the overall weights w\n  weights<- Reduce(\"+\", weightsb) / length(weightsb)\n\nreturn(list(weights = weights, weightsb = weightsb ))\n}\n\nWitdrf<- function(DRF, x, groupingvar, alpha=0.05, ...){\n\n### Function to calculate the conditional witness function with\n### confidence bands from DRF\n### DRF: DRF object\n### x: Testpoint\n\n  if (is.null(dim(x)) ){\n\n  stop(\"x needs to have dim(x) > 0\")\n  }\n\n  ntest <- nrow(x)\n  n <- nrow(DRF$Y)\n  coln<-colnames(DRF$Y)\n\n  ## Collect w^S\n  weightsb <- lapply(DRF$DRFlist, function(l) {\n\n    weightsbfinal <- Matrix(0, nrow = ntest, ncol = n , sparse = TRUE)\n\n    weightsbfinal[, l$indices] <- predict(l$DRF, x)$weights \n\n    return(weightsbfinal)\n  })\n\n  ## Obtain w\n  weightsall <- Reduce(\"+\", weightsb) / length(weightsb)\n\n  #weightsall0<-weightsall[, DRF$Y[, groupingvar]==0, drop=F]\n  #weightsall1<-weightsall[,DRF$Y[, groupingvar]==1, drop=F]\n\n  # Get the weights of the respective classes (need to standardize by propensity!)\n  weightsall0<-weightsall*(DRF$Y[, groupingvar]==0)/sum(weightsall*(DRF$Y[, groupingvar]==0))\n  weightsall1<-weightsall*(DRF$Y[, groupingvar]==1)/sum(weightsall*(DRF$Y[, groupingvar]==1))\n\n  bandwidth_Y <- drf:::medianHeuristic(DRF$Y)\n  k_Y <- rbfdot(sigma = bandwidth_Y)\n\n  K<-kernelMatrix(k_Y, DRF$Y[,coln[coln!=groupingvar]], y = DRF$Y[,coln[coln!=groupingvar]])\n\n  nulldist <- sapply(weightsb, function(wb){\n    # iterate over class 1\n\n    wb0<-wb*(DRF$Y[, groupingvar]==0)/sum(wb*(DRF$Y[, groupingvar]==0))\n    wb1<-wb*(DRF$Y[, groupingvar]==1)/sum(wb*(DRF$Y[, groupingvar]==1))\n\n    diag( ( wb0-weightsall0 - (wb1-weightsall1) )%*%K%*%t( wb0-weightsall0 - (wb1-weightsall1) )  )\n\n  })\n\n  # Choose the right quantile\n  c<-quantile(nulldist, 1-alpha)\n\n  return(list(c=c, k_Y=k_Y, Y=DRF$Y[,coln[coln!=groupingvar]], nulldist=nulldist, weightsall0=weightsall0, weightsall1=weightsall1))\n\n}\n```", "```py\n### Code to generate plots\n\n## Step 0: Choosing x\n\npoint_description = function(test_point){\n  out = ''\n\n  out = paste(out, 'job: ', test_point$occupation_description[1], sep='')\n  out = paste(out, '\\nindustry: ', test_point$industry_description[1], sep='')\n\n  out = paste(out, '\\neducation: ', test_point$education[1], sep='')\n  out = paste(out, '\\nemployer: ', test_point$employer[1], sep='')\n  out = paste(out, '\\nregion: ', test_point$economic_region[1], sep='')\n\n  out = paste(out, '\\nmarital: ', test_point$marital[1], sep='')\n  out = paste(out, '\\nfamily_size: ', test_point$family_size[1], sep='')\n  out = paste(out, '\\nchildren: ', test_point$children[1], sep='')\n\n  out = paste(out, '\\nnativity: ', test_point$nativity[1], sep='')\n  out = paste(out, '\\nhispanic: ', test_point$hispanic_origin[1], sep='')\n  out = paste(out, '\\nrace: ', test_point$race[1], sep='')\n  out = paste(out, '\\nage: ', test_point$age[1], sep='')\n\n  return(out)\n}\n```"]