["```py\n100..=2_393, 20_303..=30_239_000, 501_000_013..=501_000_016\n```", "```py\nuse range_set_blaze::RangeSetBlaze;\n// a is the set of integers from 100 to 499 (inclusive) and 501 to 1000 (inclusive)\nlet a = RangeSetBlaze::from_iter([100..=499, 501..=999]);\n // b is the set of integers -20 and the range 400 to 599 (inclusive)\nlet b = RangeSetBlaze::from_iter([-20..=-20, 400..=599]);\n// c is the union of a and b, namely -20 and 100 to 999 (inclusive)\nlet c = a | b;\nassert_eq!(c, RangeSetBlaze::from_iter([-20..=-20, 100..=999]));\n```", "```py\n#[must_use]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn is_superset(&self, other: &BTreeSet<T, A>) -> bool\nwhere\n    T: Ord,\n{\n    other.is_subset(self)\n}\n```", "```py\n#[must_use]\npub fn is_superset(&self, other: &RangeSetBlaze<T>) -> bool {\n    other.is_subset(self)\n}\n```", "```py\nlet a0 = RangeSetBlaze::from_iter([3, 2, 1, 100, 1]);\nlet a1: RangeSetBlaze<i32> = [3, 2, 1, 100, 1].into_iter().collect();\nassert!(a0 == a1 && a0.to_string() == \"1..=3, 100..=100\");\n```", "```py\n#[allow(clippy::reversed_empty_ranges)]\nlet a0 = RangeSetBlaze::from_iter([1..=2, 2..=2, -10..=-5, 1..=0]);\n#[allow(clippy::reversed_empty_ranges)]\nlet a1: RangeSetBlaze<i32> = [1..=2, 2..=2, -10..=-5, 1..=0].into_iter().collect();\nassert!(a0 == a1 && a0.to_string() == \"-10..=-5, 1..=2\");\n```", "```py\nlet a0 = RangeSetBlaze::from([3, 2, 1, 100, 1]);\nlet a1: RangeSetBlaze<i32> = [3, 2, 1, 100, 1].into();\nassert!(a0 == a1 && a0.to_string() == \"1..=3, 100..=100\")\n```", "```py\nlet a0 = RangeSetBlaze::from_sorted_disjoint(CheckSortedDisjoint::from([-10..=-5, 1..=2]));\nlet a1: RangeSetBlaze<i32> = CheckSortedDisjoint::from([-10..=-5, 1..=2]).into_range_set_blaze();\nassert!(a0 == a1 && a0.to_string() == \"-10..=-5, 1..=2\");\n```", "```py\nuse range_set_blaze::RangeSetBlaze;\nlet set = RangeSetBlaze::from_iter([30..=40, 15..=25, 10..=20]);\nlet mut ranges = set.ranges();\nassert_eq!(ranges.next(), Some(10..=25));\nassert_eq!(ranges.next(), Some(30..=40));\nassert_eq!(ranges.next(), None);\n```", "```py\nimpl<T: Integer> RangeSetBlaze<T> {\n    pub fn ranges(&self) -> RangesIter<'_, T> {\n        RangesIter {\n            iter: self.btree_map.iter(),\n        }\n    }\n}\n\n#[derive(Clone, Debug)]\n#[must_use = \"iterators are lazy and do nothing unless consumed\"]\npub struct RangesIter<'a, T: Integer> {\n    pub(crate) iter: btree_map::Iter<'a, T, T>,\n}\n\nimpl<'a, T: Integer> Iterator for RangesIter<'a, T> {\n    type Item = RangeInclusive<T>;\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next().map(|(start, end)| *start..=*end)\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n```", "```py\nimpl<T: Integer, I> Iterator for Iter<T, I>\nwhere\n    I: Iterator<Item = RangeInclusive<T>> + SortedDisjoint,\n{\n    type Item = T;\n    fn next(&mut self) -> Option<T> {\n        loop {\n            if let Some(range) = self.option_range.clone() {\n                let (start, end) = range.into_inner();\n                debug_assert!(start <= end && end <= T::safe_max_value());\n                if start < end {\n                    self.option_range = Some(start + T::one()..=end);\n                } else {\n                    self.option_range = None;\n                }\n                return Some(start);\n            } else if let Some(range) = self.iter.next() {\n                self.option_range = Some(range);\n                continue;\n            } else {\n                return None;\n            }\n        }\n    }\n```", "```py\nuse range_set_blaze::RangeSetBlaze;\n\nfn _some_fn() {\n    let _char_set = RangeSetBlaze::from_iter(['a', 'b', 'c', 'd']);\n}\n```", "```py\nlet _char_set = RangeSetBlaze::from_iter(['a', 'b', 'c', 'd']);\n  |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |                     the trait `Integer` is not implemented for `char`\n  |\n  = help: the following other types implement trait `Integer`:\n            i128\n            i16\n            i32\n            i64\n            i8\n            isize\n            u128\n            u16\n          and $N others\n```", "```py\npub trait Integer:\n    num_integer::Integer\n    + FromStr\n    + fmt::Display\n    + fmt::Debug\n    + std::iter::Sum\n    + num_traits::NumAssignOps\n    + FromStr\n    + Copy\n    + num_traits::Bounded\n    + num_traits::NumCast\n    + Send\n    + Sync\n    + OverflowingSub\n    + SampleUniform\n{\n    // associated type SafeLen definition not shown ...\n    fn safe_len(range: &RangeInclusive<Self>) -> <Self as Integer>::SafeLen;\n    fn safe_max_value() -> Self {        Self::max_value()    }\n    fn f64_to_safe_len(f: f64) -> Self::SafeLen;\n    fn safe_len_to_f64(len: Self::SafeLen) -> f64;\n    fn add_len_less_one(a: Self, b: Self::SafeLen) -> Self;\n    fn sub_len_less_one(a: Self, b: Self::SafeLen) -> Self;\n}\n```", "```py\nimpl Integer for i32 {\n    #[cfg(target_pointer_width = \"64\")]\n    type SafeLen = usize;\n    fn safe_len(r: &RangeInclusive<Self>) -> <Self as Integer>::SafeLen {\n        r.end().overflowing_sub(*r.start()).0 as u32 as <Self as Integer>::SafeLen + 1\n    }\n    fn safe_len_to_f64(len: Self::SafeLen) -> f64 {len as f64}\n    fn f64_to_safe_len(f: f64) -> Self::SafeLen {f as Self::SafeLen}\n    fn add_len_less_one(a: Self, b: Self::SafeLen) -> Self {a + (b - 1) as Self}\n    fn sub_len_less_one(a: Self, b: Self::SafeLen) -> Self {a - (b - 1) as Self}\n}\n```", "```py\nuse range_set_blaze::RangeSetBlaze;\n\nfn _some_fn() {\n    let not_guaranteed = [5..=6, 1..=3, 3..=4].into_iter();\n    let _range_set_int = RangeSetBlaze::from_sorted_disjoint(not_guaranteed);\n}\n```", "```py\n7 |     let _range_set_int = RangeSetBlaze::from_sorted_disjoint(not_guaranteed);\n  |                          ----------------------------------- ^^^^^^^^^^^^^^\n                              the trait `SortedDisjoint<_>` is not implemented for `std::array::IntoIter<RangeInclusive<{integer}>, 3>`\n  |                          |\n  |                          required by a bound introduced by this call\n  |\n  = help: the following other types implement trait `SortedDisjoint<T>`:\n            CheckSortedDisjoint<T, I> ...\n```", "```py\npub trait SortedStarts<T: Integer>: Iterator<Item = RangeInclusive<T>> {}\npub trait SortedDisjoint<T: Integer>: SortedStarts<T> {\n// methods not shown, yet\n}\n```", "```py\nimpl<T: Integer> RangeSetBlaze<T> {\n    pub fn from_sorted_disjoint<I>(iter: I) -> Self\n    where\n        I: SortedDisjoint<T>,\n    {\n        // ... code omitted ...\n    }\n}\n```", "```py\nimpl<T: Integer> SortedStarts for RangesIter<'_, T> {}\nimpl<T: Integer> SortedDisjoint for RangesIter<'_, T> {}\n```", "```py\nimpl<T: Integer, I: SortedDisjoint<T>> SortedDisjoint<T> for Tee<I> {}\n```", "```py\npub trait SortedDisjoint<T: Integer>: SortedStarts<T> {\n    fn complement(self) -> NotIter<T, Self>\n    where\n        Self: Sized,\n    {\n        NotIter::new(self)\n    }\n}\n```", "```py\nuse range_set_blaze::prelude::*;\n\nlet a = CheckSortedDisjoint::from([-10i16..=0, 1000..=2000]);\nlet complement = a.complement();\nassert_eq!(complement.to_string(), \"-32768..=-11, 1..=999, 2001..=32767\");\n```", "```py\npub use crate::{\n    intersection_dyn, union_dyn, CheckSortedDisjoint, DynSortedDisjoint, MultiwayRangeSetBlaze,\n    MultiwayRangeSetBlazeRef, MultiwaySortedDisjoint, RangeSetBlaze, SortedDisjoint,\n};\n```"]