["```py\nimport time\nfrom itertools import cycle\n\nimport numpy as np\nfrom scipy.spatial.distance import pdist, squareform\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nimport networkx as nx\nimport pyomo.environ as pyo\nfrom pyomo.contrib.appsi.solvers.highs import Highs\n```", "```py\nnp.random.seed(42)  # Results should be always the same\n\nN = 10\ndemands = np.random.randint(1, 10, size=N)\ndemands[0] = 0\n\ncapacity = 15\nn_vehicles = 4\n\ncoordinates = np.random.rand(N, 2)\ndistances = squareform(pdist(coordinates, metric=\"euclidean\"))\ndistances = np.round(distances, decimals=4)  # avoid numerical errors\n```", "```py\nmodel = pyo.ConcreteModel()\n```", "```py\nmodel.V = pyo.Set(initialize=range(len(demands)))\nmodel.A = pyo.Set(initialize=[(i, j) for i in model.V for j in model.V if i != j])\nmodel.K = pyo.Set(initialize=range(n_vehicles))\n```", "```py\nmodel.Q = pyo.Param(initialize=capacity)\nmodel.q = pyo.Param(model.V, initialize={i: d for (i, d) in enumerate(demands)})\nmodel.c = pyo.Param(model.A, initialize={(i, j): distances[i, j] for (i, j) in model.A})\n```", "```py\nmodel.x = pyo.Var(model.A, model.K, within=pyo.Binary)\nmodel.y = pyo.Var(model.V, model.K, within=pyo.Binary)\n```", "```py\nmodel.obj = pyo.Objective(\n    expr=sum(\n        model.x[i, j, k] * model.c[i, j]\n        for (i, j) in model.A\n        for k in model.K\n    ),\n    sense=pyo.minimize,\n)\n```", "```py\ndef arcs_in(model, i):\n    if i == model.V.first():\n        return sum(model.x[:, i, :]) == len(model.K)\n    else:\n        return sum(model.x[:, i, :]) == 1.0\n\ndef arcs_out(model, i):\n    if i == model.V.first():\n        return sum(model.x[i, :, :]) == len(model.K)\n    else:\n        return sum(model.x[i, :, :]) == 1.0\n\ndef vehicle_assignment(model, i, k):\n    return sum(model.x[:, i, k]) == model.y[i, k]\n\ndef comp_vehicle_assignment(model, i, k):\n    return sum(model.x[i, :, k]) == model.y[i, k]\n\ndef capacity_constraint(model, k):\n    return sum(model.y[i, k] * model.q[i] for i in model.V) <= model.Q\n```", "```py\nmodel.arcs_in = pyo.Constraint(model.V, rule=arcs_in)\nmodel.arcs_out = pyo.Constraint(model.V, rule=arcs_out)\nmodel.vehicle_assignment = pyo.Constraint(model.V, model.K, rule=vehicle_assignment)\nmodel.comp_vehicle_assignment = pyo.Constraint(model.V, model.K, rule=comp_vehicle_assignment)\nmodel.capacity_constraint = pyo.Constraint(model.K, rule=capacity_constraint)\n```", "```py\ndef subtour_elimination(model, S, Sout, h, k):\n    nodes_out = sum(model.x[i, j, k] for i in S for j in Sout)\n    return model.y[h, k] <= nodes_out\n\nmodel.subtour_elimination = pyo.ConstraintList()\n```", "```py\ndef find_arcs(model):\n    arcs = []\n    for i, j in model.A:\n        for k in model.K:\n            if np.isclose(model.x[i, j, k].value, 1):\n                arcs.append((i, j))\n    return arcs\n\ndef find_subtours(arcs):\n    G = nx.DiGraph(arcs)\n    subtours = list(nx.strongly_connected_components(G))\n    return subtours\n```", "```py\ndef eliminate_subtours(model, subtours):\n    proceed = False\n    for S in subtours:\n        if 0 not in S:\n            proceed = True\n            Sout = {i for i in model.V if i not in S}\n            for h in S:\n                for k in model.K:\n                    model.subtour_elimination.add(\n                      subtour_elimination(model, S, Sout, h, k)\n                    )\n    return proceed\n```", "```py\ndef solve_step(model, solver):\n    sol = solver.solve(model)\n    arcs = find_arcs(model)\n    subtours = find_subtours(arcs)\n    time.sleep(0.1)\n    proceed = eliminate_subtours(model, subtours)\n    return sol, proceed \n\ndef solve(model, solver):\n    proceed = True\n    while proceed:\n        sol, proceed = solve_step(model, solver)\n    return sol\n```", "```py\nsolver = Highs()\nsolver.highs_options = {\n    \"log_file\": \"Highs.log\",\n    \"mip_heuristic_effort\": 0.2,\n    \"mip_detect_symmetry\": True,\n    \"mip_rel_gap\": 1e-6,\n}\n\nsolution = solve(model, solver)\n```", "```py\ndef find_tours(model):\n    tours = []\n    for k in model.K:\n        node = 0\n        tours.append([0])\n        while True:\n            for j in model.V:\n                if (node, j) in model.A:\n                    if np.isclose(model.x[node, j, k].value, 1):\n                        node = j\n                        tours[-1].append(node)\n                        break\n            if node == 0:\n                break\n    return tours\n```", "```py\nfrom itertools import cycle\n\nimport numpy as np\nimport pandas as pd\nfrom scipy.spatial.distance import pdist, squareform\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\n```", "```py\ndataset = pd.read_csv(\"./data/tai150d.csv\", index_col=0)\ncoordinates = dataset.loc[:, [\"x\", \"y\"]]\ndemands = dataset.d.values\n\ncapacity = 1874\nn_vehicles = 15\nN = coordinates.shape[0]\n\ndistances = squareform(pdist(coordinates, metric=\"euclidean\"))\ndistances = np.round(distances, decimals=4)\n```", "```py\n# Create the routing index manager: number of nodes, number of vehicles, depot node\nmanager = pywrapcp.RoutingIndexManager(\n    N, n_vehicles, 0\n)\n\n# Create Routing Model\nrouting = pywrapcp.RoutingModel(manager)\n```", "```py\n# Same valid for any callback related to arcs/edges\ndef distance_callback(from_index, to_index):\n    from_node = manager.IndexToNode(from_index)\n    to_node = manager.IndexToNode(to_index)\n    return distances[from_node, to_node]\n\ntransit_callback_index = routing.RegisterTransitCallback(distance_callback)\n\n# Same valid for any callback related to nodes\ndef demand_callback(from_index):\n    from_node = manager.IndexToNode(from_index)\n    return demands[from_node]\n\ndemand_callback_index = routing.RegisterUnaryTransitCallback(demand_callback)\n```", "```py\n# Any constraint associated with vehicles can take same arguments\nrouting.AddDimensionWithVehicleCapacity(\n    demand_callback_index,\n    0,  # null capacity slack\n    [capacity,] * n_vehicles,  # vehicle maximum capacities (list for each vehicle)\n    True,  # start cumul to zero\n    'Capacity'\n)\n```", "```py\nrouting.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n```", "```py\n# Setting heuristic strategies\nsearch_parameters = pywrapcp.DefaultRoutingSearchParameters()\nsearch_parameters.first_solution_strategy = (\n    routing_enums_pb2.FirstSolutionStrategy.CHRISTOFIDES\n)\nsearch_parameters.local_search_metaheuristic = (\n    routing_enums_pb2.LocalSearchMetaheuristic.GUIDED_LOCAL_SEARCH\n)\nsearch_parameters.time_limit.FromSeconds(300)\n\n# Solve the problem\nsolution = routing.SolveWithParameters(search_parameters)\n```", "```py\ntours = []\nfor vehicle_id in range(n_vehicles):\n    index = routing.Start(vehicle_id)\n    tours.append([])\n    while not routing.IsEnd(index):\n        node_index = manager.IndexToNode(index)\n        previous_index = index\n        index = solution.Value(routing.NextVar(index))\n        tours[-1].append(node_index)\n    else:\n        node_index = manager.IndexToNode(index)\n        tours[-1].append(node_index)\n```"]