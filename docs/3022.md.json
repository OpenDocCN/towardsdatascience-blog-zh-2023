["```py\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.cm as cm\nimport pandas as pd\nimport seaborn as sns\n\n# to generate a visually appealing images with dataframes\nimport dataframe_image as dfi\n\n# to make functions with some arguments fixed\nfrom functools import partial\n\n# Latex typefaces will be used for math symbols in figures.\nplt.rcParams.update({\n    \"text.usetex\": True,\n    \"font.family\": \"sans-serif\",\n    \"font.sans-serif\": [\"Helvetica\"]\n})\n```", "```py\ndef K(x, H):\n\n    # unpack two dimensions\n    x1, x2 = x\n\n    # extract four components from the matrix inv(H)\n    a, b, c, d = np.linalg.inv(H).flatten()\n\n    # calculate scaling coeff to shorten the equation\n    scale = 2*np.pi*np.sqrt( np.linalg.det(H))\n\n    return np.exp(-(a*x1**2 + d*x2**2 + (b+c)*x1*x2)/2) / scale\n```", "```py\ndef KDE(x, H, data):\n\n    # unpack two dimensions\n    x1, x2 = x\n\n    # prepare the grid for output values\n    output = np.zeros_like(x1)\n\n    # process every sample\n    for sample in data:\n        output += K([x1-sample[0], x2-sample[1]], H)\n\n    return output\n```", "```py\ndef show_pdf(func, data, \n             resolution = 100, \n             contours_density = 8,\n             surf_density = 40,\n             figsize=(10,5), cmap=cm.cividis,\n             aspect='equal', margins='auto',\n             s = 40, edgecolor='black', \n             markeralpha=1, markercolor='white'\n            ):\n\n    # range for x and y axis is determined from the dataset\n    x1_min, x2_min = data.min(axis=0)\n    x1_max, x2_max = data.max(axis=0)\n\n    # plus some extra margins\n    if margins == 'auto':\n        x1_pad = max(3, int(0.3*(x1_max-x1_min)))\n        x2_pad = max(3, int(0.3*(x2_max-x2_min)))\n    else:\n        x1_pad = int(margins*(x1_max-x1_min))\n        x2_pad = int(margins*(x2_max-x2_min)) \n\n    x1_range = np.linspace(start=x1_min-x1_pad, \n                           stop=x1_max+x1_pad, num=resolution)\n    x2_range = np.linspace(start=x2_min-x2_pad, \n                           stop=x2_max+x2_pad, num=resolution)\n\n    X1_grid, X2_grid = np.meshgrid(x1_range, x2_range)\n\n    # the given func is called here \n    Z_grid = func([X1_grid, X2_grid])\n\n    # draw a figure\n    fig = plt.figure(figsize=figsize)\n    ax = fig.add_subplot(1, 2, 1)\n    c = ax.contourf(X1_grid, X2_grid, Z_grid, \n                    contours_density, cmap=cmap)\n    c2 = ax.contour(X1_grid, X2_grid, Z_grid, \n                    contours_density, colors='black')\n    ax.set_xlabel(r'$x^{(1)}$', fontsize=16, labelpad=7)\n    ax.set_ylabel(r'$x^{(2)}$', fontsize=16, rotation=0, labelpad=8)\n    ax.scatter(data[:,0], data[:,1], marker='s', \n               color=markercolor, s=s, edgecolor=edgecolor, alpha=markeralpha)\n    ax.set_aspect(aspect)\n    plt.clabel(c2, inline=True, fontsize=10)\n\n    ax = fig.add_subplot(1, 2, 2, projection='3d')\n    ax.plot_surface(X1_grid, X2_grid, Z_grid, \n                    rcount=surf_density, \n                    ccount=surf_density, cmap=cmap) \n    ax.set_xlabel(r'$x^{(1)}$', fontsize=14)\n    ax.set_ylabel(r'$x^{(2)}$', fontsize=14)\n\n    plt.show()\n```", "```py\n# covariance matrix\nH = [[1, 0],\n     [0, 1]]\n\n# a single point to make PDF\ndata = np.array([[0,0]])\n\n# fix arguments 'H' and 'data' of KDE function for further calls\nKDE_partial = partial(KDE, H=np.array(H), data=data)\n\n# draw contour and surface plots\nshow_pdf(func=KDE_partial, data=data)\n```", "```py\nH = [[1, 0.9],\n     [0.9, 1]]\n\nKDE_partial = partial(KDE, H=np.array(H), data=data)\n\n# when the function gets too sharp, boost the resolution\nshow_pdf(func=KDE_partial, data=data, \n         resolution=300, surf_density=50)\n```", "```py\ndef angle2rotation_matrix(angle):\n    return np.array([ [np.cos(angle), np.sin(angle)],\n                     [-np.sin(angle), np.cos(angle)] ])\n\nR = angle2rotation_matrix(angle=(-1/10)*np.pi)\n```", "```py\n# the first axis scale is expanded twice\nH = np.array([[2, 0],\n              [0, 0.2]])\n\n# rotation\nH = R @ H @ R.T\n\ndata = np.array([[0,0]])\n\nKDE_partial = partial(KDE, H=np.array(H), data=data)\nshow_pdf(func=KDE_partial, data=data)\n```", "```py\nfilename = 'HeightsWeightsGender_dataset.xlsx'\n\n# my Github repo\nURL = \"https://raw.githubusercontent.com/jdrapala/datasets/main/\" + filename\n\n# download the data form URL as a DataFrame\ndf = pd.read_excel(URL)\n\n# make it look appealing\ndf_styled = df.sample(7).style.background_gradient(axis=0, gmap=df['Weight'], cmap='cividis')\n\n# and export to file\ndfi.export(df_styled, 'filename.png', dpi=300)\n\n# extract numpy array from DataFrame\ndata = df[['Height','Weight']].to_numpy()\n```", "```py\nH = [[1, 0],\n     [0, 1]]\n\nKDE_partial = partial(KDE, H=np.array(H), data=data)\n\nshow_pdf(func=KDE_partial, data=data, aspect='auto', margins=0.15)\n```", "```py\nH = [[1, 0],\n     [0, 1]]\n\ns = 10\n\nKDE_partial = partial(KDE, H=s*np.array(H), data=data)\nshow_pdf(func=KDE_partial, data=data, aspect='auto', margins=0.15)\n```", "```py\n# draw PDF\nax = sns.kdeplot(x='Height', y='Weight', data=df, \n                 fill=True, cmap=cm.cividis, \n                 bw_adjust=1.1)\n# draw datapoints \nax.plot(df['Height'], df['Weight'], 's', color='white', \n        markersize=6, markeredgecolor='black', markeredgewidth=0.7)\nplt.show()\n```", "```py\nURL = \"http://exoplanets.org/csv-files/exoplanets.csv\"\n\ndf = pd.read_csv(URL, low_memory=False)\n\n# drop rows containing missing values\ndf = df[['NAME', 'MSINI', 'A']].dropna()\n\n# i don't like orignal columns names\ndf = df.rename(columns={'NAME': 'Name', \n                        'MSINI':'Mass', \n                        'A': 'Distance'}).set_index('Name').astype(float)\n\n# some masses are not missing but equal to zero, let's get rid of them too\ndf = df.drop(df[df['Mass'] == 0].index)\n\n# # make it look appealing\ndf_styled = df.sample(7).style.background_gradient(axis=0, \n                                                   gmap=df['Mass'], \n                                                   cmap='cividis')\ndfi.export(df_styled, 'filename.png', dpi=300)\n```", "```py\nwith plt.style.context('seaborn'):\n    sns.scatterplot(data=df, x='Mass', y='Distance')\n\nplt.xscale('log')\nplt.yscale('log')\nplt.show()\n```", "```py\n# logarithmic scale is more appropriate for this data\ndata = np.log(df[['Mass','Distance']].to_numpy())\n\nH = [[1, 0],\n     [0, 1]]\n\n# size of the kernel\ns = 0.7\n\nKDE_partial = partial(KDE, H=s*np.array(H), data=data)\n\nshow_pdf(func=KDE_partial, data=data, aspect='auto', \n         markeralpha=1, s=1.5, margins=0.15)\n```", "```py\nfrom sklearn.neighbors import KernelDensity\n\n# fit KDE to the dataset\nkde = KernelDensity(kernel='gaussian', bandwidth=0.4).fit(data)\n\n# Generate random samples from the model\nsynthetic_data = kde.sample(1000)\n\ndf = pd.DataFrame({'x1': synthetic_data[:,0], \n                   'x2': synthetic_data[:,1]})\n\nwith plt.style.context('seaborn'):\n    sns.scatterplot(df, x='x1',y='x2')\n\nplt.xlabel('Mass', fontsize=16)\nplt.ylabel('Distance', fontsize=16)\nplt.show()\n```"]