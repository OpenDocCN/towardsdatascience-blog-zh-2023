- en: NumPy Broadcasting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/numpy-broadcasting-4c4cb9dff1e7?source=collection_archive---------20-----------------------#2023-01-04](https://towardsdatascience.com/numpy-broadcasting-4c4cb9dff1e7?source=collection_archive---------20-----------------------#2023-01-04)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Definitions, rules and examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@cretanpan?source=post_page-----4c4cb9dff1e7--------------------------------)[![Pan
    Cretan](../Images/8b3fbab70c0e61f7ca516d2f54b646e5.png)](https://medium.com/@cretanpan?source=post_page-----4c4cb9dff1e7--------------------------------)[](https://towardsdatascience.com/?source=post_page-----4c4cb9dff1e7--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----4c4cb9dff1e7--------------------------------)
    [Pan Cretan](https://medium.com/@cretanpan?source=post_page-----4c4cb9dff1e7--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fff990ba57425&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnumpy-broadcasting-4c4cb9dff1e7&user=Pan+Cretan&userId=ff990ba57425&source=post_page-ff990ba57425----4c4cb9dff1e7---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----4c4cb9dff1e7--------------------------------)
    ·9 min read·Jan 4, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F4c4cb9dff1e7&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnumpy-broadcasting-4c4cb9dff1e7&user=Pan+Cretan&userId=ff990ba57425&source=-----4c4cb9dff1e7---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F4c4cb9dff1e7&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnumpy-broadcasting-4c4cb9dff1e7&source=-----4c4cb9dff1e7---------------------bookmark_footer-----------)![](../Images/c72e9c7fc065552e52bfb5c5c995bb30.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Photo by [Jean-Guy Nakars](https://unsplash.com/@jgnak?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[NumPy](https://numpy.org/) offers fast calculations via vectorisation that
    avoids the use of slow Python loops. Vectorisation is also available when using
    binary ufuncs, such as addition or multiplication, with the added benefit that
    arrays do not need to have the same shape. Operations with arrays of different
    shape are known as [broadcasting](https://numpy.org/doc/stable/user/basics.broadcasting.html#general-broadcasting-rules)
    and can be particularly confusing, especially with multidimensional arrays, or
    when both arrays need to be stretched.'
  prefs: []
  type: TYPE_NORMAL
- en: There are many examples and tutorials available, but I find most useful to approach
    the matter by thinking, and actually memorising, the broadcasting rules. It is
    then easier to think about any given use case and write the code without relying
    on trial-and-error.
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two data analysis and data science books that I would highly recommend.
    Both of them contain a small section on broadcasting.
  prefs: []
  type: TYPE_NORMAL
- en: '[Python for Data Analysis](https://wesmckinney.com/book/advanced-numpy.html#numpy_broadcasting)
    by Wes McKinney contains he following broadcasting rule:'
  prefs: []
  type: TYPE_NORMAL
- en: Two arrays are compatible for broadcasting if for each *trailing dimension*
    (i.e., starting from the end) the axis lengths match or if either of the lengths
    is 1\. Broadcasting is then performed over the missing or length 1 dimensions.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Python Data Science Handbook](https://jakevdp.github.io/PythonDataScienceHandbook/02.05-computation-on-arrays-broadcasting.html)
    by Jake VanderPlas contains a more verbose set of broadcasting rules:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rule 1: If the two arrays differ in their number of dimensions, the shape of
    the one with fewer dimensions is *padded* with ones on its leading (left) side.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Rule 2: If the shape of the two arrays does not match in any dimension, the
    array with shape equal to 1 in that dimension is stretched to match the other
    shape.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Rule 3: If in any dimension the sizes disagree and neither is equal to 1, an
    error is raised.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I find the second set of rules easier to follow. The examples below will be
    using these rules.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps one of the simplest examples of broadcasting, and a typical pattern,
    is to subtract the column mean from each column. Following this operation the
    column means will become numerically equally to zero
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: that prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let’s see what is going on here. Computing the means of the columns with `a.mean(axis=0)`
    produces an one-dimensional array with shape (3,). The two arrays involved in
    the subtraction differ in shape and hence `means_columns`that has fewer dimensions,
    will have its shape padded with 1 on the left according to rule 1\. Hence, behind
    the scenes, `means_columns` will be reshaped to (1, 3). Then according to rule
    2 `means_columns` will be stretched along axis 0 so that its shape becomes (3,
    3) to match the shape of `a`.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to using the rules to predict how the array with fewer dimensions
    will be stretched we can also use `[np.broadcast_to](https://numpy.org/doc/stable/reference/generated/numpy.broadcast_to.html)`
    that returns a read-only view on the original array with the given shape. The
    view may be non-contiguous and it is possible that different elements refer to
    the same memory address
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: that prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the base is the original means array (hence it is a view), whilst
    the stride along the first axis is 0, which means that different elements of the
    same column refer to the same memory location (see [here](https://medium.com/towards-data-science/numpy-internals-an-introduction-bcaafa1a68a2)
    for a primer on NumPy internals). NumPy is truly optimising memory usage wherever
    it can!
  prefs: []
  type: TYPE_NORMAL
- en: What if we wanted to demean the rows? The mean of the rows can be computed readily
    with `a.mean(axis=1)` that will return a (4,) array. Padding its shape with 1
    on the left, means that the array will become (1, 4). According to rule 3 the
    last dimension of the two arrays disagree and neither is 1\. This means that broadcasting
    will not take place. We could also anticipate this because`np.broadcast_to(a.mean(axis=1),
    a.shape)` raises an exception informing us that broadcast could not produce the
    requested shape (4, 3). The incompatibility of shapes can also be seen by executing
    `np.broadcast_shapes(a.shape, a.mean(axis=1).shape)` that also raises an exception
    explaining the shape mismatch. Demeaning the rows can be done by reshaping the
    row means into a (4, 1) array using either `a.mean(axis=1).reshape(-1, 1)` or
    `a.mean(axis=1)[:, np.newaxis]`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: that prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Rule 2 makes it clear why this works as an array with shape (4, 1) can be stretched
    across the columns for its shape to become (4, 3).
  prefs: []
  type: TYPE_NORMAL
- en: In the third example we will demonstrate that broadcasting can stretch both
    arrays in the ufunc binary function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: that gives
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Strictly speaking the reshaping of the `b` was not necessary, but it makes things
    a bit clearer. We can also broadcast the two arrays without applying the ufunc
    with `[np.broadcast_arrays](https://numpy.org/doc/stable/reference/generated/numpy.broadcast_arrays.html)`
    or the related and more flexible `[np.broadcast](https://numpy.org/doc/stable/reference/generated/numpy.broadcast.html#numpy.broadcast)`.
    For completeness, there are other ways to achieve the same result as with broadcasting,
    with one example being `np.add.outer(a, b)` that produces an equal result as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: returns True.
  prefs: []
  type: TYPE_NORMAL
- en: Demeaning a high dimensional array across any axis can be generalised with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We can confirm that `np.abs(res.mean(axis=1)).max()` is numerically equal to
    zero. The above function was taken from the book by Wes McKinney but had to be
    slightly modified to work with the NumPy version used for this article (1.23.4).
  prefs: []
  type: TYPE_NORMAL
- en: 'As a more real life example, we can use broadcasting to convert a color image
    to greyscale. The broadcasting part is annotated with comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The code above produces
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3aee3670314a7f03619d446c12e9fc02.png)'
  prefs: []
  type: TYPE_IMG
- en: Conversion of a transparent PNG image to greyscale (photo by [nextvoyage](https://pixabay.com/users/nextvoyage-5275305/)
    on [pixabay](https://pixabay.com/))
  prefs: []
  type: TYPE_NORMAL
- en: What is perhaps of interest is that the original is a RGBA image (red green
    blue alpha), i.e. it also contains a fourth alpha channel to indicate how opaque
    each pixel is. We converted the RGBA image to RGB by using a white background.
    This, and pretty much everything in this example, could have been done with [Pillow](https://pillow.readthedocs.io/en/stable/),
    but we used NumPy as much as possible on purpose (e.g. Pillow can [convert to
    greyscale](https://stackoverflow.com/questions/12201577/how-can-i-convert-an-rgb-image-into-grayscale-in-python)
    maintaining the transparency). The last part of the code is some [Matplotlib](https://matplotlib.org/)
    gimmickry to compare the color and greyscale images.
  prefs: []
  type: TYPE_NORMAL
- en: The conversion to greyscale is done using the equation
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/55253152222c572e69b7f1c72fe5af93.png)'
  prefs: []
  type: TYPE_IMG
- en: from this wikipedia [page](https://en.wikipedia.org/wiki/Grayscale). The part
    of the code carrying out the multiplication and summation that changes the shape
    of the image array from (1080, 1920, 3) to (1080, 1920) is commented. You may
    wonder if it was worth showing such a long example for one line of broadcasting
    code. This is exactly the point! Broadcasting is concise and without it the code
    will be much longer and much slower. It is often the case that the magic behind
    an algorithm is few lines of NumPy operations, often including broadcasting.
  prefs: []
  type: TYPE_NORMAL
- en: Setting values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most NumPy users associate broadcasting with array addition or multiplication.
    However, broadcasting applies equally when using indexing to set values. Below
    you can find a set of examples that we will not comment in detail
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Conclusions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Broadcasting may seem complex, but it can be easily mastered if a few key principles
    are kept in mind. The most important principle is that the array shapes are aligned
    starting from the right. Missing dimensions are filled with ones, always on the
    left. The two shapes become identical via stretching of dimensions that are equal
    to one. It may be necessary to do some reshaping with `np.newaxis` before two
    (or more!) arrays are broadcastable. Broadcasting is not only used to compute
    a whole array but also to set some of the values of an array. This is the gist
    of it. With some practice NumPy broadcasting can lead to surprisingly concise
    and efficient code. Use it to its full potential!
  prefs: []
  type: TYPE_NORMAL
