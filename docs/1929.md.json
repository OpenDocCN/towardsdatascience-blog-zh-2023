["```py\nimport numpy as np\nimport pandas as pd\nfrom scipy.optimize import linprog\nimport matplotlib.pyplot as plt\n```", "```py\ndataset = pd.read_csv(\"data.txt\", sep=\" \")\n```", "```py\n# Total width\nW = 100.0\n\n# Width and amount associated with each demand\nw = dataset.w.values\nd = dataset.d.values\n\n# LP parameters\nA = np.eye(dataset.shape[0]) * (W // w)\nc = np.ones_like(w)\n```", "```py\ndef solve_knapsack(W, w, duals):\n    return linprog(\n        -duals, A_ub=np.atleast_2d(w), b_ub=np.atleast_1d(W),\n        bounds=(0, np.inf), integrality=1,\n    )\n```", "```py\nlinprog(c, A_ub=-A, b_ub=-d, bounds=(0, None))\n```", "```py\nlinprog(-d, A_ub=A.T, b_ub=c, bounds=(0, None))\n```", "```py\n# Initial solution\nsol = linprog(c, A_ub=-A, b_ub=-d, bounds=(0, None))\nsol_dual = linprog(-d, A_ub=A.T, b_ub=c, bounds=(0, None))\ndiff = np.abs(sol_dual.x + sol.ineqlin.marginals).sum()\nprint(f\"Compare duality difference: {diff}\")\n\n# Iterate\nfor _ in range(1000):\n    duals = -sol.ineqlin.marginals\n    price_sol = solve_knapsack(W, w, duals)\n    y = price_sol.x\n    if 1 + price_sol.fun < -1e-4:\n        print(f\"Iteration: {_}; Reduced cost: {(1 + price_sol.fun):.3f}\")\n        A = np.hstack((A, y.reshape((-1, 1))))\n        c = np.append(c, 1)\n        sol = linprog(c, A_ub=-A, b_ub=-d, bounds=(0, None))\n    else:\n        break\n```", "```py\nsol_round = linprog(c, A_ub=-A, b_ub=-d, bounds=(0, np.inf), integrality=0)\nprint(f\"Rounding solution {np.ceil(sol_round.x).sum()}\")\nsol = linprog(c, A_ub=-A, b_ub=-d, bounds=(0, np.inf), integrality=1)\nprint(f\"Integer solution: {sol.x.sum()}\")\n```", "```py\nfig, ax = plt.subplots(figsize=[7, 3], dpi=100)\nhmap = ax.imshow(A > 1e-6, cmap=\"Blues\")\nplt.axis('off')\nfig.tight_layout()\nplt.show()\n```"]