["```py\nimport os\n\nroot = 'data'\ncities = ['Budapest', 'Toronto', 'Berlin', 'Stockholm']\nupdated = {city : [f for f in os.listdir(root + '/' + city) if '20' in f][0] for city in cities}\n\nupdated\n```", "```py\nfor city in cities:\n    print(len(os.listdir(root + '/' + city + '/' + updated[city])), sorted(os.listdir(root + '/' + city + '/' + updated[city])), '\\n')\n```", "```py\nimport geopandas as gpd\nfrom shapely.geometry import Point\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport osmnx as ox\n\ncity = 'Budapest'\n\ndf_stops = pd.read_csv(root + '/' + city + '/' + updated[city] + '/stops.txt')\ngeometry = [Point(xy) for xy in zip(df_stops['stop_lon'], df_stops['stop_lat'])]\ngdf_stops = gpd.GeoDataFrame(df_stops, geometry=geometry)\ndf_stops.crs = 'EPSG:4326'\n\nadmin = ox.geocode_to_gdf(city)\n\nf, ax = plt.subplots(1,1,figsize=(10,10))\n\nadmin.plot(ax=ax, color = 'none', edgecolor = 'k')\ngdf_stops.plot(ax=ax, alpha = 0.2)\n```", "```py\nstops = {}\nadmin = {}\n\nf, ax = plt.subplots(2,2,figsize=(15,15))\nindicies = [(i,j) for i in range(2) for j in range(2)]\n\nfor idx, city in enumerate(cities):\n\n    bx = ax[indicies[idx]]\n\n    df_stops = pd.read_csv(root + '/' + city + '/' + updated[city] + '/stops.txt')\n    geometry = [Point(xy) for xy in zip(df_stops['stop_lon'], df_stops['stop_lat'])]\n    gdf_stops = gpd.GeoDataFrame(df_stops, geometry=geometry)\n    gdf_stops.crs = 'EPSG:4326'\n    admin_ = ox.geocode_to_gdf(city)\n\n    gdf_stops.plot(ax=bx, markersize = 3, alpha = 0.5)\n    admin_.plot(ax=bx, color = 'none', edgecolor = 'k', linewidth = 4)\n    bx.set_title(city, fontsize = 15)\n    bx.axis('off')\n\n    stops[city] = gpd.overlay(gdf_stops, admin_)\n    admin[city] = admin_\n\nplt.tight_layout()\n```", "```py\nf, ax = plt.subplots(2,2,figsize=(15,15))\nindicies = [(i,j) for i in range(2) for j in range(2)]\n\nfor idx, (city, admin_) in enumerate(admin.items()):\n\n    bx = ax[indicies[idx]]    \n    gdf_stops = stops[city]\n    gdf_stops.plot(ax=bx, markersize = 3, alpha = 0.5)\n    admin_.plot(ax=bx, color = 'none', edgecolor = 'k', linewidth = 4)\n    bx.axis('off')\n\nplt.tight_layout() \n```", "```py\nfrom datetime import datetime\n\ndef parse_time_string(time_string):\n    hour_value = int(time_string.split(':')[0])\n    if hour_value > 23: hour_value = hour_value-24\n    time_string = str(hour_value) + ':' + time_string.split(':', 1)[1]    \n    parsed_time = datetime.strptime(time_string, \"%H:%M:%S\")\n    return parsed_time\n\nstop_times = {}\nfor city in cities:\n    print(city)\n    df_stop_times = pd.read_csv(root + '/' + city + '/' + updated[city] + '/stop_times.txt')\n    df_stop_times['departure_time'] = df_stop_times['departure_time'].apply(parse_time_string)\n    stop_times[city] = df_stop_times\n\nfor city, df_stop_times in stop_times.items():\n    print(city, len(df_stop_times))\n\ndf_stop_times.head(3)\n```", "```py\nf, ax = plt.subplots(4,1,figsize=(15,20))\n\nfor idx, (city, df_stop_times) in enumerate(stop_times.items()):\n\n    bx = ax[idx]\n\n    df_stop_times = df_stop_times\n\n    df_stop_times['hour_minute'] = df_stop_times['departure_time'].dt.strftime('%H:%M')\n\n    departure_counts = df_stop_times['hour_minute'].value_counts().sort_index()\n\n    departure_counts.plot(kind='bar', color='steelblue', alpha = 0.8, width=0.8, ax = bx)\n    bx.set_xlabel('Hour-Minute of Departure', fontsize = 18)\n    bx.set_ylabel('Number of Departures', fontsize = 18)\n    bx.set_title('Histogram of Departure Times by Hour-Minute in ' + city, fontsize = 26)\n\n    bx.set_xticks([ijk for ijk, i in enumerate(departure_counts.index) if ':00' in i])\n    bx.set_xticklabels([i for i in departure_counts.index if ':00' in i])\n\nplt.tight_layout()\n```", "```py\nimport geopandas as gpd # version: 0.13.1\nimport h3 # version: 3.7.3\nfrom shapely.geometry import Polygon # version: 1.8.5.post1\nimport numpy as np # version: 1.22.4\n\n# use this function to split an admin polygon into a hexagon grid\ndef split_admin_boundary_to_hexagons(admin_gdf, resolution):\n    coords = list(admin_gdf.geometry.to_list()[0].exterior.coords)\n    admin_geojson = {\"type\": \"Polygon\",  \"coordinates\": [coords]}\n    hexagons = h3.polyfill(admin_geojson, resolution, geo_json_conformant=True)\n    hexagon_geometries = {hex_id : Polygon(h3.h3_to_geo_boundary(hex_id, geo_json=True)) for hex_id in hexagons}\n    return gpd.GeoDataFrame(hexagon_geometries.items(), columns = ['hex_id', 'geometry'])\n\n# let's test two resolutions for Budapest\nhexagons_gdf_h8 = split_admin_boundary_to_hexagons(admin['Budapest'], 8)\nhexagons_gdf_h9 = split_admin_boundary_to_hexagons(admin['Budapest'], 9)\nhexagons_gdf_h8.plot()\nhexagons_gdf_h9.plot() \n```", "```py\nadmin['Berlin'] = gpd.GeoDataFrame(admin['Berlin'].geometry.explode(), columns = ['geometry']).head(1)\n```", "```py\nfrom matplotlib.colors import LogNorm\n\nresolution = 7\n\nfor city in cities:\n\n    # create the hexagon grid\n    hexagons_gdf = split_admin_boundary_to_hexagons(admin[city], resolution)\n\n    # merge stops and stopppings\n    gdf_stop_times = stops[city].merge(stop_times[city], left_on = 'stop_id',right_on = 'stop_id')\n\n    # compute the number of unique stops and stoppings in each hexagon\n    gdf_stops = gpd.sjoin(gdf_stop_times, hexagons_gdf)\n    nunique = gdf_stops.groupby(by = 'hex_id').nunique().to_dict()['stop_id']\n    total = gdf_stops.groupby(by = 'hex_id').count().to_dict()['stop_id']\n    hexagons_gdf['nunique'] = hexagons_gdf.hex_id.map(nunique).fillna(0)\n    hexagons_gdf['total'] = hexagons_gdf.hex_id.map(total).fillna(0)\n\n    # visualize the number of stops and stoppings\n    f, ax = plt.subplots(1,2,figsize=(15,5))\n    plt.suptitle(city + ', resolution = ' + str(resolution), fontsize=25)\n    hexagons_gdf.plot(column = 'nunique', cmap = 'RdYlGn', legend = True, ax = ax[0])\n    hexagons_gdf.plot(column = 'total', cmap = 'RdYlGn', legend = True, ax = ax[1])\n    # for log-saled coloring:\n    # hexagons_gdf.plot(column = 'total', cmap = 'RdYlGn', legend = True, ax = ax[1], norm=LogNorm(vmin=1, vmax = hexagons_gdf.total.max()))\n    ax[0].set_title('Number of unique stops', fontsize = 17)\n    ax[1].set_title('Number stoppings', fontsize = 17)\n    for aax in ax: aax.axis('off') \n```", "```py\nmap_complete = { 0   : 'Tram, Streetcar, Light rail', \n                 1   : 'Subway, Metro', \n                 2   : 'Rail',\n                 3   : 'Bus', \n                 4   : 'Ferry', \n                 11  : 'Trolleybus', \n                 100 : 'Railway Service',\n                 109 : 'Suburban Railway',\n                 400 : 'Urban Railway Service', \n                 401 : 'Metro Service', \n                 700 : 'Bus Service', \n                 717 : 'Regional Bus',\n                 900 : 'Tram Service', \n                 1000: 'Water Transport Service'}\n\nmap_simple = { 0    : 'Tram', \n               1    : 'Subway', \n               2    : 'Railway',\n               3    : 'Bus', \n               4    : 'Ferry', \n               11   : 'Trolleybus', \n               100  : 'Railway',\n               109  : 'Railway',\n               400  : 'Railway', \n               401  : 'Subway', \n               700  : 'Bus',\n               717  : 'Bus',\n               900  : 'Tram', \n               1000 : 'Ferry', } \n```", "```py\nfrom collections import Counter\nimport matplotlib.pyplot as plt\n\n# this function does some nice formatting on the axis and labels\ndef format_axis(ax):   \n    for pos in ['right', 'top']:   ax.spines[pos].set_edgecolor('w')    \n    for pos in ['bottom', 'left']: ax.spines[pos].set_edgecolor('k')         \n    ax.tick_params(axis='x', length=6, width=2, colors='k')\n    ax.tick_params(axis='y', length=6, width=2, colors='k') \n    for tick in ax.xaxis.get_major_ticks():  tick.label.set_fontsize(12) \n    for tick in ax.yaxis.get_major_ticks():  tick.label.set_fontsize(12)\n\nf, ax = plt.subplots(1,4,figsize = (15,4))\nroutes = {}\n\nfor idx, city in enumerate(cities):\n\n    # get the data, map the english names\n    df_route = pd.read_csv(root + '/' + city + '/' + updated[city] + '/routes.txt')\n    df_route['route_type'] = df_route['route_type'].astype(int)\n    df_route['route_type_en'] = df_route['route_type'].map(map_simple)\n    D = dict(Counter(df_route.route_type_en))\n    routes[city] = df_route\n\n    # define my color palette\n    transport_colors = {'Railway': '#A65C47',  \n                        'Bus': '#0BB3D9',      \n                        'Tram': '#F2B705',     \n                        'Ferry': '#997CA6'   ,  \n                        'Trolleybus' : '#D91818',\n                        'Subway' : '#0869A6'}\n\n    # create the bar charts\n    labels = D.keys()\n    values = D.values()\n    colors = [transport_colors[l] for l in labels]\n\n    ax[idx].bar(labels, values, color = colors)\n    ax[idx].set_xticklabels(labels, fontsize = 10, rotation = 60, ha = 'right')\n    format_axis(ax[idx])\n    ax[idx].set_title(city, fontsize = 18)\n    ax[idx].set_ylabel('Number of routes', fontsize = 15)\n    ax[idx].set_yscale('log')\n\nplt.tight_layout()\n```", "```py\ncity = 'Budapest'\ndf_routes = pd.read_csv(root + '/' + city + '/' + updated[city] + '/shapes.txt')\ndf_routes\n```", "```py\nimport contextily as ctx\n\nfor city in cities:\n\n    df_shapes = pd.read_csv(root + '/' + city + '/' + updated[city] + '/shapes.txt')\n\n    # transform the shape a GeoDataFrame\n    df_shapes['shape_pt_lat'] = df_shapes['shape_pt_lat'].astype(float)\n    df_shapes['shape_pt_lon'] = df_shapes['shape_pt_lon'].astype(float)\n\n    df_shapes['geometry'] = df_shapes.apply(lambda row: Point(row['shape_pt_lon'], row['shape_pt_lat']), axis=1)\n    df_shapes = gpd.GeoDataFrame(df_shapes[['shape_id', 'geometry']])\n    df_shapes.crs = 4326\n\n    gdf_shapes = gpd.GeoDataFrame(df_shapes[['shape_id', 'geometry']].groupby(by = 'shape_id').agg(list))\n    gdf_shapes = gdf_shapes[[len(g)>1 for g in gdf_shapes['geometry'].to_list()]]\n    gdf_shapes['geometry'] = gdf_shapes['geometry'].apply(lambda x: LineString(x))\n    gdf_shapes = gpd.GeoDataFrame(gdf_shapes)\n\n    # let's only keep those routes which have at least one segment that falls into the city\n    gdf_shapes['shape_id'] = gdf_shapes.index\n    shapes_in_city = set(gpd.overlay(gdf_shapes, admin[city]).shape_id.to_list())\n    gdf_shapes = gdf_shapes[gdf_shapes.shape_id.isin(shapes_in_city)]\n\n    # map the means of transport\n    df_route = routes[city][['route_id', 'route_type_en']].drop_duplicates()\n    df_trips = pd.read_csv(root + '/' + city + '/' + updated[city] + '/trips.txt')[['route_id', 'shape_id']].drop_duplicates()\n    df_trips = df_trips.merge(df_route, left_on = 'route_id', right_on = 'route_id')\n\n    # merge these\n    gdf_shapes = gdf_shapes.merge(df_trips, left_index = True, right_on = 'shape_id')\n\n    # create the visuals in matplotlib\n    f, ax = plt.subplots(1,1,figsize=(15,15))\n\n    cax = admin[city].plot(ax=ax, edgecolor = 'k', color = 'none')\n    cax = admin[city].plot(ax=ax, edgecolor = 'k', alpha = 0.52)\n    for transport, color in transport_colors.items():\n        gdf_shapes[gdf_shapes.route_type_en==transport].plot(ax=ax, color = color, alpha = 0.9, linewidth = 1)    \n    ax.axis('off')\n\n    ctx.add_basemap(ax, alpha = 0.8, crs = 4326, url = ctx.providers.CartoDB.DarkMatterNoLabels)\n\n    plt.tight_layout()\n    plt.savefig('figure7_'+city+ '.png', dpi = 150, bbox_inches = 'tight')\n    plt.close()\n```"]