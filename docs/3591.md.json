["```py\nimport numpy as np\n\n# Create a function to compute the surface\ndef f(theta):\n  x = theta[0]\n  y = theta[1]\n  return x**2 - y**2\n\n# Define a function to compute the gradient\ndef grad_f(theta):\n    returnValue = np.array([0.,0.])\n    x = theta[0]\n    y = theta[1]\n    returnValue[0] += 2*x\n    returnValue[1] += - 2*y\n    return returnValue\n```", "```py\ndef gradient_descent(x_init, y_init, step_size, n_iters, momentum):\n  eta = step_size\n  mu = momentum  # Notice that, if mu = 0, this algorithm is just SGD\n\n  # Initialize arrays to store results\n  theta = np.tile([x_init, y_init], (n_iters,1) )\n  z = np.tile([f(theta[0])], n_iters )\n\n  # Initialize velocity term\n  v_t = np.array([0,0])\n\n  for k in range (1, n_iters):\n\n   # Update velocity\n      v_t = mu*v_t - eta*grad_f(theta[k-1])\n\n   # Update position\n      theta[k] = theta[k-1] + v_t\n      z[k] = f(theta[k])\n\n  # Store position coordinates\n  dataset = np.stack((theta[:,0], theta[:,1], z), 1)  \n\n  return dataset\n```", "```py\n# Update velocity\n\n# Momentum\nv_t = mu*v_t - eta *grad_f(theta[k-1])\n\n# NAG\nv_t = mu*v_t - eta *grad_f(theta[k-1] + mu * v_t)\n```", "```py\ndef Adagrad(x_init, y_init, step_size, n_iters):\n  eta = step_size\n  G_t = 0\n  eps = 1e-8\n\n  theta = np.tile([x_init, y_init], (n_iters,1) )\n  z = np.tile([f(theta[0])], n_iters )\n  for k in range (1, n_iters):\n      # Compute gradient\n      g_t = grad_f(theta[k-1])\n\n      # Accumulate squared gradients\n      G_t += g_t**2\n\n      # Update position\n      theta[k] = theta[k-1] - eta * g_t / (np.sqrt(G_t) + eps)\n      z[k] = f(theta[k])\n\n  # Store position coordinates\n  dataSet = np.stack((theta[:,0], theta[:,1], z), 1)\n\n  return dataSet\n```", "```py\ndef RMSProp(x_init, y_init, step_size, n_iters, decay):\n  beta = decay # 0.8, 0.9, ..., 0.99\n  eta = step_size\n  eps = 1e-8\n  MSQ = 0\n\n  theta = np.tile([x_init, y_init], (n_iters,1) )\n  z = np.tile([f(theta[0])], n_iters )\n  for k in range (1, n_iters):\n      # Compute gradient\n      g_t = grad_f(theta[k-1])\n\n      # Compute the weighted mean of squared values\n      MSQ = beta * MSQ + (1 - beta) * g_t**2\n\n      # Update position (divide eta by RMS)\n      theta[k] = theta[k-1] - eta * g_t / (np.sqrt(MSQ) + eps)\n      z[k] = f(theta[k])\n\n  # Store position coordinates\n  dataSet = np.stack((theta[:,0], theta[:,1], z), 1)\n\n  return dataSet\n```", "```py\ndef AdaDelta(x_init, y_init, step_size, n_iters, decay):\n\n  eta = step_size\n  G_t = 0\n  eps = 1e-8\n  E_gsq = 0\n  E_xsq = 0\n\n  theta = np.tile([x_init, y_init], (n_iters,1) )\n  z = np.tile([f(theta[0])], n_iters )\n  for k in range (1, n_iters):\n      g_t = grad_f(theta[k-1])\n      E_gsq = decay * E_gsq + (1 - decay) * g_t**2\n      delta = - np.sqrt(E_xsq + eps) / np.sqrt(E_gsq + eps) * g_t\n      E_xsq = decay * E_xsq + (1 - decay) * delta**2\n      theta[k] = theta[k-1] + delta\n      z[k] = f(theta[k])\n\n  # Setting up Data Set for Animation\n  dataSet = np.stack((theta[:,0], theta[:,1], z), 1)  # Combining our position coordinates\n\n  return dataSet\n```", "```py\ndef Adam(x_init, y_init, step_size, n_iters, \n         beta_1 = 0.9, beta_2 = 0.999):\n\n  eps = 1e-8\n  eta = step_size\n\n  # Initialize vectors\n  m_t = np.array([0,0])\n  v_t = np.array([0,0])\n  theta = np.tile([x_init, y_init], (n_iters,1) )\n  z = np.tile([f(theta[0])], n_iters )\n\n  for k in range (1, n_iters):\n      # Compute gradient\n      g_t = grad_f(theta[k-1])\n\n      # Compute \"momentum-like\" term (weighted average)\n      m_t = beta_1 * m_t + (1 - beta_1)*g_t\n\n      # Compute the mean of squared gradient values\n      v_t = beta_2 * v_t + (1 - beta_2)*g_t**2\n\n      # Initialization bias correction terms\n      m_t_hat = m_t/(1 - beta_1**k)\n      v_t_hat = v_t/(1 - beta_2**k)\n\n      # Update position with adjusted gradient and lr\n      theta[k] = theta[k-1] - eta * m_t_hat/(np.sqrt(v_t_hat)+ eps)\n      z[k] = f(theta[k])\n\n  # Store position coordinates\n  dataSet = np.stack((theta[:,0], theta[:,1], z), 1) \n\n  return dataSet\n```"]