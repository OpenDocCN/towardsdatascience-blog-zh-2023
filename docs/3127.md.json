["```py\nfrom dotenv import load_dotenv\nfrom pathlib import Path\n\ndef load_secets():\n    load_dotenv()\n    env_path = Path(\".\") / \".env\"\n    load_dotenv(dotenv_path=env_path)\n\n    google_maps_key = os.getenv(\"GOOGLE_MAPS_API_KEY\")\n\n    return {\n        \"GOOGLE_MAPS_API_KEY\": google_maps_key,\n    }\n```", "```py\nhttps://airquality.googleapis.com/v1/currentConditions:lookup?key=YOUR_API_KEY\n```", "```py\nimport requests\nimport io\n\nclass Client(object):\n    DEFAULT_BASE_URL = \"https://airquality.googleapis.com\"\n\n    def __init__(self, key):\n        self.session = requests.Session()\n        self.key = key\n\n    def request_post(self, url, params):\n        request_url = self.compose_url(url)\n        request_header = self.compose_header()\n        request_body = params\n\n        response = self.session.post(\n            request_url,\n            headers=request_header,\n            json=request_body,\n        )\n\n        return self.get_body(response)\n\n    def compose_url(self, path):\n        return self.DEFAULT_BASE_URL + path + \"?\" + \"key=\" + self.key\n\n    @staticmethod\n    def get_body(response):\n        body = response.json()\n\n        if \"error\" in body:\n            return body[\"error\"]\n\n        return body\n\n    @staticmethod\n    def compose_header():\n        return {\n            \"Content-Type\": \"application/json\",\n        }\n```", "```py\ndef current_conditions(\n    client,\n    location,\n    include_local_AQI=True,\n    include_health_suggestion=False,\n    include_all_pollutants=True,\n    include_additional_pollutant_info=False,\n    include_dominent_pollutant_conc=True,\n    language=None,\n):\n    \"\"\"\n    See documentation for this API here\n    https://developers.google.com/maps/documentation/air-quality/reference/rest/v1/currentConditions/lookup\n    \"\"\"\n    params = {}\n\n    if isinstance(location, dict):\n        params[\"location\"] = location\n    else:\n        raise ValueError(\n            \"Location argument must be a dictionary containing latitude and longitude\"\n        )\n\n    extra_computations = []\n    if include_local_AQI:\n        extra_computations.append(\"LOCAL_AQI\")\n\n    if include_health_suggestion:\n        extra_computations.append(\"HEALTH_RECOMMENDATIONS\")\n\n    if include_additional_pollutant_info:\n        extra_computations.append(\"POLLUTANT_ADDITIONAL_INFO\")\n\n    if include_all_pollutants:\n        extra_computations.append(\"POLLUTANT_CONCENTRATION\")\n\n    if include_dominent_pollutant_conc:\n        extra_computations.append(\"DOMINANT_POLLUTANT_CONCENTRATION\")\n\n    if language:\n        params[\"language\"] = language\n\n    params[\"extraComputations\"] = extra_computations\n\n    return client.request_post(\"/v1/currentConditions:lookup\", params)\n```", "```py\n# set up client\nclient = Client(key=GOOGLE_MAPS_API_KEY)\n# a location in Los Angeles, CA\nlocation = {\"longitude\":-118.3,\"latitude\":34.1}\n# a JSON response\ncurrent_conditions_data = current_conditions(\n  client,\n  location,\n  include_health_suggestion=True,\n  include_additional_pollutant_info=True\n)\n```", "```py\n{'dateTime': '2023-10-12T05:00:00Z',\n 'regionCode': 'us',\n 'indexes': [{'code': 'uaqi',\n   'displayName': 'Universal AQI',\n   'aqi': 60,\n   'aqiDisplay': '60',\n   'color': {'red': 0.75686276, 'green': 0.90588236, 'blue': 0.09803922},\n   'category': 'Good air quality',\n   'dominantPollutant': 'pm10'},\n  {'code': 'usa_epa',\n   'displayName': 'AQI (US)',\n   'aqi': 39,\n   'aqiDisplay': '39',\n   'color': {'green': 0.89411765},\n   'category': 'Good air quality',\n   'dominantPollutant': 'pm10'}],\n 'pollutants': [{'code': 'co',\n   'displayName': 'CO',\n   'fullName': 'Carbon monoxide',\n   'concentration': {'value': 292.61, 'units': 'PARTS_PER_BILLION'},\n   'additionalInfo': {'sources': 'Typically originates from incomplete combustion of carbon fuels, such as that which occurs in car engines and power plants.',\n    'effects': 'When inhaled, carbon monoxide can prevent the blood from carrying oxygen. Exposure may cause dizziness, nausea and headaches. Exposure to extreme concentrations can lead to loss of consciousness.'}},\n  {'code': 'no2',\n   'displayName': 'NO2',\n   'fullName': 'Nitrogen dioxide',\n   'concentration': {'value': 22.3, 'units': 'PARTS_PER_BILLION'},\n   'additionalInfo': {'sources': 'Main sources are fuel burning processes, such as those used in industry and transportation.',\n    'effects': 'Exposure may cause increased bronchial reactivity in patients with asthma, lung function decline in patients with Chronic Obstructive Pulmonary Disease (COPD), and increased risk of respiratory infections, especially in young children.'}},\n  {'code': 'o3',\n   'displayName': 'O3',\n   'fullName': 'Ozone',\n   'concentration': {'value': 24.17, 'units': 'PARTS_PER_BILLION'},\n   'additionalInfo': {'sources': 'Ozone is created in a chemical reaction between atmospheric oxygen, nitrogen oxides, carbon monoxide and organic compounds, in the presence of sunlight.',\n    'effects': 'Ozone can irritate the airways and cause coughing, a burning sensation, wheezing and shortness of breath. Additionally, ozone is one of the major components of photochemical smog.'}},\n  {'code': 'pm10',\n   'displayName': 'PM10',\n   'fullName': 'Inhalable particulate matter (<10µm)',\n   'concentration': {'value': 44.48, 'units': 'MICROGRAMS_PER_CUBIC_METER'},\n   'additionalInfo': {'sources': 'Main sources are combustion processes (e.g. indoor heating, wildfires), mechanical processes (e.g. construction, mineral dust, agriculture) and biological particles (e.g. pollen, bacteria, mold).',\n    'effects': 'Inhalable particles can penetrate into the lungs. Short term exposure can cause irritation of the airways, coughing, and aggravation of heart and lung diseases, expressed as difficulty breathing, heart attacks and even premature death.'}},\n  {'code': 'pm25',\n   'displayName': 'PM2.5',\n   'fullName': 'Fine particulate matter (<2.5µm)',\n   'concentration': {'value': 11.38, 'units': 'MICROGRAMS_PER_CUBIC_METER'},\n   'additionalInfo': {'sources': 'Main sources are combustion processes (e.g. power plants, indoor heating, car exhausts, wildfires), mechanical processes (e.g. construction, mineral dust) and biological particles (e.g. bacteria, viruses).',\n    'effects': 'Fine particles can penetrate into the lungs and bloodstream. Short term exposure can cause irritation of the airways, coughing and aggravation of heart and lung diseases, expressed as difficulty breathing, heart attacks and even premature death.'}},\n  {'code': 'so2',\n   'displayName': 'SO2',\n   'fullName': 'Sulfur dioxide',\n   'concentration': {'value': 0, 'units': 'PARTS_PER_BILLION'},\n   'additionalInfo': {'sources': 'Main sources are burning processes of sulfur-containing fuel in industry, transportation and power plants.',\n    'effects': 'Exposure causes irritation of the respiratory tract, coughing and generates local inflammatory reactions. These in turn, may cause aggravation of lung diseases, even with short term exposure.'}}],\n 'healthRecommendations': {'generalPopulation': 'With this level of air quality, you have no limitations. Enjoy the outdoors!',\n  'elderly': 'If you start to feel respiratory discomfort such as coughing or breathing difficulties, consider reducing the intensity of your outdoor activities. Try to limit the time you spend near busy roads, construction sites, open fires and other sources of smoke.',\n  'lungDiseasePopulation': 'If you start to feel respiratory discomfort such as coughing or breathing difficulties, consider reducing the intensity of your outdoor activities. Try to limit the time you spend near busy roads, industrial emission stacks, open fires and other sources of smoke.',\n  'heartDiseasePopulation': 'If you start to feel respiratory discomfort such as coughing or breathing difficulties, consider reducing the intensity of your outdoor activities. Try to limit the time you spend near busy roads, construction sites, industrial emission stacks, open fires and other sources of smoke.',\n  'athletes': 'If you start to feel respiratory discomfort such as coughing or breathing difficulties, consider reducing the intensity of your outdoor activities. Try to limit the time you spend near busy roads, construction sites, industrial emission stacks, open fires and other sources of smoke.',\n  'pregnantWomen': 'To keep you and your baby healthy, consider reducing the intensity of your outdoor activities. Try to limit the time you spend near busy roads, construction sites, open fires and other sources of smoke.',\n  'children': 'If you start to feel respiratory discomfort such as coughing or breathing difficulties, consider reducing the intensity of your outdoor activities. Try to limit the time you spend near busy roads, construction sites, open fires and other sources of smoke.'}}\n```", "```py\n def request_post(self,url,params):\n\n    request_url = self.compose_url(url)\n    request_header = self.compose_header()\n    request_body = params\n\n    response = self.session.post(\n      request_url,\n      headers=request_header,\n      json=request_body,\n    )\n\n    response_body = self.get_body(response)\n\n    # put the first page in the response dictionary\n    page = 1\n    final_response = {\n        \"page_{}\".format(page) : response_body\n    }\n    # fetch all the pages if needed \n    while \"nextPageToken\" in response_body:\n      # call again with the next page's token\n      request_body.update({\n          \"pageToken\":response_body[\"nextPageToken\"]\n      })\n      response = self.session.post(\n          request_url,\n          headers=request_header,\n          json=request_body,\n      )\n      response_body = self.get_body(response)\n      page += 1\n      final_response[\"page_{}\".format(page)] = response_body\n\n    return final_response\n```", "```py\ndef historical_conditions(\n    client,\n    location,\n    specific_time=None,\n    lag_time=None,\n    specific_period=None,\n    include_local_AQI=True,\n    include_health_suggestion=False,\n    include_all_pollutants=True,\n    include_additional_pollutant_info=False,\n    include_dominant_pollutant_conc=True,\n    language=None,\n):\n    \"\"\"\n    See documentation for this API here https://developers.google.com/maps/documentation/air-quality/reference/rest/v1/history/lookup\n    \"\"\"\n    params = {}\n\n    if isinstance(location, dict):\n        params[\"location\"] = location\n    else:\n        raise ValueError(\n            \"Location argument must be a dictionary containing latitude and longitude\"\n        )\n\n    if isinstance(specific_period, dict) and not specific_time and not lag_time:\n        assert \"startTime\" in specific_period\n        assert \"endTime\" in specific_period\n\n        params[\"period\"] = specific_period\n\n    elif specific_time and not lag_time and not isinstance(specific_period, dict):\n        # note that time must be in the \"Zulu\" format\n        # e.g. datetime.datetime.strftime(datetime.datetime.now(),\"%Y-%m-%dT%H:%M:%SZ\")\n        params[\"dateTime\"] = specific_time\n\n    # lag periods in hours\n    elif lag_time and not specific_time and not isinstance(specific_period, dict):\n        params[\"hours\"] = lag_time\n\n    else:\n        raise ValueError(\n            \"Must provide specific_time, specific_period or lag_time arguments\"\n        )\n\n    extra_computations = []\n    if include_local_AQI:\n        extra_computations.append(\"LOCAL_AQI\")\n\n    if include_health_suggestion:\n        extra_computations.append(\"HEALTH_RECOMMENDATIONS\")\n\n    if include_additional_pollutant_info:\n        extra_computations.append(\"POLLUTANT_ADDITIONAL_INFO\")\n\n    if include_all_pollutants:\n        extra_computations.append(\"POLLUTANT_CONCENTRATION\")\n\n    if include_dominant_pollutant_conc:\n        extra_computations.append(\"DOMINANT_POLLUTANT_CONCENTRATION\")\n\n    if language:\n        params[\"language\"] = language\n\n    params[\"extraComputations\"] = extra_computations\n    # page size default set to 100 here\n    params[\"pageSize\"] = 100\n    # page token will get filled in if needed by the request_post method\n    params[\"pageToken\"] = \"\"\n\n    return client.request_post(\"/v1/history:lookup\", params)\n```", "```py\n# set up client\nclient = Client(key=GOOGLE_MAPS_API_KEY)\n# a location in Los Angeles, CA\nlocation = {\"longitude\":-118.3,\"latitude\":34.1}\n# a JSON response\nhistory_conditions_data = historical_conditions(\n    client,\n    location,\n    lag_time=720\n)\n```", "```py\nfrom itertools import chain\nimport pandas as pd\n\ndef historical_conditions_to_df(response_dict):\n\n  chained_pages = list(chain(*[response_dict[p][\"hoursInfo\"] for p in [*response_dict]]))\n\n  all_indexes = []\n  all_pollutants = []\n  for i in range(len(chained_pages)):\n    # need this check in case one of the timestamps is missing data, which can sometimes happen\n    if \"indexes\" in chained_pages[i]:\n      this_element = chained_pages[i]\n      # fetch the time\n      time = this_element[\"dateTime\"]\n      # fetch all the index values and add metadata\n      all_indexes += [(time , x[\"code\"],x[\"displayName\"],\"index\",x[\"aqi\"],None) for x in this_element['indexes']]\n      # fetch all the pollutant values and add metadata\n      all_pollutants += [(time , x[\"code\"],x[\"fullName\"],\"pollutant\",x[\"concentration\"][\"value\"],x[\"concentration\"][\"units\"]) for x in this_element['pollutants']]\n\n  all_results = all_indexes + all_pollutants\n  # generate \"long format\" dataframe\n  res = pd.DataFrame(all_results,columns=[\"time\",\"code\",\"name\",\"type\",\"value\",\"unit\"])\n  res[\"time\"]=pd.to_datetime(res[\"time\"])\n  return res\n```", "```py\ndf = historical_conditions_to_df(history_conditions_data)\n```", "```py\nimport seaborn as sns\ng = sns.relplot(\n    x=\"time\",\n    y=\"value\",\n    data=df[df[\"code\"].isin([\"uaqi\",\"usa_epa\",\"pm25\",\"pm10\"])],\n    kind=\"line\",\n    col=\"name\",\n    col_wrap=4,\n    hue=\"type\",\n    height=4,\n    facet_kws={'sharey': False, 'sharex': False}\n)\ng.set_xticklabels(rotation=90)\n```", "```py\nGET https://airquality.googleapis.com/v1/mapTypes/{mapType}/heatmapTiles/{zoom}/{x}/{y}\n```", "```py\n def request_get(self,url):\n\n    request_url = self.compose_url(url)\n    response = self.session.get(request_url)\n\n    # for images coming from the heatmap tiles service\n    return self.get_image(response)\n\n  @staticmethod\n  def get_image(response):\n\n    if response.status_code == 200:\n      image_content = response.content\n      # note use of Image from PIL here\n      # needs from PIL import Image\n      image = Image.open(io.BytesIO(image_content))\n      return image\n    else:\n      print(\"GET request for image returned an error\")\n      return None\n```", "```py\nimport math\nimport numpy as np\n\nclass TileHelper(object):\n\n  def __init__(self, tile_size=256):\n\n    self.tile_size = tile_size\n\n  def location_to_tile_xy(self,location,zoom_level=4):\n\n    # Based on function here\n    # https://developers.google.com/maps/documentation/javascript/examples/map-coordinates#maps_map_coordinates-javascript\n\n    lat = location[\"latitude\"]\n    lon = location[\"longitude\"]\n\n    world_coordinate = self._project(lat,lon)\n    scale = 1 << zoom_level\n\n    pixel_coord = (math.floor(world_coordinate[0]*scale), math.floor(world_coordinate[1]*scale))\n    tile_coord = (math.floor(world_coordinate[0]*scale/self.tile_size),math.floor(world_coordinate[1]*scale/self.tile_size))\n\n    return world_coordinate, pixel_coord, tile_coord\n\n  def tile_to_bounding_box(self,tx,ty,zoom_level):\n\n    # see https://developers.google.com/maps/documentation/javascript/coordinates\n    # for details\n    box_north = self._tiletolat(ty,zoom_level)\n    # tile numbers advance towards the south\n    box_south = self._tiletolat(ty+1,zoom_level)\n    box_west = self._tiletolon(tx,zoom_level)\n    # time numbers advance towards the east\n    box_east = self._tiletolon(tx+1,zoom_level)\n\n    # (latmin, latmax, lonmin, lonmax)\n    return (box_south, box_north, box_west, box_east)\n\n  @staticmethod\n  def _tiletolon(x,zoom):\n    return x / math.pow(2.0,zoom) * 360.0 - 180.0\n\n  @staticmethod\n  def _tiletolat(y,zoom):\n    n = math.pi - (2.0 * math.pi * y)/math.pow(2.0,zoom)\n    return math.atan(math.sinh(n))*(180.0/math.pi)\n\n  def _project(self,lat,lon):\n\n    siny = math.sin(lat*math.pi/180.0)\n    siny = min(max(siny,-0.9999), 0.9999)\n\n    return (self.tile_size*(0.5 + lon/360), self.tile_size*(0.5 - math.log((1 + siny) / (1 - siny)) / (4 * math.pi)))\n\n  @staticmethod\n  def find_nearest_corner(location,bounds):\n\n    corner_lat_idx = np.argmin([\n        np.abs(bounds[0]-location[\"latitude\"]),\n        np.abs(bounds[1]-location[\"latitude\"])\n        ])\n\n    corner_lon_idx = np.argmin([\n        np.abs(bounds[2]-location[\"longitude\"]),\n        np.abs(bounds[3]-location[\"longitude\"])\n        ])\n\n    if (corner_lat_idx == 0) and (corner_lon_idx == 0):\n      # closests is latmin, lonmin\n      direction = \"southwest\"\n    elif (corner_lat_idx == 0) and (corner_lon_idx == 1):\n      direction = \"southeast\"\n    elif (corner_lat_idx == 1) and (corner_lon_idx == 0):\n      direction = \"northwest\"\n    else:\n      direction = \"northeast\"\n\n    corner_coords = (bounds[corner_lat_idx],bounds[corner_lon_idx+2])\n    return corner_coords, direction\n\n  @staticmethod\n  def get_ajoining_tiles(tx,ty,direction):\n\n    if direction == \"southwest\":\n      return [(tx-1,ty),(tx-1,ty+1),(tx,ty+1)]\n    elif direction == \"southeast\":\n      return [(tx+1,ty),(tx+1,ty-1),(tx,ty-1)]\n    elif direction == \"northwest\":\n      return [(tx-1,ty-1),(tx-1,ty),(tx,ty-1)]\n    else:\n      return [(tx+1,ty-1),(tx+1,ty),(tx,ty-1)]\n```", "```py\ndef air_quality_tile(\n    client,\n    location,\n    pollutant=\"UAQI_INDIGO_PERSIAN\",\n    zoom=4,\n    get_adjoining_tiles = True\n\n):\n\n  # see https://developers.google.com/maps/documentation/air-quality/reference/rest/v1/mapTypes.heatmapTiles/lookupHeatmapTile\n\n  assert pollutant in [\n      \"UAQI_INDIGO_PERSIAN\",\n      \"UAQI_RED_GREEN\",\n      \"PM25_INDIGO_PERSIAN\",\n      \"GBR_DEFRA\",\n      \"DEU_UBA\",\n      \"CAN_EC\",\n      \"FRA_ATMO\",\n      \"US_AQI\"\n  ]\n\n  # contains useful methods for dealing the tile coordinates\n  helper = TileHelper()\n\n  # get the tile that the location is in\n  world_coordinate, pixel_coord, tile_coord = helper.location_to_tile_xy(location,zoom_level=zoom)\n\n  # get the bounding box of the tile\n  bounding_box = helper.tile_to_bounding_box(tx=tile_coord[0],ty=tile_coord[1],zoom_level=zoom)\n\n  if get_adjoining_tiles:\n    nearest_corner, nearest_corner_direction = helper.find_nearest_corner(location, bounding_box)\n    adjoining_tiles = helper.get_ajoining_tiles(tile_coord[0],tile_coord[1],nearest_corner_direction)\n  else:\n    adjoining_tiles = []\n\n  tiles = []\n  #get all the adjoining tiles, plus the one in question\n  for tile in adjoining_tiles + [tile_coord]:\n\n    bounding_box = helper.tile_to_bounding_box(tx=tile[0],ty=tile[1],zoom_level=zoom)\n    image_response = client.request_get(\n        \"/v1/mapTypes/\" + pollutant + \"/heatmapTiles/\" + str(zoom) + '/' + str(tile[0]) + '/' + str(tile[1])\n    )\n\n    # convert the PIL image to numpy\n    try:\n      image_response = np.array(image_response)\n    except:\n      image_response = None\n\n    tiles.append({\n        \"bounds\":bounding_box,\n        \"image\":image_response\n    })\n\n  return tiles \n```", "```py\nclient = Client(key=GOOGLE_MAPS_API_KEY)\nlocation = {\"longitude\":-118.3,\"latitude\":34.1}\nzoom = 7\ntiles = air_quality_tile(\n    client,\n    location,\n    pollutant=\"UAQI_INDIGO_PERSIAN\",\n    zoom=zoom,\n    get_adjoining_tiles=False)\n```", "```py\nimport leafmap.foliumap as leafmap\nimport folium\n\nlat = location[\"latitude\"]\nlon = location[\"longitude\"]\n\nmap = leafmap.Map(location=[lat, lon], tiles=\"OpenStreetMap\", zoom_start=zoom)\n\nfor tile in tiles:\n  latmin, latmax, lonmin, lonmax = tile[\"bounds\"]\n  AQ_image = tile[\"image\"]\n  folium.raster_layers.ImageOverlay(\n    image=AQ_image,\n    bounds=[[latmin, lonmin], [latmax, lonmax]],\n    opacity=0.7\n  ).add_to(map)\n```"]