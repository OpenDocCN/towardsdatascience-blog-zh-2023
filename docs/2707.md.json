["```py\n# Import neccesary packages/libraries:\nfrom iguanas.rule_generation import RuleGeneratorDT, RuleGeneratorOpt\nfrom iguanas.rule_optimisation import BayesianOptimiser\nfrom iguanas.metrics.classification import FScore, Precision\nfrom iguanas.metrics.pairwise import JaccardSimilarity\nfrom iguanas.rules import Rules, ConvertProcessedConditionsToGeneral, ReturnMappings\nfrom iguanas.correlation_reduction import AgglomerativeClusteringReducer\nfrom iguanas.rule_selection import SimpleFilter, GreedyFilter, CorrelatedFilter\nfrom iguanas.rbs import RBSPipeline, RBSOptimiser\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay, classification_report\nfrom sklearn.ensemble import RandomForestClassifier\nfrom category_encoders.one_hot import OneHotEncoder\nimport seaborn as sns\nimport pandas as pd\nimport numpy as np\n\n# Create empty dataframe:\ndf = pd.DataFrame(columns=['length (m)',\n                           'diameter (cm)',\n                           'thickness (mm)',\n                           'num welds', \n                           'num bends', \n                           'corrosion', \n                           'violation'])\n\n# Total number of datapoints in generated dataset:\ndatapoints = 100000\nnp.random.seed(10)\n\n# Min/Max length of pipe\nmin_len = 1\nmax_len = 20\n\n# Min/Max diameter of pipe\nmin_dim = 1\nmax_dim = 10\n\n# Min/Max measured wall thickness of pipe\nmin_thick = 1\nmax_thick = 10\n\n# Min/Max number of welds\nmin_welds = 0\nmax_welds = 10\n\n# Min/Max number of bends\nmin_bends = 0\nmax_bends = 5\n\nlength = np.random.randint(min_len,max_len,datapoints)\ndiameter = np.random.randint(min_dim,max_dim,datapoints)\nthickness = np.random.randint(min_thick,max_thick,datapoints)\nnum_welds = np.random.randint(min_welds,max_welds,datapoints)\nnum_bends = np.random.randint(min_bends,max_bends,datapoints)\n\n# Generate categorical variable for corrosion: 80% probability for \"None\",\n# 15% for \"Light\" and 5% for \"Severe\"\ncorrosion = np.random.choice(a=['None', 'Light', 'Severe'],\n                             size=datapoints,\n                             p=[0.8, 0.15, 0.05])\n\n# Add generated variables to dataframe: \ndf['length (m)'] = length\ndf['diameter (cm)'] = diameter\ndf['thickness (mm)'] = thickness\ndf['num welds'] = num_welds\ndf['num bends'] = num_bends\ndf['corrosion'] = corrosion\n```", "```py\nrule_1 = pd.DataFrame((df['diameter (cm)'] >= 8) & (df['thickness (mm)'] <= 2))\nrule_2 = pd.DataFrame((df['corrosion']=='Severe') & (df['thickness (mm)'] <= 5))\nrule_3 = pd.DataFrame((df['length (m)'] > 10) & (df['num welds'] == 0))\nrule_4 = pd.DataFrame((df['num bends'] > 0) & (df['num welds'] == 0) & (df['diameter (cm)'] >=5))\n\ndf['violation'] = rule_1 | rule_2 | rule_3 | rule_4\n\ndf.head()\ndf[df['violation'] ==True].head()\n```", "```py\ntarget_column = 'violation'\nX = df.drop(\n    target_column,\n    axis=1\n)\ny = df[target_column]\n\nX_train, X_test, y_train, y_test = train_test_split(\n    X,\n    y,\n    test_size=0.2,\n    random_state=0\n)\n```", "```py\nohe = OneHotEncoder(use_cat_names=True)\nohe.fit(X_train)\nX_train = ohe.transform(X_train)\nX_test = ohe.transform(X_test)\n```", "```py\n# Define metrics: F-score and precision\np = Precision()\nf1 = FScore(beta=1)\n\n# Define parameters for RuleGeneratorDT\nparams_RG_DT = {\n    'metric': f1.fit,\n    'n_total_conditions': 4,\n    'tree_ensemble': RandomForestClassifier(n_estimators=10, random_state=0),\n    'target_feat_corr_types': 'Infer',\n    'num_cores': -1,\n    'verbose': 1\n}\n\n#params_RG_OPT = {\n#    'metric': f1.fit,\n#    'n_total_conditions': 4,\n#    'num_rules_keep': 1000,\n#    'n_points': 100,\n#    'ratio_window': 1,\n#    'remove_corr_rules': True,\n#    'target_feat_corr_types': 'Infer',\n#    'verbose': 1\n#}\n\n# Instantiate and fit RuleGeneratorDT\nrg = RuleGeneratorDT(**params_RG_DT)\nX_rules_gen_train = rg.fit(\n    X=X_train,\n    y=y_train\n)\n```", "```py\n# Apply SimpleFilter\nfr = SimpleFilter(\n    threshold=0.3,\n    operator='>=',\n    metric=f1.fit,\n)\nX_rules_train = fr.fit_transform(\n    X_rules=X_rules_gen_train,\n    y=y_train\n)\n\n# Apply CorrelatedFilter\njs = JaccardSimilarity()\nacfr = AgglomerativeClusteringReducer(\n    threshold=0.7,\n    strategy='bottom_up',\n    similarity_function=js.fit,\n    metric=f1.fit\n)\nfcr = CorrelatedFilter(correlation_reduction_class=acfr)\nX_rules_train = fcr.fit_transform(\n    X_rules=X_rules_train,\n    y=y_train\n)\n\n# Apply GreedyFilter\ngf = GreedyFilter(\n    metric=f1.fit,\n    sorting_metric=p.fit,\n    verbose=1\n)\n\nX_rules_train = gf.fit_transform(\n    X_rules=X_rules_train,\n    y=y_train\n)\n\ngf.plot_top_n_performance_on_train()\n```", "```py\n# Define RBSPipeline configuration\nconfig = [\n   (1, X_rules_train.columns.tolist())\n]\n\n# Define final decision\nfinal_decision = 0\n\n# Instantiate RBSPipeline\nrbsp = RBSPipeline(\n    config=config,\n    final_decision=final_decision\n)\n\n# Optimize RBSPipeline using RBSOptimiser\nrbso = RBSOptimiser(\n    pipeline=rbsp,\n    metric=f1.fit,\n    n_iter=1000,\n    verbose=1\n)\npipe_pred_train = rbso.fit_predict(\n    X_rules=X_rules_train,\n    y=y_train\n)\n```", "```py\n# Evaluate performance using classification_report and confusion_matrix\nprint(\n    classification_report(\n        y_true=y_train,\n        y_pred=pipe_pred_train,\n        digits=2\n    )\n)\n\nsns.set_style('white')\ncm = ConfusionMatrixDisplay(\n    confusion_matrix(\n        y_true=y_train,\n        y_pred=pipe_pred_train,\n        normalize='true'\n    )\n\n)\ncm.plot()\n```", "```py\nrg.filter_rules(include=rbs_rule_names_gen)\nrg.rule_strings\n```", "```py\n{'RGDT_Rule_20220214_43': \"(X['corrosion_Severe']==True)&(X['thickness (mm)']<=5)\",\n 'RGDT_Rule_20220214_47': \"(X['diameter (cm)']>=5)&(X['num bends']>=1)&(X['num welds']<=0)\",\n 'RGDT_Rule_20220214_58': \"(X['diameter (cm)']>=8)&(X['thickness (mm)']<=2)\",\n 'RGDT_Rule_20220214_60': \"(X['length (m)']>=11)&(X['num welds']<=0)\"}\n```", "```py\n# Generated rules\nX_rules_test = rg.transform(X=X_test)\n\n# Apply our optimised RBS Pipeline to the test set:\nopt_pipe_pred_test = rbso.predict(X_rules=X_rules_test)\n\n# Print classification report and confusion matrix:\nprint(\n    classification_report(\n        y_true=y_test,\n        y_pred=opt_pipe_pred_test,\n        digits=2\n    )\n)\n\ncm = ConfusionMatrixDisplay(\n    confusion_matrix(\n        y_true=y_test,\n        y_pred=opt_pipe_pred_test,\n        normalize='true'\n    )\n)\ncm.plot()\n```"]