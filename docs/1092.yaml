- en: How to use Cypher Aggregations in Neo4j Graph Data Science library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/how-to-use-cypher-aggregations-in-neo4j-graph-data-science-library-5d8c40c2670c?source=collection_archive---------11-----------------------#2023-03-27](https://towardsdatascience.com/how-to-use-cypher-aggregations-in-neo4j-graph-data-science-library-5d8c40c2670c?source=collection_archive---------11-----------------------#2023-03-27)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Leverage Cypher Aggregation feature to project in-memory graphs using all the
    flexibility and expressiveness of Cypher query language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://bratanic-tomaz.medium.com/?source=post_page-----5d8c40c2670c--------------------------------)[![Tomaz
    Bratanic](../Images/d5821aa70918fcb3fc1ff0013497b3d5.png)](https://bratanic-tomaz.medium.com/?source=post_page-----5d8c40c2670c--------------------------------)[](https://towardsdatascience.com/?source=post_page-----5d8c40c2670c--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----5d8c40c2670c--------------------------------)
    [Tomaz Bratanic](https://bratanic-tomaz.medium.com/?source=post_page-----5d8c40c2670c--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F57f13c0ea39a&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-to-use-cypher-aggregations-in-neo4j-graph-data-science-library-5d8c40c2670c&user=Tomaz+Bratanic&userId=57f13c0ea39a&source=post_page-57f13c0ea39a----5d8c40c2670c---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----5d8c40c2670c--------------------------------)
    ·7 min read·Mar 27, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F5d8c40c2670c&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-to-use-cypher-aggregations-in-neo4j-graph-data-science-library-5d8c40c2670c&user=Tomaz+Bratanic&userId=57f13c0ea39a&source=-----5d8c40c2670c---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F5d8c40c2670c&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-to-use-cypher-aggregations-in-neo4j-graph-data-science-library-5d8c40c2670c&source=-----5d8c40c2670c---------------------bookmark_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: Cypher Aggregation is a powerful feature of the Neo4j Graph Data Science library
    that allows users to project an in-memory graph using a flexible and expressive
    approach. While it was possible to use Cypher statements to project an in-memory
    graph for quite some time using Cypher Projection, it lacked some features, most
    notably the ability to project undirected relationships. Therefore, a new approach
    to projecting an in-memory graph in GDS was added called Cypher Aggregation. This
    blog post will explore the syntax and common usage of the Cypher Aggregation projection
    option in the Neo4j Graph Data Science Library.
  prefs: []
  type: TYPE_NORMAL
- en: Environment setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to follow along with the examples, you can open a [Graph Data Science
    project in Neo4j Sandbox](https://sandbox.neo4j.com/?usecase=graph-data-science2).
    The project has a small dataset containing information about airports, their locations,
    and flight routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can visualize the graph schema with the following Cypher statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/4acad275cd607ceb29bbfb61ae524cd1.png)'
  prefs: []
  type: TYPE_IMG
- en: Graph schema. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: Projecting in-memory graphs with Cypher aggregation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let’s quickly revisit how the Neo4j Graph Data Science library operates.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c329d740ce532c99b5eb95d5c9075543.png)'
  prefs: []
  type: TYPE_IMG
- en: Graph Data Science library workflow. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can execute any graph algorithms, we first have to project an in-memory
    graph. The in-memory graph does not have to be an exact copy of the stored graph
    in the database. We have the ability to select only a subset of graph, or as you
    will learn later also project virtual relationships that are not stored in the
    database. After the in-memory graph is projected, we have can execute how many
    graph algorithms we want, and then either stream the results directly to the user,
    or write them back to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Projecting an in-memory graph with Cypher Aggregation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cypher Aggregation feature is part of the first step in Graph Data Science
    workflow, which is projecting an in-memory graph. It offers full flexibility of
    Cypher query language to select, filter, or transform a graph during projection.
    The syntax of the Cypher Aggregation function is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Only the first two parameters (graphName as sourceNode) are mandatory, however,
    you need to specify both the sourceNode and relationshipNode parameters to define
    a single relationship. We will walk through most of the options you might need
    to help you project graphs with Cypher Aggregation.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with a simple example. Let’s say we want to project all **Airport**
    nodes and the **HAS_ROUTE** relationship between them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The Cypher statements starts with a MATCH clause that selects the relevant graph.
    To define a relationship with Cypher Aggregation, we input both the **source**
    and **target** node.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the Cypher query language offers flexibility to select any subset
    of the graph. So, for example, we could project only airports in the Oceania content
    and their flight routes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The matching Cypher statement became slightly more complicated in this example,
    but the Cypher Aggregation function stayed the same. The **airports-oceania**
    graph contains 272 nodes and 973 relationships. If you are experienced with Cypher,
    you might notice that the above Cypher statement will not capture any airports
    in Oceania that don’t have flight routes with other airports in Oceania.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want to project isolated airports in the projection as well. In that
    case, we need to modify the Cypher matching statement slightly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The relationship count remains identical, while the node count has increased
    to 304\. Therefore, 32 airports in Oceania don’t have any flight routes to other
    airports in Oceania.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with multiple node and relationship types in a graph, we might
    want to retain information about node labels and relationship types during projection.
    Defining the node and relationship types during graph projection allows us to
    filter them at algorithm execution time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: I prefer using `UNION` clause when projecting multiple different graph patterns.
    However, what Cypher matching statement is entirely up to you. Since we are projecting
    two types of nodes and relationships, it is probably a good idea to retain the
    information about their labels and types. Therefore, we are using the **sourceNodeLabels**,
    **targetNodeLabels**, and **relationshipType** parameters. In this example, we
    use the existing node labels and relationship types.
  prefs: []
  type: TYPE_NORMAL
- en: However, sometimes we might want to use custom labels or relationship types
    during projection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we can use Cypher to dynamically define the node or relationship
    type or simply hardcode it. The custom node label or relationship type can also
    be calculated in the Cypher matching statement if it is more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, we also want to project node or relationship properties.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The node or relationship properties are defined as a map object (dictionary
    or JSON object for Python or JS developers), where the key represents the projected
    property, and the value represents the projected value. This syntax allows us
    to project properties that are calculated during projection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Again, we can use all the flexibility of Cypher to calculate any node or relationship
    properties. Similary as with node labels, we can also calculate the custom properties
    in the `MATCH` clause.
  prefs: []
  type: TYPE_NORMAL
- en: An important thing to note is that the current projection behavior is that the
    engine stores the node properties when it first encounters a node. However, on
    subsequent encounters of the same node, it ignores the node properties completely.
    Therefore, you have to be careful to calculate identical node properties for both
    source and target nodes. Otherwise, there may be discrepancies between what is
    projected and what you expect.
  prefs: []
  type: TYPE_NORMAL
- en: Some graph algorithms in the Neo4j Graph Data Science library expect undirected
    relationships. A relationship cannot be stored as undirected in the database and
    must be explicitly defined during graph projection.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you want to treat all projected relationships as undirected.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We can use the **undirectedRelationshipType** to specify which relationships
    should be projected as undirected. In practice, you can observe that the relationship
    count doubled when we projected an undirected graph.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you might want to project a single relationship type as undirected
    while treating the other as directed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the **HAS_ROUTE** relationship is treated as directed, while
    the **IN_CITY** relationship is treated as undirected. When we want to specify
    specific relationship types to be treated as undirected, we must include the **relationshipType**
    parameter in the relationship configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we can also project virtual relationships. A virtual relationship is
    a relationship that is not stored in the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/15a13565efa295f5ce25b7d9ed4b6020.png)'
  prefs: []
  type: TYPE_IMG
- en: Virtual relationship. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you want to examine the cities based on their flight connections. The
    database doesn’t have flight relationships between cities. Instead of creating
    the relationships in the database, you can calculate them during graph projection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can observe, projecting virtual relationships is very easy with Cypher
    Aggregation projection. We have calculated the count of routes between various
    cities and added it as a relationship property in the projected graph.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s calculate the most important cities based on the PageRank algorithm to
    finish off this blog post.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Results*'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cypher Aggregation is the newer option to project in-memory graphs in the Neo4j
    Graph Data Science library using Cypher statements. Specifically, it can be used
    to project undirected relationships, which is impossible with the older Cypher
    Projection. However, with the added flexibility of selecting and transforming
    graphs during projection comes a performance cost. Therefore, if you can, you
    should use Native Projection when possible for performance reasons. On the other
    hand, when you have specific use cases to project a particular subset of a graph,
    calculate custom properties or project virtual relationships, Cypher Aggregation
    is your friend.
  prefs: []
  type: TYPE_NORMAL
