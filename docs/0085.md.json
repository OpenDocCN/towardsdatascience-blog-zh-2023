["```py\nCREATE TABLE meetings(\n  idx SERIAL PRIMARY KEY,\n  start_at TIMESTAMP NOT NULL,\n  end_at TIMESTAMP NOT NULL\n);\n```", "```py\nINSERT INTO meetings(start_at, end_at) VALUES\n-- { 1, 18 }, { 18, 23 }, { 15, 29 }, {4, 15}, {2, 11}, {5, 13} \n('01/01/2022', '01/18/2022'),\n('01/18/2022', '01/23/2022'),\n('01/15/2022', '01/29/2022'),\n('01/04/2022', '01/15/2022'),\n('01/02/2022', '01/11/2022'),\n('01/05/2022', '01/13/2022');\n\nSELECT * FROM meetings;\n```", "```py\nWITH unique_time_points AS (\n  SELECT ts\n  FROM (\n    SELECT start_at AS ts\n    FROM meetings\n\n    UNION\n\n    SELECT end_at AS ts\n    FROM meetings\n  ) AS start_and_end_ts\n),\n\njoined AS (\n  SELECT\n    lhs.ts, COUNT(rhs.idx) AS num_overlaps\n  FROM unique_time_points lhs INNER JOIN meetings rhs\n  -- Join condition checks how many scheduled meetings intersect\n  -- the point \"ts\".\n  ON lhs.ts BETWEEN rhs.start_at AND rhs.end_at\n  GROUP BY lhs.ts\n  ORDER BY lhs.ts ASC\n)\n\nSELECT * FROM joined;\n```", "```py\nWITH unique_time_points AS (\n  SELECT start_at AS ts, +1 AS delta\n  FROM meetings\n\n  UNION\n\n  SELECT end_at AS ts, -1 AS delta\n  FROM meetings\n),\n\nwith_running_sum AS (\n  SELECT\n    ts,\n    delta,\n    -- We need to process time points in \"ts\" order. Also in case\n    -- there are multiple time points, we need to first process a\n    -- meeting start and then a meeting end since a meeting end is\n    -- assumed to occupy its end timepoint. This ensures that we\n    -- don't under-count the number of simultaneously scheduled\n    -- meetings.\n    SUM(delta) OVER (ORDER BY ts ASC, delta DESC) AS running_sum\n  FROM unique_time_points\n)\n\nSELECT * FROM with_running_sum;\n```"]