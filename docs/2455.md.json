["```py\ndef dropMultiCorrelated(cormat, threshold):\n    ##Define threshold to remove pairs of features with \n    #correlation coefficient greater than 0.7 or -0.7\n    threshold = 0.7\n\n    # Select upper triangle of correlation matrix\n    upper = cormat.abs().where(np.triu(np.ones(cormat.shape), k=1).astype(np.bool))\n\n    # Find index of feature columns with correlation greater than threshold\n    to_drop = [column for column in upper.columns if any(upper[column] > threshold)]\n    for d in to_drop:\n        print(\"Dropping {}....\".format(d))\n    return to_drop\"\n```", "```py\n## Build Multiple Linear Regression models to access true independent influence on the outcome\nfs = []\nfor feature in X_train.columns:\n  model =  sm.OLS(Y_train, sm.add_constant(X_train[feature])).fit()\n  fs.append((feature, model.params[feature]/ model.pvalues[feature]))\n\n## Extract and Store Values\nc1 = pd.DataFrame(coefs, columns = ['Feature', 'VarianceEx']).sort_values(\"VarianceEx\")\n```", "```py\nO = Y_train\n# To estimate the effect the addition/removal of a feature C\n# has on the relationship between an independent feature I and an outcome O\n\nconf = []\nfor I in X_train.columns:\n    # build a baseline model for the  effect of I on  O\n    model = sm.OLS(O, sm.add_constant(X_train[I])).fit()\n    IO_coef, IO_sig = model.params[I], model.pvalues[I]\n\n    ## Access the effect of \n    for C in X_train.columns:\n        if C != I:\n            # build an auxilliary model adding C to the relationship between I and O\n            model2 = sm.OLS(O, sm.add_constant(X_train[[I, C]])).fit()\n            ico_preds = model2.predict()\n            ICO_coef, ICO_sig = model2.params[I], model2.pvalues[I]\n\n            # build a baseline model for the effect of C on  O\n            model3 = sm.OLS(O, sm.add_constant(X_train[C])).fit()\n            CO_coef, CO_sig = model3.params[C], model3.pvalues[C]\n\n            corr_IC, _ = pearsonr(X_train[I], X_train[C]) # CORR The independent vs the control\n            corr_IO, _ = pearsonr(X_train[I], O) #CORR The independent vs the outcome\n            corr_CO, _ = pearsonr(X_train[C], O) #CORR The control vs the outcome\n            conf.append({\"I_C\":f\"{I}_{C}\",\n                                \"IO_coef\":IO_coef, \"IO_sig\":IO_sig,\n                                \"CO_coef\":CO_coef, \"CO_sig\":CO_sig,\n                                \"ICO_sig\":ICO_sig, \"ICO_coef\": ICO_coef,\n                                \"corr_IC\":corr_IC,\n                                \"corr_IO\":corr_IO,\n                                \"corr_CO\":corr_CO})\n\ncc = pd.DataFrame(conf)\ncorr_ic = (cc['corr_IC'] > 0.5) | (cc['corr_IC'] < -0.5) # I is correlated with C\ncorr_co = (cc['corr_CO'] > 0.5) | (cc['corr_CO'] < -0.5) # C is correlated with O\ncorr_io = (cc['corr_IO'] > 0.5) | (cc['corr_IO'] < -0.5) # C is correlated with O\n\n## C and O are significantly correlated\nco_sig = (cc['CO_sig'] < 0.01) # The C is independetly predictive of O\nio_sig = (cc['IO_sig'] < 0.01)\n\ncc[corr_ic & corr_io & corr_co & co_sig & io_sig]\n```", "```py\n## finding mediators\ncc = pd.DataFrame(conf)\nco_sig = (cc['CO_sig'] < 0.01) # The C is independetly predictive of Y\nio_sig = (cc['IO_sig'] < 0.01) # The I is independetly predictive of Y\nicoi_sig = (cc['ICO_I_sig'] < 0.01) # The I  and C are predictive of Y\nicoc_sig = (cc['ICO_C_sig'] < 0.05) # The C is independetly predictive of Y in the presence of I\nicoci_sig = (cc['IO_sig'] > cc['ICO_I_sig']) # Direct relationship between I and O should be stronger without C\n```"]