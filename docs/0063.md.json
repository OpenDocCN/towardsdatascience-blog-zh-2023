["```py\nCREATE TABLE inputs(idx SERIAL PRIMARY KEY, parens TEXT NOT NULL);\n\nINSERT INTO inputs(parens) VALUES\n('((()()))'), ('((()('), ('()()()())'), ('()()()()'), ('(()()(()()))');\n\nSELECT * FROM inputs;\n```", "```py\nWITH as_split AS (\n  -- First split each input string such that every character is on its\n  -- own row. We ensure that we tag each input row with the original\n  -- index of the input string from which it came so that we know which\n  -- problem it is a part of.\n  SELECT\n    idx,\n    UNNEST(\n      STRING_TO_ARRAY(\n        parens, NULL\n      )\n    ) AS ch\n  FROM inputs\n),\n\nwith_annotation AS (\n  -- Annotate characters from each problem (unique index) with its\n  -- position using ROW_NUMBER(). Also annotate an open paren with\n  -- +1 and a close paren with a -1 number, so that we can maintain\n  -- a running sum of these counters later.\n  SELECT\n    idx,\n    ch,\n    ROW_NUMBER() OVER(PARTITION BY idx) AS row_num,\n    CASE WHEN ch = '(' THEN +1 ELSE -1 END AS ctr\n  FROM as_split\n),\n\nwith_running_sum AS (\n  -- Find the running sum for characters in each problem. Note that we are\n  -- solving all the problems at once (think \"batch API\") instead of feeding\n  -- feeding each problem once into the solution machine.\n  SELECT\n    idx,\n    ch,\n    ctr,\n    row_num,\n    SUM(ctr) OVER(PARTITION BY idx ORDER BY row_num ASC) AS running_sum,\n    MAX(row_num) OVER(PARTITION BY idx) AS max_row_num\n  FROM with_annotation\n),\n\nwith_result AS (\n  -- The result is valid only if we never hit a negative running sum\n  -- (which indicates that we have an extra close paren than a corresponding\n  -- open paren) and if we end with a running sum of 0\\. If we end with a\n  -- running sum > 0 then we have an additional open paren that is not\n  -- matched with a corresponding close paren.\n  SELECT\n    idx,\n    CASE WHEN MIN(running_sum) < 0 THEN TRUE ELSE FALSE END AS has_negative,\n    CASE WHEN SUM(\n      CASE WHEN row_num = max_row_num THEN running_sum ELSE 0 END\n    ) = 0 THEN TRUE ELSE FALSE END AS ends_with_zero_sum\n  FROM with_running_sum\n  GROUP BY 1\n)\n\nSELECT\n  lhs.idx,\n  rhs.parens,\n  CASE\n    WHEN has_negative OR NOT ends_with_zero_sum THEN FALSE\n    ELSE TRUE END\n  AS is_valid_parens\nFROM with_result lhs INNER JOIN inputs rhs\nON lhs.idx = rhs.idx\nORDER BY lhs.idx ASC;\n```", "```py\nSUM(ctr) OVER(PARTITION BY idx ORDER BY row_num ASC) AS running_sum,\n```"]