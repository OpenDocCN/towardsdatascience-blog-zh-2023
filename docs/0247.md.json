["```py\n# Loading the required packages:\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\nfrom scipy.signal import savgol_filter, general_gaussian\nimport sklearn.linear_model as linear_model\n```", "```py\ndef Gauss(x, mu, sigma, A = 1):\n    # This def returns the Gaussian function of x\n    # x is an array\n    # mu is the expected value\n    # sigma is the square root of the variance\n    # A is a multiplication factor\n\n    gaussian = A/(sigma * np.sqrt(2*np.pi)) * np.exp(-0.5*((x-mu)/sigma)**2)\n\n    return gaussian\n```", "```py\n# X-axis (Wavelengths)\nx_range =  np.linspace(650, 783, 1024)\n\n# Let's create three different components\n\n# Component A\nmu_a1 = 663\nsigma_a1 = 1\nintensity_a1 = 1\n\nmu_a2 = 735\nsigma_a2 = 1\nintensity_a2 = 0.2\n\nmu_a3 = 771\nsigma_a3 = 1\nintensity_a3 = 0.3\n\ngauss_a =  Gauss(x_range, mu_a1, sigma_a1, intensity_a1) + Gauss(x_range, mu_a2, sigma_a2, intensity_a2) + Gauss(x_range, mu_a3, sigma_a3, intensity_a3)\n\n# Component B\nmu_b = 700\nsigma_b = 1\nintensity_b = 0.2\n\nmu_b1 = 690\nsigma_b1 = 2\nintensity_b1 = 0.5\n\nmu_b2 = 710\nsigma_b2 = 1\nintensity_b2 = 0.75\n\nmu_b3 = 774\nsigma_b3 = 1.5\nintensity_b3 = 0.25\n\ngauss_b = Gauss(x_range, mu_b, sigma_b, intensity_b) + Gauss(x_range, mu_b1, sigma_b1, intensity_b1) + Gauss(x_range, mu_b2, sigma_b2, intensity_b2) + Gauss(x_range, mu_b3, sigma_b3, intensity_b3)\n\n# Component C\nmu_c1 = 660\nsigma_c1 = 1\nintensity_c1 = 0.05\n\nmu_c2 = 712\nsigma_c2 = 4\nintensity_c2 = 0.7\n\ngauss_c = Gauss(x_range, mu_c1, sigma_c1, intensity_c1) + Gauss(x_range, mu_c2, sigma_c2, intensity_c2)\n\n# Component normalization\ncomponent_a = gauss_a/np.max(gauss_a)\ncomponent_b = gauss_b/np.max(gauss_b)\ncomponent_c = gauss_c/np.max(gauss_c)\n\n# How do they look?\nplt.plot(x_range, component_a, label = 'Component 1')\nplt.plot(x_range, component_b, label = 'Component 2')\nplt.plot(x_range, component_c, label = 'Component 3')\nplt.title('Known components in our mixture', fontsize = 15)\nplt.xlabel('Wavelength', fontsize = 15)\nplt.ylabel('Normalized intensity', fontsize = 15)\nplt.legend()\nplt.show()\n```", "```py\n# What concentrations we want these components to have in our mixture:\nc_a = 0.5\nc_b = 0.3\nc_c = 0.2\n\ncomps = np.array([c_a, c_b, c_c])\n\n# Let's build the spectrum to be studied: The mixture spectrum\nmix_spectrum = c_a * component_a + c_b * component_b + c_c *component_c\n\n# How does it look?\nplt.plot(x_range, mix_spectrum, color = 'black', label = 'Mixture spectrum with noise')\nplt.title('Mixture spectrum', fontsize = 15)\nplt.xlabel('Wavelength', fontsize = 15)\nplt.ylabel('Intensity',  fontsize = 15)\nplt.show()\n```", "```py\n# Let's add some noise for a bit of realism:\n\n# Random noise:\nmix_spectrum = mix_spectrum +  np.random.normal(0, 0.02, len(x_range))\n\n# Spikes: \nmix_spectrum[800] = mix_spectrum[800] + 1\nmix_spectrum[300] = mix_spectrum[300] + 0.3\n\n# Baseline as a polynomial background:\npoly = 0.2 * np.ones(len(x_range)) + 0.0001 * x_range + 0.000051 * (x_range - 680)**2 \nmix_spectrum = mix_spectrum + poly\n\n# How does it look now?\nplt.plot(x_range, mix_spectrum, color = 'black', label = 'Mixture spectrum with noise')\nplt.title('Mixture spectrum', fontsize = 15)\nplt.xlabel('Wavelength', fontsize = 15)\nplt.ylabel('Intensity',  fontsize = 15)\nplt.show()\n```", "```py\n# The next function calculates the modified z-scores of a diferentiated spectrum\n\ndef modified_z_score(ys):\n    ysb = np.diff(ys) # Differentiated intensity values\n    median_y = np.median(ysb) # Median of the intensity values\n    median_absolute_deviation_y = np.median([np.abs(y - median_y) for y in ysb]) # median_absolute_deviation of the differentiated intensity values\n    modified_z_scores = [0.6745 * (y - median_y) / median_absolute_deviation_y for y in ysb] # median_absolute_deviationmodified z scores\n    return modified_z_scores\n\n# The next function calculates the average values around the point to be replaced.\ndef fixer(y,ma):\n    threshold = 7 # binarization threshold\n    spikes = abs(np.array(modified_z_score(y))) > threshold\n    y_out = y.copy()\n    for i in np.arange(len(spikes)):\n        if spikes[i] != 0:\n            w = np.arange(i-ma,i+1+ma)\n            we = w[spikes[w] == 0]\n            y_out[i] = np.mean(y[we])\n    return y_out\n```", "```py\ndespiked_spectrum = fixer(mix_spectrum,ma=10)\n```", "```py\n# Baseline stimation with asymmetric least squares\n# According to paper: \"Baseline Correction with Asymmetric Least Squares Smoothing\" \n# by Paul H. C. Eilers and Hans F.M. Boelens. October 21, 2005\n\n# We need the following packages here:\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\n\n# Baseline stimation function:\ndef baseline_als(y, lam, p, niter=100):\n    L = len(y)\n    D = sparse.diags([1,-2,1],[0,-1,-2], shape=(L,L-2))\n    w = np.ones(L)\n    for i in range(niter):\n        W = sparse.spdiags(w, 0, L, L)\n        Z = W + lam * D.dot(D.transpose())\n        z = spsolve(Z, w*y)\n        w = p * (y > z) + (1-p) * (y < z)\n    return z\n\n# For more info see the paper and https://stackoverflow.com/questions/29156532/python-baseline-correction-library\n```", "```py\n# Parameters for this case:\nl = 10000000 # smoothness\np = 0.05 # asymmetry\n```", "```py\n# Estimation of the baseline:\nestimated_baselined = baseline_als(despiked_spectrum, l, p)\n\n# Baseline subtraction:\nbaselined_spectrum = despiked_spectrum - estimated_baselined\n\n# How does it look like?\nfig, (ax1, ax2) = plt.subplots(1,2, figsize=(16,4))\n\n# We compared the original mix spectrum and the estimated baseline:\nax1.plot(x_range, despiked_spectrum, color = 'black', label = 'Mix spectrum with noise' )\nax1.plot(x_range, estimated_baselined, color = 'red', label = 'Estimated baseline')\nax1.set_title('Baseline estimation', fontsize = 15)\nax1.set_xlabel('Wavelength', fontsize = 15)\nax1.set_ylabel('Intensity',  fontsize = 15)\nax1.legend()\n\n# We plot the mix spectrum after baseline subtraction\nax2.plot(x_range, baselined_spectrum, color = 'black', label = 'Baselined spectrum with noise' )\nax2.set_title('Baselined spectrum', fontsize = 15)\nax2.set_xlabel('Wavelength', fontsize = 15)\nax2.set_ylabel('Intensity',  fontsize = 15)\nplt.show()\n```", "```py\nfrom scipy.signal import savgol_filter, general_gaussian\n\n# Parameters:\nw = 9 # window (number of points)\np = 2 # polynomial order\n\nsmoothed_spectrum = savgol_filter(baselined_spectrum, w, polyorder = p, deriv=0)\n\n# Some more information on the implementation of this method can be found here:\n# https://nirpyresearch.com/savitzky-golay-smoothing-method/\n\n# We plot the mix spectrum after baseline subtraction\nplt.plot(x_range, baselined_spectrum, color = 'black', label = 'Baselined spectrum with noise' )\nplt.plot(x_range, smoothed_spectrum, color = 'red', label = 'Smoothed spectrum' )\nplt.title('Smoothed spectrum', fontsize = 15)\nplt.xlabel('Wavelength', fontsize = 15)\nplt.ylabel('Intensity',  fontsize = 15)\nplt.legend()\nplt.show()\n```", "```py\nquery_spectrum = smoothed_spectrum # Let's just rename it\n```", "```py\n# Generate the components matrix or K matrix\ncomponents = np.array([component_a, component_b, component_c]) \n```", "```py\nimport sklearn.linear_model as linear_model\n```", "```py\ncs = linear_model.LinearRegression().fit(components.T, query_spectrum).coef_\n#We print the result:\nprint('The expected concentrations for components A, B and C are: ' + str(cs)) \n```", "```py\n# Does the result match the original data?\n\n# Plot the original data:\nplt.plot(x_range, query_spectrum, color = 'black', label = 'Mix spectrum' )\n\n# Plot the separate components times its calculated concentration:\nfor i in np.arange(len(cs)):\n    plt.plot(x_range, cs[i]*components[i], label = 'c' + str(i)+ ' = ' + str(np.round(cs[i], 3)))\n\n# Plot the result: the sum of separate components times its calculated concentration:\nplt.plot(x_range, np.dot(cs,components), color = 'red', linewidth = 2, label = 'Calculation')\n\nplt.title('Mixture spectrum and calculated components', fontsize = 15)\nplt.xlabel('Wavelength', fontsize = 15)\nplt.ylabel('Intensity', fontsize = 15)\nplt.legend()\nplt.ylim(ymin = -0.1)\nplt.show()\n```"]