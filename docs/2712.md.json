["```py\nfrom math import log2\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nimg_size = 256\nnum_classes = 10\nhidden_size = 30\n\n# toy CNN classification model\nclass Net(nn.Module):\n    def __init__(self, img_size=img_size, num_classes=num_classes):\n        super().__init__()\n        self.conv_in = nn.Conv2d(3, hidden_size, 3, padding='same')\n        num_hidden = int(log2(img_size))\n        hidden = []\n        for i in range(num_hidden):\n            hidden.append(nn.Conv2d(hidden_size, hidden_size, 3, padding='same'))\n            hidden.append(nn.ReLU())\n            hidden.append(nn.MaxPool2d(2))\n        self.hidden = nn.Sequential(*hidden)\n        self.conv_out = nn.Conv2d(hidden_size, num_classes, 3, padding='same')\n\n    def forward(self, x):\n        x = F.relu(self.conv_in(x))\n        x = self.hidden(x)\n        x = self.conv_out(x)\n        x = torch.flatten(x, 1)\n        return x\n```", "```py\nimport numpy as np\nfrom PIL import Image\nfrom torchvision.datasets.vision import VisionDataset\ninput_img_size = [533, 800]\nclass FakeDataset(VisionDataset):\n    def __init__(self, transform):\n        super().__init__(root=None, transform=transform)\n        size = 10000\n        self.img_files = [f'0.jpg' for i in range(size)]\n        self.targets = np.random.randint(low=0,high=num_classes,\n                                         size=(size),dtype=np.uint8).tolist()\n\n    def __getitem__(self, index):\n        img_file, target = self.img_files[index], self.targets[index]\n        with torch.profiler.record_function('PIL open'):\n            img = Image.open(img_file)\n        if self.transform is not None:\n            img = self.transform(img)\n        return img, target\n\n    def __len__(self):\n        return len(self.img_files)\n```", "```py\nclass RandomMask(torch.nn.Module):\n    def __init__(self, ratio=0.25):\n        super().__init__()\n        self.ratio=ratio\n\n    def dilate_mask(self, mask):\n        # perform 4 neighbor dilation on mask\n        with torch.profiler.record_function('dilation'):\n            from scipy.signal import convolve2d\n            dilated = convolve2d(mask, [[0, 1, 0],\n                                     [1, 1, 1],\n                                     [0, 1, 0]], mode='same').astype(bool)\n        return dilated\n\n    def forward(self, img):\n        with torch.profiler.record_function('random'):\n            mask = np.random.uniform(size=(img_size, img_size)) < self.ratio\n        dilated_mask = torch.unsqueeze(torch.tensor(self.dilate_mask(mask)),0)\n        dilated_mask = dilated_mask.expand(3,-1,-1)\n        img[dilated_mask] = 0.\n        return img\n\n    def __repr__(self):\n        return f\"{self.__class__.__name__}(ratio={self.ratio})\"\n\nclass ConvertColor(torch.nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.A=torch.tensor(\n            [[0.299, 0.587, 0.114],\n             [-0.16874, -0.33126, 0.5],\n             [0.5, -0.41869, -0.08131]]\n        )\n        self.b=torch.tensor([0.,128.,128.])\n\n    def forward(self, img):\n        img = img.to(dtype=torch.get_default_dtype())\n        img = torch.matmul(self.A,img.view([3,-1])).view(img.shape)\n        img = img + self.b[:,None,None]\n        return img\n\n    def __repr__(self):\n        return f\"{self.__class__.__name__}()\"\n\nclass Scale(object):\n    def __call__(self, img):\n        return img.to(dtype=torch.get_default_dtype()).div(255)\n\n    def __repr__(self):\n        return f\"{self.__class__.__name__}()\"\n```", "```py\nimport torchvision.transforms as T\nclass CustomCompose(T.Compose):\n    def __call__(self, img):\n        for t in self.transforms:\n            with torch.profiler.record_function(t.__class__.__name__):\n                img = t(img)\n        return img\n\ntransform = CustomCompose(\n    [T.PILToTensor(),\n     T.RandomCrop(img_size),\n     RandomMask(),\n     ConvertColor(),\n     Scale()])\n```", "```py\ntrain_set = FakeDataset(transform=transform)\n\ndef custom_collate(batch):\n    from torch.utils.data._utils.collate import default_collate\n    with torch.profiler.record_function('collate'):\n        batch = default_collate(batch)\n    image, label = batch\n    return image, label\n\ntrain_loader = torch.utils.data.DataLoader(train_set, batch_size=256,\n                                           collate_fn=custom_collate,\n                                           num_workers=4, pin_memory=True)\n```", "```py\nfrom statistics import mean, variance\nfrom time import time\n\ndevice = torch.device(\"cuda:0\")\nmodel = Net().cuda(device)\ncriterion = nn.CrossEntropyLoss().cuda(device)\noptimizer = torch.optim.SGD(model.parameters(), lr=0.001, momentum=0.9)\nmodel.train()\n\nt0 = time()\ntimes = []\n\nwith torch.profiler.profile(\n    schedule=torch.profiler.schedule(wait=10, warmup=2, active=10, repeat=1),\n    on_trace_ready=torch.profiler.tensorboard_trace_handler('/tmp/prof'),\n    record_shapes=True,\n    profile_memory=True,\n    with_stack=True\n) as prof:\n    for step, data in enumerate(train_loader):\n        with torch.profiler.record_function('h2d copy'):\n            inputs, labels = data[0].to(device=device, non_blocking=True), \\\n                             data[1].to(device=device, non_blocking=True)\n        if step >= 40:\n            break\n        outputs = model(inputs)\n        loss = criterion(outputs, labels)\n        optimizer.zero_grad(set_to_none=True)\n        loss.backward()\n        optimizer.step()\n        prof.step()\n        times.append(time()-t0)\n        t0 = time()\n\nprint(f'average time: {mean(times[1:])}, variance: {variance(times[1:])}')\n```", "```py\n def dilate_mask(self, mask):\n        # perform 4 neighbor dilation on mask\n        with torch.profiler.record_function('dilation'):\n            padded = np.pad(mask, [(1,1),(1,1)])\n            dilated = padded[0:-2,1:-1] | padded[1:-1,1:-1] | padded[2:,1:-1] | padded[1:-1,0:-2]| padded[1:-1,2:]\n        return dilated\n```", "```py\ntransform = CustomCompose(\n    [T.RandomCrop(img_size),\n     T.PILToTensor(),\n     RandomMask(),\n     ConvertColor(),\n     Scale()])\n```", "```py\ndef batch_transform(img):\n    img = img.to(dtype=torch.get_default_dtype())\n    A = torch.tensor(\n        [[0.299, 0.587, 0.114],\n         [-0.16874, -0.33126, 0.5],\n         [0.5, -0.41869, -0.08131]]\n    )\n    b = torch.tensor([0., 128., 128.])\n\n    A = torch.broadcast_to(A, ([img.shape[0],3,3]))\n    t_img = torch.bmm(A,img.view(img.shape[0],3,-1))\n    t_img = t_img + b[None,:, None]\n    return t_img.view(img.shape)/255\n\ndef custom_collate(batch):\n    from torch.utils.data._utils.collate import default_collate\n    with torch.profiler.record_function('collate'):\n        batch = default_collate(batch)\n\n    image, label = batch\n    with torch.profiler.record_function('batch_transform'):\n        image = batch_transform(image)\n    return image, label\n```"]