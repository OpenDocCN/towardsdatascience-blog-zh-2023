["```py\nimport numpy as np\nfrom scipy.spatial.distance import squareform, pdist\nimport matplotlib.pyplot as plt\nimport pyomo.environ as pyo\nfrom pyomo.contrib.appsi.solvers.highs import Highs\n```", "```py\n# Fix random seeds\nnp.random.seed(12)\n\n# Create random points\nN = 25\np = 5\ncoordinates = np.random.random((N, 2))\n\n# Calculate pairwise distances\ndistances = squareform(pdist(coordinates))\n```", "```py\nmodel = pyo.ConcreteModel()\n```", "```py\n# Sets of nodes and arcs\nmodel.V = pyo.Set(initialize=range(N))\nmodel.A = pyo.Set(initialize=[(i, j) for i in model.V for j in model.V if i != j])\n```", "```py\n# Parameters\nmodel.d = pyo.Param(model.A, initialize={(i, j): distances[i, j] for (i, j) in model.A})\nmodel.p = pyo.Param(initialize=p)\n```", "```py\n# Decision variables\nmodel.x = pyo.Var(model.V, within=pyo.Binary)\nmodel.z = pyo.Var(model.A, within=pyo.Binary)\n```", "```py\n# p nodes are selected\ndef p_selection(model):\n    return sum(model.x[:]) == model.p\n\n# If starting node is not selected, the arc is 0\ndef dispersion_c1(model, i, j):\n    return model.z[i, j] <= model.x[i]\n\n# If ending node is not selected, the arc is 0\ndef dispersion_c2(model, i, j):\n    return model.z[i, j] <= model.x[j]\n\n# Include constraints in model\nmodel.p_selection = pyo.Constraint(rule=p_selection)\nmodel.dispersion_c1 = pyo.Constraint(model.A, rule=dispersion_c1)\nmodel.dispersion_c2 = pyo.Constraint(model.A, rule=dispersion_c2)\n```", "```py\ndef disp_obj(model):\n    return sum(model.z[i, j] * model.d[i, j] for (i, j) in model.A)\n\nmodel.obj = pyo.Objective(rule=disp_obj, sense=pyo.maximize)\n```", "```py\nsolver = Highs()\nsolver.solve(model)\n```", "```py\n# Max-min constraint\ndef maxmin_rule(model, i, j):\n    return model.D <= model.d[i, j] + model.M * (1 - model.x[i]) + model.M * (1 - model.x[j])\n\n# New parameter big M\nmodel.M = max(model.d[:, :])\n\n# New variable\nmodel.D = pyo.Var(within=pyo.NonNegativeReals)\n\n# New constraint\nmodel.maxmin_rule = pyo.Constraint(model.A, rule=maxmin_rule)\n\n# Objective\nmodel.obj = pyo.Objective(expr=model.D, sense=pyo.maximize)\n```", "```py\n# D must be optimal\ndef composed_constr(model):\n    return model.D >= model.d_opt\n\n# Solve p-dispersion\nsolver.solve(model)\n\n# New parameter\nmodel.d_opt = pyo.Param(initialize=model.obj())\n\n# Deactivate old objective\nmodel.obj.deactivate()\n\n# Solution will not make the current D worse\nmodel.composed_constr = pyo.Constraint(rule=composed_constr)\n\n# New objective\nmodel.obj_disp = pyo.Objective(rule=disp_obj, sense=pyo.maximize)\nsolver.solve(model)\n```"]