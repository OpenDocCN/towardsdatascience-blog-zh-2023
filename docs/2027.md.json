["```py\nlibrary(gpboost)\nlibrary(ggplot2)\nlibrary(gridExtra)\nlibrary(viridis)\nlibrary(sf)\n\n# Load data\ndata <- read.csv(\"https://raw.githubusercontent.com/fabsig/GPBoost/master/data/gdp_european_regions.csv\")\nFID <- data$FID\ndata <- as.matrix(data[,names(data)!=\"FID\"]) # convert to matrix since the boosting part currently does not support data.frames\ncovars <- c(\"L\", \"K\", \"pop\", \"edu\")\n# Load shape file for spatial plots\ncur_tempfile <- tempfile()\ndownload.file(url = \"https://raw.githubusercontent.com/fabsig/GPBoost/master/data/shape_European_regions.zip\", destfile = cur_tempfile)\nout_directory <- tempfile()\nunzip(cur_tempfile, exdir = out_directory)\nshape <- st_read(dsn = out_directory)\n\n# Create spatial plot of GDP\ndata_plot <- merge(shape, data.frame(FID = FID, y = data[,\"y\"]), by=\"FID\")\np1 <- ggplot(data_plot) + geom_sf(aes(group=FID, fill=y)) +\n  scale_fill_viridis(name=\"GDP / capita (log)\", option = \"B\") + \n   ggtitle(\"GDP / capita (log)\")\n# Sample plot excluding islands\np2 <- ggplot(data_plot) + geom_sf(aes(group=FID, fill=y)) +\n  scale_fill_viridis(name=\"GDP / capita (log)\", option = \"B\") +\n  xlim(2700000,6400000) + ylim(1500000,5200000) + \n  ggtitle(\"GDP / capita (log) -- excluding islands\")\ngrid.arrange(p1, p2, ncol=2)\n\n# # Spatial plot without a shape file\n# p1 <- ggplot(data = data.frame(Lat=data[,\"Lat\"], Long=data[,\"Long\"],\n#                                GDP=data[,\"y\"]), aes(x=Long,y=Lat,color=GDP)) +\n#   geom_point(size=2, alpha=0.5) + scale_color_viridis(option = \"B\") + \n#   ggtitle(\"GDP / capita (log)\")\n# p2 <- ggplot(data = data.frame(Lat=data[,\"Lat\"], Long=data[,\"Long\"], \n#                                GDP=data[,\"y\"]), aes(x=Long,y=Lat,color=GDP)) +\n#   geom_point(size=3, alpha=0.5) + scale_color_viridis(option = \"B\") + \n#   ggtitle(\"GDP / capita (log) -- Europe excluding islands\") + xlim(-10,28) + ylim(35,67)\n# grid.arrange(p1, p2, ncol=2)\n```", "```py\ngp_model <- GPModel(group_data = data[, c(\"cl\")], \n                    gp_coords = data[, c(\"Long\", \"Lat\")],\n                    likelihood = \"gaussian\", cov_function = \"exponential\")\nparams <- list(learning_rate = 0.01, max_depth = 2, num_leaves = 2^10,\n               min_data_in_leaf = 10, lambda_l2 = 0)\nnrounds <- 37\n# gp_model$set_optim_params(params = list(trace=TRUE)) # To monitor hyperparameter estimation\nboost_data <- gpb.Dataset(data = data[, covars], label = data[, \"y\"])\ngpboost_model <- gpboost(data = boost_data, gp_model = gp_model, \n                         nrounds = nrounds, params = params, \n                         verbose = 1) # same as gpb.train# same as gpb.train gpb.train\n```", "```py\ngp_model <- GPModel(group_data = data[, \"cl\"], \n                    gp_coords = data[, c(\"Long\", \"Lat\")],\n                    likelihood = \"gaussian\", cov_function = \"exponential\")\nboost_data <- gpb.Dataset(data = data[, covars], label = data[, \"y\"])\nparam_grid = list(\"learning_rate\" = c(1,0.1,0.01), \n                  \"min_data_in_leaf\" = c(10,100,1000),\n                  \"max_depth\" = c(1,2,3,5,10),\n                  \"lambda_l2\" = c(0,1,10))\nother_params <- list(num_leaves = 2^10)\nset.seed(1)\nopt_params <- gpb.grid.search.tune.parameters(param_grid = param_grid, params = other_params,\n                                              num_try_random = NULL, nfold = 4,\n                                              data = boost_data, gp_model = gp_model, \n                                              nrounds = 1000, early_stopping_rounds = 10,\n                                              verbose_eval = 1, metric = \"mse\") # metric = \"test_neg_log_likelihood\"\nopt_params\n# ***** New best test score (l2 = 0.0255393919591794) found for the following parameter combination: learning_rate: 0.01, min_data_in_leaf: 10, max_depth: 2, lambda_l2: 0, nrounds: 37\n```", "```py\nsummary(gp_model)\n```", "```py\n## =====================================================\n## Covariance parameters (random effects):\n##            Param.\n## Error_term 0.0131\n## Group_1    0.0221\n## GP_var     0.0089\n## GP_range   5.7502\n## =====================================================\n```", "```py\npred <- predict(gpboost_model, group_data_pred = data[1:242, c(\"cl\")], \n                gp_coords_pred = data[1:242, c(\"Long\", \"Lat\")],\n                data = data[1:242, covars], predict_var = TRUE, pred_latent = TRUE)\ndata_plot <- merge(shape, data.frame(FID = FID, y = pred$random_effect_mean), by=\"FID\")\nplot_mu <- ggplot(data_plot) + geom_sf(aes(group=FID, fill=y)) +\n  scale_fill_viridis(name=\"Spatial effect\", option = \"B\") +\n  ggtitle(\"Spatial effect (mean)\") + xlim(2700000,6400000) + ylim(1500000,5200000)\ndata_plot <- merge(shape, data.frame(FID = FID, y = pred$random_effect_cov), by=\"FID\")\nplot_sd <- ggplot(data_plot) + geom_sf(aes(group=FID, fill=y)) +\n  scale_fill_viridis(name=\"Std. dev.\", option = \"B\") +\n  ggtitle(\"Uncertainty (std. dev.)\") + xlim(2700000,6400000) + ylim(1500000,5200000)\ngrid.arrange(plot_mu, plot_sd, ncol=2)\n\n# Only spatial effects from the Gaussian process ignoring the grouped random effects\n# rand_effs <- predict_training_data_random_effects(gp_model, predict_var = TRUE)[1:242, c(\"GP\", \"GP_var\")]\n# data_plot <- merge(shape, data.frame(FID = FID, y = rand_effs[,1]), by=\"FID\")\n# plot_mu <- ggplot(data_plot) + geom_sf(aes(group=FID, fill=y)) +\n#   scale_fill_viridis(name=\"Spatial effect (mean)\", option = \"B\") +\n#   ggtitle(\"Spatial effect from Gausian process (mean)\") + xlim(2700000,6400000) + ylim(1500000,5200000)\n# data_plot <- merge(shape, data.frame(FID = FID, y = rand_effs[,2]), by=\"FID\")\n# plot_sd <- ggplot(data_plot) + geom_sf(aes(group=FID, fill=y)) +\n#   scale_fill_viridis(name=\"Uncertainty (std. dev.)\", option = \"B\") +\n#   ggtitle(\"Uncertainty (std. dev.)\") + xlim(2700000,6400000) + ylim(1500000,5200000)\n# grid.arrange(plot_mu, plot_sd, ncol=2)\n```", "```py\n# SHAP values\nlibrary(SHAPforxgboost)\nshap.plot.summary.wrap1(gpboost_model, X = data[,covars]) + ggtitle(\"SHAP values\")\n```", "```py\n# SHAP dependence plots\nshap_long <- shap.prep(gpboost_model, X_train = data[,covars])\nshap.plot.dependence(data_long = shap_long, x = covars[2], \n                           color_feature = covars[4], smooth = FALSE, size = 2) + \n  ggtitle(\"SHAP dependence plot for K\")\nshap.plot.dependence(data_long = shap_long, x = covars[4], \n                           color_feature = covars[2], smooth = FALSE, size = 2) + \n  ggtitle(\"SHAP dependence plot for edu\")\n```", "```py\n# SHAP force plot\nshap_contrib <- shap.values(gpboost_model, X_train = data[,covars])\nplot_data <- cbind(shap_contrib$shap_score, ID = 1:dim(data)[1])\nshap.plot.force_plot(plot_data, zoom_in=FALSE, id = \"ID\") + \n  scale_fill_discrete(name=\"Variable\") + xlab(\"Regions\") + \n  geom_vline(xintercept=242.5, linewidth=1) + ggtitle(\"SHAP force plot\") + \n  geom_text(x=100,y=-1.2,label=\"2000\") + geom_text(x=400,y=-1.2,label=\"2021\")\n```", "```py\n# Split-based feature importances\nfeature_importances <- gpb.importance(gpboost_model, percentage = TRUE)\ngpb.plot.importance(feature_importances, top_n = 25, measure = \"Gain\", \n                    main = \"Split-based variable importances\")\n```", "```py\n# H-statistic for interactions\nlibrary(flashlight)\nfl <- flashlight(model = gpboost_model, data = data.frame(y = data[,\"y\"], data[,covars]), \n                 y = \"y\", label = \"gpb\",\n                 predict_fun = function(m, X) predict(m, data.matrix(X[,covars]), \n                                                      gp_coords_pred = matrix(-100, ncol = 2, nrow = dim(X)[1]),\n                                                      group_data_pred = matrix(-1, ncol = 1, nrow = dim(X)[1]),\n                                                      pred_latent = TRUE)$fixed_effect)\nplot(imp <- light_interaction(fl, v = covars, pairwise = TRUE)) + \n  ggtitle(\"H interaction statistic\") # takes a few seconds\n```", "```py\n# Partial dependence plots\ngpb.plot.partial.dependence(gpboost_model, data[,covars], variable = 2, xlab = covars[2], \n                            ylab = \"gdp\", main = \"Partial dependence plot\" )\ngpb.plot.partial.dependence(gpboost_model, data[,covars], variable = 4, xlab = covars[4], \n                            ylab = \"gdp\", main = \"Partial dependence plot\" )\n```", "```py\n# Two-dimensional partial dependence plot (to visualize interactions)\ni = 1; j = 3;# i vs j\ngpb.plot.part.dep.interact(gpboost_model, data[,covars], variables = c(i,j), xlab = covars[i], \n                           ylab = covars[j], main = \"Pairwise partial dependence plot\")\n```", "```py\ngp_model <- GPModel(group_data = data[, c(\"cl\")], gp_coords = data[, c(\"Long\", \"Lat\")],\n                    likelihood = \"gaussian\", cov_function = \"exponential\",\n                    cluster_ids  = c(rep(1,242), rep(2,242)))\nboost_data <- gpb.Dataset(data = data[, covars], label = data[, \"y\"])\nparams <- list(learning_rate = 0.01, max_depth = 1, num_leaves = 2^10,\n               min_data_in_leaf = 10, lambda_l2 = 1) \n# Note: we use the same tuning parameters as above. Ideally, the would have to be chosen again\ngpboost_model <- gpboost(data = boost_data, gp_model = gp_model, nrounds = nrounds,\n                         params = params, verbose = 0)\n# Separate spatial maps for the years 2000 and 2021\npred <- predict(gpboost_model, group_data_pred = data[, c(\"cl\")], \n                gp_coords_pred = data[, c(\"Long\", \"Lat\")],\n                data = data[, covars], predict_var = TRUE, pred_latent = TRUE,\n                cluster_ids_pred = c(rep(1,242), rep(2,242)))\ndata_plot <- merge(shape, data.frame(FID = FID, y = pred$random_effect_mean[1:242]), by=\"FID\")\nplot_mu_2000 <- ggplot(data_plot) + geom_sf(aes(group=FID, fill=y)) +\n  scale_fill_viridis(name=\"Spatial effect\", option = \"B\") +\n  ggtitle(\"Spatial effect for 2000 (mean)\") + xlim(2700000,6400000) + ylim(1500000,5200000)\ndata_plot <- merge(shape, data.frame(FID = FID, y = pred$random_effect_mean[243:484]), by=\"FID\")\nplot_mu_2021 <- ggplot(data_plot) + geom_sf(aes(group=FID, fill=y)) +\n  scale_fill_viridis(name=\"Spatial effect\", option = \"B\") +\n  ggtitle(\"Spatial effect for 2021 (mean)\") + xlim(2700000,6400000) + ylim(1500000,5200000)\ngrid.arrange(plot_mu_2000, plot_mu_2021, ncol=2)\nsd(pred$random_effect_mean[1:242]) # 0.2321267\nsd(pred$random_effect_mean[243:484]) # 0.1286398\n```", "```py\ngp_model <- GPModel(group_data = data[, c(\"cl\")], gp_coords = data[, c(\"Long\", \"Lat\")],\n                    likelihood = \"gaussian\", cov_function = \"exponential\")\ncovars_interact <- c(c(\"Long\", \"Lat\"), covars) ## add spatial coordinates to fixed effects predictor variables\nboost_data <- gpb.Dataset(data = data[, covars_interact], label = data[, \"y\"])\nparams <- list(learning_rate = 0.01, max_depth = 1, num_leaves = 2^10,\n               min_data_in_leaf = 10, lambda_l2 = 1) \n# Note: we use the same tuning parameters as above. Ideally, the would have to be chosen again\ngpboost_model <- gpboost(data = boost_data, gp_model = gp_model, nrounds = nrounds,\n                         params = params, verbose = 0)\nfeature_importances <- gpb.importance(gpboost_model, percentage = TRUE)\ngpb.plot.importance(feature_importances, top_n = 25, measure = \"Gain\", \n                    main = \"Variable importances when including coordinates in the fixed effects\")\n```", "```py\ngp_model <- GPModel(group_data = data[, c(\"group\", \"cl\")], likelihood = \"gaussian\")\n```", "```py\nX_incl_1 = cbind(Intercept = rep(1,dim(data)[1]), data[, covars])\ngp_model <- fitGPModel(group_data = data[, c(\"cl\")], gp_coords = data[, c(\"Long\", \"Lat\")],\n                       likelihood = \"gaussian\", cov_function = \"exponential\",\n                       y = data[, \"y\"], X = X_incl_1, params = list(std_dev=TRUE))\nsummary(gp_model)\n```", "```py\n## =====================================================\n## Model summary:\n## Log-lik     AIC     BIC \n##  195.97 -373.94 -336.30 \n## Nb. observations: 484\n## Nb. groups: 2 (Group_1)\n## -----------------------------------------------------\n## Covariance parameters (random effects):\n##            Param. Std. dev.\n## Error_term 0.0215    0.0017\n## Group_1    0.0003    0.0008\n## GP_var     0.0126    0.0047\n## GP_range   7.2823    3.6585\n## -----------------------------------------------------\n## Linear regression coefficients (fixed effects):\n##            Param. Std. dev. z value P(>|z|)\n## Intercept 16.2816    0.4559 35.7128  0.0000\n## L          0.4243    0.0565  7.5042  0.0000\n## K          0.6493    0.0212 30.6755  0.0000\n## pop        0.0134    0.0097  1.3812  0.1672\n## edu        0.0100    0.0009 10.9645  0.0000\n## =====================================================\n```"]