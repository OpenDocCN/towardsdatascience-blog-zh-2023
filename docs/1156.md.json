["```py\nimport geopandas as gpd\nfrom shapely.geometry import Point, Polygon\nimport osmnx\nimport shapely\nimport pandas as pd\nimport numpy as np\nimport networkx as nx\n\ndef point_finder(place, tags):\n    '''\n    Returns a dataframe of coordinates of an entity from OSM.\n\n            Parameters:\n                    place (str): a location (i.e., 'Tokyo, Japan')\n                    tags (dict): key value of entity attribute in OSM (i.e., 'Name') and value (i.e., amenity name)\n            Returns:\n                    results (DataFrame): table of latitude and longitude with entity value \n    '''\n\n    gdf = osmnx.geocode_to_gdf(place)\n    #Getting the bounding box of the gdf\n    bounding = gdf.bounds\n    north, south, east, west = bounding.iloc[0,3], bounding.iloc[0,1], bounding.iloc[0,2], bounding.iloc[0,0]\n    location = gdf.geometry.unary_union\n    #Finding the points within the area polygon\n    point = osmnx.geometries_from_bbox(north,\n                                       south,\n                                       east,\n                                       west,\n                                       tags=tags)\n    point.set_crs(crs=4326)\n    point = point[point.geometry.within(location)]\n    #Making sure we are dealing with points\n    point['geometry'] = point['geometry'].apply(lambda x : x.centroid if type(x) == Polygon else x)\n    point = point[point.geom_type != 'MultiPolygon']\n    point = point[point.geom_type != 'Polygon']\n\n    results = pd.DataFrame({'name' : list(point['name']),\n                            'longitude' : list(point['geometry'].x),\n                            'latitude' : list(point['geometry'].y)}\n                            )\n\n    results['name'] = list(tags.values())[0]\n    return results\n\nconvenience_stores = place_finder(place = 'Shinjuku, Tokyo',\n                                  tags={\"brand:en\" : \" \"})\n```", "```py\n# Convert location to radians\nlocations = convenience_stores[[\"latitude\", \"longitude\"]].values\nlocations_radians =  np.radians(locations)\n\n# Create a balltree to search locations\ntree = BallTree(locations_radians, leaf_size=15, metric='haversine')\n\n# Find nearest neighbours in a 2 minute walking radius\nis_within, distances = tree.query_radius(locations_radians, r=168/6371000, count_only=False, return_distance=True)\n\n# Replace the neighbour indices with store names\ndf = pd.DataFrame(is_within)\ndf.columns = ['indices']\ndf['indices'] = [[val for val in row if val != idx] for idx, row in enumerate(df['indices'])]\n\n# create temporary index column\nconvenience_stores = convenience_stores.reset_index()\n# set temporary index column as index\nconvenience_stores = convenience_stores.set_index('index')\n# create index-name mapping\nindex_name_mapping = convenience_stores['name'].to_dict()\n\n# replace index values with names and remove duplicates\ndf['indices'] = df['indices'].apply(lambda lst: list(set(map(index_name_mapping.get, set(lst)))))\n# Append back to original df\nconvenience_stores['neighbours'] = df['indices']\n\n# Identify when a store has no neighbours\nconvenience_stores['neighbours'] = [lst if lst else ['no-neighbours'] for lst in convenience_stores['neighbours']]\n\n# Unique store names\nunique_elements = set([item for sublist in convenience_stores['neighbours'] for item in sublist])\n# Count each stores frequency in the set of neighbours per location\ncounts = [dict(Counter(row)) for row in convenience_stores['neighbours']]\n\n# Create a new dataframe with the counts\noutput_df = pd.DataFrame(counts).fillna(0)[sorted(unique_elements)]\n```", "```py\nfrom mlxtend.frequent_patterns import association_rules, apriori\n\n# Calculate apriori\nfrequent_set = apriori(output_df, min_support = 0.05, use_colnames = True)\n# Create rules\nrules = association_rules(frequent_set, metric = 'lift')\n# Sort rules by the support value\nrules.sort_values(['support'], ascending=False)\n```"]