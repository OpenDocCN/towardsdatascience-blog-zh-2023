["```py\ncargo new simd_hello\ncd simd_hello\n```", "```py\n// Tell nightly Rust to enable 'portable_simd'\n#![feature(portable_simd)]\nuse core::simd::prelude::*;\n\n// constant Simd structs\nconst LANES: usize = 32;\nconst THIRTEENS: Simd<u8, LANES> = Simd::<u8, LANES>::from_array([13; LANES]);\nconst TWENTYSIXS: Simd<u8, LANES> = Simd::<u8, LANES>::from_array([26; LANES]);\nconst ZEES: Simd<u8, LANES> = Simd::<u8, LANES>::from_array([b'Z'; LANES]);\n\nfn main() {\n    // create a Simd struct from a slice of LANES bytes\n    let mut data = Simd::<u8, LANES>::from_slice(b\"URYYBJBEYQVQBUBCRVGFNYYTBVATJRYY\");\n\n    data += THIRTEENS; // add 13 to each byte\n\n    // compare each byte to 'Z', where the byte is greater than 'Z', subtract 26\n    let mask = data.simd_gt(ZEES); // compare each byte to 'Z'\n    data = mask.select(data - TWENTYSIXS, data);\n\n    let output = String::from_utf8_lossy(data.as_array());\n    assert_eq!(output, \"HELLOWORLDIDOHOPEITSALLGOINGWELL\");\n    println!(\"{}\", output);\n}\n```", "```py\n#![feature(portable_simd)]\nuse core::simd::prelude::*;\n```", "```py\nconst LANES: usize = 32;\nconst THIRTEENS: Simd<u8, LANES> = Simd::<u8, LANES>::from_array([13; LANES]);\nconst TWENTYSIXS: Simd<u8, LANES> = Simd::<u8, LANES>::from_array([26; LANES]);\nconst ZEES: Simd<u8, LANES> = Simd::<u8, LANES>::from_array([b'Z'; LANES]);\n```", "```py\nlet mut data = Simd::<u8, LANES>::from_slice(b\"URYYBJBEYQVQBUBCRVGFNYYTBVATJRYY\");\ndata += THIRTEENS;\n```", "```py\nlet mask = data.simd_gt(ZEES);\ndata = mask.select(data - TWENTYSIXS, data);\n```", "```py\nlet output = String::from_utf8_lossy(data.as_array());\nassert_eq!(output, \"HELLOWORLDIDOHOPEITSALLGOINGWELL\");\nprintln!(\"{}\", output);\n```", "```py\nrustup override set nightly\ncargo install cargo-simd-detect --force\ncargo simd-detect\n```", "```py\nextension       width                   available       enabled\nsse2            128-bit/16-bytes        true            true\navx2            256-bit/32-bytes        true            false\navx512f         512-bit/64-bytes        true            false\n```", "```py\n# For Windows Command Prompt\nset RUSTFLAGS=-C target-feature=+avx2\n\n# For Unix-like shells (like Bash)\nexport RUSTFLAGS=\"-C target-feature=+avx2\"\n```", "```py\n# Force install every time to see changes to 'enabled'\ncargo install cargo-simd-detect --force\ncargo simd-detect\n```", "```py\nextension         width                   available       enabled\nsse2            128-bit/16-bytes        true            true\navx2            256-bit/32-bytes        true            true\navx512f         512-bit/64-bytes        true            false\n```", "```py\n# For Windows Command Prompt\nset RUSTFLAGS=-C target-cpu=native\n\n# For Unix-like shells (like Bash)\nexport RUSTFLAGS=\"-C target-cpu=native\"\n```", "```py\n# For Windows Command Prompt\nset RUSTFLAGS=\n\n# For Unix-like shells (like Bash)\nunset RUSTFLAGS\n```", "```py\npub const LANES: usize = 16;\npub fn is_consecutive_regular(chunk: &[u32; LANES]) -> bool {\n    for i in 1..LANES {\n        if chunk[i - 1].checked_add(1) != Some(chunk[i]) {\n            return false;\n        }\n    }\n    true\n}\n```", "```py\nuse std::simd::prelude::*;\n\nconst COMPARISON_VALUE_SPLAT0: Simd<u32, LANES> =\n    Simd::from_array([15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]);\n\npub fn is_consecutive_splat0(chunk: Simd<u32, LANES>) -> bool {\n    if chunk[0].overflowing_add(LANES as u32 - 1) != (chunk[LANES - 1], false) {\n        return false;\n    }\n    let added = chunk + COMPARISON_VALUE_SPLAT0;\n    Simd::splat(added[0]) == added\n}\n```", "```py\nconst COMPARISON_VALUE_SPLAT1: Simd<u32, LANES> =\n    Simd::from_array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n\npub fn is_consecutive_splat1(chunk: Simd<u32, LANES>) -> bool {\n    let subtracted = chunk - COMPARISON_VALUE_SPLAT1;\n    Simd::splat(chunk[0]) == subtracted\n}\n```", "```py\npub fn is_consecutive_sizzle(chunk: Simd<u32, LANES>) -> bool {\n    let subtracted = chunk - COMPARISON_VALUE_SPLAT1;\n    simd_swizzle!(subtracted, [0; LANES]) == subtracted\n}\n```", "```py\nconst COMPARISON_VALUE_ROTATE: Simd<u32, LANES> =\n    Simd::from_array([4294967281, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]);\n\npub fn is_consecutive_rotate(chunk: Simd<u32, LANES>) -> bool {\n    let rotated = chunk.rotate_elements_right::<1>();\n    chunk - rotated == COMPARISON_VALUE_ROTATE\n}\n```", "```py\n#[inline]\npub fn is_consecutive_splat1_gen<T, const N: usize>(\n    chunk: Simd<T, N>,\n    comparison_value: Simd<T, N>,\n) -> bool\nwhere\n    T: SimdElement + PartialEq,\n    Simd<T, N>: Sub<Simd<T, N>, Output = Simd<T, N>>,\n    LaneCount<N>: SupportedLaneCount,\n{\n    let subtracted = chunk - comparison_value;\n    Simd::splat(chunk[0]) == subtracted\n}\n```", "```py\n// DOESN'T WORK BECAUSE From<usize> is not const\npub const fn comparison_value_splat_gen<T, const N: usize>() -> Simd<T, N>\nwhere\n    T: SimdElement + Default + From<usize> + AddAssign,\n    LaneCount<N>: SupportedLaneCount,\n{\n    let mut arr: [T; N] = [T::from(0usize); N];\n    let mut i_usize = 0;\n    while i_usize < N {\n        arr[i_usize] = T::from(i_usize);\n        i_usize += 1;\n    }\n    Simd::from_array(arr)\n}\n```", "```py\n#[macro_export]\nmacro_rules! define_is_consecutive_splat1 {\n    ($function:ident, $type:ty) => {\n        #[inline]\n        pub fn $function<const N: usize>(chunk: Simd<$type, N>) -> bool\n        where\n            LaneCount<N>: SupportedLaneCount,\n        {\n            define_comparison_value_splat!(comparison_value_splat, $type);\n\n            let subtracted = chunk - comparison_value_splat();\n            Simd::splat(chunk[0]) == subtracted\n        }\n    };\n}\n#[macro_export]\nmacro_rules! define_comparison_value_splat {\n    ($function:ident, $type:ty) => {\n        pub const fn $function<const N: usize>() -> Simd<$type, N>\n        where\n            LaneCount<N>: SupportedLaneCount,\n        {\n            let mut arr: [$type; N] = [0; N];\n            let mut i = 0;\n            while i < N {\n                arr[i] = i as $type;\n                i += 1;\n            }\n            Simd::from_array(arr)\n        }\n    };\n}\n```", "```py\ndefine_is_consecutive_splat1!(is_consecutive_splat1_i32, i32);\n\nlet a: Simd<i32, 16> = black_box(Simd::from_array(array::from_fn(|i| 100 + i as i32)));\nlet ninety_nines: Simd<i32, 16> = black_box(Simd::from_array([99; 16]));\nassert!(is_consecutive_splat1_i32(a));\nassert!(!is_consecutive_splat1_i32(ninety_nines));\n```", "```py\npub trait IsConsecutive {\n    fn is_consecutive<const N: usize>(chunk: Simd<Self, N>) -> bool\n    where\n        Self: SimdElement,\n        Simd<Self, N>: Sub<Simd<Self, N>, Output = Simd<Self, N>>,\n        LaneCount<N>: SupportedLaneCount;\n}\n\nmacro_rules! impl_is_consecutive {\n    ($type:ty) => {\n        impl IsConsecutive for $type {\n            #[inline] // very important\n            fn is_consecutive<const N: usize>(chunk: Simd<Self, N>) -> bool\n            where\n                Self: SimdElement,\n                Simd<Self, N>: Sub<Simd<Self, N>, Output = Simd<Self, N>>,\n                LaneCount<N>: SupportedLaneCount,\n            {\n                define_is_consecutive_splat1!(is_consecutive_splat1, $type);\n                is_consecutive_splat1(chunk)\n            }\n        }\n    };\n}\n\nimpl_is_consecutive!(i8);\nimpl_is_consecutive!(i16);\nimpl_is_consecutive!(i32);\nimpl_is_consecutive!(i64);\nimpl_is_consecutive!(isize);\nimpl_is_consecutive!(u8);\nimpl_is_consecutive!(u16);\nimpl_is_consecutive!(u32);\nimpl_is_consecutive!(u64);\nimpl_is_consecutive!(usize);\n```", "```py\n// Works on i32 and 16 lanes\nlet a: Simd<i32, 16> = black_box(Simd::from_array(array::from_fn(|i| 100 + i as i32)));\nlet ninety_nines: Simd<i32, 16> = black_box(Simd::from_array([99; 16]));\n\nassert!(IsConsecutive::is_consecutive(a));\nassert!(!IsConsecutive::is_consecutive(ninety_nines));\n\n// Works on i8 and 64 lanes\nlet a: Simd<i8, 64> = black_box(Simd::from_array(array::from_fn(|i| 10 + i as i8)));\nlet ninety_nines: Simd<i8, 64> = black_box(Simd::from_array([99; 64]));\n\nassert!(IsConsecutive::is_consecutive(a));\nassert!(!IsConsecutive::is_consecutive(ninety_nines));\n```"]