- en: Understanding Retention with Gradio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/understanding-retention-with-gradio-c288b48918af?source=collection_archive---------3-----------------------#2023-10-21](https://towardsdatascience.com/understanding-retention-with-gradio-c288b48918af?source=collection_archive---------3-----------------------#2023-10-21)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How to leverage web applications for analytics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://miptgirl.medium.com/?source=post_page-----c288b48918af--------------------------------)[![Mariya
    Mansurova](../Images/b1dd377b0a1887db900cc5108bca8ea8.png)](https://miptgirl.medium.com/?source=post_page-----c288b48918af--------------------------------)[](https://towardsdatascience.com/?source=post_page-----c288b48918af--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----c288b48918af--------------------------------)
    [Mariya Mansurova](https://miptgirl.medium.com/?source=post_page-----c288b48918af--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F15a29a4fc6ad&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funderstanding-retention-with-gradio-c288b48918af&user=Mariya+Mansurova&userId=15a29a4fc6ad&source=post_page-15a29a4fc6ad----c288b48918af---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----c288b48918af--------------------------------)
    ·15 min read·Oct 21, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fc288b48918af&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funderstanding-retention-with-gradio-c288b48918af&user=Mariya+Mansurova&userId=15a29a4fc6ad&source=-----c288b48918af---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fc288b48918af&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Funderstanding-retention-with-gradio-c288b48918af&source=-----c288b48918af---------------------bookmark_footer-----------)![](../Images/5b58678467a50c1f821070b4f80c7267.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Image by DALL-E 3
  prefs: []
  type: TYPE_NORMAL
- en: I remember a moment when I built my first web application. It was around eight
    years ago, and I was a rather junior analyst and was convinced that BI tools could
    solve all the problems.
  prefs: []
  type: TYPE_NORMAL
- en: The engineering team built a prototype of a new SDK and wanted to learn whether
    it gathers data better. They were testing it on a set of devices, looking at the
    data and comparing it to the old version. However, the set of devices was constantly
    changing, so keeping it up-to-date in BI tools would require quite a lot of work.
    So, I decided to build a web application.
  prefs: []
  type: TYPE_NORMAL
- en: I found a set of articles (ten or eleven if I remember correctly), read them
    all and tried to use this knowledge for my task. It took me around a week to finish
    the first prototype. I had to write both the back-end and front-end sides, so
    now I could consider myself at least a junior full-stack developer. For the back-end,
    I used Flask (I was lucky not to bump into Django, or I would have spent the whole
    month), and for front-end — Bootstrap and Leaflet.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, it was a challenging task that required much effort to upskill in engineering.
    I believe it’s always worth having a deeper understanding of the other spheres
    next to your primary domain of expertise.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, I’m delighted that nowadays, there are many tools that allow analysts
    and data scientists to build prototypes in less than an hour. In many cases, such
    prototypes can bring your analytics to the next level. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Revenue and audience forecast depending on the input parameters (like marketing
    budget or markets where we will launch a new feature),
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools that will speed up your team’s work or reduce ad-hoc workload, like an
    A/B testing calculator or automatic root cause analysis,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MVP solutions, for example, if you want to use LLMs to automate some internal
    processes, it’s worth testing a prototype before spending time on a production
    version. I shared such an ML prototype in one of my previous articles, [“Build
    your first Deep Learning app within an hour”](/build-your-first-deep-learning-app-within-an-hour-4e80c120e99f).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this article, I would like to tell you about one of such frameworks that
    can help you quickly and almost effortlessly create nice-looking web applications
    without bothering with JavaScript and CSS. We will learn the basics of Gradio,
    develop a couple of web applications, and publish them to HuggingFace Spaces so
    anyone can access them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Gradio is not the only framework of that kind. There are a few other open-source
    Python alternatives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Streamlit](https://streamlit.io/) is another popular and powerful library
    for building data apps with little code. It is also supported by HuggingFace Spaces
    so that you can host such apps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Dash](https://dash.plotly.com/) could be convenient if you are already used
    to Plotly, and it provides more capabilities for customization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, if you want to build something custom and complex, your last resort
    would be [Flask](https://flask.palletsprojects.com/en/3.0.x/) or even [Django](https://www.djangoproject.com/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find more details regarding the main features of the different frameworks
    in [this article](/gradio-vs-streamlit-vs-dash-vs-flask-d3defb1209a2).
  prefs: []
  type: TYPE_NORMAL
- en: Gradio basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Gradio](https://www.gradio.app/) is an open-source Python library that is
    used to build interactive applications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main advantages of Gradio are:'
  prefs: []
  type: TYPE_NORMAL
- en: you can build applications using only Python, which also means that you can
    use all Python libraries in your app,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: you can run it in Jupyter Notebook or as a separate webpage,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: you can host Gradio apps permanently on HuggingFace spaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There’s no silver bullet, so Gradio has its limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: It’s explicitly designed for ML applications. So, if you’re using it for other
    use cases, you might have to change defaults (for example, switching off flagging
    with `allow_flagging= "never"`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customization is limited, especially if we are talking about design.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I would bear in mind that Gradio is a framework primarily for quick prototyping.
    It mostly works well, but from time to time, I face some strange behaviour. For
    example, table editing in Safari works counterintuitively, or sometimes you need
    to restart Jupyter Notebook to make the interface load.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To start using Gradio, we need to install the Python package.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Following the old programmers’ tradition, let’s start with “Hello, World!”.
  prefs: []
  type: TYPE_NORMAL
- en: We can use `gr.Interface` class to define the interface ([documentation](https://www.gradio.app/docs/interface)).
    It’s one of the core Gradio classes that helps you to create a web application
    based on any Python function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to specify the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`inputs`**:** input components of the interface (in our case, just a text field),'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`outputs`**:** outputcomponents of the interface (in our case, also just a
    text field),'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fn`**:** core functionality (a function that gets inputs and returns outputs,
    in our case, gets name from the input and returns “Hello, <name>!”),'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title` & `description`**:** a bit of markdown to make our app more user-friendly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can run this code in your Jupyter Notebook and see the results. It’s pretty
    handy for debugging. Later, we will discuss how to make your web application available
    to others.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ee92257fcd44d42a391b771476a5ca85.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s it: just a few lines of code, and your first Gradio app is running.
    Also, I must note that it looks pretty nice, and we didn’t have to use any front-end
    magic for it.'
  prefs: []
  type: TYPE_NORMAL
- en: Gradio launches a lot of processes in the background when you’re working from
    Jupyter Notebook, so it’s worth from time to time close connections using `*gr.close_all()*`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We looked at the most basic example and saw the building blocks of Gradio:
    inputs, outputs and functions. Now, we are ready to move on to real-life analytical
    tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: Growth Simulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the first example, we will look at the impact of retention on the users’
    growth for the product.
  prefs: []
  type: TYPE_NORMAL
- en: Retention as the basis for growth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Two parameters define the growth of the product:'
  prefs: []
  type: TYPE_NORMAL
- en: acquisition (number of new users each period),
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: retention (ability to retain customers in the product).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s model how the user base will grow depending on the retention curve.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can describe any retention curve using the following function with a set
    of parameters (`a`, `b`, `c` and `d`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8c2215f81a4369cd092e882007d12b08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s talk about the most common case of retention: cohort is defined by the
    first action in the product, and all actions are counted into the retention. In
    that case, retention for `periods = 0` must equal 1 (because the cohort entry
    and retention events are the same). So, we can define one of the parameters automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/bf09f55e3259530b5301d9ae7bf05777.png)'
  prefs: []
  type: TYPE_IMG
- en: The main factor for growth is long-term retention. It defines whether customers
    stick to the product for a long time and your product grows sustainably or customers
    churn in a month, and you need to acquire more and more new users for growth.
    In our formula, `a` parameter is in charge of long-term retention.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/be9107e4756eba3f7c634c3dd4e2763c.png)'
  prefs: []
  type: TYPE_IMG
- en: We can use this formula to define the retention curve. So we have everything
    we need to move on to the development.
  prefs: []
  type: TYPE_NORMAL
- en: Visualising retention graph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start simple and make an application that will take the retention curve
    parameters and show the relation as a graph.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly to our “Hello, World” example, we need to use `gr.Interface` class
    and pass `inputs`, `outputs` and `fn` to map them.
  prefs: []
  type: TYPE_NORMAL
- en: We now need more input parameters. So, `inputs` will be a list of controls.
    We will use `gr.Slider` and `gr.Dropdown` controls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For [gr.Slider](https://www.gradio.app/docs/slider), we need to pass min, max,
    default values and a label that we will use in the function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For [gr.Dropdown](https://www.gradio.app/docs/dropdown), we need to define a
    list of possible values, default value, and a label.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will still have only one output — a plot so that `outputs` will be `gr.Plot`
    without any parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function `fn` will map inputs to outputs, so it will get input arguments and
    return `plotly.Figure` object that will be visualised.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let’s try to run this app. It’s working — we can see a graph that changes if
    we submit new parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/56dbf537eb5f547cd3183d3f83cc4ff6.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding more graphs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our goal was to look at the impact of retention on growth, so we need to add
    graphs showing not only retention but also audience over time. Let’s change our
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity, we will consider that in each period, the same number of new
    users start using our product (`cohort_size` parameter).
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to make just a couple of changes to our implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: Change `get_retention_plot` function so that it gets one more parameter for
    cohort size, calculates the number of users over time and returns three Figures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameter `outputs` is now equal to the list of three `gr.Plot()` objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Fantastic, now we can see the complete picture and analyse the relationships.
    However, there’s room for improvement — we can add formatting to make our app
    more convenient for users.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/744f7a0f14e19151e3c2e24479c65173.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Adding a bit of style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can tweak our interface a bit to make it more user-friendly and straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: For that, we will be using `gr.Blocks()` as a context. [This functionality](https://www.gradio.app/docs/blocks)
    allows you to create more custom web applications and define layouts and data
    flows (events that trigger functions and consequent execution).
  prefs: []
  type: TYPE_NORMAL
- en: 'Blocks will open new opportunities for us:'
  prefs: []
  type: TYPE_NORMAL
- en: With `gr.Blocks()` we can use `gr.Row()` and `gr.Column()` to organize a layout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gr.Markdown` allows you to add markdown elements, for example, title or even
    LaTeX with formulas (by default, you need to put them inside $).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gr.Accordion` can help you hide some parameters you don’t want to show the
    user by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, this approach allows you to define more complex logic of updates. For
    example, update plots not only on the submit button but on the change of any input
    parameter. We will use this functionality in the following example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When working with Blocks, we need to define each input and output as variables,
    for example, `a = gr.Slider(0, 1, 0.03, label=”a”)`.
  prefs: []
  type: TYPE_NORMAL
- en: Also, there are no default controls, so we have to define buttons ourselves
    — `btn_caption = gr.Button(“Submit”)`.
  prefs: []
  type: TYPE_NORMAL
- en: The action on button click also must be specified, setting the already familiar
    parameters — `inputs`, `outputs` and `fn`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here is the full version of code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Hosting your application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Also, we can use HuggingFace Spaces to host our web applications and share them
    easily with others.
  prefs: []
  type: TYPE_NORMAL
- en: To start using Spaces, you need to have an account. Follow this [link](https://huggingface.co/join)
    if you haven’t registered yet. It won’t take more than a couple of minutes.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to create a new Space. You can find instructions with more
    details in [the documentation](https://huggingface.co/docs/hub/spaces-overview).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/87bb2d236b2011b8a9d35ccaca4b81ed.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: 'For new Space, you must fill in the following parameters: name, license and
    Gradio as your SDK.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/85af66926ab40de2d913bfc33c5a58c9.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Then, you need to commit your code to the Git repository from Hugging Spaces.
    First of all, we need to clone the repository.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Recently, HuggingFace has changed the [Git authentication process](https://huggingface.co/blog/password-git-deprecation),
    so we need to create a token first and then set it for the Git repo.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it’s time to commit files related to our application. We need to have
    at least the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.py` with the Python code that launches the Gradio app'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`requirements.txt` with the list of Python packages you need for your application.
    In our case, only `pandas` and `plotly`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, basic steps with git: add, commit and push to HuggingFaces.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It took a couple of minutes to build the app, and it’s done. Now our web application
    is up and running on HuggingFaces Spaces. You can try it [here](https://huggingface.co/spaces/miptgirl/retention_simulator).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/71ebe19bfd00d8a49459e08a65d25cbf.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: It looks much nicer than our initial version since the layout doesn’t require
    scrolling, and users don’t have to guess what parameters `a`, `c` and `d` mean.
  prefs: []
  type: TYPE_NORMAL
- en: Predicting retention
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve learned how to generate graphs based on a bunch of parameters in a web
    application. But in real life, we usually have to input quite a lot of data, so
    let’s find out how to use data from `.csv` files in apps.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we will look at actual retention data for a few first periods
    and try to predict retention for the following periods. It’s quite a common task
    since we usually don’t want to wait three months to compare third-month retention
    for the new cohort. We will upload factual data as a `.csv` file.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s not waste our time and jump to the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting data from files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is the code to generate the whole interface and business logic. It might
    look a bit complex. Don’t worry. We will discuss the core points later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at it closer. We have the following elements in the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '`periods` — input parameter,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`upload_button` — input parameter that allows you to load data from a `.csv`
    file,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default_button` — allows you to update table and graph with pre-defined values
    as an example,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`table` shows the data frame from uploaded data (either from `.csv` file or
    example); also, you could change the numbers in the table in place, and the graph
    will be updated — so it’s an input parameter as well,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image` — output parameter, that shows a plot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/c066c82f5e969b833220ac558a8de011.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Function `parse_file` gets either file from `upload_button` or string from the
    default example and returns a `pandas` data frame we could use further. So, using
    data from files is pretty straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'The crucial business logic is defined in the code snippet below. It defines
    actions for all interface elements:'
  prefs: []
  type: TYPE_NORMAL
- en: for uploading `.csv` file — the table and the plot are updated,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: for click on the button “Show example” — the table and the plot are updated,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: for changing data in the table — only the plot is updated,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: for changing the number of periods — only the plot is updated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Defining the best-fit function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The essential part of our solution is finding the best-fit function for our
    factual data. Let’s look at how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we define the function `get_mse_for_retention` that returns the error
    for the set of parameters (`a`, `c` and `d`). It also takes the data frame as
    an input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use standard Mean Squared Error (MSE) as the error we will minimize.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we will use `scipy.optimize.minimize` function for optimization. We need
    to pass just two parameters: the function to optimize (we passed the lambda function
    with a hard-coded data frame since we are optimizing only params) and the initial
    values for parameters (just a list of random values).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After optimisation, we could access optimal params using `result.x` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: That’s it, now we know the theoretical retention curve for our factual data
    and can use it in our app for prediction.
  prefs: []
  type: TYPE_NORMAL
- en: Last step
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I followed the same instructions and posted this app to HuggingFace Spaces as
    well. So you could try to play with it [here](https://huggingface.co/spaces/miptgirl/retention_prediction).
  prefs: []
  type: TYPE_NORMAL
- en: You can find the whole code for both apps in [GitHub](https://github.com/miptgirl/miptgirl_medium/tree/main/gradio_retention_app).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this article, we’ve gone through the basics of the Gradio library and learned
    how to build pleasant web applications with only Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve learned a couple of approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: High-level `gr.Interface` class that allows you to get a working prototype quickly,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More customizable way of using `gr.Blocks` when you can specify the exact layout
    you need and define complex relations between inputs and outputs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thank you a lot for reading this article. I hope it was insightful to you. If
    you have any follow-up questions or comments, please leave them in the comments
    section.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Reference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This article is inspired by “Building Generative AI Applications with Gradio”
    [course](https://www.deeplearning.ai/short-courses/building-generative-ai-applications-with-gradio/).
  prefs: []
  type: TYPE_NORMAL
