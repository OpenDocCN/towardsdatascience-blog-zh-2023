["```py\ndef find_signature_bounding_boxes(image):\n    # Start measuring time\n    start_time = time.time()\n\n    if image is None:\n        raise ValueError(\"Could not open or find the image\")\n\n    # Binarize the image using Otsu's thresholding method\n    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    # Threshold the image using Otsu's method\n    _, binary_image = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)\n\n    # Find connected components\n    num_labels, labels, stats, centroids = cv2.connectedComponentsWithStats(binary_image, connectivity=8, ltype=cv2.CV_32S)\n\n    # Calculate median area of components\n    areas = stats[1:, cv2.CC_STAT_AREA]  # Exclude background\n    median_area = np.median(areas)\n    print('median_area: ' + str(median_area))\n    median_character_width = int(math.sqrt(median_area))\n    print('median_character_width: ' + str(median_character_width))\n\n    # Define area thresholds\n    min_area_threshold = median_area * 4\n    max_area_threshold = median_area * 50\n\n    # Filter components based on area thresholds\n    possible_signatures = []\n    for i in range(1, num_labels):  # Exclude background\n        area = stats[i, cv2.CC_STAT_AREA]\n        if min_area_threshold < area < max_area_threshold:\n            left = stats[i, cv2.CC_STAT_LEFT]\n            top = stats[i, cv2.CC_STAT_TOP]\n            width = stats[i, cv2.CC_STAT_WIDTH]\n            height = stats[i, cv2.CC_STAT_HEIGHT]\n            print('Found candidate with area: ' + str(area))\n            #filter horizontal lines\n            if height < median_character_width * 5 and width > median_character_width*30:\n              print('   -> candidate is horizontal line with width, height: ' + str(width) + ',' + str(height))\n              continue\n            #filter vertical lines\n            if width < median_character_width * 5 and height > median_character_width*30:\n              print('   -> candidate is vertical line with width, height: ' + str(width) + ',' + str(height))\n              continue\n            #filter on a ratio of black pixels (logos for example have a higher ratio)for now guestimate is 0.3\n            roi = binary_image[top:top+height, left:left+width]\n            num_black_pixels = cv2.countNonZero(roi) # Calculate the number of black pixels in the ROI\n            total_pixels = width * height # Calculate the total number of pixels in the ROI\n            ratio = num_black_pixels / total_pixels # Calculate and return the ratio of black pixels\n            print('   -> candidate has black pixel ratio: ' + str(ratio))\n            if ratio > 0.30:\n              print('   -> candidate has too high black pixel ratio: ' )\n              continue\n            possible_signatures.append((left, top, width, height))\n\n    print('Nr of signatures found before merging: ' + str(len(possible_signatures)))\n    possible_signatures = merge_nearby_rectangles(possible_signatures, nearness=median_character_width*4)\n\n    # End measuring time\n    end_time = time.time()\n    print(f\"Function took {end_time - start_time:.2f} seconds to process the image.\")\n\n    return possible_signatures\n\ndef merge_nearby_rectangles(rectangles, nearness):\n    def is_near(rect1, rect2):\n        left1, top1, width1, height1 = rect1\n        left2, top2, width2, height2 = rect2\n        right1, bottom1 = left1 + width1, top1 + height1\n        right2, bottom2 = left2 + width2, top2 + height2\n        return not (right1 < left2 - nearness or left1 > right2 + nearness or\n                    bottom1 < top2 - nearness or top1 > bottom2 + nearness)\n\n    def merge(rect1, rect2):\n        left1, top1, width1, height1 = rect1\n        left2, top2, width2, height2 = rect2\n        right1, bottom1 = left1 + width1, top1 + height1\n        right2, bottom2 = left2 + width2, top2 + height2\n        min_left = min(left1, left2)\n        min_top = min(top1, top2)\n        max_right = max(right1, right2)\n        max_bottom = max(bottom1, bottom2)\n        return (min_left, min_top, max_right - min_left, max_bottom - min_top)\n\n    merged = []\n    while rectangles:\n        current = rectangles.pop(0)\n        has_merged = False\n\n        for i, other in enumerate(merged):\n            if is_near(current, other):\n                merged[i] = merge(current, other)\n                has_merged = True\n                break\n\n        if not has_merged:\n            for i in range(len(rectangles) - 1, -1, -1):\n                if is_near(current, rectangles[i]):\n                    current = merge(current, rectangles.pop(i))\n\n        if not has_merged:\n            merged.append(current)\n\n    return merged\n```"]