["```py\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.spatial.distance import pdist\n\ndef generate_points(dimensions, num_points, range_min, range_max):\n    return np.random.uniform(range_min, range_max, (num_points, dimensions))\n\ndef calculate_pairwise_distances(points):\n    distances = np.sqrt(((points[:, np.newaxis, :] - points[np.newaxis, :, :]) ** 2).sum(axis=-1))\n    np.fill_diagonal(distances, np.nan)  # Ignore self-distances by setting them to NaN\n    return distances\n\ndef calculate_distances_from_reference(points, reference_point):\n    distances = np.sqrt(((points - reference_point) ** 2).sum(axis=1))\n    return distances\n\ndef calculate_stats_for_dimensions(num_points, dimensions_range, range_min, range_max):\n    means_pairwise = []\n    stds_pairwise = []\n    means_ref = []\n    stds_ref = []\n\n    for dim in dimensions_range:\n        points = generate_points(dim, num_points, range_min, range_max)\n        pairwise_distances = calculate_pairwise_distances(points)\n        reference_point = generate_points(dim, 1, range_min, range_max)\n        distances_from_ref = calculate_distances_from_reference(points, reference_point)\n\n        means_pairwise.append(np.nanmean(pairwise_distances))\n        stds_pairwise.append(np.nanstd(pairwise_distances))\n        means_ref.append(np.mean(distances_from_ref))\n        stds_ref.append(np.std(distances_from_ref))\n\n    return means_pairwise, stds_pairwise, means_ref, stds_ref\n\ndef plot_histograms_and_stats(num_points, dimensions_range, range_min, range_max):\n    fig, axs = plt.subplots(2, 3, figsize=(12, 7), tight_layout=True)\n\n    # Plotting histograms for 3D and 100D\n    for i, dim in enumerate([3, 100]):\n        points = generate_points(dim, num_points, range_min, range_max)\n        pairwise_distances = calculate_pairwise_distances(points)\n        reference_point = generate_points(dim, 1, range_min, range_max)\n        distances_from_ref = calculate_distances_from_reference(points, reference_point)\n\n        axs[i, 0].hist(pairwise_distances[~np.isnan(pairwise_distances)], bins=50, alpha=0.7, color='blue', edgecolor='black')\n        axs[i, 0].set_title(f'Pairwise Distances in {dim}D')\n        axs[i, 1].hist(distances_from_ref, bins=30, alpha=0.7, color='green', edgecolor='black', range=(0, max(distances_from_ref)))\n        axs[i, 1].set_title(f'Distances to Reference in {dim}D')\n\n    # Calculating and plotting mean and std deviation trends across dimensions\n    means_pairwise, stds_pairwise, means_ref, stds_ref = calculate_stats_for_dimensions(num_points, dimensions_range, range_min, range_max)\n\n    # Plotting mean and std deviation graphs for pairwise distances\n    axs[0, 2].plot(dimensions_range, means_pairwise, label='Mean Pairwise', marker='o', color='blue')\n    axs[0, 2].plot(dimensions_range, stds_pairwise, label='Std Dev Pairwise', marker='x', color='cyan')\n    axs[0, 2].set_title('Pairwise Distances Stats')\n\n    # Plotting mean and std deviation graphs for distances to reference point\n    axs[1, 2].plot(dimensions_range, means_ref, label='Mean Reference', marker='o', color='green')\n    axs[1, 2].plot(dimensions_range, stds_ref, label='Std Dev Reference', marker='x', color='lime')\n    axs[1, 2].set_title('Reference Point Distances Stats')\n\n    axs[0, 2].legend()\n    axs[1, 2].legend()\n\n    plt.show()\n\nplot_histograms_and_stats(1000, range(1, 101), 1, 100)\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.spatial.distance import pdist\n\ndef generate_points(dimensions, num_points, range_min, range_max):\n    return np.random.uniform(range_min, range_max, (num_points, dimensions))\n\ndef calculate_distances_stats(points):\n    # Compute pairwise distances\n    distances = pdist(points)\n\n    # Calculate average and maximum distance\n    average_distance = np.mean(distances)\n    max_distance = np.max(distances)\n\n    return average_distance, max_distance\ndef plot_normalized_difference(num_points, dimensions_range, range_min, range_max):\n    normalized_differences = []\n\n    for dim in dimensions_range:\n        points = generate_points(dim, num_points, range_min, range_max)\n        average_distance, max_distance = calculate_distances_stats(points)\n        normalized_difference = (max_distance - average_distance) / max_distance\n        normalized_differences.append(normalized_difference)\n\n    plt.figure(figsize=(8, 6))\n    plt.plot(dimensions_range, normalized_differences, label='Normalized Difference', marker='o', color='blue')\n    plt.xlabel('Number of Dimensions')\n    plt.ylabel('Normalized Difference')\n    plt.title('Normalized Difference Between Max and Average Distances Across Dimensions')\n    plt.legend()\n    plt.show()\nplot_normalized_difference(500, range(1, 101), 0, 1)\n```", "```py\nimport numpy as np\n\ndef test_orthogonality(dimensions, n_trials):\n    for i in range(n_trials):\n        # Generate two random vectors\n        v1 = np.random.randn(dimensions)\n        v2 = np.random.randn(dimensions)\n\n        # Calculate dot product\n        dot_product = np.dot(v1, v2)\n\n        # Calculate magnitudes\n        magnitude_v1 = np.linalg.norm(v1)\n        magnitude_v2 = np.linalg.norm(v2)\n\n        # Calculate the cosine of the angle\n        cos_theta = dot_product / (magnitude_v1 * magnitude_v2)\n\n        # Check if vectors are almost orthogonal\n        if np.abs(cos_theta) < 0.1:  # Adjust this threshold as needed\n            orthogonality = \"Almost Orthogonal\"\n        else:\n            orthogonality = \"Not Orthogonal\"\n\n        # Calculate angle in degrees\n        theta = np.arccos(cos_theta) * (180 / np.pi)  # Convert to degrees\n\n        print(f\"Trial {i+1}:\")\n        print(f\"  Dot Product: {dot_product}\")\n        print(f\"  Cosine of Angle: {cos_theta}\")\n        print(f\"  Angle: {theta} degrees\")\n        print(f\"  Status: {orthogonality}\")\n        print(\"--------------------------------\")\n\n# Try to edit this and notice the near-orthogonality of vectors in higher dimensions\ndimensions = 100  # Number of dimensions\nn_trials = 10     # Number of trials\n\ntest_orthogonality(dimensions, n_trials)\n```"]