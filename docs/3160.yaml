- en: Quantum Computing for Complete Beginners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://towardsdatascience.com/quantum-computing-for-complete-beginners-63b989ded053?source=collection_archive---------1-----------------------#2023-10-20](https://towardsdatascience.com/quantum-computing-for-complete-beginners-63b989ded053?source=collection_archive---------1-----------------------#2023-10-20)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*A guide to the basics of quantum computing with no prior knowledge required*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://angjelinhila.medium.com/?source=post_page-----63b989ded053--------------------------------)[![Angjelin
    Hila](../Images/44d826eda81d6fb95ec9c65a1da5933d.png)](https://angjelinhila.medium.com/?source=post_page-----63b989ded053--------------------------------)[](https://towardsdatascience.com/?source=post_page-----63b989ded053--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----63b989ded053--------------------------------)
    [Angjelin Hila](https://angjelinhila.medium.com/?source=post_page-----63b989ded053--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ¬∑
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fcb73222d75bc&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fquantum-computing-for-complete-beginners-63b989ded053&user=Angjelin+Hila&userId=cb73222d75bc&source=post_page-cb73222d75bc----63b989ded053---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----63b989ded053--------------------------------)
    ¬∑25 min read¬∑Oct 20, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F63b989ded053&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fquantum-computing-for-complete-beginners-63b989ded053&user=Angjelin+Hila&userId=cb73222d75bc&source=-----63b989ded053---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F63b989ded053&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fquantum-computing-for-complete-beginners-63b989ded053&source=-----63b989ded053---------------------bookmark_footer-----------)![](../Images/a8494d01986d3b1e1a88bf3f0d9193c8.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'An IBM Quantum cryostat used to keep IBM‚Äôs 50-qubit quantum computer cold in
    the IBM Quantum lab in Yorktown Heights, New York. source: [https://www.flickr.com/photos/ibm_research_zurich/40786969122](https://www.flickr.com/photos/ibm_research_zurich/40786969122)'
  prefs: []
  type: TYPE_NORMAL
- en: Some have described the last several millennia of human dominion over the earth‚Äôs
    resources as the *anthropocene*, deriving from the Greek ‚Äúanthropo‚Äù meaning human,
    and ‚Äúcene‚Äù meaning recent. The last century in particular has been dubbed the
    [fourth industrial revolution](https://www.weforum.org/focus/fourth-industrial-revolution),
    due to the pace of technological innovation ushered in by the advent of computers
    in the middle of the 20th century.
  prefs: []
  type: TYPE_NORMAL
- en: In the past seventy years, computation has transformed every aspect of society,
    enabling efficient production at an accelerated rate, displacing human labour
    from chiefly production to services, and exponentially augmenting information
    storage, generation, and transmission through telecommunications.
  prefs: []
  type: TYPE_NORMAL
- en: How did we get here? Fundamentally, technological advancement draws on existing
    science. Without an understanding of the nature of electromagnetism and the structure
    of atoms, we wouldn‚Äôt have electricity and the integrated circuitry that power
    computers. It was only a matter of time, then, before we thought of exploiting
    the most accurate, fundamental description of physical reality provided by [quantum
    mechanics](https://en.wikipedia.org/wiki/Quantum_mechanics) for computation.
  prefs: []
  type: TYPE_NORMAL
- en: I became interested in quantum computation through both a strong interest in
    physics and the nature of computation. If successful, quantum computation could
    usher in an unprecedented chapter in our information age by exponentially augmenting
    the efficiency of current computers. As someone interested in data, computation,
    and information science, understanding the rudiments of quantum information will
    not only equip you with a very basic understanding of quantum physics but also
    prepare you for the next major technological frontier of our information age.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum Phenomena & Quantum Information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to understand the basics of computing, it is necessary to have a basic
    understanding of the physical phenomena that quantum computing exploits.
  prefs: []
  type: TYPE_NORMAL
- en: The phenomena in question are ***electron* *spin***and ***light polarization***,
    the latter being another term for *photon spin*. Recall that electrons are negatively
    charged subatomic particles that surround a positively charged nucleus, whereas
    photons are the particle equivalents of electromagnetism or light. Electron and
    photon spin are connected since they both refer to quantum properties that have
    no analogue in classical mechanics, which describes the scale of everyday objects.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, the easiest way to introduce spin is to draw a comparison to a
    classical property called angular momentum. Angular momentum refers to the rotational
    equivalent of linear momentum in a classical system, where momentum is calculated
    as the product of mass and velocity. As such, momentum is a vector quantity since
    it possesses both magnitude and direction. Angular momentum is represented as
    the cross product of the position and momentum vectors of a particle. Since angular
    momentum is a classical property, it admits of continuous values and can be expressed
    as a volume integral (generalized from the integral as the area under the curve
    in two dimensions).
  prefs: []
  type: TYPE_NORMAL
- en: Spin is often defined as *intrinsic angular momentum.* Recall that in classical
    mechanics force is defined as change in momentum. Furthermore the energy of the
    system is defined in terms of motion or the rate of change of motion, which presupposes
    mass. Unlike classical mechanics, Einstein‚Äôs special theory of relativity ascribes
    intrinsic energy to rest mass through the equality E = mc¬≤. Similarly, intrinsic
    angular momentum is intimately bound up with the intrinsic energy state of a subatomic
    particle. In fact, it is a property that elementary particles possess whether
    or not they are actually rotating, that is, regardless of extrinsic factors like
    momentum and position, hence the qualifier *intrinsic*. Like classical angular
    momentum, quantum spin changes under rotations. However, unlike classical angular
    momentum, spin is quantized, which means that it only admits a discrete set of
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The maximum spin of an elementary particle is given by the product of n (any
    integer of half integer n/2 values) and the reduced Planck‚Äôs constant ‚Ñè (h/2ùúã)
    . All ordinary particles, called fermions, have half-integer (1/2) spin, whereas
    force-carrier particles, known as bosons, like the photon have integer (1) spin.
    Both electrons and photons have two possible spin states: spin ‚Äúup‚Äù or ‚Äúdown‚Äù.
    In mathematical terms, electrons will have a maximum spin of 1/2‚Ñè or -1/2‚Ñè, namely
    spin in the positive or negative ‚Äúrotations‚Äù. The photon will have maximum spin
    of 1‚Ñè and -1‚Ñè, since it takes integer spin values. Even though we‚Äôre using the
    word ‚Äúrotation‚Äù, it is best not think of it in terms of spatial transformations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let‚Äôs look at the strange quantum properties that will be exploited for
    quantum computation. We noted earlier that the electron can have two possible
    spin states, but which state is it in at any given moment? This is where it is
    useful to draw a distinction between the *state* of the system and *measurement*.
    In classical mechanics, state and measurement coincide perfectly: the state of
    the system is what you measure. Not in quantum mechanics. The state of the system
    without measurement is given by a coherent superposition of wave functions ùõπi
    . After measurement, the state of the system will be given by either ùõπ‚Üì or ùõπ‚Üë,
    if we‚Äôre measuring a single particle. This disjunction between state and measurement
    enables quantum computers to carry out operations that can take infinite values
    in two dimensional complex vector spaces.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, measurements obey certain rules relative to the way the measurement
    is carried out. Specifically, the direction of measurement matters for the outcome.
    Let‚Äôs say we have two directions: vertical and horizontal. If we measure the spin
    of an electron in the vertical direction, we will get a state of spin up or down.
    If we carry out the exact same measurement, that is, measure spin again in the
    vertical direction, we will get the same outcome. This shows that there‚Äôs an experimental
    setup that yields predictable outcomes. However, if we first measure the spin
    of the electron in the vertical direction and subsequently in the horizontal and
    keep repeating the measurement, the outcomes will be a random sequence of spin
    up or down that distribute uniformly between the two with enough trials. This
    means that if we‚Äôre not careful, quantum measurements can produce random outcomes.
    The purpose of quantum algorithms will be to control the operations so that we
    get the outcomes we desire.'
  prefs: []
  type: TYPE_NORMAL
- en: Even though ***qubits***, the informational units of quantum computing, can
    be represented either by electron or photon spin, we will use the former as the
    physical analogue of quantum computation going forward.
  prefs: []
  type: TYPE_NORMAL
- en: From Quantum Phenomena to Quantum Computation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The fundamental informational unit of a classical computer is a called a bit,
    which has two discrete states often represented as 0 or 1\. Since the computer
    is a physical machine, this mathematical abstraction must be mapped to some physical
    phenomenon. Classical computers map these discrete states on a flowing current
    or voltage. When the voltage is low or close to none, we use it to represent state
    0 and when the voltage is higher, we use it to represent 1\. In other words, modulations
    of voltage magnitudes allow us to mechanistically realize a binary system of representation.
    Sequences of these low-voltage and high-voltage states are subsequently arranged
    into electrical circuits that simulate logical operations like AND, XOR etc called
    logic gates. Combinations of logical operations through electrical circuitry are
    subsequently scaffolded to execute any computable algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we see that classical computers leverage electricity to realize computations,
    it helps us to understand how a quantum computer might operate. Unlike a classical
    computer, a quantum computer leverages quantum or subatomic scale phenomena to
    carry out computations. While voltage in our everyday macro scale is measured
    as a continuous variable, quantum mechanics tells us that at the subatomic scale
    this is not really the case. Rather, by all experimental accounts, subatomic particles
    appear to occupy only discrete energy states. This means that an electron and
    a photon can occupy some energy states, and not others. This contravenes our intuitions
    about physical objects being able to occupy any continuous energy state. For example,
    while we typically think of time as a purely continuous variable that‚Äôs infinitely
    divisible, this is starkly not the case for the energy states of subatomic particles.
  prefs: []
  type: TYPE_NORMAL
- en: 'This has the peculiar consequence that subatomic particles cannot be described
    as having fixed positions and momenta. While we can try to describe these variables
    simultaneously, there‚Äôs a physical scale in which the precision breaks down such
    that knowing the momentum means losing track of the position and vice versa. That
    physical scale is the called the Planck scale denoted by ***h***: 6.626070¬∑ 10‚Åª¬≥‚Å¥
    m¬≤kg/s and represents the physical threshold between classical and quantum scale
    phenomena. At this scale, again by all experimental evidence, subatomic particles
    occupy all their possible states simultaneously. Because of this property, we
    can only describe subatomic particles as probability distributions of all their
    possible states as described by Schr√∂dinger‚Äôs equation. As we pointed out earlier
    however, there‚Äôs a second description called a measurement. Prior to measurement,
    the particle exists in a state of superposition as described by Schr√∂dinger‚Äôs
    wave function. After measurement, the particle collapses to a discrete state of
    one position or another. Quantum computing leverages this peculiar property of
    quantum mechanics to perform computations, that is, by taking advantage of both
    *superposition* and *measurement* states. (If you want to get clear on the experimental
    basis of the objectivity of the superposition read [*this*](https://en.wikipedia.org/wiki/Bell_test)).'
  prefs: []
  type: TYPE_NORMAL
- en: So if a classical computer builds computations from two possible discrete states,
    we can think of a quantum computer as building computations from discrete states
    as well as superpositions. A qubit can be in state 0 or 1 when we measure it.
    However, prior to measurement, the qubit is in a superposition of 0 and 1\. During
    superposition, the qubit can occupy an infinite number of states. By leveraging
    the laws of quantum mechanics, quantum computation surpasses the computational
    capacities of classical computation whose state space is confined to 2^n. To be
    sure, measurement reduces quantum states to classical states, namely, the same
    state space of 2^n. In what way then does quantum computing confer advantages
    that elude classical computing?
  prefs: []
  type: TYPE_NORMAL
- en: As we will see below, quantum algorithms enable controlled operations in the
    state of superposition that allow us to get useful answers after measurement.
    Computer scientists define the complexity of an algorithm with respect to the
    time steps required to solve it. If *n* denotes the input length of the algorithm
    and *T(n)* the time to solve it, then complexity refers to the function that describes
    the growth of *T(n)*. If *T(n)* amounts to a polynomial, then the algorithm is
    said to belong to a polynomial-time class problem. If *T(n)* amounts to an exponential
    function, then it belongs to an exponential-time class problem. Those that belong
    to exponential time, like the prime factorization of large numbers, are intractable
    for classical computers since the time required to solve the problem increases
    exponentially and can easily exceed human-scale time constraints.
  prefs: []
  type: TYPE_NORMAL
- en: The promise of quantum computing lies partly in being able to solve exponential-time
    problems sufficiently quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Representing Qubits: Linear Algebra'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to understand quantum computing, we have to understand some of the
    math underlying the representation of qubits. The mathematical tools need to correspond
    to the underlying phenomena upon which we will map computation, primarily linear
    algebra.
  prefs: []
  type: TYPE_NORMAL
- en: '*We represent Qubits with two-dimensional unit vectors.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***What is a vector?***'
  prefs: []
  type: TYPE_NORMAL
- en: 'A vector is a quantity that is expressed by at least two values: a magnitude
    and a direction. A vector‚Äôs magnitude is given by the Euclidean distance, whereas
    the direction is given by the starting point. (1,-3) for example represents a
    two dimensional vector, with a length of 3.162 and a direction given by the x
    value.'
  prefs: []
  type: TYPE_NORMAL
- en: '***What is a unit vector?***'
  prefs: []
  type: TYPE_NORMAL
- en: A unit vector is a vector with length or magnitude equal to 1\. For example
    <0,1> is a unit vector because if we calculate the Euclidean distance using the
    Pythagorean Theorem we get the value 1.
  prefs: []
  type: TYPE_NORMAL
- en: '***Why two-dimensional unit vectors?***'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since there are two possible electron spin measurement outcomes, a two dimensional
    vector space denoted by ‚Ñù¬≤ will do. We use unit vectors because we want to limit
    measurement outcomes to two possible values: 0 or 1\. As we will see, the operations
    we will perform on qubits will amount to rotations on a unitary plane. However,
    the space of possible outcomes should include all possible rotations on a three
    dimensional sphere whose underlying space is still two dimensional, denoting the
    two possible measurement outcomes. To do this we represent vectors as complex
    numbers rather than as real numbers, denoted by the complex vector space ‚ÑÇ¬≤. (Complex
    numbers are any operations involving real numbers and imaginary numbers, where
    an imaginary number *i* is equal to ‚àö-1) For simplicity‚Äôs sake, we will for now
    stick to ‚Ñù¬≤ and eschew complex numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to limit outcomes to two possible values, we need more than just unit
    vectors. We need pairs of unit vectors to be *orthogonal* to each other. Two vectors
    are orthogonal to each other if and only if their ***inner or dot product*** equals
    to zero. When combinations of unit vectors are orthogonal to each other, we call
    those **orthonormal bases**, combining the word normal that stands for unit vectors
    and orthogonal.
  prefs: []
  type: TYPE_NORMAL
- en: '**Orthogonality**: Two vectors are orthogonal if and only if their product
    equals zero : <a|b> = 0.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We can check that any n-dimension ket is an orthonormal basis if the product
    of the matrix A and its transposal A^T equals an **identity matrix** In.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bracket Notation**'
  prefs: []
  type: TYPE_NORMAL
- en: Before we describe these bases, let‚Äôs say a few words about the standard notation
    used in linear algebra so that you you‚Äôre able to interpret symbols appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: '*Column vectors* are called **bras,** whereas *row vectors* are called **kets**
    denoted as follows: <a| & |b>, where:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d98f9f4fdf10b3774ba7e471aeaf815e.png)'
  prefs: []
  type: TYPE_IMG
- en: bras are row vectors, where as kets are column vectors.
  prefs: []
  type: TYPE_NORMAL
- en: Together, they form *bra-kets*. From the dot product rule (i.e. vector multiplication),
    we can only multiply bras with kets provided that each have equal dimensionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The inner product of the bra-ket above is represented by **<a|b>** and denotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7e9e55a7f231c87ce60a2ecf56c29871.png)'
  prefs: []
  type: TYPE_IMG
- en: dot product of two unit vectors.
  prefs: []
  type: TYPE_NORMAL
- en: However, vectors of the same type (bra or ket) of the same dimension can be
    summed.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using actual values, we can use arrows to represent the types of
    orthonormal pairs relevant for electron spin measurement.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three orthonormal bases for spin:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4e983c9b799f48d0f7c23e1222006fde.png)'
  prefs: []
  type: TYPE_IMG
- en: Three two dimensional orthonormal bases used to measure spin (Berhardt, 2019).
  prefs: []
  type: TYPE_NORMAL
- en: 'When we multiply bras and kets of the same spin, we yield a value of 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b691aa2aa9c47b97773a7bc16215b644.png)'
  prefs: []
  type: TYPE_IMG
- en: Equal orthonormal bra-kets have a dot product of 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conversely, when we multiply bras and kets of opposite spins, we yield a value
    of 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9b0844c8c4c010a49f15314c731231ab.png)'
  prefs: []
  type: TYPE_IMG
- en: Opposite orthonormal bra-kets have a dot product of 0.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, **orthonormal bracket products** give us measurements that simulate
    binary outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: The first basis, represented by the up and down arrows, is called the **standard
    basis** and corresponds to vertical measurement of spin, that is, measurement
    along the y-axis. The second basis, represented by the right and left arrows corresponds
    to the horizontal measurement of spin, namely measurement along the x-axis. Generally,
    ordered orthonormal bases represent the measurement of spin along a certain direction.
    In fact we can measure spin at any angle or direction ùõ≥ and the output will collapse
    to a discrete outcome of spin up or down in that direction, since spin states
    can only be discrete.
  prefs: []
  type: TYPE_NORMAL
- en: '*A quantum state* of a single or multiple qubits will be given by a linear
    combination of these bases. The basis vectors, therefore, will represent the possible
    outcomes of a quantum state. As we said earlier, the state of a qubit can be modelled
    on the spin of an electron or photon. Prior to measurement, the particle or the
    quantum state will be in superposition, represented by a linear combination of
    the bases |b1> and |b2> that takes the form of **c1|b1> + c2|b2> ,** where c1
    and c2 represent probability amplitudes. Because the probability amplitudes can
    be negative, only their squared values are used to represent the probabilities
    of the outcomes where c1¬≤ + c2¬≤ = 1\. In a superposition, therefore, c1¬≤ and c2¬≤
    will each have a probability of 0.5.'
  prefs: []
  type: TYPE_NORMAL
- en: After measurement, the spin state collapses to one of the orthonormal bases
    |b1> or |b2>. The probability of collapsing to |b1> is given by c1¬≤, while the
    probability of collapsing to |b2> is given by c2¬≤. If the measurement collapses
    to |b1>, c1¬≤ will equal 1 and c2¬≤ 0 and vice versa. To put it even more bluntly,
    the basis vector multiplied with probability value 1 will represent the outcome
    of the measurement.
  prefs: []
  type: TYPE_NORMAL
- en: 'In classical computing, multiple bits are represented by the tensor product
    of those bits, denoted by the following symbol: ‚äó'
  prefs: []
  type: TYPE_NORMAL
- en: 'We said that [1,0] and [0,1] kets represent the standard bases, and therefore
    constitute analogues of 0 and 1 respectively in classical bits. We also said that
    any quantum state must conserve the following equality: **c1¬≤ + c2¬≤ = 1**. We
    called it the unit measure constraint ([*the second axiom of probability theory*)](https://en.wikipedia.org/wiki/Probability_axioms#Second_axiom),
    which means that all kets must be unit vectors in ‚Ñù¬≤. However, since actual quantum
    particle states are represented via complex numbers, the actual state space is
    given by ‚ÑÇ¬≤. Therefore, the actual unit measure constraint is given by: ‚Äñùõº‚Äñ¬≤ +
    ‚ÄñŒ≤‚Äñ¬≤ = 1, where ùõº and Œ≤ are complex numbers and represent probability amplitudes.'
  prefs: []
  type: TYPE_NORMAL
- en: To represent multiple qubit states we therefore take the tensor product of our
    standard bases |0> and |1>. Notice that the product will conserve the unit measure
    constraint, regardless of how many qubits we concatenate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/92a41c3d853bdbb941f821b2f5fe1796.png)'
  prefs: []
  type: TYPE_IMG
- en: Tensor product of two 1 qubits yields the above vector.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/05b6461f7a9e5a517954eceed1bb6525.png)'
  prefs: []
  type: TYPE_IMG
- en: Tensor product of two 0 qubits yields the above vector.
  prefs: []
  type: TYPE_NORMAL
- en: Since we‚Äôve been working in ‚Ñù¬≤, we can heuristically represent the state space
    of a qubit in two dimensions (x,y) via a unit circle. Remember that all operations
    will be on the orthonormal bases we enumerated above. Furthermore, all quantum
    logic gates will be represented by unitary and thereby orthogonal matrices. Why?
    Because vector multiplication by an orthogonal matrices produces *rotations* by
    preserving the inner product of vectors. This produces isometric transformations
    on a Euclidean space.
  prefs: []
  type: TYPE_NORMAL
- en: Notice, also, the negative signs for every 180‚Å∞ rotations. The negative signs
    help distinguish equivalent outputs such that every operation can in principle
    be invertible or reversible. All quantum computations will need to be reversible
    to leverage the computational capacities of quantum states, namely the states
    of superposition and entanglement prior to measurement. As we will see later,
    the state of superposition (as well as entanglement) endows quantum computing
    with advantages that elude classical computing. In the state of superposition,
    any arbitrary number of qubits N occupy all of their possible states at once.
    If we have 4 qubits, the sample will have 2‚Å¥ possible states, but in superposition
    all these states will obtain simultaneously. The probability of collapsing to
    one of these states upon measurement will be distributed equally along the linear
    combination of the unit vectors.
  prefs: []
  type: TYPE_NORMAL
- en: The lines in the unit circle below represent the state changes from input to
    output via operations with the Hadamard gate, which puts qubits into superposition
    and back. Due to the following equality ‚Äñùõº‚Äñ¬≤ + ‚ÄñŒ≤‚Äñ¬≤ = 1, measurement will always
    collapse the system into a distinct classical state, which in our case map to
    electron or photon spin. Operations with quantum gates however change the state
    of a single or multiple qubits without collapsing the wave function.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8c8e1a3cd177ec02dd33fb8ea98175e4.png)'
  prefs: []
  type: TYPE_IMG
- en: Qubit unit circle representation. Image from Wikimedia commons.
  prefs: []
  type: TYPE_NORMAL
- en: If we apply the bit-flip operator, equivalent to the NOT gate in classical computing,
    it will invert the value of the input state. For example, the |1> ket will flip
    to the |0> ket indicated below by the state transition from (0,1) to (1,0).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Hadamard gate, meanwhile, takes (0,1) as input and outputs (1/‚àö2,‚àí1/‚àö2)
    by multiplying the input with the following orthogonal or unitary matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/596c2842ccbaf499cdb9947dcc60954f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In case you‚Äôre wondering exactly how the state changes, here‚Äôs an explicit
    illustration of matrix multiplication with the Hadamard gate from |1> input:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2a596fa69464a55b483f1192c6bf3f61.png)'
  prefs: []
  type: TYPE_IMG
- en: Hadamard gate operation with |1> input state vector.
  prefs: []
  type: TYPE_NORMAL
- en: '***How does the Hadamard gate work and what is so special about it?***'
  prefs: []
  type: TYPE_NORMAL
- en: Notice by looking at the unit circle that the bit-flip operation corresponds
    to a 90‚Å∞ rotation on the unit circle, meanwhile the Hadamard gate corresponds
    to 180‚Å∞ rotation. What you need to keep in mind is that all quantum gates are
    done via orthogonal or unitary matrixes, which produce rotations along the origin.
    The Hadamard gate, specifically, produces half-rotations between the x and y axes,
    which correspond to probability amplitudes of 0.5.
  prefs: []
  type: TYPE_NORMAL
- en: Notice also that the vector output is a unit vector since (1/‚àö2, ‚àí1/‚àö2) observes
    the following identity ‚Äñùõº‚Äñ¬≤ + ‚ÄñŒ≤‚Äñ¬≤ = 1\. Try to do the calculation yourself by
    plugging in the output values in place of ùõº and Œ≤.
  prefs: []
  type: TYPE_NORMAL
- en: Think of the state of the qubit at some point in the unit circle as distributing
    the probability amplitudes from analogues of 0 and 1 to some set of values in
    between that conserve the unit sum. The Hadamard gate sets that distribution exactly
    to a 50/50 outcome. In other words, there‚Äôs a 50/50 chance that measurement will
    collapse the qbit to |0> or |1> state vectors. This is the mathematical analogue
    to a state of superposition. We will see later how superposition can be leveraged
    computationally.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, our demonstrations thus far have utilized the unit circle as the space
    of possible states of a qubit in ‚Ñù¬≤. Since actual qbit states are represented
    by complex numbers in ‚ÑÇ¬≤, a more accurate representation of the qubit state space
    is given by what‚Äôs called a **block sphere**, which aims to capture the possible
    states of complex valued numbers shown below as a three-dimensional sphere.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/37fcd2c0b73912cf049f454408a00bc9.png)'
  prefs: []
  type: TYPE_IMG
- en: Qubit block sphere representation. Image from Wikimedia commons.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum Logic Gates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Much like traditional computing, logic gates in quantum computing consist of
    circuits that perform some operation on a qubit or sets of qubits. Earlier we
    saw that quantum gates mathematically amount to matrix multiplications on qubits.
    We also said that qubits are represented by unit vectors, whereas quantum logic
    gates by orthogonal or unitary matrices. As we saw, these produce rotations on
    a unit sphere, or circle, to reduce the complex space to a two-dimensional one
    for the sake of simplification.
  prefs: []
  type: TYPE_NORMAL
- en: However, to perform operations on qubits, quantum gates must be reversible.
    Reversibility means that every operation from *input* to *output* must also be
    revertible from *output* to *input*. The reason for this is that quantum states
    are reversible, time-reversal invariant, and conserve information in the state
    of superposition. What we termed *measurement*, however, reduces the quantum state
    into a classical one. Measurement or collapse is irreversible and does not thereby
    conserve input information. In other words, we cannot revert the collapse into
    its preceding superpositioned state. As such, quantum gates constitute controlled
    operations that manipulate the quantum state while also conserving it. The circuitry
    necessary for these outcomes leverages semiconductor particles a few nanometers
    in size called quantum dots that have to be kept temperatures close to zero Kelvin.
    However, it is crucial to note that the desired outputs of quantum computation
    can only be retrieved through measurement.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are, therefore, two properties that matter the most when it comes to
    quantum logic gates: a) **reversibility** and b) **universality**. Universality
    refers to a type of logic gate that can compute all possible operations on bits.
    The most well known universal gate in classical computing is NAND (NOT AND) represented
    by the table below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4084cfd71b8c1be84e10574f9022fe8b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that NAND is the truth-functional *complement* to AND. At most, only two
    logical operators suffice to express all possible logical statements including
    the theorems of logic. This is known as *functional completeness*. Since NAND
    combines both NOT & AND into one operation, by corollary it qualifies as a functionally
    complete and thereby universal logical operator and gate. For comparison‚Äôs sake,
    let‚Äôs look at the truth table for AND:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/fafcba244a3d83d847426733e33562a2.png)'
  prefs: []
  type: TYPE_IMG
- en: In classical computing, most operations are irreversible. For example, if we
    input a sequence 010011110 into most logic gates and get another binary sequence
    as output, we would not be able to retrieve the input sequence from the output
    sequence alone. XOR and NAND are both irreversible. However, there are some gates
    that allow us to retrieve the input from the output alone, like the CNOT (equivalent
    to XOR but reversible), Hadamard and TOFFOLI gates. Among these, the Hadamard
    and TOFFOLI qualify as both *reversible* and *universal*. However, there are other
    gates that meet these qualifications like the FRIEDKIN gate. We will focus on
    the former triad.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now take a look at two gates essential for most quantum computations:
    CNOT & Hadamard. The CNOT operates on two or more qubits by entangling them. The
    Hadamard gate operates on one or more qubits by putting them into superposition.
    We will also look at a third gate, the TOFFOLI gate, also known as the controlled-controlled
    NOT gate, which is a universal version of the CNOT gate.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What is the purpose of the CNOT gate? It allows us to entangle two input qubits
    by performing bit-flip operations that are reversible. The CNOT gate consists
    of two inputs: a control and a target input. When the control bit equals 1 the
    CNOT gate flips the target input. When the control bit equals 0, the CNOT gate
    does nothing. This way, every output combination can be traced back to one and
    only one input combination.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6507d34751e0517f6ce3c15b47e4813f.png)'
  prefs: []
  type: TYPE_IMG
- en: Classical CNOT gate with bits and tensor product output
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/81fe0475faab25aaeae46e72c20af64f.png)'
  prefs: []
  type: TYPE_IMG
- en: Quantum CNOT gate on standard bases and tensor product output
  prefs: []
  type: TYPE_NORMAL
- en: In what sense is the CNOT gate equivalent to entanglement?
  prefs: []
  type: TYPE_NORMAL
- en: Let‚Äôs take a look at an operation by the CNOT gate on |1> and |0> qubits. We
    take the tensor product of the two qubits and multiply it with the CNOT gate unitary
    matrix, which converts the input tensor product from |10> to |11>. Why? Because
    CNOT flips the value of the target qubit if and only if the control qubit equals
    |1>.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a34217aef74e6af64eef40855cf0e0c1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By corollary, if our target qubit is |1> instead of |0>, the CNOT gate predictably
    flips the value back to |0> as we see below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/51d23677f57a1e2f559acf2062f60a31.png)'
  prefs: []
  type: TYPE_IMG
- en: In other words, CNOT is the reversible classic-computational equivalent of the
    XOR (exclusive OR).
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, the **Hadamard gate** yields a perfect superposition.
    How does it do that? Take a look at the orthogonal matrix below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/538f68fccfa8d14be05dc3d20e54189c.png)'
  prefs: []
  type: TYPE_IMG
- en: Hadamard gate is an orthogonal matrix that puts input qubits into superposition
    and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we multiply the matrix with a standard base |0>, then it outputs the following
    state: (1/‚àö2, 1/‚àö2) which is equivalent to (|0>+|1>)/‚àö2\. Conversely, if we multiply
    it with |1>, we get (1/‚àö2,‚àí1/‚àö2), which is equivalent to (|0>‚àí|1>)/‚àö2\. Even though
    each input converts the output to an equal distribution of probability amplitudes,
    the negative sign allows us to distinguish the input (whether it is |0> or |1>)
    and thereby ensures the operation is reversible.'
  prefs: []
  type: TYPE_NORMAL
- en: Each value has a 50/50 chance of outcome in the classical world. Notice that
    in our example we carried out the operation on a single qubit. How do we put multiple
    qubits on superposition?
  prefs: []
  type: TYPE_NORMAL
- en: We need to pass each qubit separately through a Hadamard gate, then take their
    tensor product. As we noted earlier, multiple qubit states are represented as
    tensor products of single qubit states.
  prefs: []
  type: TYPE_NORMAL
- en: 'Below you can see the operation on a single qubit by multiplying the |1> standard
    base with the Hadamard matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b4a8e0b24b69e0c39bae140c417a787b.png)'
  prefs: []
  type: TYPE_IMG
- en: Finally, let‚Äôs take a look at the TOFFOLI gate, also known as the controlled-controlled-not
    (CCNOT) gate. The TOFFOLI gate is identical to the CNOT save for having an additional
    control variable. With two control variables, the TOFFOLI gate utilizes an 8x8
    orthogonal matrix for operations on three input qubits. Like CNOT, TOFFOLI produces
    quantum entanglement, and can be used to entangle and disentangle qubits.
  prefs: []
  type: TYPE_NORMAL
- en: 'The TOFFOLI gate input-output tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d3dc1f6ea9e96884033c394453eb003b.png)'
  prefs: []
  type: TYPE_IMG
- en: Classical Toffoli gate inputs and outputs.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4a69c119395b70bdc6bb366eae6d78c5.png)'
  prefs: []
  type: TYPE_IMG
- en: Quantum Toffoli gate inputs and outputs.
  prefs: []
  type: TYPE_NORMAL
- en: '*Why do we need the TOFFOLI gate when we have CNOT?*'
  prefs: []
  type: TYPE_NORMAL
- en: Because like NAND, TOFFOLI is universal for classical computation and can thereby
    be used by a quantum computer to simulate reversible classical computations. TOFFOLI
    is however not quantum computationally universal since it cannot produce superpositions.
  prefs: []
  type: TYPE_NORMAL
- en: '***Now that we have some handle on quantum logic gates and the operations that
    they perform, how do we combine them to get quantum algorithms?***'
  prefs: []
  type: TYPE_NORMAL
- en: Since quantum gates preserve the state of superposition, we can use them to
    perform unitary computations that are reversible. Physically speaking, the evolution
    of the system in time is described by Schr√∂dinger‚Äôs wave function. To retrieve
    any information from the quantum computer, however, we need to collapse the wave
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, we combine operations of bit-flips and Hadamard gates to get desired
    outcomes. However, bit-flips are non-reversible. The challenge of quantum computing
    lies in devising ways to write non-reversible functions in a reversible way. We
    will see how to do this with the Deutsch algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Classical bits are special cases of qbits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In principle, a quantum computer can instantiate all classical computations
    as these are a proper subset of quantum computations.
  prefs: []
  type: TYPE_NORMAL
- en: In order to realize classical computations through a quantum computer, we must
    limit computations to qubits expressed by ***normal bases*** (as analogs to classical
    bits) we‚Äôve been using as examples all along and design circuitry that utilize
    ***classically universal reversible gates*** like the TOFFOLI gate. Since the
    TOFFOLI gate is a universal gate for classical computation, it can be used to
    instantiate classical computations.
  prefs: []
  type: TYPE_NORMAL
- en: However, we haven‚Äôt said anything thus far about quantum algorithms. Just how
    would be go about constructing one?
  prefs: []
  type: TYPE_NORMAL
- en: 'Quantum Algorithms: The Deutsch Oracle'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Everything we‚Äôve explicated thus far would be frivolous from a computational
    standpoint if we could not construct quantum algorithms that confer computational
    advantages over classical algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: The first algorithm that demonstrably achieved this was devised by David Deutsch
    in 1985, known as Deutsch‚Äôs Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you have four functions f‚ÇÄ-f‚ÇÉ. For every input 0 or 1, f‚ÇÄ outputs 0\.
    For every input of 0 or 1, f‚ÇÅ outputs 0 if the input is 0 and 1 if the input is
    1\. For every input of 0 or 1, f‚ÇÇ outputs 1 if the input is 0 and 0 if the input
    is 1\. For every input of 0 or 1, f‚ÇÉ outputs outputs 1.
  prefs: []
  type: TYPE_NORMAL
- en: We can call functions f‚ÇÄ and f‚ÇÉ constants, since they produce the same output
    regardless of the input. And we call the functions f‚ÇÅ-f‚ÇÇ balanced, since they
    distribute the outputs in a reciprocal way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The question we then ask is: ***if we‚Äôre given one of these functions at random,
    how many times should we query the algorithm to determine whether the function
    is a constant or balanced?***'
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that classical computation cannot determine the right answer in
    less than two queries. Let‚Äôs see how this works. We have the choice of 0 or 1
    as input. If we input 0, we could get 0 or 1 as output. Likewise, if input 1,
    we could get 0 or 1 as output. In both cases, we won‚Äôt know whether the output
    was produced by a constant or balanced function. We therefore have to query the
    algorithm a second time to make the correct determination.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a quantum algorithm, Deutsch demonstrated, we can know the correct answer
    with a single query. In order to achieve this, we make use of the Hadamard gate
    and a control qubit in addition to the input qubit. We send our inputs through
    the Hadamard gate. Remember that H puts a qubit in a state of superposition. So
    if we input the pair |0> and |1>, we get the following respective states: (1/‚àö2,
    1/‚àö2) , (1/‚àö2, ‚àí1/‚àö2). We then pass the target gate through random f‚Çì.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Hadamard is reversible, f‚Çì should put our qubit in one of the following
    states:'
  prefs: []
  type: TYPE_NORMAL
- en: (1/‚àö2) (|0>+|1>); (1/‚àö2) (|0>‚àí|1>); (‚àí1/‚àö2) (|0>‚àí|1>); (‚àí1/‚àö2) (|0>+|1>)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We pass the control qubit through the Hadamard again in order to reverse the
    superposition. Since the operations are reversible, we get the following possible
    outcomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**f‚ÇÄ ‚Üí|0>; f‚ÇÅ ‚Üí|1>; f‚ÇÇ ‚Üí ‚àí|1>; f‚ÇÉ ‚Üí‚àí|0>**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This means that when we measure the qubit at the very end, if the output is
    |0> the function is a constant, and if the output is |1>, the function is balanced.
    Even though the Deutsch Oracle has no practical uses, it provides a powerful example
    of the advantages of quantum over classical computing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Deutsch-Jozsa Algorithm**'
  prefs: []
  type: TYPE_NORMAL
- en: The Deutsch Oracle generalized to multiple variables is called the Deutsch-Jozsa
    algorithm. The diagram below provides the schematic quantum circuitry of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/bce1a5ba7680c4f90571238a17c07c1d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Circuit of Deutsch-Jozsa algorithm, where H stands for Hadamard, U for a constant
    or bit-flip function, with standard bases as input. Only the output on the top
    right is measured. [Image source: Wikipedia.](https://en.wikipedia.org/wiki/Deutsch%E2%80%93Jozsa_algorithm#/media/File:Deutsch-Jozsa-algorithm-quantum-circuit.png)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Shor‚Äôs Algorithm**'
  prefs: []
  type: TYPE_NORMAL
- en: Shor‚Äôs algorithm is a quantum algorithm used for factoring large numbers. The
    algorithm consists of two parts, the first of which is executed in a classical
    computer, and the second executed in a quantum one that makes use of the quantum
    Fourier Transform. We will not delve into the mathematical details of this algorithm
    as they‚Äôre complex and therefore beyond the scope of this article.
  prefs: []
  type: TYPE_NORMAL
- en: Shor‚Äôs algorithm requires two registers with 1024 and 2048 qubits respectively
    in order to factor a 1024 bit number with 309 digits. The largest number that
    has been factored to date has a length of 48 bits, which falls short of the RSA
    100 digit semiprime milestone. So far no quantum computer has met any of the RSA
    number challenges, which consists of a list of identified large numbers that have
    only two prime factors. RSA numbers are used in public-key cryptography for secure
    data transmission by governments and financial institutions.
  prefs: []
  type: TYPE_NORMAL
- en: With a sufficiently powerful quantum computer, Shor‚Äôs algorithm can be used
    to decode public-key cryptography, which uses very large primes deemed computationally
    intractable by classical computers.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum Supremacy & The Future
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we said at the outset, the notion of quantum supremacy refers to the ability
    of quantum computers to solve classically intractable problems in a reasonable
    time-frame. In principle, classical computers can solve any theoretically computable
    algorithm. The problem lies with praxis: limited processing power precludes them
    from solving certain problems in a useful timeframe. This is where quantum computers
    promise to bridge the gap. In 2019, Google announced that they had achieved quantum
    supremacy with their Sycamore, a 53 qubit quantum computer. In their Nature paper
    titled [Quantum Supremacy Using a Programmable Superconducting Processor](https://www.nature.com/articles/s41586-019-1666-5)
    they claim that Sycamore took 200 seconds to sample one instance of a quantum
    circuit a million times, a task which, they further claimed, would take a classical
    supercomputer 10000 years. IBM countered the latter claim by averring that one
    of their supercomputers could perform that task in 2.5 days, undercutting Google‚Äôs
    claim to the finish line.'
  prefs: []
  type: TYPE_NORMAL
- en: The largest quantum computer to date, IBM‚Äôs Osprey, sports a 433 qubit processor.
    Current attempts to build quantum computers with sufficiently large processors
    are beleaguered by creeping noise, namely the potential of the quantum state to
    decohere or collapse into a classical state through interaction with its surrounding
    environment such as changes in temperature and magnetic fields.
  prefs: []
  type: TYPE_NORMAL
- en: The noise-problem constitutes one of the key challenges of scaling quantum computers
    to the computational potential such as factoring inordinately large primes. [Noise-cancelling
    qubits](https://news.uchicago.edu/story/noise-cancelling-qubits-can-minimize-errors-quantum-computers#:~:text=As%20existing%20quantum%20computers%20are,to%20high%20rates%20of%20error.)
    could offset some of these challenges, but currently the advent of quantum computing
    is still in its infancy.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bernhardt, Chris. *Quantum Computing for Everyone*. The MIT Press, 2020.
  prefs: []
  type: TYPE_NORMAL
- en: '*IBM unveils 400 qubit-plus quantum processor and next-generation IBM Quantum
    System Two*. IBM Newsroom. (n.d.). [https://newsroom.ibm.com/2022-11-09-IBM-Unveils-400-Qubit-Plus-Quantum-Processor-and-Next-Generation-IBM-Quantum-System-Two](https://newsroom.ibm.com/2022-11-09-IBM-Unveils-400-Qubit-Plus-Quantum-Processor-and-Next-Generation-IBM-Quantum-System-Two)'
  prefs: []
  type: TYPE_NORMAL
- en: Kaye, P., Laflamme, R., & Mosca, M. (2020). *An introduction to quantum computing*.
    Oxford University Press.
  prefs: []
  type: TYPE_NORMAL
- en: '*‚ÄúNoise-cancelling‚Äù qubits can minimize errors in quantum computers*. University
    of Chicago News. (n.d.). [https://news.uchicago.edu/story/noise-cancelling-qubits-can-minimize-errors-quantum-computers#:~:text=As%20existing%20quantum%20computers%20are,to%20high%20rates%20of%20error.](https://news.uchicago.edu/story/noise-cancelling-qubits-can-minimize-errors-quantum-computers#:~:text=As%20existing%20quantum%20computers%20are,to%20high%20rates%20of%20error.)'
  prefs: []
  type: TYPE_NORMAL
- en: Roush, W. (2020, July 13). *The google-IBM ‚ÄúQuantum Supremacy‚Äù feud*. MIT Technology
    Review. [https://www.technologyreview.com/2020/02/26/905777/google-ibm-quantum-supremacy-computing-feud/](https://www.technologyreview.com/2020/02/26/905777/google-ibm-quantum-supremacy-computing-feud/)
  prefs: []
  type: TYPE_NORMAL
- en: 'Zubairy, Muhammad Suhail. *Quantum Mechanics for Beginners: With Applications
    to Quantum Communication and Quantum Computing*. Oxford University Press, 2020.'
  prefs: []
  type: TYPE_NORMAL
