- en: How to Encode Periodic Time Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/how-to-encode-periodic-time-features-7640d9b21332?source=collection_archive---------9-----------------------#2023-08-24](https://towardsdatascience.com/how-to-encode-periodic-time-features-7640d9b21332?source=collection_archive---------9-----------------------#2023-08-24)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Thoughtful processing of dates, days of the week and times of day for deep learning
    and other prediction models.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@christoph.oliver.moehl?source=post_page-----7640d9b21332--------------------------------)[![Christoph
    Möhl](../Images/fa254d72929c710f11bda8f760f43453.png)](https://medium.com/@christoph.oliver.moehl?source=post_page-----7640d9b21332--------------------------------)[](https://towardsdatascience.com/?source=post_page-----7640d9b21332--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----7640d9b21332--------------------------------)
    [Christoph Möhl](https://medium.com/@christoph.oliver.moehl?source=post_page-----7640d9b21332--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F5bd469d8e345&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-to-encode-periodic-time-features-7640d9b21332&user=Christoph+M%C3%B6hl&userId=5bd469d8e345&source=post_page-5bd469d8e345----7640d9b21332---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----7640d9b21332--------------------------------)
    ·5 min read·Aug 24, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F7640d9b21332&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-to-encode-periodic-time-features-7640d9b21332&user=Christoph+M%C3%B6hl&userId=5bd469d8e345&source=-----7640d9b21332---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F7640d9b21332&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-to-encode-periodic-time-features-7640d9b21332&source=-----7640d9b21332---------------------bookmark_footer-----------)![](../Images/96d47e7431f8e45e5865c4fbad063b2f.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure by Author
  prefs: []
  type: TYPE_NORMAL
- en: Many prediction tasks require time information as model input. Think of a regression
    model to forecast lemonade sales of a retail company (you might remember the example
    from my [article about context enriched features](/context-enriched-data-the-secret-superpower-for-your-deep-learning-model-549826a5fb3d)).
    The demand for refreshing drinks is obviously higher in summer resulting in a
    periodic sales curve with peaks in July/August (thinking of a location in Europe
    here).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/66e003f048a08b48dbf0781e166c64b1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this case, the time within the year is obviously a valuable seasonal information
    that we should feed into the model. But how should we do that? Dates are difficult,
    the number of days change depending on the month (and for February even depending
    to the year) and they exist in various formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '*13th Jan 2023*'
  prefs: []
  type: TYPE_NORMAL
- en: '*13.01.2023*'
  prefs: []
  type: TYPE_NORMAL
- en: '*2023/03/13*'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we can omit the year. To account for a seasonal effect, we just
    need day and month. In a very simple (and not very thoughtful) approach, we could
    just input the month as one number and the day as another number.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/492cc551748d167940e2a221629fdb42.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Why is that a bad idea? The model would have to learn how the Christian Gregorian
    Calendar works (around 30 days per month, 12 months per year, leap years etc.).
    With sufficient training data, a deep-learning model will sure be able to “understand”
    our calendar. “Understanding” means in this case: The model can infer the relative
    time position within the year from month and date inputs. But we should make learning
    as easy as possible for our model and take this job on our shoulders (at least
    we already know how the calendar works). We make use of Python’s *datetime* library
    and calculate the relative time within the year with quite simple logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The resulting *postion_within_year* feature with a value range from close to
    *0.0* (*January 1*) to *1.0* (*December 31*) is much easier to interpret by the
    model than the (damn complicated) Gregorian Calendar.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/247ad8a5d1e33e94026eda6fc88cc4e6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'But it’s still not ideal. The *position_within_year* feature describes a “saw-tooth”
    pattern with a hard jump from *1.0* to *0.0* at each turn of the year. This sharp
    discontinuity can be a problem for effective learning. *December 31* and *January
    1* are very similar dates: They are direct neighbors and have much in common (e.g.
    similar weather conditions), and they probably have a similar potential for lemonade
    sales. However, the feature *position_within_year* does not reflect this similarity
    for *December 31* and *January 1*; in fact, it is as different as it can be.'
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, time points in close proximity to each other should have similar time
    values. We somehow have to design a feature that represents the cyclical nature
    of the year. In other words, by *December 31* we should arrive at the position
    where we started on *January 1*. So, of course, it makes sense to model the position
    within the year as the position on a circle. We can do this by transforming *position_within_year*
    into the *x* and *y* coordinate of a unit circle.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this we use the *sine* and *cosine* functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '*sin(α) = x*'
  prefs: []
  type: TYPE_NORMAL
- en: '*cos(α) = y*'
  prefs: []
  type: TYPE_NORMAL
- en: where *α* is the the angle applied to the circle. If the unit circle represents
    the year, *α* represents the time within the year that has already passed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3c0c2139409a08c6124251e2f59c1f57.png)'
  prefs: []
  type: TYPE_IMG
- en: '*α* is thus equivalent to the *position_within_year* feature, the only difference
    being that *α* has a different scale (*α*: *0.0*–*2π*¹, *position_within_year*:
    *0.0*-*1.0*).'
  prefs: []
  type: TYPE_NORMAL
- en: By simply scaling *position_within_year* to *α* and calculating *sine* and *cosine,*
    we transform the “saw-tooth” pattern to a circular representation with soft transitions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/729a3d16d948f65464642b8d37631afc.png)'
  prefs: []
  type: TYPE_IMG
- en: The resulting *time_feature* is a two-element vector scaled between *0* and
    *1* that is easy to digest by your prediction model. With a few lines of code,
    we took lots of unnecessary learning effort from our model’s shoulders.
  prefs: []
  type: TYPE_NORMAL
- en: 'The unit circle model can be applied to any periodic time information such
    as **day of the month**, **day of the week**, **time of the day**, minute of the
    hour etc. The concept can also be expanded to cyclic features outside the time
    domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Logistics/Public Transport**: Relative position of a bus on its round-trip
    through the city'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/710e1b4c6526430b88db706bb035c5bd.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Biology**: Status of a cell within the [cell cycle](https://en.wikipedia.org/wiki/Cell_cycle).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you have other use cases in mind? You’re welcome to write a comment!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further Information / Connection Points
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A great [hands-on article](/cyclical-features-encoding-its-about-time-ce23581845ca)
    about the same topic from Pierre-Luis Bescond.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to learn more about feature engineering for deep-learning models? Check
    my [article about context enriched data](https://medium.com/towards-data-science/context-enriched-data-the-secret-superpower-for-your-deep-learning-model-549826a5fb3d).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have questions? You need a [**freelance expert for AI, Data Science, Data
    Engineering or Python Development**](https://www.moehl-data-services.de/en)? Visit
    [my website](https://moehl-data-services.de/en) and write me a message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[1] The angle is given in radians here. *0* in radians correspond to *0°*,
    *2π* in radians correspond to 360°.'
  prefs: []
  type: TYPE_NORMAL
- en: All figures were created by the author.
  prefs: []
  type: TYPE_NORMAL
