- en: 'The Ultimate Ndarray Handbook: Mastering the Art of Scientific Computing with
    Rust'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 《终极 Ndarray 手册：掌握 Rust 的科学计算艺术》
- en: 原文：[https://towardsdatascience.com/the-ultimate-ndarray-handbook-mastering-the-art-of-scientific-computing-with-rust-ef5ab767212a?source=collection_archive---------1-----------------------#2023-05-02](https://towardsdatascience.com/the-ultimate-ndarray-handbook-mastering-the-art-of-scientific-computing-with-rust-ef5ab767212a?source=collection_archive---------1-----------------------#2023-05-02)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/the-ultimate-ndarray-handbook-mastering-the-art-of-scientific-computing-with-rust-ef5ab767212a?source=collection_archive---------1-----------------------#2023-05-02](https://towardsdatascience.com/the-ultimate-ndarray-handbook-mastering-the-art-of-scientific-computing-with-rust-ef5ab767212a?source=collection_archive---------1-----------------------#2023-05-02)
- en: An overview of different Rust’s built-in data structures and a deep dive into
    the Ndarray library
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对 Rust 的不同内置数据结构进行概述，并深入探讨 Ndarray 库
- en: '[](https://wiseai.medium.com/?source=post_page-----ef5ab767212a--------------------------------)[![Mahmoud
    Harmouch](../Images/d61617549d25565399975debaad5908f.png)](https://wiseai.medium.com/?source=post_page-----ef5ab767212a--------------------------------)[](https://towardsdatascience.com/?source=post_page-----ef5ab767212a--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----ef5ab767212a--------------------------------)
    [Mahmoud Harmouch](https://wiseai.medium.com/?source=post_page-----ef5ab767212a--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://wiseai.medium.com/?source=post_page-----ef5ab767212a--------------------------------)[![Mahmoud
    Harmouch](../Images/d61617549d25565399975debaad5908f.png)](https://wiseai.medium.com/?source=post_page-----ef5ab767212a--------------------------------)[](https://towardsdatascience.com/?source=post_page-----ef5ab767212a--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----ef5ab767212a--------------------------------)
    [Mahmoud Harmouch](https://wiseai.medium.com/?source=post_page-----ef5ab767212a--------------------------------)'
- en: ·
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fb15db3da5667&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fthe-ultimate-ndarray-handbook-mastering-the-art-of-scientific-computing-with-rust-ef5ab767212a&user=Mahmoud+Harmouch&userId=b15db3da5667&source=post_page-b15db3da5667----ef5ab767212a---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----ef5ab767212a--------------------------------)
    ·31 min read·May 2, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fef5ab767212a&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fthe-ultimate-ndarray-handbook-mastering-the-art-of-scientific-computing-with-rust-ef5ab767212a&user=Mahmoud+Harmouch&userId=b15db3da5667&source=-----ef5ab767212a---------------------clap_footer-----------)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[关注](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fb15db3da5667&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fthe-ultimate-ndarray-handbook-mastering-the-art-of-scientific-computing-with-rust-ef5ab767212a&user=Mahmoud+Harmouch&userId=b15db3da5667&source=post_page-b15db3da5667----ef5ab767212a---------------------post_header-----------)
    发表在 [Towards Data Science](https://towardsdatascience.com/?source=post_page-----ef5ab767212a--------------------------------)
    ·31分钟阅读·2023年5月2日[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fef5ab767212a&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fthe-ultimate-ndarray-handbook-mastering-the-art-of-scientific-computing-with-rust-ef5ab767212a&user=Mahmoud+Harmouch&userId=b15db3da5667&source=-----ef5ab767212a---------------------clap_footer-----------)'
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fef5ab767212a&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fthe-ultimate-ndarray-handbook-mastering-the-art-of-scientific-computing-with-rust-ef5ab767212a&source=-----ef5ab767212a---------------------bookmark_footer-----------)![](../Images/6fd226fc675887e1ef5fcb21042dc628.png)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fef5ab767212a&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fthe-ultimate-ndarray-handbook-mastering-the-art-of-scientific-computing-with-rust-ef5ab767212a&source=-----ef5ab767212a---------------------bookmark_footer-----------)![](../Images/6fd226fc675887e1ef5fcb21042dc628.png)'
- en: Photo by [Crissy Jarvis](https://unsplash.com/@crissyjarvis?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 照片由 [Crissy Jarvis](https://unsplash.com/@crissyjarvis?utm_source=medium&utm_medium=referral)
    提供，发布在 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: TL;DR
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TL;DR
- en: Rust has gained immense popularity as a programming language globally, and it’s
    not without reason. Additionally, when discussing data analysis specifically,
    Rust stands out from its peers with its exceptional capabilities in this field.
    The extensive library support coupled with robust tools makes Rust the preferred
    option for many professionals working on complex datasets today. Moreover, knowing
    how to store your data is essential if you are looking to use Rust for data analysis
    or other related tasks.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 在全球编程语言中获得了巨大的受欢迎程度，这并非没有理由。此外，当讨论数据分析时，Rust 凭借其卓越的能力在同类中脱颖而出。丰富的库支持加上强大的工具使
    Rust 成为许多专业人士处理复杂数据集的首选。此外，如果你希望使用 Rust 进行数据分析或其他相关任务，了解如何存储数据至关重要。
- en: By the end of this article, you’ll have a rock-solid foundation that will enable
    you to kick off your Rust data analysis journey with confidence and ease.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到文章结尾时，你将拥有一个坚实的基础，使你能够自信且轻松地开启 Rust 数据分析之旅。
- en: '**Note**: This article assumes you are a bit familiar with Rust references
    and its borrow checker.'
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意**：本文假设你对 Rust 的引用和借用检查器有一定了解。'
- en: ''
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The notebook named [2-ndarray-tutorial.ipynb](https://github.com/wiseaidev/rust-data-analysis/blob/main/2-ndarray-tutorial.ipynb)
    was developed for this article which can be found in the following repo:'
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了这篇文章开发了名为 [2-ndarray-tutorial.ipynb](https://github.com/wiseaidev/rust-data-analysis/blob/main/2-ndarray-tutorial.ipynb)
    的笔记本，可以在以下仓库中找到：
- en: '[](https://github.com/wiseaidev/rust-data-analysis?source=post_page-----ef5ab767212a--------------------------------)
    [## GitHub - wiseaidev/rust-data-analysis: The ultimate data analysis course with
    Rust.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://github.com/wiseaidev/rust-data-analysis?source=post_page-----ef5ab767212a--------------------------------)
    [## GitHub - wiseaidev/rust-data-analysis: 终极数据分析课程与 Rust。'
- en: This repository is a collection of Jupyter notebooks, all powered by a Rust
    kernel. With these notebooks, you'll be…
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 这个仓库是一个 Jupyter 笔记本的集合，所有笔记本都由 Rust 内核提供支持。通过这些笔记本，你将会…
- en: github.com](https://github.com/wiseaidev/rust-data-analysis?source=post_page-----ef5ab767212a--------------------------------)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: github.com](https://github.com/wiseaidev/rust-data-analysis?source=post_page-----ef5ab767212a--------------------------------)
- en: Table of Contents(TOC)
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目录（TOC）
- en: ∘ [What Is This Article All About?](#d2ef)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [这篇文章讲了什么？](#d2ef)
- en: ∘ [Rust Built-In Data Structures](#3498)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [Rust 内置数据结构](#3498)
- en: ∘ [1\. Vectors](#5a24)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [1\. 向量](#5a24)
- en: ∘ [2\. Arrays](#c03f)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [2\. 数组](#c03f)
- en: ∘ [3\. Tuples](#d625)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [3\. 元组](#d625)
- en: ∘ [4\. Hash Sets](#2bba)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [4\. 哈希集合](#2bba)
- en: ∘ [5\. HashMaps](#31e1)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [5\. 哈希映射](#31e1)
- en: ∘ [Ndarray for Data Analysis](#672d)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [Ndarray 用于数据分析](#672d)
- en: ∘ [Ndarray Intro](#373b)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [Ndarray 简介](#373b)
- en: ∘ [Ndarray Use Cases](#3b5f)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [Ndarray 用例](#3b5f)
- en: ∘ [Initial Placeholders](#7d56)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [初始占位符](#7d56)
- en: ∘ [Multidimensional Arrays](#b787)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [多维数组](#b787)
- en: ∘ [Ndarray Arrays Manipulation](#b4f3)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [Ndarray 数组操作](#b4f3)
- en: ∘ [Indexing & Slicing](#8047)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [索引与切片](#8047)
- en: ∘ [Reshaping](#1131)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [重塑](#1131)
- en: ∘ [Transposing](#edbc)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [转置](#edbc)
- en: ∘ [Swapping Axes](#7c44)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [交换轴](#7c44)
- en: ∘ [Linear Algebra](#bc63)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [线性代数](#bc63)
- en: ∘ [Conclusion](#aa63)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [结论](#aa63)
- en: ∘ [Closing Note](#aa3d)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [结束语](#aa3d)
- en: ∘ [Resources](#f6a5)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ∘ [资源](#f6a5)
- en: What Is This Article All About?
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这篇文章讲了什么？
- en: '![](../Images/e06c1558e0ba0e05b00c9891493a0b7a.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e06c1558e0ba0e05b00c9891493a0b7a.png)'
- en: Photo by [Ashni](https://unsplash.com/@ashni_ahlawat?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[Ashni](https://unsplash.com/@ashni_ahlawat?utm_source=medium&utm_medium=referral)
    在 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral) 上的照片'
- en: The spotlight of this piece is on an essential Rust library for data analysis,
    namely `**ndarray**`. `**ndarray**` empowers users with the ability to handle
    large multi-dimensional arrays and matrices while also offering an extensive selection
    of mathematical operations that can be performed on them.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 本文的重点是一个用于数据分析的重要 Rust 库，即 `**ndarray**`。`**ndarray**` 使用户能够处理大型多维数组和矩阵，同时提供了广泛的数学操作选择。
- en: But before we dive into `**ndarray**` specifically, let’s take a step back and
    explore different **Rust built-in data structures** and why Rust is such a great
    language for data analysis in general.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们深入探讨 `**ndarray**` 之前，让我们退一步，探索一下不同的 **Rust 内置数据结构**，以及为什么 Rust 是进行数据分析的绝佳语言。
- en: Rust Built-In Data Structures
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust 内置数据结构
- en: In this section, we’ll delve into the fundamental concepts and powerful tools
    that form the backbone of this fantastic Rust programming language. In particular,
    we will cover the basics of Rust data structures, including vectors, tuples, sets,
    and hash maps, gaining a solid understanding of how they work and how they can
    be used to solve real-world problems.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入探讨构成这个出色的 Rust 编程语言基础的基本概念和强大工具。特别是，我们将涵盖 Rust 数据结构的基础知识，包括向量、元组、集合和哈希映射，深入理解它们的工作原理以及如何用它们来解决实际问题。
- en: 1\. Vectors
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1\. 向量
- en: '![](../Images/1d7913fc0d7655a9d216be4d419e6f47.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1d7913fc0d7655a9d216be4d419e6f47.png)'
- en: Vectors memory layout (Image by author)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 向量内存布局（作者提供的图片）
- en: '**Vectors**, known as “**lists**” in some programming languages like Python,
    are everywhere; From simple shopping lists to more complex recipe instructions,
    they can help us keep track of things and find them when needed. In programming,
    vectors are an essential data structure used in countless applications, taking
    many different shapes and forms.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**向量**在一些编程语言如 Python 中被称为“**列表**”，它们无处不在；从简单的购物清单到更复杂的食谱说明，它们可以帮助我们跟踪事物并在需要时找到它们。在编程中，向量是一个重要的数据结构，广泛应用于许多不同的场景和形式。'
- en: Creating a Vector
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建向量
- en: 'In Rust, vectors are essential data structures, and you can create them using
    different approaches. To create an empty vector, you can call the `[**Vec::new()**](https://doc.rust-lang.org/std/vec/struct.Vec.html#method.new)`
    function and add a type annotation since Rust doesn’t know what elements you intend
    to store in it:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，向量是基本的数据结构，你可以通过不同的方式创建它们。要创建一个空向量，你可以调用`[**Vec::new()**](https://doc.rust-lang.org/std/vec/struct.Vec.html#method.new)`函数，并添加类型注释，因为
    Rust 不知道你打算存储什么元素：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alternatively, you can use the `[**vec!**](https://doc.rust-lang.org/std/macro.vec.html#)`
    macro to create a new vector with initial values:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你可以使用`[**vec!**](https://doc.rust-lang.org/std/macro.vec.html#)`宏来创建一个带有初始值的新向量：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The rust compiler has the ability to **infer the type** of vector through its
    initial values, thereby eliminating manual specification. After creating a vector,
    you have diverse options for modifying it based on your requirements.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 编译器能够**推断向量的类型**，通过初始值来消除手动指定的需要。创建向量后，你有多种选项来根据需求修改它。
- en: Accessing Vectors Elements
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问向量元素
- en: 'In Rust, we can access values stored in a vector in two ways: either by indexing
    or using the `[**get**](https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.get)`
    method. Let’s explore both methods, along with some code examples!'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，我们可以通过两种方式访问存储在向量中的值：要么通过索引，要么使用`[**get**](https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.get)`方法。让我们探索这两种方法，并附上代码示例！
- en: 'First, let’s consider the following vector `**v**` with some values:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑以下具有一些值的向量`**v**`：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The indexing operator `**[]**` can be utilized to retrieve a specific value
    from a vector. To access the second element, let’s consider the following example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 索引操作符`**[]**`可以用来从向量中检索特定的值。要访问第二个元素，我们来看以下示例：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, we’re creating a reference `**&**` to the second element in the vector
    using indexing with `**[]**`. When attempting to access a non-existent index,
    the Rust compiler will trigger termination/panic and cause program failure. To
    avoid this, we can utilize the get function that produces an `**Option<&T>**`
    instead of a reference. Here’s how it works:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用索引`**[]**`来创建指向向量中第二个元素的引用`**&**`。当尝试访问一个不存在的索引时，Rust 编译器会触发终止/崩溃，并导致程序失败。为了避免这种情况，我们可以利用
    get 函数，该函数返回一个`**Option<&T>**`而不是引用。它是如何工作的：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By invoking `**v.get(2)**`, the method will return an `[**Option<&T>**](https://doc.rust-lang.org/std/option/index.html)`
    type that yields a positive result in the form of `**Some**` if the element is
    present, or a negative outcome as `**None**`. We can utilize a robust approach
    by implementing a **match expression** to handle both scenarios effectively. By
    leveraging these techniques, you can easily access elements in vectors!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`**v.get(2)**`，该方法将返回一个`[**Option<&T>**](https://doc.rust-lang.org/std/option/index.html)`类型，如果元素存在，将返回`**Some**`形式的正面结果，否则返回`**None**`形式的负面结果。我们可以通过实现**match
    表达式**来有效处理这两种情况。利用这些技巧，你可以轻松访问向量中的元素！
- en: Iterating over Values
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历值
- en: 'In Rust, iterating through a vector is a common task that can be executed in
    two ways: utilizing **immutable** and **mutable** references. This approach enables
    us to perform actions on each vector element individually. To gain further understanding,
    let’s explore both of these methods using some code examples!'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，遍历向量是一个常见任务，可以通过两种方式执行：利用 **不可变** 和 **可变** 引用。这种方法使我们能够对每个向量元素逐一操作。为了进一步理解，让我们通过一些代码示例来探索这两种方法！
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the above code snippet, we are using the `**&**` operator to obtain an immutable
    reference for every item in the vector. Then, we display the value of each element
    by utilizing the `[**println**](https://doc.rust-lang.org/std/macro.println.html)**!**`
    macro.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，我们使用 `**&**` 运算符为向量中的每个项获取不可变引用。然后，我们通过利用 `[**println**](https://doc.rust-lang.org/std/macro.println.html)**!**`
    宏来显示每个元素的值。
- en: In addition, the `[**iter()**](https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter)`
    function creates an iterator for vector values. Using this technique, we can obtain
    mutable references to each value in the vector, allowing us to add 10 seamlessly.
    The code below demonstrates how to use the `**iter()**` method to optimize your
    iteration over vectors efficiently.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`[**iter()**](https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter)`
    函数创建一个向量值的迭代器。使用这种技术，我们可以获得向量中每个值的可变引用，从而无缝地添加 10。以下代码演示了如何使用 `**iter()**` 方法有效地优化向量的迭代。
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can effectively traverse a **portion** of the vector’s elements by utilizing
    a **for loop** and **range**. To illustrate this concept, consider the following
    code snippet showcasing how to employ a for loop to obtain **immutable references**
    to get only three elements from a given vector before outputting them to the terminal.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过利用 **for 循环** 和 **范围** 有效地遍历向量元素的 **部分**。为了说明这个概念，考虑以下代码片段，展示了如何使用 for
    循环获取 **不可变引用**，从给定的向量中仅获取三个元素，然后将其输出到终端。
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: By utilizing Rust’s `[**enumerate()**](https://doc.rust-lang.org/core/iter/trait.Iterator.html#method.enumerate)`
    function, we can effortlessly traverse a vector and obtain its values and corresponding
    indices. The code snippet below showcases how to use the `**enumerate()**` method
    to retrieve **immutable references** for each element within an `**i32**` value-based
    vector while simultaneously printing their respective indices and values.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用 Rust 的 `[**enumerate()**](https://doc.rust-lang.org/core/iter/trait.Iterator.html#method.enumerate)`
    函数，我们可以轻松遍历向量并获得其值及对应的索引。下面的代码片段展示了如何使用 `**enumerate()**` 方法获取 **不可变引用**，用于从 `**i32**`
    值类型的向量中检索每个元素，同时打印它们各自的索引和值。
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using these techniques, you can easily **iterate** and **manipulate** elements
    in vectors!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些技巧，你可以轻松地 **迭代** 和 **操作** 向量中的元素！
- en: Modifying a Vector
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改向量
- en: The versatility of Rust’s vector lies in its ability to resize dynamically,
    allowing for the addition or removal of elements during runtime. This section
    will explore different approaches to modifying and updating vectors within Rust.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 的向量的多功能性在于其动态调整大小的能力，允许在运行时添加或删除元素。本节将探讨在 Rust 中修改和更新向量的不同方法。
- en: Adding elements
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加元素
- en: '![](../Images/add9570e28879f1d0e4854190a2708ff.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/add9570e28879f1d0e4854190a2708ff.png)'
- en: Add an element to a vector (Image by author)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 向量中添加元素（图像来源：作者）
- en: 'We can add elements to a vector using the `[**push**](https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.push)`
    method, which appends an element to the end of the vector:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `[**push**](https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.push)`
    方法向向量中添加元素，该方法将一个元素附加到向量的末尾：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The given example involves the creation of a three-element vector, followed
    by appending **“mango”** to its end with a **push** operation. Finally, we display
    the modified vector on the terminal via the `**println!**` macro. Alternatively,
    We can use the insert method to add an element at a specific index:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的示例涉及创建一个包含三个元素的向量，然后通过 **push** 操作将 **“mango”** 附加到向量的末尾。最后，我们通过 `**println!**`
    宏在终端上显示修改后的向量。或者，我们可以使用 insert 方法在特定索引处添加元素：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The above example entails the creation of a four-element vector, followed by
    the insertion of **“mango”** at the end of the vector by utilization of the `[**insert**](https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.insert)`
    method. Finally, we display the modified vector on the terminal through the `**println!**`
    macro.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例涉及创建一个四元素的向量，然后通过使用`[**insert**](https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.insert)`方法在向量末尾插入**“mango”**。最后，我们通过`**println!**`宏在终端上显示修改后的向量。
- en: Modifying Elements
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改元素
- en: To alter the elements of a string vector, we can utilize the index operator
    `**[]**` to reach out for an element at a particular position and substitute it
    with a new value. This approach is highly effective in modifying values within
    a given vector.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改字符串向量的元素，我们可以利用索引操作符`**[]**`来访问特定位置的元素，并用新值替换它。这种方法在修改给定向量中的值时非常有效。
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The given example involves the creation of a vector `**v**` comprising three
    elements, followed by the alteration of its second element (located at index 1)
    to `**“pear”**` and assigning `**“grapefruit”**` as the value for the third one
    (at index 2). Finally, we display this updated version on the terminal through
    the `**println!**` macro.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的示例涉及创建一个包含三个元素的向量`**v**`，然后将其第二个元素（位于索引1）修改为`**“pear”**`，并将第三个元素（在索引2）的值指定为`**“grapefruit”**`。最后，我们通过`**println!**`宏在终端上显示这个更新后的版本。
- en: Removing Elements
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除元素
- en: '![](../Images/78b67871e69275da49c456afea969603.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/78b67871e69275da49c456afea969603.png)'
- en: Removing an element from a vector (Image by author)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 从向量中删除元素（图像由作者提供）
- en: 'We can remove an element from a vector using the `[**pop()**](https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.pop)`
    method, which removes and returns the last element of the vector:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`[**pop()**](https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.pop)`方法从向量中删除一个元素，该方法会删除并返回向量中的最后一个元素：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the example above, we created a four-element vector called `**v**` and then
    removed the last element using the `**pop**` method. This method also provides
    us with the removed component as output. Finally, we used the `**println!**` macro
    to display both our updated vector and extracted element on the terminal screen
    in an orderly manner.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们创建了一个四元素的向量`**v**`，然后使用`**pop**`方法删除了最后一个元素。该方法还向我们提供了被删除的组件作为输出。最后，我们使用`**println!**`宏以有序的方式在终端屏幕上显示更新后的向量和提取的元素。
- en: 'We can also use the `[**remove**](https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.remove)`
    method to remove an element at a specific index:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`[**remove**](https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.remove)`方法来删除特定索引处的元素：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To remove all elements from a vector in Rust, use `[**retain**](https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.retain)`
    method to keep all elements that match a certain condition:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Rust中的向量中删除所有元素，使用`[**retain**](https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.retain)`方法来保留所有符合某个条件的元素：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Concatenating Two Vectors
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接两个向量
- en: 'To concatenate two vectors of strings, we can use the `**extend**` method,
    which takes an **iterator** as an argument and appends all its elements to the
    vector:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接两个字符串向量，我们可以使用`**extend**`方法，该方法将一个**迭代器**作为参数，并将其所有元素附加到向量中：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the example above, we first create two vectors `**v1**` and `**v2**` , then
    we concatenate them by calling the extend method on `**v1**` and passing `**v2**`
    as a parameter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们首先创建了两个向量`**v1**`和`**v2**`，然后通过在`**v1**`上调用extend方法并传递`**v2**`作为参数来连接它们。
- en: Filter & Map Elements
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤与映射元素
- en: We can filter and map elements of a vector in Rust using the `[**iter**](https://doc.rust-lang.org/core/iter/index.html)`,
    `[**filter**](https://doc.rust-lang.org/core/iter/struct.Filter.html)`, and `[**map**](https://doc.rust-lang.org/core/iter/struct.Map.html)`
    methods.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`[**iter**](https://doc.rust-lang.org/core/iter/index.html)`、`[**filter**](https://doc.rust-lang.org/core/iter/struct.Filter.html)`和`[**map**](https://doc.rust-lang.org/core/iter/struct.Map.html)`方法来过滤和映射Rust中的向量元素。
- en: '**Filter Elements**'
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**过滤元素**'
- en: 'We can effectively filter out vector elements by combining the `**iter**` and
    `**filter**` methods. To illustrate this point, let’s consider how to filter out
    all even numbers from a set of integers using the following example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过结合使用`**iter**`和`**filter**`方法有效地过滤向量元素。为了说明这一点，让我们考虑如何使用以下示例从整数集合中过滤出所有偶数：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the example above, we first create a vector `**v**` with ten elements, then
    we use `**iter**` and `**filter**` methods to create a new vector `**odd_numbers**`
    that contains only the **odd numbers** from v. Finally, we print the new vector
    to the terminal using the `**println!**` macro.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Map Elements
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To **map** elements of a vector, we can use the `**iter**` and `**map**` methods
    together. For example, to convert a vector of strings to uppercase:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the example above, we first create a vector `**v**` with **three** elements,
    then we use `**iter**` and `**map**` methods to create a new vector `**uppercase_strings**`
    that contains the uppercase versions of the elements in v. Finally, we print the
    new vector to the console using the `**println!**` macro.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Length
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To compute the length, we can use the `[**len**](https://doc.rust-lang.org/core/iter/trait.ExactSizeIterator.html#method.len)`
    method:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Check If Element Exists
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use `[**contains**](https://doc.rust-lang.org/core/primitive.str.html#method.contains)`
    to check if a vector contains a specific element:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note the method requires a **borrowed copy**, hence the `**&**` in the argument.
    The compiler will tell you to add this symbol if you forget.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Reversing Elements
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can reverse a vector in Rust using the `[**reverse**](https://doc.rust-lang.org/core/primitive.slice.html#method.reverse)`
    method. This method modifies the vector in place, so it doesn’t return anything.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the example above, a vector `**v**` consisting of five elements is created,
    and then the `**reverse**` method is employed to alter the sequence of these components
    in place. Finally, we display the reversed vector on the terminal for observation.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Maximum & Minimum Elements
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By utilizing Rust’s `**iter**` function alongside the `**max**` and `**min**`
    methods, one can effortlessly locate both the highest and lowest values within
    a vector. This approach is highly effective in simplifying such operations with
    ease.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the example above, we initialized a vector v of five elements. Subsequently,
    the `**iter**` method is employed to create an iterator which helps us determine
    the maximum and minimum values by utilizing `**max**` and `**min**` methods. Finally,
    using `**println!**`, we display both these results on the console screen.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have a solid foundation for using and manipulating vectors, let’s
    look at another built-in collection: arrays.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Arrays
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/c5f5bed40ef9169713b78f1dfdc56123.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: Rust array memory layout (Image by author)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Using an **array** is a viable option for storing different values of the same
    data type. **Unlike vectors**, each element in the array must have **consistent
    data types**. Compared to arrays in other programming languages, they are **fixed-size
    collections** with identical data type elements. These collections come with benefits
    when you need to allocate memory on the **stack** or know that their sizes will
    remain constant throughout the runtime.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Creating an array
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create an array, you can use square brackets `**[]**` with comma-separated
    values:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建数组，您可以使用方括号 `**[]**` 并用逗号分隔的值：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can also explicitly specify the number of elements in the array and their
    types, like so:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以明确指定数组中元素的数量和类型，如下所示：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Using this syntax, an array consisting of `**i32**` values with a length equivalent
    to 5 can be formed. In order to set all elements within this array to one typical
    value, you may employ the following method:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此语法，可以形成一个由 `**i32**` 值组成且长度为 5 的数组。为了将此数组中的所有元素设置为一个典型值，可以使用以下方法：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This creates an array of length 5, with all the elements initialized to 0.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这会创建一个长度为 5 的数组，所有元素都初始化为 0。
- en: Accessing Elements
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问元素
- en: 'You can access individual elements of an array using square brackets with the
    index of the element:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用带有元素索引的方括号访问数组的单个元素：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Modifying Elements
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改元素
- en: 'Since arrays have a fixed size, you cannot push or remove elements like vectors.
    However, you can modify individual elements by making the array mutable using
    the `**mut**` keyword so that you can change its elements:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数组具有固定的大小，您无法像向量那样推送或移除元素。但是，可以通过使用 `**mut**` 关键字使数组可变，从而修改其元素：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Iterating
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代
- en: To retrieve every individual element from an array, we must traverse through
    all of them instead of relying on indices to access one at a time. Demonstrated
    below is the implementation of a for loop that effectively retrieves and prints
    out each value within an `**i32**` type array.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要从数组中检索每个单独的元素，我们必须遍历它们，而不是依赖索引逐个访问。下面演示了有效检索并打印 `**i32**` 类型数组中每个值的 for 循环实现。
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Slicing Arrays
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片数组
- en: 'You can also create a new array that contains a subset of the original array
    using slicing:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用切片创建包含原始数组子集的新数组：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This creates a new array containing the original array’s elements at indices
    1, 2, and 3.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个包含原始数组元素的新数组，其索引为 1、2 和 3。
- en: To sum up, Rust arrays are versatile data structures that serve numerous purposes.
    Their fixed-size nature renders them more effective than vectors in specific scenarios.
    When you have the array size predetermined and no need for runtime modifications,
    employing arrays is an ideal choice for storing data.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，Rust 数组是多功能的数据结构，可以服务多种用途。其固定大小的特性使其在特定场景下比向量更为有效。当数组大小预先确定且不需要运行时修改时，使用数组是存储数据的理想选择。
- en: 3\. Tuples
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3\. 元组
- en: A tuple is a compound type in Rust that allows you to group several values with
    varying types into one object. Regarding size, tuples are fixed and cannot be
    resized once declared, much like arrays.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是 Rust 中的一种复合类型，允许将多个具有不同类型的值组合成一个对象。就大小而言，元组是固定的，一旦声明就不能调整大小，与数组类似。
- en: Creating a Tuple
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建元组
- en: In Rust, creating a tuple is an effortless task. Just enclose your values in
    parentheses and separate them with commas. Each position within the tuple has
    its type, which may differ from one another without any constraints on the uniformity
    of the types among all elements present in it.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，创建元组是一项简单的任务。只需将值括在括号中，并用逗号分隔它们。元组中的每个位置都有其类型，这些类型可能彼此不同，不会对其类型的一致性施加任何约束。
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When creating a tuple, it is possible to incorporate optional type annotations.
    This can be observed in the example below:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建元组时，可以加入可选的类型注解。下面的示例中展示了这一点：
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Updating a Tuple
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新元组
- en: 'Utilizing the `**mut**` keyword, you can transform a tuple into a mutable form
    and modify its contents. This grants access to alter specific elements within
    the tuple by referencing them through **dot notation** followed by their respective
    **index** values:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `**mut**` 关键字，您可以将元组转换为可变形式并修改其内容。这允许通过引用后跟其各自 **索引** 值的 **点符号** 修改元组中的特定元素：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can modify its elements by utilizing the dot notation followed by the corresponding
    element index.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用点符号和相应的元素索引来修改其元素。
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Destructuring a Tuple
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组的解构
- en: The process of extracting different components from a tuple and assigning them
    to separate variables is known as **destructuring** which is demonstrated in the
    following example.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 从元组中提取不同组件并将它们分配给单独变量的过程称为**解构**，这在以下示例中进行了演示。
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can also ignore some of the elements of the tuple while **destructuring**:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在解构时忽略元组中的某些元素：
- en: '[PRE34]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In addition, we can access a specific element in a tuple using indexing:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用索引访问元组中的特定元素：
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In summary, tuples are a powerful way to group together **values with different
    types** into one object in Rust. They are **immutable** and **fixed in size**
    but can be made mutable to modify their contents. You can also **destructure**
    tuples to access their elements. With these features, tuples are a versatile tool
    for working with data in Rust!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，元组是在 Rust 中将**不同类型的值**组合成一个对象的强大方式。它们是**不可变**的并且**大小固定**，但可以被设为可变以修改其内容。你还可以**解构**元组以访问其元素。凭借这些特性，元组是处理
    Rust 数据的多功能工具！
- en: 4\. Hash Sets
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4\. 哈希集合
- en: If you are familiar with Python, sets may already be a known concept. These
    collections consist of distinct elements and do not prioritize orders. In Rust
    programming language, **hash sets** and **B-tree sets** represent these unique
    groups; however, the former is more frequently employed in practice.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对 Python 比较熟悉，集合可能已经是一个熟悉的概念。这些集合由不同的元素组成，不重视顺序。在 Rust 编程语言中，**哈希集合**和**B
    树集合**代表这些唯一的组；然而，前者在实践中更为常用。
- en: Creating a Set
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建集合
- en: 'Creating a hash set in Rust is as simple as importing it from the standard
    library and calling the `**new**` method or associated function:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中创建一个哈希集合非常简单，只需从标准库中导入并调用`**new**`方法或相关函数：
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can also create a set from a vector of elements:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以从元素的向量中创建一个集合：
- en: '[PRE37]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can even initialize it from an array:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以从数组初始化它：
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Updating a Set
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新集合
- en: Adding elements
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加元素
- en: 'Adding elements to a hash set is easy with the `[**insert**](https://doc.rust-lang.org/std/collections/hash_set/struct.HashSet.html#method.insert)`
    method:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 向哈希集合中添加元素很简单，只需使用 `[**insert**](https://doc.rust-lang.org/std/collections/hash_set/struct.HashSet.html#method.insert)`
    方法：
- en: '[PRE39]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Removing elements
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除元素
- en: 'Removing elements from a hash set is done using the `[**remove**](https://doc.rust-lang.org/std/collections/hash_set/struct.HashSet.html#method.remove)`
    method:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 从哈希集合中移除元素可以使用 `[**remove**](https://doc.rust-lang.org/std/collections/hash_set/struct.HashSet.html#method.remove)`
    方法：
- en: '[PRE40]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Iterate over Sets
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历集合
- en: 'You can easily iterate over a hash set using a for loop:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 for 循环轻松地遍历哈希集合：
- en: '[PRE41]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Sets Operations
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合操作
- en: '![](../Images/9398199d6d0f7c1e9d1c90dc219e4a59.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9398199d6d0f7c1e9d1c90dc219e4a59.png)'
- en: Different set operations (Image by author)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的集合操作（图像由作者提供）
- en: 'Rust’s hash sets offer an array of set operations, including `[**difference**](https://doc.rust-lang.org/std/collections/hash_set/struct.Difference.html)`,
    `[**intersection**](https://doc.rust-lang.org/std/collections/hash_set/struct.Intersection.html)`,
    and `[**union**](https://doc.rust-lang.org/std/collections/hash_set/struct.Union.html)`
    functions. These functionalities enable us to execute set arithmetic on hash sets
    which makes them a valuable resource for storing unique data. To illustrate this
    point, let’s consider the following example:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 的哈希集合提供了一系列集合操作，包括 `[**difference**](https://doc.rust-lang.org/std/collections/hash_set/struct.Difference.html)`、`[**intersection**](https://doc.rust-lang.org/std/collections/hash_set/struct.Intersection.html)`
    和 `[**union**](https://doc.rust-lang.org/std/collections/hash_set/struct.Union.html)`
    函数。这些功能使我们能够在哈希集合上执行集合运算，使其成为存储唯一数据的宝贵资源。为说明这一点，我们来看以下示例：
- en: '[PRE42]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In essence, hash sets are an indispensable asset that every Rust developer has
    to familiarize themselves with. They possess remarkable efficiency and offer plenty
    of operations for **set arithmetic**. Having been equipped with the illustrations
    provided, you should now be able to incorporate hash sets into your personal Rust
    projects.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，哈希集合是每个 Rust 开发者都必须熟悉的不可或缺的资产。它们具有显著的效率，并提供了大量的**集合运算**操作。通过提供的示例，你现在应该能够将哈希集合整合到你的个人
    Rust 项目中。
- en: For more info, you can refer to [the official doc](https://doc.rust-lang.org/std/collections/struct.HashSet.html).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请参阅 [官方文档](https://doc.rust-lang.org/std/collections/struct.HashSet.html)。
- en: 5\. Hash Maps
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5\. 哈希映射
- en: '![](../Images/0f1181e99cd25818afcc8b70220e3d3b.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0f1181e99cd25818afcc8b70220e3d3b.png)'
- en: Hash Map (image by author)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希映射（图像由作者提供）
- en: Hash Maps are a type of collection that consists of **key-value pairs** and
    offer quick and effective access to data by utilizing keys instead of indexing.
    Rust declares Hash Maps through the `[**std::collections::HashMap**](https://doc.rust-lang.org/std/collections/struct.HashMap.html)`
    module, an unordered structure with remarkable speed. Let’s look at how to create,
    update, access, and iterate over Hash Maps in Rust.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希映射是一种包含**键值对**的集合类型，通过利用键而非索引来快速有效地访问数据。Rust 通过 `[**std::collections::HashMap**](https://doc.rust-lang.org/std/collections/struct.HashMap.html)`
    模块声明哈希映射，它是一种无序结构，速度非常快。让我们看看如何在 Rust 中创建、更新、访问和遍历哈希映射。
- en: Creating a Hash Map
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建哈希映射
- en: You can initialize a Hash Map in Rust in a number of ways, one of which is by
    using the `[**new**](https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.new)`
    method of the Hash Map struct.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过多种方式在Rust中初始化哈希映射，其中一种方法是使用哈希映射结构体的`[**new**](https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.new)`方法。
- en: '[PRE43]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the given instance, we introduce a new Hash Map named `**employees_map**`.
    Subsequently, utilizing the `[**insert**](https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.insert)`
    function, we add elements to this Hash Map. Lastly, by applying the `**println!**`
    macro and formatting it with `**{:?}**`, we exhibit debug mode representation
    of our created HashMap. Another way to initialize a HashMap is by using the `[**HashMap::from**](https://doc.rust-lang.org/std/collections/struct.HashMap.html#impl-From%3C%5B(K,+V);+N%5D%3E-for-HashMap%3CK,+V,+RandomState%3E)`
    method.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定的示例中，我们引入了一个新的哈希映射（Hash Map），命名为`**employees_map**`。随后，利用`[**insert**](https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.insert)`函数，我们向这个哈希映射中添加元素。最后，通过应用`**println!**`宏并使用`**{:?}**`格式化，我们展示了我们创建的HashMap的调试模式表示。另一种初始化哈希映射的方法是使用`[**HashMap::from**](https://doc.rust-lang.org/std/collections/struct.HashMap.html#impl-From%3C%5B(K,+V);+N%5D%3E-for-HashMap%3CK,+V,+RandomState%3E)`方法。
- en: '[PRE44]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Updating a Hash Map
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新哈希映射
- en: Adding Elements
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加元素
- en: 'As we have seen in the previous example, we can use the `[**insert**](https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.insert)`
    method to add elements (**key-value pairs**) to a Hash Map. For example:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的示例中所见，我们可以使用`[**insert**](https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.insert)`方法向哈希映射中添加元素（**键值对**）。例如：
- en: '[PRE45]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Removing Elements
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除元素
- en: 'We can use the `[**remove**](https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.remove)`
    method to remove an element (**key-value pair**) from a Hash Map. For example:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`[**remove**](https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.remove)`方法从哈希映射中移除一个元素（**键值对**）。例如：
- en: '[PRE46]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Updating an Element
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新元素
- en: 'We can update elements of a Hash Map by using the `[**insert**](https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.insert)`
    method. For example:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`[**insert**](https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.insert)`方法来更新哈希映射的元素。例如：
- en: '[PRE47]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Access Values
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问值
- en: 'Like Python, we can use the `**get**` to access a value from a given Hash Map
    in Rust. For example:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于Python，我们可以使用`**get**`来从给定的哈希映射中访问一个值。例如：
- en: '[PRE48]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Iterate over Hash Maps
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历哈希映射
- en: '[PRE49]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In essence, Rust’s Hash Map is a robust data structure that facilitates the
    effective management and arrangement of data through **key-value pairs**. They
    offer **fast access** to data and are frequently used for tasks like **counting
    occurrences**, **memoization**, and **caching**. Thanks to Rust’s integrated Hash
    Map implementation coupled with its extensive array of techniques, utilizing Hash
    Maps is an effortless process devoid of complications.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，Rust的哈希映射是一种强大的数据结构，它通过**键值对**有效地管理和排列数据。它们提供**快速访问**数据的能力，并且经常用于如**计数出现次数**、**记忆化**和**缓存**等任务。得益于Rust的集成哈希映射实现以及其广泛的技术组合，使用哈希映射是一个简单而不复杂的过程。
- en: For more info, you can refer to [**this page**](https://doc.rust-lang.org/std/collections/struct.HashMap.html)
    of the official docs.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，你可以参考官方文档的[**这一页面**](https://doc.rust-lang.org/std/collections/struct.HashMap.html)。
- en: As we come to the end of this first segment, let us reflect on our journey into
    the vast world of Rust’s built-in data structures. Our exploration has led us
    through some fundamental components such as vectors, arrays, tuples, and hash
    maps — all crucial elements for any proficient programmer in their quest towards
    building robust programs.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们结束这一部分时，让我们回顾一下我们进入Rust内置数据结构广阔世界的旅程。我们的探索涉及了一些基本组件，如向量、数组、元组和哈希映射——这些都是任何熟练程序员在构建强健程序过程中不可或缺的元素。
- en: Through our mastery of creating and accessing data structures and manipulating
    them with ease, we have gained valuable insights into their defining characteristics
    and nuances. Armed with this knowledge, you will be empowered to craft Rust code
    that is efficient and highly effective in achieving your desired outcomes.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们对创建和访问数据结构的掌握，以及轻松操控它们的能力，我们获得了有关其定义特性和细微差别的宝贵见解。凭借这些知识，你将能够编写出高效且能够有效实现预期结果的Rust代码。
- en: Having established a firm grasp on the fundamental concepts of Rust’s built-in
    data structures, we shall now integrate them with the latter half of this article
    that delves into Ndarray. This fantastic library is famous for its prowess in
    numerical computation within Rust. It features an array object similar to a vector
    but augmented with advanced capabilities to execute mathematical operations seamlessly.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在牢固掌握了 Rust 内置数据结构的基本概念后，我们现在将其与本文后半部分探讨的 Ndarray 结合起来。这个出色的库因其在 Rust 中进行数值计算的能力而闻名。它具有类似于向量的数组对象，但具有增强的能力，能够无缝地执行数学运算。
- en: Ndarray for Data Analysis
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ndarray 在数据分析中的应用
- en: '![](../Images/62fc6ce98c7ec14be3334f950bc8fbc7.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/62fc6ce98c7ec14be3334f950bc8fbc7.png)'
- en: Different arrays Dimensions (image by author)
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 不同数组的维度（图片作者提供）
- en: 'In the following sections, we will delve into the world of `[**ndarray**](https://docs.rs/ndarray/latest/ndarray/)`:
    a robust Rust library that easily enables numerical computations and data manipulation.
    With its diverse array of methods for working with arrays and matrices containing
    numeric data, it is an essential asset in any data analysis toolkit. In the following
    sections, we’ll cover all aspects of using `**ndarray**` from scratch, including
    how to work with array and matrix structures and perform mathematical operations
    on them effortlessly. We’ll also explore advanced concepts such as indexing and
    slicing, which flexibly facilitate the efficient handling of large datasets.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将深入探讨 `[**ndarray**](https://docs.rs/ndarray/latest/ndarray/)`：一个强大的
    Rust 库，能够轻松进行数值计算和数据操作。凭借其多种处理数组和矩阵中数值数据的方法，它是任何数据分析工具包中的重要资产。在接下来的章节中，我们将从零开始讲解如何使用
    `**ndarray**`，包括如何处理数组和矩阵结构，以及如何轻松地对其进行数学运算。我们还将探索高级概念，如索引和切片，这些概念灵活地促进了对大数据集的高效处理。
- en: By following through examples and hands-on exercises throughout these sections,
    you can gain mastery over employing `ndarray`arrays effectively towards your unique
    analytical tasks!
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在这些章节中的示例和实践练习，你可以掌握如何有效地利用 `ndarray` 数组来完成你的独特分析任务！
- en: Ndarray Intro
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ndarray 介绍
- en: 'The `[**ArrayBase**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html)`
    struct provides an essential data structure, aptly named the n-dimensional array,
    that effectively stores and manages vast arrays of data. This includes integers
    or floating point values. The benefits of using a `**ndarray**`arraysover Rust’s
    native **arrays** or **tuple** structures are various: it is more efficient and
    user-friendly.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`[**ArrayBase**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html)`
    结构提供了一种重要的数据结构，恰如其名为 n 维数组，有效地存储和管理大量的数据。这包括整数或浮点值。使用 `**ndarray**` 数组相较于 Rust
    原生的 **数组** 或 **元组** 结构有多种好处：它更高效且用户友好。'
- en: Ndarray Use Cases
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ndarray 使用案例
- en: 'Here are some real-life use cases of `**ndarray**` in data analysis:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `**ndarray**` 在数据分析中的一些实际应用案例：
- en: '**Data Cleaning and Preprocessing**: Ndarray offers robust features for data
    cleaning and preprocessing, including the ability to filter out missing values,
    convert various data types, and scale your dataset. Suppose you have a set of
    records with gaps; ndarray’s nan (not a number) value can represent these absent
    entries effectively. Utilizing functions like `[**fill**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.fill)`,
    you can easily manage those incomplete pieces of information without any hassle.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据清洗与预处理**：Ndarray 提供了强大的数据清洗与预处理功能，包括过滤缺失值、转换各种数据类型以及缩放数据集的能力。假设你有一组记录中存在缺口；ndarray
    的 nan（非数值）可以有效地表示这些缺失的条目。利用如 `[**填充**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.fill)`
    这样的函数，你可以轻松地管理这些不完整的信息，毫不费力。'
- en: '**Data Visualization**: Ndarray arrays are a reliable option for data storage
    to facilitate visualization. The versatility of `**ndarray**` arrays allows them
    to be used with the `[**Plotters**](https://plotters-rs.github.io/home/)` library
    for visual representation purposes. For instance, by generating an array containing
    random numbers using Ndarrays, we could plot the distribution in the form of a
    histogram through **Plotters**’ plotting capabilities.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据可视化**：Ndarray 数组是数据存储的可靠选择，有助于可视化。`**ndarray**` 数组的多功能性使得它们可以与 `[**Plotters**](https://plotters-rs.github.io/home/)`
    库配合使用，以实现可视化目的。例如，通过使用 Ndarrays 生成一个包含随机数的数组，我们可以通过 **Plotters** 的绘图能力将其以直方图的形式绘制出来。'
- en: '**Descriptive Statistics**: Ndarray offers an array of robust methods for doing
    descriptive statistics on arrays, including computing the mean, median, mode,
    variance, and standard deviation. These functions are invaluable in analyzing
    data as they provide a quick overview of key metrics. For instance, by utilizing
    ndarray’s `[**mean**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.mean)`
    function, we can easily calculate the average value within our dataset with ease.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述性统计**：Ndarray 提供了一系列强大的方法用于对数组进行描述性统计，包括计算均值、中位数、众数、方差和标准差。这些函数在分析数据时非常宝贵，因为它们提供了关键指标的快速概览。例如，通过利用
    ndarray 的 `[**mean**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.mean)`
    函数，我们可以轻松计算数据集中的平均值。'
- en: '**Machine Learning**: Ndarray is a crucial component in machine learning, offering
    speedy and effective manipulation of large datasets. Numerical data must often
    be expressed as arrays for use with these algorithms, making `**ndarray**` an
    ideal solution due to its ease of use and efficiency. With this tool, we can effortlessly
    generate feature and label arrays that are essential for the success of any given
    machine-learning algorithm.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机器学习**：Ndarray 是机器学习中的一个关键组件，提供了对大数据集的快速而有效的操作。数值数据通常必须以数组形式表示以便与这些算法配合使用，使得`**ndarray**`成为一个理想的解决方案，因为它使用方便且高效。借助这个工具，我们可以轻松生成特征和标签数组，这对任何机器学习算法的成功至关重要。'
- en: '**Linear Algebra**: Ndarray offers many robust methods for carrying out linear
    algebraic operations like matrix inversion, multiplication, and decomposition.
    These functions are convenient when analyzing data represented as matrices or
    vectors. For instance, the `[**dot**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.dot)`
    function in `**ndarray**` enables us to execute matrix multiplication on two arrays
    with ease.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线性代数**：Ndarray 提供了许多强大的方法来执行线性代数操作，如矩阵求逆、乘法和分解。这些功能在分析表示为矩阵或向量的数据时非常方便。例如，`[**dot**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.dot)`函数可以让我们轻松对两个数组进行矩阵乘法。'
- en: Initial Placeholders
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始占位符
- en: '**Ndarray** offers a variety of functions for generating and initializing arrays,
    known as **initial placeholders** or array creation functions. These powerful
    tools enable us to create customized arrays with specific shapes and data types,
    complete with predetermined or randomized values. Here are some frequently utilized
    examples of these handy initial placeholder functions within the `**ndarray**`
    library:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ndarray** 提供了多种生成和初始化数组的函数，被称为**初始占位符**或数组创建函数。这些强大的工具使我们能够创建具有特定形状和数据类型的自定义数组，并填充预定或随机值。以下是`**ndarray**`库中一些常用的初始占位符函数示例：'
- en: '`[**ndarray::Array::<type, _>::zeros(shape.f())**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.zeros)`:
    This function creates an array filled with zeros. The `**shape**` parameter specifies
    the array’s dimensions, and the `**type**` parameter specifies the data type of
    the array elements. The `**f**` function converts the array from row-major into
    column-major.'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`[**ndarray::Array::<type, _>::zeros(shape.f())**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.zeros)`：此函数创建一个填充了0的数组。`**shape**`
    参数指定数组的维度，`**type**` 参数指定数组元素的数据类型。`**f**` 函数将数组从行优先转换为列优先。'
- en: '`[**ndarray::Array<::type, _>::ones(shape.f())**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.ones)`:
    This function creates an array filled with ones. The `**type**` and the `**f**`
    have the same effect as for `**ndarray::Array::zeros**`.'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`[**ndarray::Array<::type, _>::ones(shape.f())**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.ones)`：此函数创建一个填充了1的数组。`**type**`
    和 `**f**` 的效果与 `**ndarray::Array::zeros**` 相同。'
- en: '`[**ndarray::Array::<type, _>::range(start, end, step)**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.range)`:
    This function creates an array with values in a range. The start parameter specifies
    the range’s start, and the end parameter specifies the end of the range (exclusive).
    The step parameter specifies the step size between values. The `**type**` parameter
    specifies the data type of the array elements.'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`[**ndarray::Array::<type, _>::range(start, end, step)**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.range)`：此函数创建一个范围内值的数组。start
    参数指定范围的起点，end 参数指定范围的终点（不包括）。step 参数指定值之间的步长。`**type**` 参数指定数组元素的数据类型。'
- en: '`[**ndarray::Array::<type, _>::linspace(start, end, n)**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.linspace)`:
    This function creates an array with values evenly spaced between the `**start**`
    and `**end**` values. The `**n**` parameter specifies the number of values in
    the array, and the end parameter specifies whether the stop value is included.
    The `**type**` parameter specifies the data type of the array elements.'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`[**ndarray::Array::<type, _>::linspace(start, end, n)**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.linspace)`:
    这个函数创建一个数组，其中的值在`**start**`和`**end**`之间均匀分布。参数`**n**`指定数组中的值的数量，而`end`参数指定是否包含停止值。参数`**type**`指定数组元素的数据类型。'
- en: '`[**ndarray::Array::<type, _>::fill(value)**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.fill)`:
    This function fills an array with a specified value. The `**value**` parameter
    specifies the value to fill the array with.'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`[**ndarray::Array::<type, _>::fill(value)**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.fill)`:
    这个函数用指定的值填充数组。参数`**value**`指定要填充数组的值。'
- en: '`[**ndarray::Array::<type, _>::eye(shape.f())**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.eye)`:
    This function creates a squared identity matrix with ones on the diagonal and
    zeros elsewhere. The `**n**` parameter specifies the number of rows and columns.
    The `**type**` parameter and `**f**` function have the same meaning as for `**ndarray::Array::zeros**`.'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`[**ndarray::Array::<type, _>::eye(shape.f())**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.eye)`:
    这个函数创建一个方阵的单位矩阵，对角线上为1，其他位置为0。参数`**n**`指定行和列的数量。参数`**type**`和`**f**`函数与`**ndarray::Array::zeros**`的意义相同。'
- en: '`[**ndarray::Array<type, _>::random(shape.f(), distribution_function)**](https://crates.io/crates/ndarray-rand)`:
    This function creates an array with random values with a given distribution. The
    `**shape**` parameter specifies the dimensions of the array.'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`[**ndarray::Array<type, _>::random(shape.f(), distribution_function)**](https://crates.io/crates/ndarray-rand)`:
    这个函数使用给定的分布函数创建一个具有随机值的数组。参数`**shape**`指定数组的维度。'
- en: These initial placeholder functions are highly valuable for generating and initializing
    arrays in `**ndarray**`. They offer a hassle-free approach to creating collections
    of diverse shapes and data types, allowing the user to specify specific or random
    values. Here’s a simple Rust program example to showcase the various placeholders
    available within `**ndarray**`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这些初始的占位函数对于在`**ndarray**`中生成和初始化数组非常有价值。它们提供了一种无需繁琐操作的方法来创建不同形状和数据类型的集合，允许用户指定特定或随机的值。以下是一个展示`**ndarray**`中各种占位符的简单
    Rust 程序示例。
- en: '[PRE50]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Multidimensional Arrays
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多维数组
- en: Ndarray can build arrays with multiple dimensions, such as 2D matrices and 3D
    matrices. We can effortlessly generate complex data structures using the `[**from_vec**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.from_vec)`
    function along with a vector of vectors, or using the `[**array!**](https://docs.rs/ndarray/latest/ndarray/macro.array.html)`
    macro. For instance, let’s take an example program that showcases how ndarray
    creates arrays across various dimensions.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Ndarray 可以构建具有多个维度的数组，例如 2D 矩阵和 3D 矩阵。我们可以轻松使用`[**from_vec**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.from_vec)`函数与向量的向量，或者使用`[**array!**](https://docs.rs/ndarray/latest/ndarray/macro.array.html)`宏来生成复杂的数据结构。例如，让我们看一个展示如何使用
    ndarray 在各种维度上创建数组的示例程序。
- en: '[PRE51]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Ndarray Arrays Manipulation
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ndarray 数组操作
- en: In this section, we will delve into the diverse techniques of altering **ndarray**
    arrays, such as **indexing**, **slicing**, and **reshaping**.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入探讨**ndarray**数组的多种技术，例如**索引**、**切片**和**重塑**。
- en: '[Indexing](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#indexing-and-dimension)
    & [Slicing](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#slicing)'
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[索引](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#indexing-and-dimension)
    & [切片](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#slicing)'
- en: '![](../Images/a4a0c6b3556995118bfc2df99560956b.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a4a0c6b3556995118bfc2df99560956b.png)'
- en: Array Slicing (Image by author)
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 数组切片（图片由作者提供）
- en: 'Ndarray offers impressive capabilities through **indexing** and **slicing**
    features, enabling us to access and modify individual elements or subarrays within
    an array. Like Python lists, indexing in an **ndarray** involves using index values
    to retrieve specific elements from the array. As a demonstration of this functionality,
    consider accessing the second element of an array with code like so:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Ndarray 通过 **索引** 和 **切片** 功能提供了令人印象深刻的能力，使我们能够访问和修改数组中的单个元素或子数组。与 Python 列表类似，在
    **ndarray** 中，索引涉及使用索引值从数组中检索特定元素。作为这种功能的演示，请考虑使用以下代码访问数组的第二个元素：
- en: '[PRE52]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Multidimensional arrays also support indexing and slicing, not just 1D arrays.
    To illustrate this point, consider the code below which retrieves an element from
    a 2D array by specifying its row and column coordinates:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 多维数组也支持索引和切片，而不仅仅是 1D 数组。为了说明这一点，请考虑以下代码，它通过指定行和列坐标从 2D 数组中检索一个元素：
- en: '[PRE53]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Slicing is a powerful technique that enables us to extract a subarray from
    an array. The syntax for slicing resembles indexing, but instead of square brackets,
    it uses periods `**..**` to specify the start and end points of the slice. To
    illustrate this method in action, consider the following code, which generates
    a new array consisting only of its first three elements:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 切片是一种强大的技术，可以从数组中提取子数组。切片的语法类似于索引，但它使用点 `**..**` 来指定切片的开始和结束点。为了展示这种方法，请考虑以下代码，它生成一个只包含前三个元素的新数组：
- en: '[PRE54]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Reshaping
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重塑
- en: Reshaping is a technique of altering the configuration or arrangement of an
    array while retaining its data. The ndarray library offers a range of powerful
    functions to reshape arrays, such as `[**flatten**](https://docs.rs/ndarray-linalg/latest/ndarray_linalg/convert/fn.flatten.html)`
    and, most notably, `[**reshape**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.reshape)`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 重塑是一种改变数组配置或排列的技术，同时保留其数据。ndarray 库提供了一系列强大的函数来重塑数组，如 `[**flatten**](https://docs.rs/ndarray-linalg/latest/ndarray_linalg/convert/fn.flatten.html)`
    和最显著的 `[**reshape**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.reshape)`。
- en: Reshape
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重塑
- en: '![](../Images/aee487bbadac24685a13ee9faaed8344.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/aee487bbadac24685a13ee9faaed8344.png)'
- en: Array reshaping (image by author)
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 数组重塑（图像由作者提供）
- en: 'With the `[**reshape**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.reshape)`
    function, which can only be applied on `[**ArcArray**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#arcarray)`,
    you can modify an array’s shape by defining the number of rows and columns for
    its new configuration. For example, the following code snippet transforms a 1D
    array with four elements into a 2D one consisting of two rows and two columns:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `[**reshape**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.reshape)`
    函数，这个函数只能应用于 `[**ArcArray**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#arcarray)`，你可以通过定义新配置的行数和列数来修改数组的形状。例如，以下代码片段将一个具有四个元素的
    1D 数组转换为一个包含两行两列的 2D 数组：
- en: '[PRE55]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '**Flatten**'
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**展平**'
- en: '![](../Images/c2722fbb99175769336a7d26d5090003.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c2722fbb99175769336a7d26d5090003.png)'
- en: Array flattening (Image by author)
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 数组展平（图像由作者提供）
- en: The `[**ndarray_linalg::convert::flatten**](https://docs.rs/ndarray-linalg/latest/ndarray_linalg/convert/fn.flatten.html)`
    function produces a 1D array containing all the elements from the source array.
    However, it generates a new copy of data instead of mutating the original collection.
    This approach ensures distinctness between both arrays and avoids any potential
    confusion or errors arising from overlapping arrays.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`[**ndarray_linalg::convert::flatten**](https://docs.rs/ndarray-linalg/latest/ndarray_linalg/convert/fn.flatten.html)`
    函数生成一个包含源数组所有元素的 1D 数组。然而，它会生成一个新的数据副本，而不是改变原始集合。这种方法确保了两个数组之间的区别，避免了由于数组重叠而引发的潜在混淆或错误。'
- en: '[PRE56]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Not only does `**ndarray**` offer the ability to reshape arrays, but it also
    presents a range of other functions for array manipulation. These include transposing,
    and swapping axes, among many others.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`**ndarray**` 不仅提供了重塑数组的功能，还提供了一系列其他数组操作函数。这些包括转置和交换轴等。'
- en: Transposing
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转置
- en: '![](../Images/01ba4d4b77e0dea0ff774279f8515b96.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01ba4d4b77e0dea0ff774279f8515b96.png)'
- en: Array transposition (Image by author)
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 数组转置（图像由作者提供）
- en: 'By using the`[**t**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.t)`
    function, a new array is generated with its axes transposed. To illustrate this
    point, let’s consider the following code snippet which demonstrates how to transpose
    a 2D array:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `[**t**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.t)`
    函数，可以生成一个其轴已转置的新数组。为了说明这一点，让我们考虑以下代码片段，该片段演示了如何转置一个二维数组：
- en: '[PRE57]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Swapping Axes
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交换轴
- en: Swapping axes in `**ndarray**` involve exchanging the rows and columns within
    the array. This can be accomplished by utilizing either the `**t**` method, previously
    discussed, or through using ndarray’s `[**swap_axes**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.swap_axes)`
    method. Swapping axes is a crucial aspect when conducting data analysis with multi-dimensional
    arrays.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `**ndarray**` 中交换轴涉及交换数组中的行和列。这可以通过使用先前讨论的 `**t**` 方法或使用 ndarray 的 `[**swap_axes**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.swap_axes)`
    方法来完成。交换轴是进行多维数组数据分析时的一个关键方面。
- en: 'It’s important to note that an axis refers to each dimension present within
    a multi-dimensional array; for instance, 1D arrays have only one axis, while 2D
    ones possess two — namely rows and columns. Similarly, 3D arrays feature three
    distinct axes: height, width, and depth — starting from zero until additional
    axes are added.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，轴是指多维数组中的每一个维度；例如，1D 数组只有一个轴，而 2D 数组具有两个轴——即行和列。类似地，3D 数组具有三个不同的轴：高度、宽度和深度——从零开始，直到添加额外的轴。
- en: To perform such swaps using Rust’s `**ndarray**` library via its built-in methods
    like `**swap_axes**`, you need simply provide it with two arguments representing
    which specific pair should be swapped around accordingly based on their respective
    positions along these various dimensional planes!
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Rust 的 `**ndarray**` 库通过其内置方法如 `**swap_axes**` 执行这样的交换，你只需提供两个参数，表示要根据它们在不同维度平面上的位置进行交换的具体对。
- en: '[PRE58]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Linear Algebra
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线性代数
- en: Ndarray, a feature-rich Rust library for numerical calculations and data handling,
    provides exceptional linear algebra support through a separate crate called `[**ndarray-linalg**](https://crates.io/crates/ndarray-linalg)`.
    This section delves into the diverse array of functions that `**ndarray**` offers
    in terms of linear algebra and how they can be effectively utilized to facilitate
    data analysis tasks easily.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Ndarray 是一个功能丰富的 Rust 库，用于数值计算和数据处理，通过一个名为 `[**ndarray-linalg**](https://crates.io/crates/ndarray-linalg)`
    的独立 crate 提供卓越的线性代数支持。本节将深入探讨 `**ndarray**` 在进行线性代数方面提供的多种函数，并展示如何有效地利用这些函数来轻松促进数据分析任务。
- en: '**Matrix Multiplication**: The process of matrix multiplication can be executed
    through the `[**ArrayBase.dot**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.dot)`
    function, which effectively calculates the dot product between two matrices. To
    illustrate this concept further, we will utilize it to determine the outcome when
    multiplying matrices `**a**` and `**b**` together and then storing that result
    in a new matrix called `**c**`.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**矩阵乘法**：矩阵乘法的过程可以通过 `[**ArrayBase.dot**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.dot)`
    函数执行，该函数有效地计算两个矩阵之间的点积。为了进一步说明这个概念，我们将利用它来确定将矩阵 `**a**` 和 `**b**` 相乘的结果，并将该结果存储在一个名为
    `**c**` 的新矩阵中。'
- en: '[PRE59]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '**Inversion**: another essential operation when working with matrices that
    can be achieved using `[**ndarray_linalg::solve::Inverse.inv**](https://docs.rs/ndarray-linalg/latest/ndarray_linalg/solve/trait.Inverse.html#tymethod.inv)`
    function that computes the inverse for any given matrix inputted into it! For
    instance, suppose you want to invert Matrix `**array_d2**`, invoke the `**inv**`
    method on its values, and use a `**match**` statement to handle the result.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逆运算**：在处理矩阵时，另一个重要操作是通过 `[**ndarray_linalg::solve::Inverse.inv**](https://docs.rs/ndarray-linalg/latest/ndarray_linalg/solve/trait.Inverse.html#tymethod.inv)`
    函数来实现的，该函数计算任何给定矩阵的逆！例如，假设你想要对矩阵 `**array_d2**` 进行逆运算，调用其 `**inv**` 方法，并使用 `**match**`
    语句来处理结果。'
- en: '[PRE60]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '**Eigen Decomposition**: The `[**use ndarray_linalg::Eig**](https://docs.rs/ndarray-linalg/latest/ndarray_linalg/eig/trait.Eig.html#tymethod.eig)`
    function showcases this by calculating the eigenvalues and eigenvectors of a matrix.
    In our case, we determine these values for Matrix `**array_d2**` and save them
    in matrices `**eigs**` and `**vecs**` correspondingly.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特征分解**：`[**use ndarray_linalg::Eig**](https://docs.rs/ndarray-linalg/latest/ndarray_linalg/eig/trait.Eig.html#tymethod.eig)`函数通过计算矩阵的特征值和特征向量来展示这一点。在我们的例子中，我们确定了矩阵`**array_d2**`的这些值，并分别将它们保存在矩阵`**eigs**`和`**vecs**`中。'
- en: '[PRE61]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '**Singular Value Decomposition (SVD)**: The power of `[**ndarray_linalg::svd::SVD**](https://docs.rs/ndarray-linalg/latest/ndarray_linalg/svd/trait.SVD.html#tymethod.svd)`
    function is showcased as it calculates the left and right singular vectors along
    with the distinct values for a given matrix. To illustrate this, we perform **SVD**
    on matrix `**array_d2**` resulting in `**u**` holding its left singular vectors,
    `**v**` storing its distinct values while containing the right ones.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**奇异值分解（SVD）**：`[**ndarray_linalg::svd::SVD**](https://docs.rs/ndarray-linalg/latest/ndarray_linalg/svd/trait.SVD.html#tymethod.svd)`函数的强大功能体现在它计算给定矩阵的左奇异向量、右奇异向量以及奇异值。为了说明这一点，我们对矩阵`**array_d2**`执行**SVD**，得到`**u**`保存左奇异向量，`**v**`存储奇异值，同时包含右奇异向量。'
- en: '[PRE62]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '**Matrix Trace**: The `[**ndarray_linalg::trace::Trace**](https://docs.rs/ndarray-linalg/latest/ndarray_linalg/trace/trait.Trace.html#tymethod.trace)`
    function is a powerful function that calculates the sum of diagonal elements in
    any matrix. By applying this method to Matrix `**array_d2**`, we obtain its trace
    result and match its value for further analysis. This simple yet effective technique
    showcases how mathematical functions can enhance data processing capabilities
    with ease and precision.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**矩阵迹**：`[**ndarray_linalg::trace::Trace**](https://docs.rs/ndarray-linalg/latest/ndarray_linalg/trace/trait.Trace.html#tymethod.trace)`函数是一个强大的函数，用于计算任何矩阵对角线元素的总和。通过将此方法应用于矩阵`**array_d2**`，我们得到其迹结果，并匹配其值以进行进一步分析。这种简单而有效的技术展示了数学函数如何轻松而精确地提升数据处理能力。'
- en: '[PRE63]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '**Matrix Determinant**: The calculation of a matrix’s determinant is exemplified
    through the utilization of [**ndarray_linalg::solve::Determinant**](https://docs.rs/ndarray-linalg/latest/ndarray_linalg/solve/trait.Determinant.html#method.det)
    function. Our focus lies on computing the determinant value for Matrix `**array_d2**`.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**矩阵行列式**：通过使用[**ndarray_linalg::solve::Determinant**](https://docs.rs/ndarray-linalg/latest/ndarray_linalg/solve/trait.Determinant.html#method.det)函数来计算矩阵的行列式。我们关注的是计算矩阵`**array_d2**`的行列式值。'
- en: '[PRE64]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '**Solving Linear Equations**: The `[**ndarray_linalg::solve**](https://docs.rs/ndarray-linalg/latest/ndarray_linalg/solve/index.html)`
    function is utilized to showcase the solution of a set of linear equations in
    the format `**ax = b**`. In this example, we resolve the equation system `**ax=b**`
    by employing `**a**` as an array of constants and then store our results within
    the variable `**x**`.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**求解线性方程**：`[**ndarray_linalg::solve**](https://docs.rs/ndarray-linalg/latest/ndarray_linalg/solve/index.html)`函数用于展示如何求解`**ax
    = b**`格式的线性方程组。在这个例子中，我们通过使用`**a**`作为常量数组来解决方程组`**ax=b**`，然后将结果存储在变量`**x**`中。'
- en: '[PRE65]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In this segment of the article, we delved into working with Multidimensional
    Arrays in `**ndarray**`. These arrays are a crucial component utilized across
    various scientific computing fields. The `**array!**` macro function in `**ndarray**`
    enables effortless creation and manipulation of multidimensional arrays, making
    it an invaluable tool for data management.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在文章的这一部分，我们深入探讨了如何使用`**ndarray**`中的多维数组。这些数组是各个科学计算领域中一个至关重要的组件。`**array!**`宏函数在`**ndarray**`中使得多维数组的创建和操作变得轻而易举，这使其成为数据管理中的一项宝贵工具。
- en: In addition, we have gained knowledge on how to utilize Arithmetic operations
    with `**ndarray**` arrays. These types of arrays are capable of supporting fundamental
    arithmetic functions like adding, subtracting, multiplying, and dividing. It is
    possible to carry out these calculations either for individual elements or the
    entire array simultaneously.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还了解了如何利用`**ndarray**`数组进行算术运算。这些类型的数组能够支持基本的算术功能，如加、减、乘、除。可以对单个元素或整个数组同时进行这些计算。
- en: Finally, we delved into the realm of `**ndarray**` and its application in Linear
    Algebra. This dynamic tool offers a vast array of functions that enable seamless
    matrix operations including dot product, transpose, inverse as well as determinant.
    These fundamental mathematical tools are essential for tackling complex problems
    encountered across diverse fields such as finance, engineering, and physics.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们深入探讨了 `**ndarray**` 及其在线性代数中的应用。这种动态工具提供了广泛的函数，能够无缝进行矩阵操作，包括点积、转置、逆矩阵以及行列式。这些基本数学工具对于解决在金融、工程和物理等各个领域遇到的复杂问题至关重要。
- en: Conclusion
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: 'Throughout this article, we delved into the fundamental data structures in
    Rust and demonstrated how to execute various arithmetic operations using the **ndarray**
    library. Additionally, it highlights Rust’s potential for linear algebra: a critical
    component of data science.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们深入探讨了 Rust 中的基本数据结构，并演示了如何使用**ndarray**库执行各种算术操作。此外，还强调了 Rust 在线性代数方面的潜力，这是数据科学的一个关键组件。
- en: This long-running series indicates that Rust is a language with remarkable strength
    and vast capabilities for seamlessly building data science projects. It provides
    exceptional performance while also being relatively simple to handle complex datasets.
    Those looking to pursue a promising career in data science should undoubtedly
    include Rust as one of their top choices.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这个长期连载表明，Rust 是一种具有显著优势和广泛能力的语言，能够无缝地构建数据科学项目。它在处理复杂数据集时表现出色，同时相对简单。那些希望在数据科学领域取得有前途职业的人应该毫无疑问地将
    Rust 作为首选之一。
- en: Closing Note
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结尾说明
- en: '![](../Images/bef1895c3809bb773cf033fd615b0884.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/bef1895c3809bb773cf033fd615b0884.png)'
- en: Photo by [Kelly Sikkema](https://unsplash.com/@kellysikkema?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 照片由 [Kelly Sikkema](https://unsplash.com/@kellysikkema?utm_source=medium&utm_medium=referral)
    提供，刊登于 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: As always, I want to take a moment and extend my heartfelt gratitude to everyone
    who has invested their efforts and time in reading this article and following
    along. Showcasing the capabilities of Rust and its ecosystem with you all was
    an absolute delight.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，我想花一点时间向所有投入时间和精力阅读本文并跟进的人表示衷心的感谢。与大家一起展示 Rust 及其生态系统的能力是非常愉快的体验。
- en: Being passionate about data science, I promise you that I will keep writing
    at least one comprehensive article every week or so on related topics. If staying
    updated with my work interests you, consider connecting with me on various social
    media platforms or reach out directly if anything else needs assistance.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 对数据科学充满热情的我承诺，每周都会写至少一篇全面的相关文章。如果你对跟进我的工作感兴趣，可以考虑在各种社交媒体平台上与我联系，或直接联系我，如果有其他需要帮助的地方。
- en: Thank You!
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 谢谢！
- en: Resources
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源
- en: '[](https://github.com/wiseaidev/rust-data-analysis?source=post_page-----ef5ab767212a--------------------------------)
    [## GitHub - wiseaidev/rust-data-analysis: The ultimate data analysis course with
    Rust.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://github.com/wiseaidev/rust-data-analysis?source=post_page-----ef5ab767212a--------------------------------)
    [## GitHub - wiseaidev/rust-data-analysis: 最终的数据分析课程，使用 Rust。'
- en: This repository is a collection of Jupyter notebooks, all powered by a Rust
    kernel. With these notebooks, you'll be…
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 这个库包含了一系列 Jupyter notebook，所有这些 notebook 都由 Rust 内核驱动。通过这些 notebook，你将会……
- en: github.com](https://github.com/wiseaidev/rust-data-analysis?source=post_page-----ef5ab767212a--------------------------------)  [##
    ndarray - Rust
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: github.com](https://github.com/wiseaidev/rust-data-analysis?source=post_page-----ef5ab767212a--------------------------------)  [##
    ndarray - Rust
- en: Expand description The ndarray crate provides an n-dimensional container for
    general elements and for numerics. In…
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 展开描述 ndarray crate 提供了一个用于一般元素和数值的 n 维容器。在……
- en: docs.rs](https://docs.rs/ndarray/latest/ndarray/?source=post_page-----ef5ab767212a--------------------------------)
    [](https://doc.rust-lang.org/std/index.html?source=post_page-----ef5ab767212a--------------------------------)
    [## std - Rust
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: docs.rs](https://docs.rs/ndarray/latest/ndarray/?source=post_page-----ef5ab767212a--------------------------------)
    [](https://doc.rust-lang.org/std/index.html?source=post_page-----ef5ab767212a--------------------------------)
    [## std - Rust
- en: The Rust Standard Library is the foundation of portable Rust software, a set
    of minimal and battle-tested shared…
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Rust 标准库是可移植 Rust 软件的基础，一套经过最小化和实战检验的共享库……
- en: doc.rust-lang.org](https://doc.rust-lang.org/std/index.html?source=post_page-----ef5ab767212a--------------------------------)  [##
    Rust By Example
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: doc.rust-lang.org](https://doc.rust-lang.org/std/index.html?source=post_page-----ef5ab767212a--------------------------------)  [##
    Rust By Example
- en: Rust is a modern systems programming language focusing on safety, speed, and
    concurrency. It accomplishes these goals…
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Rust 是一种现代系统编程语言，注重安全性、速度和并发性。它实现这些目标的方式是…
- en: doc.rust-lang.org](https://doc.rust-lang.org/rust-by-example/?source=post_page-----ef5ab767212a--------------------------------)  [##
    The Rust Programming Language
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '[Rust By Example](https://doc.rust-lang.org/rust-by-example/?source=post_page-----ef5ab767212a--------------------------------)
    [## Rust 编程语言'
- en: by Steve Klabnik and Carol Nichols, with contributions from the Rust Community
    This version of the text assumes you're…
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作者：Steve Klabnik 和 Carol Nichols，感谢 Rust 社区的贡献。本版本的文本假设你已…
- en: doc.rust-lang.org](https://doc.rust-lang.org/book/?source=post_page-----ef5ab767212a--------------------------------)
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '[Rust 编程语言](https://doc.rust-lang.org/book/?source=post_page-----ef5ab767212a--------------------------------)'
