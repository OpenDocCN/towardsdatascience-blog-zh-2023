- en: 'The Ultimate Ndarray Handbook: Mastering the Art of Scientific Computing with
    Rust'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/the-ultimate-ndarray-handbook-mastering-the-art-of-scientific-computing-with-rust-ef5ab767212a?source=collection_archive---------1-----------------------#2023-05-02](https://towardsdatascience.com/the-ultimate-ndarray-handbook-mastering-the-art-of-scientific-computing-with-rust-ef5ab767212a?source=collection_archive---------1-----------------------#2023-05-02)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An overview of different Rust’s built-in data structures and a deep dive into
    the Ndarray library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://wiseai.medium.com/?source=post_page-----ef5ab767212a--------------------------------)[![Mahmoud
    Harmouch](../Images/d61617549d25565399975debaad5908f.png)](https://wiseai.medium.com/?source=post_page-----ef5ab767212a--------------------------------)[](https://towardsdatascience.com/?source=post_page-----ef5ab767212a--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----ef5ab767212a--------------------------------)
    [Mahmoud Harmouch](https://wiseai.medium.com/?source=post_page-----ef5ab767212a--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fb15db3da5667&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fthe-ultimate-ndarray-handbook-mastering-the-art-of-scientific-computing-with-rust-ef5ab767212a&user=Mahmoud+Harmouch&userId=b15db3da5667&source=post_page-b15db3da5667----ef5ab767212a---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----ef5ab767212a--------------------------------)
    ·31 min read·May 2, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fef5ab767212a&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fthe-ultimate-ndarray-handbook-mastering-the-art-of-scientific-computing-with-rust-ef5ab767212a&user=Mahmoud+Harmouch&userId=b15db3da5667&source=-----ef5ab767212a---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fef5ab767212a&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fthe-ultimate-ndarray-handbook-mastering-the-art-of-scientific-computing-with-rust-ef5ab767212a&source=-----ef5ab767212a---------------------bookmark_footer-----------)![](../Images/6fd226fc675887e1ef5fcb21042dc628.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Photo by [Crissy Jarvis](https://unsplash.com/@crissyjarvis?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: TL;DR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust has gained immense popularity as a programming language globally, and it’s
    not without reason. Additionally, when discussing data analysis specifically,
    Rust stands out from its peers with its exceptional capabilities in this field.
    The extensive library support coupled with robust tools makes Rust the preferred
    option for many professionals working on complex datasets today. Moreover, knowing
    how to store your data is essential if you are looking to use Rust for data analysis
    or other related tasks.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this article, you’ll have a rock-solid foundation that will enable
    you to kick off your Rust data analysis journey with confidence and ease.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**: This article assumes you are a bit familiar with Rust references
    and its borrow checker.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The notebook named [2-ndarray-tutorial.ipynb](https://github.com/wiseaidev/rust-data-analysis/blob/main/2-ndarray-tutorial.ipynb)
    was developed for this article which can be found in the following repo:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[](https://github.com/wiseaidev/rust-data-analysis?source=post_page-----ef5ab767212a--------------------------------)
    [## GitHub - wiseaidev/rust-data-analysis: The ultimate data analysis course with
    Rust.'
  prefs: []
  type: TYPE_NORMAL
- en: This repository is a collection of Jupyter notebooks, all powered by a Rust
    kernel. With these notebooks, you'll be…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: github.com](https://github.com/wiseaidev/rust-data-analysis?source=post_page-----ef5ab767212a--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Table of Contents(TOC)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ∘ [What Is This Article All About?](#d2ef)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Rust Built-In Data Structures](#3498)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [1\. Vectors](#5a24)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [2\. Arrays](#c03f)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [3\. Tuples](#d625)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [4\. Hash Sets](#2bba)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [5\. HashMaps](#31e1)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Ndarray for Data Analysis](#672d)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Ndarray Intro](#373b)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Ndarray Use Cases](#3b5f)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Initial Placeholders](#7d56)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Multidimensional Arrays](#b787)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Ndarray Arrays Manipulation](#b4f3)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Indexing & Slicing](#8047)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Reshaping](#1131)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Transposing](#edbc)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Swapping Axes](#7c44)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Linear Algebra](#bc63)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Conclusion](#aa63)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Closing Note](#aa3d)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Resources](#f6a5)
  prefs: []
  type: TYPE_NORMAL
- en: What Is This Article All About?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/e06c1558e0ba0e05b00c9891493a0b7a.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Ashni](https://unsplash.com/@ashni_ahlawat?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: The spotlight of this piece is on an essential Rust library for data analysis,
    namely `**ndarray**`. `**ndarray**` empowers users with the ability to handle
    large multi-dimensional arrays and matrices while also offering an extensive selection
    of mathematical operations that can be performed on them.
  prefs: []
  type: TYPE_NORMAL
- en: But before we dive into `**ndarray**` specifically, let’s take a step back and
    explore different **Rust built-in data structures** and why Rust is such a great
    language for data analysis in general.
  prefs: []
  type: TYPE_NORMAL
- en: Rust Built-In Data Structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’ll delve into the fundamental concepts and powerful tools
    that form the backbone of this fantastic Rust programming language. In particular,
    we will cover the basics of Rust data structures, including vectors, tuples, sets,
    and hash maps, gaining a solid understanding of how they work and how they can
    be used to solve real-world problems.
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Vectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/1d7913fc0d7655a9d216be4d419e6f47.png)'
  prefs: []
  type: TYPE_IMG
- en: Vectors memory layout (Image by author)
  prefs: []
  type: TYPE_NORMAL
- en: '**Vectors**, known as “**lists**” in some programming languages like Python,
    are everywhere; From simple shopping lists to more complex recipe instructions,
    they can help us keep track of things and find them when needed. In programming,
    vectors are an essential data structure used in countless applications, taking
    many different shapes and forms.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Vector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Rust, vectors are essential data structures, and you can create them using
    different approaches. To create an empty vector, you can call the `[**Vec::new()**](https://doc.rust-lang.org/std/vec/struct.Vec.html#method.new)`
    function and add a type annotation since Rust doesn’t know what elements you intend
    to store in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use the `[**vec!**](https://doc.rust-lang.org/std/macro.vec.html#)`
    macro to create a new vector with initial values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The rust compiler has the ability to **infer the type** of vector through its
    initial values, thereby eliminating manual specification. After creating a vector,
    you have diverse options for modifying it based on your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Vectors Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Rust, we can access values stored in a vector in two ways: either by indexing
    or using the `[**get**](https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.get)`
    method. Let’s explore both methods, along with some code examples!'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s consider the following vector `**v**` with some values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The indexing operator `**[]**` can be utilized to retrieve a specific value
    from a vector. To access the second element, let’s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we’re creating a reference `**&**` to the second element in the vector
    using indexing with `**[]**`. When attempting to access a non-existent index,
    the Rust compiler will trigger termination/panic and cause program failure. To
    avoid this, we can utilize the get function that produces an `**Option<&T>**`
    instead of a reference. Here’s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: By invoking `**v.get(2)**`, the method will return an `[**Option<&T>**](https://doc.rust-lang.org/std/option/index.html)`
    type that yields a positive result in the form of `**Some**` if the element is
    present, or a negative outcome as `**None**`. We can utilize a robust approach
    by implementing a **match expression** to handle both scenarios effectively. By
    leveraging these techniques, you can easily access elements in vectors!
  prefs: []
  type: TYPE_NORMAL
- en: Iterating over Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Rust, iterating through a vector is a common task that can be executed in
    two ways: utilizing **immutable** and **mutable** references. This approach enables
    us to perform actions on each vector element individually. To gain further understanding,
    let’s explore both of these methods using some code examples!'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the above code snippet, we are using the `**&**` operator to obtain an immutable
    reference for every item in the vector. Then, we display the value of each element
    by utilizing the `[**println**](https://doc.rust-lang.org/std/macro.println.html)**!**`
    macro.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the `[**iter()**](https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter)`
    function creates an iterator for vector values. Using this technique, we can obtain
    mutable references to each value in the vector, allowing us to add 10 seamlessly.
    The code below demonstrates how to use the `**iter()**` method to optimize your
    iteration over vectors efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can effectively traverse a **portion** of the vector’s elements by utilizing
    a **for loop** and **range**. To illustrate this concept, consider the following
    code snippet showcasing how to employ a for loop to obtain **immutable references**
    to get only three elements from a given vector before outputting them to the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: By utilizing Rust’s `[**enumerate()**](https://doc.rust-lang.org/core/iter/trait.Iterator.html#method.enumerate)`
    function, we can effortlessly traverse a vector and obtain its values and corresponding
    indices. The code snippet below showcases how to use the `**enumerate()**` method
    to retrieve **immutable references** for each element within an `**i32**` value-based
    vector while simultaneously printing their respective indices and values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Using these techniques, you can easily **iterate** and **manipulate** elements
    in vectors!
  prefs: []
  type: TYPE_NORMAL
- en: Modifying a Vector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The versatility of Rust’s vector lies in its ability to resize dynamically,
    allowing for the addition or removal of elements during runtime. This section
    will explore different approaches to modifying and updating vectors within Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Adding elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/add9570e28879f1d0e4854190a2708ff.png)'
  prefs: []
  type: TYPE_IMG
- en: Add an element to a vector (Image by author)
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add elements to a vector using the `[**push**](https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.push)`
    method, which appends an element to the end of the vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The given example involves the creation of a three-element vector, followed
    by appending **“mango”** to its end with a **push** operation. Finally, we display
    the modified vector on the terminal via the `**println!**` macro. Alternatively,
    We can use the insert method to add an element at a specific index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The above example entails the creation of a four-element vector, followed by
    the insertion of **“mango”** at the end of the vector by utilization of the `[**insert**](https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.insert)`
    method. Finally, we display the modified vector on the terminal through the `**println!**`
    macro.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To alter the elements of a string vector, we can utilize the index operator
    `**[]**` to reach out for an element at a particular position and substitute it
    with a new value. This approach is highly effective in modifying values within
    a given vector.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The given example involves the creation of a vector `**v**` comprising three
    elements, followed by the alteration of its second element (located at index 1)
    to `**“pear”**` and assigning `**“grapefruit”**` as the value for the third one
    (at index 2). Finally, we display this updated version on the terminal through
    the `**println!**` macro.
  prefs: []
  type: TYPE_NORMAL
- en: Removing Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/78b67871e69275da49c456afea969603.png)'
  prefs: []
  type: TYPE_IMG
- en: Removing an element from a vector (Image by author)
  prefs: []
  type: TYPE_NORMAL
- en: 'We can remove an element from a vector using the `[**pop()**](https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.pop)`
    method, which removes and returns the last element of the vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the example above, we created a four-element vector called `**v**` and then
    removed the last element using the `**pop**` method. This method also provides
    us with the removed component as output. Finally, we used the `**println!**` macro
    to display both our updated vector and extracted element on the terminal screen
    in an orderly manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the `[**remove**](https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.remove)`
    method to remove an element at a specific index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove all elements from a vector in Rust, use `[**retain**](https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.retain)`
    method to keep all elements that match a certain condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Concatenating Two Vectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To concatenate two vectors of strings, we can use the `**extend**` method,
    which takes an **iterator** as an argument and appends all its elements to the
    vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the example above, we first create two vectors `**v1**` and `**v2**` , then
    we concatenate them by calling the extend method on `**v1**` and passing `**v2**`
    as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Filter & Map Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can filter and map elements of a vector in Rust using the `[**iter**](https://doc.rust-lang.org/core/iter/index.html)`,
    `[**filter**](https://doc.rust-lang.org/core/iter/struct.Filter.html)`, and `[**map**](https://doc.rust-lang.org/core/iter/struct.Map.html)`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filter Elements**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can effectively filter out vector elements by combining the `**iter**` and
    `**filter**` methods. To illustrate this point, let’s consider how to filter out
    all even numbers from a set of integers using the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the example above, we first create a vector `**v**` with ten elements, then
    we use `**iter**` and `**filter**` methods to create a new vector `**odd_numbers**`
    that contains only the **odd numbers** from v. Finally, we print the new vector
    to the terminal using the `**println!**` macro.
  prefs: []
  type: TYPE_NORMAL
- en: Map Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To **map** elements of a vector, we can use the `**iter**` and `**map**` methods
    together. For example, to convert a vector of strings to uppercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the example above, we first create a vector `**v**` with **three** elements,
    then we use `**iter**` and `**map**` methods to create a new vector `**uppercase_strings**`
    that contains the uppercase versions of the elements in v. Finally, we print the
    new vector to the console using the `**println!**` macro.
  prefs: []
  type: TYPE_NORMAL
- en: Length
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To compute the length, we can use the `[**len**](https://doc.rust-lang.org/core/iter/trait.ExactSizeIterator.html#method.len)`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Check If Element Exists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use `[**contains**](https://doc.rust-lang.org/core/primitive.str.html#method.contains)`
    to check if a vector contains a specific element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note the method requires a **borrowed copy**, hence the `**&**` in the argument.
    The compiler will tell you to add this symbol if you forget.
  prefs: []
  type: TYPE_NORMAL
- en: Reversing Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can reverse a vector in Rust using the `[**reverse**](https://doc.rust-lang.org/core/primitive.slice.html#method.reverse)`
    method. This method modifies the vector in place, so it doesn’t return anything.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the example above, a vector `**v**` consisting of five elements is created,
    and then the `**reverse**` method is employed to alter the sequence of these components
    in place. Finally, we display the reversed vector on the terminal for observation.
  prefs: []
  type: TYPE_NORMAL
- en: Maximum & Minimum Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By utilizing Rust’s `**iter**` function alongside the `**max**` and `**min**`
    methods, one can effortlessly locate both the highest and lowest values within
    a vector. This approach is highly effective in simplifying such operations with
    ease.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the example above, we initialized a vector v of five elements. Subsequently,
    the `**iter**` method is employed to create an iterator which helps us determine
    the maximum and minimum values by utilizing `**max**` and `**min**` methods. Finally,
    using `**println!**`, we display both these results on the console screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have a solid foundation for using and manipulating vectors, let’s
    look at another built-in collection: arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/c5f5bed40ef9169713b78f1dfdc56123.png)'
  prefs: []
  type: TYPE_IMG
- en: Rust array memory layout (Image by author)
  prefs: []
  type: TYPE_NORMAL
- en: Using an **array** is a viable option for storing different values of the same
    data type. **Unlike vectors**, each element in the array must have **consistent
    data types**. Compared to arrays in other programming languages, they are **fixed-size
    collections** with identical data type elements. These collections come with benefits
    when you need to allocate memory on the **stack** or know that their sizes will
    remain constant throughout the runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create an array, you can use square brackets `**[]**` with comma-separated
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also explicitly specify the number of elements in the array and their
    types, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this syntax, an array consisting of `**i32**` values with a length equivalent
    to 5 can be formed. In order to set all elements within this array to one typical
    value, you may employ the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This creates an array of length 5, with all the elements initialized to 0.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can access individual elements of an array using square brackets with the
    index of the element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Modifying Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since arrays have a fixed size, you cannot push or remove elements like vectors.
    However, you can modify individual elements by making the array mutable using
    the `**mut**` keyword so that you can change its elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Iterating
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To retrieve every individual element from an array, we must traverse through
    all of them instead of relying on indices to access one at a time. Demonstrated
    below is the implementation of a for loop that effectively retrieves and prints
    out each value within an `**i32**` type array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Slicing Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also create a new array that contains a subset of the original array
    using slicing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This creates a new array containing the original array’s elements at indices
    1, 2, and 3.
  prefs: []
  type: TYPE_NORMAL
- en: To sum up, Rust arrays are versatile data structures that serve numerous purposes.
    Their fixed-size nature renders them more effective than vectors in specific scenarios.
    When you have the array size predetermined and no need for runtime modifications,
    employing arrays is an ideal choice for storing data.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A tuple is a compound type in Rust that allows you to group several values with
    varying types into one object. Regarding size, tuples are fixed and cannot be
    resized once declared, much like arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Tuple
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Rust, creating a tuple is an effortless task. Just enclose your values in
    parentheses and separate them with commas. Each position within the tuple has
    its type, which may differ from one another without any constraints on the uniformity
    of the types among all elements present in it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When creating a tuple, it is possible to incorporate optional type annotations.
    This can be observed in the example below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Updating a Tuple
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Utilizing the `**mut**` keyword, you can transform a tuple into a mutable form
    and modify its contents. This grants access to alter specific elements within
    the tuple by referencing them through **dot notation** followed by their respective
    **index** values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You can modify its elements by utilizing the dot notation followed by the corresponding
    element index.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Destructuring a Tuple
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The process of extracting different components from a tuple and assigning them
    to separate variables is known as **destructuring** which is demonstrated in the
    following example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also ignore some of the elements of the tuple while **destructuring**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, we can access a specific element in a tuple using indexing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In summary, tuples are a powerful way to group together **values with different
    types** into one object in Rust. They are **immutable** and **fixed in size**
    but can be made mutable to modify their contents. You can also **destructure**
    tuples to access their elements. With these features, tuples are a versatile tool
    for working with data in Rust!
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Hash Sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are familiar with Python, sets may already be a known concept. These
    collections consist of distinct elements and do not prioritize orders. In Rust
    programming language, **hash sets** and **B-tree sets** represent these unique
    groups; however, the former is more frequently employed in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating a hash set in Rust is as simple as importing it from the standard
    library and calling the `**new**` method or associated function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create a set from a vector of elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even initialize it from an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Updating a Set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adding elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adding elements to a hash set is easy with the `[**insert**](https://doc.rust-lang.org/std/collections/hash_set/struct.HashSet.html#method.insert)`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Removing elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Removing elements from a hash set is done using the `[**remove**](https://doc.rust-lang.org/std/collections/hash_set/struct.HashSet.html#method.remove)`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Iterate over Sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can easily iterate over a hash set using a for loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Sets Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/9398199d6d0f7c1e9d1c90dc219e4a59.png)'
  prefs: []
  type: TYPE_IMG
- en: Different set operations (Image by author)
  prefs: []
  type: TYPE_NORMAL
- en: 'Rust’s hash sets offer an array of set operations, including `[**difference**](https://doc.rust-lang.org/std/collections/hash_set/struct.Difference.html)`,
    `[**intersection**](https://doc.rust-lang.org/std/collections/hash_set/struct.Intersection.html)`,
    and `[**union**](https://doc.rust-lang.org/std/collections/hash_set/struct.Union.html)`
    functions. These functionalities enable us to execute set arithmetic on hash sets
    which makes them a valuable resource for storing unique data. To illustrate this
    point, let’s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In essence, hash sets are an indispensable asset that every Rust developer has
    to familiarize themselves with. They possess remarkable efficiency and offer plenty
    of operations for **set arithmetic**. Having been equipped with the illustrations
    provided, you should now be able to incorporate hash sets into your personal Rust
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: For more info, you can refer to [the official doc](https://doc.rust-lang.org/std/collections/struct.HashSet.html).
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Hash Maps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0f1181e99cd25818afcc8b70220e3d3b.png)'
  prefs: []
  type: TYPE_IMG
- en: Hash Map (image by author)
  prefs: []
  type: TYPE_NORMAL
- en: Hash Maps are a type of collection that consists of **key-value pairs** and
    offer quick and effective access to data by utilizing keys instead of indexing.
    Rust declares Hash Maps through the `[**std::collections::HashMap**](https://doc.rust-lang.org/std/collections/struct.HashMap.html)`
    module, an unordered structure with remarkable speed. Let’s look at how to create,
    update, access, and iterate over Hash Maps in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Hash Map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can initialize a Hash Map in Rust in a number of ways, one of which is by
    using the `[**new**](https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.new)`
    method of the Hash Map struct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the given instance, we introduce a new Hash Map named `**employees_map**`.
    Subsequently, utilizing the `[**insert**](https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.insert)`
    function, we add elements to this Hash Map. Lastly, by applying the `**println!**`
    macro and formatting it with `**{:?}**`, we exhibit debug mode representation
    of our created HashMap. Another way to initialize a HashMap is by using the `[**HashMap::from**](https://doc.rust-lang.org/std/collections/struct.HashMap.html#impl-From%3C%5B(K,+V);+N%5D%3E-for-HashMap%3CK,+V,+RandomState%3E)`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Updating a Hash Map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adding Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have seen in the previous example, we can use the `[**insert**](https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.insert)`
    method to add elements (**key-value pairs**) to a Hash Map. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Removing Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use the `[**remove**](https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.remove)`
    method to remove an element (**key-value pair**) from a Hash Map. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Updating an Element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can update elements of a Hash Map by using the `[**insert**](https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.insert)`
    method. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Access Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like Python, we can use the `**get**` to access a value from a given Hash Map
    in Rust. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Iterate over Hash Maps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In essence, Rust’s Hash Map is a robust data structure that facilitates the
    effective management and arrangement of data through **key-value pairs**. They
    offer **fast access** to data and are frequently used for tasks like **counting
    occurrences**, **memoization**, and **caching**. Thanks to Rust’s integrated Hash
    Map implementation coupled with its extensive array of techniques, utilizing Hash
    Maps is an effortless process devoid of complications.
  prefs: []
  type: TYPE_NORMAL
- en: For more info, you can refer to [**this page**](https://doc.rust-lang.org/std/collections/struct.HashMap.html)
    of the official docs.
  prefs: []
  type: TYPE_NORMAL
- en: As we come to the end of this first segment, let us reflect on our journey into
    the vast world of Rust’s built-in data structures. Our exploration has led us
    through some fundamental components such as vectors, arrays, tuples, and hash
    maps — all crucial elements for any proficient programmer in their quest towards
    building robust programs.
  prefs: []
  type: TYPE_NORMAL
- en: Through our mastery of creating and accessing data structures and manipulating
    them with ease, we have gained valuable insights into their defining characteristics
    and nuances. Armed with this knowledge, you will be empowered to craft Rust code
    that is efficient and highly effective in achieving your desired outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: Having established a firm grasp on the fundamental concepts of Rust’s built-in
    data structures, we shall now integrate them with the latter half of this article
    that delves into Ndarray. This fantastic library is famous for its prowess in
    numerical computation within Rust. It features an array object similar to a vector
    but augmented with advanced capabilities to execute mathematical operations seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: Ndarray for Data Analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/62fc6ce98c7ec14be3334f950bc8fbc7.png)'
  prefs: []
  type: TYPE_IMG
- en: Different arrays Dimensions (image by author)
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following sections, we will delve into the world of `[**ndarray**](https://docs.rs/ndarray/latest/ndarray/)`:
    a robust Rust library that easily enables numerical computations and data manipulation.
    With its diverse array of methods for working with arrays and matrices containing
    numeric data, it is an essential asset in any data analysis toolkit. In the following
    sections, we’ll cover all aspects of using `**ndarray**` from scratch, including
    how to work with array and matrix structures and perform mathematical operations
    on them effortlessly. We’ll also explore advanced concepts such as indexing and
    slicing, which flexibly facilitate the efficient handling of large datasets.'
  prefs: []
  type: TYPE_NORMAL
- en: By following through examples and hands-on exercises throughout these sections,
    you can gain mastery over employing `ndarray`arrays effectively towards your unique
    analytical tasks!
  prefs: []
  type: TYPE_NORMAL
- en: Ndarray Intro
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `[**ArrayBase**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html)`
    struct provides an essential data structure, aptly named the n-dimensional array,
    that effectively stores and manages vast arrays of data. This includes integers
    or floating point values. The benefits of using a `**ndarray**`arraysover Rust’s
    native **arrays** or **tuple** structures are various: it is more efficient and
    user-friendly.'
  prefs: []
  type: TYPE_NORMAL
- en: Ndarray Use Cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some real-life use cases of `**ndarray**` in data analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data Cleaning and Preprocessing**: Ndarray offers robust features for data
    cleaning and preprocessing, including the ability to filter out missing values,
    convert various data types, and scale your dataset. Suppose you have a set of
    records with gaps; ndarray’s nan (not a number) value can represent these absent
    entries effectively. Utilizing functions like `[**fill**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.fill)`,
    you can easily manage those incomplete pieces of information without any hassle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data Visualization**: Ndarray arrays are a reliable option for data storage
    to facilitate visualization. The versatility of `**ndarray**` arrays allows them
    to be used with the `[**Plotters**](https://plotters-rs.github.io/home/)` library
    for visual representation purposes. For instance, by generating an array containing
    random numbers using Ndarrays, we could plot the distribution in the form of a
    histogram through **Plotters**’ plotting capabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Descriptive Statistics**: Ndarray offers an array of robust methods for doing
    descriptive statistics on arrays, including computing the mean, median, mode,
    variance, and standard deviation. These functions are invaluable in analyzing
    data as they provide a quick overview of key metrics. For instance, by utilizing
    ndarray’s `[**mean**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.mean)`
    function, we can easily calculate the average value within our dataset with ease.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Machine Learning**: Ndarray is a crucial component in machine learning, offering
    speedy and effective manipulation of large datasets. Numerical data must often
    be expressed as arrays for use with these algorithms, making `**ndarray**` an
    ideal solution due to its ease of use and efficiency. With this tool, we can effortlessly
    generate feature and label arrays that are essential for the success of any given
    machine-learning algorithm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linear Algebra**: Ndarray offers many robust methods for carrying out linear
    algebraic operations like matrix inversion, multiplication, and decomposition.
    These functions are convenient when analyzing data represented as matrices or
    vectors. For instance, the `[**dot**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.dot)`
    function in `**ndarray**` enables us to execute matrix multiplication on two arrays
    with ease.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initial Placeholders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Ndarray** offers a variety of functions for generating and initializing arrays,
    known as **initial placeholders** or array creation functions. These powerful
    tools enable us to create customized arrays with specific shapes and data types,
    complete with predetermined or randomized values. Here are some frequently utilized
    examples of these handy initial placeholder functions within the `**ndarray**`
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[**ndarray::Array::<type, _>::zeros(shape.f())**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.zeros)`:
    This function creates an array filled with zeros. The `**shape**` parameter specifies
    the array’s dimensions, and the `**type**` parameter specifies the data type of
    the array elements. The `**f**` function converts the array from row-major into
    column-major.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`[**ndarray::Array<::type, _>::ones(shape.f())**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.ones)`:
    This function creates an array filled with ones. The `**type**` and the `**f**`
    have the same effect as for `**ndarray::Array::zeros**`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`[**ndarray::Array::<type, _>::range(start, end, step)**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.range)`:
    This function creates an array with values in a range. The start parameter specifies
    the range’s start, and the end parameter specifies the end of the range (exclusive).
    The step parameter specifies the step size between values. The `**type**` parameter
    specifies the data type of the array elements.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`[**ndarray::Array::<type, _>::linspace(start, end, n)**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.linspace)`:
    This function creates an array with values evenly spaced between the `**start**`
    and `**end**` values. The `**n**` parameter specifies the number of values in
    the array, and the end parameter specifies whether the stop value is included.
    The `**type**` parameter specifies the data type of the array elements.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`[**ndarray::Array::<type, _>::fill(value)**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.fill)`:
    This function fills an array with a specified value. The `**value**` parameter
    specifies the value to fill the array with.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`[**ndarray::Array::<type, _>::eye(shape.f())**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.eye)`:
    This function creates a squared identity matrix with ones on the diagonal and
    zeros elsewhere. The `**n**` parameter specifies the number of rows and columns.
    The `**type**` parameter and `**f**` function have the same meaning as for `**ndarray::Array::zeros**`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`[**ndarray::Array<type, _>::random(shape.f(), distribution_function)**](https://crates.io/crates/ndarray-rand)`:
    This function creates an array with random values with a given distribution. The
    `**shape**` parameter specifies the dimensions of the array.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These initial placeholder functions are highly valuable for generating and initializing
    arrays in `**ndarray**`. They offer a hassle-free approach to creating collections
    of diverse shapes and data types, allowing the user to specify specific or random
    values. Here’s a simple Rust program example to showcase the various placeholders
    available within `**ndarray**`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Multidimensional Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ndarray can build arrays with multiple dimensions, such as 2D matrices and 3D
    matrices. We can effortlessly generate complex data structures using the `[**from_vec**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.from_vec)`
    function along with a vector of vectors, or using the `[**array!**](https://docs.rs/ndarray/latest/ndarray/macro.array.html)`
    macro. For instance, let’s take an example program that showcases how ndarray
    creates arrays across various dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Ndarray Arrays Manipulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will delve into the diverse techniques of altering **ndarray**
    arrays, such as **indexing**, **slicing**, and **reshaping**.
  prefs: []
  type: TYPE_NORMAL
- en: '[Indexing](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#indexing-and-dimension)
    & [Slicing](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#slicing)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/a4a0c6b3556995118bfc2df99560956b.png)'
  prefs: []
  type: TYPE_IMG
- en: Array Slicing (Image by author)
  prefs: []
  type: TYPE_NORMAL
- en: 'Ndarray offers impressive capabilities through **indexing** and **slicing**
    features, enabling us to access and modify individual elements or subarrays within
    an array. Like Python lists, indexing in an **ndarray** involves using index values
    to retrieve specific elements from the array. As a demonstration of this functionality,
    consider accessing the second element of an array with code like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Multidimensional arrays also support indexing and slicing, not just 1D arrays.
    To illustrate this point, consider the code below which retrieves an element from
    a 2D array by specifying its row and column coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Slicing is a powerful technique that enables us to extract a subarray from
    an array. The syntax for slicing resembles indexing, but instead of square brackets,
    it uses periods `**..**` to specify the start and end points of the slice. To
    illustrate this method in action, consider the following code, which generates
    a new array consisting only of its first three elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Reshaping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reshaping is a technique of altering the configuration or arrangement of an
    array while retaining its data. The ndarray library offers a range of powerful
    functions to reshape arrays, such as `[**flatten**](https://docs.rs/ndarray-linalg/latest/ndarray_linalg/convert/fn.flatten.html)`
    and, most notably, `[**reshape**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.reshape)`.
  prefs: []
  type: TYPE_NORMAL
- en: Reshape
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/aee487bbadac24685a13ee9faaed8344.png)'
  prefs: []
  type: TYPE_IMG
- en: Array reshaping (image by author)
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `[**reshape**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.reshape)`
    function, which can only be applied on `[**ArcArray**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#arcarray)`,
    you can modify an array’s shape by defining the number of rows and columns for
    its new configuration. For example, the following code snippet transforms a 1D
    array with four elements into a 2D one consisting of two rows and two columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '**Flatten**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/c2722fbb99175769336a7d26d5090003.png)'
  prefs: []
  type: TYPE_IMG
- en: Array flattening (Image by author)
  prefs: []
  type: TYPE_NORMAL
- en: The `[**ndarray_linalg::convert::flatten**](https://docs.rs/ndarray-linalg/latest/ndarray_linalg/convert/fn.flatten.html)`
    function produces a 1D array containing all the elements from the source array.
    However, it generates a new copy of data instead of mutating the original collection.
    This approach ensures distinctness between both arrays and avoids any potential
    confusion or errors arising from overlapping arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Not only does `**ndarray**` offer the ability to reshape arrays, but it also
    presents a range of other functions for array manipulation. These include transposing,
    and swapping axes, among many others.
  prefs: []
  type: TYPE_NORMAL
- en: Transposing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/01ba4d4b77e0dea0ff774279f8515b96.png)'
  prefs: []
  type: TYPE_IMG
- en: Array transposition (Image by author)
  prefs: []
  type: TYPE_NORMAL
- en: 'By using the`[**t**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.t)`
    function, a new array is generated with its axes transposed. To illustrate this
    point, let’s consider the following code snippet which demonstrates how to transpose
    a 2D array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Swapping Axes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Swapping axes in `**ndarray**` involve exchanging the rows and columns within
    the array. This can be accomplished by utilizing either the `**t**` method, previously
    discussed, or through using ndarray’s `[**swap_axes**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.swap_axes)`
    method. Swapping axes is a crucial aspect when conducting data analysis with multi-dimensional
    arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important to note that an axis refers to each dimension present within
    a multi-dimensional array; for instance, 1D arrays have only one axis, while 2D
    ones possess two — namely rows and columns. Similarly, 3D arrays feature three
    distinct axes: height, width, and depth — starting from zero until additional
    axes are added.'
  prefs: []
  type: TYPE_NORMAL
- en: To perform such swaps using Rust’s `**ndarray**` library via its built-in methods
    like `**swap_axes**`, you need simply provide it with two arguments representing
    which specific pair should be swapped around accordingly based on their respective
    positions along these various dimensional planes!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Linear Algebra
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ndarray, a feature-rich Rust library for numerical calculations and data handling,
    provides exceptional linear algebra support through a separate crate called `[**ndarray-linalg**](https://crates.io/crates/ndarray-linalg)`.
    This section delves into the diverse array of functions that `**ndarray**` offers
    in terms of linear algebra and how they can be effectively utilized to facilitate
    data analysis tasks easily.
  prefs: []
  type: TYPE_NORMAL
- en: '**Matrix Multiplication**: The process of matrix multiplication can be executed
    through the `[**ArrayBase.dot**](https://docs.rs/ndarray/latest/ndarray/struct.ArrayBase.html#method.dot)`
    function, which effectively calculates the dot product between two matrices. To
    illustrate this concept further, we will utilize it to determine the outcome when
    multiplying matrices `**a**` and `**b**` together and then storing that result
    in a new matrix called `**c**`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '**Inversion**: another essential operation when working with matrices that
    can be achieved using `[**ndarray_linalg::solve::Inverse.inv**](https://docs.rs/ndarray-linalg/latest/ndarray_linalg/solve/trait.Inverse.html#tymethod.inv)`
    function that computes the inverse for any given matrix inputted into it! For
    instance, suppose you want to invert Matrix `**array_d2**`, invoke the `**inv**`
    method on its values, and use a `**match**` statement to handle the result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '**Eigen Decomposition**: The `[**use ndarray_linalg::Eig**](https://docs.rs/ndarray-linalg/latest/ndarray_linalg/eig/trait.Eig.html#tymethod.eig)`
    function showcases this by calculating the eigenvalues and eigenvectors of a matrix.
    In our case, we determine these values for Matrix `**array_d2**` and save them
    in matrices `**eigs**` and `**vecs**` correspondingly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '**Singular Value Decomposition (SVD)**: The power of `[**ndarray_linalg::svd::SVD**](https://docs.rs/ndarray-linalg/latest/ndarray_linalg/svd/trait.SVD.html#tymethod.svd)`
    function is showcased as it calculates the left and right singular vectors along
    with the distinct values for a given matrix. To illustrate this, we perform **SVD**
    on matrix `**array_d2**` resulting in `**u**` holding its left singular vectors,
    `**v**` storing its distinct values while containing the right ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '**Matrix Trace**: The `[**ndarray_linalg::trace::Trace**](https://docs.rs/ndarray-linalg/latest/ndarray_linalg/trace/trait.Trace.html#tymethod.trace)`
    function is a powerful function that calculates the sum of diagonal elements in
    any matrix. By applying this method to Matrix `**array_d2**`, we obtain its trace
    result and match its value for further analysis. This simple yet effective technique
    showcases how mathematical functions can enhance data processing capabilities
    with ease and precision.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '**Matrix Determinant**: The calculation of a matrix’s determinant is exemplified
    through the utilization of [**ndarray_linalg::solve::Determinant**](https://docs.rs/ndarray-linalg/latest/ndarray_linalg/solve/trait.Determinant.html#method.det)
    function. Our focus lies on computing the determinant value for Matrix `**array_d2**`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '**Solving Linear Equations**: The `[**ndarray_linalg::solve**](https://docs.rs/ndarray-linalg/latest/ndarray_linalg/solve/index.html)`
    function is utilized to showcase the solution of a set of linear equations in
    the format `**ax = b**`. In this example, we resolve the equation system `**ax=b**`
    by employing `**a**` as an array of constants and then store our results within
    the variable `**x**`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: In this segment of the article, we delved into working with Multidimensional
    Arrays in `**ndarray**`. These arrays are a crucial component utilized across
    various scientific computing fields. The `**array!**` macro function in `**ndarray**`
    enables effortless creation and manipulation of multidimensional arrays, making
    it an invaluable tool for data management.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we have gained knowledge on how to utilize Arithmetic operations
    with `**ndarray**` arrays. These types of arrays are capable of supporting fundamental
    arithmetic functions like adding, subtracting, multiplying, and dividing. It is
    possible to carry out these calculations either for individual elements or the
    entire array simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we delved into the realm of `**ndarray**` and its application in Linear
    Algebra. This dynamic tool offers a vast array of functions that enable seamless
    matrix operations including dot product, transpose, inverse as well as determinant.
    These fundamental mathematical tools are essential for tackling complex problems
    encountered across diverse fields such as finance, engineering, and physics.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Throughout this article, we delved into the fundamental data structures in
    Rust and demonstrated how to execute various arithmetic operations using the **ndarray**
    library. Additionally, it highlights Rust’s potential for linear algebra: a critical
    component of data science.'
  prefs: []
  type: TYPE_NORMAL
- en: This long-running series indicates that Rust is a language with remarkable strength
    and vast capabilities for seamlessly building data science projects. It provides
    exceptional performance while also being relatively simple to handle complex datasets.
    Those looking to pursue a promising career in data science should undoubtedly
    include Rust as one of their top choices.
  prefs: []
  type: TYPE_NORMAL
- en: Closing Note
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/bef1895c3809bb773cf033fd615b0884.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Kelly Sikkema](https://unsplash.com/@kellysikkema?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: As always, I want to take a moment and extend my heartfelt gratitude to everyone
    who has invested their efforts and time in reading this article and following
    along. Showcasing the capabilities of Rust and its ecosystem with you all was
    an absolute delight.
  prefs: []
  type: TYPE_NORMAL
- en: Being passionate about data science, I promise you that I will keep writing
    at least one comprehensive article every week or so on related topics. If staying
    updated with my work interests you, consider connecting with me on various social
    media platforms or reach out directly if anything else needs assistance.
  prefs: []
  type: TYPE_NORMAL
- en: Thank You!
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://github.com/wiseaidev/rust-data-analysis?source=post_page-----ef5ab767212a--------------------------------)
    [## GitHub - wiseaidev/rust-data-analysis: The ultimate data analysis course with
    Rust.'
  prefs: []
  type: TYPE_NORMAL
- en: This repository is a collection of Jupyter notebooks, all powered by a Rust
    kernel. With these notebooks, you'll be…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: github.com](https://github.com/wiseaidev/rust-data-analysis?source=post_page-----ef5ab767212a--------------------------------)  [##
    ndarray - Rust
  prefs: []
  type: TYPE_NORMAL
- en: Expand description The ndarray crate provides an n-dimensional container for
    general elements and for numerics. In…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: docs.rs](https://docs.rs/ndarray/latest/ndarray/?source=post_page-----ef5ab767212a--------------------------------)
    [](https://doc.rust-lang.org/std/index.html?source=post_page-----ef5ab767212a--------------------------------)
    [## std - Rust
  prefs: []
  type: TYPE_NORMAL
- en: The Rust Standard Library is the foundation of portable Rust software, a set
    of minimal and battle-tested shared…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: doc.rust-lang.org](https://doc.rust-lang.org/std/index.html?source=post_page-----ef5ab767212a--------------------------------)  [##
    Rust By Example
  prefs: []
  type: TYPE_NORMAL
- en: Rust is a modern systems programming language focusing on safety, speed, and
    concurrency. It accomplishes these goals…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: doc.rust-lang.org](https://doc.rust-lang.org/rust-by-example/?source=post_page-----ef5ab767212a--------------------------------)  [##
    The Rust Programming Language
  prefs: []
  type: TYPE_NORMAL
- en: by Steve Klabnik and Carol Nichols, with contributions from the Rust Community
    This version of the text assumes you're…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: doc.rust-lang.org](https://doc.rust-lang.org/book/?source=post_page-----ef5ab767212a--------------------------------)
  prefs: []
  type: TYPE_NORMAL
