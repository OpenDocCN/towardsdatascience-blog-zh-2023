- en: 'The Underrated Gems Pt.1: 8 Pandas Methods That Will Make You a Pro'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: åŸæ–‡ï¼š[https://towardsdatascience.com/the-underrated-gems-pt-1-8-pandas-methods-that-will-make-you-a-pro-b1437a19ca3c?source=collection_archive---------0-----------------------#2023-07-17](https://towardsdatascience.com/the-underrated-gems-pt-1-8-pandas-methods-that-will-make-you-a-pro-b1437a19ca3c?source=collection_archive---------0-----------------------#2023-07-17)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Underrated, underappreciated, and underexplored
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@andreas030503?source=post_page-----b1437a19ca3c--------------------------------)[![Andreas
    Lukita](../Images/8660ca1fea5da34ce3475281c1f52152.png)](https://medium.com/@andreas030503?source=post_page-----b1437a19ca3c--------------------------------)[](https://towardsdatascience.com/?source=post_page-----b1437a19ca3c--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----b1437a19ca3c--------------------------------)
    [Andreas Lukita](https://medium.com/@andreas030503?source=post_page-----b1437a19ca3c--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Â·
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F955ef38ea7b&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fthe-underrated-gems-pt-1-8-pandas-methods-that-will-make-you-a-pro-b1437a19ca3c&user=Andreas+Lukita&userId=955ef38ea7b&source=post_page-955ef38ea7b----b1437a19ca3c---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----b1437a19ca3c--------------------------------)
    Â·10 min readÂ·Jul 17, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fb1437a19ca3c&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fthe-underrated-gems-pt-1-8-pandas-methods-that-will-make-you-a-pro-b1437a19ca3c&user=Andreas+Lukita&userId=955ef38ea7b&source=-----b1437a19ca3c---------------------clap_footer-----------)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fb1437a19ca3c&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fthe-underrated-gems-pt-1-8-pandas-methods-that-will-make-you-a-pro-b1437a19ca3c&source=-----b1437a19ca3c---------------------bookmark_footer-----------)![](../Images/dfa5d2a3776475bd5e3957104b82b7ae.png)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Photo by [Roman Kraft](https://unsplash.com/@iamromankraft?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: â€œAmidst the noise of the crowd, itâ€™s the softly spoken words that hold the hidden
    wisdom ğŸ’â€
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Forget ChatGPT for a while. For some of us, we get tired by constantly googling
    for solution every time we want to perform a simple Pandas operation. There seems
    to be numerous ways of doing the same thing, which is which? Having lots of possible
    solution to choose from is of course great, but with it also comes inconsistency
    and confusion in understanding what the line of code is supposed to do.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: æš‚æ—¶å¿˜è®°ChatGPTã€‚å¯¹æˆ‘ä»¬ä¸­çš„ä¸€äº›äººæ¥è¯´ï¼Œæˆ‘ä»¬ä¼šå› ä¸ºæ¯æ¬¡æƒ³æ‰§è¡Œç®€å•çš„Pandasæ“ä½œæ—¶éƒ½è¦ä¸æ–­åœ°è°·æ­Œæœç´¢è§£å†³æ–¹æ¡ˆè€Œæ„Ÿåˆ°ç–²æƒ«ã€‚ä¼¼ä¹æœ‰æ— æ•°ç§æ–¹æ³•æ¥åšåŒä¸€ä»¶äº‹ï¼Œé‚£ä¹ˆç©¶ç«Ÿå“ªä¸€ç§æ‰æ˜¯æœ€ä½³é€‰æ‹©ï¼Ÿè™½ç„¶æœ‰å¾ˆå¤šå¯èƒ½çš„è§£å†³æ–¹æ¡ˆç¡®å®å¾ˆå¥½ï¼Œä½†ä¹Ÿå¸¦æ¥äº†ä¸ä¸€è‡´å’Œå¯¹ä»£ç åŠŸèƒ½çš„å›°æƒ‘ã€‚
- en: Thereâ€™s 1000 possible routes to reach Rome, maybe even more. The question is,
    do you travel the hidden shortcut or do you take the complicated route?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°è¾¾ç½—é©¬æœ‰1000æ¡å¯èƒ½çš„è·¯çº¿ï¼Œå¯èƒ½ç”šè‡³æ›´å¤šã€‚é—®é¢˜æ˜¯ï¼Œä½ é€‰æ‹©éšè—çš„å°è·¯è¿˜æ˜¯å¤æ‚çš„è·¯çº¿ï¼Ÿ
- en: '![](../Images/fae6c5a44fa88fad591aaa9d53e554e8.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/fae6c5a44fa88fad591aaa9d53e554e8.png)'
- en: Image by Author
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡ç”±ä½œè€…æä¾›
- en: Here is the takeaway of this post. Iâ€™ll walk you through how to put these methods
    to practical use by working through the [bike sharing dataset from UCI Machine
    Learning](https://doi.org/10.24432/C5W894)[Â¹](#aba8). By adopting these methods,
    youâ€™ll not only streamline your data manipulation code, but also gain a deeper
    understanding of the code you write. Letâ€™s get started by importing the dataset
    and can a quick view on the DataFrame!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯æœ¬æ–‡çš„è¦ç‚¹ã€‚æˆ‘å°†å¸¦ä½ äº†è§£å¦‚ä½•é€šè¿‡å¤„ç†æ¥è‡ª[UCIæœºå™¨å­¦ä¹ çš„è‡ªè¡Œè½¦å…±äº«æ•°æ®é›†](https://doi.org/10.24432/C5W894)[Â¹](#aba8)æ¥å°†è¿™äº›æ–¹æ³•ä»˜è¯¸å®è·µã€‚é€šè¿‡é‡‡ç”¨è¿™äº›æ–¹æ³•ï¼Œä½ ä¸ä»…å¯ä»¥ç®€åŒ–æ•°æ®å¤„ç†ä»£ç ï¼Œè¿˜èƒ½æ›´æ·±å…¥åœ°ç†è§£ä½ ç¼–å†™çš„ä»£ç ã€‚è®©æˆ‘ä»¬å¼€å§‹å¯¼å…¥æ•°æ®é›†ï¼Œå¹¶å¿«é€ŸæŸ¥çœ‹DataFrameï¼
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![](../Images/eb8d9b78b58f0bee83d63227051d66d8.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/eb8d9b78b58f0bee83d63227051d66d8.png)'
- en: Image by Author
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡ç”±ä½œè€…æä¾›
- en: '**Table of Contents**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**ç›®å½•**'
- en: '[Method #1:](#b318) `[**.assign()**](#b318)`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[æ–¹æ³• #1:](#b318) `[**.assign()**](#b318)`'
- en: '[Method #2:](#987c) `[**.groupby()**](#987c)`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[æ–¹æ³• #2:](#987c) `[**.groupby()**](#987c)`'
- en: '[Method #3:](#e599) `[**.agg()**](#e599)`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[æ–¹æ³• #3:](#e599) `[**.agg()**](#e599)`'
- en: '[Method #4:](#399c) `[**.transform()**](#399c)`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[æ–¹æ³• #4:](#399c) `[**.transform()**](#399c)`'
- en: '[Method #5:](#5c03) `[**.pivot_table()**](#5c03)`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[æ–¹æ³• #5:](#5c03) `[**.pivot_table()**](#5c03)`'
- en: '[Method #6:](#0c9c) `[**.resample()**](#0c9c)`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[æ–¹æ³• #6:](#0c9c) `[**.resample()**](#0c9c)`'
- en: '[Method #7:](#8974) `[**.unstack()**](#8974)`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[æ–¹æ³• #7:](#8974) `[**.unstack()**](#8974)`'
- en: '[Method #8:](#6079) `[**.pipe()**](#6079)`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[æ–¹æ³• #8:](#6079) `[**.pipe()**](#6079)`'
- en: 'â˜•ï¸ Method #1: .assign()'
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'â˜•ï¸ æ–¹æ³• #1: .assign()'
- en: Forget about using operations such as `**df["new_col"] =**` and `**df.new_col
    =**` to create new columns. Here is why you should be using the `**.assign()**`
    method â€” it returns you a DataFrame object, which allows you to continue your
    chaining operation to further manipulate your DataFrame. Unlike the `**.assign()**`
    method, the two infamous operation above return you a `None` which means you cannot
    possibly chain your operation further.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: å¿˜æ‰ä½¿ç”¨`**df["new_col"] =**`å’Œ`**df.new_col =**`è¿™ç§æ“ä½œæ¥åˆ›å»ºæ–°åˆ—ã€‚è¿™é‡Œæ˜¯ä½ åº”è¯¥ä½¿ç”¨`**.assign()**`æ–¹æ³•çš„åŸå› â€”â€”å®ƒè¿”å›ä¸€ä¸ªDataFrameå¯¹è±¡ï¼Œå…è®¸ä½ ç»§ç»­é“¾å¼æ“ä½œä»¥è¿›ä¸€æ­¥å¤„ç†DataFrameã€‚ä¸`**.assign()**`æ–¹æ³•ä¸åŒï¼Œä¸Šè¿°ä¸¤ç§è‡­åæ˜­è‘—çš„æ“ä½œä¼šè¿”å›`None`ï¼Œè¿™æ„å‘³ç€ä½ æ— æ³•è¿›ä¸€æ­¥é“¾å¼æ“ä½œã€‚
- en: If you are not convinced, then let me bring back the old nemesis â€” `**SettingWithCopyWarning**`.
    Pretty sure each of us has bumped into this one at some point in time.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ ä¸ä¿¡ï¼Œé‚£ä¹ˆè®©æˆ‘é‡æ–°æèµ·æ—§çš„æ•Œäººâ€”â€”`**SettingWithCopyWarning**`ã€‚ç›¸ä¿¡æˆ‘ä»¬æ¯ä¸ªäººåœ¨æŸä¸ªæ—¶åˆ»éƒ½é‡åˆ°è¿‡è¿™ä¸ªé—®é¢˜ã€‚
- en: '![](../Images/f972812fa73304ae581315e1660cd13a.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f972812fa73304ae581315e1660cd13a.png)'
- en: Image by Author
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡ç”±ä½œè€…æä¾›
- en: Enough of the warning, I want to unsee ugly red boxes in my notebook!
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è­¦å‘Šå¤Ÿäº†ï¼Œæˆ‘ä¸æƒ³åœ¨æˆ‘çš„ç¬”è®°æœ¬ä¸­å†çœ‹åˆ°ä¸‘é™‹çš„çº¢è‰²æ¡†æ¡†ï¼
- en: Using `**.assign()**`, let us add a few new columns such as `**ratio_casual_registered**`,
    `**avg_temp**`, and `**ratio_squared**`
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨`**.assign()**`ï¼Œè®©æˆ‘ä»¬æ·»åŠ ä¸€äº›æ–°åˆ—ï¼Œå¦‚`**ratio_casual_registered**`ã€`**avg_temp**`å’Œ`**ratio_squared**`
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In short, hereâ€™s what the method above does:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ç®€è€Œè¨€ä¹‹ï¼Œä¸Šè¿°æ–¹æ³•çš„ä½œç”¨å¦‚ä¸‹ï¼š
- en: We can create as many new columns as we want using the `**.assign()**` method,
    separated by the delimiter comma.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥ä½¿ç”¨`**.assign()**`æ–¹æ³•åˆ›å»ºä»»æ„æ•°é‡çš„æ–°åˆ—ï¼Œç”¨é€—å·åˆ†éš”ã€‚
- en: The lambda function when creating the column `**ratio_squared**` serves to get
    access to the most recent DataFrame after we added the column `**ratio_casual_registered**`.
    Say, we do not use a lambda function to get access to the most recent DataFrame
    `**df_**`, but instead continue with `**bike.ratio_casual_registered.pow(2)**`,
    we would get an error as the original DataFrame does not have the column `**ratio_casual_registered**`,
    even after adding it in the `**.assign()**` method before creating `**ratio_squared**`.
    If you canâ€™t wrap your head around this concept to decide whether or not to use
    lambda function, my suggestion is just use one!
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bonus! I leave some not-so-common way to perform arithmetic operations using
    methods.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'â˜•ï¸ Method #2: .groupby()'
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, the `**.groupby()**` method is not uncommonly used, but they are necessary
    to get us started before we delve deeper into the next methods. One thing that
    often goes unnoticed and left unspoken of is that the the `**.groupby()**` method
    has a lazy nature. By that, it means that the method is lazily evaluated. In other
    words, it does not evaluate right away, that is why you often see `**<pandas.core.groupby.generic.DataFrameGroupBy
    object at 0x14fdc3610>**` right after calling the method `**.groupby()**`
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: From Pandas DataFrame [documentation](https://pandas.pydata.org/docs/reference/frame.html)[Â²](#f249),
    the value to feed in the parameter `**by**` could be a ***mapping, function, label,
    pd.Grouper or list of such.*** Nonetheless, the most common one you probably encounter
    is to group by columns names (list of Series name separated by comma). After the
    `**.groupby()**` operation, we could perform operation such as `**.mean()**`,
    `**.median()**`, or applying custom function using `**.apply()**`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: The value of the specified columns that we feed into the `**by**` parameters
    in the `**.groupby()**` method would become the index of the result. If we specify
    grouping more than 1 column, then we will obtain a MultiIndex.
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we grouped our DataFrame by the column `**season**`, and `**weathersit**`.
    Then, we calculate the mean value and subset only the column `**atemp**`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b9321d008606497cf39b9bdcda719e00.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'â˜•ï¸ Method #3: .agg()'
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are meticulous enough to dig the Pandas [documentation](https://pandas.pydata.org/docs/reference/frame.html)[Â²](#f249),
    you might encounter both methods `**.agg()**` and `**.aggregate()**`. You might
    be wondering what is the difference and when to use which? Save your time! They
    are the same, `**.agg()**` is merely an alias for `**.aggregate()**`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '`**.agg()**` has a parameter `**func**`, which literally takes in a function,
    string function name, or list of functions. By the way, you can aggregate different
    functions over the columns as well! Letâ€™s continue our example above!'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![](../Images/3a7641b468ffb53f978a9bd105544194.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'â˜•ï¸ Method #4: .transform()'
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With `**.agg()**`, the result we obtain is of reduced dimensionality as compared
    to the initial dataset. In simple terms, your data dimension shrinks with lesser
    number of rows and columns, containing the aggregate information. If what you
    want is to summarize the grouped data and obtain aggregated values, then `**.groupby()**`
    is the solution.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: With `**.transform()**`, we also start with the intention of doing aggregation
    of information. However, instead of creating a summary of information, we want
    the output to have the same shape as the original DataFrame, without shrinking
    the size of the original DataFrame.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Those of you who have exposure to database systems like SQL may find the idea
    behind `**.transform()**` similar to that of Window Function. Letâ€™s see how `**.transform()**`
    works on the above example!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![](../Images/57cfdf8e60580a2e42ea2ac46196f4d4.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: As seen above, we created a new column with column nameâ€”`**mean_atemp_season**`
    where we fill in the column with the aggregate (mean) of the `**atemp**` column.
    Thus, whenever `**season**` is 1, then we have the same value for `**mean_atemp_season**`.
    Notice the important observation here is that we retain the original dimension
    of the dataset plus one additional column!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'â˜•ï¸ Method #5: .pivot_table()'
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hereâ€™s a bonus for those obsessed with Microsoft Excel. You might be tempted
    to use `**.pivot_table()**` to create summary table. Well of course, this method
    works too! But hereâ€™s a two cent, `**.groupby()**` is more versatile and used
    for a broader range of operations beyond just reshaping, such as filtering, transformation,
    or applying group-specific calculations.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Hereâ€™s how to use `**.pivot_table()**` in short. You specify the column(s) you
    want to aggregate in the argument `**values**`. Next, specify the **index** of
    the summary table you want to create using a subset of the original DataFrame.
    This can be more than one column and the summary table will be DataFrame of MultiIndex.
    Next, specify the **columns** of the summary table you want to create using a
    subset of the original DataFrame that has not been selected as the index. Last
    but not least, donâ€™t forget to specify the `**aggfunc**`! Letâ€™s take a quick look!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](../Images/b2cc556fc524085340ac327e66b94545.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'â˜•ï¸ Method #6: .resample()'
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Roughly speaking, the method `**.resample()**` can be viewed as grouping and
    aggregation specifically for time-series data, where
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: The index of the DataFrame or Series is a datetime-like object.
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This allows you to group and aggregate data based on different time frequencies,
    such as hourly, daily, weekly, monthly, etc. More generally, `**.resample()**`
    can take in **DateOffset, Timedelta or str**as the rule to perform resampling.
    Letâ€™s apply this to our previous example.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In short, what we do above is drop the column `**instant**`, overwrite the `**dteday**`
    column with the `**dteday**` column being converted from `object` type to `**datetime64[ns]**`
    type, and finally setting this `**datetime64[ns]**` column as the index of the
    DataFrame.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5a33370ebfd03d27d90be81dedbadff8.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](../Images/1a857d820fb1f9834a0da75717f63f95.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Here, we obtain a descriptive statistics summary (mean) of the feature `**temp**`
    with monthy frequency. Try and play with the `**.resample()**` method using differency
    frequency such as `**Q**`, `**2M**`, `**A**` and so on,
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'â˜•ï¸ Method #7: .unstack()'
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are nearing the end! Let me show you why `**.unstack()**` is both powerful
    and useful. But before that, letâ€™s get back to one of the example above where
    we want to find the mean temperature across different season and weather situation
    by using `**.groupby()**` and `**.agg()**`
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![](../Images/6be4039549c302e00b1da416acef33cb.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Now, letâ€™s visualise this using a line chart produced minimally by chaining
    the methods `**.plot**` and `**.line()**` to the code above. Behind the scene,
    Pandas leverages on Matplotlib plotting backend to do the plotting task. This
    gives the following result, which none of us wanted since the x-axis of the plot
    is grouped by the MultiIndex, making it more difficult to interpret and less meaningful.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3654c1d2def7e557a794dec007f3016b.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Compared the plot above and below after we introduce the `**.unstack()**` method.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![](../Images/de2067fddba9d0e6526b58bb11ac7515.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: In short, what the method `**.unstack()**` does is to unstack the inner most
    index of the MultiIndex DataFrame, which in this case, is `**weathersit**`. This
    so-called un-stacked index becomes the columns of the new DataFrame, which allows
    our plotting of line plot to give more meaningful outcome for comparison purposes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6892843a34315addb39ca843d2dbd08c.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: You can also unstack the outer-most index instead of the inner-most index of
    the DataFrame, by specifying the argument `**level=0**` as part of the `**.unstack()**`
    method. Letâ€™s see how we can achieve this.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![](../Images/fcaeb87f0b7cd880bda70f0a457b75a0.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3c938f38c42c3371f16f5bb6040b6f3b.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
- en: Image by Author
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'â˜•ï¸ Method #8: .pipe()'
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From my observation, you almost never see common folks implement this method
    in their Pandas code when you search online. For one reason, `**.pipe()**` somehow
    has its own mysterious unexplainable aura that makes it not friendly to beginners
    and intermediates-alike. When you go to Pandas [documentation](https://pandas.pydata.org/docs/reference/frame.html)[Â²](#f249),
    the short explanation you will find is ***â€œApply chainable functions that expect
    Series or DataFramesâ€***. I think this explanation is a little confusing and not
    really helpful, provided if you have never work with chaining before.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: In short, what `**.pipe()**` offers you is the ability to continue your method
    chaining technique using a function, in the event where you canâ€™t manage to find
    a straightforward solution to perform an operation to return a DataFrame.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ç®€è€Œè¨€ä¹‹ï¼Œ`**.pipe()**`ä¸ºæ‚¨æä¾›çš„æ˜¯ä½¿ç”¨å‡½æ•°ç»§ç»­æ–¹æ³•é“¾æŠ€æœ¯çš„èƒ½åŠ›ï¼Œåœ¨æ‚¨æ— æ³•æ‰¾åˆ°ç›´æ¥è§£å†³æ–¹æ¡ˆæ‰§è¡Œæ“ä½œè¿”å›DataFrameçš„æƒ…å†µä¸‹ã€‚
- en: The method `**.pipe()**` takes in a function, by that, you can define a method
    outside the chain and then refer to the method as an argument to the `**.pipe()**`
    method.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: æ–¹æ³•`**.pipe()**`æ¥å—ä¸€ä¸ªå‡½æ•°ä½œä¸ºå‚æ•°ï¼Œé€šè¿‡è¿™ä¸ªå‡½æ•°å¯ä»¥å®šä¹‰ä¸€ä¸ªé“¾å¤–æ–¹æ³•ï¼Œç„¶åå°†è¯¥æ–¹æ³•ä½œä¸º`**.pipe()**`æ–¹æ³•çš„å‚æ•°å¼•ç”¨ã€‚
- en: With `.pipe()`, you can pass a DataFrame or Series as the first argument to
    a custom function, and the function will be applied to the object being passed,
    followed by any additional arguments specified afterwards.
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½¿ç”¨`.pipe()`ï¼Œæ‚¨å¯ä»¥å°†DataFrameæˆ–Seriesä½œä¸ºè‡ªå®šä¹‰å‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°ä¼ é€’ï¼Œå¹¶ä¸”è¯¥å‡½æ•°å°†åº”ç”¨äºä¼ é€’çš„å¯¹è±¡ï¼Œéšåæ˜¯æŒ‡å®šçš„ä»»ä½•å…¶ä»–å‚æ•°ã€‚
- en: Most of the time, you will see a one-liner lambda function inside the `**.pipe()**`
    method for the purpose of convenience (i.e. get access to the most recent DataFrame
    after some modification steps in the chaining process).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œæ‚¨ä¼šçœ‹åˆ°`**.pipe()**`æ–¹æ³•ä¸­çš„ä¸€è¡Œlambdaå‡½æ•°ï¼Œä»¥æ–¹ä¾¿ä½¿ç”¨ï¼ˆä¾‹å¦‚ï¼Œåœ¨é“¾å¤„ç†è¿‡ç¨‹ä¸­çš„æŸäº›ä¿®æ”¹æ­¥éª¤åè·å–æœ€æ–°DataFrameï¼‰ã€‚
- en: 'Let me illustrate using a simplified example. Letâ€™s say we want to get insights
    on the following question: ***â€œFor the year 2012, what is the proportion of working
    day per season, relative to the total working day of that year?â€***'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ç”¨ä¸€ä¸ªç®€åŒ–çš„ä¾‹å­æ¥è¯´æ˜ã€‚å‡è®¾æˆ‘ä»¬æƒ³è¦äº†è§£ä»¥ä¸‹é—®é¢˜ï¼š***â€œå¯¹äº2012å¹´ï¼Œæ¯ä¸ªå­£èŠ‚ç›¸å¯¹äºè¯¥å¹´æ€»å·¥ä½œæ—¥çš„å·¥ä½œæ—¥æ¯”ä¾‹æ˜¯å¤šå°‘ï¼Ÿâ€***
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we use `**.pipe()**` to inject function into our chaining method. Since
    after performing `**.agg(sum)**`, we cannot just continue chaining with `**.div()**`,
    the following code will not work since we lost access to the latest state of the
    DataFrame after some modification through the chaining process.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨`**.pipe()**`å°†å‡½æ•°æ³¨å…¥åˆ°æˆ‘ä»¬çš„é“¾å¼æ–¹æ³•ä¸­ã€‚ç”±äºæ‰§è¡Œäº†`**.agg(sum)**`ä¹‹åï¼Œæˆ‘ä»¬æ— æ³•ç»§ç»­ä½¿ç”¨`**.div()**`è¿›è¡Œé“¾å¼å¤„ç†ï¼Œå› æ­¤ä»¥ä¸‹ä»£ç å°†æ— æ³•å·¥ä½œï¼Œå› ä¸ºæˆ‘ä»¬åœ¨é“¾å¼å¤„ç†è¿‡ç¨‹ä¸­å¤±å»äº†å¯¹DataFrameçš„æœ€æ–°çŠ¶æ€çš„è®¿é—®ã€‚
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Tips: If you canâ€™t find a way to continue chaining your methods, try think
    of how `.pipe()` can help! Most of the time, it will!'
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æç¤ºï¼šå¦‚æœæ‰¾ä¸åˆ°ç»§ç»­é“¾æ¥æ–¹æ³•çš„æ–¹å¼ï¼Œè¯·è€ƒè™‘å¦‚ä½•ä½¿ç”¨`.pipe()`ï¼å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œå®ƒä¼šæœ‰æ‰€å¸®åŠ©ï¼
- en: Afterword
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç»“è¯­
- en: That wraps up the first part of The Underrated Gems ğŸ’! They are all methods
    that I didnâ€™t use as much before, perhaps due to my bad habit of brute-forcing
    my code with the thinking that â€œAs long as it works, itâ€™s good enough!â€ Unfortunately,
    itâ€™s not!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°±æ˜¯ä½ä¼°çš„å®çŸ³ğŸ’ç¬¬ä¸€éƒ¨åˆ†çš„å…¨éƒ¨å†…å®¹ï¼è¿™äº›éƒ½æ˜¯æˆ‘ä»¥å‰æ²¡æœ‰ç»å¸¸ä½¿ç”¨çš„æ–¹æ³•ï¼Œä¹Ÿè®¸æ˜¯å› ä¸ºæˆ‘çš„åä¹ æƒ¯â€”â€”ç”¨â€œåªè¦èƒ½ç”¨ï¼Œå°±å¤Ÿå¥½ï¼â€çš„æ€ç»´å¼ºè¡Œè§£å†³ä»£ç é—®é¢˜ã€‚ä¸å¹¸çš„æ˜¯ï¼Œè¿™æ ·åšæ˜¯ä¸å¤Ÿå¥½çš„ï¼
- en: Only after I spend time to learn how to use them properly, they prove to be
    lifesaving, to say the least! I also want to thank Matt Harrison and his book
    [Effective Pandas](https://store.metasnake.com/effective-pandas-book)[Â³](#deae)
    which completely changes the way I write my Pandas code. Now, I can say my code
    is more concise, readable, and just makes more sense.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: åªæœ‰åœ¨æˆ‘èŠ±æ—¶é—´å­¦ä¹ å¦‚ä½•æ­£ç¡®ä½¿ç”¨å®ƒä»¬ä¹‹åï¼Œå®ƒä»¬æ‰è¢«è¯æ˜æ˜¯æ•‘å‘½ç¨»è‰ï¼Œå¯ä»¥è¿™ä¹ˆè¯´ï¼æˆ‘è¿˜è¦æ„Ÿè°¢Matt Harrisonå’Œä»–çš„ä¹¦[ã€Šé«˜æ•ˆPandasã€‹](https://store.metasnake.com/effective-pandas-book)[Â³](#deae)ï¼Œè¿™æœ¬ä¹¦å½»åº•æ”¹å˜äº†æˆ‘ç¼–å†™Pandasä»£ç çš„æ–¹å¼ã€‚ç°åœ¨ï¼Œæˆ‘å¯ä»¥è¯´æˆ‘çš„ä»£ç æ›´ç®€æ´ã€æ›´å¯è¯»ï¼Œè€Œä¸”æ›´æœ‰æ„ä¹‰ã€‚
- en: In Part 2 of The Underrated Gems, we are going to touch on another eight lesser-known
    Pandas methods such as `**.explode()**`, `**.melt()**`, and `**.expanding()**`!
    You probably wonâ€™t use them as much but they certainly come in handy at the moment
    you need them.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä½ä¼°çš„å®çŸ³ç¬¬äºŒéƒ¨åˆ†ä¸­ï¼Œæˆ‘ä»¬å°†ä»‹ç»å…¶ä»–å…«ä¸ªè¾ƒå°‘ä¸ºäººçŸ¥çš„Pandasæ–¹æ³•ï¼Œä¾‹å¦‚`**.explode()**`ã€`**.melt()**`å’Œ`**.expanding()**`ï¼æ‚¨å¯èƒ½ä¸ä¼šç»å¸¸ä½¿ç”¨å®ƒä»¬ï¼Œä½†åœ¨éœ€è¦å®ƒä»¬çš„æ—¶å€™å®ƒä»¬è‚¯å®šå¾ˆæ–¹ä¾¿ã€‚
- en: If you pick up something useful from this article, do consider giving me a [***Follow***](https://medium.com/@andreas030503)
    on Medium. Easy, 1 article a week to keep yourself updated and stay ahead of the
    curve!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ ä»æœ¬æ–‡ä¸­è·å¾—äº†ä¸€äº›æœ‰ç”¨çš„ä¸œè¥¿ï¼Œè¯·è€ƒè™‘åœ¨Mediumä¸Šç»™æˆ‘[***å…³æ³¨***](https://medium.com/@andreas030503)ã€‚æ¯å‘¨ä¸€ç¯‡æ–‡ç« ï¼Œè½»æ¾è·Ÿä¸Šæ—¶ä»£æ½®æµï¼
- en: Connect With Me!
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: è”ç³»æˆ‘ï¼
- en: '[*LinkedIn*](https://www.linkedin.com/in/andreaslukita7/)ğŸ‘”'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*LinkedIn*](https://www.linkedin.com/in/andreaslukita7/)ğŸ‘”'
- en: '[*Twitter*](https://twitter.com/andreaslukita7)ğŸ–Š'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*Twitter*](https://twitter.com/andreaslukita7)ğŸ–Š'
- en: References
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å‚è€ƒèµ„æ–™
- en: Fanaee-T, Hadi. (2013). Bike Sharing Dataset. UCI Machine Learning Repository.
    [https://doi.org/10.24432/C5W894](https://doi.org/10.24432/C5W894).
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Fanaee-Tï¼ŒHadiã€‚ (2013)ã€‚è‡ªè¡Œè½¦å…±äº«æ•°æ®é›†ã€‚UCIæœºå™¨å­¦ä¹ åº“ã€‚[https://doi.org/10.24432/C5W894](https://doi.org/10.24432/C5W894)ã€‚
- en: 'Pandas Documentation: [https://pandas.pydata.org/docs/reference/frame.html](https://pandas.pydata.org/docs/reference/frame.html)'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Pandas æ–‡æ¡£: [https://pandas.pydata.org/docs/reference/frame.html](https://pandas.pydata.org/docs/reference/frame.html)'
- en: 'Effective Pandas by Matt Harrison: [https://store.metasnake.com/effective-pandas-book](https://store.metasnake.com/effective-pandas-book)'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Matt Harrisonçš„ã€ŠEffective Pandasã€‹: [https://store.metasnake.com/effective-pandas-book](https://store.metasnake.com/effective-pandas-book)'
