- en: Nine Rules for Running Rust on the Web and on Embedded
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在网络和嵌入式系统上运行 Rust 的九条规则
- en: 原文：[https://towardsdatascience.com/nine-rules-for-running-rust-on-the-web-and-on-embedded-94462ef249a2?source=collection_archive---------3-----------------------#2023-07-05](https://towardsdatascience.com/nine-rules-for-running-rust-on-the-web-and-on-embedded-94462ef249a2?source=collection_archive---------3-----------------------#2023-07-05)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/nine-rules-for-running-rust-on-the-web-and-on-embedded-94462ef249a2?source=collection_archive---------3-----------------------#2023-07-05](https://towardsdatascience.com/nine-rules-for-running-rust-on-the-web-and-on-embedded-94462ef249a2?source=collection_archive---------3-----------------------#2023-07-05)
- en: Practical Lessons from Porting `range-set-blaze` to no_std and WASM
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从将 `range-set-blaze` 移植到 no_std 和 WASM 的实际经验
- en: '[](https://medium.com/@carlmkadie?source=post_page-----94462ef249a2--------------------------------)[![Carl
    M. Kadie](../Images/9dbe27c76e9567136e5a7dc587f1fb15.png)](https://medium.com/@carlmkadie?source=post_page-----94462ef249a2--------------------------------)[](https://towardsdatascience.com/?source=post_page-----94462ef249a2--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----94462ef249a2--------------------------------)
    [Carl M. Kadie](https://medium.com/@carlmkadie?source=post_page-----94462ef249a2--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@carlmkadie?source=post_page-----94462ef249a2--------------------------------)[![Carl
    M. Kadie](../Images/9dbe27c76e9567136e5a7dc587f1fb15.png)](https://medium.com/@carlmkadie?source=post_page-----94462ef249a2--------------------------------)[](https://towardsdatascience.com/?source=post_page-----94462ef249a2--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----94462ef249a2--------------------------------)
    [Carl M. Kadie](https://medium.com/@carlmkadie?source=post_page-----94462ef249a2--------------------------------)'
- en: ·
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fa5e87027005f&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnine-rules-for-running-rust-on-the-web-and-on-embedded-94462ef249a2&user=Carl+M.+Kadie&userId=a5e87027005f&source=post_page-a5e87027005f----94462ef249a2---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----94462ef249a2--------------------------------)
    ·17 min read·Jul 5, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F94462ef249a2&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnine-rules-for-running-rust-on-the-web-and-on-embedded-94462ef249a2&user=Carl+M.+Kadie&userId=a5e87027005f&source=-----94462ef249a2---------------------clap_footer-----------)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[关注](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fa5e87027005f&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnine-rules-for-running-rust-on-the-web-and-on-embedded-94462ef249a2&user=Carl+M.+Kadie&userId=a5e87027005f&source=post_page-a5e87027005f----94462ef249a2---------------------post_header-----------)
    发表在 [Towards Data Science](https://towardsdatascience.com/?source=post_page-----94462ef249a2--------------------------------)
    ·17 分钟阅读·2023年7月5日[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F94462ef249a2&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnine-rules-for-running-rust-on-the-web-and-on-embedded-94462ef249a2&user=Carl+M.+Kadie&userId=a5e87027005f&source=-----94462ef249a2---------------------clap_footer-----------)'
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F94462ef249a2&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnine-rules-for-running-rust-on-the-web-and-on-embedded-94462ef249a2&source=-----94462ef249a2---------------------bookmark_footer-----------)![](../Images/59da1d54d5821d92e578ab92da9a5abb.png)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F94462ef249a2&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fnine-rules-for-running-rust-on-the-web-and-on-embedded-94462ef249a2&source=-----94462ef249a2---------------------bookmark_footer-----------)![](../Images/59da1d54d5821d92e578ab92da9a5abb.png)'
- en: 'Crab running on a microcontroller — Source: [https://openai.com/dall-e-2/](https://openai.com/dall-e-2/)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 微控制器上的螃蟹 — 来源：[https://openai.com/dall-e-2/](https://openai.com/dall-e-2/)
- en: I recommend Rust when you want the speed of C++ and the memory-safety of Python.
    On top of that, with Rust you can build on more than 100,000 [software libraries](https://crates.io/).
    In addition, Rust offers the potential of running your code not just on a conventional
    computer, but also inside a web page or even on a robot.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我推荐使用 Rust，当你需要 C++ 的速度和 Python 的内存安全时。此外，使用 Rust 你可以构建在超过 100,000 个 [软件库](https://crates.io/)
    上。除此之外，Rust 还提供了将你的代码运行在不仅是传统计算机上，还有网页甚至机器人上的潜力。
- en: Running “almost everywhere”, however, comes with complications. This article
    is for Rust programmers who want to mitigate these complications. (It may also
    be of interest to those who want to see Rust’s “run almost everywhere” story.)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，“几乎所有地方”运行会带来复杂性。本文是为那些希望减轻这些复杂性的Rust程序员准备的。（它也可能对那些想了解Rust的“几乎所有地方”运行故事的人感兴趣。）
- en: 'First complication: Web pages and the embedded processors of robots don’t support
    general file IO. If your project is mostly about reading and writing files, it’s
    not a good candidate for running on a robot, other embedded processor, or a web
    page.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个复杂性：网页和机器人的嵌入式处理器不支持通用文件IO。如果你的项目主要涉及读写文件，它不适合在机器人、其他嵌入式处理器或网页上运行。
- en: 'Second complication: Porting code to run almost everywhere requires many steps
    and choices. Navigating these choices can be time consuming. Missing a step can
    lead to failure. This article aims to reduce this second complication by offering
    these nine rules, which we’ll later explore in detail:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个复杂性：将代码移植到几乎所有地方需要多个步骤和选择。导航这些选择可能会耗时。遗漏一步可能导致失败。本文旨在通过提供这九条规则来减少第二个复杂性，稍后我们将详细探讨这些规则：
- en: Mark your lib.rs or main.rs as no_std.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的lib.rs或main.rs标记为no_std。
- en: Use the built-in “crate alloc” if you can.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果可能的话，使用内置的“crate alloc”。
- en: Switch to “no std” dependences.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到“no std”依赖项。
- en: Create std and alloc features and make your std-only functions optional.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建std和alloc功能，并将你的std-only函数设为可选。
- en: Build your project for WASM. Use cargo tree to get it working.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为WASM构建你的项目。使用cargo tree来使其正常工作。
- en: Create WASM tests and a WASM demo.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建WASM测试和WASM演示。
- en: '[Optional] Build your project for embedded.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[可选] 为嵌入式设备构建你的项目。'
- en: '[Optional] Create a single embedded test and an embedded demo.'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[可选] 创建一个嵌入式测试和嵌入式演示。'
- en: Finish up with CI testing, Cargo.toml metadata, and an updated README.md.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成CI测试、Cargo.toml元数据和更新的README.md。
- en: Following these rules will help you create very fast and memory-safe code that
    runs everywhere from a PC, to a smart phone web page ([demo](https://carlkcarlk.github.io/range-set-blaze/wasm-demo/)),
    to a robot. The code can be very tiny and can leverage the huge Rust crate library.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这些规则将帮助你创建运行在从PC到智能手机网页（[demo](https://carlkcarlk.github.io/range-set-blaze/wasm-demo/)）到机器人等所有地方的非常快速且内存安全的代码。代码可以非常小，并且可以利用庞大的Rust
    crate库。
- en: To illustrate the rules, we’ll port the `[range-set-blaze](https://github.com/CarlKCarlK/range-set-blaze)`
    crate to run inside web pages — WASM — and on microcontrollers — embedded. (This
    crate manipulates sets of “clumpy” integers. A user of the crate requested the
    port.)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这些规则，我们将把`[range-set-blaze](https://github.com/CarlKCarlK/range-set-blaze)`
    crate移植到网页——WASM——和微控制器——嵌入式。 （这个crate操作“块状”整数的集合。这个crate的用户请求了这个移植。）
- en: A port to WASM and embedded requires that you avoid using Rust’s standard library,
    “std”. Converting to “no std” was both easier and harder than I expected. Easier
    because you can still use `Vec` and `String.` Harder, mostly because of testing.
    Based on my experience with `range-set-blaze`, here are the decisions, described
    one at a time, that I recommend. To avoid wishy-washiness, I’ll express these
    recommendations as rules.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 移植到WASM和嵌入式要求你避免使用Rust的标准库“std”。转换到“no std”比我预期的既容易又困难。容易是因为你仍然可以使用`Vec`和`String`。困难主要是因为测试。基于我在`range-set-blaze`上的经验，以下是我推荐的决策，逐一描述。为了避免优柔寡断，我将这些建议表达为规则。
- en: 'Rule 1: Mark your lib.rs or main.rs as no_std.'
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则1：将你的lib.rs或main.rs标记为no_std。
- en: 'Aside 1: First, use Git to create a new branch for your project. That way,
    if things don’t work out, you can easily undo all changes.'
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附注1：首先，使用Git为你的项目创建一个新分支。这样，如果出现问题，你可以轻松地撤销所有更改。
- en: ''
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Aside 2: *Actually*, [WASM partially supports std](https://github.com/paritytech/substrate/issues/4043).
    For example, it supports `vec`, `String`, and `HashSet`. It does not support File
    IO. If you only want WASM support, you may be able to skip all the “no_std” work
    in this article.'
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附注2：*实际上*，[WASM部分支持std](https://github.com/paritytech/substrate/issues/4043)。例如，它支持`vec`、`String`和`HashSet`。它不支持文件IO。如果你只需要WASM支持，你可能可以跳过本文中的所有“no_std”工作。
- en: ''
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Aside 3: A tip from [Reddit](https://www.reddit.com/r/rust/comments/14rc70l/)
    that I haven’t tested yet: “You really don’t need to set anything to `no_std`
    for Wasm. If you use anything like `wasm-opt` or `wasm-gc` or even just a full
    integrated pipeline with `trunk` you won''t see a difference in the binary size
    since anything you don''t use will be stripped away. No need to set up `no_std`
    and look for `no_std` dependencies.”'
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附注 3：来自[Reddit](https://www.reddit.com/r/rust/comments/14rc70l/)的一个提示，我还没有测试过：“你真的不需要为Wasm设置任何`no_std`。如果你使用诸如`wasm-opt`或`wasm-gc`，甚至只是一个完整的集成管道与`trunk`，你不会看到二进制文件大小的差异，因为任何你没有使用的东西都会被剥离。无需设置`no_std`并寻找`no_std`依赖项。”
- en: 'Mark the top of `lib.rs` with:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在`lib.rs`的顶部标记为：
- en: '`#![cfg_attr(not(test), no_std)]`'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`#![cfg_attr(not(test), no_std)]`'
- en: This tells the Rust compiler not to include the standard library, except when
    testing.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Rust编译器除非在测试时，否则不要包含标准库。
- en: 'Aside 1: My project is a library project with a `lib.rs`. I believe the steps
    for a binary project with a `main.rs` are about the same, but I haven’t tested
    them.'
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附注 1：我的项目是一个具有`lib.rs`的库项目。我认为具有`main.rs`的二进制项目的步骤大致相同，但我还没有测试过。
- en: ''
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Aside 2: We’ll talk much more about code testing in later rules.'
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附注 2：我们将在后面的规则中详细讨论代码测试。
- en: 'Adding the “no_std” line to `range-set-blaze`’s `lib.rs`, causes 40 compiler
    problems, most of this form:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在`range-set-blaze`的`lib.rs`中添加“no_std”行，会导致40个编译器问题，大多数问题形式如下：
- en: '![](../Images/cd34403675a277899925aa81efd0278e.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/cd34403675a277899925aa81efd0278e.png)'
- en: Fix some of these by changing, “std::” to “core::” in your main code (not in
    test code). For `range-set-blaze`, this reduces the number of problems from 40
    to 12\. This fix helps because many items, such as `std::cmp::max`, are also available
    as `core::cmp::max`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将主代码中的“std::”更改为“core::”来修复其中的一些问题（不包括测试代码）。对于`range-set-blaze`，这将问题数量从40个减少到12个。这个修复很有效，因为许多项，如`std::cmp::max`，在`core::cmp::max`中也可以找到。
- en: Sadly, items such as `Vec` and `Box` cannot be in `core` because they need to
    allocate memory. Happily, if you’re willing to support memory allocation, you
    can still use them.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 可悲的是，像`Vec`和`Box`这样的项不能在`core`中，因为它们需要分配内存。幸运的是，如果你愿意支持内存分配，你仍然可以使用它们。
- en: 'Rule 2: Use the built-in “crate alloc” if you can.'
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 2：如果可以的话，使用内置的“crate alloc”。
- en: 'Should you allow your crate to allocate memory? For WASM you should. For many
    embedded applications, you also should. For some embedded applications, however,
    you should not. If you decide to allow memory allocation, then at the top of `lib.rs`
    add:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否应该允许你的crate分配内存？对于WASM，你应该允许。对于许多嵌入式应用程序，你也应该允许。然而，对于一些嵌入式应用程序，你不应该允许。如果你决定允许内存分配，那么在`lib.rs`的顶部添加：
- en: '`extern crate alloc;`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`extern crate alloc;`'
- en: 'You can now add lines such as these to get access to many memory-allocated
    items:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以添加这样的行，以获取许多内存分配的项：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With `range-set-blaze`, this reduces the number of problems from 12 to two.
    We’ll fix these in Rule 3.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`range-set-blaze`，这将问题数量从12个减少到两个。我们将在规则 3 中解决这些问题。
- en: 'Aside: What if you are writing for an embedded environment that can’t use memory
    allocation and are having problems with, for example, `Vec`. You may be able to
    re-write. For example, you may be able to use an array in place of a vector. If
    that doesn’t work, take a look at the other rules. If nothing works, you may not
    be able to port your crate to `no_std`.'
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附注：如果你在编写一个不能使用内存分配的嵌入式环境，并且遇到了例如`Vec`的问题，你可以尝试重写。例如，你可以尝试用数组替代向量。如果这样不行，可以查看其他规则。如果都不行，你可能无法将你的crate移植到`no_std`。
- en: 'Rule 3: Switch to “no std” dependences.'
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 3：切换到“no std”依赖项。
- en: The Rust compiler complains if your project used a crate that puts “std” functions
    in your code. Sometimes, you can search [crates.io](https://crates.io/search?q=thiserror+no_std)
    and find alternative “no_std” crates. For example, the popular `thiserror` crate
    injects “std” into your code. However, the community has created [alternatives
    that do not](https://crates.io/search?q=thiserror+no_std).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的项目使用了将“std”函数引入你代码中的crate，Rust编译器会发出警告。有时，你可以搜索[crates.io](https://crates.io/search?q=thiserror+no_std)并找到替代的“no_std”
    crate。例如，流行的`thiserror` crate会将“std”注入你的代码。然而，社区已经创建了[不含](https://crates.io/search?q=thiserror+no_std)“std”的替代品。
- en: In the case of `range-set-blaze`, the two remaining problems relate to crate
    `[gen_ops](https://crates.io/crates/gen_ops)` — a wonderful crate for defining
    operators such as “+” and “&” conveniently. Version 0.3.0 of `gen_ops` did not
    fully support “no std”. Version 0.4.0, however, does. I updated my dependencies
    in `Cargo.toml` and improved my “no std” compatibility.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `range-set-blaze`，剩下的两个问题与 crate `[gen_ops](https://crates.io/crates/gen_ops)`
    相关——这是一个方便地定义操作符如 “+” 和 “&” 的绝妙 crate。`gen_ops` 的版本 0.3.0 未完全支持 “no std”。然而，版本
    0.4.0 支持。我更新了 `Cargo.toml` 中的依赖项，并改进了我的“no std”兼容性。
- en: 'I can now run these commands:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在可以运行这些命令：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The command `cargo check` confirms that my crate isn’t directly using the standard
    library. The command `cargo test` confirms that my tests (which still use the
    standard library) continue to pass. If your crate still doesn’t compile, take
    a look at the next rule.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 命令 `cargo check` 确认了我的 crate 并没有直接使用标准库。命令 `cargo test` 确认了我的测试（仍使用标准库）继续通过。如果你的
    crate 仍然不能编译，请查看下一个规则。
- en: 'Rule 4: Create std and alloc features and make your std-only functions optional.'
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 4：创建 std 和 alloc 特性，并使你的 std-only 函数可选。
- en: Embedded processors generally don’t support reading and writing files. Likewise,
    WASM doesn’t yet fully support files. While you can find some file-related “no
    std” crates, none seem comprehensive. So, if file IO is central to your crate,
    porting to WASM and embedded may not be practical.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式处理器通常不支持读取和写入文件。同样，WASM 也尚未完全支持文件。虽然你可以找到一些与文件相关的“no std” crates，但似乎没有一个是全面的。因此，如果文件
    IO 是你的 crate 的核心，移植到 WASM 和嵌入式可能不切实际。
- en: 'However, if file IO — or any other std-only function — is merely incidental
    to your crate, you can make that function optional via a “std” feature. Here is
    how:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果文件 IO —— 或任何其他 std-only 函数 —— 只是你的 crate 的附带功能，你可以通过“std”特性使该函数可选。方法如下：
- en: 'Add this section to your `Cargo.toml`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下部分添加到你的 `Cargo.toml`：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This says that your crate now has two features, “std” and “alloc”. By default,
    the compiler should use “std”.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示你的 crate 现在有两个特性，“std”和“alloc”。默认情况下，编译器应使用“std”。
- en: 'At the top of your `lib.rs`, replace:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `lib.rs` 顶部，替换：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'with:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 替换为：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This says that if you do not apply the “std” feature, the compiler should compile
    without the standard library.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示如果你不应用“std”特性，编译器应在没有标准库的情况下进行编译。
- en: 'On the line before any code that is std-only, placed `#[cfg(feature = "std")]`.
    For example, here we define a function that creates a `RangeSetBlaze` struct based
    on the contents of a file:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何 std-only 代码之前的行中，添加 `#[cfg(feature = "std")]`。例如，这里我们定义了一个基于文件内容创建 `RangeSetBlaze`
    结构体的函数：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To check the “std” and “alloc” features, do this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查 “std” 和 “alloc” 特性，请执行以下操作：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can test “std” with
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下方式测试“std”：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Aside: Surprisingly, `cargo test --features alloc --no-default-features` does
    not test "alloc”. That is because tests [require threads, allocation, and other
    things](https://github.com/rust-lang/wg-cargo-std-aware/issues/72) that may not
    be available​ in `no_std` so cargo always runs regular tests as “std”.'
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附注：令人惊讶的是，`cargo test --features alloc --no-default-features` 不会测试 "alloc"。这是因为测试
    [需要线程、分配和其他可能在 `no_std` 中不可用的东西](https://github.com/rust-lang/wg-cargo-std-aware/issues/72)，因此
    cargo 总是将常规测试作为“std”运行。
- en: At this point we’re checking both "std” and “alloc”, so can we assume that our
    library will work with WASM and embedded. No! Generally, **Nothing works without
    being tested.** Specifically, we might be depending on crates that use “std” code
    internally. To find these issues, we must test in the WASM and embedded environments.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们检查了“std”和“alloc”，所以我们可以假设我们的库将与 WASM 和嵌入式兼容吗？不！一般来说，**没有经过测试的东西都无法正常工作**。具体来说，我们可能依赖于内部使用“std”代码的
    crates。为了发现这些问题，我们必须在 WASM 和嵌入式环境中进行测试。
- en: 'Rule 5: Build your project for WASM. Use cargo tree to get it working.'
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 5：为 WASM 构建你的项目。使用 `cargo tree` 来使其正常工作。
- en: 'Install the WASM cross compiler and check your project with these commands:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 WASM 交叉编译器，并用以下命令检查你的项目：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When I do this on `range-set-blaze`, it complains that the `getrandom` crate
    doesn’t work with WASM. On the one hand, I’m not surprised that WASM does not
    fully support random numbers. On the other hand, I am surprised because my project
    doesn’t *directly* depend on `getrandom`. To find the *indirect* dependency, I
    use `cargo tree`. I discover that my project depends on crate `rand` which depends
    on `getrandom`. Here is the `cargo tree` command to use:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在 `range-set-blaze` 上执行此操作时，它抱怨 `getrandom` crate 与 WASM 不兼容。一方面，我不惊讶 WASM
    不完全支持随机数。另一方面，我感到惊讶，因为我的项目并不*直接*依赖于 `getrandom`。为了找出*间接*依赖，我使用 `cargo tree`。我发现我的项目依赖于
    crate `rand`，而 `rand` 依赖于 `getrandom`。以下是使用的 `cargo tree` 命令：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The command outputs both crates and the features they use:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令输出所有的 crate 及其使用的特性：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The output shows that `range-set-blaze` depends on `rand`. Also, it shows that
    `rand` depends on `getrandom` with its “std” feature.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示`range-set-blaze`依赖于`rand`。此外，它还显示`rand`依赖于带有“std”特性的`getrandom`。
- en: 'I read the `getrandom` [documentation](https://docs.rs/getrandom/latest/getrandom/#webassembly-support)
    and learn that its “js” feature supports WASM. So, how do we tell `rand` to use
    `getrandom/js`, but only when we compile with our "alloc” feature? We update our
    `Cargo.toml` like so:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我阅读了 `getrandom` [documentation](https://docs.rs/getrandom/latest/getrandom/#webassembly-support)
    并了解到其“js”特性支持 WASM。那么，我们如何让 `rand` 使用 `getrandom/js`，但仅在我们编译时启用我们的“alloc”特性？我们这样更新我们的
    `Cargo.toml`：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This says that our “std” feature depends on `getrandom`’s “std" feature. Our
    “alloc” feature, however, should use the `js` feature of `getrandom`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示我们的“std”特性依赖于 `getrandom` 的“std”特性。然而，我们的“alloc”特性应使用 `getrandom` 的 `js`
    特性。
- en: 'This now works:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以正常工作：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: So, we have WASM compiling, but what about testing WASM?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们已经完成了 WASM 的编译，但测试 WASM 呢？
- en: 'Rule 6: Create WASM tests and a WASM demo.'
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 6：创建 WASM 测试和 WASM 演示。
- en: Let’s put the WASM version to work, first with tests and then with a demo web
    page.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先用测试然后用演示网页来运行 WASM 版本。
- en: Create WASM tests in `tests/wasm.rs`
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 `tests/wasm.rs` 中创建 WASM 测试
- en: 'You can test on WASM almost as easily as you can test natively. We do this
    by having the original tests only run natively while an almost duplicate set of
    tests run on WASM. Here are the steps based on [The](https://rustwasm.github.io/wasm-bindgen/wasm-bindgen-test/index.html)
    `[wasm-bindgen](https://rustwasm.github.io/wasm-bindgen/wasm-bindgen-test/index.html)`
    [Guide](https://rustwasm.github.io/wasm-bindgen/wasm-bindgen-test/index.html):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以几乎像测试本地代码一样测试 WASM。我们通过让原始测试仅在本地运行，而几乎重复的测试集在 WASM 上运行来做到这一点。以下是基于 [The](https://rustwasm.github.io/wasm-bindgen/wasm-bindgen-test/index.html)
    `[wasm-bindgen](https://rustwasm.github.io/wasm-bindgen/wasm-bindgen-test/index.html)`
    [Guide](https://rustwasm.github.io/wasm-bindgen/wasm-bindgen-test/index.html)
    的步骤：
- en: Do `cargo install wasm-bindgen-cli`
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `cargo install wasm-bindgen-cli`
- en: Copy your current integration tests from, for example, `tests/integration_tests.rs`
    to `tests/wasm.rs`. (Recall that in Rust, integration tests are tests that live
    outside the `src` directory and that see only the public methods of a project.)
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前的集成测试从，例如 `tests/integration_tests.rs` 复制到 `tests/wasm.rs`。 （回忆一下，在 Rust
    中，集成测试是位于 `src` 目录外的测试，并且只能看到项目的公共方法。）
- en: At the top of `tests/wasm.rs`, remove `#![cfg(test)]` and add
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `tests/wasm.rs` 顶部，删除 `#![cfg(test)]` 并添加
- en: '`#![cfg(target_arch = "wasm32")]`'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`#![cfg(target_arch = "wasm32")]`'
- en: '`use wasm_bindgen_test::*; wasm_bindgen_test_configure!(run_in_browser);`'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`use wasm_bindgen_test::*; wasm_bindgen_test_configure!(run_in_browser);`'
- en: In `wasm.rs`, replace all`#[test]`’s to `#[wasm_bindgen_test]`’s.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `wasm.rs` 中，将所有的`#[test]`替换为`#[wasm_bindgen_test]`。
- en: 'Everywhere you have `#![cfg(test)]` (typically, in`tests/integration_tests.rs`
    and `src/tests.rs`) add the additional line: `#![cfg(not(target_arch = "wasm32"))]`'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你所有的 `#![cfg(test)]` 处（通常在`tests/integration_tests.rs`和`src/tests.rs`），添加额外的行：`#![cfg(not(target_arch
    = "wasm32"))]`
- en: In your, `Cargo.toml`, change your`[dev-dependencies]` (if any) to `[target.'cfg(not(target_arch
    = "wasm32"))'.dev-dependencies]`
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `Cargo.toml` 中，将 `[dev-dependencies]`（如果有的话）更改为 `[target.'cfg(not(target_arch
    = "wasm32"))'.dev-dependencies]`
- en: 'In your, `Cargo.toml`, add a section:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `Cargo.toml` 中，添加一个部分：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With all this set up, native tests, `cargo test`, should still work. If you
    don’t have the Chrome browser installed, install it. Now try to run the WASM tests
    with:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 设置完成后，本地测试，即`cargo test`，应该仍然有效。如果没有安装 Chrome 浏览器，请安装它。现在尝试使用以下命令运行 WASM 测试：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It will likely fail because your WASM tests use dependencies that haven’t or
    can’t be put in `Cargo.toml`. Go through each issue and either:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会失败，因为你的 WASM 测试使用了尚未或无法放入 `Cargo.toml` 的依赖。逐个解决每个问题，或者：
- en: Add the needed dependencies to `Cargo.toml’`s `[target.'cfg(target_arch = "wasm32")'.dev-dependencies]`section,
    or
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所需的依赖项添加到 `Cargo.toml` 的 `[target.'cfg(target_arch = "wasm32")'.dev-dependencies]`
    部分，或者
- en: Remove the tests from `tests/wasm.rs`.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `tests/wasm.rs` 中移除测试。
- en: For `range-set-blaze`, I removed all WASM tests related to testing the package’s
    benchmarking framework. These tests will still be run on the native side. Some
    useful tests in `tests\wasm.rs` needed crate `syntactic-for`, so I added it to
    `Cargo.toml`, under `[target.'cfg(target_arch = "wasm32")'.dev-dependencies]`.
    With this fixed, all 59 WASM tests run and pass.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `range-set-blaze`，我删除了所有与测试包的基准测试框架相关的 WASM 测试。这些测试仍将在本地运行。在 `tests\wasm.rs`
    中的一些有用的测试需要 crate `syntactic-for`，所以我将其添加到 `Cargo.toml` 中的 `[target.'cfg(target_arch
    = "wasm32")'.dev-dependencies]` 下。修复后，所有 59 个 WASM 测试均已运行并通过。
- en: 'Aside: If your project includes an [examples folde](http://xion.io/post/code/rust-examples.html)r,
    you may need create a `native` module inside your example and a `wasm` module.
    See this `range-set-blaze` file for an [“example” example](https://github.com/CarlKCarlK/range-set-blaze/commit/444b9b65f0a36281d5f02067cb690108e30f77fe?diff=split#diff-37c9e138e5ec0636c73b0b74bfe4c82663f180de02c51a29055d52603f30d4b7)
    of how to do this.'
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 旁注：如果你的项目包括一个 [examples folde](http://xion.io/post/code/rust-examples.html)r，你可能需要在你的示例中创建一个
    `native` 模块和一个 `wasm` 模块。查看这个 `range-set-blaze` 文件中的[“示例”示例](https://github.com/CarlKCarlK/range-set-blaze/commit/444b9b65f0a36281d5f02067cb690108e30f77fe?diff=split#diff-37c9e138e5ec0636c73b0b74bfe4c82663f180de02c51a29055d52603f30d4b7)来了解如何操作。
- en: Create a WASM demo in `tests/wasm-demo`
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 `tests/wasm-demo` 中创建一个 WASM 演示。
- en: Part of the fun of supporting WASM is that you can demo your Rust code in a
    web page. Here is a web [demo of](http://carlkcarlk.github.io/range-set-blaze/wasm-demo/)
    `[range-set-blaze](http://carlkcarlk.github.io/range-set-blaze/wasm-demo/)`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 支持 WASM 的乐趣之一是你可以在网页中演示你的 Rust 代码。这是一个网页 [演示](http://carlkcarlk.github.io/range-set-blaze/wasm-demo/)
    `[range-set-blaze](http://carlkcarlk.github.io/range-set-blaze/wasm-demo/)`。
- en: 'Follow these steps to create your own web demo:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建你自己的网页演示：
- en: 'In your project’s main `Cargo.toml` file, define a workspace and add `tests/wasm-demo`
    to it:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的主 `Cargo.toml` 文件中，定义一个工作区并将 `tests/wasm-demo` 添加到其中：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In your tests folder, create a `test/wasm-demo` subfolder.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的测试文件夹中，创建一个 `test/wasm-demo` 子文件夹。
- en: 'It should contain a new `Cargo.toml` like this (change `range-set-blaze` to
    the name of your project):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该包含一个新的 `Cargo.toml` 文件，类似于这样（将 `range-set-blaze` 更改为你项目的名称）：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Also, create a file `tests/wasm-demo/src/lib.rs`. Here is mine:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，创建一个文件 `tests/wasm-demo/src/lib.rs`。这是我的示例：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This file defines a function called `disjoint_intervals` that takes a vector
    of integers as input, for example, `100,103,101,102,-3,-4`. Using the `range-set-blaze`
    package, the function returns a string of the integers as sorted, disjoint ranges,
    for example, `-4..=-3, 100..=103`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件定义了一个名为 `disjoint_intervals` 的函数，它接受一个整数向量作为输入，例如，`100,103,101,102,-3,-4`。使用
    `range-set-blaze` 包，函数返回一个字符串，表示这些整数按排序后、互不重叠的区间，例如，`-4..=-3, 100..=103`。
- en: As your final step, create file `tests/wasm-demo/index.html.` Mine uses a little
    JavaScript to accept a list of integers and then call the Rust WASM function `disjoint_intervals`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，创建文件 `tests/wasm-demo/index.html`。我的使用了一些 JavaScript 代码来接收一个整数列表，然后调用
    Rust WASM 函数 `disjoint_intervals`。
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To run the demo locally, first move your terminal to `tests/wasm-demo`. Then
    do:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本地运行演示，首先将终端移动到 `tests/wasm-demo`。然后执行：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, start a local web server and view the page. I use the [Live Preview](https://marketplace.visualstudio.com/items?itemName=ms-vscode.live-server)
    extension to VS Code. Many people use `python -m http.server`. The `range-set-blaze`
    demo looks like this (also available, [live on GitHub](https://carlkcarlk.github.io/range-set-blaze/wasm-demo/)):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，启动本地网络服务器并查看页面。我使用了 [Live Preview](https://marketplace.visualstudio.com/items?itemName=ms-vscode.live-server)
    扩展到 VS Code。许多人使用 `python -m http.server`。`range-set-blaze` 演示看起来像这样（也可以[在 GitHub
    上实时查看](https://carlkcarlk.github.io/range-set-blaze/wasm-demo/)）：
- en: '![](../Images/0413748bafff879c803c0c63b28d809b.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0413748bafff879c803c0c63b28d809b.png)'
- en: I find watching my Rust project run in a web page very gratifying. If WASM-compatibility
    is all you are looking for, you can skip to Rule 9.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现看到我的 Rust 项目在网页中运行非常令人满意。如果 WASM 兼容性是你所寻找的一切，你可以跳到规则 9。
- en: 'Rule 7: Build your project for embedded.'
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 7：为嵌入式构建你的项目。
- en: If you want to take your project a step beyond WASM, follow this rule and the
    next.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将你的项目推进到 WASM 之外，请遵循这个规则和接下来的规则。
- en: 'Be sure you move your terminal back to your project’s home directory. Then,
    install `thumbv7m-none-eabi`, a popular embedded processor, and check your project
    with these commands:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将终端移动回项目的主目录。然后，安装 `thumbv7m-none-eabi`，这是一个流行的嵌入式处理器，并使用以下命令检查你的项目：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When I do this on `range-set-blaze`, I get errors related to four sets of dependencies:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在`range-set-blaze`上执行此操作时，我得到与四组依赖项相关的错误：
- en: '`thiserror` — My project depended on this crate but didn’t actually use it.
    I removed the dependency.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thiserror` — 我的项目依赖于这个crate，但实际上没有使用它。我删除了这个依赖。'
- en: '`rand` and `getrandom` — My project only needs random numbers for native testing,
    so I moved the dependency to `[target.''cfg(not(target_arch = "wasm32"))''.dev-dependencies]`.
    I also updated my main and testing code.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rand`和`getrandom` — 我的项目只需要在本地测试中使用随机数，所以我将依赖项移动到了`[target.''cfg(not(target_arch
    = "wasm32"))''.dev-dependencies]`。我还更新了我的主代码和测试代码。'
- en: '`itertools`, `num-traits`, and `num-integer` — These crates offer features
    for “std” and “alloc”. I updated `Cargo.toml` like so:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`itertools`、`num-traits`和`num-integer` — 这些crate为“std”和“alloc”提供了功能。我将`Cargo.toml`更新为如下：'
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How did I know which feature of which dependancies to use? Understanding the
    features of a crate such as `itertools` requires reading [its documentation](https://docs.rs/itertools/latest/itertools/#crate-features)
    and (often) going to [its GitHub repository](https://github.com/rust-itertools/itertools/blob/master/Cargo.toml)
    and reading its `Cargo.toml`. You should also use `cargo tree` to check that you
    are getting the desire feature from each dependency. For example, this use of
    `cargo tree` shows that for a default compile, I get the “std” features of `range-set-blaze`,
    `num-integer`, and `num-traits` and the “use-std” features of `itertools` and
    `either:`
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我怎么知道使用哪个依赖项的哪个功能？理解像`itertools`这样的crate的功能需要阅读[其文档](https://docs.rs/itertools/latest/itertools/#crate-features)并（通常）访问[其GitHub仓库](https://github.com/rust-itertools/itertools/blob/master/Cargo.toml)并阅读其`Cargo.toml`。你还应该使用`cargo
    tree`来检查你是否从每个依赖项中获得了所需的功能。例如，这种使用`cargo tree`的方法显示了对于默认编译，我得到了`range-set-blaze`、`num-integer`和`num-traits`的“std”功能，以及`itertools`和`either`的“use-std”功能：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And this shows that for a `--features alloc --no-default-feature` compile,
    I get the desired “use_alloc” feature of `itertools` and “no default” version
    of the other dependences:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明，对于`--features alloc --no-default-feature`编译，我获得了`itertools`的“use_alloc”功能以及其他依赖项的“无默认”版本：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When you think you have everything working, use these commands to check/test
    native, WASM, and embedded:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当你认为一切正常时，使用这些命令来检查/测试本地、WASM和嵌入式：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: These *check* embedded, but what about *testing* embedded?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这些*检查*嵌入，但*测试*嵌入呢？
- en: 'Rule 8: Create a single embedded test and an embedded demo.'
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 8：创建一个单一的嵌入式测试和一个嵌入式演示。
- en: Let’s put our embedded feature to work by creating a combined test and demo.
    We will run it on an emulator called QEMU.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个综合测试和演示来发挥我们的嵌入式功能。我们将它运行在一个叫做QEMU的模拟器上。
- en: Testing native Rust is easy. Testing WASM Rust is OK. Testing embedded Rust
    is hard. We will do only a single, simple test.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 测试本地Rust很简单。测试WASM Rust还可以。测试嵌入式Rust很困难。我们将只进行一次简单的测试。
- en: 'Aside 1: For more, about running and emulating embedded Rust see: [The Embedded
    Rust Book](https://docs.rust-embedded.org/book/start/index.html).'
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附注 1：有关运行和模拟嵌入式Rust的更多信息，请参见：[The Embedded Rust Book](https://docs.rust-embedded.org/book/start/index.html)。
- en: ''
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Aside 2: For ideas on a more complete test framework for embedded Rust, see
    [defmt-test](https://github.com/knurling-rs/defmt/tree/main/firmware/defmt-test).
    Sadly, I couldn’t figure out how to get it to run under emulation. The [cortex-m/testsuite](https://github.com/rust-embedded/cortex-m/tree/master/testsuite)
    project uses a fork of defmt-test and can run under emulation but doesn’t offer
    a stand-alone testing crate and requires three additional (sub)projects.'
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附注 2：有关更完整的嵌入式Rust测试框架的想法，请参见[defmt-test](https://github.com/knurling-rs/defmt/tree/main/firmware/defmt-test)。遗憾的是，我无法搞清楚如何在模拟下运行它。[cortex-m/testsuite](https://github.com/rust-embedded/cortex-m/tree/master/testsuite)项目使用了defmt-test的一个分支，并且可以在模拟下运行，但没有提供独立的测试crate，并且需要三个额外的（子）项目。
- en: ''
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Aside 3: One embedded test is infinitely better than no tests. We’ll do the
    rest of our testing at the native and WASM level.'
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附注 3：一个嵌入式测试要比没有测试好得多。我们将在本地和WASM级别进行其余的测试。
- en: 'We will create the embedded test and demo inside our current `tests` folder.
    The files will be:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在当前的`tests`文件夹内创建嵌入式测试和演示。文件将是：
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here are the steps to creating the files and setting things up.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是创建文件和设置的步骤。
- en: Install the [QEMU emulator](https://www.qemu.org/). On Windows, this involves
    running an installer and then manually adding `"C:\Program Files\qemu\"` to your
    path.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装[QEMU模拟器](https://www.qemu.org/)。在Windows上，这涉及运行安装程序，然后手动将`"C:\Program Files\qemu\"`添加到你的路径中。
- en: '2\. Create a `tests/embedded/Cargo.toml` that depends on your local project
    with “no default features” and “alloc”. Here is mine:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 创建一个依赖于本地项目的 `tests/embedded/Cargo.toml`，并包含“无默认功能”和“alloc”。这是我的：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '3\. Create a file `tests/embedded/src/main.rs`. Put your test code after the
    “test goes here” comment. Here is my file:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 创建一个文件 `tests/embedded/src/main.rs`。将你的测试代码放在“test goes here”注释之后。这是我的文件：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 4\. Copy `build.rs` and `memory.x` from `[cortex-m-quickstart](https://github.com/rust-embedded/cortex-m-quickstart/tree/master)`’s
    GitHub to `tests/embedded/`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 从 `[cortex-m-quickstart](https://github.com/rust-embedded/cortex-m-quickstart/tree/master)`
    的 GitHub 仓库复制 `build.rs` 和 `memory.x` 到 `tests/embedded/`。
- en: '5\. Create a `tests/embedded/.cargo/config.toml` containing:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. 创建一个包含以下内容的 `tests/embedded/.cargo/config.toml`：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '6\. Update your project’s main `Cargo.toml` by adding `tests/embedded` to your
    workspace:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 6\. 通过将 `tests/embedded` 添加到你的工作区来更新项目的主 `Cargo.toml`：
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'With this setup, you are almost ready to run emulated embedded. Next, get your
    terminal in position and the compiler set to nightly:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个设置，你几乎准备好运行模拟的嵌入式了。接下来，准备好你的终端，并将编译器设置为 nightly：
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can now use `cargo check`, `cargo build`, and `cargo run` on the demo app.
    For example:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以在演示应用上使用 `cargo check`、`cargo build` 和 `cargo run`。例如：
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When you get this working, you will have successfully run your project on an
    (emulated) microcontroller! If you have problems with the setup, double check
    these instructions. If that doesn’t work, take a look at [The Embedded Rust Book](https://docs.rust-embedded.org/book/start/qemu.html).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成这项工作时，你将成功在一个（模拟的）微控制器上运行你的项目！如果你在设置过程中遇到问题，请仔细检查这些说明。如果还是不行，可以查看 [The Embedded
    Rust Book](https://docs.rust-embedded.org/book/start/qemu.html)。
- en: 'When you are done, be sure to set your compiler back to stable:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，请务必将编译器设置回稳定版本：
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Rule 9: Finish up with CI testing, Cargo.toml metadata, and an updated README.md.'
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 9：完成 CI 测试、Cargo.toml 元数据和更新后的 README.md。
- en: CI Testing
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CI 测试
- en: We’re almost done, but we must make sure that everything that works today will
    work tomorrow. That’s the job of CI (continuous integration) testing.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快完成了，但我们必须确保今天有效的内容明天也能有效。这就是 CI（持续集成）测试的工作。
- en: 'I set my CI tests to run every check in and once every month. If on GitHub,
    create a file `.github/workflows/tests.yml`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我将我的 CI 测试设置为每次检查和每个月运行一次。如果在 GitHub 上，创建一个文件 `.github/workflows/tests.yml`：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If you are only doing WASM, you can leave off the last two steps that relate
    to embedded.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仅仅使用 WASM，你可以省略与嵌入式相关的最后两个步骤。
- en: 'Aside: Why does the last test say `timeout-minutes: 3`? Because a failed embedded
    test doesn’t return with failure. Instead, it goes into an endless loop. We catch
    this with the timeout.'
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '附注：为什么最后一个测试会显示 `timeout-minutes: 3`？因为一个失败的嵌入式测试不会返回失败。相反，它会进入一个无限循环。我们通过超时来捕捉这一点。'
- en: Metadata
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元数据
- en: 'Rust allows you to mark your code as working on particular architectures and
    environments. The convention is to use keyword and category metadata. Specifically,
    add these keywords and [categories](https://crates.io/category_slugs) to your
    `Cargo.toml` as appropriate:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 允许你标记你的代码适用于特定的架构和环境。惯例是使用关键字和类别元数据。具体来说，根据需要将这些关键字和 [类别](https://crates.io/category_slugs)
    添加到你的 `Cargo.toml` 中：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**README.md**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**README.md**'
- en: 'You should also update your `README.md` to tell people that you support WASM
    and embedded. Here is what I added:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该更新你的 `README.md`，告诉大家你支持 WASM 和嵌入式。这是我添加的内容：
- en: '[PRE38]toml'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE38]toml'
- en: '[dependencies]'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[dependencies]'
- en: range-set-blaze = { features = ["alloc"], default-features = false, version=VERSION
    }
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: range-set-blaze = { features = ["alloc"], default-features = false, version=VERSION
    }
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'So, there you have it: nine rules for WASM and no_std ports in Rust. Rust is
    a great language for native, WASM, and embedded programming. It offers speed,
    safety, and access to thousands of useful crates. Follow these nine rules to run
    your own Rust code almost everywhere.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你现在有了：针对 Rust 中 WASM 和 no_std 端口的九条规则。Rust 是一个出色的语言，适用于本地、WASM 和嵌入式编程。它提供了速度、安全性，并访问到成千上万的有用
    crate。遵循这九条规则，可以在几乎所有地方运行你自己的 Rust 代码。
- en: 'Aside: If you’re interested in future articles, please [follow me on Medium](https://medium.com/@carlmkadie).
    I write on scientific programming in Rust and Python, machine learning, and statistics.
    I tend to write about one article per month.'
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附注：如果你对未来的文章感兴趣，请 [关注我在 Medium](https://medium.com/@carlmkadie)。我写关于 Rust 和
    Python 的科学编程、机器学习和统计。我通常每月写一篇文章。
