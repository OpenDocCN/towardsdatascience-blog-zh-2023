- en: Implementing a Transformer Encoder from Scratch with JAX and Haiku ü§ñ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://towardsdatascience.com/implementing-a-transformer-encoder-from-scratch-with-jax-and-haiku-791d31b4f0dd?source=collection_archive---------7-----------------------#2023-11-07](https://towardsdatascience.com/implementing-a-transformer-encoder-from-scratch-with-jax-and-haiku-791d31b4f0dd?source=collection_archive---------7-----------------------#2023-11-07)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Understanding the fundamental building blocks of Transformers.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@ryanpegoud?source=post_page-----791d31b4f0dd--------------------------------)[![Ryan
    P√©goud](../Images/9314b76c2be56bda8b73b4badf9e3e4d.png)](https://medium.com/@ryanpegoud?source=post_page-----791d31b4f0dd--------------------------------)[](https://towardsdatascience.com/?source=post_page-----791d31b4f0dd--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----791d31b4f0dd--------------------------------)
    [Ryan P√©goud](https://medium.com/@ryanpegoud?source=post_page-----791d31b4f0dd--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ¬∑
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F27fba63b402e&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fimplementing-a-transformer-encoder-from-scratch-with-jax-and-haiku-791d31b4f0dd&user=Ryan+P%C3%A9goud&userId=27fba63b402e&source=post_page-27fba63b402e----791d31b4f0dd---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----791d31b4f0dd--------------------------------)
    ¬∑12 min read¬∑Nov 7, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F791d31b4f0dd&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fimplementing-a-transformer-encoder-from-scratch-with-jax-and-haiku-791d31b4f0dd&user=Ryan+P%C3%A9goud&userId=27fba63b402e&source=-----791d31b4f0dd---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F791d31b4f0dd&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fimplementing-a-transformer-encoder-from-scratch-with-jax-and-haiku-791d31b4f0dd&source=-----791d31b4f0dd---------------------bookmark_footer-----------)![](../Images/bdeff665e8c9cb3e1a1bdb370c5de52f.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Transformers, in the style of Edward Hopper (generated by Dall.E 3)
  prefs: []
  type: TYPE_NORMAL
- en: Introduced in 2017 in the seminal paper ‚Äú[***Attention is all you need***](https://arxiv.org/pdf/1706.03762.pdf)***‚Äù***[0],
    the Transformer architecture is arguably one of the most impactful breakthroughs
    in recent Deep Learning history, enabling the rise of large language models and
    even finding use in fields such as computer vision.
  prefs: []
  type: TYPE_NORMAL
- en: Succeeding to former state-of-the-art architectures relying on **recurrence**
    such as Long Short-Term Memory (**LSTM**) networks or Gated Recurrent Units (**GRU**),
    **Transformers** introduce the concept of **self-attention**, coupled with an
    **encoder/decoder** architecture.
  prefs: []
  type: TYPE_NORMAL
- en: In this article, we‚Äôll implement the first half of a Transformer, the **Encoder**,
    from scratch and step by step. We‚Äôll use **JAX** as our main framework along with
    **Haiku,** one of DeepMind‚Äôs deep learning libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case you are unfamiliar with JAX or need a fresh reminder about its amazing
    functionalities, I‚Äôve already covered the topic in the context of Reinforcement
    Learning in my **previous article**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/vectorize-and-parallelize-rl-environments-with-jax-q-learning-at-the-speed-of-light-49d07373adf5?source=post_page-----791d31b4f0dd--------------------------------)
    [## Vectorize and Parallelize RL Environments with JAX: Q-learning at the Speed
    of Light‚ö°'
  prefs: []
  type: TYPE_NORMAL
- en: Learn to vectorize a GridWorld environment and train 30 Q-learning agents in
    parallel on a CPU, at 1.8 million step per‚Ä¶
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/vectorize-and-parallelize-rl-environments-with-jax-q-learning-at-the-speed-of-light-49d07373adf5?source=post_page-----791d31b4f0dd--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 'We‚Äôll go over each of the blocks that make up the encoder and learn to implement
    them efficiently. In particular, the outline of this article contains:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Embedding Layer** and **Positional Encodings**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multi-Head Attention**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Residual Connections** and **Layer Normalization**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Position-wise Feed-Forward Networks**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Disclaimer: this article is not intended to be a complete introduction to
    these notions as we‚Äôll focus on implementation first. If needed, please refer
    to the resources at the end of this post.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***As always, the fully commented code for this article as well as illustrated
    notebooks are available on*** [***GitHub***](https://github.com/RPegoud/jab)***,
    feel free to star the repository if you enjoyed the article!***'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://github.com/RPegoud/jab?source=post_page-----791d31b4f0dd--------------------------------)
    [## GitHub ‚Äî RPegoud/jab: A collection of foundational Deep Learning models implemented
    in JAX'
  prefs: []
  type: TYPE_NORMAL
- en: 'A collection of foundational Deep Learning models implemented in JAX ‚Äî GitHub
    ‚Äî RPegoud/jab: A collection of‚Ä¶'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: github.com](https://github.com/RPegoud/jab?source=post_page-----791d31b4f0dd--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Main parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we get started, we need to define a few parameters that will play a
    crucial role in the encoder block:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sequence Length** (`seq_len`): The number of tokens or words in a sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Embedding Dimension** (`embed_dim`): The dimension of the embeddings, in
    other words, the number of numerical values used to describe a single token or
    word.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Batch Size (**`batch_size`**):** The size of a batch of inputs, i.e. the
    number of sequences processed at the same time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The input sequences to our encoder model will typically be of shape **(**`batch_size`**,**
    `seq_len`**)**. In this article, we‚Äôll use `batch_size=32` and `seq_len=10`, which
    means that our encoder will simultaneously process 32 sequences of 10 words.
  prefs: []
  type: TYPE_NORMAL
- en: 'Paying attention to the shape of our data at each step of the processing will
    enable us to better visualize and understand how the data flows in the encoder
    block. Here‚Äôs a high-level overview of our encoder, we‚Äôll start from the bottom
    with the **embedding layer** and **positional encodings**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/818dc653dc223239b2d0b4bd7739222f.png)'
  prefs: []
  type: TYPE_IMG
- en: Representation of the **Transformer Encoder block** (made by the author)
  prefs: []
  type: TYPE_NORMAL
- en: Embedding Layer and Positional Encodings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned previously, our model takes batched sequences of tokens as inputs.
    Generating those tokens could be as simple as collecting a set of unique words
    in our dataset, and assigning an index to each of them. Then we would sample **32**
    **sequences** of **10 words** and replace each word with its index in the vocabulary.
    This procedure would provide us with an array of shape **(**`batch_size`**,**
    `seq_len`**)**, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to get started with our Encoder. The first step is to create
    ‚Äú***positional embeddings***‚Äù for our sequences. Positional embeddings are the
    **sum** of **word embeddings** and **positional encodings**.
  prefs: []
  type: TYPE_NORMAL
- en: Word Embeddings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Word embeddings allow us to encode the **meaning** and **semantic relations**
    **between words** in our vocabulary. In this article, the embedding dimension
    is fixed to **64**. This means that each word is represented by a **64-dimensional
    vector** so that words with similar meanings have similar coordinates. Moreover,
    we can manipulate these vectors to **extract relations between words**, as depicted
    below.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/55b06988518a9554add4ad341f107320.png)'
  prefs: []
  type: TYPE_IMG
- en: Example of analogies derived from word embeddings (image from developers.google.com)
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Haiku, generating learnable embeddings is as simple as calling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: These embeddings will be updated along with other learnable parameters during
    model training *(more on that in a second)*.
  prefs: []
  type: TYPE_NORMAL
- en: Positional Encodings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As opposed to recurrent neural nets, Transformers can‚Äôt infer the position of
    a token given a shared hidden state as they **lack recurrent** or **convolutional
    structures**. Hence the introduction of **positional encodings, vectors** that
    convey a **token‚Äôs position** in the **input sequence**.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, each token is assigned a **positional vector** composed of **alternating
    sine and cosine values**. Those vectors match the dimensionality of word embeddings
    so that both can be summed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, the original Transformer paper uses the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/683d82eb429e0126a88dbded90881ceb.png)![](../Images/c29c91a5570ead1acef50cc6df4c3e59.png)'
  prefs: []
  type: TYPE_IMG
- en: Positional Encoding functions (reproduced from ‚ÄúAttention is all you need‚Äù,
    Vaswani et al. 2017)
  prefs: []
  type: TYPE_NORMAL
- en: The below figures enable us to further understand the functioning of positional
    encodings. Let‚Äôs take a look at the first row of the uppermost plot, we can see
    **alternating sequences of zeros and ones.** Indeed, rows represent the position
    of a token in the sequence (the `pos` variable) while columns represent the embedding
    dimension (the `i` variable).
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, when `pos=0`, the previous equations return `sin(0)=0` for even embedding
    dimensions and `cos(0)=1` for odd dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, we see that adjacent rows share similar values, whereas the first
    and last rows are wildly different. This property is helpful for the model to
    assess the **distance between words** in the sequence as well as their **ordering**.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the third plot represents the sum of positional encodings and embeddings,
    which is the output of the embedding block.
  prefs: []
  type: TYPE_NORMAL
- en: Representation of word embeddings and positional encodings, with seq_len=16
    and embed_dim=64 (made by the author)
  prefs: []
  type: TYPE_NORMAL
- en: Using Haiku, we define the embedding layer as follows. Similarly to other deep
    learning frameworks, Haiku allows us to define **custom modules** (here `hk.Module`)
    to **store learnable parameters** and **define the behavior** of our model‚Äôs components.
  prefs: []
  type: TYPE_NORMAL
- en: Each Haiku module needs to have an `__init__`and `__call__`function. Here, the
    call function simply computes the embeddings using the `hk.Embed` function and
    the positional encodings, before summing them.
  prefs: []
  type: TYPE_NORMAL
- en: The positional encoding function uses JAX functionalities such as `vmap`and`lax.cond`for
    performance. If you are unfamiliar with those functions, feel free to check out
    my [previous post](https://medium.com/towards-data-science/vectorize-and-parallelize-rl-environments-with-jax-q-learning-at-the-speed-of-light-49d07373adf5)
    where they are presented more in-depth.
  prefs: []
  type: TYPE_NORMAL
- en: Put simply, `vmap`allows us to define a function for a **single sample** and
    **vectorize it** so that it can be applied to **batches** of data. The `in_axes`parameter
    is used to specify that we want to iterate over the first axis of the `dim`input,
    which is the embedding dimension. On the other hand, `lax.cond`is an XLA-compatible
    version of a Python if/else statement.
  prefs: []
  type: TYPE_NORMAL
- en: Self-attention and MultiHead-Attention
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Attention aims to compute the **importance of each word in a sequence**, **relative
    to an input word**. For example, in the sentence:'
  prefs: []
  type: TYPE_NORMAL
- en: ‚ÄúThe black cat jumped on the sofa, lied down and fell asleep, as it was tired‚Äù.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The word ‚Äú**it**‚Äù could be quite ambiguous for the model, as *technically*,
    it could refer to both ‚Äú**cat**‚Äù and ‚Äú**sofa**‚Äù. A well-trained attention model
    would be able to understand that ‚Äú**it**‚Äù refers to ‚Äú**cat**‚Äù and therefore assign
    attention values to the rest of the sentence accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, **attention values** could be seen as **weights** that describe
    the **importance** of a certain word **given the context of the input** word.
    For instance, the attention vector for the word ‚Äú**jumped**‚Äù would have high values
    for words like ‚Äú**cat**‚Äù (*what* jumped?), ‚Äú**on**‚Äù, and ‚Äú**sofa**‚Äù (*where* did
    it jump?) as these words are **relevant to its context**.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/31016a82455c64d4f840c4bbe4861bad.png)'
  prefs: []
  type: TYPE_IMG
- en: Visual representation of an **attention vector** (made by the author)
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Transformer paper, attention is computed using ***Scaled Dot-Product
    Attention***. Which is summarized by the formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/252c2d3a224b203a09510ff5ba3d43a9.png)'
  prefs: []
  type: TYPE_IMG
- en: Scaled Dot-Product Attention (reproduced from ‚ÄúAttention is all you need‚Äù, *Vaswani
    et al. 2017*)
  prefs: []
  type: TYPE_NORMAL
- en: Here, Q,K and V stand for ***Queries, Keys*** and ***Values****.* These matrices
    are obtained by multiplying learned weight vectors WQ, WK and WV with positional
    embeddings.
  prefs: []
  type: TYPE_NORMAL
- en: These names are mainly **abstractions** used to help understand how the information
    is processed and weighted in the attention block. They are an allusion to **retrieval
    systems** vocabulary[2] (e.g. searching a video on YouTube for instance).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here‚Äôs an **intuitive** explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Queries**: They can be interpreted as a ‚Äú*set of questions*‚Äù about all the
    positions in a sequence. For instance, interrogating the context of a word and
    trying to identify the most relevant parts of the sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keys**: They can be seen as holding information that the queries interact
    with, the compatibility between a query and a key determines how much attention
    the query should pay to the corresponding value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Values**: Matching keys and queries allows us to decide which keys are relevant,
    values are the actual content paired with the keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following figure, the query is a YouTube search, the keys are the video
    descriptions and metadata, while the value are the associated videos.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/483f936afe83dcd9d81810153894e7b2.png)'
  prefs: []
  type: TYPE_IMG
- en: Intuitive representation of the Queries, Keys, Values concept (made by the author)
  prefs: []
  type: TYPE_NORMAL
- en: In our case, queries, keys, and values come from the **same source** (as they‚Äôre
    derived from the input sequences), hence the name **self-attention**.
  prefs: []
  type: TYPE_NORMAL
- en: The computation of attention scores is usually executed **multiple times in
    parallel**, each time with a **fraction of the embeddings**. This mechanism is
    called ‚Äú**Multi-Head Attention**‚Äù and enables each head to learn several different
    representations of the data in parallel, leading to a more **robust** model.
  prefs: []
  type: TYPE_NORMAL
- en: A single attention head would generally process arrays with shape (`batch_size,
    seq_len, d_k`**)**where `d_k`can be set as the ratio between the number of heads
    and the dimension of the embeddings (`d_k = n_heads/embed_dim`). This way, concatenating
    the outputs of each head conveniently gives an array with shape **(**`batch_size,
    seq_len, embed_dim`**)**, as the input.
  prefs: []
  type: TYPE_NORMAL
- en: 'The computation of attention matrices can be broken down into several steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we define **learnable weight vectors** WQ, WK, and WV. These vectors
    have shapes **(**`n_heads, embed_dim, d_k`**)**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In parallel, we **multiply** the **positional embeddings** with the **weight
    vectors**. We obtain Q, K, and V matrices with shapes **(**`batch_size, seq_len,
    d_k`**)**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then **scale** the **dot-product** of Q and K (transposed). This scaling
    involves dividing the result of the dot-product by the square root of `d_k`and
    applying the softmax function on the matrices rows. Therefore, attention scores
    for an input token (i.e. a row) sum up to one, this helps prevent values from
    becoming too large and slowing down computation. The output has shape (`batch_size,
    seq_len, seq_len`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we dot the result of the previous operation with V, making the shape
    of the output (`batch_size, seq_len, d_k`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/53a16f4b352d266f793268e64d9cd1e6.png)'
  prefs: []
  type: TYPE_IMG
- en: Visual representation of matrix operations inside **an attention block** (made
    by the author)
  prefs: []
  type: TYPE_NORMAL
- en: The outputs of each attention head can then be **concatenated** to form a matrix
    with shape (`batch_size, seq_len, embed_dim`). The Transformer paper also adds
    a **linear layer** at the end of the multi-head attention module, to **aggregate**
    and **combine** the learned representations from **all the attention heads**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/2b83a1bf528562df5c6794e0dffe2819.png)'
  prefs: []
  type: TYPE_IMG
- en: Concatenation of multi-head attention matrices and linear layer (made by the
    author)
  prefs: []
  type: TYPE_NORMAL
- en: In Haiku, the Multi-Head Attention module can be implemented as follows. The
    `__call__`function follows the same logic as the above graph while the class methods
    take advantage of JAX utilities such as `vmap`(to vectorize our operations over
    the different attention heads and matrices) and `tree_map`(to map matrix dot-products
    over weight vectors).
  prefs: []
  type: TYPE_NORMAL
- en: Residual Connections and Layer Normalization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you might have noticed on the Transformer graph, the multi-head attention
    block and the feed-forward net are followed by **residual connections** and **layer
    normalization**.
  prefs: []
  type: TYPE_NORMAL
- en: Residual or skip connections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Residual connections are a standard solution to **solve** the **vanishing gradient
    problem**, which occurs when gradients become too small to effectively update
    the model‚Äôs parameters.
  prefs: []
  type: TYPE_NORMAL
- en: As this issue naturally arises in particularly deep architectures, residual
    connections are used in a variety of complex models such as **ResNet** *(*[*Kaiming
    et al*](https://arxiv.org/abs/1512.03385v1)*, 2015)* in computer vision, **AlphaZero**
    ([*Silver et al*](https://arxiv.org/abs/1712.01815v1)*, 2017*) in reinforcement
    learning, and of course, **Transformers**.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, residual connections simply forward the output of a specific layer
    to a following one, **skipping one or more layers** on the way. For instance,
    the residual connection around the multi-head attention is equivalent to summing
    the output of multi-head attention with positional embeddings.
  prefs: []
  type: TYPE_NORMAL
- en: This enables gradients to flow more efficiently through the architecture during
    backpropagation and can usually lead to **faster convergence** and more **stable
    training**.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/abba4a948e3ceaf4187f0f3469983f17.png)'
  prefs: []
  type: TYPE_IMG
- en: Representation of **residual connections** in Transformers (made by the author)
  prefs: []
  type: TYPE_NORMAL
- en: Layer Normalization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Layer normalization helps ensure that the values propagated through the model
    do not ‚Äú***explode***‚Äù (tend toward infinity), which could easily happen in attention
    blocks, where several matrices are multiplied during each forward pass.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike batch normalization, which normalizes across the batch dimension assuming
    a uniform distribution, **layer normalization operates** **across the features**.
    This approach is suitable for sentence batches where each may have **unique distributions**
    due to **varying meanings** and **vocabularies**.
  prefs: []
  type: TYPE_NORMAL
- en: By normalizing across **features**, such as **embeddings** or **attention values**,
    layer normalization **standardizes data** to a consistent scale **without conflating
    distinct sentence characteristics**, maintaining the unique distribution of each.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ac49f30b74e842229d2043091b9ef894.png)'
  prefs: []
  type: TYPE_IMG
- en: Representation of **Layer Normalization** in the context of Transformers (made
    by the author)
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of layer normalization is pretty straightforward, we initialize
    the learnable parameters alpha and beta and normalize along the desired feature
    axis.
  prefs: []
  type: TYPE_NORMAL
- en: '**Position-wise Feed-Forward Network**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last component of the encoder that we need to cover is the **position-wise
    feed-forward network**. This fully connected network takes the normalized outputs
    of the attention block as inputs and is used to introduce **non-linearity** and
    increase the **model‚Äôs capacity** to learn complex functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is composed of two dense layers separated by a [gelu activation](https://paperswithcode.com/method/gelu):'
  prefs: []
  type: TYPE_NORMAL
- en: After this block, we have another residual connection and layer normalization
    to complete the encoder.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There we have it! By now you should be familiar with the main concepts of the
    Transformer encoder. Here‚Äôs the full encoder class, notice that in Haiku, we assign
    a name to each layer, so that learnable parameters are separated and easy to access.
    The `__call__`function provides a good summary of the different steps of our encoder:'
  prefs: []
  type: TYPE_NORMAL
- en: To use this module on actual data, we have to apply `hk.transform` to a function
    encapsulating the encoder class. Indeed, you might remember that JAX embraces
    the **functional programming** paradigm, therefore, Haiku follows the same principles.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define a function containing an instance of the encoder class and return
    the output of a forward pass. Applying `hk.transform` returns a transformed object
    having access to two functions: `init` and `apply`.'
  prefs: []
  type: TYPE_NORMAL
- en: The former enables us to initialize the module with a random key as well as
    some dummy data (notice that here we pass an array of zeros with shape `batch_size,
    seq_len`) while the latter allows us to process real data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the next article, we‚Äôll **complete the transformer** architecture by adding
    a **decoder**, which reuses most of the blocks we introduced so far, and learn
    how to **train a model** on a specific task using Optax!
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Thank you for reading this far**, if you are interested in dabbling with
    the code, you can find it fully commented on GitHub, along with additional details
    and a walkthrough using a toy dataset.'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://github.com/RPegoud/jab?source=post_page-----791d31b4f0dd--------------------------------)
    [## GitHub - RPegoud/jab: A collection of foundational Deep Learning models implemented
    in JAX'
  prefs: []
  type: TYPE_NORMAL
- en: 'A collection of foundational Deep Learning models implemented in JAX - GitHub
    - RPegoud/jab: A collection of‚Ä¶'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: github.com](https://github.com/RPegoud/jab?source=post_page-----791d31b4f0dd--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: If you‚Äôd like to dig deeper into Transformers, the following section contains
    some articles that helped me redact this article.
  prefs: []
  type: TYPE_NORMAL
- en: Until next time üëã
  prefs: []
  type: TYPE_NORMAL
- en: 'References and Resources:'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[1] [***Attention is all you need***](https://arxiv.org/pdf/1706.03762.pdf)
    (2017), Vaswani et al, Google'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] [***What exactly are keys, queries, and values in attention mechanisms?***](https://stats.stackexchange.com/questions/421935/what-exactly-are-keys-queries-and-values-in-attention-mechanisms)*(2019)*Stack
    Exchange'
  prefs: []
  type: TYPE_NORMAL
- en: '[3] [***The Illustrated Transformer***](http://jalammar.github.io/illustrated-transformer/)*(2018),*
    [Jay Alammar](http://jalammar.github.io/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[4] [***A Gentle Introduction to Positional Encoding in Transformer Models***](https://machinelearningmastery.com/a-gentle-introduction-to-positional-encoding-in-transformer-models-part-1/)*(2023),*
    [**Mehreen Saeed**](https://machinelearningmastery.com/author/msaeed/), Machine
    Learning Mastery'
  prefs: []
  type: TYPE_NORMAL
- en: '[***JAX documentation***](https://jax.readthedocs.io/en/latest/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[***Haiku documentation***](https://dm-haiku.readthedocs.io/en/latest/notebooks/basics.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image Credits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Word embeddings](https://developers.google.com/machine-learning/crash-course/embeddings/translating-to-a-lower-dimensional-space?hl=fr),
    developers.google.com'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cat picture, [Karsten Winegeart](https://unsplash.com/fr/photos/bulldog-francese-marrone-che-indossa-una-camicia-gialla-5PVXkqt2s9k),
    Unsplash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Norway landscape, [Pascal Debrunner](https://unsplash.com/fr/photos/corpo-de-agua-perto-da-montanha-LKOuYT5_dyw),
    Unsplash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dog picture, [Loan](https://unsplash.com/fr/photos/chaton-tabby-argente-sur-marbre-7AIDE8PrvA0),
    Unsplash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
