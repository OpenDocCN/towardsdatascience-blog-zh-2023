- en: The Matrix Algebra of Linear Regression in R
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/the-matrix-algebra-of-linear-regression-in-r-b172ee5296e3?source=collection_archive---------12-----------------------#2023-05-10](https://towardsdatascience.com/the-matrix-algebra-of-linear-regression-in-r-b172ee5296e3?source=collection_archive---------12-----------------------#2023-05-10)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explore how to estimate regression parameter using R’s matrix operators
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@dataforyou?source=post_page-----b172ee5296e3--------------------------------)[![Rob
    Taylor, PhD](../Images/5e4e86da7b77404ed42d00a60ea5eacf.png)](https://medium.com/@dataforyou?source=post_page-----b172ee5296e3--------------------------------)[](https://towardsdatascience.com/?source=post_page-----b172ee5296e3--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----b172ee5296e3--------------------------------)
    [Rob Taylor, PhD](https://medium.com/@dataforyou?source=post_page-----b172ee5296e3--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: ·
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F98de080592fc&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fthe-matrix-algebra-of-linear-regression-in-r-b172ee5296e3&user=Rob+Taylor%2C+PhD&userId=98de080592fc&source=post_page-98de080592fc----b172ee5296e3---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----b172ee5296e3--------------------------------)
    ·12 min read·May 10, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fb172ee5296e3&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fthe-matrix-algebra-of-linear-regression-in-r-b172ee5296e3&user=Rob+Taylor%2C+PhD&userId=98de080592fc&source=-----b172ee5296e3---------------------clap_footer-----------)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fb172ee5296e3&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fthe-matrix-algebra-of-linear-regression-in-r-b172ee5296e3&source=-----b172ee5296e3---------------------bookmark_footer-----------)![](../Images/db58cd733b595a3b246084687d7db11e.png)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Photo by [Breno Machado](https://unsplash.com/@brenomachado?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I recently wrote an [article](/the-matrix-algebra-of-linear-regression-6fb433f522d5)
    that explored the matrix algebra and mathematical operations that sit behind linear
    regression. Now, while it’s certainly important to have a firm grasp of theoretical
    principles, nothing actually beats *doing* those calculations. So, in this follow
    up article, we’re going to look at how to implement those matrix operations using
    R.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: This article should be treated as a companion to my earlier [post](/the-matrix-algebra-of-linear-regression-6fb433f522d5),
    so if you haven’t read it already, I encourage you to check it out; however, if
    you haven’t, you’ll still be able to following along.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本文应作为我之前的[文章](/the-matrix-algebra-of-linear-regression-6fb433f522d5)的补充，如果你还没读过这篇文章，我鼓励你去看看；不过即使没读过，你也能继续跟进。
- en: The Data
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据
- en: 'As our working example I’ve chosen the `cars` dataset from the `datasets` package
    in R. It’s nice and simple set of data that comprise stopping distances for cars
    travelling at varying speeds. Accordingly, the dataset contains just two variables:
    `speed` and `dist.` Now, the observations were made during the 1920s so it’s certainly
    not the most current data! Nevertheless, it’s perfect for building a simple linear
    regression model.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们的工作示例，我选择了 R 中 `datasets` 包里的 `cars` 数据集。这是一个简单的数据集，包含了在不同速度下的汽车停止距离。因此，这个数据集包含两个变量：`speed`
    和 `dist`。不过，这些观测数据是1920年代的，因此绝不是最新的数据！尽管如此，它非常适合用来建立一个简单的线性回归模型。
- en: 'First, let’s just take a quick look at the data:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们快速查看一下数据：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There’s nothing complicated here. We have a total of 50 observations and two
    numeric variables. The only point to note, perhaps, is that both `speed` and `dist`
    are integer values. This does introduce some discretisation but that doesn’t matter
    so much for now.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么复杂的。我们共有50个观测值和两个数值变量。需要注意的一点是 `speed` 和 `dist` 都是整数值。这确实引入了一些离散化，但目前这不太重要。
- en: To get a sense of the relationship between `dist` and `speed,` below I’ve plotted
    stopping distance as a function of speed. There’s a decent positive association
    between these variables suggesting that stopping distances *increase* with higher
    speeds. I’ve also overlayed the best fitting regression line using ggplot’s `geom_smooth`
    function.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解 `dist` 和 `speed` 之间的关系，下面我绘制了停止距离与速度的关系图。这些变量之间存在较强的正相关，表明停止距离随着速度的*增加*而增加。我还使用
    ggplot 的 `geom_smooth` 函数叠加了最佳拟合回归线。
- en: Our goal, then, is to estimate the parameters of this line *without* using the
    inbuilt `lm` function. Instead, we’re going to apply matrix operations to obtain
    regression coefficients and then generate fitted values that should fall along
    this line.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的目标是*不*使用内置的 `lm` 函数来估计这条直线的参数。相反，我们将应用矩阵运算来获得回归系数，然后生成应当落在这条直线上的拟合值。
- en: '![](../Images/ecde3aaf52c5f24e897d7e5b79fed328.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ecde3aaf52c5f24e897d7e5b79fed328.png)'
- en: Plot of the stopping distance as a function of speed. From the cars dataset
    in R (image by author).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个展示停止距离与速度关系的图。数据来源于 R 的汽车数据集（图片由作者提供）。
- en: A Quick Review
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简要回顾
- en: It’s worth reminding ourselves what we’re actually aiming to do. To that end,
    we are attempting to model a response vector *Y* containing *n* observations as
    a weighted linear combination of *m* predictor variables plus an intercept term.
    For the example data here we only have a single predictor, `speed,`so we can let
    *m =* 1.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 值得提醒自己我们实际的目标是什么。为此，我们试图将包含 *n* 个观测值的响应向量 *Y* 建模为 *m* 个预测变量的加权线性组合，加上一个截距项。对于这里的示例数据，我们只有一个预测变量
    `speed`，因此我们可以设定 *m =* 1。
- en: 'The predictor and intercept together form an *n* × *p* design matrix, where
    *p = m + 1* reflectsthe number of unknown regression coefficients in the model
    which must be estimated from data. Estimation requires finding a solution to the
    following *normal equation*:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 预测变量和截距项共同形成一个 *n* × *p* 设计矩阵，其中 *p = m + 1* 反映了模型中需要从数据中估计的未知回归系数的数量。估计需要找到以下*正规方程*的解：
- en: '![](../Images/b1d44c78834574b4e7515cae3829549b.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b1d44c78834574b4e7515cae3829549b.png)'
- en: The normal equation (image by author).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 正规方程（图片由作者提供）。
- en: 'Rearranging the equation to solve for the unknown coefficients, we arrive at
    the following solution:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 重新排列方程以求解未知系数，我们得到以下解：
- en: '![](../Images/83c7b142968ce142f76bbd673a288b5b.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/83c7b142968ce142f76bbd673a288b5b.png)'
- en: Estimation equation (image by author).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 估计方程（图片由作者提供）。
- en: where **b** is a *p*-dimensional vector containing the best fitting regression
    coefficients.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 **b** 是一个 *p* 维向量，包含最佳拟合的回归系数。
- en: In approaching this problem, I’m going to break down the estimation equation
    into parts that each deal with a different operation, before bringing them back
    together to estimate the model parameters. In effect, there are three operations
    we need to do, each of which returns a matrix we need to use at some point.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决这个问题时，我将把估计方程分解成处理不同操作的部分，然后再将它们合并以估计模型参数。实际上，我们需要做三个操作，每个操作返回一个我们在某个时候需要使用的矩阵。
- en: Matrix Operations in R
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: R 中的矩阵运算
- en: Before diving in, I’ll just quickly review the matrix operations that we’ll
    be using. There are only *three* operations that are important for this example.
    The first is *matrix multiplication*. If you haven’t already come across this,
    matrix multiplication in R is performed using the `%*%` operator. The second operation
    involves finding the *inverse of a matrix*, which in R is done using the `solve`
    function (no, we won’t be doing this part by hand!). The final operation is `t,`
    which is the *transpose* operator.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究之前，我将快速回顾一下我们将要使用的矩阵运算。这个例子中只有 *三* 个重要的操作。第一个是 *矩阵乘法*。如果你还没有接触过这个，R 中的矩阵乘法是使用
    `%*%` 运算符来执行的。第二个操作涉及求 *矩阵的逆*，在 R 中使用 `solve` 函数来完成（不，我们不会手动完成这部分！）。最后一个操作是 `t`，这是
    *转置* 操作符。
- en: Setting Up
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置
- en: 'First, we need to define a *response vector* and create the *design matrix*.
    For our toy example, we’re modelling distance as a function of speed, so therefore
    `dist` is our *response variable*. Let’s assign those values its own vector called
    `y_vec`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要定义一个 *响应向量* 并创建 *设计矩阵*。对于我们的示例，我们将距离建模为速度的函数，因此 `dist` 是我们的 *响应变量*。让我们为这些值分配一个名为
    `y_vec` 的向量：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note the `$` is used here to access the `dist`column in the `cars` data frame.
    I find that this method isn’t always convenient, or tidy, so you’ll see that I
    soon switch to using `with` for some calculations.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这里使用 `$` 访问 `cars` 数据框中的 `dist` 列。我发现这种方法并不总是方便或整洁，因此你会看到我很快转而使用 `with`
    进行一些计算。
- en: 'We next need to assign `speed` to the design matrix, which can be done using
    the `model.matrix` function. Here I’m creating a variable called `x_mat`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要使用 `model.matrix` 函数将 `speed` 分配给设计矩阵。在这里，我创建了一个名为 `x_mat` 的变量：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note that the call to `model.matrix` is very similar to an `lm` function call.
    There’s obviously a good reason for that, but here the formula just lets `model.matrix`
    know that `speed` is a predictor variable. Let’s just take a quick look at what
    this produces:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对 `model.matrix` 的调用与 `lm` 函数调用非常相似。显然，这样做有一个很好的理由，但在这里公式只是让 `model.matrix`
    知道 `speed` 是一个预测变量。让我们快速看一下它产生了什么：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can see that we have *two* columns: one for our `speed` variable and another
    containing only ones. Recall that the design matrix includes an additional column
    to accomodate the intercept term.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们有 *两* 列：一个是我们的 `speed` 变量，另一个只包含 `1`。回顾一下，设计矩阵包括一个额外的列以容纳截距项。
- en: Now that we have `y_vec` and `x_mat` loaded into our workspace, we can move
    onto the matrix operations.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经将 `y_vec` 和 `x_mat` 加载到我们的工作空间中，我们可以继续进行矩阵运算。
- en: Step 1
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤 1
- en: If we look at the right hand side of the estimation equation, the first term
    is the inverse of the design matrix multiplied by itself. I’m going to deal with
    the inverse in Step 2, so we first need to compute *X*ᵀ*X.*
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们观察估计方程的右手边，第一项是设计矩阵的逆与其自身的乘积。在步骤2中，我们将处理逆，因此我们首先需要计算 *X*ᵀ*X*。
- en: 'For our simple linear regression model here, *X*ᵀ*X* will be square 2 × 2 matrix.
    For practical purposes I’m just going to denote this as matrix *A*. Using the
    matrix multiplication, `%*%,`and transpose, `t` , operators to compute this matrix,
    I’ll assign the output to an object called `A`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的简单线性回归模型，*X*ᵀ*X* 将是一个 2 × 2 的方阵。出于实际目的，我将简单地将其表示为矩阵 *A*。使用矩阵乘法 `%*%` 和转置
    `t` 运算符来计算这个矩阵，我将将输出赋值给一个叫做 `A` 的对象：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, in my earlier post we learned a little bit about the elements contained
    in this matrix by working through the matrix operations. I won’t revisit those
    specific details here and will just note the result below:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我之前的帖子中，我们通过矩阵运算了解了这个矩阵中包含的元素的一些信息。我不会在这里重新讨论具体细节，只是将结果如下记录：
- en: '![](../Images/b1682048cb8a51d79ef59ef220e99985.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b1682048cb8a51d79ef59ef220e99985.png)'
- en: The cross product of the design matrix (image by author).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 设计矩阵的交叉乘积（作者提供的图片）。
- en: We can see that each element in *A* is quite easy to interpret, and indeed compute.
    Notice that *a₁₁* is just the total number of observations, *n,* which is 50 for
    the `cars` dataset. The elements along the minor diagonal, *a₁₂* and *a₂₁,* are
    just the sum of `speed`, while *a₂₂* is the sum of `speed` squared.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do some quick checks to verify that our object `A` does indeed contain
    these values. Let’s first print `A` to see what we have:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The value at `A[1,1]` matches the total number of observations in `cars` so
    we’re off to a good start. We can next check the values in `A[1,2]` and `A[2,1]`
    by simply summing `speed:`
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Another match — things are looking good! Finally, we can check the value in
    `A[2,2]` by computing the square of `speed` and summing those values:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That’s correct, too!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Step 2
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step is to find the *inverse* of the matrix *XᵀX*. In R, we use the
    `solve` function to perform this operation on `A.` Let’s do that first and assign
    the output to an object called `A_inv:`
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, before we take a look at `A_inv` lets first examine the solution for the
    inverse of *XᵀX:*
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/936f0f5ae04f7aeb3071c1cb3b4ece9c.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: The inverse of the design matrix cross product (image by author).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: If we ignore the first term for now, then what we see is that some of the elements
    in the original matrix *A* have been swapped around, while others have been transformed
    slightly. Specifically, elements *a₁₂* and *a₂₁* have had their signs reversed
    and now reflect the *negative* sum of `speed` . Also, the values at *a₁₁* and
    *a₂₂* in the original matrix have swapped locations, so now *a₂₂* is the total
    number of observations and *a₁₁* is thesum of `speed` squared.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s compile a matrix that contains these adjusted elements and assign it
    to an object called `A_rev` , then check that everything worked:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Everything looks good! We can now multiply `A_rev` by the first term which is
    a *scalar constant* equal to the reciprocal of *n* times the sum of squared deviations
    around the mean of `speed.` Let’s quickly compute the constant term by creating
    a variable called `c:`
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'I won’t print this out because it’s an exceedingly small value. All that’s
    left to do now is to multiply `c` and `A_rev` together and see what we get:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let’s now compare these values to the solution we got using `solve` by printing
    `A_inv` to the console:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Fantastic — each element in `A_inv` matches with its corresponding element in
    `A_rev.`
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving on to the next step there is one additional check we could do.
    If for some reason we were suspicious that the output from `solve` was errant
    in some way, we can lean on the fact that any *n* × *n* square matrix *A* is considered
    *invertible* if and only if there exists another square *n* × *n* matrix *B* that
    results in the following identity:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6a845c04b13e0f9540be32cbc3ce0519.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
- en: Condition for matrix invertibility (image by author).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'What this implies is, if `A_inv` is indeed the multiplicative inverse of `A`
    then, if we multiply `A` and `A_inv` together, we should get back the *identity
    matrix*:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It’s looks like the `solve` function is doing sensible things.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'Just a note before moving on: these checks on the matrix outputs are not at
    all necessary for any practical purpose. Rather, what I’m hoping to do by including
    these little tests is further enhance your understanding about these concepts
    by actually putting the mathematics into action.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Step 3
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have the inverse of *XᵀX* taken care of, we can shift our attention
    to the last term in the estimation equation: *XᵀY.* This operation involves multiplying
    the *design matrix* with the *response vector.* Given the data we’re working with,
    this computation will produce a *p × 1* vector that we’ll simply denote as *B*.
    Again, we’ll just apply the matrix multiplication operator and assign the output
    to a variable, though this time we call the variable `B:`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As we’ve done above, let’s consider what the expected output of this operation
    is:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/694d2c7c07ee8921b843d9a6cd10f55d.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
- en: The cross product of the design matrix with the response vector (image by author).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Again, we have some elements that are fairly easy to intuit. One is simply the
    sum of the response variable `dist` and the other is just the sum of the product
    of `speed` and `dist.` Let’s quickly compute those values and see whether they
    match up with the values already stored in `B:`
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We have a match!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Parameter Estimation
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Alright. We now have everything we need to estimate the model coefficients.
    In fact, the only objects we need are `A_inv` and `B,` and all we need to do is
    multiply these together:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let’s print this to the console and see what we have:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Taking a quick look at the slope parameter, we’ve got a positive value. This
    is a good sign given the positive association observed earlier and hopefully means
    we’re on the right track. Let’s now see how these estimates compare to the coefficients
    returned using the `lm` function:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Identical!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s just one last thing I want to point out. I demonstrated in my earlier
    post that if you do some algebra with the estimation equation you arrive at a
    very convenient solution. That is, the slope parameter is equivalent to:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/34ab197a6dc7deb317ffcd1787e9a765.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: The slope parameter (image by author).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'and the intercept parameter is equivalent to:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/80d70d35f595c980c8a328469c442ee2.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
- en: The intercept parameter (image by author).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Both these are very straightforward to compute and can be done in R as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Printing these objects to console shows that we get the same parameter values:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Interpreting the Coefficients
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Looking at our estimates, we can see that we have a negative intercept term
    which doesn’t make much sense. The intercept here is the value of `dist` when
    `speed` is set to zero, implying that when the vehicle has zero speed — i.e.,
    it’s *stantionary* — it has a *negative* stopping distance. I’m not going to address
    that issue here, so for now we’ll leave this alone and just accept that this is
    reasonable (it’s not, though).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: The slope parameter, on the other hand, is certainly more useful. What this
    indicates is that for every unit *increase* in speed (which is in miles per hour)
    the stopping distance *increase* by nearly 4 feet. So, if a vehicle increases
    its speed from 10mph to 11mph, the distance required to stop jumps from 21.7ft
    to 25.7ft. However, the same increase in stopping distance would also be expected
    if the car increased its speed from 60mph to 61mph, which might not be as reasonable.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Computing the Fitted Values
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last thing we need to do is compute the fitted values. To do so, we just
    grab our parameter estimates held in `b_vec` and multiply those with the design
    matrix:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: I have also computed the error vector in the above code, but this is just to
    show you how, more than anything. We’re not going to be doing anything with those
    values here.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'The very last thing we can do is overlay our fitted values on the plot we produced
    earlier. All things being good, we should see that our fitted values fall nicely
    along the regression line:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c01051643702151c2b223a07e79f0e53.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: Overlaying the fitted values on the plot produced earlier (image by author).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: And indeed they do.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Up
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The focus here has very much been on parameter estimation so there is much I
    haven’t touched on. For example, model diagnostics, computing standard errors
    for the parameter estimates, and model fit measures like the coefficient of determination,
    *R²*. Because this post is intended to be a companion to my earlier article I
    wanted to avoid introducing new concepts here, but I’ll cover those concepts another
    time. Nevertheless, I hope this article helps you along your linear algebra journey
    in some way. If you want to check out the code used in this article its available
    at my [Git](https://github.com/dataforyounz/matrix-regression-in-r) page.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Related Articles
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[The Matrix Algebra of Linear Regression](/the-matrix-algebra-of-linear-regression-6fb433f522d5)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A Primer on Linear Algebra](https://medium.com/towards-data-science/a-primer-on-linear-algebra-414111d195ca)'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A [Primer on Linear Algebra: Part 2](https://medium.com/towards-data-science/a-primer-on-linear-algebra-part-2-eba53c564a90)'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Multicollinearity: Problem, or Not?](https://medium.com/towards-data-science/multicollinearity-problem-or-not-d4bd7a9cfb91)'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thanks for reading!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: If you enjoyed this post and would like to stay up to date then please consider
    [following me on Medium.](https://medium.com/@dataforyou) This will ensure you
    don’t miss out on any new content.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: To get unlimited access to all content consider signing up for a [Medium subscription](https://medium.com/membership).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取对所有内容的无限访问权限，请考虑订阅 [Medium](https://medium.com/membership)。
- en: You can also follow me on [Twitter](https://twitter.com/dataforyounz), [LinkedIn](https://www.linkedin.com/in/dataforyou/),
    or check out my [GitHub](https://github.com/dataforyounz) if that’s more your
    thing.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在 [Twitter](https://twitter.com/dataforyounz)、[LinkedIn](https://www.linkedin.com/in/dataforyou/)
    上关注我，或者查看我的 [GitHub](https://github.com/dataforyounz)，如果你更喜欢这样的话。
