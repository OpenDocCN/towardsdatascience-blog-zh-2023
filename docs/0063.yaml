- en: Validate Balanced Parenthesis using SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/validate-balanced-parenthesis-using-sql-5bb79732d772?source=collection_archive---------22-----------------------#2023-01-04](https://towardsdatascience.com/validate-balanced-parenthesis-using-sql-5bb79732d772?source=collection_archive---------22-----------------------#2023-01-04)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Check the well-formed-ness of a string containing open and close parenthesis
    using just SQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@dhruvbird?source=post_page-----5bb79732d772--------------------------------)[![Dhruv
    Matani](../Images/d63bf7776c28a29c02b985b1f64abdd3.png)](https://medium.com/@dhruvbird?source=post_page-----5bb79732d772--------------------------------)[](https://towardsdatascience.com/?source=post_page-----5bb79732d772--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----5bb79732d772--------------------------------)
    [Dhruv Matani](https://medium.com/@dhruvbird?source=post_page-----5bb79732d772--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F63f5d5495279&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fvalidate-balanced-parenthesis-using-sql-5bb79732d772&user=Dhruv+Matani&userId=63f5d5495279&source=post_page-63f5d5495279----5bb79732d772---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----5bb79732d772--------------------------------)
    ·5 min read·Jan 4, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F5bb79732d772&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fvalidate-balanced-parenthesis-using-sql-5bb79732d772&user=Dhruv+Matani&userId=63f5d5495279&source=-----5bb79732d772---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F5bb79732d772&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fvalidate-balanced-parenthesis-using-sql-5bb79732d772&source=-----5bb79732d772---------------------bookmark_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: Validating if a string contains balanced parenthesis is a practical problem
    resulting from string/expression parsing/validation in various practical scenarios.
    In this article, we look at how to validate such a string containing only open
    ‘(’ and close ‘)’ parenthesis using just declarative SQL.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d2fee6c8922213106725258d8446a8ab.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Elena Mozhvilo](https://unsplash.com/@miracleday?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: 'Previous Article: [Longest Increasing Subsequence of an array in SQL](https://medium.com/@dhruvbird/longest-increasing-subsequence-of-an-array-in-sql-3202888c637f)'
  prefs: []
  type: TYPE_NORMAL
- en: Problem Statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given a string containing only open and closed parenthesis, can you determine
    if these parenthesis are balanced? Being balanced means:'
  prefs: []
  type: TYPE_NORMAL
- en: Every open parenthesis ‘(’ has exactly one closing parenthesis ‘)’ after it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A closing parenthesis ‘)’ is always matched with exactly one open parenthesis
    ‘(’ that appears before it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following are examples of **valid** balanced parenthesis strings:'
  prefs: []
  type: TYPE_NORMAL
- en: ((()()))
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ()()()()
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (()()(()()))
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following are example of **invalid** balanced parenthesis:'
  prefs: []
  type: TYPE_NORMAL
- en: ((()( — here, the first 2 and the last open parenthesis don’t have a matching
    closing parenthesis
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ()()()()) — here, the last closing parenthesis doesn’t match any other unmatched
    open parenthesis
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Online coverage of the problem statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Bradfield CS](https://bradfieldcs.com/algos/stacks/balanced-parentheses/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Leetcode](https://leetcode.com/problems/valid-parentheses/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Geeksforgeeks](https://www.geeksforgeeks.org/check-for-balanced-parentheses-in-an-expression/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Input Table Schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The input table has 2 columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**idx:** The problem index. i.e. the 1st string to check will have idx = 1,
    the 2nd string to check will have idx = 2, and so on.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**parens:** A string containing only open and close parenthesis. This string
    needs to be checked for well-formedness.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/c9a13d40328fc769891665fb2137c855.png)'
  prefs: []
  type: TYPE_IMG
- en: The input table for the balanced parenthesis problem (Image by author)
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution: Maintain a running counter: O(n)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In imperative programming languages, this problem is usually solved by maintaining
    a stack which receives an ‘(’ every time it is encountered in the input string.
    Hence, the stack contains only ‘(’ characters. Every time a ‘)’ is seen in the
    input, it is matched with an ‘(’ on the top of the stack, and the ‘)’ character
    is popped off.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have **only one type of open (and close) brackets**, we can eliminate
    the stack and **maintain just a counter**, which counts how many unmatched ‘(’
    characters have been seen so far. Every time an ‘(’ character is encountered,
    we increment the counter, and every time a ‘)’ character is encountered, we decrement
    the counter.
  prefs: []
  type: TYPE_NORMAL
- en: '**Negative counter value:** If the counter ever reaches a negative (< 0) value,
    it indicates an unmatched closing parenthesis.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Final counter value:** After all the characters in the input string are processed,
    if the value of the counter is != 0, it indicates a problem. A positive value
    indicates an unmatched ‘(’ character in the input, and a negative value is already
    considered above.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The SQL code for this solution looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There are quite a few intermediate tables used in the solution above to aid
    readability and to separate out the various processing steps.
  prefs: []
  type: TYPE_NORMAL
- en: This is the first time we have used the [UNNEST](https://www.postgresql.org/docs/9.2/functions-array.html)
    keyword in SQL. This is also the first time I’ve written a solution that batch-processes
    multiple inputs and solves them at once. I leverage the **idx** field which indicates
    the index of the input string. All intermediate tables use the **idx** field to
    separate out solutions to different problems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e14566348e6942080cd3bc54742515d8.png)'
  prefs: []
  type: TYPE_IMG
- en: The result of the O(n) solution (Image by author)
  prefs: []
  type: TYPE_NORMAL
- en: '**Estimated Cost:** The estimated cost for this query on a table with 5 distinct
    input rows is [45k](https://explain.depesz.com/s/mN2y). Most of this cost seems
    to be coming from the use of the window aggregation functions.'
  prefs: []
  type: TYPE_NORMAL
- en: While I’ve tagged the runtime to be **O(n)**, it would depend on how the database
    engine internally executes the query. For example, if the engine notices that
    the assignment of the **row_num** column using **ROW_NUMBER()** results in rows
    that have a strictly increasing value for that column, and the database is able
    to preserve that row order across CTE tables, then it can avoid doing a sort later
    when it encounters an **ORDER BY** clause in the window function execution here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The **ORDER BY** in the **OVER()** clause above is essential to ensure that
    we get a running sum, and not an overall sum for the entire partition.
  prefs: []
  type: TYPE_NORMAL
- en: SQL Fiddle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The SQL Fiddle link to the solution in this post can be found [here](http://sqlfiddle.com/#!17/e83e88/20).
  prefs: []
  type: TYPE_NORMAL
- en: Extensions and exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if we have more than one type of parenthesis such as square brackets [],
    curly braces {}. How would you evolve the solution to account for this change?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What if the string that make up the open and close bracket pairs were not fixed
    but specified in another dimension table. How would you evolve the solution to
    account for this change?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We shall see (in later posts) how these extensions solve real-world and practical
    problems encountered by SQL practitioners.
  prefs: []
  type: TYPE_NORMAL
