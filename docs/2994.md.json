["```py\nsolve_tsp(distances: np.ndarray) -> List[int]\n```", "```py\ntsp-app/\n│\n├── .streamlit/                # General streamlit configuration\n│   └── config.toml\n│\n├── data/                      # Directory for data if any\n│   ├── dataset.csv\n│   └── ...\n│\n├── assets/                    # These will be referenced in the app\n│   ├── dataset.csv\n│   └── ...\n│\n├── optimizer/                 # TSP optimizer internal package\n│   ├── __init__.py\n│   └── ...\n│\n├── app.py                     # Main Streamlit script\n│\n├── Dockerfile                 # Docker configuration file\n├── .dockerignore\n│\n├── .gitignore                 # File ignored in Git\n├── requirements.txt           # Python dependencies\n└── README.md                  # Project description\n```", "```py\n...\n├── optimizer/                 # TSP optimizer internal package\n│   ├── __init__.py\n│   └── ...\n│\n├── interface/                 # Utility functions for the interface\n│   ├── __init__.py\n│   └── ...\n│\n├── app.py                     # Main Streamlit script\n...\n```", "```py\npip install -r requirements.txt\n```", "```py\npip install --no-deps ortools==9.7.2996\n```", "```py\nstreamlit run app.py\n```", "```py\ndocker build -t tsp_app:latest .\n```", "```py\ndocker run -p 8501:8501 tsp_app:latest\n```", "```py\nImports\n\nDefinition of utility functions (could have been in a separate file)\nDeclaring constants\nDeclaring default session_state attributes\nParsing solver parameters\nParsing input file\n\nif input is not None:\n    read (and cache) input data\n\n    if execute button is pressed:\n        solve model based on input\n        store solution as a session_state attribute\n\nif solution is not None:\n    make output available\n    plot results\n```", "```py\n[theme]\nprimaryColor = \"#5300A5\"\nbackgroundColor = \"#403E43\"\nsecondaryBackgroundColor = \"#1C1B1E\"\ntextColor = \"#F5F3F7\"\nfont = \"sans serif\"\nbase = \"dark\"\n```", "```py\nimport os\nfrom io import BytesIO\nimport json\nfrom typing import List\n\nimport pandas as pd\nfrom pyomo.contrib.appsi.solvers.highs import Highs\nimport streamlit as st\nfrom streamlit_folium import st_folium\n\nfrom optimize.tsp import get_distance_xy, build_mip, solve_mip, TSP, plot_tour, request_matrix,\\\n    plot_map, get_coord_path\n```", "```py\n# Create current solution as session_state\nif \"tour\" not in st.session_state:\n    st.session_state.tour = None\n\nif \"dataframe\" not in st.session_state:\n    st.session_state.dataframe = None\n\nif \"sol\" not in st.session_state:\n    st.session_state.sol = None\n\nif \"route_path\" not in st.session_state:\n    st.session_state.route_path = None\n```", "```py\n# Finds distance matrix\n@st.cache\ndef driving_distances(dataframe: pd.DataFrame):\n    return request_matrix(dataframe)[\"distances\"] / 1000\n\n# Callback uploading a new file\ndef upload_callback():\n    st.session_state.tour = None\n    st.session_state.sol = None\n    st.session_state.route_path = None\n\n# Update route path after solution\ndef update_path(tour: List[int], dataframe: pd.DataFrame):\n    coord_rt = dataframe.loc[tour, :]\n    path = get_coord_path(coord_rt)\n    st.session_state.route_path = path\n```", "```py\n# Path to icon\nicon_path = os.path.join(\"assets\", \"icon_tsp.png\")\n\n# Set the page config to wide mode\nst.set_page_config(\n    page_title=\"TSP\",\n    page_icon=icon_path,\n    layout=\"wide\",\n)\n\nst.sidebar.image(icon_path)\n\nst.title(\"TSP\")\nst.write(\"Welcome to the Traveling Salesman Problem solver.\")\n```", "```py\ndisplay_tutorial = st.checkbox(\"Display tutorial\")\nif display_tutorial:\n    section = st.selectbox(\"Choose a section\", [\"Execution\", \"Solutions\", \"Contact\"], index=1)\n    tutorial = read_section(section)\n    st.markdown(tutorial)\n```", "```py\nproblem_type = st.sidebar.selectbox(\"Choose an input type:\", [\"xy\", \"lat-long\"], index=0)\nmethod = st.sidebar.selectbox(\"Choose a strategy:\", [\"MIP\", \"Heuristic\"], index=0)\ntime_limit = st.sidebar.number_input(\"Time limit\", min_value=0, value=5, step=1)\n```", "```py\nfile = st.file_uploader(\"Upload input file\", type=[\"csv\"], on_change=upload_callback)\n```", "```py\nif file is not None:\n    dataframe = pd.read_csv(file)\n    st.session_state.dataframe = dataframe\n    distances = FORMATS[problem_type](dataframe)\n    start_button = st.button(\"Optimize\")\n```", "```py\nFORMATS = {\n    \"xy\": get_distance_xy,\n    \"lat-long\": driving_distances\n}\n```", "```py\n# Run if start is pressed\nif file is not None and start_button:\n\n    # Solve MIP\n    if method == \"MIP\":\n        solver = Highs()\n        solver.highs_options = {\"time_limit\": time_limit}\n        model = build_mip(distances)\n        tour = solve_mip(model, solver)\n        st.session_state.tour = tour\n\n    # Solve Heuristic\n    elif method == \"Heuristic\":\n        model = TSP(distances)\n        tour = model.solve(time_limit=time_limit)\n        st.session_state.tour = tour\n\n    # Display the results\n    sol = model.obj()\n    st.session_state.sol = sol\n\n    # Update path in case of lat-long\n    if problem_type == \"lat-long\":\n        update_path(tour, dataframe)\n```", "```py\n# Compute current state variables\nsol = st.session_state.sol\ntour = st.session_state.tour\ndataframe = st.session_state.dataframe\n\nif sol is not None and tour is not None:\n    col_left, col_right = st.columns(2)  # Divide space into two columns\n    col_left.write(f\"Current solution: {sol:.3f}\")\n    col_right.download_button(\n        label=\"Download Output\",\n        data=json.dumps(tour),\n        file_name='output.json',\n        mime='json',\n    )\n```", "```py\nbuffer = BytesIO()\nwith pd.ExcelWriter(buffer) as writer:\n    for name, df in dataframes.items():\n        df.to_excel(writer, sheet_name=name)\n\nst.download_button(\n    label=\"Download Output\",\n    data=buffer,\n    file_name='output.xlsx',\n    mime='xlsx',\n)\n```", "```py\nf\"https://router.project-osrm.org/table/v1/driving/{points}?sources={sources_str}&destinations={dest_str}&annotations={annotations}\"\n```", "```py\ndef get_request_points(coordinates: pd.DataFrame) -> List[str]:\n    return coordinates.apply(lambda x: f\"{x['long']},{x['lat']}\", axis=1).to_list()\n\ndef get_coord_path(coordinates: pd.DataFrame) -> List[Tuple[float, float]]:\n    pts = get_request_points(coordinates)\n    pts_req = \";\".join(pts)\n    r = session.get(\n        f\"http://router.project-osrm.org/route/v1/car/{pts_req}?overview=false&steps=true\"\n    )\n    result = r.json()\n    first_route = result[\"routes\"][0]\n    coords = [(p[\"location\"][1], p[\"location\"][0])\n              for l in first_route[\"legs\"]\n              for s in l[\"steps\"]\n              for p in s[\"intersections\"]]\n    return coords\n```", "```py\ndef plot_map(\n    path: List[Tuple[float, float]],\n    color: Union[str, tuple] = \"darkblue\",\n    zoom_start=8,\n    **kwargs\n):\n    # Coordinates from path\n    lat, long = zip(*path)\n\n    # Create map\n    m = folium.Map(zoom_start=zoom_start)\n    new_line = folium.PolyLine(\n        path, weight=4, opacity=1.0,\n        color=color, tooltip=f\"Route\",\n        **kwargs\n    )\n    new_line.add_to(m)\n\n    # Trim zoom\n    sw = [min(lat), min(long)]\n    ne = [max(lat), max(long)]\n\n    m.fit_bounds([sw, ne])\n    return m\n```", "```py\nif tour is not None and dataframe is not None:\n\n    # Plot solution\n    if problem_type == \"xy\":\n        pass  # Not really in the app, but skipping here\n\n    elif problem_type == \"lat-long\":\n        map = plot_map(st.session_state.route_path)\n        st_folium(map, width=700, height=500, returned_objects=[])\n```"]