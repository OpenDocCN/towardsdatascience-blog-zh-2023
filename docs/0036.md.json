["```py\ndef download_road_network(place_name, network_type='drive'):\n    graph = ox.graph_from_place(place_name, network_type=network_type, \n                                simplify=False)\n    graph = ox.add_edge_speeds(graph)\n    graph = ox.add_edge_travel_times(graph)\n    graph = ox.bearing.add_edge_bearings(graph)\n    return graph\n```", "```py\nroad_network = download_road_network(\"Ann Arbor, Michigan, USA\")\n```", "```py\nnetwork_utm = ox.projection.project_graph(road_network)\n```", "```py\neasting, northing, zone_num, zone_ltr = utm.from_latlon(42.287702, -83.707775)\nedge_id = ox.distance.nearest_edges(network_utm, easting, northing)\n```", "```py\nnetwork_utm[edge_id[0]][edge_id[1]][0]\n```", "```py\n{'osmid': 8723817,\n 'oneway': False,\n 'lanes': '2',\n 'highway': 'tertiary',\n 'reversed': True,\n 'length': 116.428,\n 'speed_kph': 48.3,\n 'travel_time': 8.7,\n 'bearing': 267.3,\n 'name': 'Glazier Way',\n 'maxspeed': '30 mph'}\n```", "```py\nclass RoadNetwork(object):\n\n    def __init__(self, graph, projected=False):\n        self.graph = graph\n        self.projected = projected\n        self.max_edge_length = max([graph[e[0]][e[1]][0][\"length\"] \\\n                                    for e in graph.edges])\n        self.ids, self.locations = self.get_locations()\n        self.geo_spoke = GeoSpoke(self.locations)\n# more...\n```", "```py\n def get_locations(self):\n        latitudes = []\n        longitudes = []\n        ids = []\n        for n in self.graph.nodes:\n            ids.append(n)\n            node = self.graph.nodes[n]\n            longitudes.append(node['x'])\n            latitudes.append(node['y'])\n\n        locations = np.array(list(zip(latitudes, longitudes)))\n        return np.array(ids), locations\n# more...\n```", "```py\ndef get_matching_edge(self, latitude, longitude, bearing=None):\n    loc = np.array([latitude, longitude])\n    _, r = self.geo_spoke.query_knn(loc, 1)\n    radius = self.max_edge_length + r[0]\n    node_idx, dists = self.geo_spoke.query_radius(loc, radius)\n    nodes = self.ids[node_idx]\n    distances = dict(zip(nodes, dists))\n    adjacent_set = set()\n    graph = self.graph\n\n    best_edge = None\n    for node in nodes:\n        if node not in adjacent_set:\n            adjacent_nodes = np.intersect1d(np.array(graph.adj[node]),\n                                            nodes, assume_unique=True)\n\n            adjacent_set.update(adjacent_nodes)\n            for adjacent in adjacent_nodes:\n                edge_length = graph[node][adjacent][0]['length']\n                ratio = (distances[node] + distances[adjacent]) / \\\n                        edge_length\n                if best_edge is None or ratio < best_edge[2]:\n                    best_edge = (node, adjacent, ratio)\n\n        if bearing is not None:\n            best_edge = fix_edge_bearing(best_edge, bearing, graph)\n    return best_edge\n```", "```py\ndef fix_edge_bearing(best_edge, bearing, graph):\n    if (best_edge[1], best_edge[0], 0) in graph.edges:\n        bearing0 = radians(graph[best_edge[0]][best_edge[1]][0]['bearing'])\n        bearing1 = radians(graph[best_edge[1]][best_edge[0]][0]['bearing'])\n        gps_bearing = radians(bearing)\n        if cos(bearing1 - gps_bearing) > cos(bearing0 - gps_bearing):\n            best_edge = (best_edge[1], best_edge[0], best_edge[2])\n    return best_edge\n```", "```py\ndef get_nearest_edge(self, latitude, longitude, bearing=None):\n    best_edge = None\n    adjacent_set = set()\n    graph = self.graph\n\n    loc = np.array([latitude, longitude])\n    _, r = self.geo_spoke.query_knn(loc, 1)\n    radius = self.max_edge_length + r[0]\n    node_idx, dists = self.geo_spoke.query_radius(loc, radius)\n    nodes = self.ids[node_idx]\n    distances = dict(zip(nodes, dists))\n\n    for node in nodes:\n        if node not in adjacent_set:\n            adjacent_nodes = np.intersect1d(np.array(graph.adj[node]),\n                                            nodes, assume_unique=True)\n\n            adjacent_set.update(adjacent_nodes)\n            for adjacent in adjacent_nodes:\n                a = distances[node]\n                b = graph[node][adjacent][0]['length']\n                c = distances[adjacent]\n\n                a2, b2, c2 = a * a, b * b, c * c\n\n                if c2 > a2 + b2 or a2 > b2 + c2:\n                    distance = min(a, c)\n                else:\n                    area = heron_area(a, b, c)\n                    distance = area * 2.0 / b\n\n                if best_edge is None or distance < best_edge[2]:\n                    best_edge = (node, adjacent, distance)\n\n    if bearing is not None:\n        best_edge = fix_edge_bearing(best_edge, bearing, graph)\n    return best_edge\n```", "```py\n@njit()\ndef heron_area(a, b, c):\n    c, b, a = np.sort(np.array([a, b, c]))\n    return sqrt((a + (b + c)) *\n                (c - (a - b)) *\n                (c + (a - b)) *\n                (a + (b - c))) / 4.0\n```"]