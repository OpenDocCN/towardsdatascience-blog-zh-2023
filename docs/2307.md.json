["```py\nclass MobileNetV3Backbone(nn.Module):\n    def __init__(self, backbone):\n        super().__init__()\n        self.backbone = backbone\n\n    def forward(self, x):\n        \"\"\" Passes input theough MobileNetV3 backbone feature extraction layers\n            layers to add connections to\n                - 1:  1/4 res\n                - 3:  1/8 res\n                - 7, 8:  1/16 res\n                - 10, 11: 1/32 res\n           \"\"\"\n        skips = nn.ParameterDict()\n        for i in range(len(self.backbone) - 1):\n            x = self.backbone[i](x)\n            # add skip connection outputs\n            if i in [1, 3, 7, 8, 10, 11]:\n                skips.update({f\"l{i}_out\" : x})\n\n        return skips\n```", "```py\nfrom torchvision.models import mobilenet_v3_small\n\nmobilenet = mobilenet_v3_small(weights='IMAGENET1K_V1')\n\nencoder = MobileNetV3Backbone(mobilenet.features)\ndecoder = LightWeightRefineNet(num_seg_classes)\nmodel = MultiTaskNetwork(encoder, freeze_encoder=False).to(device)\n```", "```py\n# find optimal backend for performing convolutions \ntorch.backends.cudnn.benchmark = True \n\n# rescale to half size\nrescaled_sample = Rescale(400, 1024)(sample)\nrescaled_left = rescaled_sample['left'].to(DEVICE)\n\n# INIT LOGGERS\nstarter, ender = torch.cuda.Event(enable_timing=True), torch.cuda.Event(enable_timing=True)\nrepetitions = 300\ntimings=np.zeros((repetitions,1))\n#GPU-WARM-UP\nfor _ in range(10):\n    _, _ = model(rescaled_left.unsqueeze(0))\n# MEASURE PERFORMANCE\nwith torch.no_grad():\n    for rep in range(repetitions):\n        starter.record()\n        _, _ = model(rescaled_left.unsqueeze(0))\n        ender.record()\n        # WAIT FOR GPU SYNC\n        torch.cuda.synchronize()\n        curr_time = starter.elapsed_time(ender)\n        timings[rep] = curr_time\n\nmean_syn = np.sum(timings) / repetitions\nstd_syn = np.std(timings)\nprint(mean_syn, std_syn)\n```"]