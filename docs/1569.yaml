- en: Implementing, Solving, and Visualizing the Traveling Salesman Problem with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: åŸæ–‡ï¼š[https://towardsdatascience.com/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c?source=collection_archive---------8-----------------------#2023-05-09](https://towardsdatascience.com/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c?source=collection_archive---------8-----------------------#2023-05-09)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Translate an optimization model from math to Python, optimize it, and visualize
    the solution to gain quick feedback on modeling errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@carlosjuribe?source=post_page-----fc7ee8198b6c--------------------------------)[![Carlos
    J. Uribe](../Images/902c5f4ac5d404dd99916f145be6756c.png)](https://medium.com/@carlosjuribe?source=post_page-----fc7ee8198b6c--------------------------------)[](https://towardsdatascience.com/?source=post_page-----fc7ee8198b6c--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----fc7ee8198b6c--------------------------------)
    [Carlos J. Uribe](https://medium.com/@carlosjuribe?source=post_page-----fc7ee8198b6c--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: Â·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F4337eddb94ed&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fplan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c&user=Carlos+J.+Uribe&userId=4337eddb94ed&source=post_page-4337eddb94ed----fc7ee8198b6c---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----fc7ee8198b6c--------------------------------)
    Â·24 min readÂ·May 9, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Ffc7ee8198b6c&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fplan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c&user=Carlos+J.+Uribe&userId=4337eddb94ed&source=-----fc7ee8198b6c---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Ffc7ee8198b6c&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fplan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c&source=-----fc7ee8198b6c---------------------bookmark_footer-----------)![](../Images/15ba58fb291ca49e32b081f48ba9f3f7.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Image generated by DALLÂ·E 3 with authorâ€™s prompt: â€œa network of locations in
    a city and an optimal route connecting themâ€'
  prefs: []
  type: TYPE_NORMAL
- en: '*ğŸ‘ï¸* **This is article #3 of the series covering the project â€œ**[**An Intelligent
    Decision Support System for Tourism in Python**](https://medium.com/@carlosjuribe/list/an-intelligent-decision-support-system-for-tourism-in-python-b6ba165b4236)**â€.**
    I encourage you to check it out to get a general overview of the whole project.
    If youâ€™re only interested in how to implement a model of the TSP in Python, youâ€™re
    still at the right place: this article is self-contained, and I will walk you
    through all the stepsâ€”installation of dependencies, analysis, code, interpretation
    of results, and model debugging.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The present article continues our journey right where [sprint 2](https://medium.com/@carlosjuribe/modeling-the-traveling-salesman-problem-from-first-principles-bd6530c9c07)
    left off. Here, we take the **mathematical** model we formulated in the previous
    article, and **implement it in Python**, using **Pyomo**, and following **good
    practices.** Then, the model is optimized, and **its solutions are visualized
    and analyzed**. For pedagogyâ€™s sake, we find that the initial model formulation
    is incomplete, so I show how we can derive, from first principles, the **constraints
    needed to fix the formulation**. These new constraints are added to the Pyomo
    model, and the new solutions are analyzed again and verified.
  prefs: []
  type: TYPE_NORMAL
- en: Table of contents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[1\. Implementing the model in Python using Pyomo](#238c)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[1.1\. Installing the dependencies](#d7b4)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[1.2\. Math becomes code](#c3f6)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[2\. Solving and validating the model](#2c66)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[2.1\. Solving the model](#5d50)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[2.2\. Visualizing the results](#5e0a)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[2.3\. Analyzing the results](#8620)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[3\. Fixing the formulation](#b10a)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[3.1\. The motivating idea](#be6b)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[3.2\. Expressing the motivating idea as logical implications](#42b8)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[3.3\. Formulating the logical implications as linear constraints](#ebeb)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[3.4\. Deducing a proper value for the â€œbig Mâ€](#7747)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[4\. Implementing and verifying the new formulation](#195f)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[4.1\. Augmenting the Pyomo model](#50da)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[4.2\. Plotting the updated modelâ€™s solution](#f2ba)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[5\. Conclusion (for next sprint)](#8f98)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*ğŸ“–* If you didnâ€™t read the [previous article](https://medium.com/@carlosjuribe/modeling-the-traveling-salesman-problem-from-first-principles-bd6530c9c07),
    worry not. The mathematical formulation is also **stated (but not derived**) here,
    with each model component next to its code implementation. If you donâ€™t understand
    where things come from or mean, please read the article of â€œ[sprint 2](https://medium.com/@carlosjuribe/modeling-the-traveling-salesman-problem-from-first-principles-bd6530c9c07)â€,
    and if youâ€™d like more context on the problem statement and motivation, read the
    article for â€œ[sprint 1](https://medium.com/@carlosjuribe/plan-an-optimal-trip-for-your-next-holidays-with-the-help-of-operations-research-and-python-481b1ea38fef)".'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[](/modeling-the-traveling-salesman-problem-from-first-principles-bd6530c9c07?source=post_page-----fc7ee8198b6c--------------------------------)
    [## Modeling the Traveling Salesman Problem from first principles'
  prefs: []
  type: TYPE_NORMAL
- en: A concepts-first, math-second approach to modeling the most well-known routing
    problem in Operations Research
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/modeling-the-traveling-salesman-problem-from-first-principles-bd6530c9c07?source=post_page-----fc7ee8198b6c--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Implementing the model in Python using Pyomo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is used as itâ€™s the top language in data science, and [**Pyomo**](https://www.pyomo.org/)
    as itâ€™s one of the best (open-source) libraries that deal effectively with large-scale
    models.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this section, Iâ€™ll go through each **model component** defined in the formulation,
    **and explain how it is translated to Pyomo code**. Iâ€™ve tried to not leave any
    gaps, but if you feel otherwise, please leave a question in the comments.
  prefs: []
  type: TYPE_NORMAL
- en: '***Disclaimer****: The target reader is expected to be new to Pyomo, and even
    to modeling, so to lower their cognitive burden,* ***concise and simple implementation
    is prioritized over programming best practices****. The goal now is to teach optimization
    modeling, not software engineering. The code is incrementally improved in future
    iterations as this proof-of-concept evolves into a more sophisticated MVP.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 1.1\. Installing the dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For people in a hurry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Install (or make sure you already have installed) the libraries `pyomo`, `networkx`
    and `pandas`, and the package `glpk`.
  prefs: []
  type: TYPE_NORMAL
- en: '*ğŸ“* The package `glpk` contains the [GLPK solver](https://www.gnu.org/software/glpk/),
    which is an (open source) **external solver** we will use to optimize the models
    we create. Pyomo is used to **create models of problems** and pass them to GLPK,
    which will run the algorithms that carry out the optimization process itself.
    GLPK then returns the solutions to the Pyomo model object, which are stored as
    model attributes, so we can use them conveniently without leaving Python.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The recommended way to install GLPK is [through conda](https://anaconda.org/conda-forge/glpk)
    so that Pyomo can find the GLPK solver easily. To install all dependencies together
    in one go, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For organized people
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I recommend creating a separate **virtual environment** in which to install
    all the libraries needed to follow the articles in this series. Copy this text
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: and save it in a YAML file named `environment.yml`. Open an Anaconda prompt
    in the same location and run the command
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: After some minutes, the environment is created with all the dependencies installed
    inside. Run `conda activate ttp` to "get inside" the environment, fire up Jupyter
    Lab (by running `jupyter lab` in the terminal), and start coding along!
  prefs: []
  type: TYPE_NORMAL
- en: 1.2\. Math becomes code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, letâ€™s make sure the GLPK solver is findable by Pyomo
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*â›”* If you got the message `''glpk'' available: False`, the solver didn''t
    install properly. Please try one of these to fix the issue:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '- re-do the installation steps carefully'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '- run `conda install -y -c conda-forge glpk` in the base (default) environment'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '- try to install a different solver that works for you'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Then read the distance data CSV file
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/18f610b518e1fed4161c761c29896bb7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we enter â€œstage 4â€ of the [Agile Operations Research workflow], marked
    as the green block below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7f9b746e25cbf6a6d4850431739abfc9.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1.** Minimalist workflow to problem-solving in OR. 4th stage: **computer**
    **model** (Image by author)'
  prefs: []
  type: TYPE_NORMAL
- en: The task is to take the mathematical model created earlier and implement it
    in code *exactly as it was defined mathematically.*
  prefs: []
  type: TYPE_NORMAL
- en: '*ğŸ‘ï¸* We are allowed to create as many Python objects as we want if that makes
    the model implementation easier, but **we are not allowed to modify the underlying
    model in any way, while weâ€™re coding it**. **It would cause the math model and
    the computer model to be out-of-sync**, thereby making later model debugging pretty
    hard.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We instantiate an empty Pyomo model, in which we will store model components
    as attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 1.2.1\. Sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to create the set of sites ğ•Š = {Louvre, Tour Eiffel, â€¦, hotel}, we
    extract their names from the index of the dataframe and use it to create a Pyomo
    `Set` named `sites`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To create the derived set
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d715b2ebc97925fc3acc15991d0d540e.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Expression 3.1.** Derived set of possible arcs of the tour (site-to-site
    trajectories).'
  prefs: []
  type: TYPE_NORMAL
- en: We store the filter ğ‘– â‰  ğ‘— inside a *construction rule* (the Python function
    `_rule_domain_arcs`), and pass this rule to the `filter` keyword when initializing
    the `Set`. Note that this filter will be applied to the cross-product of the sites
    (ğ•Š Ã— ğ•Š), and will filter out those members of the cross-product that do not satisfy
    the rule.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 1.2.2\. Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The parameter
  prefs: []
  type: TYPE_NORMAL
- en: ğ·áµ¢â±¼ â‰” Distance between site ğ‘– and site ğ‘—
  prefs: []
  type: TYPE_NORMAL
- en: 'is created with the constructor `pyo.Param`, which takes as **the first** (positional)
    argument the domain ğ”¸ (`model.valid_arcs`) that indexes it, and as the *keyword*
    argument `initialize` another construction rule, `_rule_distance_between_sites`,
    that is evaluated for each pair (ğ‘–, ğ‘—) âˆˆ ğ”¸. In each evaluation, the numeric value
    of the distance is fetched from the dataframe `df_distances`, and linked internally
    to the pair (ğ‘–, ğ‘—):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 1.2.3\. Decision variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because ğ›¿áµ¢â±¼ has the same â€œindex domainâ€ as ğ·áµ¢â±¼, the way to build this component
    is very similar, with the exception that no construction rule is needed here.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/991fc19df0913c668de95e6e5728825e.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Expression 3.2.** Binary decision variables'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The first positional argument of `pyo.Var` is reserved for its index set ğ”¸,
    and the "type" of variable is specified with the keyword argument `within`. With
    "type of variable" I mean the **range of values** that the variable can take.
    Here, the range of ğ›¿áµ¢â±¼ is just 0 and 1, so it is of type binary. Mathematically,
    we would write ğ›¿áµ¢â±¼ âˆˆ {0, 1}, but instead of creating separate constraints to indicate
    this, we can indicate it directly in Pyomo by setting `within=pyo.Binary` at the
    time we create the variable.
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.4\. Objective function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/07c3a8da73c03dd98cdfa05171e38da0.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Expression 3.3.** The objective function to be minimized: total tour distance'
  prefs: []
  type: TYPE_NORMAL
- en: To construct an objective function we can â€œstoreâ€ the expression in a function
    that will be used as the *construction rule* for the objective. This function
    only takes one argument, the model, which is used to fetch any model component
    needed to build the expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Observe the parallelism between the mathematical expression and the return statement
    of the function. We specify that this is a minimization problem with the `sense`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.5\. Constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you recall from the previous article, a convenient way to enforce that each
    site is visited only once is by enforcing that each site is â€œenteredâ€ once and
    â€œexitedâ€ once, simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: '**Each site is entered just once**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b77de8c8305e21df5c734eb15e98d8b5.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Expression 3.4.** Constraint set enforcing that each site is â€œenteredâ€ just
    once.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '**Each site is exited just once**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/19605aa22a16c154824f63abdd7e883e.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Expression 3.5.** Constraint set enforcing that each site is â€œexitedâ€ just
    once.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 1.2.6\. Final inspection of the model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The model implementation is done. To see what it looks like as a whole, we should
    execute `model.pprint()`, and navigate a bit around to see if we missed some declarations
    or made some mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get an idea of the size of the model, we print the number of variables and
    constraints that it is made of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Having fewer than 100 constraints or variables, this is a small-size problem,
    and it will be optimized relatively fast by the solver.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Solving and validating the model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 2.1\. Solving the model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step in the [AOR flowchart] is to optimize the model, and inspect
    the solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Good news! The solver has found an **optimal solution** to this problem! Letâ€™s
    check it so that we can know what tour to follow when we get to Paris!
  prefs: []
  type: TYPE_NORMAL
- en: 'For a very quick check, we can run `model.delta_ij.pprint()`, which will print
    all the (optimal) values of the ğ›¿áµ¢â±¼ variables, being either 0 or 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b4904acd1b5e94da81a282a4590f687e.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.1.** Excerpt of the values of the decision variables as printed
    by the model (Image by Author)'
  prefs: []
  type: TYPE_NORMAL
- en: Itâ€™s difficult to visualize a tour merely by looking at a list of *chosen arcs*,
    let alone analyze it to validate that we formulated the model correctly.
  prefs: []
  type: TYPE_NORMAL
- en: To really understand the solution, we need to visualize it.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2\. Visualizing the results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*An image is worth a thousand records*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As weâ€™re dealing with nodes and arcs, the easiest way to **visualize the solution
    is to plot it as a graph**. Remember that this is a proof-of-concept, so **quick,
    effective feedback trumps beauty**. The [more insightful visualizations](/visualizing-routes-on-interactive-maps-with-python-part-1-44f8d25d0761)
    can wait until we have a working MVP. For now, letâ€™s write some helper functions
    to plot solutions efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: The function `extract_solution_as_arcs` takes in a solved Pyomo model and extracts
    the "chosen arcs" from the solution. Next, the function `plot_arcs_as_graph` stores
    the list of active arcs in a Graph object for easier analysis and plots that graph
    so that the hotel is the only red node, for reference. Lastly, the function `plot_solution_as_graph`
    calls the above two functions to display the solution of the given model as a
    graph.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can see what the solution really looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/452bd38032fcfd45ffa9c45cb2f71896.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.2.** The solution of the first formulation, showing undesired subtours
    instead of a single tour. (Image by author)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, this is obviously **not what we expected!** There is no **single tour**
    traversing all sites and coming back to the hotel. Itâ€™s true that all sites are
    visited, but only as part of small disconnected clusters of sites. Technically,
    yes, the constraints we specified are carefully obeyed: each site is entered just
    once and exited just once, but **the overall result is not one single tour, as
    we intended, but a group of subtours**. This means that [the assumption we did
    in the previous article](/modeling-the-traveling-salesman-problem-from-first-principles-bd6530c9c07#:~:text=Let%E2%80%99s%20take%20an,all%20the%20time).)
    is wrong, so something else is missing in the model that will encode the requirement
    that â€œsubtours are not permitted in the solutionâ€.'
  prefs: []
  type: TYPE_NORMAL
- en: 2.3\. Analyzing the results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What has gone wrong?
  prefs: []
  type: TYPE_NORMAL
- en: '*When the solution of a model does not make sense, thereâ€™s only one possible
    explanation: the* ***model is wrong***[***Â¹***](#02f5)*.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The solver gave us what *truly* is the optimal solution to the model, **but
    we gave it a model that does not map to the problem we want to solve**. The task
    is now to find out why, and where we made a mistake. On reflection, the obvious
    candidate is the *dubious assumption* we made in the last two paragraphs of section
    â€œ4.4\. Creating the constraintsâ€ in [the predecessor article](/modeling-the-traveling-salesman-problem-from-first-principles-bd6530c9c07),
    where we designed the mathematical model. **We** (wrongly, as we now know) **assumed
    that the formation of a *single tour* would follow naturally from the two constraints
    that ensure each site is visited just once**. But as we just visualized, it doesnâ€™t.
    Why?
  prefs: []
  type: TYPE_NORMAL
- en: 'The root cause of the error lies in what I call â€œ**unspoken common-sense**â€:
    knowledge we have about the world that is so obvious that we forget to specify
    it in the model'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We knew, **implicitly**, that teleportation is not possible when visiting sites,
    **but we didnâ€™t explicitly tell the model**. Thatâ€™s why we observe those little
    subtours, connecting some of the sites, but not all. The model â€œthinksâ€ itâ€™s okay
    to teleport from one site to another, as long as, once itâ€™s on a site, it is *exited*
    once and *entered* once (see Figure 3.2 again). If we see subtours is only because
    we told the model to minimize the tourâ€™s distance, and just so happens that teleportation
    is helpful at saving distance.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, **we need to prevent the formation of these subtours** to obtain a realistic
    solution. **We need to design some new constraints** that â€œtell the modelâ€ that
    subtours are forbidden, or, equivalently, that **the solution must be a single
    tour**. Letâ€™s go with the latter, and **deduce, from first principles**, one set
    of constraints that is intuitive and does the job fine.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Fixing the formulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Referring to the [Agile Operations Research workflow], we are now in the **model
    reformulation phase**. A reformulation of a model could be about improving it
    or fixing it. Ours will be about fixing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We know what we want: to force the solution to be a single tour, starting and
    ending at our initial site, the hotel. **The challenge is how to encode that requirement
    into a set of linear constraints**. Below is one idea, stemming from the properties
    of a tour.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.1\. The motivating idea
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have ğ‘ sites to â€œtraverseâ€, including the hotel. Since we start at the hotel,
    that means ğ‘ âˆ’ 1 sites left to visit. **If we keep track of the â€œchronological
    orderâ€ in which we visit those sites**, such that the first destination (after
    the hotel) is given the number 1, the second destination is given the number 2,
    and so on, then the last destination before returning to the hotel will be given
    the number ğ‘ âˆ’ 1\. If we call these numbers used to track the order of visits
    â€œ*ranks*â€, then **the pattern that occurs in the tour** is that *the rank of any
    site (****other than the hotel****) is always 1 unit higher than the rank of the
    site that preceded it in the tour*. If we could **formulate a set of constraints
    that impose such a pattern on any feasible solution**, we would be, loosely speaking,
    introducing a â€œchronological orderâ€ requirement in the model. And it turns out
    we can indeed.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2\. Expressing the motivating idea as logical implications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*ğŸ’¡* *This is the â€œpatternâ€ that we want any feasible solution to satisfy:*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The rank of any site (other than the hotel) must always be 1 unit higher than
    the rank of the site that preceded it in the tour
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We can re-express this pattern as a **logical implication**, like this: â€œthe
    rank of site ğ‘— must be 1 unit higher than the rank of site ğ‘– *if and only if*
    ğ‘— is visited right after ğ‘–, for all arcs (ğ‘–, ğ‘—) that do not include the hotel
    ğ»â€. This wording is expressed mathematically as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/76ce023b64fdfb59d61f06838d7b8f0b.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Expression 3.6\.** Logical implication for rank variables: they increase
    by 1 with each new site visited.'
  prefs: []
  type: TYPE_NORMAL
- en: 'where ğ‘Ÿáµ¢ are the **new variables we need to keep track of the (yet unknown)
    order of visits**. To distinguish them from the decision variables, letâ€™s call
    them â€œ**rank** variablesâ€. The right side is read as â€œfor all ğ‘– and ğ‘— belonging
    to the set of all sites excluding the hotelâ€. For *notational convenience*, we
    define the new set ğ•Š* to store all the sites except the hotel (denoted by ğ»):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b45b2753cce9e55709c1509d1efc521e.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Expression 3.7\.** The set of all sites of interest: all sites except the
    hotel.'
  prefs: []
  type: TYPE_NORMAL
- en: 'which allows us to define the rank variables concisely as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/efecbbacc7c452405d7d615d61c2d04f.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Expression 3.8.** Definition of the rank variables, defined only for the
    sites of interest.'
  prefs: []
  type: TYPE_NORMAL
- en: '*ğŸ‘ï¸* *Itâ€™s crucial that the hotel* ***does not have an associated rank variable***
    *because* it will be simultaneously the origin and final destination of any tour*,
    a condition that* ***would violate the pattern*** *of â€œever increasing rank variables
    in the tourâ€. This way, the rank of each site is always forced to increase with
    any new arc taken, which ensures that* ***closed loops are prohibited unless the
    loops close at the only site that doesnâ€™t have a rank variable: the hotel***'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The bounds of ğ‘Ÿáµ¢ are derived from its description: the rank starts at 1 and
    monotonically increases until all sites in ğ•Š* are visited, thus ending at | ğ•Š*
    | (the size of the set of non-hotel sites). Besides, we allow them to take any
    positive real value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9044818c9b95300536e6d8e8807a49d9.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Expression 3.9.** Bounds and range of the rank variables'
  prefs: []
  type: TYPE_NORMAL
- en: 3.3\. Formulating the logical implications as linear constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The challenge now is to translate this logical implication to a set of linear
    constraints. Thankfully, **linear inequalities serve also the purpose of enforcing
    logical implications**, not just finite resource limitations.
  prefs: []
  type: TYPE_NORMAL
- en: One way to do that is through the so-called **Big-M method**, which consists
    of declaring a constraint in such a way that, **when the condition you care about
    is met, the constraint applies (becomes active), and when the condition you care
    about is not met, the constraint becomes redundant (becomes inactive)**. The technique
    is called â€œbig-Mâ€ because it makes use of a constant value ğ‘€ that **is sufficiently
    large so as to, when appearing in the constraint, render it redundant for every
    case**. When ğ‘€ does not appear in the constraint, the constraint is â€œactiveâ€ in
    the sense that it is enforcing the *desired implication*.
  prefs: []
  type: TYPE_NORMAL
- en: '**But what determines whether a constraint is â€œactiveâ€ or not?** The short
    answer is the **values of the decision variables themselves** that the constraint
    applies to. Letâ€™s see how it works.'
  prefs: []
  type: TYPE_NORMAL
- en: The desired implication is to have ğ‘Ÿâ±¼ = ğ‘Ÿáµ¢ + 1 only when ğ›¿áµ¢â±¼ = 1\. We can replace
    the 1 in the expression with ğ›¿áµ¢â±¼, which yields
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ce44a6deb3909982fc5f7195c0b9ab90.png)'
  prefs: []
  type: TYPE_IMG
- en: This is the relation we want to hold when ğ›¿áµ¢â±¼ = 1, but not when ğ›¿áµ¢â±¼ = 0\. To
    â€œcorrectâ€ for the case when ğ›¿áµ¢â±¼ = 0, **we add a redundancy term,** ğ‘…ğ‘‡**, whose
    function is to â€œdeactivate the constraintâ€ only when** ğ›¿áµ¢â±¼ = 0\. Therefore, this
    redundancy term must include the variable ğ›¿áµ¢â±¼, as it depends on it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d1bc487b50553663942c9939915fdfdf.png)'
  prefs: []
  type: TYPE_IMG
- en: '*In this context, â€œdeactivating the constraintâ€ stands for â€œmaking it redundantâ€,
    since a redundant constraint has the same effect as a non-existing constraint
    in a model.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Letâ€™s see how we can deduce the expression for *RT*. The expression for ğ‘…ğ‘‡(ğ›¿áµ¢â±¼)
    needs to satisfy these properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a80c248947cb3c1c1b6961574decc29f.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Expression 3.10.** Properties the redundancy term must satisfy to enforce
    valid redundancy.'
  prefs: []
  type: TYPE_NORMAL
- en: To satisfy point (1) we need ğ‘…ğ‘‡(ğ›¿áµ¢â±¼ = 1) = 0, and thus the expression for ğ‘…ğ‘‡
    must contain the multiplier (1 âˆ’ ğ›¿áµ¢â±¼), as it becomes 0 when ğ›¿áµ¢â±¼ =1\. This form
    makes ğ‘…ğ‘‡ â€œvanishâ€ when ğ›¿áµ¢â±¼ = 1, or â€œbe reducedâ€ to a constant (letâ€™s call it *M*)
    when ğ›¿áµ¢â±¼ = 0\. Thus, a candidate for the redundancy term is
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/67e2e24e2c25fe241ac7b1461d740a72.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Expression 3.11.** Definition of the â€œredundancy termâ€ needed to selectively
    make some constraints redundant.'
  prefs: []
  type: TYPE_NORMAL
- en: where ğ‘€ should be determined from the problem data (more on that later).
  prefs: []
  type: TYPE_NORMAL
- en: To satisfy point (2) for **all possible ğ‘–â€™s and ğ‘—â€™s**, we need to make the equality
    in expression (3.11) an inequality (= becomes â‰¥), and **find a constant** ğ‘€ **big
    enough (in absolute value) so that, no matter what values** ğ‘Ÿâ±¼ **and** ğ‘Ÿáµ¢ **take,
    the constraint is always satisfied**. This is where the â€œbigâ€ in â€œbig Mâ€ comes
    from.
  prefs: []
  type: TYPE_NORMAL
- en: Once we find such a **sufficiently large constant** ğ‘€, our â€œlogical implicationâ€
    constraint will take the form
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ac57dd4e680caee411938e2ec4e60f96.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Expression 3.12**. Constraints for the implication that â€œa siteâ€™s rank must
    be higher than its preceding siteâ€™sâ€.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing these constraints into the model will, presumably, force the solution
    to be a single tour. But the constraints wonâ€™t have the desired effect unless
    we first specify a good value for *M.*
  prefs: []
  type: TYPE_NORMAL
- en: 3.4\. Deducing a proper value for the â€œbig Mâ€
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since the goal is to have ğ‘…ğ‘‡(ğ›¿áµ¢â±¼ = 0) = ğ‘€, we can **deduce a proper value for**
    ğ‘€ by setting ğ›¿áµ¢â±¼ = 0 in the general constraint stated in Expression (3.12):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b33d3bcb04f30c303366638dcd576754.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Expression 3.13.** Deduction of minimum value for M.'
  prefs: []
  type: TYPE_NORMAL
- en: For ğ‘Ÿâ±¼ âˆ’ ğ‘Ÿáµ¢ â‰¥ ğ‘€ to be **satisfied for all non-hotel sites** ğ‘–, ğ‘—, we need the
    **lower bound** **of ğ‘Ÿâ±¼ âˆ’ ğ‘Ÿáµ¢ to be also greater than ğ‘€.** The lower bound (LB)
    of ğ‘Ÿâ±¼ âˆ’ ğ‘Ÿáµ¢ is the minimum value that ğ‘Ÿâ±¼ âˆ’ ğ‘Ÿáµ¢ can take, and can be obtained by
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e052a9f7fb498681f45574c532e2f8c3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'where ğ‘Ÿáµâ±â¿ is the minimum possible rank and ğ‘ŸáµáµƒË£ the maximum possible rank.
    Therefore, for inequality (1) in Expression (3.13) to be true for all ranks of
    all sites, the following inequality must hold too:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c35c59fb0307427a3ffa7b4f60712565.png)'
  prefs: []
  type: TYPE_IMG
- en: Thanks to this inequalitywe know **the minimum value that** ğ‘€ **must take in
    order for the big-M method to work**, which is
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/509528146ae2d5bdfdbaad62174cf8e1.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Expression 3.14\.** Lower bound for the big-M.'
  prefs: []
  type: TYPE_NORMAL
- en: 'And what are the values of ğ‘Ÿáµâ±â¿ and ğ‘ŸáµáµƒË£? In our convention, we gave the first
    visited site the rank 1, which is, of course, the *minimum rank* (*i.e.*, ğ‘Ÿáµâ±â¿
    = 1). Since the rank grows by 1 unit in each site visited, the last non-hotel
    site in the tour will have the *maximum rank*, equal to *the number of all non-hotel
    sites*. As the number of non-hotel sites can vary, we need a general expression.
    If you remember, we defined the set ğ•Š* to contain all non-hotel sites, so the
    number weâ€™re after is the *size* (*i.e.*, the number of elements) of the set ğ•Š*,
    which in math notation is expressed as | ğ•Š* |. Thus, we have deduced that ğ‘Ÿáµâ±â¿
    = 1 and ğ‘ŸáµáµƒË£ = | ğ•Š* |. Substituting in Expression (3.14), we finally arrive at
    a proper value for M:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ceb6c3b83c0912cf432ce8397d299483.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Expression 3.15**. The value of the big-M, deduced from the problem data.'
  prefs: []
  type: TYPE_NORMAL
- en: Because ğ•Š* will always have more than 2 sites to be visited (*otherwise, there
    would be no* ***decision*** *problem at all in the first place*), the â€œbig Mâ€
    value, in this model, is always a **negative â€œbigâ€ valueâ€**.
  prefs: []
  type: TYPE_NORMAL
- en: '*ğŸ“* **Theoretical *values* versus computational *values***'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Theoretically, we are allowed to choose arbitrarily â€œmore negativeâ€ values
    for ğ‘€ than the one deduced hereâ€”even make up* huge *numbers to be sure theyâ€™re
    big enough, to avoid this calculation â€” but* ***this is not good practice.***
    *If ğ‘€ gets too large (in absolute value), it can create* performance issues *in
    the solverâ€™s algorithms, or, in the worst case scenario, even make the solver*
    ***consider infeasible solutions as feasible****. Thatâ€™s why the recommended practice
    is to derive, from the problemâ€™s data, a* ***tight, but sufficiently large value***
    *for ğ‘€.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now that we have deduced a proper value for â€œbig Mâ€, we will store it in a new
    model parameter, for easier reuse. With this, **the subtour elimination constraint
    set is ready**, and its â€œfull formâ€ is
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/173a04975424ba275a920b98435085e5.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Expression 3.16**. The subtour elimination constraints.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep things in perspective, note that this is actually the â€œ**constraint
    equivalentâ€** of the original **logical implication** we formulated earlier in
    Expression (3.6):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0f3a375a13ac3a1a07f78e43acb5a5d4.png)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! We finally have a set of constraints that can be added to our
    model. Coming up with them was the hard part. Now, letâ€™s verify that their addition
    to the model really results in the disappearance of subtours.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Implementing and verifying the new formulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 4.1\. Augmenting the Pyomo model with the new formulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Revising and correcting the model has required the addition of a few more sets,
    parameters, variables, and constraints. Letâ€™s add these new **model components**
    to the Pyomo model, following the same order as in the initial formulation phase.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.1\. Sets and parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Sites of interest**, ğ•Š*: set of all sites **excluding the hotel:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/a510017c12ff97cc877f6b116824557e.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Expression 3.17**. Definition of the set of sites of interest (a.k.a., non-hotel
    sites)'
  prefs: []
  type: TYPE_NORMAL
- en: '*Pyomo* `Set` objects have operations compatible with *Python* sets, so we
    can do the difference between a Pyomo set and a Python set directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '**big M**, the new parameter for the subtour elimination constraint:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/ceb6c3b83c0912cf432ce8397d299483.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 4.1.2\. Auxiliary variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**rank variables, r**áµ¢: to keep track of the order in which sites are visited:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/f6be26d9f90a5b0a066539c01ff727f8.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the comments, you can see how nicely the elements of the full *mathematical
    definition* of the variables map to the arguments of the *Pyomo variable declaration*
    function `pyo.Var`. I hope this helps you appreciate the value of having a well-defined
    *mathematical* model before starting to build a *Pyomo* model. The implementation
    will just flow naturally, and errors will be less likely.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.3\. Constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The solution must be a **single tour** starting and ending at the hotel:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/173a04975424ba275a920b98435085e5.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The Pyomo model has been updated. How much has it grown after the addition of
    the subtour elimination constraints?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We have gone **from 72 to 80 variables and from 18 to 74 constraints**. Clearly,
    this formulation is heavier on constraints than on variables, as it has quadrupled
    the number of constraints we had before. Thatâ€™s the â€œprice we payâ€, in general,
    for making models more â€œrealisticâ€, as realism usually entailsâ€”if the data is
    unchangedâ€”limiting the number of allowable solutions.
  prefs: []
  type: TYPE_NORMAL
- en: As always, we can inspect the model structure with`model.pprint()`. Although
    this â€œprintâ€ loses its value rapidly as the number of model components grows,
    it still can give us a quick overview of what the model is made of, and how big
    it is.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2\. Plotting the updated modelâ€™s solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Letâ€™s solve the updated model and plot the new solution. Fingers crossed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/15644a14b7ecefad953db4ce9ce3a954.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now weâ€™re talking! This is exactly what we were expecting after the addition
    of the new constraints: **no subtours have formed**, which makes the solution
    path **a single tour** now.'
  prefs: []
  type: TYPE_NORMAL
- en: Note how, obviously, the objective value of this solved model is now 14.9 km,
    instead of the unfaithful 5.7 km we got with the incomplete model.
  prefs: []
  type: TYPE_NORMAL
- en: '***ğŸ‘ï¸* A drawing of a graph is not a tour on a map**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Note that this image is just one possible **drawing** of a graph, not a geographical
    trajectory. The circles and links you see do not correspond to a real path in
    geographical space (how could it, if we havenâ€™t used any geographical information
    in its creation?). You can verify this yourself by running `plot_solution_as_graph(model)`
    multiple times: each time you run it, the nodes will take different positions.
    [Graphs](https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)) are abstract
    mathematical structures that connect "points" through "links", representing relationships
    of any kind between entities of any kind. We used a graph here to **study the
    solution''s validity**, not to **visualize the real tour** in Paris. We do that
    in [this article].'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 5\. Conclusion (or planning for the next sprint)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this final verification of the solution, **we conclude that this updated
    version of the model can solve any instance of the Traveling Salesman Problem**,
    so we can consider it a successful proof-of-concept (POC).
  prefs: []
  type: TYPE_NORMAL
- en: '*ğŸ’¡* **Evolving solutions, one sprint at a time**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This POC doesnâ€™t solve (yet) our original [complex tourism problem](https://medium.com/@carlosjuribe/plan-an-optimal-trip-for-your-next-holidays-with-the-help-of-operations-research-and-python-481b1ea38fef),
    but **it does solve the minimum valuable problem** we proposed as the first stepping-stone
    towards a more sophisticated solution. Hence, **it gets us provably** (i.e., evidence-based)
    **closer to a valuable solution of the more complex problem**. With a minimal
    *working* example at hand, we can better evaluate what needs to be done to advance
    in the direction we want, and what can be provisionally *simplified away* until
    a more mature version of the solution is reached. **While having something useful
    at all times, weâ€™ll develop an increasingly-valuable system, until weâ€™re** [**satisficed**](https://en.wikipedia.org/wiki/Satisficing).
    That is the essence of the â€œagile roadâ€ to effective solutions.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: With the validity of this approach proven, we must expand it and refine it so
    **it can gradually encompass more features of our original problem**, with each
    iteration providing **incrementally valuable solutions.** In this POC, we focused
    on the design and formulation of a basic model, so we had to assume a fixed set
    of sites and their distance matrix as a given. Of course, this is limiting, and
    the next step should be to have a model that accepts any number of sites. For
    that, **we need a way to automatically generate the distance matrix given a list
    of sites and their geographical coordinates.** That is the goal of [our next sprint](https://medium.com/@carlosjuribe/compute-the-distance-matrix-of-a-set-of-sites-from-their-coordinates-in-python-d5fc92a0ba9e).
  prefs: []
  type: TYPE_NORMAL
- en: 5.1\. Whatâ€™s next
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the next article (sprint 4) we will work on a class that **generates a distance
    matrix automatically from any list of sites.** This functionality, when combined
    with the model we just built here**,** will allow us, among other things, to solve
    **many models for different inputs, quickly,** and compare them**.** Besides,
    generalizing the solution this way will make our lives easier later on when we
    do a bit of **sensitivity and scenario analysis** in future sprints. Also, as
    we will upgrade this proof-of-concept to an â€œMVP statusâ€, we will start using
    **object-oriented code** to keep things well organized, and ready for extensibility.
    Donâ€™t waste the flow and jump [right in](https://medium.com/@carlosjuribe/compute-the-distance-matrix-of-a-set-of-sites-from-their-coordinates-in-python-d5fc92a0ba9e):'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/compute-the-distance-matrix-of-a-set-of-sites-from-their-coordinates-in-python-d5fc92a0ba9e?source=post_page-----fc7ee8198b6c--------------------------------)
    [## Compute the Distance Matrix of a Set of Sites from Their Coordinates in Python'
  prefs: []
  type: TYPE_NORMAL
- en: Estimate the distance between any pair of sites from their geographical coordinates
    as a stepping stone to solvingâ€¦
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/compute-the-distance-matrix-of-a-set-of-sites-from-their-coordinates-in-python-d5fc92a0ba9e?source=post_page-----fc7ee8198b6c--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Footnotes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Actually, thereâ€™s another cause for a wrong result: the *data* the model feeds
    on can also be wrong, not just the model formulation. But, in a sense, if you
    think of â€œa modelâ€ as a â€œ**model instance**â€, *i.e.*, a concrete model with concrete
    data, then the model will be of course wrong if the data is wrong, which is what
    I intended by the statement. [â†©](#e5d1)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thanks for reading, and see you in the next one! ğŸ“ˆğŸ˜Š
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to follow me, ask me questions, **give me feedback** in the comments,
    or contact me on [LinkedIn](https://www.linkedin.com/in/carlosjuribe/).
  prefs: []
  type: TYPE_NORMAL
