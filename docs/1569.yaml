- en: Implementing, Solving, and Visualizing the Traveling Salesman Problem with Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python实现、解决和可视化旅行推销员问题
- en: 原文：[https://towardsdatascience.com/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c?source=collection_archive---------8-----------------------#2023-05-09](https://towardsdatascience.com/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c?source=collection_archive---------8-----------------------#2023-05-09)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c?source=collection_archive---------8-----------------------#2023-05-09](https://towardsdatascience.com/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c?source=collection_archive---------8-----------------------#2023-05-09)
- en: Translate an optimization model from math to Python, optimize it, and visualize
    the solution to gain quick feedback on modeling errors
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数学优化模型翻译为Python，进行优化，并可视化解决方案，以便快速获得建模错误的反馈
- en: '[](https://medium.com/@carlosjuribe?source=post_page-----fc7ee8198b6c--------------------------------)[![Carlos
    J. Uribe](../Images/902c5f4ac5d404dd99916f145be6756c.png)](https://medium.com/@carlosjuribe?source=post_page-----fc7ee8198b6c--------------------------------)[](https://towardsdatascience.com/?source=post_page-----fc7ee8198b6c--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----fc7ee8198b6c--------------------------------)
    [Carlos J. Uribe](https://medium.com/@carlosjuribe?source=post_page-----fc7ee8198b6c--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@carlosjuribe?source=post_page-----fc7ee8198b6c--------------------------------)[![Carlos
    J. Uribe](../Images/902c5f4ac5d404dd99916f145be6756c.png)](https://medium.com/@carlosjuribe?source=post_page-----fc7ee8198b6c--------------------------------)[](https://towardsdatascience.com/?source=post_page-----fc7ee8198b6c--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----fc7ee8198b6c--------------------------------)
    [Carlos J. Uribe](https://medium.com/@carlosjuribe?source=post_page-----fc7ee8198b6c--------------------------------)'
- en: ·
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F4337eddb94ed&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fplan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c&user=Carlos+J.+Uribe&userId=4337eddb94ed&source=post_page-4337eddb94ed----fc7ee8198b6c---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----fc7ee8198b6c--------------------------------)
    ·24 min read·May 9, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Ffc7ee8198b6c&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fplan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c&user=Carlos+J.+Uribe&userId=4337eddb94ed&source=-----fc7ee8198b6c---------------------clap_footer-----------)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[关注](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F4337eddb94ed&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fplan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c&user=Carlos+J.+Uribe&userId=4337eddb94ed&source=post_page-4337eddb94ed----fc7ee8198b6c---------------------post_header-----------)
    发表在[Towards Data Science](https://towardsdatascience.com/?source=post_page-----fc7ee8198b6c--------------------------------)
    ·24 分钟阅读·2023 年 5 月 9 日[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Ffc7ee8198b6c&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fplan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c&user=Carlos+J.+Uribe&userId=4337eddb94ed&source=-----fc7ee8198b6c---------------------clap_footer-----------)'
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Ffc7ee8198b6c&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fplan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c&source=-----fc7ee8198b6c---------------------bookmark_footer-----------)![](../Images/15ba58fb291ca49e32b081f48ba9f3f7.png)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Ffc7ee8198b6c&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fplan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c&source=-----fc7ee8198b6c---------------------bookmark_footer-----------)![](../Images/15ba58fb291ca49e32b081f48ba9f3f7.png)'
- en: 'Image generated by DALL·E 3 with author’s prompt: “a network of locations in
    a city and an optimal route connecting them”'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 由DALL·E 3生成的图像，作者的提示是：“城市中的位置网络和连接它们的最佳路线”
- en: '*👁️* **This is article #3 of the series covering the project “**[**An Intelligent
    Decision Support System for Tourism in Python**](https://medium.com/@carlosjuribe/list/an-intelligent-decision-support-system-for-tourism-in-python-b6ba165b4236)**”.**
    I encourage you to check it out to get a general overview of the whole project.
    If you’re only interested in how to implement a model of the TSP in Python, you’re
    still at the right place: this article is self-contained, and I will walk you
    through all the steps—installation of dependencies, analysis, code, interpretation
    of results, and model debugging.'
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*👁️* **这是涵盖项目“**[**Python 中的智能决策支持系统**](https://medium.com/@carlosjuribe/list/an-intelligent-decision-support-system-for-tourism-in-python-b6ba165b4236)**”的系列文章中的第
    3 篇。** 我鼓励你查看，以获得整个项目的一般概述。如果你只是对如何在 Python 中实现 TSP 模型感兴趣，你仍然来对地方了：这篇文章是自包含的，我将带你完成所有步骤——安装依赖项、分析、代码、结果解释和模型调试。'
- en: The present article continues our journey right where [sprint 2](https://medium.com/@carlosjuribe/modeling-the-traveling-salesman-problem-from-first-principles-bd6530c9c07)
    left off. Here, we take the **mathematical** model we formulated in the previous
    article, and **implement it in Python**, using **Pyomo**, and following **good
    practices.** Then, the model is optimized, and **its solutions are visualized
    and analyzed**. For pedagogy’s sake, we find that the initial model formulation
    is incomplete, so I show how we can derive, from first principles, the **constraints
    needed to fix the formulation**. These new constraints are added to the Pyomo
    model, and the new solutions are analyzed again and verified.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本文继续从[sprint 2](https://medium.com/@carlosjuribe/modeling-the-traveling-salesman-problem-from-first-principles-bd6530c9c07)结束的地方接着讲解。在这里，我们将上一篇文章中**制定的数学**模型**实现到
    Python 中**，使用**Pyomo**，并遵循**良好实践**。然后，模型经过优化，**解决方案被可视化和分析**。为了教学目的，我们发现初始模型公式不完整，因此我展示了如何从第一性原理推导出**修正公式所需的约束**。这些新约束被添加到
    Pyomo 模型中，新解决方案再次被分析和验证。
- en: Table of contents
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目录
- en: '[1\. Implementing the model in Python using Pyomo](#238c)'
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[1\. 使用 Pyomo 在 Python 中实现模型](#238c)'
- en: '[1.1\. Installing the dependencies](#d7b4)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[1.1\. 安装依赖项](#d7b4)'
- en: '[1.2\. Math becomes code](#c3f6)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[1.2\. 数学变成代码](#c3f6)'
- en: '[2\. Solving and validating the model](#2c66)'
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[2\. 解决和验证模型](#2c66)'
- en: '[2.1\. Solving the model](#5d50)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.1\. 解决模型](#5d50)'
- en: '[2.2\. Visualizing the results](#5e0a)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.2\. 结果可视化](#5e0a)'
- en: '[2.3\. Analyzing the results](#8620)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.3\. 分析结果](#8620)'
- en: '[3\. Fixing the formulation](#b10a)'
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[3\. 修正公式](#b10a)'
- en: '[3.1\. The motivating idea](#be6b)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3.1\. 激励思想](#be6b)'
- en: '[3.2\. Expressing the motivating idea as logical implications](#42b8)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3.2\. 将激励思想表达为逻辑蕴涵](#42b8)'
- en: '[3.3\. Formulating the logical implications as linear constraints](#ebeb)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3.3\. 将逻辑蕴涵公式化为线性约束](#ebeb)'
- en: '[3.4\. Deducing a proper value for the “big M”](#7747)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3.4\. 推导“大 M”的适当值](#7747)'
- en: '[4\. Implementing and verifying the new formulation](#195f)'
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[4\. 实现和验证新公式](#195f)'
- en: '[4.1\. Augmenting the Pyomo model](#50da)'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[4.1\. 扩展 Pyomo 模型](#50da)'
- en: '[4.2\. Plotting the updated model’s solution](#f2ba)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[4.2\. 绘制更新模型的解决方案](#f2ba)'
- en: '[5\. Conclusion (for next sprint)](#8f98)'
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[5\. 结论（用于下一个冲刺）](#8f98)'
- en: '*📖* If you didn’t read the [previous article](https://medium.com/@carlosjuribe/modeling-the-traveling-salesman-problem-from-first-principles-bd6530c9c07),
    worry not. The mathematical formulation is also **stated (but not derived**) here,
    with each model component next to its code implementation. If you don’t understand
    where things come from or mean, please read the article of “[sprint 2](https://medium.com/@carlosjuribe/modeling-the-traveling-salesman-problem-from-first-principles-bd6530c9c07)”,
    and if you’d like more context on the problem statement and motivation, read the
    article for “[sprint 1](https://medium.com/@carlosjuribe/plan-an-optimal-trip-for-your-next-holidays-with-the-help-of-operations-research-and-python-481b1ea38fef)".'
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*📖* 如果你没有阅读过[上一篇文章](https://medium.com/@carlosjuribe/modeling-the-traveling-salesman-problem-from-first-principles-bd6530c9c07)，也不用担心。数学公式在这里也**阐述（但没有推导）**，每个模型组件都与其代码实现相邻。如果你不理解这些内容的来源或含义，请阅读“[冲刺
    2](https://medium.com/@carlosjuribe/modeling-the-traveling-salesman-problem-from-first-principles-bd6530c9c07)”的文章，如果你想了解更多关于问题陈述和动机的背景，请阅读“[冲刺
    1](https://medium.com/@carlosjuribe/plan-an-optimal-trip-for-your-next-holidays-with-the-help-of-operations-research-and-python-481b1ea38fef)”的文章。'
- en: '[](/modeling-the-traveling-salesman-problem-from-first-principles-bd6530c9c07?source=post_page-----fc7ee8198b6c--------------------------------)
    [## Modeling the Traveling Salesman Problem from first principles'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[](/modeling-the-traveling-salesman-problem-from-first-principles-bd6530c9c07?source=post_page-----fc7ee8198b6c--------------------------------)
    [## 从第一原则建模旅行推销员问题'
- en: A concepts-first, math-second approach to modeling the most well-known routing
    problem in Operations Research
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一种以概念为先，数学为后的建模方法，用于解决运筹学中最著名的路径问题
- en: towardsdatascience.com](/modeling-the-traveling-salesman-problem-from-first-principles-bd6530c9c07?source=post_page-----fc7ee8198b6c--------------------------------)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[towardsdatascience.com](/modeling-the-traveling-salesman-problem-from-first-principles-bd6530c9c07?source=post_page-----fc7ee8198b6c--------------------------------)'
- en: 1\. Implementing the model in Python using Pyomo
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1. 实现使用Pyomo的Python模型
- en: Python is used as it’s the top language in data science, and [**Pyomo**](https://www.pyomo.org/)
    as it’s one of the best (open-source) libraries that deal effectively with large-scale
    models.
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用Python是因为它是数据科学中的顶级语言，而[**Pyomo**](https://www.pyomo.org/)则是处理大规模模型的最佳（开源）库之一。
- en: In this section, I’ll go through each **model component** defined in the formulation,
    **and explain how it is translated to Pyomo code**. I’ve tried to not leave any
    gaps, but if you feel otherwise, please leave a question in the comments.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将逐一讲解在公式中定义的每个**模型组件**，**并解释它是如何转换为Pyomo代码**的。我尽量不留下任何空白，但如果你觉得还有问题，请在评论中提问。
- en: '***Disclaimer****: The target reader is expected to be new to Pyomo, and even
    to modeling, so to lower their cognitive burden,* ***concise and simple implementation
    is prioritized over programming best practices****. The goal now is to teach optimization
    modeling, not software engineering. The code is incrementally improved in future
    iterations as this proof-of-concept evolves into a more sophisticated MVP.*'
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '***免责声明****：目标读者预计对Pyomo甚至建模都是新手，因此为了降低他们的认知负担，* ***简洁明了的实现优先于编程最佳实践****。目前的目标是教授优化建模，而非软件工程。代码会在未来迭代中逐步改进，随着这一概念验证演变成更复杂的MVP。'
- en: 1.1\. Installing the dependencies
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1. 安装依赖项
- en: For people in a hurry
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对于着急的人
- en: Install (or make sure you already have installed) the libraries `pyomo`, `networkx`
    and `pandas`, and the package `glpk`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 安装（或确保已经安装）库`pyomo`、`networkx`和`pandas`，以及包`glpk`。
- en: '*📝* The package `glpk` contains the [GLPK solver](https://www.gnu.org/software/glpk/),
    which is an (open source) **external solver** we will use to optimize the models
    we create. Pyomo is used to **create models of problems** and pass them to GLPK,
    which will run the algorithms that carry out the optimization process itself.
    GLPK then returns the solutions to the Pyomo model object, which are stored as
    model attributes, so we can use them conveniently without leaving Python.'
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*📝* 包`glpk`包含[GLPK求解器](https://www.gnu.org/software/glpk/)，这是我们用来优化创建模型的**外部求解器**。Pyomo用于**创建问题模型**并将其传递给GLPK，GLPK将运行算法来执行优化过程。然后，GLPK将解决方案返回给Pyomo模型对象，这些解决方案被存储为模型属性，我们可以在不离开Python的情况下方便地使用它们。'
- en: 'The recommended way to install GLPK is [through conda](https://anaconda.org/conda-forge/glpk)
    so that Pyomo can find the GLPK solver easily. To install all dependencies together
    in one go, run:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐的安装GLPK的方法是通过[conda](https://anaconda.org/conda-forge/glpk)，这样Pyomo可以轻松找到GLPK求解器。要一次性安装所有依赖项，请运行：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For organized people
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对于有组织的人
- en: I recommend creating a separate **virtual environment** in which to install
    all the libraries needed to follow the articles in this series. Copy this text
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议创建一个单独的**虚拟环境**，在其中安装所有需要的库以跟随本系列的文章。复制这段文本
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: and save it in a YAML file named `environment.yml`. Open an Anaconda prompt
    in the same location and run the command
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 并将其保存在名为`environment.yml`的YAML文件中。在相同位置打开Anaconda提示符并运行命令
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After some minutes, the environment is created with all the dependencies installed
    inside. Run `conda activate ttp` to "get inside" the environment, fire up Jupyter
    Lab (by running `jupyter lab` in the terminal), and start coding along!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，环境将创建完毕，所有依赖项都已安装。运行`conda activate ttp`以“进入”环境，启动Jupyter Lab（在终端中运行`jupyter
    lab`），然后开始编码吧！
- en: 1.2\. Math becomes code
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2. 数学变成代码
- en: First, let’s make sure the GLPK solver is findable by Pyomo
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保Pyomo可以找到GLPK求解器
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*⛔* If you got the message `''glpk'' available: False`, the solver didn''t
    install properly. Please try one of these to fix the issue:'
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*⛔* 如果你收到消息`''glpk'' available: False`，说明求解器安装不正确。请尝试以下方法解决问题：'
- en: ''
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '- re-do the installation steps carefully'
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '- 重新仔细执行安装步骤'
- en: ''
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '- run `conda install -y -c conda-forge glpk` in the base (default) environment'
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '- 在基础（默认）环境中运行 `conda install -y -c conda-forge glpk`'
- en: ''
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '- try to install a different solver that works for you'
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '- 尝试安装适合你的不同求解器'
- en: Then read the distance data CSV file
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后读取距离数据的CSV文件
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](../Images/18f610b518e1fed4161c761c29896bb7.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/18f610b518e1fed4161c761c29896bb7.png)'
- en: 'Now we enter “stage 4” of the [Agile Operations Research workflow], marked
    as the green block below:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们进入[敏捷运筹学工作流程]的“阶段4”，如下图所示的绿色块：
- en: '![](../Images/7f9b746e25cbf6a6d4850431739abfc9.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7f9b746e25cbf6a6d4850431739abfc9.png)'
- en: '**Figure 1.** Minimalist workflow to problem-solving in OR. 4th stage: **computer**
    **model** (Image by author)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 1.** 运筹学问题解决的极简工作流程。第4阶段：**计算机** **模型**（作者提供的图片）'
- en: The task is to take the mathematical model created earlier and implement it
    in code *exactly as it was defined mathematically.*
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 任务是将之前创建的数学模型实现成代码，*完全按照数学上定义的方式*。
- en: '*👁️* We are allowed to create as many Python objects as we want if that makes
    the model implementation easier, but **we are not allowed to modify the underlying
    model in any way, while we’re coding it**. **It would cause the math model and
    the computer model to be out-of-sync**, thereby making later model debugging pretty
    hard.'
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*👁️* 如果这样可以使模型实现更容易，我们可以创建任意数量的Python对象，但**在编写代码时，我们不允许以任何方式修改底层模型**。**这会导致数学模型和计算机模型不同步**，从而使后续的模型调试变得相当困难。'
- en: 'We instantiate an empty Pyomo model, in which we will store model components
    as attributes:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实例化一个空的Pyomo模型，在其中将模型组件作为属性存储：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 1.2.1\. Sets
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2.1\. 集合
- en: 'In order to create the set of sites 𝕊 = {Louvre, Tour Eiffel, …, hotel}, we
    extract their names from the index of the dataframe and use it to create a Pyomo
    `Set` named `sites`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建站点集合𝕊 = {卢浮宫，埃菲尔铁塔，…，酒店}，我们从数据框的索引中提取它们的名称，并用它来创建一个名为`sites`的Pyomo `Set`：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To create the derived set
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 创建派生集
- en: '![](../Images/d715b2ebc97925fc3acc15991d0d540e.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d715b2ebc97925fc3acc15991d0d540e.png)'
- en: '**Expression 3.1.** Derived set of possible arcs of the tour (site-to-site
    trajectories).'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式 3.1.** 旅行的可能弧的派生集（站点到站点的轨迹）。'
- en: We store the filter 𝑖 ≠ 𝑗 inside a *construction rule* (the Python function
    `_rule_domain_arcs`), and pass this rule to the `filter` keyword when initializing
    the `Set`. Note that this filter will be applied to the cross-product of the sites
    (𝕊 × 𝕊), and will filter out those members of the cross-product that do not satisfy
    the rule.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将过滤器𝑖 ≠ 𝑗 存储在*构造规则*（Python函数`_rule_domain_arcs`）中，并在初始化`Set`时将此规则传递给`filter`关键字。请注意，这个过滤器将应用于站点的笛卡尔积（𝕊
    × 𝕊），并会筛选出那些不符合规则的笛卡尔积成员。
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 1.2.2\. Parameters
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2.2\. 参数
- en: The parameter
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: 𝐷ᵢⱼ ≔ Distance between site 𝑖 and site 𝑗
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 𝐷ᵢⱼ ≔ 站点𝑖和站点𝑗之间的距离
- en: 'is created with the constructor `pyo.Param`, which takes as **the first** (positional)
    argument the domain 𝔸 (`model.valid_arcs`) that indexes it, and as the *keyword*
    argument `initialize` another construction rule, `_rule_distance_between_sites`,
    that is evaluated for each pair (𝑖, 𝑗) ∈ 𝔸. In each evaluation, the numeric value
    of the distance is fetched from the dataframe `df_distances`, and linked internally
    to the pair (𝑖, 𝑗):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 是通过构造函数`pyo.Param`创建的，该构造函数将**第一个**（位置）参数域𝔸（`model.valid_arcs`）传递给它，并将*关键字*参数`initialize`设置为另一个构造规则`_rule_distance_between_sites`，该规则针对每对（𝑖,
    𝑗）∈ 𝔸进行评估。在每次评估中，距离的数值从数据框`df_distances`中提取，并在内部与对（𝑖, 𝑗）相关联：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 1.2.3\. Decision variables
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2.3\. 决策变量
- en: Because 𝛿ᵢⱼ has the same “index domain” as 𝐷ᵢⱼ, the way to build this component
    is very similar, with the exception that no construction rule is needed here.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于𝛿ᵢⱼ具有与𝐷ᵢⱼ相同的“索引域”，因此构建此组件的方式非常相似，只是这里不需要构造规则。
- en: '![](../Images/991fc19df0913c668de95e6e5728825e.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/991fc19df0913c668de95e6e5728825e.png)'
- en: '**Expression 3.2.** Binary decision variables'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式 3.2.** 二进制决策变量'
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first positional argument of `pyo.Var` is reserved for its index set 𝔸,
    and the "type" of variable is specified with the keyword argument `within`. With
    "type of variable" I mean the **range of values** that the variable can take.
    Here, the range of 𝛿ᵢⱼ is just 0 and 1, so it is of type binary. Mathematically,
    we would write 𝛿ᵢⱼ ∈ {0, 1}, but instead of creating separate constraints to indicate
    this, we can indicate it directly in Pyomo by setting `within=pyo.Binary` at the
    time we create the variable.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`pyo.Var`的第一个位置参数保留用于其索引集𝔸，变量的“类型”通过关键字参数`within`指定。这里的“变量类型”指的是变量可以取的**值范围**。在这里，𝛿ᵢⱼ的范围仅为0和1，所以它是二进制类型。从数学上讲，我们会写作𝛿ᵢⱼ
    ∈ {0, 1}，但我们可以在创建变量时通过设置`within=pyo.Binary`直接在Pyomo中表示这一点，而无需创建单独的约束。'
- en: 1.2.4\. Objective function
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2.4\. 目标函数
- en: '![](../Images/07c3a8da73c03dd98cdfa05171e38da0.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/07c3a8da73c03dd98cdfa05171e38da0.png)'
- en: '**Expression 3.3.** The objective function to be minimized: total tour distance'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式 3.3.** 需要最小化的目标函数：总巡回距离'
- en: To construct an objective function we can “store” the expression in a function
    that will be used as the *construction rule* for the objective. This function
    only takes one argument, the model, which is used to fetch any model component
    needed to build the expression.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要构造目标函数，我们可以将表达式“存储”在一个函数中，该函数将用作*构造规则*。此函数只接受一个参数，即模型，用于提取构建表达式所需的任何模型组件。
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Observe the parallelism between the mathematical expression and the return statement
    of the function. We specify that this is a minimization problem with the `sense`
    keyword.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 观察数学表达式与函数的返回语句之间的平行关系。我们通过`sense`关键字指定这是一个最小化问题。
- en: 1.2.5\. Constraints
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2.5\. 约束
- en: If you recall from the previous article, a convenient way to enforce that each
    site is visited only once is by enforcing that each site is “entered” once and
    “exited” once, simultaneously.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得之前的文章，一个方便的方式来强制每个站点仅被访问一次是强制每个站点同时被“进入”一次和“退出”一次。
- en: '**Each site is entered just once**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**每个站点仅被访问一次**'
- en: '![](../Images/b77de8c8305e21df5c734eb15e98d8b5.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b77de8c8305e21df5c734eb15e98d8b5.png)'
- en: '**Expression 3.4.** Constraint set enforcing that each site is “entered” just
    once.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式 3.4.** 约束集，强制每个站点仅被“进入”一次。'
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Each site is exited just once**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**每个站点仅被退出一次**'
- en: '![](../Images/19605aa22a16c154824f63abdd7e883e.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/19605aa22a16c154824f63abdd7e883e.png)'
- en: '**Expression 3.5.** Constraint set enforcing that each site is “exited” just
    once.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式 3.5.** 约束集，强制每个站点仅被“退出”一次。'
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 1.2.6\. Final inspection of the model
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2.6\. 模型的最终检查
- en: The model implementation is done. To see what it looks like as a whole, we should
    execute `model.pprint()`, and navigate a bit around to see if we missed some declarations
    or made some mistakes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 模型实现已完成。为了查看模型的整体情况，我们应该执行`model.pprint()`，并稍微浏览一下，以查看是否遗漏了一些声明或犯了一些错误。
- en: 'To get an idea of the size of the model, we print the number of variables and
    constraints that it is made of:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解模型的规模，我们打印它包含的变量和约束的数量：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Having fewer than 100 constraints or variables, this is a small-size problem,
    and it will be optimized relatively fast by the solver.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有少于100个约束或变量，这个问题的规模较小，求解器会相对较快地优化它。
- en: 2\. Solving and validating the model
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. 解决和验证模型
- en: 2.1\. Solving the model
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1\. 解决模型
- en: 'The next step in the [AOR flowchart] is to optimize the model, and inspect
    the solutions:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[AOR 流程图](https://example.org)中的下一步是优化模型并检查解决方案：'
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Good news! The solver has found an **optimal solution** to this problem! Let’s
    check it so that we can know what tour to follow when we get to Paris!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息！求解器找到了这个问题的**最优解**！让我们检查一下，以便知道到巴黎时该跟随什么路线！
- en: 'For a very quick check, we can run `model.delta_ij.pprint()`, which will print
    all the (optimal) values of the 𝛿ᵢⱼ variables, being either 0 or 1:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行快速检查，我们可以运行`model.delta_ij.pprint()`，这将打印所有𝛿ᵢⱼ变量的（最优）值，值为0或1：
- en: '![](../Images/b4904acd1b5e94da81a282a4590f687e.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b4904acd1b5e94da81a282a4590f687e.png)'
- en: '**Figure 3.1.** Excerpt of the values of the decision variables as printed
    by the model (Image by Author)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 3.1.** 模型打印的决策变量值摘录（图片来源：作者）'
- en: It’s difficult to visualize a tour merely by looking at a list of *chosen arcs*,
    let alone analyze it to validate that we formulated the model correctly.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过查看*选择的弧线*很难可视化一个巡回路线，更不用说分析它以验证我们是否正确地制定了模型。
- en: To really understand the solution, we need to visualize it.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正理解解决方案，我们需要对其进行可视化。
- en: 2.2\. Visualizing the results
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2\. 结果可视化
- en: '*An image is worth a thousand records*'
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*一张图片胜过千言万语*'
- en: As we’re dealing with nodes and arcs, the easiest way to **visualize the solution
    is to plot it as a graph**. Remember that this is a proof-of-concept, so **quick,
    effective feedback trumps beauty**. The [more insightful visualizations](/visualizing-routes-on-interactive-maps-with-python-part-1-44f8d25d0761)
    can wait until we have a working MVP. For now, let’s write some helper functions
    to plot solutions efficiently.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们处理的是节点和弧，**可视化解决方案的最简单方法是将其绘制成图形**。请记住，这只是一个概念验证，因此**快速、有效的反馈优于美观**。更具洞察力的[可视化](/visualizing-routes-on-interactive-maps-with-python-part-1-44f8d25d0761)可以等到我们有一个可行的MVP后再做。现在，让我们编写一些辅助函数以高效地绘制解决方案。
- en: The function `extract_solution_as_arcs` takes in a solved Pyomo model and extracts
    the "chosen arcs" from the solution. Next, the function `plot_arcs_as_graph` stores
    the list of active arcs in a Graph object for easier analysis and plots that graph
    so that the hotel is the only red node, for reference. Lastly, the function `plot_solution_as_graph`
    calls the above two functions to display the solution of the given model as a
    graph.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`extract_solution_as_arcs`接收一个已解决的Pyomo模型，并从解决方案中提取“选定的弧”。接下来，函数`plot_arcs_as_graph`将活跃弧的列表存储在Graph对象中以便于分析，并绘制该图，使得酒店是唯一的红色节点，作为参考。最后，函数`plot_solution_as_graph`调用上述两个函数，以图形的形式展示给定模型的解决方案。
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we can see what the solution really looks like:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到解决方案的真实情况：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![](../Images/452bd38032fcfd45ffa9c45cb2f71896.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/452bd38032fcfd45ffa9c45cb2f71896.png)'
- en: '**Figure 3.2.** The solution of the first formulation, showing undesired subtours
    instead of a single tour. (Image by author)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.2.** 第一个模型的解决方案，显示了不希望出现的子旅行，而不是单一旅行路线。（图像由作者提供）'
- en: 'Well, this is obviously **not what we expected!** There is no **single tour**
    traversing all sites and coming back to the hotel. It’s true that all sites are
    visited, but only as part of small disconnected clusters of sites. Technically,
    yes, the constraints we specified are carefully obeyed: each site is entered just
    once and exited just once, but **the overall result is not one single tour, as
    we intended, but a group of subtours**. This means that [the assumption we did
    in the previous article](/modeling-the-traveling-salesman-problem-from-first-principles-bd6530c9c07#:~:text=Let%E2%80%99s%20take%20an,all%20the%20time).)
    is wrong, so something else is missing in the model that will encode the requirement
    that “subtours are not permitted in the solution”.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这显然是**不符合我们预期的！** 没有**单一的旅行路线**遍历所有站点并返回酒店。确实，所有站点都被访问了，但只是作为小的、不连通的站点簇的一部分。技术上讲，我们指定的约束条件确实被严格遵守：每个站点只进入一次，离开一次，但**总体结果不是我们所期望的单一旅行路线，而是一组子旅行**。这意味着[我们在上一篇文章中的假设](/modeling-the-traveling-salesman-problem-from-first-principles-bd6530c9c07#:~:text=Let%E2%80%99s%20take%20an,all%20the%20time).)
    是错误的，因此模型中缺少了某些东西，以编码“解决方案中不允许子旅行”的要求。
- en: 2.3\. Analyzing the results
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3\. 分析结果
- en: What has gone wrong?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 出了什么问题？
- en: '*When the solution of a model does not make sense, there’s only one possible
    explanation: the* ***model is wrong***[***¹***](#02f5)*.*'
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*当一个模型的解决方案不合逻辑时，唯一的可能解释是：* ***模型是错误的***[***¹***](#02f5)*。*'
- en: The solver gave us what *truly* is the optimal solution to the model, **but
    we gave it a model that does not map to the problem we want to solve**. The task
    is now to find out why, and where we made a mistake. On reflection, the obvious
    candidate is the *dubious assumption* we made in the last two paragraphs of section
    “4.4\. Creating the constraints” in [the predecessor article](/modeling-the-traveling-salesman-problem-from-first-principles-bd6530c9c07),
    where we designed the mathematical model. **We** (wrongly, as we now know) **assumed
    that the formation of a *single tour* would follow naturally from the two constraints
    that ensure each site is visited just once**. But as we just visualized, it doesn’t.
    Why?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 求解器给出了模型的*真实*最优解，但**我们给出的模型并不符合我们要解决的问题**。现在的任务是找出原因，以及我们哪里犯了错误。回顾起来，显而易见的候选因素是我们在[前一篇文章](/modeling-the-traveling-salesman-problem-from-first-principles-bd6530c9c07)“4.4\.
    创建约束”部分最后两段中做出的*可疑假设*，即我们设计数学模型时的假设。**我们**（现在知道是错误的）**假设从两个约束条件自然会形成一个*单一的旅行路线***。但正如我们刚刚可视化的那样，并非如此。为什么？
- en: 'The root cause of the error lies in what I call “**unspoken common-sense**”:
    knowledge we have about the world that is so obvious that we forget to specify
    it in the model'
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 错误的根源在于我所称的“**未言明的常识**”：我们对世界的知识如此明显，以至于我们忘记在模型中指定它。
- en: We knew, **implicitly**, that teleportation is not possible when visiting sites,
    **but we didn’t explicitly tell the model**. That’s why we observe those little
    subtours, connecting some of the sites, but not all. The model “thinks” it’s okay
    to teleport from one site to another, as long as, once it’s on a site, it is *exited*
    once and *entered* once (see Figure 3.2 again). If we see subtours is only because
    we told the model to minimize the tour’s distance, and just so happens that teleportation
    is helpful at saving distance.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们**隐含地**知道在访问站点时传送是不可能的，**但我们没有明确告知模型**。这就是为什么我们观察到那些小的子旅行，连接了一些站点，但不是全部。模型“认为”从一个站点传送到另一个站点是可以的，只要一旦到达某个站点，就会*退出*一次并*进入*一次（请再次查看图3.2）。我们之所以看到子旅行，仅仅是因为我们告诉模型最小化旅行的距离，而正好传送有助于节省距离。
- en: Thus, **we need to prevent the formation of these subtours** to obtain a realistic
    solution. **We need to design some new constraints** that “tell the model” that
    subtours are forbidden, or, equivalently, that **the solution must be a single
    tour**. Let’s go with the latter, and **deduce, from first principles**, one set
    of constraints that is intuitive and does the job fine.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，**我们需要防止这些子旅行的形成**以获得一个现实的解。**我们需要设计一些新的约束条件**，以“告知模型”子旅行是被禁止的，或者说，**解必须是一个单一的旅行**。我们选择后者，并**从第一原则出发**，推导出一组直观的约束条件，并能很好地完成任务。
- en: 3\. Fixing the formulation
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3\. 修正模型
- en: Referring to the [Agile Operations Research workflow], we are now in the **model
    reformulation phase**. A reformulation of a model could be about improving it
    or fixing it. Ours will be about fixing it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 参考[敏捷运筹研究工作流程]，我们现在处于**模型重新制定阶段**。模型的重新制定可能涉及改进或修复。我们的目的是修复它。
- en: 'We know what we want: to force the solution to be a single tour, starting and
    ending at our initial site, the hotel. **The challenge is how to encode that requirement
    into a set of linear constraints**. Below is one idea, stemming from the properties
    of a tour.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们想要什么：强制解为一个单一的旅行，从我们的初始站点，即酒店，开始和结束。**挑战在于如何将这一要求编码为一组线性约束**。下面是一个想法，源于旅行的性质。
- en: 3.1\. The motivating idea
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1\. 激励思想
- en: We have 𝑁 sites to “traverse”, including the hotel. Since we start at the hotel,
    that means 𝑁 − 1 sites left to visit. **If we keep track of the “chronological
    order” in which we visit those sites**, such that the first destination (after
    the hotel) is given the number 1, the second destination is given the number 2,
    and so on, then the last destination before returning to the hotel will be given
    the number 𝑁 − 1\. If we call these numbers used to track the order of visits
    “*ranks*”, then **the pattern that occurs in the tour** is that *the rank of any
    site (****other than the hotel****) is always 1 unit higher than the rank of the
    site that preceded it in the tour*. If we could **formulate a set of constraints
    that impose such a pattern on any feasible solution**, we would be, loosely speaking,
    introducing a “chronological order” requirement in the model. And it turns out
    we can indeed.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有𝑁个站点需要“遍历”，包括酒店。由于我们从酒店开始，这意味着还有 𝑁 − 1 个站点需要访问。**如果我们跟踪访问这些站点的“时间顺序”**，使得第一个目的地（酒店之后）标记为1，第二个目的地标记为2，以此类推，那么在返回酒店之前的最后一个目的地将被标记为
    𝑁 − 1。如果我们将这些用于跟踪访问顺序的数字称为“*等级*”，那么**在旅行中出现的模式**是*任何站点（**除了酒店**）的等级总是比前一个站点的等级高1个单位*。如果我们能够**制定一组约束条件，使得任何可行解都符合这种模式**，那么可以说，我们在模型中引入了一个“时间顺序”的要求。事实证明我们确实可以做到这一点。
- en: 3.2\. Expressing the motivating idea as logical implications
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2\. 将激励思想表达为逻辑蕴涵
- en: '*💡* *This is the “pattern” that we want any feasible solution to satisfy:*'
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*💡* *这是我们希望任何可行解都满足的“模式”：*'
- en: ''
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The rank of any site (other than the hotel) must always be 1 unit higher than
    the rank of the site that preceded it in the tour
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 任何站点（除了酒店）的等级必须总是比其在旅行中前面的站点的等级高1个单位
- en: 'We can re-express this pattern as a **logical implication**, like this: “the
    rank of site 𝑗 must be 1 unit higher than the rank of site 𝑖 *if and only if*
    𝑗 is visited right after 𝑖, for all arcs (𝑖, 𝑗) that do not include the hotel
    𝐻”. This wording is expressed mathematically as:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个模式重新表达为一个**逻辑蕴涵**，如下：“站点𝑗的等级必须比站点𝑖的等级高1个单位*当且仅当* 𝑗 紧接着 𝑖 被访问，对于所有不包括酒店𝐻的弧
    (𝑖, 𝑗)”。这个措辞在数学上表示为：
- en: '![](../Images/76ce023b64fdfb59d61f06838d7b8f0b.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/76ce023b64fdfb59d61f06838d7b8f0b.png)'
- en: '**Expression 3.6\.** Logical implication for rank variables: they increase
    by 1 with each new site visited.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式 3.6\.** 排名变量的逻辑含义：每访问一个新地点，排名增加 1。'
- en: 'where 𝑟ᵢ are the **new variables we need to keep track of the (yet unknown)
    order of visits**. To distinguish them from the decision variables, let’s call
    them “**rank** variables”. The right side is read as “for all 𝑖 and 𝑗 belonging
    to the set of all sites excluding the hotel”. For *notational convenience*, we
    define the new set 𝕊* to store all the sites except the hotel (denoted by 𝐻):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 𝑟ᵢ 是**我们需要跟踪（尚未确定的）访问顺序的新变量**。为了将它们与决策变量区分开来，我们称它们为“**排名**变量”。右侧的意思是“对于所有属于所有地点集合（不包括酒店）的
    𝑖 和 𝑗”。为了*符号方便*，我们定义新的集合 𝕊* 来存储除酒店之外的所有地点（用 𝐻 表示）：
- en: '![](../Images/b45b2753cce9e55709c1509d1efc521e.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b45b2753cce9e55709c1509d1efc521e.png)'
- en: '**Expression 3.7\.** The set of all sites of interest: all sites except the
    hotel.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式 3.7\.** 所有感兴趣地点的集合：所有地点，除酒店外。'
- en: 'which allows us to define the rank variables concisely as:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们简洁地定义排名变量为：
- en: '![](../Images/efecbbacc7c452405d7d615d61c2d04f.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/efecbbacc7c452405d7d615d61c2d04f.png)'
- en: '**Expression 3.8.** Definition of the rank variables, defined only for the
    sites of interest.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式 3.8.** 排名变量的定义，仅定义在感兴趣的地点。'
- en: '*👁️* *It’s crucial that the hotel* ***does not have an associated rank variable***
    *because* it will be simultaneously the origin and final destination of any tour*,
    a condition that* ***would violate the pattern*** *of “ever increasing rank variables
    in the tour”. This way, the rank of each site is always forced to increase with
    any new arc taken, which ensures that* ***closed loops are prohibited unless the
    loops close at the only site that doesn’t have a rank variable: the hotel***'
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*👁️* *酒店* ***不能有相关的排名变量*** *因为* 酒店将同时是任何旅行的起点和终点*，这一条件* ***会违反模式*** *“旅行中排名变量不断增加”*。这样，每个地点的排名总是随着每个新弧的添加而增加，从而确保*
    ***禁止封闭环路，除非环路闭合在唯一一个没有排名变量的地点：酒店***。'
- en: 'The bounds of 𝑟ᵢ are derived from its description: the rank starts at 1 and
    monotonically increases until all sites in 𝕊* are visited, thus ending at | 𝕊*
    | (the size of the set of non-hotel sites). Besides, we allow them to take any
    positive real value:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 𝑟ᵢ 的界限源自其描述：排名从 1 开始，并单调增加，直到所有 𝕊* 中的地点都被访问，最终为 | 𝕊* |（非酒店地点集合的大小）。此外，我们允许它们取任何正实数值：
- en: '![](../Images/9044818c9b95300536e6d8e8807a49d9.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9044818c9b95300536e6d8e8807a49d9.png)'
- en: '**Expression 3.9.** Bounds and range of the rank variables'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式 3.9.** 排名变量的范围和界限'
- en: 3.3\. Formulating the logical implications as linear constraints
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.3\. 将逻辑含义表述为线性约束
- en: The challenge now is to translate this logical implication to a set of linear
    constraints. Thankfully, **linear inequalities serve also the purpose of enforcing
    logical implications**, not just finite resource limitations.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的挑战是将这种逻辑含义转化为一组线性约束。幸运的是，**线性不等式也可以用来强制逻辑含义**，不仅仅是有限资源限制。
- en: One way to do that is through the so-called **Big-M method**, which consists
    of declaring a constraint in such a way that, **when the condition you care about
    is met, the constraint applies (becomes active), and when the condition you care
    about is not met, the constraint becomes redundant (becomes inactive)**. The technique
    is called “big-M” because it makes use of a constant value 𝑀 that **is sufficiently
    large so as to, when appearing in the constraint, render it redundant for every
    case**. When 𝑀 does not appear in the constraint, the constraint is “active” in
    the sense that it is enforcing the *desired implication*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是通过所谓的**Big-M 方法**，其包括声明一个约束，使得**当您关心的条件满足时，约束有效（激活），当您关心的条件不满足时，约束变得冗余（失效）**。该技术称为“大
    M”是因为它使用一个常数值 𝑀，**该值足够大，以至于当出现在约束中时，使约束在任何情况下都变得冗余**。当 𝑀 不出现在约束中时，约束在*期望的含义*上是“有效的”。
- en: '**But what determines whether a constraint is “active” or not?** The short
    answer is the **values of the decision variables themselves** that the constraint
    applies to. Let’s see how it works.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**但是什么决定了约束是否“有效”？** 简短的回答是约束所应用的**决策变量的值**。让我们看看它是如何工作的。'
- en: The desired implication is to have 𝑟ⱼ = 𝑟ᵢ + 1 only when 𝛿ᵢⱼ = 1\. We can replace
    the 1 in the expression with 𝛿ᵢⱼ, which yields
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 希望的含义是仅当 𝛿ᵢⱼ = 1 时 𝑟ⱼ = 𝑟ᵢ + 1。我们可以用 𝛿ᵢⱼ 替代表达式中的 1，得到
- en: '![](../Images/ce44a6deb3909982fc5f7195c0b9ab90.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ce44a6deb3909982fc5f7195c0b9ab90.png)'
- en: This is the relation we want to hold when 𝛿ᵢⱼ = 1, but not when 𝛿ᵢⱼ = 0\. To
    “correct” for the case when 𝛿ᵢⱼ = 0, **we add a redundancy term,** 𝑅𝑇**, whose
    function is to “deactivate the constraint” only when** 𝛿ᵢⱼ = 0\. Therefore, this
    redundancy term must include the variable 𝛿ᵢⱼ, as it depends on it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当𝛿ᵢⱼ = 1时，这是我们希望保持的关系，但当𝛿ᵢⱼ = 0时则不是。为了“纠正”𝛿ᵢⱼ = 0的情况，**我们添加一个冗余项** 𝑅𝑇 **，其功能是仅在**
    𝛿ᵢⱼ = 0 **时“解除约束”。因此，这个冗余项必须包括变量𝛿ᵢⱼ，因为它依赖于它。**
- en: '![](../Images/d1bc487b50553663942c9939915fdfdf.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d1bc487b50553663942c9939915fdfdf.png)'
- en: '*In this context, “deactivating the constraint” stands for “making it redundant”,
    since a redundant constraint has the same effect as a non-existing constraint
    in a model.*'
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*在这个上下文中，“解除约束”意味着“使其冗余”，因为冗余约束在模型中与不存在的约束效果相同。*'
- en: 'Let’s see how we can deduce the expression for *RT*. The expression for 𝑅𝑇(𝛿ᵢⱼ)
    needs to satisfy these properties:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来深入探讨如何推导*RT*的表达式。𝑅𝑇(𝛿ᵢⱼ)的表达式需要满足以下这些属性：
- en: '![](../Images/a80c248947cb3c1c1b6961574decc29f.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a80c248947cb3c1c1b6961574decc29f.png)'
- en: '**Expression 3.10.** Properties the redundancy term must satisfy to enforce
    valid redundancy.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式 3.10.** 冗余项必须满足的属性以确保有效的冗余。'
- en: To satisfy point (1) we need 𝑅𝑇(𝛿ᵢⱼ = 1) = 0, and thus the expression for 𝑅𝑇
    must contain the multiplier (1 − 𝛿ᵢⱼ), as it becomes 0 when 𝛿ᵢⱼ =1\. This form
    makes 𝑅𝑇 “vanish” when 𝛿ᵢⱼ = 1, or “be reduced” to a constant (let’s call it *M*)
    when 𝛿ᵢⱼ = 0\. Thus, a candidate for the redundancy term is
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足点（1），我们需要𝑅𝑇(𝛿ᵢⱼ = 1) = 0，因此𝑅𝑇的表达式必须包含乘数（1 − 𝛿ᵢⱼ），因为当𝛿ᵢⱼ = 1时它变为0。这种形式使𝑅𝑇在𝛿ᵢⱼ
    = 1时“消失”，或在𝛿ᵢⱼ = 0时“减少”为一个常数（我们称之为*M*）。因此，冗余项的一个候选项是
- en: '![](../Images/67e2e24e2c25fe241ac7b1461d740a72.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/67e2e24e2c25fe241ac7b1461d740a72.png)'
- en: '**Expression 3.11.** Definition of the “redundancy term” needed to selectively
    make some constraints redundant.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式 3.11.** 定义用于选择性使某些约束变为冗余的“冗余项”。'
- en: where 𝑀 should be determined from the problem data (more on that later).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 其中𝑀应该从问题数据中确定（稍后会详细说明）。
- en: To satisfy point (2) for **all possible 𝑖’s and 𝑗’s**, we need to make the equality
    in expression (3.11) an inequality (= becomes ≥), and **find a constant** 𝑀 **big
    enough (in absolute value) so that, no matter what values** 𝑟ⱼ **and** 𝑟ᵢ **take,
    the constraint is always satisfied**. This is where the “big” in “big M” comes
    from.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足**所有可能的𝑖和𝑗**的点（2），我们需要将表达式（3.11）中的等式变成不等式（=变为≥），并**找到一个足够大的常数** 𝑀 **（绝对值）以确保无论**
    𝑟ⱼ **和** 𝑟ᵢ **取什么值，约束始终得到满足**。这就是“大M”中的“大”的来源。
- en: Once we find such a **sufficiently large constant** 𝑀, our “logical implication”
    constraint will take the form
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到这样的**足够大的常数** 𝑀，我们的“逻辑暗示”约束将采取以下形式
- en: '![](../Images/ac57dd4e680caee411938e2ec4e60f96.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ac57dd4e680caee411938e2ec4e60f96.png)'
- en: '**Expression 3.12**. Constraints for the implication that “a site’s rank must
    be higher than its preceding site’s”.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式 3.12**. 对于“一个站点的等级必须高于其前一个站点”的暗示的约束。'
- en: Introducing these constraints into the model will, presumably, force the solution
    to be a single tour. But the constraints won’t have the desired effect unless
    we first specify a good value for *M.*
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些约束引入模型中，将会强制解为单一巡回。但如果我们不首先指定一个好的*M*值，约束将不会产生期望的效果。
- en: 3.4\. Deducing a proper value for the “big M”
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.4. 推导出“巨大M”的适当值
- en: 'Since the goal is to have 𝑅𝑇(𝛿ᵢⱼ = 0) = 𝑀, we can **deduce a proper value for**
    𝑀 by setting 𝛿ᵢⱼ = 0 in the general constraint stated in Expression (3.12):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于目标是使𝑅𝑇(𝛿ᵢⱼ = 0) = 𝑀，我们可以通过在表达式（3.12）中设置𝛿ᵢⱼ = 0来**推导出适当的** 𝑀 **值：**
- en: '![](../Images/b33d3bcb04f30c303366638dcd576754.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b33d3bcb04f30c303366638dcd576754.png)'
- en: '**Expression 3.13.** Deduction of minimum value for M.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式 3.13.** 𝑀的最小值的推导。'
- en: For 𝑟ⱼ − 𝑟ᵢ ≥ 𝑀 to be **satisfied for all non-hotel sites** 𝑖, 𝑗, we need the
    **lower bound** **of 𝑟ⱼ − 𝑟ᵢ to be also greater than 𝑀.** The lower bound (LB)
    of 𝑟ⱼ − 𝑟ᵢ is the minimum value that 𝑟ⱼ − 𝑟ᵢ can take, and can be obtained by
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使𝑟ⱼ − 𝑟ᵢ ≥ 𝑀对**所有非酒店站点** 𝑖，𝑗 **都满足，我们需要** 𝑟ⱼ − 𝑟ᵢ **的下界也大于𝑀。** 𝑟ⱼ − 𝑟ᵢ的下界（LB）是𝑟ⱼ
    − 𝑟ᵢ可以取的最小值，可以通过以下方式获得
- en: '![](../Images/e052a9f7fb498681f45574c532e2f8c3.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e052a9f7fb498681f45574c532e2f8c3.png)'
- en: 'where 𝑟ᵐⁱⁿ is the minimum possible rank and 𝑟ᵐᵃˣ the maximum possible rank.
    Therefore, for inequality (1) in Expression (3.13) to be true for all ranks of
    all sites, the following inequality must hold too:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 其中𝑟ᵐⁱⁿ是可能的最低等级，𝑟ᵐᵃˣ是可能的最高等级。因此，为了使表达式（3.13）中的不等式（1）对所有站点的所有等级都成立，以下不等式也必须成立：
- en: '![](../Images/c35c59fb0307427a3ffa7b4f60712565.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c35c59fb0307427a3ffa7b4f60712565.png)'
- en: Thanks to this inequalitywe know **the minimum value that** 𝑀 **must take in
    order for the big-M method to work**, which is
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了这个不等式，我们知道**为了使大M方法有效，𝑀 必须取的最小值**是
- en: '![](../Images/509528146ae2d5bdfdbaad62174cf8e1.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/509528146ae2d5bdfdbaad62174cf8e1.png)'
- en: '**Expression 3.14\.** Lower bound for the big-M.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式 3.14**. 大M的下界。'
- en: 'And what are the values of 𝑟ᵐⁱⁿ and 𝑟ᵐᵃˣ? In our convention, we gave the first
    visited site the rank 1, which is, of course, the *minimum rank* (*i.e.*, 𝑟ᵐⁱⁿ
    = 1). Since the rank grows by 1 unit in each site visited, the last non-hotel
    site in the tour will have the *maximum rank*, equal to *the number of all non-hotel
    sites*. As the number of non-hotel sites can vary, we need a general expression.
    If you remember, we defined the set 𝕊* to contain all non-hotel sites, so the
    number we’re after is the *size* (*i.e.*, the number of elements) of the set 𝕊*,
    which in math notation is expressed as | 𝕊* |. Thus, we have deduced that 𝑟ᵐⁱⁿ
    = 1 and 𝑟ᵐᵃˣ = | 𝕊* |. Substituting in Expression (3.14), we finally arrive at
    a proper value for M:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 𝑟ᵐⁱⁿ 和 𝑟ᵐᵃˣ 的值是多少？根据我们的约定，我们给第一个访问的站点排了第 1 名，这当然是*最小排名*（*即*，𝑟ᵐⁱⁿ = 1）。由于排名在每个访问的站点中增加
    1 单位，旅行中的最后一个非酒店站点将具有*最大排名*，等于*所有非酒店站点的数量*。由于非酒店站点的数量可能会变化，我们需要一个通用表达式。如果你还记得，我们定义了集合
    𝕊* 包含所有非酒店站点，因此我们要找的数字是集合 𝕊* 的*大小*（*即*，元素的数量），用数学符号表示为 | 𝕊* |。因此，我们推导出 𝑟ᵐⁱⁿ =
    1 和 𝑟ᵐᵃˣ = | 𝕊* |。代入表达式（3.14），我们最终得到了一个适当的 M 值：
- en: '![](../Images/ceb6c3b83c0912cf432ce8397d299483.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ceb6c3b83c0912cf432ce8397d299483.png)'
- en: '**Expression 3.15**. The value of the big-M, deduced from the problem data.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式 3.15**. 从问题数据中推导出的“大M”值。'
- en: Because 𝕊* will always have more than 2 sites to be visited (*otherwise, there
    would be no* ***decision*** *problem at all in the first place*), the “big M”
    value, in this model, is always a **negative “big” value”**.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 𝕊* 总是会有超过 2 个需要访问的站点（*否则就没有* ***决策*** *问题*），在这个模型中，“大M”值总是**负的“大”值**。
- en: '*📝* **Theoretical *values* versus computational *values***'
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*📝* **理论*值*与计算*值***'
- en: ''
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Theoretically, we are allowed to choose arbitrarily “more negative” values
    for 𝑀 than the one deduced here—even make up* huge *numbers to be sure they’re
    big enough, to avoid this calculation — but* ***this is not good practice.***
    *If 𝑀 gets too large (in absolute value), it can create* performance issues *in
    the solver’s algorithms, or, in the worst case scenario, even make the solver*
    ***consider infeasible solutions as feasible****. That’s why the recommended practice
    is to derive, from the problem’s data, a* ***tight, but sufficiently large value***
    *for 𝑀.*'
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*理论上，我们可以选择比这里推导出的 𝑀 值更“负”的值——甚至可以编造* 巨大的 *数字以确保它们足够大，避免这个计算——但* ***这不是好的实践。***
    *如果 𝑀 变得过大（绝对值），可能会在求解器的算法中产生* 性能问题 *，或者，在最坏的情况下，甚至使求解器*** 将不可行的解视为可行解***。这就是为什么推荐的做法是从问题数据中推导出*
    ***紧凑但足够大的值*** *来表示 𝑀。*'
- en: Now that we have deduced a proper value for “big M”, we will store it in a new
    model parameter, for easier reuse. With this, **the subtour elimination constraint
    set is ready**, and its “full form” is
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经推导出适当的“大M”值，我们将把它存储在新的模型参数中，以便于重复使用。有了这个，**子旅行排除约束集已准备好**，其“完整形式”为
- en: '![](../Images/173a04975424ba275a920b98435085e5.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/173a04975424ba275a920b98435085e5.png)'
- en: '**Expression 3.16**. The subtour elimination constraints.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式 3.16**. 子旅行排除约束。'
- en: 'To keep things in perspective, note that this is actually the “**constraint
    equivalent”** of the original **logical implication** we formulated earlier in
    Expression (3.6):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持视角的准确性，请注意，这实际上是**原始** **逻辑蕴涵**在表达式（3.6）中的“**约束等价物**”：
- en: '![](../Images/0f3a375a13ac3a1a07f78e43acb5a5d4.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0f3a375a13ac3a1a07f78e43acb5a5d4.png)'
- en: Congratulations! We finally have a set of constraints that can be added to our
    model. Coming up with them was the hard part. Now, let’s verify that their addition
    to the model really results in the disappearance of subtours.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们终于有了一组可以添加到模型中的约束。提出这些约束是困难的部分。现在，让我们验证将它们添加到模型中是否真的能消除子旅行。
- en: 4\. Implementing and verifying the new formulation
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4\. 实现和验证新公式
- en: 4.1\. Augmenting the Pyomo model with the new formulation
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1\. 使用新公式扩展 Pyomo 模型
- en: Revising and correcting the model has required the addition of a few more sets,
    parameters, variables, and constraints. Let’s add these new **model components**
    to the Pyomo model, following the same order as in the initial formulation phase.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 修订和纠正模型需要添加一些额外的集合、参数、变量和约束。让我们将这些新的**模型组件**按照最初制定阶段的顺序添加到 Pyomo 模型中。
- en: 4.1.1\. Sets and parameters
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1.1\. 集合和参数
- en: '**Sites of interest**, 𝕊*: set of all sites **excluding the hotel:**'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**感兴趣的站点**，𝕊*: 所有站点的集合 **不包括酒店：**'
- en: '![](../Images/a510017c12ff97cc877f6b116824557e.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a510017c12ff97cc877f6b116824557e.png)'
- en: '**Expression 3.17**. Definition of the set of sites of interest (a.k.a., non-hotel
    sites)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式 3.17**。感兴趣的站点集合的定义（即，非酒店站点）'
- en: '*Pyomo* `Set` objects have operations compatible with *Python* sets, so we
    can do the difference between a Pyomo set and a Python set directly:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*Pyomo* `Set` 对象具有与 *Python* 集合兼容的操作，因此我们可以直接计算 Pyomo 集合与 Python 集合之间的差异：'
- en: '[PRE18]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**big M**, the new parameter for the subtour elimination constraint:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大 M**，子回路消除约束的新参数：'
- en: '![](../Images/ceb6c3b83c0912cf432ce8397d299483.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ceb6c3b83c0912cf432ce8397d299483.png)'
- en: '[PRE19]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 4.1.2\. Auxiliary variables
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1.2\. 辅助变量
- en: '**rank variables, r**ᵢ: to keep track of the order in which sites are visited:'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**排序变量，r**ᵢ: 用于跟踪站点访问顺序：'
- en: '![](../Images/f6be26d9f90a5b0a066539c01ff727f8.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f6be26d9f90a5b0a066539c01ff727f8.png)'
- en: '[PRE20]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the comments, you can see how nicely the elements of the full *mathematical
    definition* of the variables map to the arguments of the *Pyomo variable declaration*
    function `pyo.Var`. I hope this helps you appreciate the value of having a well-defined
    *mathematical* model before starting to build a *Pyomo* model. The implementation
    will just flow naturally, and errors will be less likely.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在评论中，你可以看到完整的*数学定义*中变量的元素是如何很好地映射到*Pyomo 变量声明*函数 `pyo.Var` 的参数上的。我希望这有助于你理解在开始构建
    *Pyomo* 模型之前拥有一个良好定义的*数学*模型的价值。实现过程将自然流畅，错误也会减少。
- en: 4.1.3\. Constraints
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1.3\. 约束
- en: 'The solution must be a **single tour** starting and ending at the hotel:'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解必须是一个**从酒店开始并结束的单一巡回**：
- en: '![](../Images/173a04975424ba275a920b98435085e5.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/173a04975424ba275a920b98435085e5.png)'
- en: '[PRE21]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The Pyomo model has been updated. How much has it grown after the addition of
    the subtour elimination constraints?
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Pyomo 模型已更新。增加子回路消除约束后，它增长了多少？
- en: '[PRE22]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We have gone **from 72 to 80 variables and from 18 to 74 constraints**. Clearly,
    this formulation is heavier on constraints than on variables, as it has quadrupled
    the number of constraints we had before. That’s the “price we pay”, in general,
    for making models more “realistic”, as realism usually entails—if the data is
    unchanged—limiting the number of allowable solutions.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经**从72个变量增加到80个变量，从18个约束增加到74个约束**。显然，这种表述在约束方面比变量更多，因为它使我们之前的约束数量增加了四倍。这就是我们通常为使模型更“现实”而付出的代价，因为现实性通常意味着——如果数据不变——限制可允许的解的数量。
- en: As always, we can inspect the model structure with`model.pprint()`. Although
    this “print” loses its value rapidly as the number of model components grows,
    it still can give us a quick overview of what the model is made of, and how big
    it is.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们可以使用`model.pprint()`检查模型结构。虽然随着模型组件数量的增加，这种“打印”迅速失去价值，但它仍然可以让我们快速了解模型的构成和规模。
- en: 4.2\. Plotting the updated model’s solution
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.2\. 绘制更新模型的解
- en: Let’s solve the updated model and plot the new solution. Fingers crossed.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解决更新后的模型并绘制新解。祈祷好运。
- en: '[PRE23]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![](../Images/15644a14b7ecefad953db4ce9ce3a954.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/15644a14b7ecefad953db4ce9ce3a954.png)'
- en: 'Now we’re talking! This is exactly what we were expecting after the addition
    of the new constraints: **no subtours have formed**, which makes the solution
    path **a single tour** now.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们说到点子了！这正是我们在新增约束后期待的结果：**没有形成子回路**，这使得解路径现在变成了**单一巡回**。
- en: Note how, obviously, the objective value of this solved model is now 14.9 km,
    instead of the unfaithful 5.7 km we got with the incomplete model.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，显然，这个解模型的目标值现在是 14.9 公里，而不是不准确的 5.7 公里，我们从不完整的模型中得到的。
- en: '***👁️* A drawing of a graph is not a tour on a map**'
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '***👁️* 图形绘制不是地图上的巡回**'
- en: ''
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Note that this image is just one possible **drawing** of a graph, not a geographical
    trajectory. The circles and links you see do not correspond to a real path in
    geographical space (how could it, if we haven’t used any geographical information
    in its creation?). You can verify this yourself by running `plot_solution_as_graph(model)`
    multiple times: each time you run it, the nodes will take different positions.
    [Graphs](https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)) are abstract
    mathematical structures that connect "points" through "links", representing relationships
    of any kind between entities of any kind. We used a graph here to **study the
    solution''s validity**, not to **visualize the real tour** in Paris. We do that
    in [this article].'
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请注意，这张图片仅仅是图表的一种可能**绘图**，而不是地理轨迹。你看到的圆圈和链接并不对应于地理空间中的实际路径（如果我们没有在创建过程中使用任何地理信息，它怎么可能对应呢？）。你可以通过多次运行`plot_solution_as_graph(model)`来验证这一点：每次运行时，节点的位置都会不同。[图表](https://en.wikipedia.org/wiki/Graph_(discrete_mathematics))是抽象的数学结构，通过“链接”连接“点”，表示任意实体之间的关系。我们在这里使用图表来**研究解决方案的有效性**，而不是**可视化巴黎的真实旅行**。我们在[这篇文章]中做到了这一点。
- en: 5\. Conclusion (or planning for the next sprint)
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5\. 结论（或规划下一个冲刺）
- en: With this final verification of the solution, **we conclude that this updated
    version of the model can solve any instance of the Traveling Salesman Problem**,
    so we can consider it a successful proof-of-concept (POC).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对解决方案的最终验证，**我们得出结论，这个更新版本的模型可以解决任何实例的旅行推销员问题**，因此我们可以认为它是一个成功的概念验证（POC）。
- en: '*💡* **Evolving solutions, one sprint at a time**'
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*💡* **逐步演进解决方案，每次冲刺一个**'
- en: ''
  id: totrans-240
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This POC doesn’t solve (yet) our original [complex tourism problem](https://medium.com/@carlosjuribe/plan-an-optimal-trip-for-your-next-holidays-with-the-help-of-operations-research-and-python-481b1ea38fef),
    but **it does solve the minimum valuable problem** we proposed as the first stepping-stone
    towards a more sophisticated solution. Hence, **it gets us provably** (i.e., evidence-based)
    **closer to a valuable solution of the more complex problem**. With a minimal
    *working* example at hand, we can better evaluate what needs to be done to advance
    in the direction we want, and what can be provisionally *simplified away* until
    a more mature version of the solution is reached. **While having something useful
    at all times, we’ll develop an increasingly-valuable system, until we’re** [**satisficed**](https://en.wikipedia.org/wiki/Satisficing).
    That is the essence of the “agile road” to effective solutions.
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个POC尚未解决我们原始的[复杂旅游问题](https://medium.com/@carlosjuribe/plan-an-optimal-trip-for-your-next-holidays-with-the-help-of-operations-research-and-python-481b1ea38fef)，但**它确实解决了我们作为第一个基石提出的最小有价值问题**。因此，**它确实使我们可以证明**（即基于证据）**更接近复杂问题的有价值解决方案**。有了一个最小的*有效*示例，我们可以更好地评估在我们希望的方向上需要做什么，以及在解决方案的更成熟版本达到之前可以临时*简化掉*的内容。**在任何时候都有一些有用的东西，我们将开发一个越来越有价值的系统，直到我们**[**满足**](https://en.wikipedia.org/wiki/Satisficing)。这就是通往有效解决方案的“敏捷之路”的本质。
- en: With the validity of this approach proven, we must expand it and refine it so
    **it can gradually encompass more features of our original problem**, with each
    iteration providing **incrementally valuable solutions.** In this POC, we focused
    on the design and formulation of a basic model, so we had to assume a fixed set
    of sites and their distance matrix as a given. Of course, this is limiting, and
    the next step should be to have a model that accepts any number of sites. For
    that, **we need a way to automatically generate the distance matrix given a list
    of sites and their geographical coordinates.** That is the goal of [our next sprint](https://medium.com/@carlosjuribe/compute-the-distance-matrix-of-a-set-of-sites-from-their-coordinates-in-python-d5fc92a0ba9e).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的有效性已经得到验证，我们必须扩展和改进它，以便**逐渐涵盖我们原始问题的更多特征**，每次迭代都提供**逐步有价值的解决方案**。在这个POC中，我们专注于基本模型的设计和制定，因此我们不得不假设一组固定的站点及其距离矩阵作为给定条件。当然，这具有局限性，下一步应该是有一个能够接受任意数量站点的模型。为此，**我们需要一种方法，根据站点列表及其地理坐标自动生成距离矩阵**。这就是[我们下一个冲刺](https://medium.com/@carlosjuribe/compute-the-distance-matrix-of-a-set-of-sites-from-their-coordinates-in-python-d5fc92a0ba9e)的目标。
- en: 5.1\. What’s next
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1\. 接下来做什么
- en: 'In the next article (sprint 4) we will work on a class that **generates a distance
    matrix automatically from any list of sites.** This functionality, when combined
    with the model we just built here**,** will allow us, among other things, to solve
    **many models for different inputs, quickly,** and compare them**.** Besides,
    generalizing the solution this way will make our lives easier later on when we
    do a bit of **sensitivity and scenario analysis** in future sprints. Also, as
    we will upgrade this proof-of-concept to an “MVP status”, we will start using
    **object-oriented code** to keep things well organized, and ready for extensibility.
    Don’t waste the flow and jump [right in](https://medium.com/@carlosjuribe/compute-the-distance-matrix-of-a-set-of-sites-from-their-coordinates-in-python-d5fc92a0ba9e):'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一篇文章（第4次冲刺）中，我们将创建一个**从任何站点列表中自动生成距离矩阵**的类。这一功能与我们刚刚在这里构建的模型结合起来，将使我们能够快速地解决**不同输入的多个模型**，并进行比较**。**此外，以这种方式对解决方案进行概括，将使我们在未来进行一些**敏感性和情景分析**时更加轻松。此外，随着我们将这个概念验证升级为“MVP状态”，我们将开始使用**面向对象的代码**来保持良好的组织，并为扩展做好准备。不要浪费时间，直接跳到[这里](https://medium.com/@carlosjuribe/compute-the-distance-matrix-of-a-set-of-sites-from-their-coordinates-in-python-d5fc92a0ba9e)：
- en: '[](/compute-the-distance-matrix-of-a-set-of-sites-from-their-coordinates-in-python-d5fc92a0ba9e?source=post_page-----fc7ee8198b6c--------------------------------)
    [## Compute the Distance Matrix of a Set of Sites from Their Coordinates in Python'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[](/compute-the-distance-matrix-of-a-set-of-sites-from-their-coordinates-in-python-d5fc92a0ba9e?source=post_page-----fc7ee8198b6c--------------------------------)
    [## 从地理坐标计算一组站点的距离矩阵'
- en: Estimate the distance between any pair of sites from their geographical coordinates
    as a stepping stone to solving…
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从地理坐标估算任何一对站点之间的距离，作为解决问题的一个起点……
- en: towardsdatascience.com](/compute-the-distance-matrix-of-a-set-of-sites-from-their-coordinates-in-python-d5fc92a0ba9e?source=post_page-----fc7ee8198b6c--------------------------------)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: towardsdatascience.com](/compute-the-distance-matrix-of-a-set-of-sites-from-their-coordinates-in-python-d5fc92a0ba9e?source=post_page-----fc7ee8198b6c--------------------------------)
- en: Footnotes
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚注
- en: 'Actually, there’s another cause for a wrong result: the *data* the model feeds
    on can also be wrong, not just the model formulation. But, in a sense, if you
    think of “a model” as a “**model instance**”, *i.e.*, a concrete model with concrete
    data, then the model will be of course wrong if the data is wrong, which is what
    I intended by the statement. [↩](#e5d1)'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际上，还有一个导致结果错误的原因：模型所依赖的*数据*也可能是错误的，不只是模型公式。但是，从某种意义上说，如果你把“模型”视为“**模型实例**”，*即*，一个具体的模型与具体的数据，那么如果数据错误，模型自然也会错误，这就是我声明中的意思。[↩](#e5d1)
- en: Thanks for reading, and see you in the next one! 📈😊
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢阅读，下次见！📈😊
- en: Feel free to follow me, ask me questions, **give me feedback** in the comments,
    or contact me on [LinkedIn](https://www.linkedin.com/in/carlosjuribe/).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 随时关注我，向我提问，在评论中**给我反馈**，或在[LinkedIn](https://www.linkedin.com/in/carlosjuribe/)上联系我。
