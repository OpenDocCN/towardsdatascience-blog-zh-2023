["```py\nimport numpy as np\nfrom PIL import Image\nimport math\n\ndef plot_line(from_coordinates, to_coordinates, thickness, colour, pixels):\n\n    # Figure out the boundaries of our pixel array\n    max_x_coordinate = len(pixels[0])\n    max_y_coordinate = len(pixels)\n\n    # The distances along the x and y axis between the 2 points\n    horizontal_distance = to_coordinates[1] - from_coordinates[1]\n    vertical_distance = to_coordinates[0] - from_coordinates[0]\n\n    # The total distance between the two points\n    distance =  math.sqrt((to_coordinates[1] - from_coordinates[1])**2 \\\n                + (to_coordinates[0] - from_coordinates[0])**2)\n\n    # How far we will step forwards each time we colour in a new pixel\n    horizontal_step = horizontal_distance/distance\n    vertical_step = vertical_distance/distance\n\n    # At this point, we enter the loop to draw the line in our pixel array\n    # Each iteration of the loop will add a new point along our line\n    for i in range(round(distance)):\n\n        # These 2 coordinates are the ones at the center of our line\n        current_x_coordinate = round(from_coordinates[1] + (horizontal_step*i))\n        current_y_coordinate = round(from_coordinates[0] + (vertical_step*i))\n\n        # Once we have the coordinates of our point, \n        # we draw around the coordinates of size 'thickness'\n        for x in range (-thickness, thickness):\n            for y in range (-thickness, thickness):\n                x_value = current_x_coordinate + x\n                y_value = current_y_coordinate + y\n\n                if (x_value > 0 and x_value < max_x_coordinate and \\\n                    y_value > 0 and y_value < max_y_coordinate):\n                    pixels[y_value][x_value] = colour\n\n# Define the size of our image\npixels = np.zeros( (500,500,3), dtype=np.uint8 )\n\n# Draw a line\nplot_line([0,0], [499,499], 1, [255,200,0], pixels)\n\n# Turn our pixel array into a real picture\nimg = Image.fromarray(pixels)\n\n# Show our picture, and save it\nimg.show()\nimg.save('Line.png')\n```", "```py\ndef draw_triangle(center, side_length, thickness, colour, pixels):\n\n    # The height of an equilateral triangle is, h = ½(√3a)\n    # where 'a' is the side length\n    triangle_height = round(side_length * math.sqrt(3)/2)\n\n    # The top corner\n    top = [center[0] - triangle_height/2, center[1]]\n\n    # Bottom left corner\n    bottom_left = [center[0] + triangle_height/2, center[1] - side_length/2]\n\n    # Bottom right corner\n    bottom_right = [center[0] + triangle_height/2, center[1] + side_length/2]\n\n    # Draw a line between each corner to complete the triangle\n    plot_line(top, bottom_left, thickness, colour, pixels)\n    plot_line(top, bottom_right, thickness, colour, pixels)\n    plot_line(bottom_left, bottom_right, thickness, colour, pixels)\n```", "```py\ndef rotate(coordinate, center_point, degrees):\n    # Subtract the point we are rotating around from our coordinate\n    x = (coordinate[0] - center_point[0])\n    y = (coordinate[1] - center_point[1])\n\n    # Python's cos and sin functions take radians instead of degrees\n    radians = math.radians(degrees)\n\n    # Calculate our rotated points \n    new_x = (x * math.cos(radians)) - (y * math.sin(radians))\n    new_y = (y * math.cos(radians)) + (x * math.sin(radians))\n\n    # Add back our offset we subtracted at the beginning to our rotated points\n    return [new_x + center_point[0], new_y + center_point[1]]\n```", "```py\ndef draw_triangle(center, side_length, degrees_rotate, thickness, colour, \\\n                  pixels, shrink_side_by, iteration, max_depth):\n\n    # The height of an equilateral triangle is, h = ½(√3a) \n    # where 'a' is the side length\n    triangle_height = side_length * math.sqrt(3)/2\n\n    # The top corner\n    top = [center[0] - triangle_height/2, center[1]]\n\n    # Bottom left corner\n    bottom_left = [center[0] + triangle_height/2, center[1] - side_length/2]\n\n    # Bottom right corner\n    bottom_right = [center[0] + triangle_height/2, center[1] + side_length/2]\n\n    if (degrees_rotate != 0):\n        top = rotate(top, center, degrees_rotate)\n        bottom_left = rotate(bottom_left, center, degrees_rotate)\n        bottom_right = rotate(bottom_right, center, degrees_rotate)\n\n    # Coordinates between each edge of the triangle\n    lines = [[top, bottom_left],[top, bottom_right],[bottom_left, bottom_right]]\n\n    line_number = 0\n\n    # Draw a line between each corner to complete the triangle\n    for line in lines:\n        line_number += 1\n\n        plot_line(line[0], line[1], thickness, colour, pixels)\n\n        # If we haven't reached max_depth, draw some new triangles\n        if (iteration < max_depth and (iteration < 1 or line_number < 3)):\n            gradient = (line[1][0] - line[0][0]) / (line[1][1] - line[0][1])\n\n            new_side_length = side_length*shrink_side_by\n\n            # Center of the line of the traingle we are drawing\n            center_of_line = [(line[0][0] + line[1][0]) / 2, \\\n                              (line[0][1] + line[1][1]) / 2]\n\n            new_center = []\n            new_rotation = degrees_rotate\n\n            # Amount we need to rotate the traingle by\n            if (line_number == 1):\n                new_rotation += 60\n            elif (line_number == 2):\n                new_rotation -= 60\n            else:\n                new_rotation += 180\n\n            # In an ideal world this would be gradient == 0,\n            # but due to floating point division we cannot\n            # ensure that this will always be the case\n            if (gradient < 0.0001 and gradient > -0.0001):\n                if (center_of_line[0] - center[0] > 0):\n                    new_center = [center_of_line[0] + triangle_height * \\\n                                 (shrink_side_by/2), center_of_line[1]]\n                else:\n                    new_center = [center_of_line[0] - triangle_height * \\\n                                  (shrink_side_by/2), center_of_line[1]]\n\n            else:\n\n                # Calculate the normal to the gradient of the line\n                difference_from_center = -1/gradient\n\n                # Calculate the distance from the center of the line\n                # to the center of our new traingle\n                distance_from_center = triangle_height * (shrink_side_by/2)\n\n                # Calculate the length in the x direction, \n                # from the center of our line to the center of our new triangle\n                x_length = math.sqrt((distance_from_center**2)/ \\\n                                     (1 + difference_from_center**2))\n\n                # Figure out which way around the x direction needs to go\n                if (center_of_line[1] < center[1] and x_length > 0):\n                    x_length *= -1\n\n                # Now calculate the length in the y direction\n                y_length = x_length * difference_from_center\n\n                # Offset the center of the line with our new x and y values\n                new_center = [center_of_line[0] + y_length, \\\n                              center_of_line[1] + x_length]\n\n            draw_triangle(new_center, new_side_length, new_rotation, \\\n                          thickness, colour, pixels, shrink_side_by, \\\n                          iteration+1, max_depth)\n```"]