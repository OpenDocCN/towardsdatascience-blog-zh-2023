- en: Why You Need a Knowledge Graph, And How to Build It
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/why-you-need-a-knowledgegraph-and-how-to-build-it-ac4f35cb75b7?source=collection_archive---------0-----------------------#2023-08-09](https://towardsdatascience.com/why-you-need-a-knowledgegraph-and-how-to-build-it-ac4f35cb75b7?source=collection_archive---------0-----------------------#2023-08-09)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A Guide to Migrating from a Relational Database to a Graph Database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://swpugsley.medium.com/?source=post_page-----ac4f35cb75b7--------------------------------)[![Stan
    Pugsley](../Images/3b9894cdd03406db213c017a7d77b113.png)](https://swpugsley.medium.com/?source=post_page-----ac4f35cb75b7--------------------------------)[](https://towardsdatascience.com/?source=post_page-----ac4f35cb75b7--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----ac4f35cb75b7--------------------------------)
    [Stan Pugsley](https://swpugsley.medium.com/?source=post_page-----ac4f35cb75b7--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fc3a1e6da7396&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fwhy-you-need-a-knowledgegraph-and-how-to-build-it-ac4f35cb75b7&user=Stan+Pugsley&userId=c3a1e6da7396&source=post_page-c3a1e6da7396----ac4f35cb75b7---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----ac4f35cb75b7--------------------------------)
    ·7 min read·Aug 9, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fac4f35cb75b7&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fwhy-you-need-a-knowledgegraph-and-how-to-build-it-ac4f35cb75b7&user=Stan+Pugsley&userId=c3a1e6da7396&source=-----ac4f35cb75b7---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fac4f35cb75b7&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fwhy-you-need-a-knowledgegraph-and-how-to-build-it-ac4f35cb75b7&source=-----ac4f35cb75b7---------------------bookmark_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: '**TLDR: A knowledge graph organizes events, people, resources, and documents
    in a graph database for advanced analysis. This article will explain the purpose
    of a knowledge graph and show you the basics of how to translate a relational
    data model into a graph model, load the data into a graph database, and write
    some sample graph queries.**'
  prefs: []
  type: TYPE_NORMAL
- en: Why a Knowledge Graph?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Relational databases are great for creating lists, but terrible for managing
    networks of diverse entities. Have you ever tried to do any of these tasks with
    a relational database?
  prefs: []
  type: TYPE_NORMAL
- en: analyze a **healthcare episode of care** when a patient interacted with dozens
    of people, places and procedures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: find patterns in **financial fraud** with a web of vendors, customers and transaction
    types involved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: optimize the dependencies and interconnected elements of a **supply chain**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are all examples of networks of events, people and resources that create
    huge headaches for SQL analysts using relational databases. Relational databases
    become exponentially slower as the network size increases, while graph databases
    have a relatively linear relationship. If you are managing a network, or web,
    of activities and things, a graph database is the right choice. In the future,
    we should expect to see enterprise data groups adopting a combination of **relational
    databases for isolated analysis** on one business function, and **knowledge graphs
    for complex, networked processes** that span functions.
  prefs: []
  type: TYPE_NORMAL
- en: A knowledge graph, based in graph database technology, is built to handle a
    diverse network of processes and entities. In a knowledge graph, you have nodes
    that represent people, events, places, resources, documents, etc. And you have
    relationships (edges) that represent links between the nodes. The relationships
    are physically stored in the database with a name and direction. Not every graph
    database is a knowledge graph. To be considered a knowledge graph, the design
    must **embed the business** [**semantic model**](https://medium.com/@nripapathak/semantic-data-modelling-92aa64582dc7),
    reflected in clear business names for nodes and relationships, in a diverse set
    of nodes that span multiple business functions. You are in essence creating a
    **seamless web** out of all parts of the business that interact, and using the
    business semantics to closely tie data to the processes they represent. This can
    serve as the **foundation for future generative LLM model** use.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate a diverse set of data in a knowledge graph, let’s look at a simple
    example for supply chain logistics. The business process might be modeled like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/157b14bda8e08226239735ed7c22e643.png)'
  prefs: []
  type: TYPE_IMG
- en: Supply chain graph database model. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: 'This model could be extended to include any related part of the business processes:
    customer returns, invoices, raw materials, manufacturing processes, employees,
    and even customer reviews. There is no pre-defined schema, so the model can expand
    in any direction or depth.'
  prefs: []
  type: TYPE_NORMAL
- en: From Relational Model to Dimensional Model to Graph Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let’s go through the process of translating a typical relational database
    model into a graph model using the scenario of an ecommerce vendor. Let’s assume
    that this vendor is running a series of digital marketing campaigns, receiving
    orders on their website, and shipping product to customers. The relational model
    could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6c7d862fcce9e6eb6d2b748783c195e3.png)'
  prefs: []
  type: TYPE_IMG
- en: Ecommerce relational database model. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to convert this to a dimensional model for use in a data warehouse,
    the model could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8ec4f138c2ec97e3157f82e4c312601c.png)'
  prefs: []
  type: TYPE_IMG
- en: Ecommerce dimensional model (data warehouse). Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the fact tables are focused on events, and the dimension tables represent
    all of the attributes of a business entity combined into one table. This event-centered
    design gives faster query time, but creates other problems. Each event is a distinct
    fact table, and it is difficult to see the connection from one event to a related
    event. There is no easy way to understand all the relationships between a dimension
    entity, like a product, and all of the events that it shares with an entity in
    another dimension, like a carrier, when those relationships are split between
    multiple fact tables. The Dimensional Model focuses on one event at a time, but
    obscures the connections between the different events.
  prefs: []
  type: TYPE_NORMAL
- en: 'The graph model solves the problem of showing interrelatedness between entities
    by modeling the process like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b95db77f848760ca2063af1978deaf7d.png)'
  prefs: []
  type: TYPE_IMG
- en: Ecommerce graph database model. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: On first look, this graph model has more similarities to the relational model
    than to the dimensional model, but it can be used for the same analytical purposes
    as the data warehouse. Note that each relationship is named and has a direction.
    And relationships can be created between any nodes — event to event, person to
    person, document to event, etc. **The graph queries also allow you to traverse
    the graph in ways not possible with SQL.**
  prefs: []
  type: TYPE_NORMAL
- en: For example you can gather any nodes related to a key event and study the pattern
    of occurrence. Hierarchies are preserved and each level can be referenced individually,
    unlike a denormalized dimension table. Most importantly, graphs are much more
    flexible in modeling any event or entity in the business without following a strict
    set of schema constraints. The graph is designed to match the semantic model of
    the business.
  prefs: []
  type: TYPE_NORMAL
- en: Extract, Transform and Load (ETL)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let’s look at a sample relational database table, and create some sample
    scripts to extract, transform and load the data into a graph database. For this
    article, I’m going to use Cypher language, which is used by [Neo4j](https://neo4j.com/),
    the most popular commercial graph database. But the concepts would apply to other
    variations of [graph query languages (GQL)](https://www.gqlstandards.org/). We
    will use the following sample Product table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/974529f665138bed48974a12b4720e57.png)'
  prefs: []
  type: TYPE_IMG
- en: Product table. Image by the author
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this query we could pull the new products updated in the last 24 hours:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We could pull those results into a [Python Pandas](https://pandas.pydata.org/)
    dataframe named “df”, open a graph database connection, and then merge the dataframe
    into the graph using this script
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first line references a parameter “df”, which is the dataframe from Pandas.
    We will merge into the node type “Product”, which is referenced by an alias “P”.
    Then the “product_id” section is used to bind to a unique identifier in the node.
    After that, the Merge statement looks similar to a merge in SQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have created each of the nodes using merge statements like the one
    above, we create relationships. Relationships may be created either in the same
    script, or in a post-processing script using a merge command like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The Match statement looks like the legacy join usage in Oracle, with two node
    types declared after the Match and then the join happening in the Where clause.
  prefs: []
  type: TYPE_NORMAL
- en: Queries on the Graph Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s assume that we have built the graph, and now want to query it. We can
    use a query like this to see the Ad Groups that have driven orders from Arizona.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This query would return the ad group name and count of orders, filtered on
    the state of Arizona. Note that no Group By clause is required in Cypher, unlike
    SQL. From that query, we would receive the following sample output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b05c0476daa8caf01376779c1ee5a8e1.png)'
  prefs: []
  type: TYPE_IMG
- en: Sample results from a graph query. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example might seem trivial because you could easily create a similar query
    in a relational database or data warehouse using the order fact table. But let’s
    consider a more complicated query. Suppose that you want to see the time it takes
    from the launch of a campaign until the attributable deliveries have been received.
    In a data warehouse, this query would cross fact tables (not a simple task) and
    take considerable resources. In a relational database, this query would involve
    a long series of joins. In a graph database, the query would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'I used one sample query path, but there are a variety of paths that a user
    could take to answer different business questions. In the query, note that the
    path from Campaign to Delivery goes through a relationship between the Order and
    Delivery. Also note that for readability, I split the path into two parts, starting
    with the alias for Ad in the second line. The output of the query would look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2f735ace47c047c8fb2c2caf55a7fc29.png)'
  prefs: []
  type: TYPE_IMG
- en: Sample results from a graph query. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have looked at some sample steps to translate an e-commerce business process
    from a relational model to a graph model, but we can’t cover all of the design
    principles in this one article. Hopefully you have seen that graph databases require
    about the **same level of technical skill** as relational databases, and that
    the migration isn’t a huge hurdle.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest challenge is to retrain your brain away from traditional relational
    modeling techniques and think in terms of semantic or business modeling. If you
    see a potential application for graph technology, give it a try with a proof-of-concept
    project. The possibilities for analysis with a knowledge graph reach far beyond
    what you can do with two dimensional tables!
  prefs: []
  type: TYPE_NORMAL
- en: '*All images are by the author*'
  prefs: []
  type: TYPE_NORMAL
