- en: 'Rust Polars: Unlocking High-Performance Data Analysis — Part 2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/rust-polars-unlocking-high-performance-data-analysis-part-2-7c58a3cb7a1f?source=collection_archive---------3-----------------------#2023-05-18](https://towardsdatascience.com/rust-polars-unlocking-high-performance-data-analysis-part-2-7c58a3cb7a1f?source=collection_archive---------3-----------------------#2023-05-18)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exploring Rust’s Polars DataFrames, Aggregation Functions, and Beyond
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://wiseai.medium.com/?source=post_page-----7c58a3cb7a1f--------------------------------)[![Mahmoud
    Harmouch](../Images/d61617549d25565399975debaad5908f.png)](https://wiseai.medium.com/?source=post_page-----7c58a3cb7a1f--------------------------------)[](https://towardsdatascience.com/?source=post_page-----7c58a3cb7a1f--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----7c58a3cb7a1f--------------------------------)
    [Mahmoud Harmouch](https://wiseai.medium.com/?source=post_page-----7c58a3cb7a1f--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fb15db3da5667&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Frust-polars-unlocking-high-performance-data-analysis-part-2-7c58a3cb7a1f&user=Mahmoud+Harmouch&userId=b15db3da5667&source=post_page-b15db3da5667----7c58a3cb7a1f---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----7c58a3cb7a1f--------------------------------)
    ·24 min read·May 18, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F7c58a3cb7a1f&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Frust-polars-unlocking-high-performance-data-analysis-part-2-7c58a3cb7a1f&user=Mahmoud+Harmouch&userId=b15db3da5667&source=-----7c58a3cb7a1f---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F7c58a3cb7a1f&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Frust-polars-unlocking-high-performance-data-analysis-part-2-7c58a3cb7a1f&source=-----7c58a3cb7a1f---------------------bookmark_footer-----------)![](../Images/700d954aea76580261342f38363b4daf.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Image by [Alan](https://pixabay.com/users/ad_images-6663717/?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=3348777)
    from [Pixabay](https://pixabay.com//?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=3348777)
  prefs: []
  type: TYPE_NORMAL
- en: TL;DR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Rust programming language has been making waves in the industry and is now
    gaining momentum within data science. Its remarkable speed and strong security
    features are highly sought after by developers who need to manage large datasets
    effectively. The Polars library takes full advantage of Rust’s capabilities, providing
    fast and efficient methods for manipulating complex data sets. With its outstanding
    performance, it proves to be an appealing choice for those working on complicated
    projects that require quick processing abilities.
  prefs: []
  type: TYPE_NORMAL
- en: This write-up acts as a continuum in this series where we demystify the world
    of Polars. [**In the first part of this series**](/rust-polars-unlocking-high-performance-data-analysis-part-1-ce42af370ece),
    we learned about Rust’s Polars series object, its use cases, and much more. In
    this part of the series, we will explore another Polars’s fundamental data structure,
    namely the **DataFrame** object. Through hands-on exercises and code snippets,
    you’ll acquire crucial skills such as executing diverse operations on DataFrames
    among other things.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** This article assumes that you have a fairly basic understanding of
    the Rust programming language.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The notebook named [**4-polars-tutorial-part-2.ipynb**](https://github.com/wiseaidev/rust-data-analysis/blob/main/4-polars-tutorial-part-2.ipynb)wasdeveloped
    for this article which can be found in the following repository:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[](https://github.com/wiseaidev/rust-data-analysis?source=post_page-----7c58a3cb7a1f--------------------------------)
    [## GitHub - wiseaidev/rust-data-analysis: The ultimate data analysis with Rust
    course.'
  prefs: []
  type: TYPE_NORMAL
- en: This repository is a collection of Jupyter notebooks, all powered by a Rust
    kernel. With these notebooks, you'll be…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: github.com](https://github.com/wiseaidev/rust-data-analysis?source=post_page-----7c58a3cb7a1f--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Table of Contents(TOC)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ∘ [DataFrame Object](#6752)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Indexing & Slicing](#5a00)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Data Cleaning](#bf0b)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Measures of central tendency](#406b)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Ndarray](#b0f8)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Aggregation Functions](#6902)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Merging DataFrames](#b011)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Conclusion](#4c07)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Closing Note](#7e8f)
  prefs: []
  type: TYPE_NORMAL
- en: ∘ [Resources](#7546)
  prefs: []
  type: TYPE_NORMAL
- en: DataFrame Object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/042a84b685ff0191afef47ee5ecb0fb1.png)'
  prefs: []
  type: TYPE_IMG
- en: Polars dataframe representation (Image by author)
  prefs: []
  type: TYPE_NORMAL
- en: At the heart of the Polars library lies an essential component that serves as
    its foundation; The [**DataFrame**](https://docs.rs/polars/latest/polars/prelude/struct.DataFrame.html#)
    structure. This ingenious **two-dimensional data** representation is organized
    in **rows and columns**, similar to a series object but with added dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: DataFrame Initialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Polars, initializing a data frame is as simple as using the powerful [**DataFrame**](https://docs.rs/polars/latest/polars/prelude/struct.DataFrame.html)
    Struct. To illustrate the incredible simplicity of DataFrame initialization, let’s
    consider the following snippet of code to create an empty data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, let us explore the flexibility of the Polars library in depth. Take a look
    at this code snippet where series are effortlessly converted into a **2-D DataFrame:**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The Polars DataFrame initialization process is straightforward, as evident
    from its effortless implementation. Moreover, the `[**df!**](https://docs.rs/polars/latest/polars/prelude/macro.df.html)`
    macro enables you to create data frames easily. Take the following as an example
    of utilizing this macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Describe
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `[**describe**](https://docs.rs/polars/latest/polars/frame/struct.DataFrame.html#method.describe)`
    method in Polars is a highly utilized technique that provides **an overview of
    statistical measures** for datasets. This method creates a comprehensive table
    consisting of the **count**, **mean**, **standard deviation**, **minimum** and
    **maximum** values, and the **25th** **percentile** to **75th** **percentile**
    **range** (**median**) for each column within the dataset. By employing this method,
    you can acquire valuable insights into your data’s characteristics, such as identifying
    potential outliers while comprehending its distribution pattern effectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Head
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like the series object, the `[**head**](https://docs.rs/polars/latest/polars/frame/struct.DataFrame.html#method.head)`
    method lets us quickly preview the first few rows of a DataFrame object. This
    method saves time and effort as it eliminates the need for scrolling through numerous
    records, which can be tedious and overwhelming. When called upon, this function
    returns a new DataFrame containing n number of rows from the original dataset
    based on user-defined parameters. **By default, ten (10) rows** are displayed
    when `**None**` is passed into this method. Let’s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: By default, the `**head**` method displays **the first ten rows** but can be
    customized to show any number using its argument. For instance, `**df.head(Some(3))**`
    would return only the first three rows of data. This feature enables us to verify
    column names and content while providing an overview of what’s inside before diving
    deeper into the analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Tail
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like series, the `[**tail**](https://docs.rs/polars/latest/polars/frame/struct.DataFrame.html#method.tail)`
    function in Polars is a powerful method that lets you preview **the last few rows**
    of any DataFrame object. For instance, if your DataFrame contains information
    about employees, such as their names, ages, and heights; using this method will
    allow you to verify column data and structure quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the `**tail**` method displays the last ten rows of your dataset,
    but it can be customized by specifying an argument for how many rows should be
    displayed instead. To illustrate further: `**df.tail(Some(3))**` would display
    only the last three rows from our example employees’ data frame.'
  prefs: []
  type: TYPE_NORMAL
- en: In essence, utilizing `**tail**` on DataFrames helps save time when verifying
    contents or getting insights into its overall layout. It provides valuable information
    at a glance without having to go through every single row manually!
  prefs: []
  type: TYPE_NORMAL
- en: Indexing & Slicing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike series, a DataFrame object can be indexed using square brackets `**[]**`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have constructed a data frame that consists of four columns-
    “Name”, “Age”, “Gender” and “Salary”. We then showcased various techniques to
    index the data frame by using brackets. To extract a single column based on its
    name, we utilized `**df[‘Name’]**`. This method returns a Polars Series consisting
    of all values belonging to the specified column — in our case, it was the ‘Name’
    column. Employing such methods is highly beneficial when one requires specific
    information from their respective data frames.
  prefs: []
  type: TYPE_NORMAL
- en: 'Subsequently, through slicing with **df[..2]**, we chose only certain subsets
    of columns, which resulted in creating **another** **new** **DataFrame** containing
    **the first two columns solely**: namely `**Name**` and `**Age**`. Such quick
    yet efficient ways are ideal for selecting multiple desired attributes from any
    given data frame effortlessly. Likewise, we can select a subset of columns using
    the select method and, for example, calling `[**df.select([“Name”, “Age”])**](https://docs.rs/polars/latest/polars/prelude/struct.DataFrame.html#method.select)`will
    return only the ‘**Name**’ and ‘**Gender**’ columns.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can also use the `[**column**](https://docs.rs/polars/latest/polars/frame/struct.DataFrame.html#method.column)`
    method to retrieve a specific column, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also select rows using **boolean indexing**, known as **masking**.
    Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, the `[**slice**](https://docs.rs/polars/latest/polars/frame/struct.DataFrame.html#method.slice)`
    method allows us to select specific subsets of rows and columns from a data frame
    object. For instance, if we use **df.slice(2,3)**, three rows will be returned
    starting at index two (using zero-based indexing). Furthermore, this selection
    would include all columns resulting in an entirely new data frame consisting of
    three rows, if exists, by four columns.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: An alternative is utilizing the `[**transpose**](https://docs.rs/polars/latest/polars/prelude/struct.DataFrame.html#method.transpose)`
    function, which flips the rows and columns of the matrix. This allows us to access
    a single row as a series through indexing on its transpose form.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that this is a very expensive operation as mentioned in the docs.
  prefs: []
  type: TYPE_NORMAL
- en: Data Cleaning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/406554a8f993a79109604500e3583878.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Towfiqu barbhuiya](https://unsplash.com/@towfiqu999999?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: The process of cleaning your data involves a critical step that entails detecting
    and resolving missing information. The presence of null values can significantly
    affect the precision when analyzing or making decisions based on this material.
    Fortunately, Rust’s Polars library provides numerous robust techniques for managing
    these gaps effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Nulls Count
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The process of counting the number of null or missing values in a given data
    frame is essential to create another data frame that displays the count of such
    occurrences per column. This data proves extremely useful as it enables fast identification
    of columns with missing information and quantifies how much data is missing. Based
    on this knowledge, we can make informed decisions about eliminating those rows
    containing incomplete entries or adopting imputation methods for filling up these
    values instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Duplicates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Utilizing this method can obtain a boolean mask that pinpoints all the replicated
    rows in your DataFrame. This particular mask serves as an effective tool to filter
    out these duplicates and get a new data frame with precision. To use the [**is_duplicated**](https://docs.rs/polars/latest/polars/frame/struct.DataFrame.html#method.is_duplicated)
    function, invoke it on your DataFrame and allocate the resulting mask to a new
    variable. Subsequently, apply this same filter to your original data frame to
    eliminate those replicas.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Unique Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `[**is_unique**](https://docs.rs/polars/latest/polars/frame/struct.DataFrame.html#method.is_unique)`
    method provides a way to determine if each row in your DataFrame contains unique
    values. This method enables you to obtain a mask of all the distinct rows present
    within your dataset, which can be especially advantageous when working with extensive
    data or conducting complex operations on it.
  prefs: []
  type: TYPE_NORMAL
- en: To apply this technique, just invoke the `**is_unique**` function on a **DataFrame**
    object. It will generate a boolean array that highlights those rows containing
    unique elements. You may then utilize this array as a filter mechanism for extracting
    only the unique rows from your original **DataFrame** efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Drop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Removing unnecessary information from a data frame or series is essential in
    data analysis. Luckily, Polars offers multiple ways to do so effectively. One
    such method involves using the `[**drop**](https://docs.rs/polars/latest/polars/frame/struct.DataFrame.html#method.drop)`
    function, which allows you to eliminate specific rows or columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this method, specify the name/label of your target column as an argument
    for the `**drop**` method. It’s worth noting that by default, this function returns
    a new **DataFrame** object with only specified rows removed — leaving the original
    **DataFrame** intact. This can be especially helpful for beginners who may expect
    their initial dataset to change permanently after running specific functions.
    For instance, let’s take an example of a **Fruit** and **Color**-based **DataFrame**
    object where the column “**Color**” is no longer needed in further analyses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `**drop**` function to remove the column with the label “**Color**”
    from this DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: A new DataFrame object, **df_remain**, now holds identical data to the original
    except for the “**Color**” column. Upon inspection of the initial data frame,
    we can confirm its information remains unaltered.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you wish to make changes directly to the original **DataFrame**, consider
    using the `[**drop_in_place**](https://docs.rs/polars/latest/polars/prelude/struct.DataFrame.html#method.drop_in_place)`
    function instead of `**drop**`. This method operates similarly to `**drop**`,
    but it alters the data frame without generating a new object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, you can also remove multiple columns by specifying their names
    as the arguments for the `[**drop_many**](https://docs.rs/polars/latest/polars/prelude/struct.DataFrame.html#method.drop_many)`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can use the `[**drop_nulls**](https://docs.rs/polars/latest/polars/prelude/struct.DataFrame.html#method.drop_nulls)`
    function to remove any rows that contain null or missing values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'By utilizing the `[**is_not_null**](https://docs.rs/polars/latest/polars/prelude/fn.is_not_null.html)`method,
    we can create a non-null mask for any column in our **DataFrame**. This method
    returns a boolean mask that distinguishes between values containing null and those
    without. Once applied to a specific column, this creates a filter where each value
    corresponds with its respective row’s status as either **null** or **not null**.
    By using this effective technique to extract only rows meeting certain criteria,
    we can remove all instances of missing data from our new DataFrame with ease.
    For example, to create a null mask for the “**Salary**” column of a **DataFrame**,
    we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The code snippet creates an empty mask for the “**Salary**” column in the **df**
    **DataFrame** object. It also displays some initial values of the Boolean mask
    produced as output. This filter can be applied to extract data only from rows
    where there are non-null entries within the “**Salary**” column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Utilizing a null mask grants greater precision in managing the filtering process.
    This method proves beneficial when we aim to filter based on various conditions
    or combinations of null values across distinct columns. Nevertheless, it entails
    writing more code than simply using the `**drop_nulls**` function and may not
    be as efficient for large datasets.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize this section, dropping rows is a common and handy operation for
    removing rows or columns from a data frame in Polars. There are several options
    for modifying the original data or dropping null values.
  prefs: []
  type: TYPE_NORMAL
- en: Fill
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Polars presents a valuable method for handling absent data — the `[**fill_null**](https://docs.rs/polars/latest/polars/prelude/struct.DataFrame.html#method.fill_null)`
    method. This function allows us to substitute null or missing values in a **DataFrame**
    or **Series** object with an assigned method or value. A frequent application
    of `**fill_null**` is replacing all bad entries within a **DataFrame** or **Series**
    with one single value. You can accomplish this by passing a scalar parameter into
    `**fill_null**`. For example, if you want to replace every missing entry in your
    DataFrame with previous values, simply use `**fill_null**` as demonstrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: It’s essential to note that statistical functions typically ignore any missing
    values present within **DataFrame** by default when analyzing data. However, it
    is crucial to understand why these gaps exist because they may affect your analysis
    results significantly. Moreover, determining whether or not imputing/filling-in
    those absent entries would be appropriate depends on various factors like reasons
    behind their occurrence- intentional vs accidental errors during collection, etc.,
    and accuracy required for further processing tasks at hand, among others.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, carefully considering all aspects surrounding missing data before
    deciding how best to approach handling them will ensure accurate analyses without
    compromising quality outcomes!
  prefs: []
  type: TYPE_NORMAL
- en: Measures of central tendency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mean
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like Series, we can compute the mean of each individual column in a given
    data frame.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Median
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can also compute the median of each individual column in a given data frame.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Measures of Spread
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Std
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: var
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Ndarray
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can convert a data frame to ndarray, as we saw in [**the first article**](https://wiseai.medium.com/rust-the-next-big-thing-in-data-science-319a03305883)of
    this series. This method creates a 2D `**ndarray::Array**` object from a **DataFrame**
    object. This requires all columns in the DataFrame to be non-null and numeric.
    They will be cast to the same data type (if they aren’t already). It will implicitly
    convert **None** to **NaN** without failure for floating point data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can apply different operations on this array discussed in a previous
    article titled: [The Ultimate Ndarray Handbook: Mastering the Art of Scientific
    Computing with Rust](/the-ultimate-ndarray-handbook-mastering-the-art-of-scientific-computing-with-rust-ef5ab767212a).'
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/2b919c5d4ef5da4f0a51f0cc20e9c348.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Nicolas COMTE](https://unsplash.com/@rotor_?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: When working with large amounts of data, it’s crucial to categorize and comprehend
    aggregated data on a group level. Fortunately, Polars provides an excellent solution
    through its `[**groupby**](https://docs.rs/polars/latest/polars/prelude/struct.DataFrame.html#method.groupby)`
    function. This method splits the data frame into chunks based on specific key
    values before applying computations and combining results back together in another
    data frame — known as a [**split-apply-combine**](https://www.jstatsoft.org/article/view/v040i01)
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'With aggregation functions in place, we can perform various operations such
    as **count**, **sum**, or **mean** within these groups quickly; this significantly
    speeds up computation time when dealing with massive datasets efficiently. Other
    common examples of aggregation functions include **variance**, and **std**. Here
    are a few examples of the use of `**.groupby**`:'
  prefs: []
  type: TYPE_NORMAL
- en: A retail company uses the `**groupby**` method to analyze sales data by region
    and product category. This analysis enables them to determine which products are
    selling well in which regions and make more informed decisions regarding inventory
    management and product promotions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Utilising the `**groupby**` method, a healthcare organization can analyze patient
    data based on age group and medical condition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: A transportation enterprise can utilize the `**groupby**` technique to analyze
    their vehicle’s fuel usage based on driver and vehicle category. This analysis
    empowers them to pinpoint inefficiencies in gas consumption, allowing for prompt
    corrective actions that enhance fuel efficiency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: By utilizing the `**groupby**` method, an insurance company can effectively
    analyse claims data based on policy type and customer demographics. This analysis
    enables them to pinpoint high-risk customers while crafting policies that cater
    to their individual requirements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In summary, the `**.groupby**` method is a powerful tool for data analysis that
    allows you to group your data in any way imaginable and apply any type of function
    independently to each group before returning a single dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/645783e9fe9a381fdaf1ab40cb839e39.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Alexander Schimmeck](https://unsplash.com/@alschim?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Let us delve into a[**flights dataset**](https://www.kaggle.com/datasets/deepak007chaubey/flight-on-time-dataset?select=Flight_on_time_HIX.csv)
    hosted on Kaggle and carry out a basic aggregation that involves just one grouping
    column, one aggregating column, and an individual aggregating function. Our aim
    is to determine the average arrival delay for each airline. Polars offers various
    syntaxes for creating such an aggregation, which we will explore in this section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: To effectively group data in a DataFrame, it is important to define the grouping
    columns such as `**Airline**`, and choose an aggregating function like the `**mean**`
    for `**Arrival_Delay_Minutes**` column. Once this is done, simply place the grouping
    column within `**groupby**` method and select your desired display column before
    applying an aggregation function to it. This will generate a new DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'With multiple columns, **grouping** and **aggregating** are achievable. However,
    the syntax varies from that of a single-column operation. To ensure smooth execution
    during any type of group function process, it’s important to identify three key
    components: aggregation functions, grouping columns, and aggregated columns. For
    instance; in this example, we are calculating **Airline-wise** average departure
    delay per **Origin Airport**.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If you are familiar with Python pandas, then the use of `**groupby**` will result
    in a [**MultiIndex**](https://pandas.pydata.org/docs/reference/api/pandas.MultiIndex.html#pandas.MultiIndex)object.
    The occurrence of **MultiIndexes** can be found both within the index and columns
    themselves. However, **Polars** eliminates this issue altogether by not requiring
    any such operations from developers, making it an advantageous alternative over
    Pandas for data handling purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Merging DataFrames
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/9bb2f0879cd6130877721f8c0c3ccc0e.png)'
  prefs: []
  type: TYPE_IMG
- en: Different Polars join methods (Image by author)
  prefs: []
  type: TYPE_NORMAL
- en: Polars offers an array of data manipulation tools for executing tasks like merging
    datasets. One such tool is the join method which facilitates joining different
    DataFrame objects. To execute this operation, you need to call upon the [**join**](https://docs.rs/polars/latest/polars/prelude/trait.DataFrameJoinOps.html#method.join)
    function on any one of the DataFrames and specify other parameters along with
    it. To better understand how this works in practice, consider the following code
    example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: When performing a merge operation, the `**how**` parameter plays an important
    role in determining what type of merging will take place. You have several options
    to choose from including inner, left, right and outer joins.
  prefs: []
  type: TYPE_NORMAL
- en: To determine the exact variables that will serve as join keys for each DataFrame,
    utilize the `**left_on**` and `**right_on**` parameters accordingly. These specific
    values facilitate linking corresponding rows from both DataFrames with ease.
  prefs: []
  type: TYPE_NORMAL
- en: If there is another data frame that needs to be merged with your first one then
    simply use the `**other**` parameter to indicate this second dataset. This new
    information can either be added on top of your existing data set or appended onto
    it depending on how you want things organized!
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, if two columns share identical names within separate datasets being
    merged together then using suffixes can differentiate them easily by appending
    unique strings at the end of their respective column titles. Here is an exmaple
    on how to use the `**join**` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: When merging DataFrames in Polars, it’s important to understand the different
    types of joins available. **Inner joins** only keep rows that are **common** between
    both DataFrames while **left** and **right** joins retain **all** rows from one
    DataFrame and add relevant data from the other based on matching values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: If there is no corresponding data for a row in either DataFrame, null or missing
    values will be filled accordingly. Right join works similarly but retains all
    rows from the right DataFrame instead.
  prefs: []
  type: TYPE_NORMAL
- en: Merging DataFrames can greatly enhance your ability to analyze data effectively
    with Polars’ convenient **join** method.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/baa60e628868134899f091005f89931b.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Adeolu Eletu](https://unsplash.com/@adeolueletu?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: This article has familiarized you with a fundamental data structure in Polars
    —**DataFrame**. Additionally, we have explored basic concepts of querying, modifying,
    and joining data frames in Polars. As a result, this should give you confidence
    when working with DataFrames going forward. It will be an integral component throughout
    the rest of this series of articles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout this article, we have covered the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Polars’s DataFrame object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring different aggregation functions available in Polars.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to merge DataFrames in Polars and how it is different from Pandas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And much more. As we progress through the upcoming articles, your knowledge
    of Polars will expand to encompass more advanced features and techniques. By mastering
    this library, you’ll gain rock-solid and valuable skills that empower you to easily
    tackle complex data analysis tasks while handling massive datasets effortlessly.
  prefs: []
  type: TYPE_NORMAL
- en: Closing Note
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/c732ae653e11e63222cc5fd9bc49b0e4.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Aaron Burden](https://unsplash.com/@aaronburden?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: As we conclude this tutorial, I would like to express my sincere appreciation
    to all those who have dedicated their time and energy to completing it. It has
    been an absolute pleasure to demonstrate the extraordinary capabilities of Rust
    programming language with you.
  prefs: []
  type: TYPE_NORMAL
- en: As always, being passionate about data science, I promise you that I will keep
    writing at least one comprehensive article every week or so on related topics
    from now on. If staying updated with my work interests you, consider connecting
    with me on various social media platforms or reach out directly if anything else
    needs assistance.
  prefs: []
  type: TYPE_NORMAL
- en: Thank You!
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://github.com/wiseaidev/rust-data-analysis?source=post_page-----7c58a3cb7a1f--------------------------------)
    [## GitHub - wiseaidev/rust-data-analysis: The ultimate data analysis with Rust
    course.'
  prefs: []
  type: TYPE_NORMAL
- en: This repository is a collection of Jupyter notebooks, all powered by a Rust
    kernel. With these notebooks, you'll be…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: github.com](https://github.com/wiseaidev/rust-data-analysis?source=post_page-----7c58a3cb7a1f--------------------------------)  [##
    DataFrame in polars::prelude - Rust
  prefs: []
  type: TYPE_NORMAL
- en: A contiguous growable collection of `Series` that have the same length.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: docs.rs](https://docs.rs/polars/latest/polars/prelude/struct.DataFrame.html?source=post_page-----7c58a3cb7a1f--------------------------------)  [##
    Rust By Example
  prefs: []
  type: TYPE_NORMAL
- en: Rust is a modern systems programming language focusing on safety, speed, and
    concurrency. It accomplishes these goals…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: doc.rust-lang.org](https://doc.rust-lang.org/rust-by-example/?source=post_page-----7c58a3cb7a1f--------------------------------)  [##
    The Rust Programming Language
  prefs: []
  type: TYPE_NORMAL
- en: by Steve Klabnik and Carol Nichols, with contributions from the Rust Community
    This version of the text assumes you're…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: doc.rust-lang.org](https://doc.rust-lang.org/book/?source=post_page-----7c58a3cb7a1f--------------------------------)
  prefs: []
  type: TYPE_NORMAL
