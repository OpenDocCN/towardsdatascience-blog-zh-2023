- en: Can LLMs Replace Data Analysts? Getting Answers Using SQL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/can-llms-replace-data-analysts-getting-answers-using-sql-8cf7da132259?source=collection_archive---------0-----------------------#2023-12-22](https://towardsdatascience.com/can-llms-replace-data-analysts-getting-answers-using-sql-8cf7da132259?source=collection_archive---------0-----------------------#2023-12-22)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Part 2: Diving deeper into LLM agents'
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://miptgirl.medium.com/?source=post_page-----8cf7da132259--------------------------------)[![Mariya
    Mansurova](../Images/b1dd377b0a1887db900cc5108bca8ea8.png)](https://miptgirl.medium.com/?source=post_page-----8cf7da132259--------------------------------)[](https://towardsdatascience.com/?source=post_page-----8cf7da132259--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----8cf7da132259--------------------------------)
    [Mariya Mansurova](https://miptgirl.medium.com/?source=post_page-----8cf7da132259--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: ·
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F15a29a4fc6ad&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fcan-llms-replace-data-analysts-getting-answers-using-sql-8cf7da132259&user=Mariya+Mansurova&userId=15a29a4fc6ad&source=post_page-15a29a4fc6ad----8cf7da132259---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----8cf7da132259--------------------------------)
    ·31 min read·Dec 22, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F8cf7da132259&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fcan-llms-replace-data-analysts-getting-answers-using-sql-8cf7da132259&user=Mariya+Mansurova&userId=15a29a4fc6ad&source=-----8cf7da132259---------------------clap_footer-----------)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F8cf7da132259&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fcan-llms-replace-data-analysts-getting-answers-using-sql-8cf7da132259&source=-----8cf7da132259---------------------bookmark_footer-----------)![](../Images/a9a7ac47dced35c371073a2c4bd70565.png)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Image by DALL-E 3
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: In [the previous article](https://medium.com/towards-data-science/can-llms-replace-data-analysts-building-an-llm-powered-analyst-851578fa10ce),
    we’ve started building an LLM-powered analyst. We decided to focus on descriptive
    analytics and reporting tasks since they are the most common for analysts. Most
    analysts start their careers with such tasks, and most companies start building
    the analytical function with reporting and BI tools.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Our first prototype can use ready-made tools to answer questions related to
    the defined metrics, like in the example below.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/37dd8da1463d0133009b5fea8137b792.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
- en: Illustration by author
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 作者插图
- en: The next step would be to teach our LLM-powered analyst to get any metrics.
    Analysts usually use SQL to get data. So, the most helpful skill for the LLM analyst
    would be interacting with SQL databases.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是教我们的 LLM 驱动分析师获取任何指标。分析师通常使用 SQL 来获取数据。因此，对 LLM 分析师来说，最有用的技能是与 SQL 数据库互动。
- en: We’ve already discussed OpenAI functions and learned how LLMs can use tools
    to integrate with the world. In this article, I would like to focus on LLM agents
    and discuss them in more detail. We will learn how to build agents using LangChain
    and try different agent types.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了 OpenAI 功能，并了解了 LLM 如何使用工具与世界进行集成。在这篇文章中，我想专注于 LLM 代理，并详细讨论它们。我们将学习如何使用
    LangChain 构建代理，并尝试不同类型的代理。
- en: Setting up a database
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置数据库
- en: First, let’s set up a database we will be interacting with. My choice is ClickHouse.
    ClickHouse is an open-source column-oriented SQL database management system for
    online analytical processing (OLAP). It’s a good option for big data and analytical
    tasks.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们设置一个我们将要交互的数据库。我选择的是 ClickHouse。ClickHouse 是一个开源的列式 SQL 数据库管理系统，适用于在线分析处理（OLAP）。它是大数据和分析任务的良好选择。
- en: If you want to learn more about ClickHouse, please check [my article](https://towardsdev.com/clickhouse-tips-tricks-i-wish-i-knew-f575f0371cd3).
    However, you can use any database. You will need just to tweak the code for functions
    that get data.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于 ClickHouse 的内容，请查看[我的文章](https://towardsdev.com/clickhouse-tips-tricks-i-wish-i-knew-f575f0371cd3)。不过，你可以使用任何数据库。你只需调整获取数据的函数代码即可。
- en: Installing ClickHouse is just one line of code. The initial command executes
    the script provided by the ClickHouse team to download the proper binary for your
    platform. Then, you need to launch a server, and that’s it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 ClickHouse 只需一行代码。初始命令会执行 ClickHouse 团队提供的脚本，以下载适合你平台的二进制文件。然后，你需要启动一个服务器，就完成了。
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can access ClickHouse via HTTP API. By default, it listens on the 8123 port.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 HTTP API 访问 ClickHouse。默认情况下，它监听 8123 端口。
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: I usually check that `r.status_code = 200` to ensure the request has been successfully
    completed and raise the error otherwise. However, we will pass the results of
    this function to LLM. So, getting any output DB returns is okay, regardless of
    whether it is an error or not. LLM will be able to handle it properly.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常检查 `r.status_code = 200` 以确保请求已成功完成，否则会引发错误。然而，我们将把此函数的结果传递给 LLM。因此，无论输出
    DB 返回什么，都没关系，无论是否为错误，LLM 都能够妥善处理。
- en: I’ve generated synthetic data for this example. If you would like to learn more
    about data simulation, you can find the code [here](https://github.com/miptgirl/miptgirl_medium/blob/main/analyst_agent/generate_synthetic_data_for_sql.ipynb).
    I used retention curves to model sessions for customers, considering the number
    of days since account creation and weekly seasonality. It could be a bit of an
    overcomplicated approach right now since we don’t use data much. But I hope in
    future prototypes, we will be able to get some insights from this data using LLMs.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我为这个例子生成了合成数据。如果你想了解更多关于数据模拟的内容，可以在[这里](https://github.com/miptgirl/miptgirl_medium/blob/main/analyst_agent/generate_synthetic_data_for_sql.ipynb)找到代码。我使用了保留曲线来为客户建模会话，考虑了账户创建以来的天数和每周的季节性。这可能现在有些复杂，因为我们还不太使用数据。但我希望在未来的原型中，我们能利用
    LLM 从这些数据中获得一些见解。
- en: We need just a couple of tables representing a data model for a basic e-commerce
    product. We will work with the list of users (`ecommerce.users`) and their sessions
    (`ecommerce.sessions`).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要几个表来表示基本的电子商务产品数据模型。我们将处理用户列表（`ecommerce.users`）及其会话（`ecommerce.sessions`）。
- en: Let’s look at the `ecommerce.sessions` table.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下 `ecommerce.sessions` 表。
- en: '![](../Images/8430e5082dd3450b91d9779b4faf0aa1.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8430e5082dd3450b91d9779b4faf0aa1.png)'
- en: Screenshot by author
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 作者截图
- en: And here, you can see what features we have for users.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们为用户提供了哪些功能。
- en: '![](../Images/faf4589845750ce8ac3151e06172aced.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/faf4589845750ce8ac3151e06172aced.png)'
- en: Screenshot by author
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 作者截图
- en: Now, we have data to work with and are ready to move on and discuss LLM agents
    in more detail.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了可以使用的数据，准备继续深入讨论 LLM 代理的细节。
- en: Agents overview
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理概述
- en: The core idea of the LLM agents is to use LLM as a reasoning engine to define
    the set of actions to take. In the classic approach, we hardcode a sequence of
    actions, but with agents, we give the model tools and tasks and let her decide
    how to achieve them.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: LLM 代理的核心思想是将 LLM 作为推理引擎来定义要执行的操作集合。在经典方法中，我们硬编码了一系列操作，但使用代理时，我们给模型提供工具和任务，让它决定如何实现这些任务。
- en: 'One of the most foundational papers regarding LLM agents is [“ReAct: Synergizing
    Reasoning and Acting in Language Models”](https://arxiv.org/abs/2210.03629) by
    Shunyu Yao et al. The ReAct (**Re**asoning + **Act**ing) approach suggests combining:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '关于LLM代理的最基础论文之一是[“ReAct: Synergizing Reasoning and Acting in Language Models”](https://arxiv.org/abs/2210.03629)，作者是Shunyu
    Yao等。ReAct（**Re**asoning + **Act**ing）方法建议结合：'
- en: reasoning that helps to create the plan and update it in case of exceptions,
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助制定计划并在出现例外情况时更新计划的推理，
- en: actions that allow the model to leverage external tools or gather data from
    external sources.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许模型利用外部工具或从外部来源获取数据的操作。
- en: Such an approach shows much better performance on different tasks. One of the
    examples from the paper is below.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在不同任务上的表现更好。下面是来自论文的一个示例。
- en: '![](../Images/35ba2a3b5a9028a1189160df6725e4e1.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/35ba2a3b5a9028a1189160df6725e4e1.png)'
- en: Example from [the paper by Yao et al.](https://arxiv.org/abs/2210.03629)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 来自[Yao等人的论文](https://arxiv.org/abs/2210.03629)的示例
- en: 'Actually, that’s how human intelligence works: we combine inner voice reasoning
    with task-oriented actions. Suppose you need to cook a dinner. You will use reasoning
    to define a plan (“guests will be in 30 minutes, I have time only to cook pasta”),
    adjust it (“Ben has become a vegan, I should order something for him”) or decide
    to delegate which is an equivalent of external tools (“there’s no pasta left,
    I need to ask my partner to buy it”). At the same time, you will use actioning
    to use some tools (ask a partner for help or use a mixer) or get some information
    (to look up in the internet how many minutes you need to cook pasta to make it
    al dente). So, it’s reasonable to use a similar approach with LLMs since it works
    for humans (who are no doubt AGI).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这就是人类智能的工作方式：我们将内在的推理与任务导向的行动结合起来。假设你需要做晚餐。你将使用推理来制定计划（“客人将在30分钟内到达，我只有时间做意大利面”），调整计划（“本变成了素食者，我应该为他订购一些食物”）或决定委派任务（相当于外部工具，“意大利面没了，我需要问我的伴侣去买”）。同时，你会使用行动来使用一些工具（询问伴侣帮助或使用搅拌机）或获取一些信息（查找互联网了解煮意大利面所需的时间，以使其达到“
    al dente”）。所以，使用类似的方法对LLM是合理的，因为它对人类有效（人类无疑是AGI）。
- en: Now, there are quite a lot of different approaches for LLM agents since ReAct.
    They differ in prompts used to set the model’s reasoning, how we define tools,
    output format, handling memory about the intermediate steps, etc.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，自ReAct以来，LLM代理有许多不同的方法。它们在用于设置模型推理的提示、如何定义工具、输出格式、处理中间步骤的记忆等方面有所不同。
- en: 'Some of the most popular approaches are:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一些最受欢迎的方法包括：
- en: OpenAI functions,
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenAI函数，
- en: AutoGPT,
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AutoGPT，
- en: BabyAGI,
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BabyAGI，
- en: Plan-and-execute agent.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计划并执行的代理。
- en: We will use these approaches later on for our task and see how they work and
    what the differences are.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会使用这些方法来完成我们的任务，并查看它们的工作原理及其差异。
- en: Building Agent from Scratch
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从零开始构建代理
- en: Let’s start to build an agent. We will do it from scratch to understand how
    everything works under the hood. Then, we will use LangChain’s tools for faster
    prototyping if you don’t need any customisation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建一个代理。我们将从零开始，以了解其内部工作原理。然后，如果你不需要任何自定义，我们将使用LangChain的工具来加快原型制作。
- en: 'The core components of LLM agents are:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: LLM代理的核心组件包括：
- en: Prompt to guide the model’s reasoning.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引导模型推理的提示。
- en: Tools that the model can use.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型可以使用的工具。
- en: Memory — a mechanism to pass previous iterations to the model.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记忆 — 一个将先前迭代传递给模型的机制。
- en: For the first version of the LLM agent, we will use OpenAI functions as a framework
    to build an agent.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于LLM代理的第一个版本，我们将使用OpenAI函数作为构建代理的框架。
- en: Defining tools
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义工具
- en: 'Let’s start with defining the tools for our robot. Let’s think about what information
    our LLM-powered analyst might need to be able to answer questions:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始定义我们机器人的工具。让我们考虑一下我们的LLM驱动分析师可能需要哪些信息来回答问题：
- en: List of tables — we can put it in the system prompt so that the model has some
    view on what data we have and doesn’t need to execute a tool for it every time,
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表格中的列表 — 我们可以将其放入系统提示中，以便模型了解我们拥有的数据，并且每次都不需要执行工具。
- en: List of columns for the table so that the model can understand the data schema,
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表格的列列表，以便模型可以理解数据模式，
- en: Top values for the column in the table so that the model can look up values
    for filters,
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表格中列的前几个值，以便模型可以查找过滤器的值，
- en: Results of SQL query execution to be able to get actual data.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL查询执行的结果，以便获取实际数据。
- en: To define tools in LangChain, we need to use `@tool` decorator for the function.
    We will use Pydantic to specify the arguments schema for each function so that
    the model knows what to pass to the function.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 LangChain 中定义工具，我们需要对函数使用 `@tool` 装饰器。我们将使用 Pydantic 来指定每个函数的参数模式，以便模型知道传递给函数的内容。
- en: We’ve discussed tools and OpenAI functions in detail in [the previous article](https://medium.com/towards-data-science/can-llms-replace-data-analysts-building-an-llm-powered-analyst-851578fa10ce).
    So don’t hesitate to read it if you need to revise this topic.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [上一篇文章](https://medium.com/towards-data-science/can-llms-replace-data-analysts-building-an-llm-powered-analyst-851578fa10ce)
    中详细讨论了工具和 OpenAI 功能。所以如果你需要复习这个主题，请不要犹豫去阅读它。
- en: 'The code below defines three tools: `execute_sql`, `get_table_columns` and
    `get_table_column_distr`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码定义了三个工具：`execute_sql`、`get_table_columns` 和 `get_table_column_distr`。
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It’s worth noting that the code above uses Pydantic v1\. In June 2023, Pydantic
    released v2, which is incompatible with v1\. So, check your version if you see
    validation errors. You can find more details on the Pydantic compatibility in
    [the documentation](https://python.langchain.com/docs/guides/pydantic_compatibility).
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 值得注意的是，上面的代码使用了 Pydantic v1。在 2023 年 6 月，Pydantic 发布了 v2，这与 v1 不兼容。所以如果你看到验证错误，请检查你的版本。你可以在
    [文档](https://python.langchain.com/docs/guides/pydantic_compatibility) 中找到有关 Pydantic
    兼容性的更多详细信息。
- en: We will be working with OpenAI functions and need to convert our tools. Also,
    I saved our toolkit in a dictionary. It will be handy when executing tools to
    get observations.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 OpenAI 的功能，需要转换我们的工具。此外，我已经将工具包保存在一个字典中。在执行工具以获取观察结果时，这将非常方便。
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Defining a chain
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一个链
- en: We’ve created tools for the model. Now, we need to define the agent chain. We
    will use the latest GPT 4 Turbo, which was also fine-tuned to be used with the
    functions. Let’s initialise a chat model.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为模型创建了工具。现在，我们需要定义代理链。我们将使用最新的 GPT 4 Turbo，它也经过了微调以便与这些功能一起使用。让我们初始化一个聊天模型。
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The next step is to define a prompt consisting of a system message and a user
    question. We also need a `MessagesPlaceholder` to set up a place for the list
    of observations the model will be working with.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是定义一个由系统消息和用户问题组成的提示。我们还需要一个 `MessagesPlaceholder` 来设置模型将要处理的观察列表的位置。
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we discussed, I’ve added the list of tables in the database to the prompt
    so that the model has at least some knowledge about our data.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们讨论过的，我已经将数据库中的表列表添加到提示中，以便模型对我们的数据有至少一些了解。
- en: We have all the building blocks and are ready to set up the agent chain. The
    input parameters are a user message and intermediate steps (previous messages,
    function calls and observations). We pass the input parameters to the prompt using
    `format_to_openai_function_messages` to convert them into the expected format.
    Then, we pass everything to the LLM and, in the end, use the output parser `OpenAIFunctionsAgentOutputParser`
    for convenience.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们拥有所有构建块，并准备好设置代理链。输入参数包括用户消息和中间步骤（之前的消息、函数调用和观察）。我们使用 `format_to_openai_function_messages`
    将输入参数传递到提示中，以转换成期望的格式。然后，我们将所有内容传递给 LLM，最后使用输出解析器 `OpenAIFunctionsAgentOutputParser`
    以方便操作。
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We’ve defined our primary agent chain. Let’s try to invoke it. I’ve passed an
    empty list since we have no intermediate steps in the beginning.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了我们的主要代理链。让我们尝试调用它。我传递了一个空列表，因为开始时没有中间步骤。
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We got an `AgentActionMessageLog` object, which means the model wants to call
    `execute_sql` function. When the model is ready to return the final answer to
    the user, it returns the `AgentFinish` object.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了一个 `AgentActionMessageLog` 对象，这意味着模型想要调用 `execute_sql` 函数。当模型准备好将最终答案返回给用户时，它会返回
    `AgentFinish` 对象。
- en: If we look at the `tool_input`, we can see that the model wants to execute the
    following query.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 `tool_input`，可以看到模型想要执行以下查询。
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The query looks pretty good but uses the wrong column name: `active` instead
    of `is_active`. It will be interesting to see whether LLM will be able to recover
    from this error and return the result.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 查询看起来很好，但使用了错误的列名：`active` 而不是 `is_active`。有趣的是，LLM 是否能够从这个错误中恢复并返回结果。
- en: We can do execution step by step manually, however it will be more convenient
    to automate it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以一步一步地手动执行这些步骤，但自动化会更方便。
- en: If the `AgentActionMessageLog` object is returned, we need to call a tool, add
    the observation to the `agent_scratchpad`, and invoke the chain one more time.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果返回 `AgentActionMessageLog` 对象，我们需要调用一个工具，将观察结果添加到 `agent_scratchpad` 中，并再次调用链。
- en: If we got the`AgentFinish` object, we can terminate execution since we have
    the final answer.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们得到了 `AgentFinish` 对象，我们可以终止执行，因为我们已经得到了最终答案。
- en: I will also add a break after ten iterations to avoid potential endless loops.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我还会在十次迭代后添加一个断点，以避免潜在的无限循环。
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: I added some logging of the tools’ usage to the output to see how the execution
    is going. Also, you can always use LangChain debug mode to see all the calls.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我在输出中添加了一些工具使用的日志，以查看执行情况。此外，你可以随时使用 LangChain 调试模式查看所有调用。
- en: As a result of the execution, we got the following output.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 执行结果如下。
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note: there’s no guarantee that the agent won’t execute DML operations on your
    database. So, if you’re using it in a production environment, ensure that LLM
    either doesn’t have permission to change data or your tool implementation doesn’t
    allow it.'
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意：不能保证代理不会对你的数据库执行 DML 操作。因此，如果在生产环境中使用，请确保 LLM 要么没有更改数据的权限，要么你的工具实现不允许这样做。
- en: So, the model tried to execute SQL but got an error that there was no column
    `active`. Then, it decided to see the table schema, corrected the query accordingly,
    and got the result.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，模型尝试执行 SQL，但收到错误提示，没有 `active` 列。然后，它决定查看表的 schema，随后相应地修正了查询，并获得了结果。
- en: It’s a pretty decent performance. I behave the same way myself. I usually try
    recalling or guessing column names first and check the documentation only if the
    first attempt fails.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相当不错的性能。我自己也是如此。我通常会先尝试回忆或猜测列名，只有在第一次尝试失败时才会查看文档。
- en: However, in most cases, we don’t need to write the execution ourselves. We can
    use the LangChain `AgentExecutor` class for it. Check documentation to learn about
    all possible [parameters](https://api.python.langchain.com/en/latest/agents/langchain.agents.agent.AgentExecutor.html)
    for the class.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 但在大多数情况下，我们不需要自己编写执行代码。我们可以使用 LangChain 的 `AgentExecutor` 类。查看文档以了解该类的所有可能的
    [参数](https://api.python.langchain.com/en/latest/agents/langchain.agents.agent.AgentExecutor.html)。
- en: You need to write your own executor only if you want to customise something.
    For example, add some conditions to terminate the execution or logic to use tools.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你只有在想要自定义某些内容时，才需要编写自己的执行器。例如，添加一些条件以终止执行或逻辑来使用工具。
- en: You can find the same code using the `AgentExecutor` below.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在下面找到使用 `AgentExecutor` 的相同代码。
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As a result, we got an easy-to-trace output with the same result. You can note
    that LangChain’s formatting for the agent’s output is very convenient.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是我们得到了一个易于追踪的输出，且结果相同。你可以注意到 LangChain 对代理输出的格式化非常方便。
- en: '![](../Images/9af57b26a48a6cae3401a95f913919fd.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9af57b26a48a6cae3401a95f913919fd.png)'
- en: Image by author
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由作者提供
- en: We’ve built the LLM agent from scratch. So now, we understand how it works and
    know how to customise it. However, LangChain provides a high-level function `initialize_agent`
    that could do it within just one call. You can find all the details in the [documentation](https://api.python.langchain.com/en/latest/agents/langchain.agents.initialize.initialize_agent.html?highlight=initialize_agent#langchain.agents.initialize.initialize_agent).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从头开始构建了 LLM 代理。现在，我们了解它是如何工作的，并知道如何自定义它。然而，LangChain 提供了一个高级函数 `initialize_agent`，可以仅通过一次调用完成。你可以在
    [文档](https://api.python.langchain.com/en/latest/agents/langchain.agents.initialize.initialize_agent.html?highlight=initialize_agent#langchain.agents.initialize.initialize_agent)
    中找到所有详细信息。
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that we passed the ChatOpenAI model without functions bound to it. We’ve
    passed tools separately, so we don’t need to link them to the model.
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请注意，我们传递了 ChatOpenAI 模型，但未绑定任何函数。我们单独传递了工具，因此不需要将它们链接到模型。
- en: Different Agent Types
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的代理类型
- en: We’ve built an LLM agent based on OpenAI functions from scratch. However, there
    are quite a lot of other approaches. So let’s try them out as well.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从头开始构建了一个基于 OpenAI 函数的 LLM 代理。然而，还有很多其他方法。因此，我们也来尝试一下这些方法。
- en: 'We will look at the ReAct approach (the initial one from the paper we discussed
    earlier) and several experimental approaches provided by LangChain: Plan-and-execute,
    BabyAGI and AutoGPT.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看 ReAct 方法（来自我们之前讨论的论文中的初始版本）以及 LangChain 提供的几种实验方法：Plan-and-execute、BabyAGI
    和 AutoGPT。
- en: ReAct agent
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ReAct 代理
- en: Let’s start with looking at ReAct agents. With the current implementation, we
    can easily change the agent type and try the ReAct approach described in the paper.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看 ReAct 代理开始。通过当前的实现，我们可以轻松地更改代理类型，并尝试论文中描述的 ReAct 方法。
- en: The most general ReAct implementation is [Zero-shot ReAct](https://python.langchain.com/docs/modules/agents/agent_types/react).
    It won’t work for us because it supports only tools with a single string in input.
    Our tools require multiple arguments, so we need to use [Structured Input ReAct](https://python.langchain.com/docs/modules/agents/agent_types/structured_chat).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'We can leverage the advantage of using a modular framework: we need to change
    just one parameter `agent = AgentType.STRUCTURED_CHAT_ZERO_SHOT_REACT_DESCRIPTION`,
    and that’s it.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You might wonder how to find the arguments you can specify for the agent. Unfortunately,
    it’s not documented, so we need to dive into the source code to understand it.
    Let’s discuss it step-by-step.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: We can see that `analyst_agent_react` is an object of the `AgentExecutor` class.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This class has an agent field. In our case, it’s an object of the `StructuredChatAgent`
    class. The class depends on the specified agent type.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s find a `StructuredChatAgent` class implementation and see how it works.
    In this case, LangChain [creates](https://github.com/langchain-ai/langchain/blob/133971053a0b84a034fb0bc78cd1150cdb7f5dbf/libs/langchain/langchain/agents/structured_chat/base.py#L91)
    a prompt consisting of prefix, tools’ description, formatted instructions and
    suffix.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the complete list of parameters you can pass as `agent_kwargs`
    in [the code](https://github.com/langchain-ai/langchain/blob/133971053a0b84a034fb0bc78cd1150cdb7f5dbf/libs/langchain/langchain/agents/structured_chat/base.py#L103).
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, we can override the default `PREFIX` value from [here](https://github.com/langchain-ai/langchain/blob/133971053a0b84a034fb0bc78cd1150cdb7f5dbf/libs/langchain/langchain/agents/structured_chat/prompt.py#L2)
    and pass it as a `prefix` in `agent_kwargs`. Also, if you’re interested, you can
    read through the default ReAct prompt here and think about how to tweak it for
    your task.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are interested, you can see the final prompt using the following call.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let’s invoke our method and see the result.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can notice that the model follows a slightly different framework for reasoning.
    The model starts iteration with writing down the thought (reasoning), then moves
    to action (function call) and observation (the result of function call). Then,
    iteration repeats. In the end, the model returns `action = Final Answer`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '{'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '"action": "get_table_columns",'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '"action_input": {'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '"database": "ecommerce",'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"table": "users"'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '{'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '"action": "execute_sql",'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '"action_input": {'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '"query": "SELECT COUNT(*) AS active_customers_uk FROM ecommerce.users WHERE
    country = ''United Kingdom'' AND is_active = 1"'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '{'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '"action": "Final Answer",'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '"action_input": "There are 111,469 active customers from the United Kingdom."'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Even though the model followed a different path (starting with understanding
    the table schema and then executing SQL), it came to the same result.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s move on to experimental approaches. In LangChain, there are experimental
    agent types. They are not advised for production usage yet. However, it will be
    interesting to try using them and see how they work.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续实验方法。在 LangChain 中，有实验性的代理类型。它们尚不建议用于生产。然而，尝试使用它们并查看它们的工作效果会很有趣。
- en: Plan-and-execute agent
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计划与执行代理
- en: '*The code below is based on the* [*example*](https://github.com/langchain-ai/langchain/blob/master/cookbook/plan_and_execute_agent.ipynb)
    *from LangChain’s cookbook.*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*下面的代码基于来自 LangChain 厨房书的* [*示例*](https://github.com/langchain-ai/langchain/blob/master/cookbook/plan_and_execute_agent.ipynb)
    *。*'
- en: This agent follows a “Plan-and-execute” approach in contrast to the “Action”
    agents we looked at previously. This approach was inspired by the BabyAGI framework
    and [the paper “Plan-and-Solve Prompting”](https://arxiv.org/abs/2305.04091).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 该代理遵循“计划与执行”方法，与我们之前查看的“行动”代理不同。这一方法受 BabyAGI 框架和 [论文《计划与解决提示》](https://arxiv.org/abs/2305.04091)
    的启发。
- en: The characteristic of such an approach is that the agent first tries to plan
    the next steps and then executes them.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的特点是代理首先尝试规划下一步，然后执行它们。
- en: 'There are two components in this approach:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有两个组成部分：
- en: Planner — a regular Large Language Model with the primary goal — just to reason
    and plan,
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规划器 — 一个常规的大型语言模型，其主要目标是进行推理和规划，
- en: Executor — Action agent, an LLM empowered with the set of tools it can use to
    action.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行者 — 行动代理，是一个拥有可以用来执行的工具集合的 LLM。
- en: 'The advantage of this approach is that you have a separation: one model focuses
    on planning (reasoning), while the other focuses on execution (action). It’s more
    modular, and potentially, you could use smaller and cheaper models fine-tuned
    for your specific tasks. However, this approach also generates more LLM calls,
    so it’s more expensive if we are using ChatGPT.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优势在于你有一个分离：一个模型专注于规划（推理），另一个模型专注于执行（行动）。它更具模块化，可能你可以使用针对特定任务微调的小型且便宜的模型。然而，这种方法也会产生更多的
    LLM 调用，因此如果我们使用 ChatGPT，会更昂贵。
- en: Let’s initialise the planner and the executor.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们初始化规划器和执行者。
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There’s currently no way to specify a custom prompt for the executor since you
    can’t pass it to [the function](https://github.com/langchain-ai/langchain/blob/master/libs/experimental/langchain_experimental/plan_and_execute/executors/agent_executor.py).
    However, we can hack the prompt and add our initial system message that gives
    some context about the task to the beginning of the default prompt.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 目前没有办法为执行者指定自定义提示，因为你不能将其传递给 [该函数](https://github.com/langchain-ai/langchain/blob/master/libs/experimental/langchain_experimental/plan_and_execute/executors/agent_executor.py)。然而，我们可以破解提示，将我们的初始系统消息添加到默认提示的开头，以提供一些关于任务的背景。
- en: 'Disclaimer: overriding objects’ fields is a bad practice because we might bypass
    some prompt validations. We are doing it now only to experiment with this approach.
    Such a solution is not suitable for production.'
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 免责声明：覆盖对象字段是一种不好的做法，因为我们可能会绕过一些提示验证。我们现在这样做只是为了实验这种方法。这样的解决方案不适用于生产。
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, it’s time to define an agent and execute the same query we were asking
    before.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候定义一个代理并执行我们之前询问的相同查询了。
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The call returned an error: `RateLimitError: Error code: 429 — {''error'':
    {''message'': ''Request too large for gpt-4–1106-preview in organization on tokens_usage_based
    per min: Limit 150000, Requested 235832.'', ''type'': ''tokens_usage_based'',
    ''param'': None, ''code'': ''rate_limit_exceeded''}}` . It looks like the model
    tried to send too many tokens to OpenAI.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '调用返回了一个错误：`RateLimitError: Error code: 429 — {''error'': {''message'': ''请求超出
    gpt-4–1106-preview 组织内基于令牌使用的每分钟限制：限制 150000，要求 235832。'', ''type'': ''tokens_usage_based'',
    ''param'': None, ''code'': ''rate_limit_exceeded''}}`。看起来模型尝试向 OpenAI 发送了过多的令牌。'
- en: 'Let’s try to understand what has happened by looking at the model’s output
    (you can find it below):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看模型的输出（可以在下面找到）来尝试理解发生了什么：
- en: First, the model decided to look at `ecommerce.users` and `ecommerce.sessions`
    columns to determine the criteria for “active” customers.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，模型决定查看 `ecommerce.users` 和 `ecommerce.sessions` 列，以确定“活跃”客户的标准。
- en: It realised that it needed to use `is_active` in `ecommerce.users` table. However,
    the model decided it should also use sessions’ data to define the customer’s activity.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它意识到需要在 `ecommerce.users` 表中使用 `is_active`。然而，模型决定还应该使用会话数据来定义客户的活动。
- en: Then, the model went down this rabbit hole trying to define criteria for recent
    activity in `ecommerce.sessions`. It looked at the distributions for `action_date`,
    `session_duration` and `revenue`.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, it defined active customers as those who have had a session within
    the last 30 days, with a session duration and revenue above certain thresholds,
    neglecting that it could just use `is_active`. The model planned to look at the
    data to define these thresholds.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final error was caused by an attempt to load all user_ids for customers
    since there are too many tokens for ChatGPT.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even though there is quite a lot of text, I encourage you to read it to see
    how the model thinks through the problems.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '{'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '"action": "Final Answer",'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '"action_input": "The data regarding customers is stored in a SQL Database,
    specifically in the table named ''ecommerce.users''."'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '{'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '"action": "get_table_columns",'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '"action_input": {'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '"database": "ecommerce",'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"table": "users"'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '{'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '"action": "get_table_columns",'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '"action_input": {'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '"database": "ecommerce",'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"table": "sessions"'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '{'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '"action": "get_table_column_distr",'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '"action_input": {'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '"database": "ecommerce",'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"table": "sessions",'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"column": "action_date",'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"n": 10'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '{'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '"action": "get_table_column_distr",'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '"action_input": {'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '"database": "ecommerce",'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"table": "sessions",'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"column": "session_duration",'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"n": 10'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '{'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '"action": "get_table_column_distr",'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '"action_input": {'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '"database": "ecommerce",'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"table": "sessions",'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"column": "revenue",'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"n": 10'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '{'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '"action": "Final Answer",'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '"action_input": "Based on the data available in the ''ecommerce.users'' and
    ''ecommerce.sessions'' tables, an ''active'' customer could preliminarily be defined
    as one who has had a session within the last 30 days, with a session duration
    and revenue above certain thresholds. The ''is_active'' column in the ''users''
    table may already reflect this or a similar definition, but further analysis would
    be required to set specific thresholds for ''session_duration'' and ''revenue''.
    These thresholds could be determined by calculating averages or percentiles based
    on the data distribution."'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '{'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '"action": "get_table_columns",'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '"action_input": {'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '"database": "ecommerce",'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"table": "users"'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '{'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '"action": "execute_sql",'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '"action_input": {'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '"query": "SELECT user_id FROM ecommerce.users WHERE country = ''United Kingdom''"'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: That’s an excellent example of the situation when the agent overcomplicated
    the question and went into too much detail. Human analysts also make such mistakes
    from time to time. So, it’s interesting to see similar patterns in LLM behaviour.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to reflect on how we could potentially fix this issue, there are
    a couple of ways:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: First, we could prevent the cases when we try to get too much data from the
    database, returning an error if there are more than 1K rows in the output of the
    `execute_sql` function.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other thing I would think about is allowing LLM to ask follow-up questions
    and instruct it not to make assumptions.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s move on to the BabyAGI approach that inspired the current one.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续研究启发当前方法的 BabyAGI 方法。
- en: BabyAGI agent with Tools
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带工具的 BabyAGI 代理
- en: '*The code below is based on* [*example*](https://github.com/langchain-ai/langchain/blob/master/cookbook/baby_agi_with_agent.ipynb)
    *from LangChain’s cookbook.*'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*下面的代码基于* [*示例*](https://github.com/langchain-ai/langchain/blob/master/cookbook/baby_agi_with_agent.ipynb)
    *来自 LangChain 的食谱。*'
- en: Similar to the previous approach, our other experimental one, BabyAGI, tries
    to plan first and then execute.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的方法类似，我们的另一个实验方法 BabyAGI 尝试先计划然后执行。
- en: This approach uses retrieval, so we need to set up a vector storage and embedding
    model. I use open-source and lightweight [Chroma](https://python.langchain.com/docs/integrations/vectorstores/chroma)
    for storage and OpenAI embeddings.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使用检索，因此我们需要设置向量存储和嵌入模型。我使用开源且轻量级的 [Chroma](https://python.langchain.com/docs/integrations/vectorstores/chroma)
    进行存储和 OpenAI 嵌入。
- en: '[PRE33]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Retrieval allows the model to store all the results for a long term and extract
    and pass only the most relevant ones. If you want to learn more about retrieval,
    read [my article on RAG](https://medium.com/towards-data-science/rag-how-to-talk-to-your-data-eaf5469b83b0)
    (Retrieval Augmented Generation).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 检索允许模型长期存储所有结果，并提取和传递仅最相关的结果。如果你想了解更多关于检索的内容，请阅读 [我关于 RAG 的文章](https://medium.com/towards-data-science/rag-how-to-talk-to-your-data-eaf5469b83b0)（检索增强生成）。
- en: Firstly, we will create a TO-DO chain that we will use as a tool for our executor
    later.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个待办事项链，稍后将用作我们执行器的工具。
- en: '[PRE34]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Then, we will create an agent specifying tools and prompts.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个指定工具和提示的代理。
- en: '[PRE35]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The last step is to define the BabyAGI executor and run it.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是定义 BabyAGI 执行器并运行它。
- en: '[PRE36]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Again, the model failed to return results because it wasn’t able to follow the
    input schema for the tool.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，模型未能返回结果，因为它无法遵循工具的输入模式。
- en: Also, surprisingly, the model decided not to use the TO-DO function to create
    a to-do list but to jump into querying SQL. However, the first query wasn’t correct.
    The model tried to recover and call the`get_table_columns` function to get column
    names, but it failed to follow the schema.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，令人惊讶的是，模型决定不使用待办事项功能来创建待办列表，而是直接跳入 SQL 查询。然而，第一个查询不正确。模型尝试恢复并调用`get_table_columns`函数以获取列名，但未能遵循模式。
- en: Let’s look at the log.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看日志。
- en: '[PRE37]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: So, we’ve seen another problem that is pretty common for agents not powered
    by OpenAI functions — they fail to follow the structure.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们看到另一个问题，这在未使用 OpenAI 函数的代理中非常常见——它们无法遵循结构。
- en: AutoGPT agent with Tools
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带工具的 AutoGPT 代理
- en: '*The code below is based on* [*example*](https://github.com/langchain-ai/langchain/blob/master/cookbook/autogpt/marathon_times.ipynb)
    *from LangChain’s cookbook.*'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '*下面的代码基于* [*示例*](https://github.com/langchain-ai/langchain/blob/master/cookbook/autogpt/marathon_times.ipynb)
    *来自 LangChain 的食谱。*'
- en: Let’s look at another experimental approach — the implementation of [AutoGPT](https://github.com/Significant-Gravitas/AutoGPT)
    using the LangChain framework.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一种实验方法——使用 LangChain 框架实现的 [AutoGPT](https://github.com/Significant-Gravitas/AutoGPT)。
- en: Again, we need to set up a vector storage for intermediate steps.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们需要为中间步骤设置向量存储。
- en: '[PRE38]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this case, again, we can’t specify any prompt to the model. Let’s try to
    use it without any specific guidance. But let’s add the `get_tables` tool so the
    model can see all the available tables. I hope it will help the model with writing
    correct SQL queries.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们再次无法向模型指定任何提示。让我们尝试在没有任何具体指导的情况下使用它。但我们将添加 `get_tables` 工具，以便模型可以查看所有可用的表。我希望这能帮助模型编写正确的
    SQL 查询。
- en: '[PRE39]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Let’s create an AutoGPT agent. It’s as easy as one function call. Then, let’s
    execute it and see how it works.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个 AutoGPT 代理。这只需一个函数调用即可完成。然后，我们执行它，看看它是如何工作的。
- en: '[PRE40]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The model was able to come up with the right answer: “The number of active
    customers from the United Kingdom is 111,469.”'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 模型能够给出正确的答案：“来自英国的活跃客户数量是 111,469。”
- en: Reading through the prompt is interesting since we used the default one. You
    can access it via `analyst_agent_autogpt.chain.prompt`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读提示是有趣的，因为我们使用了默认提示。你可以通过 `analyst_agent_autogpt.chain.prompt` 访问它。
- en: '[PRE41]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: So, we can see that this model has long-term memory via vector storage. Also,
    it has a comprehensive reasoning consisting of thought, reasons, plan, criticism
    and summary.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们可以看到这个模型通过向量存储具有长期记忆。此外，它还具备全面的推理，包括思考、理由、计划、批评和总结。
- en: Let’s look at the model’s reasoning (I’ve filtered only the model’s responses).
    So, it followed the same way as the previous successful agents.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Overall, AutoGPT looks like a working approach. However, I still believe that
    the most reliable way to build agents right now is through OpenAI functions.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Do we need to build everything from scratch?
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve spent some wonderful learning time building the agent integrated with
    SQL Database. However, I must mention that LangChain has its own implementation
    of SQL agent — [SQLDatabaseChain](https://python.langchain.com/docs/integrations/toolkits/sql_database).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: This approach uses SQL Alchemy to interact with the databases. So, we need to
    install the package `clickhouse-sqlalchemy` to connect to ClickHouse.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We can set up a connection to the database and initialize a toolkit.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: A toolkit is a collection of useful tools related to some topic. You can find
    lots of examples in [the documentation](https://python.langchain.com/docs/integrations/toolkits).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: We can see the list of tools we have in the toolkit. There are tools to make
    an SQL query or get information related to the database.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Then, we can quickly create and run an agent based on OpenAI functions.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We got the correct answer without much hassle on our side.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We can use `langchain.debug = True` to see what prompt was used.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: So, we have a pretty convenient and working implementation of SQL analyst. If
    you don’t need any custom changes, you can just use the LangChain implementation.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Also, you can tweak it a bit, for example, by passing a prompt to the `create_sql_agent`
    function ([documentation](https://api.python.langchain.com/en/latest/agent_toolkits/langchain_community.agent_toolkits.sql.base.create_sql_agent.html?highlight=create_sql_agent#langchain_community.agent_toolkits.sql.base.create_sql_agent)).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today, we’ve learned how to create different types of agents. We’ve implemented
    an LLM-powered agent that can work with SQL databases entirely from scratch. Then,
    we leveraged high-level LangChain tools to achieve the same result with a couple
    of function calls.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: So, now our LLM-powered analyst can use data from your DB and answer questions.
    It’s a significant improvement. We can add our SQL Database agent as a tool for
    our LLM-powered analyst. It will be our first skill.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: The agent now can answer data-related questions and work on their own. However,
    the cornerstone of the analytics work is collaboration. So, in the following article,
    we will add memory and learn agents to ask follow-up questions. Stay tuned!
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Thank you a lot for reading this article. I hope it was insightful to you. If
    you have any follow-up questions or comments, please leave them in the comments
    section.
  id: totrans-299
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
