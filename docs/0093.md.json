["```py\nimport os\nimport sys\nimport time\nimport numpy as np\nimport scipy as sci\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\n```", "```py\nclass Molecule(object):\n    #Constructor\n    def __init__(self,molecule,position,velocity,mass,color=\"black\"):\n        self.molecule=molecule\n        self.position=np.array([x_i for x_i in position])\n        self.velocity=np.array([v_i for v_i in velocity])\n        self.mass=mass\n        self.color=color\n\n    #Setters for position, velocity, mass and color\n    def set_position(self,position):\n        self.position=np.array([x_i for x_i in position])\n\n    def set_velocity(self,velocity):\n        self.velocity=np.array([v_i for v_i in velocity])\n\n    def set_color(self,color):\n        self.color=color\n\n    def set_mass(self,mass):\n        self.mass=mass\n\n    #Getters for position, velocity, mass and color\n    def get_position(self):\n        return self.position\n\n    def get_velocity(self):\n        return self.velocity\n\n    def get_color(self):\n        return self.color\n\n    def get_mass(self):\n        return self.mass\n```", "```py\nclass Simulation(object):\n    #Constructor\n    def __init__(self,name,box_dim,t_step,particle_radius):\n        #Set simulation inputs\n        self.name=name #Name of the simulation\n        self.box_dim=[x for x in box_dim] #Dimensions of the box\n        self.t_step=t_step #Timestep\n        self.particle_radius=particle_radius #Radius of the particles\n\n        #Calculate volume and number of dimensions\n        self.V=np.prod(self.box_dim) #Area/Volume of the box\n        self.dim=int(len(box_dim)) #Number of dimensions (2D or 3D)\n\n        #Initialize paramters\n        self.molecules=[] #Create empty list to store objects of class Molecule\n        self.n_molecules=0 #Create variable to store number of molecules\n        self.wall_collisions=0 #Create variable to store number of wall collisions\n        self.wall_momentum=0 #Create variable to store net momentum exchanged with wall\n```", "```py\n #Still in Simulation class\n    def _generate_initial_positions(self,n,dist=\"uniform\"):\n            #Uniform distribution\n            if dist==\"uniform\":\n                _pos=np.random.uniform(low=[0]*self.dim,high=self.box_dim,size=(n,self.dim))\n\n            #Store positions in temporary variable    \n            self._positions=_pos\n\n    def _generate_initial_velocities(self,n,v_mean,v_std,dist=\"normal\"):\n        #Normal distribution with mean v_mean and std v_std\n        if dist==\"normal\":\n            self.v_mean=v_mean\n            self.v_std=v_std\n            _vel=np.random.normal(loc=v_mean,scale=v_std,size=(n,self.dim))\n\n        #Uniform distribution with lower bound v_mean and higher bound v_std\n        if dist==\"uniform\":\n            self.v_mean=v_mean\n            self.v_std=v_std\n            _vel=np.random.uniform(low=v_mean,high=v_std,size=(n,self.dim))\n\n        #All velocities equal to v_mean\n        if dist==\"equal\":\n            self.v_mean=v_mean\n            self.v_std=v_std\n            _vel=v_mean*np.ones((n,self.dim))\n\n        #Randomly switch velocities to negative with probability 0.5\n        for i in range(_vel.shape[0]):\n            for j in range(_vel.shape[1]):\n                if np.random.uniform() > 0.5:\n                    _vel[i,j]=-_vel[i,j]\n\n        #Store velocities in temporary variable\n        self._velocities=_vel\n```", "```py\n #Still in Simulation class\n    def add_molecules(self,molecule,n,v_mean,v_std,pos_dist=\"uniform\",v_dist=\"normal\",color=\"black\"):\n        #Generate initial positions and velocities\n        self._generate_initial_positions(n,dist=pos_dist)\n        self._generate_initial_velocities(n,v_mean,v_std,dist=v_dist)\n\n        #Initialize objects of class Molecule in a list (set mass to 1 as default)\n        _add_list=[Molecule(molecule,position=self._positions[i,:],velocity=self._velocities[i,:],color=color,mass=1) for i in range(n)]\n        self.molecules.extend(_add_list)\n        self.n_molecules+=len(_add_list)\n```", "```py\n #Still in Simulation class\n    def make_matrices(self):\n        #Make empty matrices to store positions, velocities, colors, and masses\n        self.positions=np.zeros((self.n_molecules,self.dim))\n        self.velocities=np.zeros((self.n_molecules,self.dim))\n        self.colors=np.zeros(self.n_molecules,dtype=\"object\")\n        self.masses=np.zeros(self.n_molecules)\n\n        #Iterate over molecules, get their properties and assign to matrices\n        for i,m in enumerate(self.molecules):\n            self.positions[i,:]=m.get_position()\n            self.velocities[i,:]=m.get_velocity()\n            self.colors[i]=m.get_color()\n            self.masses[i]=m.get_mass()\n\n        #Make vectors with magnitudes of positions and velocities\n        self.positions_norm=np.linalg.norm(self.positions,axis=1)\n        self.velocities_norm=np.linalg.norm(self.velocities,axis=1)\n\n        #Make distance matrix\n        self.distance_matrix=np.zeros((self.n_molecules,self.n_molecules))\n        for i in range(self.distance_matrix.shape[0]):\n            for j in range(self.distance_matrix.shape[1]):\n                self.distance_matrix[i,j]=np.linalg.norm(self.positions[i,:]-self.positions[j,:])\n\n        #Set diagonal entries (distance with itself) to a high value\n        #to prevent them for appearing in the subsequent distance filter\n        np.fill_diagonal(self.distance_matrix,1e5)\n```", "```py\n #Still in Simulation class\n    def update_positions(self):\n        #1: Check molecule collisions\n\n        #Find molecule pairs that will collide\n        collision_pairs=np.argwhere(self.distance_matrix < 2*self.particle_radius)\n\n        #If collision pairs exist \n        if len(collision_pairs):\n\n            #Go through pairs and remove repeats of indices\n            #(for eg., only consider (1,2), remove (2,1))\n            pair_list=[]\n            for pair in collision_pairs:\n                add_pair=True\n                for p in pair_list:\n                    if set(p)==set(pair):\n                        add_pair=False\n                        break\n                if add_pair:\n                    pair_list.append(pair)\n\n            #For every remaining pair, get the molecules, positions, and velocities\n            for pair in pair_list:\n                m_1=self.molecules[pair[0]]\n                m_2=self.molecules[pair[1]]\n\n                x_1=m_1.get_position()\n                x_2=m_2.get_position()\n\n                u_1=m_1.get_velocity()\n                u_2=m_2.get_velocity()\n\n                #Check if molecules are approaching or departing\n                approach_sign=np.sign(np.dot(u_1-u_2,x_2-x_1))\n                #If molecules are approaching\n                if approach_sign == 1:\n                    #Get masses\n                    ms_1=m_1.get_mass()\n                    ms_2=m_2.get_mass()\n\n                    #Calculate final velocities\n                    v_1=u_1 - 2*ms_2/(ms_1 + ms_2) * (np.dot(u_1-u_2,x_1-x_2)/np.linalg.norm(x_1-x_2)**2) * (x_1 - x_2)\n                    v_2=u_2 - 2*ms_1/(ms_1 + ms_2) * (np.dot(u_2-u_1,x_2-x_1)/np.linalg.norm(x_2-x_1)**2) * (x_2 - x_1)\n\n                    #Update velocities of the molecule objects\n                    m_1.set_velocity(v_1)\n                    m_2.set_velocity(v_2)\n\n        #2: Update positions\n\n        #Iterate over all the molecule objects\n        for i,m in enumerate(self.molecules):\n            #Get the position, velocity, and mass\n            _x=m.get_position()\n            _v=m.get_velocity()\n            _m=m.get_mass()\n\n            #Calculate new position\n            _x_new=_x + _v * self.t_step\n\n            #3: Check wall collisions\n\n            #Check collisions with the top and right walls\n            _wall_diff=_x_new - np.array(self.box_dim)           \n            #If wall collisions present\n            if _wall_diff[_wall_diff>=0].shape[0] > 0:\n                #Increment collision counter\n                self.wall_collisions+=1\n                #Check whether collision in x or y direction\n                _coll_ind=np.argwhere(_wall_diff>0)\n                #For component(s) to be reflected\n                for c in _coll_ind:\n                    #Reflect velocity\n                    _v[c]=-_v[c]\n                    #Increment wall momentum\n                    self.wall_momentum+=2*_m*np.abs(_v[c])\n                #Update velocity\n                m.set_velocity(_v)\n                #Update position based on new velocity\n                _x_new=_x + _v * self.t_step\n\n            #Check collisions with the bottom and left walls    \n            if _x_new[_x_new<=0].shape[0] > 0:\n                #Increment collision counter\n                self.wall_collisions+=1\n                #Check whether collision in x or y direction\n                _coll_ind=np.argwhere(_x_new<0)\n                #For component(s) to be reflected\n                for c in _coll_ind:\n                    #Reflect velocity\n                    _v[c]=-_v[c]\n                    #Increment wall momentum\n                    self.wall_momentum+=2*_m*np.abs(_v[c])\n                #Update velocity    \n                m.set_velocity(_v)\n                #Update position based on new velocity\n                _x_new=_x + _v * self.t_step\n\n            #Update position of the molecule object            \n            m.set_position(_x_new)\n\n        #Construct matrices with updated positions and velocities\n        self.make_matrices()\n```", "```py\n #Still in Simulation class\n    def safe_division(self,n,d):\n        if d==0:\n            return 0\n        else:\n            return n/d\n\n    def run_simulation(self,max_time):\n        #Print \"Starting simulation\"\n        print(\"Starting simulation...\")\n\n        #Make matrices\n        self.make_matrices()\n\n        #Calculate number of iterations\n        self.max_time=max_time\n        self.n_iters=int(np.floor(self.max_time/self.t_step))\n\n        #Make tensors to store positions and velocities of all molecules at each timestep f\n        self.x_dynamics=np.zeros(((self.n_molecules,self.dim,self.n_iters)))\n        self.v_dynamics=np.zeros((self.n_molecules,self.n_iters))\n\n        #In each iteration\n        for i in range(self.n_iters):                   \n            #Save positions and velocities to the defined tensors\n            self.x_dynamics[:,:,i]=self.positions\n            self.v_dynamics[:,i]=self.velocities_norm\n\n            #Calculate rms velocity\n            self.v_rms=np.sum(np.sqrt(self.velocities_norm**2))/self.velocities_norm.shape[0]\n\n            #Print current iteration information\n            _P=self.safe_division(self.wall_momentum,i*self.t_step*np.sum(self.box_dim))\n            print(\"Iteration:{0:d}\\tTime:{1:.2E}\\tV_RMS:{2:.2E}\\tWall Pressure:{3}\".format(i,i*self.t_step,self.v_rms,_P))\n\n            #Call the update_positions function to handle collisions and update positions\n            self.update_positions()\n\n        #Caclulate final pressure\n        self.P=self.wall_momentum/(self.n_iters*self.t_step*np.sum(self.box_dim))\n        print(\"Average pressure on wall: {0}\".format(self.P))\n        return self.P\n```", "```py\n #Still in Simulation class\n    def create_2D_box(self):\n        fig=plt.figure(figsize=(10,10*self.box_dim[1]/self.box_dim[0]),dpi=300)\n        return fig\n```", "```py\n #Still in Simulation class\n    def show_molecules(self,i):\n        #Clear axes\n        plt.cla()\n\n        #Plot a line showing the trajectory of a single molecule\n        plt.plot(self.x_dynamics[0,0,:i+1],self.x_dynamics[0,1,:i+1],color=\"red\",linewidth=1.,linestyle=\"-\")\n\n        #Plot a single molecule in red that is being tracked \n        plt.scatter(self.x_dynamics[0,0,i],self.x_dynamics[0,1,i],color=\"red\",s=20)\n\n        #Plot the rest of the molecules\n        plt.scatter(self.x_dynamics[1:,0,i],self.x_dynamics[1:,1,i],color=self.colors[1:],s=20)\n\n        #Remove ticks on the plot\n        plt.xticks([])\n        plt.yticks([])\n\n        #Set margins to 0\n        plt.margins(0)\n\n        #Set the limits of the box according to the box dimensions\n        plt.xlim([0,self.box_dim[0]])\n        plt.ylim([0,self.box_dim[1]])\n\n    def make_animation(self,filename=\"KTG_animation.mp4\"):\n        #Call the function to create the figure\n        fig=self.create_2D_box()\n\n        #Create the animation\n        anim=FuncAnimation(fig,self.show_molecules,frames=self.n_iters,interval=50,blit=False)\n\n        #Save animation as a file\n        anim.save(filename,writer=\"ffmpeg\")\n```", "```py\n #Still in Simulation class\n    def plot_hist(self,i):\n        #Clear axes\n        plt.cla()\n\n        #Make histogram\n        plt.hist(self.v_dynamics[:,i],density=True,color=\"plum\",edgecolor=\"black\")\n\n        #Define axis limits\n        plt.xlim([0,3])\n        plt.ylim([0,3])\n\n    def make_velocity_histogram_animation(self,filename=\"KTG_histogram.mp4\"):\n        #Create empty figure\n        fig=plt.figure(figsize=(5,5),dpi=500)\n\n        #Create animation\n        anim_hist=FuncAnimation(fig,self.plot_hist,frames=self.n_iters,interval=50,blit=False)\n\n        #Save animation\n        anim_hist.save(filename,writer=\"ffmpeg\")\n```", "```py\nif __name__==\"__main__\":\n    #Create simulation object and define input parameters\n    sim=Simulation(name=\"kinetic_theory_simulation\",box_dim=[1.0,1.0],t_step=1e-2,particle_radius=1e-2)\n\n    #Add N2 molecules to the box\n    sim.add_molecules(\"N2\",n=100,v_mean=1.0,v_std=0.2,v_dist=\"normal\")\n\n    #Run the simulation and store the pressure output in P\n    P=sim.run_simulation(15)\n\n    #Make the box animation\n    sim.make_animation()\n\n    #Make the histogram animation\n    sim.make_velocity_histogram_animation()\n```"]