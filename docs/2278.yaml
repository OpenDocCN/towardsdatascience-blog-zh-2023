- en: Compute the Distance Matrix of a Set of Sites from Their Coordinates in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://towardsdatascience.com/compute-the-distance-matrix-of-a-set-of-sites-from-their-coordinates-in-python-d5fc92a0ba9e?source=collection_archive---------0-----------------------#2023-07-16](https://towardsdatascience.com/compute-the-distance-matrix-of-a-set-of-sites-from-their-coordinates-in-python-d5fc92a0ba9e?source=collection_archive---------0-----------------------#2023-07-16)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Easily estimate the distance between any pair of sites from their geographical
    coordinates as a stepping stone to solving general routing problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@carlosjuribe?source=post_page-----d5fc92a0ba9e--------------------------------)[![Carlos
    J. Uribe](../Images/902c5f4ac5d404dd99916f145be6756c.png)](https://medium.com/@carlosjuribe?source=post_page-----d5fc92a0ba9e--------------------------------)[](https://towardsdatascience.com/?source=post_page-----d5fc92a0ba9e--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----d5fc92a0ba9e--------------------------------)
    [Carlos J. Uribe](https://medium.com/@carlosjuribe?source=post_page-----d5fc92a0ba9e--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ¬∑
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F4337eddb94ed&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fcompute-the-distance-matrix-of-a-set-of-sites-from-their-coordinates-in-python-d5fc92a0ba9e&user=Carlos+J.+Uribe&userId=4337eddb94ed&source=post_page-4337eddb94ed----d5fc92a0ba9e---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----d5fc92a0ba9e--------------------------------)
    ¬∑13 min read¬∑Jul 16, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fd5fc92a0ba9e&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fcompute-the-distance-matrix-of-a-set-of-sites-from-their-coordinates-in-python-d5fc92a0ba9e&user=Carlos+J.+Uribe&userId=4337eddb94ed&source=-----d5fc92a0ba9e---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fd5fc92a0ba9e&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fcompute-the-distance-matrix-of-a-set-of-sites-from-their-coordinates-in-python-d5fc92a0ba9e&source=-----d5fc92a0ba9e---------------------bookmark_footer-----------)![](../Images/871f751c51440a309a64ceac1dc53e26.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Image generated by DALL¬∑E 3 with author‚Äôs prompt: ‚Äúan image of a network of
    cities on top of a map where each city is connected to all other cities‚Äù'
  prefs: []
  type: TYPE_NORMAL
- en: '*üëÅÔ∏è* **This is article #4 of the series covering the project ‚Äú**[**An Intelligent
    Decision Support System for Tourism in Python**](https://medium.com/@carlosjuribe/list/an-intelligent-decision-support-system-for-tourism-in-python-b6ba165b4236)**‚Äù,**
    I encourage you to check it out to get a general overview of the whole project.
    If you‚Äôre only interested in creating distance matrices, this article is all you
    need, it‚Äôs self-contained. If you also want to apply the distance matrix to practical
    problems, the series will be of interest to you.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The present article continues our journey right where [sprint 3](https://medium.com/@carlosjuribe/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c)
    left off: the building of an optimization model for the Traveling Salesman Problem,
    *given a fixed set of places to visit* and their pair-wise distances. In sprint
    4, we take a brief detour from modeling and **develop a class with geospatial
    functionality** that will be very handy when we attempt to solve **general** Traveling
    Salesman Problems, *i.e.,* problemsfor arbitrary sites for which we may not have
    distance data readily available. We stated this ‚Äúrequirement‚Äù in the previous
    sprint, and we‚Äôll build a subsystem to satisfy it in this one.'
  prefs: []
  type: TYPE_NORMAL
- en: Table of contents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[1\. Previous sprint recap](#3457)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[2\. Reading the input data](#d4c6)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[3\. Creating a distance matrix from location data](#4a0e)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[3.1\. Should I go the extra mile to gain an extra yard?](#4a07)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[3.2\. Geolocation utilities with](#8bc3) `[geopy](#8bc3)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[3.3\. Getting to the points](#f713)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[3.4\. From coordinates to distance matrix](#6590)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[4\. Wrap it up! (inside a class)](#8f29)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[4.1\.](#a881) `[GeoAnalyzer](#a881)` [class design](#a881)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[4.2\. Class usage demo](#8c36)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[5\. Conclusion (or planning for next sprint)](#ef0c)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 1\. Previous sprint recap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous article, the one of [sprint 3](https://medium.com/@carlosjuribe/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c),
    we carried out a proof-of-concept whereby we demonstrated that we can solve the
    [Traveling Salesman Problem](https://en.wikipedia.org/wiki/Travelling_salesman_problem)
    (TSP) for a list of sites, *provided we had the distances between each possible
    pair of sites*, as a distance matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c?source=post_page-----d5fc92a0ba9e--------------------------------)
    [## Implementing, solving and visualizing the Traveling Salesman Problem with
    Python'
  prefs: []
  type: TYPE_NORMAL
- en: Learn how to translate an optimization model from Math to Python, optimize it,
    and visualize the solution to gain quick‚Ä¶
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c?source=post_page-----d5fc92a0ba9e--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: We considered the distance matrix as given because, at that stage of development,
    the focus was on *model building*, not *data acquisition*. But once the model
    was ready and worked fine for our fixed set of locations, we quickly realized
    **we needed a way to** **solve general TSP problems** (problems for arbitrary
    sets of sites). This generalization is required to create a truly useful MVP.
    As such, we concluded the natural next step is to find a way to **automatically
    obtain a distance matrix from the coordinates of our sites of interest**, a step
    that we‚Äôll cover in this article.
  prefs: []
  type: TYPE_NORMAL
- en: 'In doing so, our **new basic input** will be much simpler and natural, just
    the geographical coordinates of the sites we want to visit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/59ec3de04074a9813170b50ccf7fed83.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1.** Coordinates of the sites of interest. (Image by author)'
  prefs: []
  type: TYPE_NORMAL
- en: 'and the output will be the dataframe we used as input for the TSP model, the
    distance matrix for the input sites:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/18f610b518e1fed4161c761c29896bb7.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 2.** Desired distance matrix for a given set of sites. (Image by author)'
  prefs: []
  type: TYPE_NORMAL
- en: For consistency, we‚Äôll use the same Paris sites we have considered so far. In
    the [next article](/a-classy-approach-to-solving-traveling-salesman-problems-effectively-dbb44e7d30b9),
    we‚Äôll integrate this functionality with the optimization model of the Traveling
    Salesman Problem, arriving at a more versatile MVP.
  prefs: []
  type: TYPE_NORMAL
- en: '***üéØ******Keeping the final goal in mind***'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Let‚Äôs take a step back and briefly recapitulate why we‚Äôre doing this. The
    original real-life problem we are aspiring to solve is what we can call the* ***Traveling
    Tourist Problem*** *(TTP), that is, the problem of creating* ***optimal trip plans***
    *for the general tourist,* ***given both her ‚Äúpersonal‚Äù data*** *(preferences,
    budgets, etc.)* ***and the trip ‚Äúenvironment‚Äù data*** *(distances, prices, modes
    of transport, etc.).*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Since this real-life problem was deemed too complex, we simplified it to its
    essentialist version in* [*sprint 1*](https://medium.com/@carlosjuribe/plan-an-optimal-trip-for-your-next-holidays-with-the-help-of-operations-research-and-python-481b1ea38fef)*,
    to bootstrap the design of a solution. This ‚Äúessentialist problem‚Äù turned out
    to be the* [*Traveling Salesman Problem*](/modeling-the-traveling-salesman-problem-from-first-principles-bd6530c9c07)
    *(TSP), where we considered the points to visit to be the ‚Äúsites of interest‚Äù
    for the tourist in a city. With the functionality developed in this article, we
    are one step closer to a general solution of the TTP, with the TSP as the core
    of the solution.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 2\. Reading the input data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our basic input is now the geographical coordinates of the sites we want to
    visit on the trip. We will treat the ‚Äòhotel‚Äô as a different kind of site, since
    the hotel is not, in itself, a ‚Äúsite of interest‚Äù, but a place we must visit to
    get some sleep on multi-day trips. Our choice of hotel could be different on a
    different trip, or under different circumstances, while the sites of interest
    in a city are more or less ‚Äúconstant‚Äù places that many travel guides agree on.
    The usefulness of this distinction will become more apparent when we‚Äôre ready
    to explore more advanced applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, I‚Äôve stored the coordinates of our hotel in a CSV file, `location_hotel.csv`,
    and the coordinates for the "sites of interest" in a separate CSV file, `sites_coordinates.csv`.
    Both CSVs have the same structure, so we read and combine them into one dataframe
    containing all our sites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/b01c96cdeebff5b18e72e0b390391c18.png)'
  prefs: []
  type: TYPE_IMG
- en: '***‚ÑπÔ∏è How to quickly prepare your own location data***'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you want to follow along this article using your own list of sites, you
    have to replicate the steps I took to obtain the coordinates:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 1\. Go to [Google Maps](https://www.google.com/maps/) and search for each site
    in your list.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '2\. Each site will appear as a point on the map. Right-click on each one. The
    first element that appears is a pair of numbers: the latitude and longitude of
    the point you clicked on.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 3\. Click on those numbers, they will be saved in your clipboard, ready to be
    pasted in a file together with the name you choose for that point.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 4\. Repeat 1 to 3 for all your sites and you‚Äôll have a file equivalent to `sites_coordinates.csv`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This process works fine for a small set of sites, but if you have hundreds,
    or even tens, of sites, it becomes very tedious. In [a future article] we‚Äôll create
    a way to automate this manual work, which is called *geolocation*.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 3\. Creating a distance matrix from location data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To build a distance matrix, we need to obtain the distance between any pair
    of locations. Sounds simple, but ‚Äúdistance‚Äù really depends on the context. Do
    we consider the number reported by mapping applications, like Google Maps, that
    take into account the streets network, bridges, parks, *etc*.? If so, do we take
    the distance that a pedestrian would walk, or that a car would drive? Or maybe
    just the good old length of a straight line connecting the two points? Clearly,
    we have many possible distances to choose from, with varying degrees of accuracy.
    *The first question we have to answer is*: **how should we define ‚Äúdistance‚Äù**
    in the particular context of *our problem*, and at *this stage*?'
  prefs: []
  type: TYPE_NORMAL
- en: 3.1\. Should I go the extra mile to gain an extra yard?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It‚Äôs natural to feel tempted to use accurate data. In the end, we all know that
    accuracy is intrinsically valuable, and hence we are inclined to pursue accurate
    data, the more, the better. But we must also remember that more accurate data
    entails more complex code and dependencies, and thus more development time and
    maintenance. As we‚Äôre following an **agile approach**, we don‚Äôt let the *best*
    be the enemy of the *good*, so **we will start as simple as we can, and then add
    complexity gradually, only if it is justified.**
  prefs: []
  type: TYPE_NORMAL
- en: At this point of having to find distances between locations, we could do as
    many do, and jump straight to third-party API-based solutions that require app
    keys, credentials, or even credit card numbers for cloud providers. That approach
    is fine, but often times it is inefficient, as we can forget that **accurate information
    brings added value, but also comes with added costs**.
  prefs: []
  type: TYPE_NORMAL
- en: '*üëÅÔ∏è* ***There ain‚Äôt no such thing as ‚Äúfree accuracy‚Äù***'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Remembering that in general we always ‚Äúpay a price‚Äù for accessing accurate
    data (which is closely related to the concept of* [***Value of Information***](https://en.wikipedia.org/wiki/Value_of_information)*)
    is another reason why taking an agile approach to the problem is a leaner course
    of action. By* ***starting with simple assumptions*** *on the ‚Äú*required level
    of accuracy*‚Äù, and verifying their validity* ***on our own problem data****, we
    are ensuring that, if we eventually need to increase the accuracy of our data,
    we will be ‚Äúpaying a price‚Äù that is* ***worth the*** *(expected)* ***improved
    results****.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So let‚Äôs start very simple. We have coordinates. **First idea:** these coordinates
    are spread over parcels of the Earth *very small* compared to the radius of the
    Earth, so we could treat the latitudes as Y coordinates and the longitudes as
    X coordinates on a 2D plane, and then just compute the Euclidean distance (fancy
    term for the usual ‚Äústraight line‚Äù).
  prefs: []
  type: TYPE_NORMAL
- en: 'Pros: a simple formula for distance, no new dependencies or data, spatial relationships
    between locations are conserved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cons: latitudes and longitudes are dimensionless numbers, so the numbers we‚Äôd
    get when solving the problem would not be actual distances. This means that some
    info we care about, like total distance traveled, would not be available, even
    if we can obtain the optimal tour.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The cons trump the pros, so we need a more complex approach (**but still simple**).
    **Second idea**: treat the coordinates as what they are, points on the Earth,
    but approximate the Earth as a sphere. A sphere does not have the familiar Euclidean
    geometry, so we will need a non-trivial formula that considers this spherical
    geometry when calculating the ‚Äústraight line‚Äù distance between two points. So
    now it‚Äôs just a matter of implementing that formula using the radius of the Earth.
    We could do that, but we‚Äôll instead rely on a famous library that already does
    that, and even better.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.2\. Geolocation utilities with `**geopy**`
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If this article series were especially focused on geospatial data science, it
    would be valuable to take the time to explain and implement the formula for the
    [great-circle distance](https://en.wikipedia.org/wiki/Great-circle_distance),
    a nice baseline option to compute ‚Äústraight-line‚Äù distances between points on
    a sphere. However, this article series is about the creation of an **optimization-based
    tourism planning system**, so instead of crafting our own formulas for geospatial
    utilities, we will rely on [Geopy](https://geopy.readthedocs.io/en/stable/) to
    do the heavy lifting for us. That way, we maintain focus on reaching a solution
    quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install it by running in an Anaconda prompt (or inside the conda environment
    we created in the [first article](https://medium.com/@carlosjuribe/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c#:~:text=For%20organized%20people,in%20this%20series),
    if you created it) the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, let‚Äôs do a demonstration with `geopy` for just two locations.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3\. Getting to the points
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given the coordinates of two points, the `[geodesic](https://geopy.readthedocs.io/en/stable/#geopy.distance.geodesic)`
    function of `geopy` computes the distance of the geodesic connecting them across
    the Earth's surface. In Geometry, the [*geodesic*](https://en.wikipedia.org/wiki/Geodesic)
    is the path of minimal distance between points on a given [metric space](https://en.wikipedia.org/wiki/Metric_space).
    In our familiar Euclidean space, **straight lines** are the geodesics. In a spherical
    space, **great-circles** are. The underlying "space" that Geopy's `geodesic` function
    considers is an **accurate ellipsoid model of the Earth**.
  prefs: []
  type: TYPE_NORMAL
- en: '***üëÅ A great-circle is great, but an ellipse is even greater***'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Earlier I said we would consider the Earth to be a sphere, because it was
    the simplest workable approximation. In reality, the Earth isn‚Äôt a sphere, but
    an ellipsoid, a solid with a more complex geometry. Now that* `*geopy*` *will
    spare us from coding our own functions for non-Euclidean geometries, we can upgrade
    our approximation of the Earth and employ the more accurate* ***ellipsoidal distance***
    *between two points, instead of the great-circle distance. A better Earth model
    for the same lines of code. This indeed is free accuracy, so why not take it?*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here‚Äôs a function that computes the ellipsoidal distance between point 1 and
    point 2, in meters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: What is the distance between the Eiffel Tour and the Louvre?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 3173 meters, around 3.2 km. Google Maps says it‚Äôs 3.5 km. The **computed** distance
    is 8.6 % lower than the ‚Äú**real**‚Äù distance. Our legs only care about *absolute
    errors* in distance, though, which in this case amounts to just 330 extra meters
    to walk, compared to the estimated distance. Doesn‚Äôt seem like a significant error
    for a tourist who expects to be walking around all day in a big city.
  prefs: []
  type: TYPE_NORMAL
- en: And between the Eiffel Tour and Port de Suffren?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 328 meters, this time 6% lower (just 22 meters shorter) than the 350 meters
    Google Maps provides. Not that bad for applying a formula. As we would expect,
    the closer the points are, the less chance there is for streets to zigzag and
    turns to appear, and hence the lower the error incurred by the ellipsoid model.
    Looks **good enough** for our present purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Now we must apply this function to all pairs of locations, thus getting the
    distance matrix the TSP model needs.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4\. From coordinates to distance matrix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the easy part, where we just have to loop over all the sites twice and
    compute and store the distance between each pair. The below function does that.
    Note that the distance metric is passed as an optional argument, being the ellipsoidal
    distance we used before the default. We leave the door open to better distance
    metrics to be passed in the future.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/dc8c5a88bbc2fe418177b846e152407c.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.** Distance matrix resulting from using the ellipsoidal model of
    the Earth. (Image by author)'
  prefs: []
  type: TYPE_NORMAL
- en: And there we have it! As expected, the diagonal of the matrix is zero, and the
    matrix is symmetric. The index and columns of the output dataframe contain the
    names of the input sites.
  prefs: []
  type: TYPE_NORMAL
- en: Functionality demonstrated. Now we can do better to facilitate the use of this
    function. Let‚Äôs wrap up this functionality inside a class in a convenient manner,
    **for easy re-use**, and more importantly, for **easier integration with the optimization
    model** of the TSP we built in the previous sprint.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Wrap it up! (inside a class)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 4.1\. `GeoAnalyzer` class design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let‚Äôs create a new class, `GeoAnalyzer`, dedicated to the geospatial utilities
    that may arise in routing problems. As such, our function `compute_distance_matrix`
    fits in naturally as a method. The main parts of this class will be, for now:'
  prefs: []
  type: TYPE_NORMAL
- en: A dataframe having site locations, the attribute `_df_locations`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pure function `ellipsoidal_distance`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method `get_distance_matrix`, being equivalent to the previous function
    `compute_distance_matrix`, but using the instance attribute `_df_locations` to
    compute the distances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the user may want to add new locations to the list of locations at any
    point in his analysis, we include the method `add_locations` that accepts a dataframe
    of geographical coordinates and appends it to the previously existing one.
  prefs: []
  type: TYPE_NORMAL
- en: Below you can find the definition of `GeoAnalyzer`. Note there are other convenience
    methods and properties not mentioned here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 4.2\. Class usage demo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let‚Äôs explore a bit the main functionality of the class. We create an instance
    and add our sites of interest from Paris:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We check the representation of our instance at this point, which informs us
    that we‚Äôve provided 9 locations, which we can check the details of with the attribute
    `locations`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/eeb4a74be1a03f64e941620e2256c7c0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Of course, we can extract the distance matrix from the object, which by now
    it‚Äôs quite familiar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/dc8c5a88bbc2fe418177b846e152407c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And lastly, in case we‚Äôre curious about where these values come from, we can
    check it from the dataframe itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This would be more valuable if more distance metrics were available, something
    that we will see in future sprints.
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Conclusion (or planning for next sprint)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The end result of our work has been a class, `GeoAnalyzer`, with convenient
    methods that will help us generalize the Traveling Salesman Problem to arbitrary
    sets of sites. That generalization will be the precise goal of our [next sprint](https://medium.com/@carlosjuribe/a-classy-approach-to-solving-traveling-salesman-problems-effectively-dbb44e7d30b9),
    in which **we will create an estimator-like class for the TSP** that hides away
    the model-building steps covered in [sprint 2](https://medium.com/@carlosjuribe/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c)
    and takes as input the geo-coordinates of the sites to be visited. The `GeoAnalyzer`
    class will be a key component of this new estimator class, **enabling a true general
    use of the TSP optimization model** we have built. This new estimator-like class,
    combining the generality of both the `GeoAnalyzer` and the TSP model, will become
    the core of our solution to the more general **Traveling Tourist Problem** we
    aspire to solve. Continue to the [next sprint](https://medium.com/@carlosjuribe/a-classy-approach-to-solving-traveling-salesman-problems-effectively-dbb44e7d30b9)
    for the real deal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/a-classy-approach-to-solving-traveling-salesman-problems-effectively-dbb44e7d30b9?source=post_page-----d5fc92a0ba9e--------------------------------)
    [## A classy approach to solving Traveling Salesman Problems effectively with
    Python'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the TSP model in a scikit-learn-like fashion to ease the building
    and solving of routing optimization‚Ä¶
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/a-classy-approach-to-solving-traveling-salesman-problems-effectively-dbb44e7d30b9?source=post_page-----d5fc92a0ba9e--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to follow me, ask me questions, **give me feedback**, or contact me
    on [LinkedIn](https://www.linkedin.com/in/carlosjuribe/). Thanks for reading!
    üìàüòä
  prefs: []
  type: TYPE_NORMAL
