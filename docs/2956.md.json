["```py\nOPENAI_API_KEY = {your open ai key}\nGOOGLE_PALM_API_KEY = {your google palm api key}\nGOOGLE_MAPS_API_KEY = {your google maps api key here}\n```", "```py\nimport googlemaps\n\ndef convert_to_coords(input_address):\n    return self.gmaps.geocode(input_address)\n\nsecrets = load_secets()\ngmaps = googlemaps.Client(key=secrets[\"GOOGLE_MAPS_API_KEY\"])\n\nexample_coords = convert_to_coords(\"The Washington Moment, DC\")\n```", "```py\n[{'address_components': [{'long_name': '2',\n    'short_name': '2',\n    'types': ['street_number']},\n   {'long_name': '15th Street Northwest',\n    'short_name': '15th St NW',\n    'types': ['route']},\n   {'long_name': 'Washington',\n    'short_name': 'Washington',\n    'types': ['locality', 'political']},\n   {'long_name': 'District of Columbia',\n    'short_name': 'DC',\n    'types': ['administrative_area_level_1', 'political']},\n   {'long_name': 'United States',\n    'short_name': 'US',\n    'types': ['country', 'political']},\n   {'long_name': '20024', 'short_name': '20024', 'types': ['postal_code']}],\n  'formatted_address': '2 15th St NW, Washington, DC 20024, USA',\n  'geometry': {'location': {'lat': 38.8894838, 'lng': -77.0352791},\n   'location_type': 'ROOFTOP',\n   'viewport': {'northeast': {'lat': 38.89080313029149,\n     'lng': -77.0338224697085},\n    'southwest': {'lat': 38.8881051697085, 'lng': -77.0365204302915}}},\n  'partial_match': True,\n  'place_id': 'ChIJfy4MvqG3t4kRuL_QjoJGc-k',\n  'plus_code': {'compound_code': 'VXQ7+QV Washington, DC',\n   'global_code': '87C4VXQ7+QV'},\n  'types': ['establishment',\n   'landmark',\n   'point_of_interest',\n   'tourist_attraction']}]\n```", "```py\n def build_mapping_dict(start, end, waypoints):\n\n    mapping_dict = {}\n    mapping_dict[\"start\"] = self.convert_to_coords(start)[0]\n    mapping_dict[\"end\"] = self.convert_to_coords(end)[0]\n\n    if waypoints:\n      for i, waypoint in enumerate(waypoints):\n          mapping_dict[\"waypoint_{}\".format(i)] = convert_to_coords(\n                    waypoint\n                )[0\n\n    return mapping_dict\n```", "```py\n def build_directions_and_route(\n        mapping_dict, start_time=None, transit_type=None, verbose=True\n    ):\n    if not start_time:\n        start_time = datetime.now()\n\n    if not transit_type:\n        transit_type = \"driving\"\n\n      # later we replace this with place_id, which is more efficient\n      waypoints = [\n            mapping_dict[x][\"formatted_address\"]\n            for x in mapping_dict.keys()\n            if \"waypoint\" in x\n      ]\n      start = mapping_dict[\"start\"][\"formatted_address\"]\n      end = mapping_dict[\"end\"][\"formatted_address\"]\n\n      directions_result = gmaps.directions(\n            start,\n            end,\n            waypoints=waypoints,\n            mode=transit_type,\n            units=\"metric\",\n            optimize_waypoints=True,\n            traffic_model=\"best_guess\",\n            departure_time=start_time,\n      )\n\n      return directions_result\n```", "```py\n['bounds', \n'copyrights', \n'legs', \n'overview_polyline', \n'summary', \n'warnings', \n'waypoint_order'\n]\n```", "```py\n['distance', \n'duration', \n'end_address', \n'end_location', \n'start_address', \n'start_location', \n'steps', \n'traffic_speed_entry', \n'via_waypoint'\n]\n```", "```py\n['distance', \n'duration', \n'end_location', \n'html_instructions', \n'polyline', \n'start_location', \n'travel_mode'\n]\n```", "```py\nfrom googlemaps.convert import decode_polyline\n\noverall_route = decode_polyline(\ndirections_result[0][\"overview_polyline\"][\"points\"]\n)\nroute_coords = [(float(p[\"lat\"]),float(p[\"lng\"])) for p in overall_route]\n```", "```py\n marker_points = []\nnlegs = len(directions_result[0][\"legs\"])\nfor i, leg in enumerate(directions_result[0][\"legs\"]):\n\n  start, start_address = leg[\"start_location\"], leg[\"start_address\"]\n  end,  end_address = leg[\"end_location\"], leg[\"end_address\"]\n\n  start_loc = (float(start[\"lat\"]),float(start[\"lng\"]))\n  end_loc = (float(end[\"lat\"]),float(end[\"lng\"]))\n\n  marker_points.append((start_loc,start_address))\n\n  if i == nlegs-1:\n    marker_points.append((end_loc,end_address))\n```", "```py\nimport folium\nfrom branca.element import Figure\n\nfigure = Figure(height=500, width=1000)\n\n# decode the route\noverall_route = decode_polyline(\n  directions_result[0][\"overview_polyline\"][\"points\"]\n)\nroute_coords = [(float(p[\"lat\"]),float(p[\"lng\"])) for p in overall_route]\n\n# set the map center to be at the start location of the route\nmap_start_loc = [overall_route[0][\"lat\"],overall_route[0][\"lng\"]]\nmap = folium.Map(\n  location=map_start_loc, \n  tiles=\"Stamen Terrain\", \n  zoom_start=9\n)\nfigure.add_child(map)\n\n# Add the waypoints as red markers \nfor location, address in marker_points:\n    folium.Marker(\n        location=location,\n        popup=address,\n        tooltip=\"<strong>Click for address</strong>\",\n        icon=folium.Icon(color=\"red\", icon=\"info-sign\"),\n    ).add_to(map)\n\n# Add the route as a blue line\nf_group = folium.FeatureGroup(\"Route overview\")\nfolium.vector_layers.PolyLine(\n    route_coords,\n    popup=\"<b>Overall route</b>\",\n    tooltip=\"This is a tooltip where we can add distance and duration\",\n    color=\"blue\",\n    weight=2,\n).add_to(f_group)\nf_group.add_to(map)\n```", "```py\ndef get_route(directions_result):\n    waypoints = {}\n\n    for leg_number, leg in enumerate(directions_result[0][\"legs\"]):\n        leg_route = {}\n\n        distance, duration = leg[\"distance\"][\"text\"], leg[\"duration\"][\"text\"]\n        leg_route[\"distance\"] = distance\n        leg_route[\"duration\"] = duration\n        leg_route_points = []\n\n        for step in leg[\"steps\"]:\n             decoded_points = decode_polyline(step[\"polyline\"][\"points\"])\n            for p in decoded_points:\n              leg_route_points.append(f'{p[\"lat\"]},{p[\"lng\"]}')\n\n            leg_route[\"route\"] = leg_route_points\n            waypoints[leg_number] = leg_route\n\n    return waypoints\n```", "```py\ndef sample_route_with_legs(route, distance_per_point_in_km=0.25)):\n\n    all_distances = sum([float(route[i][\"distance\"].split(\" \")[0]) for i in route])\n    # Total points in the sample\n    npoints = int(np.ceil(all_distances / distance_per_point_in_km))\n\n    # Total points per leg\n    points_per_leg = [len(v[\"route\"]) for k, v in route.items()]\n    total_points = sum(points_per_leg)\n\n    # get number of total points that need to be represented on each leg\n    number_per_leg = [\n      max(1, np.round(npoints * (x / total_points), 0)) for x in points_per_leg\n      ]\n\n    sampled_points = {}\n    for leg_id, route_info in route.items():\n        total_points = int(points_per_leg[leg_id])\n        total_sampled_points = int(number_per_leg[leg_id])\n        step_size = int(max(total_points // total_sampled_points, 1.0))\n        route_sampled = [\n                route_info[\"route\"][idx] for idx in range(0, total_points, step_size)\n            ]\n\n        distance = route_info[\"distance\"]\n        duration = route_info[\"duration\"]\n\n        sampled_points[leg_id] = {\n                \"route\": [\n                    (float(x.split(\",\")[0]), float(x.split(\",\")[1]))\n                    for x in route_sampled\n                ],\n                \"duration\": duration,\n                \"distance\": distance,\n            }\n    return sampled_points\n```", "```py\nfor leg_id, route_points in sampled_points.items():\n    leg_distance = route_points[\"distance\"]\n    leg_duration = route_points[\"duration\"]\n\n    f_group = folium.FeatureGroup(\"Leg {}\".format(leg_id))\n    folium.vector_layers.PolyLine(\n                route_points[\"route\"],\n                popup=\"<b>Route segment {}</b>\".format(leg_id),\n                tooltip=\"Distance: {}, Duration: {}\".format(leg_distance, leg_duration),\n                color=\"blue\",\n                weight=2,\n    ).add_to(f_group)\n    # assumes the map has already been generated\n    f_group.add_to(map)\n```", "```py\nclass RouteFinder:\n    MAX_WAYPOINTS_API_CALL = 25\n\n    def __init__(self, google_maps_api_key):\n        self.logger = logging.getLogger(__name__)\n        self.logger.setLevel(logging.INFO)\n        self.mapper = RouteMapper()\n        self.gmaps = googlemaps.Client(key=google_maps_api_key)\n\n    def generate_route(self, list_of_places, itinerary, include_map=True):\n\n        self.logger.info(\"# \" * 20)\n        self.logger.info(\"PROPOSED ITINERARY\")\n        self.logger.info(\"# \" * 20)\n        self.logger.info(itinerary)\n\n        t1 = time.time()\n        directions, sampled_route, mapping_dict = self.build_route_segments(\n            list_of_places\n        )\n        t2 = time.time()\n        self.logger.info(\"Time to build route : {}\".format((round(t2 - t1, 2))))\n\n        if include_map:\n            t1 = time.time()\n            self.mapper.add_list_of_places(list_of_places)\n            self.mapper.generate_route_map(directions, sampled_route)\n            t2 = time.time()\n            self.logger.info(\"Time to generate map : {}\".format((round(t2 - t1, 2))))\n\n        return directions, sampled_route, mapping_dict\n```", "```py\nclass TravelMapperBase(object):\n    def __init__(\n        self, openai_api_key, google_palm_api_key, google_maps_key, verbose=False\n    ):\n        self.travel_agent = Agent(\n            open_ai_api_key=openai_api_key,\n            google_palm_api_key=google_palm_api_key,\n            debug=verbose,\n        )\n        self.route_finder = RouteFinder(google_maps_api_key=google_maps_key)\n\n    def parse(self, query, make_map=True):\n\n        itinerary, list_of_places, validation = self.travel_agent.suggest_travel(query)\n\n        directions, sampled_route, mapping_dict = self.route_finder.generate_route(\n            list_of_places=list_of_places, itinerary=itinerary, include_map=make_map\n        )\n```", "```py\nfrom travel_mapper.TravelMapper import load_secrets, assert_secrets\nfrom travel_mapper.TravelMapper import TravelMapperBase\n\ndef test(query=None):\n    secrets = load_secrets()\n    assert_secrets(secrets)\n\n    if not query:\n        query = \"\"\"\n        I want to do 2 week trip from Berkeley CA to New York City.\n        I want to visit national parks and cities with good food.\n        I want use a rental car and drive for no more than 5 hours on any given day.\n        \"\"\"\n\n    mapper = TravelMapperBase(\n        openai_api_key=secrets[\"OPENAI_API_KEY\"],\n        google_maps_key=secrets[\"GOOGLE_MAPS_API_KEY\"],\n        google_palm_api_key=secrets[\"GOOGLE_PALM_API_KEY\"],\n    )\n\n    mapper.parse(query, make_map=True)\n```"]