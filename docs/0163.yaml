- en: How to Build a Custom Labeler in Python with IPyWidgets and Plotly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/how-to-build-a-custom-labeler-in-python-with-ipywidgets-and-plotly-f6cc1fd7e3cc?source=collection_archive---------21-----------------------#2023-01-10](https://towardsdatascience.com/how-to-build-a-custom-labeler-in-python-with-ipywidgets-and-plotly-f6cc1fd7e3cc?source=collection_archive---------21-----------------------#2023-01-10)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Create a segmentation tool in a Jupyter environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@jacky.kaub?source=post_page-----f6cc1fd7e3cc--------------------------------)[![Jacky
    Kaub](../Images/e66c699ee5a9d5bbd58a1a72d688234a.png)](https://medium.com/@jacky.kaub?source=post_page-----f6cc1fd7e3cc--------------------------------)[](https://towardsdatascience.com/?source=post_page-----f6cc1fd7e3cc--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----f6cc1fd7e3cc--------------------------------)
    [Jacky Kaub](https://medium.com/@jacky.kaub?source=post_page-----f6cc1fd7e3cc--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F7ccb7065ef90&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-to-build-a-custom-labeler-in-python-with-ipywidgets-and-plotly-f6cc1fd7e3cc&user=Jacky+Kaub&userId=7ccb7065ef90&source=post_page-7ccb7065ef90----f6cc1fd7e3cc---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----f6cc1fd7e3cc--------------------------------)
    ·11 min read·Jan 10, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Ff6cc1fd7e3cc&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-to-build-a-custom-labeler-in-python-with-ipywidgets-and-plotly-f6cc1fd7e3cc&user=Jacky+Kaub&userId=7ccb7065ef90&source=-----f6cc1fd7e3cc---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Ff6cc1fd7e3cc&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-to-build-a-custom-labeler-in-python-with-ipywidgets-and-plotly-f6cc1fd7e3cc&source=-----f6cc1fd7e3cc---------------------bookmark_footer-----------)![](../Images/a47b2b2f32879bd5ccc1adbd9766dfb0.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Glomerulli segmented from kidney. Original images provided by the [HuBMAP’s
    tissue mapping center](https://medschool.vanderbilt.edu/biomic/) at Vanderbilt
    University
  prefs: []
  type: TYPE_NORMAL
- en: Did you know that you can turn a simple **Jupyter Notebook** into **a** powerful
    labeler in a few line of codes ?
  prefs: []
  type: TYPE_NORMAL
- en: Turning a simple notebook to a labeling tool can be really time saving at the
    beginning of a project when you are still trying to assess the potential of an
    idea and you don’t want to spend much in building a robust web app.
  prefs: []
  type: TYPE_NORMAL
- en: In this article I will show you how to build a segmentation tool with **plotly**
    and **ipywidget** to generate binary masks out of images in python. In image segmentation,
    binary masks can be used to train deep learning models to efficiently recognize
    and isolate area of interest automatically.
  prefs: []
  type: TYPE_NORMAL
- en: I assume that you are already familiar with the basis of combining ipywidgets
    and plotly. If this is not the case, I strongly recommend having a look first
    at [this article](https://medium.com/@jacky.kaub/build-custom-widgets-with-ipywidgets-and-plotly-a454cb3b2b4f)
    where we go through the basics.
  prefs: []
  type: TYPE_NORMAL
- en: A word about the usecase
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I am using the [HuBMAP dataset](https://www.kaggle.com/competitions/hubmap-kidney-segmentation/data)
    from a Kaggle competition hosted in 2021.
  prefs: []
  type: TYPE_NORMAL
- en: 'I chose this dataset as it illustrates perfectly real life applications: a
    client reach out to you with a bunch of images and asks if you could find a way
    to automatically isolate within those images specific areas of interests. Those
    areas(in this example) are called glomeruli, tiny parts of the kidney that helps
    to filter out waste and extra water from the blood, see the illustration below.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The illustration below shows what your customer is expected here: a model to
    quickly identify those areas of interest.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/075e02aa0858e1ed84f463e96c2de637.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Project objective: providing segmented area of the kidney images. Original
    images provided by the [HuBMAP’s tissue mapping center](https://medschool.vanderbilt.edu/biomic/)
    at Vanderbilt University'
  prefs: []
  type: TYPE_NORMAL
- en: In exploration phases, time is of the essence. Often, we only have access to
    raw data and need to quickly generate labels to train and evaluate a model and
    assess the feasibility of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of spending hours searching for an open-source tool that may still require
    customization, I will guide you through building your own custom tool. You’ll
    see that with a bit of effort, you can easily create any type of widget to aid
    in your daily tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Building the widget technical specifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before jumping directly to the coding part, we need to take a step back and
    think about what we want exactly from our widget. Among the questions we need
    to answer:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the format of the inputs ? Are they jpeg images ? Numpy array ? rasters
    ? etc..
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where are they stored ? Locally ? In multiple area ? Or even in the cloud ?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are you expecting as an output ? Another jpeg images or numpy array ? Maybe
    annotations stored in a json ?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the interactions you are expecting ? Clicking in a button do to something,
    having some UI elements to navigate efficiently from data to data, interacting
    directly with a figure, etc…
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each interaction, how, practically will you manage it ? How this will affect
    the inner state of the widget ?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to draw somewhere, even on paper, the way you want your widget to looks
    like. This will help you structure your widget’s layout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our case:'
  prefs: []
  type: TYPE_NORMAL
- en: I assume that the main images are already divided into 256x256 pixels sub-images
    and stored as .npy files in an imgs/ folder locally.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The generated masks will be stored in the masks/ folder, also as .npy, with
    the same name as the original image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Among the functionalities desired by our tool:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The widget will display two figures: the raw image with a transparent overlay
    of the mask (work ongoing), and the currently saved mask, that will allow a user
    to visualize the current work done and complete it if required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user can click multiple times on the image to generate a polygon defining
    an area. This will be used inside the widget to generate a mask with 0 for pixels
    outside of the area, and 1 for pixels inside.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A button should be used to save the mask when the user is happy with its label,
    so that the result is stored and can be retrieved by him or another service (like
    a deep learning modele)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A button should be used to delete the current polygon, which will be convenient
    to fix drawing mistakes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A button should be used to reset the locally saved mask, allowing to revert
    to the original state if needed without having to delete the mask manually.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user can navigate from image to image via a dropdown menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/b7679ccbba9d3ebc483e098f4ebca07b.png)'
  prefs: []
  type: TYPE_IMG
- en: A rough view of the widget layout that we want to achieve. Original images provided
    by the [HuBMAP’s tissue mapping center](https://medschool.vanderbilt.edu/biomic/)
    at Vanderbilt University
  prefs: []
  type: TYPE_NORMAL
- en: Building the widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some good practices before starting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I recommend you to build your widget within a custom Class. That will facilitate
    your life in term of state management as everything will be held internally, and
    be way easier to package.
  prefs: []
  type: TYPE_NORMAL
- en: Also, as a general advice,you should build the main layout first, and build
    the interactions only in a second phase.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, keep things as much separated as possible ! It does not cost more to
    create a dedicated function for creating each button, or a function to handle
    separately each callback, but it might save you a precious time for testing and
    debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, for building efficiently all kind of widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class to hold all the internal states used in the widget
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build functions to initialize the figures and the components, without interactions
    in a first phase
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the interactions and test them step by step
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep your code clean and organized
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Widget internal state logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our widget needs to keeps in memory and modify several information:'
  prefs: []
  type: TYPE_NORMAL
- en: The _current_id is used to store the current name of the image and is also use
    to access and save the binary mask.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The _polygon_coordinates list will contain the coordinates of the points clicked
    by the user and will be used to generate the binary mask (using a **skimage**
    function)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the _initialize_widget function will generate all the other states used to build
    the layout such as the buttons, figures and intermediate masks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Note: Python does not manage public and private variables, but as a good pep8
    practice, non-public variable and function can be prefixed with “_”.*'
  prefs: []
  type: TYPE_NORMAL
- en: Read the images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to develop a function for reading both the image and its associated
    mask, when it exists.
  prefs: []
  type: TYPE_NORMAL
- en: This function will be called during the initialization of the widget, but also
    every time the user navigate to a new image.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Note: I prefer to package a dedicated function here. I could have put everything
    directly in my __init__, but it would have been much less digest. If you identify
    a task that make sense as a whole, use a function.*'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the graphs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step is to initialize our FigureWidgets.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to display the RGB image using the plotly.express.imshow method
    while we are using plotly.graph_objects.Heatmap for the binary mask.
  prefs: []
  type: TYPE_NORMAL
- en: We are currently giving a focus to the general layout of our widget so we are
    leaving the definitions of the callback for later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Don’t hesitate to spend a bit of time on the formatting, it might looks annoying
    to do, but having a tool of the good size with just the good level of information
    will save you some time when you manipulate it*'
  prefs: []
  type: TYPE_NORMAL
- en: Buttons, Dropdown, and final layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now add functions to integrate the interface components to the widget.
    As precised in the specs, we want 3 buttons (displayed horizontally), a dropdown
    menu, and the two figures next to each other.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: I add a “public” display() method (the only “public” of the widget). It will
    result in showing the initial state of your widget.
  prefs: []
  type: TYPE_NORMAL
- en: Having such a method allow users to directly display the widget without having
    to look for your widget name inside its internal state…
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ad364ac049395129d9098cf7d48bd310.png)'
  prefs: []
  type: TYPE_IMG
- en: Original images provided by the [HuBMAP’s tissue mapping center](https://medschool.vanderbilt.edu/biomic/)
    at Vanderbilt University
  prefs: []
  type: TYPE_NORMAL
- en: Taking care of the interactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our widget fully initialized, we can start to work on the different
    interactions.
  prefs: []
  type: TYPE_NORMAL
- en: The dropdown interaction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The dropdown allows the user to navigate through the different images of the
    dataset. In order to work correctly, the dropdown callback should:'
  prefs: []
  type: TYPE_NORMAL
- en: Read the new image and the new mask
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update both figures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clear the list of points in _polygon_coordinates to start a new polygon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To update the px.imshow() trace, we need to modify its “source” parameter.
  prefs: []
  type: TYPE_NORMAL
- en: To update the go.Heatmap() trace, we modify the “z” parameter of the trace.
  prefs: []
  type: TYPE_NORMAL
- en: '*Note that each trace is usually displaying as an object containing all the
    information of the chart. Don’t hesitate to display it to see what you can modify
    more easily.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We can now navigate through the different images.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f0471ed71b38d443101d39db3807bfee.png)'
  prefs: []
  type: TYPE_IMG
- en: Original images provided by the [HuBMAP’s tissue mapping center](https://medschool.vanderbilt.edu/biomic/)
    at Vanderbilt University
  prefs: []
  type: TYPE_NORMAL
- en: The FigureWidget on_click interaction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clicking on a pixel in the image will store its coordinate in the widget state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having 3 or more pixels stored should trigger a function that will:'
  prefs: []
  type: TYPE_NORMAL
- en: Generate a new mask array with a value of 0 or 2 if the pixel is located within
    or outside the polygon defined by the list of coordinates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an intermediate mask containing both information of the previous mask
    and the mask newly generated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display on the left figure that newly generated mask
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are using skimage.draw to generate efficiently the polygon mask from the
    list of coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: '*Scikit-image is a powerful tool for handling all type of image processing.
    Check* [*their documentation*](https://scikit-image.org/) *to get a grab on the
    possibilities!*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can then update our _initialize_figures method to attach the callback.
  prefs: []
  type: TYPE_NORMAL
- en: '*Note: As the figure is made of several image layers, we attach the callback
    to the top layer.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is it ! We can now visualize the effect of our chart interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/54b58906563ba78c3c1e3c671f2c326c.png)'
  prefs: []
  type: TYPE_IMG
- en: Original images provided by the [HuBMAP’s tissue mapping center](https://medschool.vanderbilt.edu/biomic/)
    at Vanderbilt University
  prefs: []
  type: TYPE_NORMAL
- en: The buttons interactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To finish our app, let’s code the button interactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The “Save Configuration” button. This button save the mask by:'
  prefs: []
  type: TYPE_NORMAL
- en: Copying 0 and 2 pixels from the _intermediate_mask to the _current_mask
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the _current_mask in the /masks folder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refresh the figures
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reset the _polygon_coordinates list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/6a8c1ae8d5c1c0148806595935b6d4a8.png)'
  prefs: []
  type: TYPE_IMG
- en: Original images provided by the [HuBMAP’s tissue mapping center](https://medschool.vanderbilt.edu/biomic/)
    at Vanderbilt University
  prefs: []
  type: TYPE_NORMAL
- en: The “Delete Current Mask” button. This button simply reset the _intermediate_mask
    to the _current_mask value and refresh the figures and the _polygon_coordinates
    list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/f5b07125ecbd2e53123b2cb61545af7c.png)'
  prefs: []
  type: TYPE_IMG
- en: Original images provided by the [HuBMAP’s tissue mapping center](https://medschool.vanderbilt.edu/biomic/)
    at Vanderbilt University
  prefs: []
  type: TYPE_NORMAL
- en: The “Delete All Mask” button. This button simply reset the _intermediate_mask
    to 0 and the _polygon_coordinates to an empty list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/e2d73c91b19af88ef415856921842b00.png)'
  prefs: []
  type: TYPE_IMG
- en: Original images provided by the [HuBMAP’s tissue mapping center](https://medschool.vanderbilt.edu/biomic/)
    at Vanderbilt University
  prefs: []
  type: TYPE_NORMAL
- en: You want to try it out yourself ? The full code is available [here](https://github.com/jkaub/segmentation-widget)!
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a few hours of work we have been able to setup our tool and have now the
    capability to quickly label our images, which will help us answering the original
    request of our client. After preparing the masks of few hundreds of images, we
    could train a preliminary model, and assess if we are willing to mobilize more
    resources to push the project further.
  prefs: []
  type: TYPE_NORMAL
- en: Be creative
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you arrived here, congratulation ! You are now able to generate yourself
    a custom labeling tool directly in your Jupyter Notebook. We explored only one
    of the many use-cases that can be leveraged quickly with plotly and ipywidgets,
    and you have now all the keys to develop your own applications.
  prefs: []
  type: TYPE_NORMAL
