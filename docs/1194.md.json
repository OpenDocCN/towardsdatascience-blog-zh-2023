["```py\n+---------------------+--------+-------+------+\n| Reactant \\ Product  |   D    |   E   |   F  |\n+---------------------+--------+-------+------+\n| A                   |  7/10  |  1/3  |  1/2 |\n| B                   |  1/5   |  2/3  |  1/6 |\n| C                   |  1/10  |  0    |  1/3 |\n+---------------------+--------+-------+------+\n```", "```py\nimport numpy as np\nfrom scipy.optimize import linprog\n```", "```py\n# Pseudo costs\nmargins = np.array([2.15, 1.34, 1.72])\nc = - margins\n\n# Proportions\nA = np.array([\n    [7/10, 1/3, 1/2],\n    [1/5, 2/3, 1/6],\n    [1/10, 0.0, 1/3]\n])\n\n# Availability\nb = np.array([8000.0, 3000.0, 2500.0])\n```", "```py\nsol = linprog(c, A_ub=A, b_ub=b)\nprint(sol)\n```", "```py\nimport pyomo.environ as pyo\n```", "```py\nmodel = pyo.ConcreteModel()\n```", "```py\nmodel.I = pyo.Set(initialize=[\"A\", \"B\", \"C\"])\nmodel.J = pyo.Set(initialize=[\"D\", \"E\", \"F\"])\n```", "```py\n# Availability\nmodel.b = pyo.Param(model.I, initialize=dict(zip(model.I, b)))\n\n# Margins (now as a maximization objective)\nmodel.c = pyo.Param(model.J, initialize=dict(zip(model.J, margins)))\n\n# Proportions\nproportions = {}\nfor k, i in enumerate(model.I):\n    for l, j in enumerate(model.J):\n        proportions[i, j] = A[k, l]\n\nmodel.f = pyo.Param(model.I, model.J, initialize=proportions)\n```", "```py\n# Decision variables\nmodel.x = pyo.Var(model.J, within=pyo.NonNegativeReals)\n\n# Availability constraint\ndef availability_rule_cstr(model, i):\n    return sum(model.f[i, j] * model.x[j] for j in model.J) <= model.b[i]\n\nmodel.cstr_available = pyo.Constraint(model.I, rule=availability_rule_cstr)\n```", "```py\n# Objective function\ndef obj_func(model):\n    return sum(model.x[j] * model.c[j] for j in model.J)\n\nmodel.obj = pyo.Objective(rule=obj_func, sense=pyo.maximize)\n```", "```py\ncbc = pyo.SolverFactory(\"cbc\")\nsol = cbc.solve(model, tee=False)\n```", "```py\n+---+------+------+------+------+\n|   |   A  |    B |    C |    D |\n+---+------+------+------+------+\n| 1 |   10 |    5 |   20 |   12 |\n| 2 |   12 |    7 |   12 |   19 |\n| 3 |    6 |   12 |   16 |   17 |\n+---+------+------+------+------+\n```", "```py\ncosts = pd.DataFrame({\n    \"A\": [10, 12, 6],\n    \"B\": [5, 7, 12],\n    \"C\": [20, 12, 16],\n    \"D\": [12, 19, 17],\n}, index=[1, 2, 3])\n\navailability = {1: 14, 2: 26, 3: 11}\ndemands = {\"A\": 5, \"B\": 15, \"C\": 13, \"D\": 17}\n```", "```py\nmodel = pyo.ConcreteModel()\n```", "```py\nmodel.I = pyo.Set(initialize=[1, 2, 3])\nmodel.J = pyo.Set(initialize=[\"A\", \"B\", \"C\", \"D\"])\n```", "```py\nmodel.b = pyo.Param(model.I, initialize=availability)\n\nmodel.d = pyo.Param(model.J, initialize=demands)\n\nc = {(i, j): costs.loc[i, j] for i in costs.index for j in costs.columns}\nmodel.c = pyo.Param(model.I, model.J, initialize=c)\n```", "```py\nmodel.x = pyo.Var(model.I, model.J, within=pyo.NonNegativeReals)\n```", "```py\ndef availability_rule(model, i):\n    return sum(model.x[i, j] for j in model.J) <= model.b[i]\n\nmodel.availability_constr = pyo.Constraint(model.I, rule=availability_rule)\n\ndef demand_rule(model, j):\n    return sum(model.x[i, j] for i in model.I) == model.d[j]\n\nmodel.demand_constr = pyo.Constraint(model.J, rule=demand_rule)\n```", "```py\nmodel.obj = pyo.Objective(expr=sum(model.x[i, j] * model.c[i, j] for (i, j) in model.x), sense=pyo.minimize)\nsol = cbc.solve(model, tee=False)\n```", "```py\nresults = pd.DataFrame(index=model.I, columns=model.J)\nfor i, j in model.x:\n    results.loc[i, j] = model.x[i, j].value\n```", "```py\n+---+---------+----------+----------+----------+\n|   |    A    |      B   |      C   |      D   |\n+---+---------+----------+----------+----------+\n| 1 |     0.0 |      2.0 |      0.0 |     12.0 |\n| 2 |     0.0 |     13.0 |     13.0 |      0.0 |\n| 3 |     5.0 |      0.0 |      0.0 |      5.0 |\n+---+---------+----------+----------+----------+\n```"]