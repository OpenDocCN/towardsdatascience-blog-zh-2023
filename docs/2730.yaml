- en: A classy approach to solving Traveling Salesman Problems effectively with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://towardsdatascience.com/a-classy-approach-to-solving-traveling-salesman-problems-effectively-dbb44e7d30b9?source=collection_archive---------5-----------------------#2023-08-28](https://towardsdatascience.com/a-classy-approach-to-solving-traveling-salesman-problems-effectively-dbb44e7d30b9?source=collection_archive---------5-----------------------#2023-08-28)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Implementing the TSP model in a scikit-learn-like fashion to ease the building
    and solving of routing optimization models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@carlosjuribe?source=post_page-----dbb44e7d30b9--------------------------------)[![Carlos
    J. Uribe](../Images/902c5f4ac5d404dd99916f145be6756c.png)](https://medium.com/@carlosjuribe?source=post_page-----dbb44e7d30b9--------------------------------)[](https://towardsdatascience.com/?source=post_page-----dbb44e7d30b9--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----dbb44e7d30b9--------------------------------)
    [Carlos J. Uribe](https://medium.com/@carlosjuribe?source=post_page-----dbb44e7d30b9--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ¬∑
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F4337eddb94ed&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fa-classy-approach-to-solving-traveling-salesman-problems-effectively-dbb44e7d30b9&user=Carlos+J.+Uribe&userId=4337eddb94ed&source=post_page-4337eddb94ed----dbb44e7d30b9---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----dbb44e7d30b9--------------------------------)
    ¬∑27 min read¬∑Aug 28, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fdbb44e7d30b9&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fa-classy-approach-to-solving-traveling-salesman-problems-effectively-dbb44e7d30b9&user=Carlos+J.+Uribe&userId=4337eddb94ed&source=-----dbb44e7d30b9---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fdbb44e7d30b9&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fa-classy-approach-to-solving-traveling-salesman-problems-effectively-dbb44e7d30b9&source=-----dbb44e7d30b9---------------------bookmark_footer-----------)![](../Images/44dbc85e4fab1ee01aca3f8d40880deb.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Image generated by DALL¬∑E 3 with author‚Äôs prompt: ‚Äúa series of optimal routes
    traversing the planet with Python code in the background‚Äù'
  prefs: []
  type: TYPE_NORMAL
- en: 'üëÅÔ∏è **This is article #5 of the series** **covering the project ‚Äú**[**An Intelligent
    Decision Support System for Tourism in Python**](https://medium.com/@carlosjuribe/list/an-intelligent-decision-support-system-for-tourism-in-python-b6ba165b4236)**‚Äù.**
    I encourage you to check it out to get a general overview of the whole project.
    If you‚Äôre only interested in solving TSPs, this article is still for you, as I
    show an approach that makes it incredibly simple to solve any TSP. **The article
    does build upon the previous ones, but reading them is optional**; do so if you‚Äôd
    like to know the ‚Äúhow‚Äù, or skip them if you want to have something working as
    soon as possible.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Table of contents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[1\. Previous sprints recap](#9b5c)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[2\. Read data for the sites to be visited](#fa87)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[3\. The basic architecture](#336e)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[3.1\. The Optimizer class diagram](#7b91)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[3.2\.](#eefc) `[**GeoAnalyzer**](#eefc)`[, revisited](#eefc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[3.3\. Laying the *bases*: a base class for optimization utilities](#43ef)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[4\. One class to route them all: the](#c043) `[TravelingSalesmanOptimizer](#c043)`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[4.1\.](#127d) `[**TravelingSalesmanOptimizer**](#127d)` [design](#127d)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[4.2\.](#419d) `[**TravelingSalesmanOptimizer**](#419d)` [implementation](#419d)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[4.3\.](#9ab8) `[**TravelingSalesmanOptimizer**](#9ab8)` [for dummies](#9ab8)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[5\. Beyond the optimal solution: extracting insights with the optimizer](#754e)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[6\. Conclusion (or planning for next sprint)](#c3ec)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 1\. Previous sprints recap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [sprint 1](https://medium.com/@carlosjuribe/plan-an-optimal-trip-for-your-next-holidays-with-the-help-of-operations-research-and-python-481b1ea38fef)
    we reasoned our way through a ubiquitous tourism planning problem and concluded
    that its **minimum valuable problem** took the form of the [**Traveling Salesman
    Problem** (TSP)](https://en.wikipedia.org/wiki/Travelling_salesman_problem). That
    is why we dedicated [sprint 2](https://medium.com/@carlosjuribe/modeling-the-traveling-salesman-problem-from-first-principles-bd6530c9c07)
    and [sprint 3](https://medium.com/@carlosjuribe/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c)
    to develop a mathematical model, and a computer model, respectively, of the TSP.
    However, the goal then was only to **demonstrate the viability** of using optimization
    modeling to solve such a problem. Once this proof-of-concept was deemed viable,
    the new goal was to upgrade it, to refine it into a **Minimum Viable Product**
    (MVP) that could be used to **solve this *kind* of problems systematically, and
    in a more general fashion**. We noticed that, as a prerequisite, we needed a way
    of **obtaining distance data** from arbitrary locations. We tackled this issue
    in [sprint 4](https://medium.com/@carlosjuribe/compute-the-distance-matrix-of-a-set-of-sites-from-their-coordinates-in-python-d5fc92a0ba9e),
    where we built the `GeoAnalyzer` class to compute the distance matrix for any
    set of locations given only their coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'All those iterative advancements take us here, to sprint 5, where we finally
    hit a major milestone: the creation of **an estimator-like class that solves *general*
    TSPs, quickly and intuitively**. We will accomplish this by integrating what we‚Äôve
    built so far in an extensible fashion, thereby paving the way for future enhancements
    that will extend the capabilities of our model far beyond the TSP, something we
    must do if our system is to solve realistic tourism problems. That said, **the
    Traveling Salesman Problem** ‚Äî arguably the most famous transportation problem
    in all Operations Research ‚Äî **is in a class of its own, so in this article, we‚Äôll
    give it a *class* of its own**. This class will hide away all the low-level modeling
    and solution parsing details, thereby enabling the **seamless solution of any
    TSP problem with just a method call**. If you feel this article lacks enough context
    or makes big jumps, please read the prep work to learn [how to implement a model
    for the TSP in Pyomo](/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c),'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c?source=post_page-----dbb44e7d30b9--------------------------------)
    [## Implementing, solving and visualizing the Traveling Salesman Problem with
    Python'
  prefs: []
  type: TYPE_NORMAL
- en: Learn how to translate an optimization model from Math to Python, optimize it,
    and visualize the solution to gain quick‚Ä¶
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c?source=post_page-----dbb44e7d30b9--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: and [how to find distances between locations in an automatic manner](/compute-the-distance-matrix-of-a-set-of-sites-from-their-coordinates-in-python-d5fc92a0ba9e),
  prefs: []
  type: TYPE_NORMAL
- en: '[](/compute-the-distance-matrix-of-a-set-of-sites-from-their-coordinates-in-python-d5fc92a0ba9e?source=post_page-----dbb44e7d30b9--------------------------------)
    [## Compute the Distance Matrix of a Set of Sites from Their Coordinates in Python'
  prefs: []
  type: TYPE_NORMAL
- en: Estimate the distance between any pair of sites from their geographical coordinates
    as a stepping stone to solving‚Ä¶
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/compute-the-distance-matrix-of-a-set-of-sites-from-their-coordinates-in-python-d5fc92a0ba9e?source=post_page-----dbb44e7d30b9--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: and you will understand, in more depth, where the ideas and code we‚Äôll discuss
    here come from. If you‚Äôre already versed on the TSP, jump right in!
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Read data for the sites to be visited
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The basic input for the generic TSP is the locations we want to visit. In our
    example, we have a list of sites of interest in Paris, including our hotel. Let‚Äôs
    read them into a dataframe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/a8ac65de957710474d2d97505db2075b.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1.** Input coordinates for the optimizer (Image by author)'
  prefs: []
  type: TYPE_NORMAL
- en: 3\. The basic architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start coding, it‚Äôs important to have a high-level understanding, and
    thus a design, of what we are about to do and why. Our goal is the creation of
    a class that **takes in some geographical coordinates of some sites, and solves
    the TSP problem for them, *i.e.*, outputs the order in which we ought to visit
    those sites** to minimize the total distance traveled. We won‚Äôt create just one
    class that does everything; we will keep different functionalities in different
    classes, and then combine them together[¬π](#0558).
  prefs: []
  type: TYPE_NORMAL
- en: 3.1\. The Optimizer class diagram
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I believe it is convenient for our class to have a scikit-learn-ish API. However,
    I won‚Äôt refer to our new class as an ‚Äú*estimator*‚Äù, but rather, as an ‚Äú*optimizer*‚Äù[¬≤](#4124).
    A self-explanatory name is `TravelingSalesmanOptimizer`. One of its helper attributes
    will be the `GeoAnalyzer` class built in [sprint 4](https://medium.com/@carlosjuribe/compute-the-distance-matrix-of-a-set-of-sites-from-their-coordinates-in-python-d5fc92a0ba9e).
    Also, as this won't be the only optimizer class we'll end up creating in this
    project, we will store all the functionality related to the solving of models
    inside a separate class, `BaseOptimizer`. The reason is that all optimizers, no
    matter what internal model they implement, will need to optimize it, so it's best
    to keep the logic related to the optimization itself in a separate class, a base
    class which all optimizers will inherit from.
  prefs: []
  type: TYPE_NORMAL
- en: In the class diagram below, we can see how the three classes fit together. Inside
    each, I have included their **main attributes and methods** (but not all) for
    us to get the idea.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e8c714186abc4b21a798483e156f5f3a.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 2.** Class diagram for the TSP Optimizer (Image by author)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here‚Äôs the main purpose of each class, in a nutshell:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BaseOptimizer` is responsible for the optimization of the models of "proper"
    optimizer subclasses, it''s not intended to be instantiated on its own.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GeoAnalyzer` is a self-contained class of geo-utilities. It aids in the crucial
    step of computing a distance matrix from user-given coordinates, needed to construct
    a model if the user doesn''t have custom distance data at hand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TravelingSalesmanOptimizer` is an optimizer that can be fitted to a dataframe
    having the coordinates of the sites. Once fitted, the "visit order" of those sites
    can be retrieved. Internally, it implements a [mathematical model](https://medium.com/@carlosjuribe/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c)
    of the Traveling Salesman Problem as a [Pyomo model](https://pyomo.readthedocs.io/en/stable/pyomo_overview/simple_examples.html)
    object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With a concrete design in mind, let‚Äôs assemble it.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2\. `GeoAnalyzer`, revisited
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the code for `GeoAnalyzer` was already developed in the previous sprint,
    here we just move it to a new module, `geoutils.py`, and import the class from
    there. If you haven''t read [the article in which it was created](https://medium.com/@carlosjuribe/compute-the-distance-matrix-of-a-set-of-sites-from-their-coordinates-in-python-d5fc92a0ba9e),
    don''t worry, all you need to know is that it takes in some dataframe of coordinates
    and outputs a distance matrix, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/4f12661ff8fbe9db8e0db9e08440b218.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.** Distance matrix generated by GeoAnalyzer (Image by author)'
  prefs: []
  type: TYPE_NORMAL
- en: This dataframe of distances is what we‚Äôll use inside `TravelingSalesmanOptimizer`
    to create an internal model, as the real data that is needed to model a Traveling
    Salesman problem is distances, not coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: '3.3\. Laying the bases: a base class for optimization utilities'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the [article for sprint 3](http://localhost:8888/lab/workspaces/auto-c/tree/Projects/TWDS/traveling_tourist_problem/TTPOptimizer_part3.ipynb#https://medium.com/@carlosjuribe/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c),
    the very first code snippet is about instantiating a Pyomo solver and printing
    its version. A bit further below, in [section 2.1](https://medium.com/@carlosjuribe/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c#:~:text=validating%20the%20model-,2.1.%20Solving%20the%20model,-The%20next%20step),
    we used this solver to optimize the model. With that in mind, creating `BaseOptimizer`
    is only a matter of putting these pieces together into a class. We will modify
    the original code slightly so that it becomes easier to read, but essentially
    it's the same thing wrapped conveniently.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The main things to keep in mind about this class are:'
  prefs: []
  type: TYPE_NORMAL
- en: At instantiation, the solver is set up internally by `_setup_solver`. As we
    can't solve any model without a solver, if the setup fails, an exception will
    be raised. If the solver is found, it's kept as a private attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The method `_optimize` will be invoked whenever a subclass to `BaseOptimizer`
    calls a `fit`-like method. `_optimize` takes in a model and **attempts** to solve
    it, using the internal solver. If an optimal solution *exists*, the attribute
    `_solution_exists` will cease to be `None` and will take the value `True`. If
    *no optimal solution exists*[*¬≥*](#f7e6), it will take the value `False`, and
    a warning is printed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The remaining methods are explained in their docstrings. Now, time to build
    our first optimizer.
  prefs: []
  type: TYPE_NORMAL
- en: '4\. One class to route them all: the `TravelingSalesmanOptimizer`'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here we won‚Äôt start from scratch. As stated earlier, we already developed the
    code that builds a Pyomo model of the TSP and solves it in [sprint 3](http://localhost:8888/lab/workspaces/auto-c/tree/Projects/TWDS/traveling_tourist_problem/TTPOptimizer_part3.ipynb#https://medium.com/@carlosjuribe/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c).
    And trust me, that was the hardest part. Now, we have the easier task of organizing
    what we did in a way that makes it general, hiding the details while keeping the
    *essential* elements visible. In a sense, we want the optimizer to look like a
    ‚Äúmagic box‚Äù that even users not familiar with math modeling are able to use to
    solve their TSP problems intuitively.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1\. `TravelingSalesmanOptimizer` design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our optimizer class will have ‚Äúcore‚Äù methods, doing the bulk of the work, and
    ‚Äúsuperficial‚Äù methods, serving as the high-level interface of the class, which
    invoke the core methods underneath.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the steps that will lie at the core of the optimizer‚Äôs logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create a Pyomo model** out of a distance matrix. This is done by the `_create_model`
    method, which basically wraps [the code of the proof-of-concept](/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c#:~:text=start%20coding%20along!-,1.2.%20Math%20becomes%20code,First%2C%20let%E2%80%99s%20make%20sure%20the%20GLPK%20solver%20is%20findable%20by%20Pyomo,-%23%23%23%20%3D%3D%3D%3D%3D%20%20Code%20block%203.1)
    we already did. It accepts a dataframe of a distance matrix and builds a Pyomo
    model out of it. The only important difference between what we did and what we''re
    doing is that, now, the initial site is not hard-coded as simply `"hotel"`, but
    is *assumed* to be the site of the first row in `df_distances`. In the general
    case, thus, **the initial site is taken to be the first one in the coordinates
    dataframe**[‚Å¥](#8dd4) `df_sites`. This generalization allows the optimizer to
    solve any instance.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**(Attempt to) Solve the model**. This is performed in the `_optimize` method
    inherited from `BaseOptimizer`, which returns `True` only if a solution is found.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Extract the solution from the model and parse it** in a way that is easy
    to interpret and use. This happens inside `_store_solution_from_model`, which
    is a method that inspects the solved model and extracts the values of the decision
    variables, and the value of the objective function, to *create* the attributes
    `tour_` and `tour_distance_`, respectively. This method *gets invoked* ***only
    if*** *a solution exists*, so if no solution is found, the "solution attributes"
    `tour_` and `tour_distance_` never get created. The benefit of this is that the
    presence of these two "solution attributes", after fitting, will inform the user
    of the existence of a solution. As a plus, the optimal values of both the variables
    and objective can be conveniently retrieved at any point, not necessarily at the
    moment of fitting.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last 2 steps ‚Äî finding and extracting the solution ‚Äî are wrapped inside
    the last ‚Äúcore‚Äù method, `_fit_to_distances`.
  prefs: []
  type: TYPE_NORMAL
- en: ‚ÄúBut wait‚Äù ‚Äî you might think ‚Äî ‚ÄúAs the name implies, `_fit_to_distances` requires
    distances as input; isn't our goal to solve TSP problems using only *coordinates*,
    not *distances*?". Yes, that's where the `fit` method *fits* in. We pass *coordinates*
    to it, and we take advantage of `GeoAnalyzer` to construct the distance matrix,
    which is then processed normally by `_fit_to_distances`. In this way, if the user
    does not want to collect the distances himself, he can delegate the task by using
    `fit`. If, however, he prefers to use custom data, he can assemble it in a `df_distances`
    and pass it to `_fit_to_distances` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2\. `TravelingSalesmanOptimizer` implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let‚Äôs follow the design outlined above to incrementally build the optimizer.
    First, a minimalist version that just builds a model and solves it ‚Äî without any
    solution parsing yet. Notice how the `__repr__` method allows us to know the name
    and number of sites the optimizer contains whenever we print it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let‚Äôs quickly check how the optimizer behaves. Upon instantiation, the optimizer
    does not contain any number of sites, as the representation string shows, or an
    internal model, and it‚Äôs of course not fitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We now fit it to the distance data, and if we don‚Äôt get a warning, it means
    that it all went well. We can see that now the representation string tells us
    we provided 9 sites, there‚Äôs an internal model, and that the optimizer was fitted
    to the distance data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'That the optimal solution was found is corroborated by the presence of definite
    values in the rank decision variables of the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: These rank variables represent the chronological order of the stops in the optimal
    tour. If you recall from [their definition](/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c#:~:text=rank%20variables%2C%20r%E1%B5%A2%3A%20to%20keep%20track%20of%20the%20order%20in%20which%20sites%20are%20visited%3A),
    they are defined over all sites except the initial one[‚Åµ](#f9a3), and that‚Äôs why
    the hotel does not appear in them. Easy, we could add the hotel with rank 0, and
    there we would have **the answer to our problem**. We don‚Äôt need to extract ùõø·µ¢‚±º,
    the decision variables for the *individual* arcs of the tour, to know in which
    order we should visit the sites. Although that‚Äôs true, we‚Äôre still going to use
    the arc variables ùõø·µ¢‚±º to extract the exact sequence of stops from the solved model.
  prefs: []
  type: TYPE_NORMAL
- en: '*üí°* **Agile *doesn‚Äôt need to be* fragile**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If our only aim were to solve the TSP, without looking to* extend *the model
    to encompass more details of our real-life problem, it would be enough to use
    the rank variables to extract the optimal tour. However, as the TSP is just* ***the
    initial prototype of what will become a more sophisticated model****, we‚Äôre better
    off extracting the solution from the arc decision variables ùõø·µ¢‚±º, as they will
    be present in any model that involves routing decisions. All other decision variables
    are auxiliary, and, when needed, their job is to represent states or indicate
    conditions dependant on the* true *decision variables, ùõø·µ¢‚±º. As you‚Äôll see in the
    next articles, choosing the rank variables to extract the tour works for a pure
    TSP model, but won‚Äôt work for extensions of it that make it* optional *to visit
    some sites. Hence, if we extract the solution from ùõø·µ¢‚±º,* ***our approach will
    be general and re-usable, no matter how complex the model we‚Äôre using****.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The benefits of this approach will become apparent in the following articles,
    where new requirements are added, and thus additional variables are needed inside
    the model. With the *why* covered, let‚Äôs jump into the *how*.
  prefs: []
  type: TYPE_NORMAL
- en: '**4.2.1 Extracting the optimal tour from the model**'
  prefs: []
  type: TYPE_NORMAL
- en: '**We have** the variable ùõø·µ¢‚±º, indexed by possible arcs (i, j), where ùõø·µ¢‚±º=0
    means the arc is not selected and ùõø·µ¢‚±º=1 means the arc is selected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**We want** a dataframe where the sites are in the index (as in our input `df_sites`),
    and where the stop number is indicated in the column `"visit_order"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**We write** a method to extract such dataframe from the fitted optimizer.
    These are the steps we‚Äôll follow, with each step encapsulated in its own helper
    method(s):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extract the selected arcs from ùõø·µ¢‚±º, which represents the tour. Done in `_get_selected_arcs_from_model`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the list of arcs (edges) into a list of stops (nodes). Done in `_get_stops_order_list`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the list of stops into a dataframe with a consistent structure. Done
    in `_get_tour_stops_dataframe`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As the selected arcs are mixed (*i.e.*, not in ‚Äútraversing order‚Äù), getting
    a list of ordered stops is not that straight-forward. To avoid convoluted code,
    we exploit the fact that the arcs represent a *graph*, and we use the graph object
    `G_tour` to traverse the tour nodes in order, arriving at the list easily.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let‚Äôs see what this new method gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/dc75bd513f652b2d63c68f741e8680e4.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 4**. Solution (optimal tour) as ranked sites (Image by Author)'
  prefs: []
  type: TYPE_NORMAL
- en: The `visit_order` column indicates we should go from the hotel to Notre Dame,
    then to the Louvre, and so on, until the last stop before closing the tour, Sacre
    Coeur. After that, it's trivial that one must return to the hotel. Good, now we
    have the solution in a format easy to interpret and work with. But the sequence
    of stops is not all we care about. **The value of the objective function is also
    an important metric to keep track of**, as it's the criterion guiding our decisions.
    For our particular case of the TSP, this means getting the total distance of the
    optimal tour.
  prefs: []
  type: TYPE_NORMAL
- en: '**4.2.2 Extracting the optimal objective from the model**'
  prefs: []
  type: TYPE_NORMAL
- en: In the same manner that we didn‚Äôt use the rank variables to extract the sequence
    of stops because in more complex models their values wouldn‚Äôt coincide with the
    tour stops, we won‚Äôt use the objective function *directly* to obtain the total
    distance of the tour, even though, here too, both measures are equivalent. **In
    more complex models, the objective function will also incorporate other targets**,
    so this equivalence will no longer hold.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we‚Äôll keep it simple and create a non-public method, `_get_tour_total_distance`,
    which clearly indicates the intent. The details of where this distance comes from
    are hidden, and will depend on the particular targets that more advanced models
    care about. For now, the details are simple: get the objective value of the solved
    model.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It may look superfluous now, but it‚Äôll serve as a reminder to our future selves
    that there is a design for grabbing objective values we‚Äôd better follow. Let‚Äôs
    check it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It‚Äôs around 14.9 km. As both the optimal tour and its distance are important,
    let‚Äôs make the optimizer store them together whenever the `_fit_to_distances`
    method gets called, **and only when an optimal solution is found**.
  prefs: []
  type: TYPE_NORMAL
- en: '**4.2.3 Storing the solution in attributes**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the implementation of `_fit_to_distances` above, we just created a model
    and solved it, we didn''t do any parsing of the solution stored inside the model.
    Now, we''ll modify `_fit_to_distances` so that **when the model solution succeeds,
    two new attributes are created and made available** with the two relevant parts
    of the solution: the `tour_` and the `tour_distance_`. To make it simple, the
    `tour_` attribute won''t return the dataframe we did earlier, it will return the
    list with ordered stops. The new method `_store_solution_from_model` takes care
    of this.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let‚Äôs fit the optimizer again to the distance data and see how easy it is to
    get the solution now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Nice. But we can do even better. To further **increase the usability of this
    class**, let‚Äôs allow the user to solve the problem by only providing the dataframe
    of sites coordinates. As not everyone will be able to collect a distance matrix
    for their sites of interest, the class can take care of it and provide an approximate
    distance matrix. This was done above in section 3.2 with the `GeoAnalyzer`, here
    we just put it under the new `fit` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And now we have achieved our goal: **find the optimal tour from just the sites
    locations** (and not from the distances as before):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 4.3\. `TravelingSalesmanOptimizer` for dummies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Congratulations! We reached the point where the optimizer is very intuitive
    to use. For mere convenience, I‚Äôll add another method that will be quite helpful
    later on when we do [sensitivity analysis] and compare the results of different
    models. The optimizer, as it is now, tells me the optimal visit order in a list,
    or in a separate dataframe returned by `get_tour_stops_dataframe()`, but I''d
    like it to tell me **the visit order by *transforming* the locations dataframe**
    that I give it directly‚Äîby returning the same dataframe with a new column having
    the optimal sequence of stops. The method `fit_prescribe` will be in charge of
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can solve any TSP in just **one line**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/5d2606e413b5c613d32d084a580c17d1.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6**. Solution (optimal tour) appended to dataframe of sites (Image
    by Author)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we‚Äôd like to conserve the original order of locations as they were in `df_sites`,
    we can do it by specifying `sort=False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/fba80c8ddb8a99700fb200517675ec64.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7**. Solution appended to dataframe of sites, sites order preserved
    (Image by Author)'
  prefs: []
  type: TYPE_NORMAL
- en: And if we‚Äôre curious we can also check the number of variables and constraints
    the internal model needed to solve our particular instance of the TSP. This will
    be handy when doing debugging or performance analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '5\. Beyond the optimal solution: extracting insights with the optimizer'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we close this article, I would like to show you some brief examples of
    how easy it is to use this class, **not just to solve TSP problems, but to also
    answer general questions that usually arise when planning a trip**.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose you have already come up with a list of sites to visit
    in one day of your trip to Paris, and you have them in a dataframe called `df_sites`.
    You''d like to know *only* the total length of the optimal tour to traverse them
    all. You don''t have to go to *great lengths* to know that; this one-liner has
    you covered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now suppose you‚Äôre not very sure of your set of sites, and are thinking of
    trimming it down a little. You are pondering over skipping the visit to *Arc de
    Triomphe*, as it is far from the hotel. **You may wonder: ‚ÄúHow much does the optimal
    tour change if I don‚Äôt go to this site?‚Äù**. Thanks to the optimizer, getting the
    answer is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With this, you know that you would save around 768 m of walking if you skipped
    *Arc de Triomphe*. It‚Äôs up to you to decide whether that‚Äôs worth it or not.
  prefs: []
  type: TYPE_NORMAL
- en: '**It‚Äôs not just about optimal routes: we can find ‚Äúoptimal‚Äù hotels too!**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As another practical example, imagine that you have settled with a list of
    sites to visit, but haven‚Äôt picked a hotel yet. You have several options, and
    in order to decide better, **you would like to know how each choice of hotel impacts
    the total distance of the tour you‚Äôll make**. Then it‚Äôs just a matter of **fitting
    another optimizer** with a sites dataframe containing the new candidate hotel,
    **and comparing the optimal distance with the optimal distance of using the initial
    hotel**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The conclusion is that **if we choose ‚Äúhotel 2‚Äù, we will have to *walk 2.8 km
    more* than if we chose ‚Äúhotel 1‚Äù**, on a tour traversing the same set of sites.
    All other things being equal, this informs us that ‚Äúhotel 1‚Äù is a better choice
    than ‚Äúhotel 2‚Äù (*given* the sites we want to visit).
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Conclusion (or planning for next sprint)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this article, we have created two new classes (`BaseOptimizer` and `TravelingSalesmanOptimizer`).
    In future sprints, we'll be using them, extending them, and adding more advanced
    optimizers to the toolkit, so to do things cleanly, let's move them to a new module,
    `routimizers.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, one final thing to keep in mind is the scope of this MVP. This first optimizer
    gives us the answer to the question ‚Äúin which **order** should I visit the sites?‚Äù,
    but it doesn‚Äôt tell us *how to go* from one site to the next. That is fine, as
    that‚Äôs the job of GIS applications like Google Maps, not of our humble optimizer.
  prefs: []
  type: TYPE_NORMAL
- en: '***üëÅ*** *Our optimizer solves the* ***tactical*** *problem of telling us the
    optimal* sequence of stops *on a tour, not the* ***operational*** *problem of
    guiding us along that tour. The latter problem is easily solvable by many great
    GIS applications, like Google Maps.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you‚Äôre happy with the result (the tour), and you‚Äôd like to actually implement
    it in *real life*, it‚Äôs easy: go straight to Google Maps and introduce these sites
    as stops in the *order specified by the optimizer*. Hit ‚Äúgo‚Äù and there you have
    your *operational* answer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Nevertheless, it still feels like one should be able to *visualize* the results,
    not just be content with the numbers that the optimizer puts in a new column;
    if not for the implementation in real life, at least for a better understanding
    of the solutions. In sprint 3 we did [visualize the solution a bit](https://medium.com/@carlosjuribe/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c#:~:text=valuable%20final%20check.-,4.2.%20Plotting%20the%20augmented%20model%E2%80%99s%20solution,-Let%E2%80%99s%20solve%20the),
    even without having the coordinates. Now that we *do have* the coordinates of
    the sites, we can do much better and visualize the resulting optimal tours in
    a more realistic fashion. That is precisely the goal of [our next sprint](/visualizing-routes-on-interactive-maps-with-python-part-1-44f8d25d0761):
    **to create nice visuals that enable us to better understand the solutions** (tours)
    **provided by the optimizer**, and, in the process, ask and answer more and better
    questions that allow us to plan better trips. Grab a cup of coffee, and jump right
    in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/visualizing-routes-on-interactive-maps-with-python-part-1-44f8d25d0761?source=post_page-----dbb44e7d30b9--------------------------------)
    [## Visualizing Routes on Interactive Maps with Python: Part 1'
  prefs: []
  type: TYPE_NORMAL
- en: A pragmatic guide to interactive data visualization for transportation problems
    with Folium
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/visualizing-routes-on-interactive-maps-with-python-part-1-44f8d25d0761?source=post_page-----dbb44e7d30b9--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: '*Footnotes*'
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of this separation will become apparent in future sprints for problems
    that extend the TSP. [‚Ü©](#7894)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Because our class will optimize decisions, not estimate parameters. There‚Äôs
    a subtle difference. Granted, `scikit-learn` estimators do carry out an optimization
    under the hood during model training, but the distinction still matters because
    **optimization means different things in Machine Learning and in Operations Research**.
    An *estimator* uses optimization to ***estimate*** the unknown values of the *model
    parameters*, while an *optimizer* uses optimization to ***find*** the optimum
    values of the variables representing *decisions* we need to make. Inside estimators,
    the objective function is always a *loss function,* which measures **the extent
    to which a *predicted* outcome differs from a *true* outcome**. In optimizers
    (or more generally, in OR models) **the objective function** can be arbitrary,
    as it i**s a measure of *our* desired global state of the world**,dependent on
    our decisions. In other words: *in Machine Learning, we seek the* ***optimal model
    parameters*** *that produce the* ***best generalization*** *of the data* we have.
    *In Operations Research*, however, our possible actions are represented in the
    models, so *we seek the* ***optimal actions*** *that will produce the* ***best
    outcome*** *given the resources we have.* The key distinction is that there''s
    no such thing as "true decisions" that need to be "estimated from data" through
    optimization techniques. **Decisions are prescribed *given* the data, not estimated
    *from* the data**. [‚Ü©](#c61f)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This can happen only due to [two reasons](https://en.wikipedia.org/wiki/Linear_programming#:~:text=An%20optimal%20solution%20need,of%20the%20objective%20function.):
    the model is *infeasible* (the most common), or the model is *unbounded* (less
    common, but possible). [‚Ü©](#97f0)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That‚Äôs why, when reading the input coordinates into a dataframe, we read the
    coordinates of the hotel first. [‚Ü©](#d459)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is a [technical requirement](https://medium.com/@carlosjuribe/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c#:~:text=It%E2%80%99s%20crucial%20that,variable%3A%20the%20hotel)
    that *exactly* one of the sites does not have an associated rank variable (it
    doesn‚Äôt matter which, but generally the ‚Äúinitial site‚Äù is picked). As the hotel
    was in the index of the first row of `df_distances`, it was considered the initial
    site and stored inside the Pyomo model (see attribute `tsp.model.initial_site`)
    without an associated rank variable. Remember that the job of the ranks r·µ¢ is
    *not* to indicate the order of visits (that's inherent in ùõø·µ¢‚±º), but only to prevent
    the formation of subtours. [‚Ü©](#7f87)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thanks for reading, and see you in [the next one](/visualizing-routes-on-interactive-maps-with-python-part-1-44f8d25d0761)!
    üìàüòä
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to follow me, ask me questions, **give me feedback**, or contact me
    on [LinkedIn](https://www.linkedin.com/in/carlosjuribe/).
  prefs: []
  type: TYPE_NORMAL
