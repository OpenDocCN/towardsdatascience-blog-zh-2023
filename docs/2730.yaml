- en: A classy approach to solving Traveling Salesman Problems effectively with Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一种优雅的方式来有效解决旅行推销员问题
- en: 原文：[https://towardsdatascience.com/a-classy-approach-to-solving-traveling-salesman-problems-effectively-dbb44e7d30b9?source=collection_archive---------5-----------------------#2023-08-28](https://towardsdatascience.com/a-classy-approach-to-solving-traveling-salesman-problems-effectively-dbb44e7d30b9?source=collection_archive---------5-----------------------#2023-08-28)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/a-classy-approach-to-solving-traveling-salesman-problems-effectively-dbb44e7d30b9?source=collection_archive---------5-----------------------#2023-08-28](https://towardsdatascience.com/a-classy-approach-to-solving-traveling-salesman-problems-effectively-dbb44e7d30b9?source=collection_archive---------5-----------------------#2023-08-28)
- en: Implementing the TSP model in a scikit-learn-like fashion to ease the building
    and solving of routing optimization models
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以类似 scikit-learn 的方式实现 TSP 模型，简化路线优化模型的构建和求解
- en: '[](https://medium.com/@carlosjuribe?source=post_page-----dbb44e7d30b9--------------------------------)[![Carlos
    J. Uribe](../Images/902c5f4ac5d404dd99916f145be6756c.png)](https://medium.com/@carlosjuribe?source=post_page-----dbb44e7d30b9--------------------------------)[](https://towardsdatascience.com/?source=post_page-----dbb44e7d30b9--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----dbb44e7d30b9--------------------------------)
    [Carlos J. Uribe](https://medium.com/@carlosjuribe?source=post_page-----dbb44e7d30b9--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@carlosjuribe?source=post_page-----dbb44e7d30b9--------------------------------)[![Carlos
    J. Uribe](../Images/902c5f4ac5d404dd99916f145be6756c.png)](https://medium.com/@carlosjuribe?source=post_page-----dbb44e7d30b9--------------------------------)[](https://towardsdatascience.com/?source=post_page-----dbb44e7d30b9--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----dbb44e7d30b9--------------------------------)
    [Carlos J. Uribe](https://medium.com/@carlosjuribe?source=post_page-----dbb44e7d30b9--------------------------------)'
- en: ·
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F4337eddb94ed&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fa-classy-approach-to-solving-traveling-salesman-problems-effectively-dbb44e7d30b9&user=Carlos+J.+Uribe&userId=4337eddb94ed&source=post_page-4337eddb94ed----dbb44e7d30b9---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----dbb44e7d30b9--------------------------------)
    ·27 min read·Aug 28, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fdbb44e7d30b9&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fa-classy-approach-to-solving-traveling-salesman-problems-effectively-dbb44e7d30b9&user=Carlos+J.+Uribe&userId=4337eddb94ed&source=-----dbb44e7d30b9---------------------clap_footer-----------)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[关注](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F4337eddb94ed&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fa-classy-approach-to-solving-traveling-salesman-problems-effectively-dbb44e7d30b9&user=Carlos+J.+Uribe&userId=4337eddb94ed&source=post_page-4337eddb94ed----dbb44e7d30b9---------------------post_header-----------)
    发表在 [Towards Data Science](https://towardsdatascience.com/?source=post_page-----dbb44e7d30b9--------------------------------)
    ·27分钟阅读·2023年8月28日'
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fdbb44e7d30b9&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fa-classy-approach-to-solving-traveling-salesman-problems-effectively-dbb44e7d30b9&source=-----dbb44e7d30b9---------------------bookmark_footer-----------)![](../Images/44dbc85e4fab1ee01aca3f8d40880deb.png)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fdbb44e7d30b9&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fa-classy-approach-to-solving-traveling-salesman-problems-effectively-dbb44e7d30b9&source=-----dbb44e7d30b9---------------------bookmark_footer-----------)![](../Images/44dbc85e4fab1ee01aca3f8d40880deb.png)'
- en: 'Image generated by DALL·E 3 with author’s prompt: “a series of optimal routes
    traversing the planet with Python code in the background”'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由 DALL·E 3 根据作者的提示生成：“一系列优化路线穿越地球，背景中有 Python 代码”
- en: '👁️ **This is article #5 of the series** **covering the project “**[**An Intelligent
    Decision Support System for Tourism in Python**](https://medium.com/@carlosjuribe/list/an-intelligent-decision-support-system-for-tourism-in-python-b6ba165b4236)**”.**
    I encourage you to check it out to get a general overview of the whole project.
    If you’re only interested in solving TSPs, this article is still for you, as I
    show an approach that makes it incredibly simple to solve any TSP. **The article
    does build upon the previous ones, but reading them is optional**; do so if you’d
    like to know the “how”, or skip them if you want to have something working as
    soon as possible.'
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '👁️ **这是系列文章的第 #5 篇** **涵盖了项目“**[**Python中的智能旅游决策支持系统**](https://medium.com/@carlosjuribe/list/an-intelligent-decision-support-system-for-tourism-in-python-b6ba165b4236)**”**。我鼓励你查看它，以获得整个项目的一般概述。如果你只是对解决TSP感兴趣，这篇文章也适合你，因为我展示了一种方法，使解决任何TSP变得非常简单。**这篇文章确实建立在之前的文章基础上，但阅读它们是可选的**；如果你想了解“如何”，可以阅读；如果你想尽快得到成果，则可以跳过。'
- en: Table of contents
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目录
- en: '[1\. Previous sprints recap](#9b5c)'
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[1. 之前冲刺回顾](#9b5c)'
- en: '[2\. Read data for the sites to be visited](#fa87)'
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[2. 读取待访问地点的数据](#fa87)'
- en: '[3\. The basic architecture](#336e)'
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[3. 基本架构](#336e)'
- en: '[3.1\. The Optimizer class diagram](#7b91)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3.1. 优化器类图](#7b91)'
- en: '[3.2\.](#eefc) `[**GeoAnalyzer**](#eefc)`[, revisited](#eefc)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3.2.](#eefc) `[**地理分析器**](#eefc)`[, 回顾](#eefc)'
- en: '[3.3\. Laying the *bases*: a base class for optimization utilities](#43ef)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3.3. 打下*基础*：优化工具的基类](#43ef)'
- en: '[4\. One class to route them all: the](#c043) `[TravelingSalesmanOptimizer](#c043)`'
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[4. 一个类来解决所有问题：](#c043) `[旅行推销员优化器](#c043)`'
- en: '[4.1\.](#127d) `[**TravelingSalesmanOptimizer**](#127d)` [design](#127d)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[4.1.](#127d) `[**旅行推销员优化器**](#127d)` [设计](#127d)'
- en: '[4.2\.](#419d) `[**TravelingSalesmanOptimizer**](#419d)` [implementation](#419d)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[4.2.](#419d) `[**旅行推销员优化器**](#419d)` [实现](#419d)'
- en: '[4.3\.](#9ab8) `[**TravelingSalesmanOptimizer**](#9ab8)` [for dummies](#9ab8)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[4.3.](#9ab8) `[**旅行推销员优化器**](#9ab8)` [为初学者](#9ab8)'
- en: '[5\. Beyond the optimal solution: extracting insights with the optimizer](#754e)'
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[5. 超越最优解：使用优化器提取见解](#754e)'
- en: '[6\. Conclusion (or planning for next sprint)](#c3ec)'
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[6. 结论（或下一次冲刺的计划）](#c3ec)'
- en: 1\. Previous sprints recap
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1. 之前冲刺回顾
- en: In [sprint 1](https://medium.com/@carlosjuribe/plan-an-optimal-trip-for-your-next-holidays-with-the-help-of-operations-research-and-python-481b1ea38fef)
    we reasoned our way through a ubiquitous tourism planning problem and concluded
    that its **minimum valuable problem** took the form of the [**Traveling Salesman
    Problem** (TSP)](https://en.wikipedia.org/wiki/Travelling_salesman_problem). That
    is why we dedicated [sprint 2](https://medium.com/@carlosjuribe/modeling-the-traveling-salesman-problem-from-first-principles-bd6530c9c07)
    and [sprint 3](https://medium.com/@carlosjuribe/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c)
    to develop a mathematical model, and a computer model, respectively, of the TSP.
    However, the goal then was only to **demonstrate the viability** of using optimization
    modeling to solve such a problem. Once this proof-of-concept was deemed viable,
    the new goal was to upgrade it, to refine it into a **Minimum Viable Product**
    (MVP) that could be used to **solve this *kind* of problems systematically, and
    in a more general fashion**. We noticed that, as a prerequisite, we needed a way
    of **obtaining distance data** from arbitrary locations. We tackled this issue
    in [sprint 4](https://medium.com/@carlosjuribe/compute-the-distance-matrix-of-a-set-of-sites-from-their-coordinates-in-python-d5fc92a0ba9e),
    where we built the `GeoAnalyzer` class to compute the distance matrix for any
    set of locations given only their coordinates.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [冲刺 1](https://medium.com/@carlosjuribe/plan-an-optimal-trip-for-your-next-holidays-with-the-help-of-operations-research-and-python-481b1ea38fef)
    中，我们通过一个普遍的旅游规划问题进行了推理，并得出其**最小可行问题**为 [**旅行推销员问题** (TSP)](https://en.wikipedia.org/wiki/Travelling_salesman_problem)。因此，我们将
    [冲刺 2](https://medium.com/@carlosjuribe/modeling-the-traveling-salesman-problem-from-first-principles-bd6530c9c07)
    和 [冲刺 3](https://medium.com/@carlosjuribe/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c)
    专门用于开发 TSP 的数学模型和计算机模型。然而，当时的目标只是**展示使用优化建模解决此类问题的可行性**。一旦此概念验证被认为是可行的，新的目标是升级它，将其精炼为一个**最小可行产品**
    (MVP)，以**系统地和更通用地解决这种*类型*的问题**。我们注意到，作为前提条件，我们需要一种**从任意位置获取距离数据**的方法。我们在 [冲刺 4](https://medium.com/@carlosjuribe/compute-the-distance-matrix-of-a-set-of-sites-from-their-coordinates-in-python-d5fc92a0ba9e)
    中解决了这个问题，在那里我们构建了 `GeoAnalyzer` 类来计算任何位置集合的距离矩阵，只需它们的坐标即可。
- en: 'All those iterative advancements take us here, to sprint 5, where we finally
    hit a major milestone: the creation of **an estimator-like class that solves *general*
    TSPs, quickly and intuitively**. We will accomplish this by integrating what we’ve
    built so far in an extensible fashion, thereby paving the way for future enhancements
    that will extend the capabilities of our model far beyond the TSP, something we
    must do if our system is to solve realistic tourism problems. That said, **the
    Traveling Salesman Problem** — arguably the most famous transportation problem
    in all Operations Research — **is in a class of its own, so in this article, we’ll
    give it a *class* of its own**. This class will hide away all the low-level modeling
    and solution parsing details, thereby enabling the **seamless solution of any
    TSP problem with just a method call**. If you feel this article lacks enough context
    or makes big jumps, please read the prep work to learn [how to implement a model
    for the TSP in Pyomo](/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c),'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些迭代进展将我们带到了第五阶段，我们最终达成了一个重大里程碑：创建一个**像估算器一样的类，可以快速直观地解决*通用* TSP**。我们将通过以可扩展的方式集成到目前为止所构建的内容来实现这一目标，从而为未来的增强铺平道路，这些增强将使我们的模型的能力远超
    TSP。如果我们要解决现实世界的旅游问题，这是必须做的。也就是说，**旅行推销员问题**——可以说是所有运筹学中最著名的运输问题——**独具一格，因此在本文中，我们将为其提供一个*独特的类***。这个类将隐藏所有低级建模和解决方案解析的细节，从而使**通过方法调用即可无缝解决任何
    TSP 问题**。如果你觉得这篇文章缺乏足够的背景或跳跃较大，请阅读准备工作，了解[如何在 Pyomo 中实现 TSP 模型](https://towardsdatascience.com/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c?source=post_page-----dbb44e7d30b9--------------------------------)
- en: '[](/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c?source=post_page-----dbb44e7d30b9--------------------------------)
    [## Implementing, solving and visualizing the Traveling Salesman Problem with
    Python'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[## 使用 Python 实现、解决和可视化旅行推销员问题](https://towardsdatascience.com/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c?source=post_page-----dbb44e7d30b9--------------------------------)'
- en: Learn how to translate an optimization model from Math to Python, optimize it,
    and visualize the solution to gain quick…
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习如何将优化模型从数学转换为 Python，优化它，并可视化解决方案以快速获得结果…
- en: towardsdatascience.com](/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c?source=post_page-----dbb44e7d30b9--------------------------------)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[towardsdatascience.com](https://towardsdatascience.com/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c?source=post_page-----dbb44e7d30b9--------------------------------)'
- en: and [how to find distances between locations in an automatic manner](/compute-the-distance-matrix-of-a-set-of-sites-from-their-coordinates-in-python-d5fc92a0ba9e),
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以及[如何以自动方式查找地点之间的距离](https://towardsdatascience.com/compute-the-distance-matrix-of-a-set-of-sites-from-their-coordinates-in-python-d5fc92a0ba9e)
- en: '[](/compute-the-distance-matrix-of-a-set-of-sites-from-their-coordinates-in-python-d5fc92a0ba9e?source=post_page-----dbb44e7d30b9--------------------------------)
    [## Compute the Distance Matrix of a Set of Sites from Their Coordinates in Python'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[## 从坐标计算一组站点的距离矩阵](https://towardsdatascience.com/compute-the-distance-matrix-of-a-set-of-sites-from-their-coordinates-in-python-d5fc92a0ba9e?source=post_page-----dbb44e7d30b9--------------------------------)'
- en: Estimate the distance between any pair of sites from their geographical coordinates
    as a stepping stone to solving…
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 估算任意一对站点之间的距离，作为解决问题的一个步骤…
- en: towardsdatascience.com](/compute-the-distance-matrix-of-a-set-of-sites-from-their-coordinates-in-python-d5fc92a0ba9e?source=post_page-----dbb44e7d30b9--------------------------------)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[## 从坐标计算一组站点的距离矩阵](https://towardsdatascience.com/compute-the-distance-matrix-of-a-set-of-sites-from-their-coordinates-in-python-d5fc92a0ba9e?source=post_page-----dbb44e7d30b9--------------------------------)'
- en: and you will understand, in more depth, where the ideas and code we’ll discuss
    here come from. If you’re already versed on the TSP, jump right in!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你将更深入地理解我们将在这里讨论的想法和代码的来源。如果你已经熟悉 TSP，可以直接跳入！
- en: 2\. Read data for the sites to be visited
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. 读取要访问的站点数据
- en: 'The basic input for the generic TSP is the locations we want to visit. In our
    example, we have a list of sites of interest in Paris, including our hotel. Let’s
    read them into a dataframe:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通用 TSP 的基本输入是我们要访问的地点。在我们的示例中，我们有一个巴黎的兴趣点列表，包括我们的酒店。让我们将它们读入数据框：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![](../Images/a8ac65de957710474d2d97505db2075b.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a8ac65de957710474d2d97505db2075b.png)'
- en: '**Figure 1.** Input coordinates for the optimizer (Image by author)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 1.** 优化器的输入坐标（作者提供的图片）'
- en: 3\. The basic architecture
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3\. 基本架构
- en: Before we start coding, it’s important to have a high-level understanding, and
    thus a design, of what we are about to do and why. Our goal is the creation of
    a class that **takes in some geographical coordinates of some sites, and solves
    the TSP problem for them, *i.e.*, outputs the order in which we ought to visit
    those sites** to minimize the total distance traveled. We won’t create just one
    class that does everything; we will keep different functionalities in different
    classes, and then combine them together[¹](#0558).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编码之前，重要的是对我们即将做的工作和原因有一个高层次的理解和设计。我们的目标是创建一个**接受某些站点的地理坐标，并为它们解决TSP问题，*即*，输出我们应该访问这些站点的顺序**以最小化总旅行距离。我们不会创建一个完成所有任务的类；我们将把不同的功能保存在不同的类中，然后将它们组合在一起[¹](#0558)。
- en: 3.1\. The Optimizer class diagram
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1\. 优化器类图
- en: I believe it is convenient for our class to have a scikit-learn-ish API. However,
    I won’t refer to our new class as an “*estimator*”, but rather, as an “*optimizer*”[²](#4124).
    A self-explanatory name is `TravelingSalesmanOptimizer`. One of its helper attributes
    will be the `GeoAnalyzer` class built in [sprint 4](https://medium.com/@carlosjuribe/compute-the-distance-matrix-of-a-set-of-sites-from-their-coordinates-in-python-d5fc92a0ba9e).
    Also, as this won't be the only optimizer class we'll end up creating in this
    project, we will store all the functionality related to the solving of models
    inside a separate class, `BaseOptimizer`. The reason is that all optimizers, no
    matter what internal model they implement, will need to optimize it, so it's best
    to keep the logic related to the optimization itself in a separate class, a base
    class which all optimizers will inherit from.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我们的类采用类似scikit-learn的API是便利的。然而，我不会将我们的新类称为“*估算器*”，而是称为“*优化器*”[²](#4124)。一个自解释的名称是
    `TravelingSalesmanOptimizer`。它的一个辅助属性将是[第4阶段](https://medium.com/@carlosjuribe/compute-the-distance-matrix-of-a-set-of-sites-from-their-coordinates-in-python-d5fc92a0ba9e)中构建的
    `GeoAnalyzer` 类。此外，由于这将不是我们在这个项目中创建的唯一优化器类，我们将把所有与模型求解相关的功能存储在一个单独的类 `BaseOptimizer`
    中。原因是所有优化器，无论它们实现什么内部模型，都需要优化它，因此最好将与优化本身相关的逻辑保存在一个单独的类中，作为所有优化器的基类。
- en: In the class diagram below, we can see how the three classes fit together. Inside
    each, I have included their **main attributes and methods** (but not all) for
    us to get the idea.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的类图中，我们可以看到这三个类如何组合在一起。在每个类内部，我包含了它们的**主要属性和方法**（但不是全部），以便我们能理解整体概念。
- en: '![](../Images/e8c714186abc4b21a798483e156f5f3a.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e8c714186abc4b21a798483e156f5f3a.png)'
- en: '**Figure 2.** Class diagram for the TSP Optimizer (Image by author)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2。** TSP优化器的类图（作者提供的图像）'
- en: 'Here’s the main purpose of each class, in a nutshell:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类的主要目的，简而言之：
- en: '`BaseOptimizer` is responsible for the optimization of the models of "proper"
    optimizer subclasses, it''s not intended to be instantiated on its own.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BaseOptimizer` 负责优化“适当”的优化器子类的模型，它不打算单独实例化。'
- en: '`GeoAnalyzer` is a self-contained class of geo-utilities. It aids in the crucial
    step of computing a distance matrix from user-given coordinates, needed to construct
    a model if the user doesn''t have custom distance data at hand.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GeoAnalyzer` 是一个自包含的地理工具类。它在计算用户提供的坐标的距离矩阵的关键步骤中提供帮助，如果用户没有自定义距离数据，这一步是构建模型所必需的。'
- en: The `TravelingSalesmanOptimizer` is an optimizer that can be fitted to a dataframe
    having the coordinates of the sites. Once fitted, the "visit order" of those sites
    can be retrieved. Internally, it implements a [mathematical model](https://medium.com/@carlosjuribe/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c)
    of the Traveling Salesman Problem as a [Pyomo model](https://pyomo.readthedocs.io/en/stable/pyomo_overview/simple_examples.html)
    object.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TravelingSalesmanOptimizer` 是一个优化器，可以拟合具有站点坐标的数据框。一旦拟合，便可以检索这些站点的“访问顺序”。在内部，它实现了[旅行商问题的数学模型](https://medium.com/@carlosjuribe/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c)作为一个[Pyomo模型](https://pyomo.readthedocs.io/en/stable/pyomo_overview/simple_examples.html)对象。'
- en: With a concrete design in mind, let’s assemble it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有了具体的设计，我们来组装它。
- en: 3.2\. `GeoAnalyzer`, revisited
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2\. `GeoAnalyzer` 的重新审视
- en: 'As the code for `GeoAnalyzer` was already developed in the previous sprint,
    here we just move it to a new module, `geoutils.py`, and import the class from
    there. If you haven''t read [the article in which it was created](https://medium.com/@carlosjuribe/compute-the-distance-matrix-of-a-set-of-sites-from-their-coordinates-in-python-d5fc92a0ba9e),
    don''t worry, all you need to know is that it takes in some dataframe of coordinates
    and outputs a distance matrix, like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`GeoAnalyzer`的代码已在前一次冲刺中开发完成，这里我们只是将其移动到一个新模块`geoutils.py`中，并从那里导入该类。如果你没有阅读[创建它的文章](https://medium.com/@carlosjuribe/compute-the-distance-matrix-of-a-set-of-sites-from-their-coordinates-in-python-d5fc92a0ba9e)，不要担心，你需要知道的是，它接受一些坐标数据框并输出一个距离矩阵，如下所示：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![](../Images/4f12661ff8fbe9db8e0db9e08440b218.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4f12661ff8fbe9db8e0db9e08440b218.png)'
- en: '**Figure 3.** Distance matrix generated by GeoAnalyzer (Image by author)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 3.** GeoAnalyzer生成的距离矩阵（图片由作者提供）'
- en: This dataframe of distances is what we’ll use inside `TravelingSalesmanOptimizer`
    to create an internal model, as the real data that is needed to model a Traveling
    Salesman problem is distances, not coordinates.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个距离数据框是我们将在`TravelingSalesmanOptimizer`内部用于创建内部模型的，因为建模旅行销售员问题所需的真实数据是距离，而不是坐标。
- en: '3.3\. Laying the bases: a base class for optimization utilities'
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3\. 打下基础：优化工具的基类
- en: In the [article for sprint 3](http://localhost:8888/lab/workspaces/auto-c/tree/Projects/TWDS/traveling_tourist_problem/TTPOptimizer_part3.ipynb#https://medium.com/@carlosjuribe/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c),
    the very first code snippet is about instantiating a Pyomo solver and printing
    its version. A bit further below, in [section 2.1](https://medium.com/@carlosjuribe/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c#:~:text=validating%20the%20model-,2.1.%20Solving%20the%20model,-The%20next%20step),
    we used this solver to optimize the model. With that in mind, creating `BaseOptimizer`
    is only a matter of putting these pieces together into a class. We will modify
    the original code slightly so that it becomes easier to read, but essentially
    it's the same thing wrapped conveniently.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第三次冲刺的文章](http://localhost:8888/lab/workspaces/auto-c/tree/Projects/TWDS/traveling_tourist_problem/TTPOptimizer_part3.ipynb#https://medium.com/@carlosjuribe/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c)中，第一个代码片段是关于实例化Pyomo求解器并打印其版本。稍后在[2.1节](https://medium.com/@carlosjuribe/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c#:~:text=validating%20the%20model-,2.1.%20Solving%20the%20model,-The%20next%20step)中，我们使用了这个求解器来优化模型。考虑到这一点，创建`BaseOptimizer`只需将这些部分组合成一个类即可。我们将稍微修改原始代码，以便更易于阅读，但本质上它是相同的，方便地封装起来。
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The main things to keep in mind about this class are:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个类需要记住的主要事项是：
- en: At instantiation, the solver is set up internally by `_setup_solver`. As we
    can't solve any model without a solver, if the setup fails, an exception will
    be raised. If the solver is found, it's kept as a private attribute.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实例化时，求解器由`_setup_solver`在内部设置。由于没有求解器我们无法解决任何模型，如果设置失败，将会抛出异常。如果找到了求解器，它会被作为私有属性保存。
- en: The method `_optimize` will be invoked whenever a subclass to `BaseOptimizer`
    calls a `fit`-like method. `_optimize` takes in a model and **attempts** to solve
    it, using the internal solver. If an optimal solution *exists*, the attribute
    `_solution_exists` will cease to be `None` and will take the value `True`. If
    *no optimal solution exists*[*³*](#f7e6), it will take the value `False`, and
    a warning is printed.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当一个`BaseOptimizer`的子类调用类似`fit`的方法时，方法`_optimize`将会被调用。`_optimize`接受一个模型，并使用内部求解器**尝试**解决它。如果*存在*最优解，属性`_solution_exists`将不再是`None`，而是取值`True`。如果*没有最优解存在*[*³*](#f7e6)，它将取值`False`，并会打印一个警告。
- en: The remaining methods are explained in their docstrings. Now, time to build
    our first optimizer.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的方法在它们的文档字符串中进行了说明。现在，开始构建我们的第一个优化器。
- en: '4\. One class to route them all: the `TravelingSalesmanOptimizer`'
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4\. 一个类解决所有问题：`TravelingSalesmanOptimizer`
- en: Here we won’t start from scratch. As stated earlier, we already developed the
    code that builds a Pyomo model of the TSP and solves it in [sprint 3](http://localhost:8888/lab/workspaces/auto-c/tree/Projects/TWDS/traveling_tourist_problem/TTPOptimizer_part3.ipynb#https://medium.com/@carlosjuribe/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c).
    And trust me, that was the hardest part. Now, we have the easier task of organizing
    what we did in a way that makes it general, hiding the details while keeping the
    *essential* elements visible. In a sense, we want the optimizer to look like a
    “magic box” that even users not familiar with math modeling are able to use to
    solve their TSP problems intuitively.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会从头开始。正如前面所述，我们已经开发了构建TSP的Pyomo模型并在[sprint 3](http://localhost:8888/lab/workspaces/auto-c/tree/Projects/TWDS/traveling_tourist_problem/TTPOptimizer_part3.ipynb#https://medium.com/@carlosjuribe/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c)中解决它的代码。相信我，那是最难的部分。现在，我们的任务是将我们所做的组织成一种通用的方式，隐藏细节同时保留*基本*元素。某种意义上，我们希望优化器看起来像一个“魔法盒子”，即使是对数学建模不熟悉的用户也能直观地解决他们的TSP问题。
- en: 4.1\. `TravelingSalesmanOptimizer` design
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1. `TravelingSalesmanOptimizer`设计
- en: Our optimizer class will have “core” methods, doing the bulk of the work, and
    “superficial” methods, serving as the high-level interface of the class, which
    invoke the core methods underneath.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的优化器类将包含“核心”方法，处理大部分工作，还有“表面”方法，作为类的高级接口，调用底层的核心方法。
- en: 'These are the steps that will lie at the core of the optimizer’s logic:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将成为优化器逻辑的核心：
- en: '**Create a Pyomo model** out of a distance matrix. This is done by the `_create_model`
    method, which basically wraps [the code of the proof-of-concept](/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c#:~:text=start%20coding%20along!-,1.2.%20Math%20becomes%20code,First%2C%20let%E2%80%99s%20make%20sure%20the%20GLPK%20solver%20is%20findable%20by%20Pyomo,-%23%23%23%20%3D%3D%3D%3D%3D%20%20Code%20block%203.1)
    we already did. It accepts a dataframe of a distance matrix and builds a Pyomo
    model out of it. The only important difference between what we did and what we''re
    doing is that, now, the initial site is not hard-coded as simply `"hotel"`, but
    is *assumed* to be the site of the first row in `df_distances`. In the general
    case, thus, **the initial site is taken to be the first one in the coordinates
    dataframe**[⁴](#8dd4) `df_sites`. This generalization allows the optimizer to
    solve any instance.'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从距离矩阵创建一个Pyomo模型**。这由`_create_model`方法完成，该方法基本上封装了我们已经完成的[概念验证代码](/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c#:~:text=start%20coding%20along!-,1.2.%20Math%20becomes%20code,First%2C%20let%E2%80%99s%20make%20sure%20the%20GLPK%20solver%20is%20findable%20by%20Pyomo,-%23%23%23%20%3D%3D%3D%3D%3D%20%20Code%20block%203.1)。它接受一个距离矩阵的数据框，并基于此构建一个Pyomo模型。我们所做的与我们现在要做的唯一重要区别在于，初始站点不再硬编码为简单的`"hotel"`，而是*假定*为`df_distances`中第一行的站点。一般情况下，**初始站点被认为是坐标数据框**[⁴](#8dd4)
    `df_sites`中的第一个。这一推广使得优化器能够解决任何实例。'
- en: '**(Attempt to) Solve the model**. This is performed in the `_optimize` method
    inherited from `BaseOptimizer`, which returns `True` only if a solution is found.'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**（尝试）解决模型**。这是在继承自`BaseOptimizer`的`_optimize`方法中执行的，只有找到解决方案时才返回`True`。'
- en: '**Extract the solution from the model and parse it** in a way that is easy
    to interpret and use. This happens inside `_store_solution_from_model`, which
    is a method that inspects the solved model and extracts the values of the decision
    variables, and the value of the objective function, to *create* the attributes
    `tour_` and `tour_distance_`, respectively. This method *gets invoked* ***only
    if*** *a solution exists*, so if no solution is found, the "solution attributes"
    `tour_` and `tour_distance_` never get created. The benefit of this is that the
    presence of these two "solution attributes", after fitting, will inform the user
    of the existence of a solution. As a plus, the optimal values of both the variables
    and objective can be conveniently retrieved at any point, not necessarily at the
    moment of fitting.'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从模型中提取解决方案并解析**成易于理解和使用的形式。这发生在`_store_solution_from_model`方法内部，该方法检查已解决的模型并提取决策变量的值，以及目标函数的值，以*创建*属性`tour_`和`tour_distance_`。此方法*仅在*存在解决方案时*被调用，因此如果未找到解决方案，“解决方案属性”`tour_`和`tour_distance_`将不会被创建。这样做的好处是，在拟合之后，这两个“解决方案属性”的存在将通知用户存在解决方案。此外，变量和目标的最优值可以在任何时刻方便地检索，而不仅仅是在拟合时。'
- en: The last 2 steps — finding and extracting the solution — are wrapped inside
    the last “core” method, `_fit_to_distances`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的两个步骤——找到并提取解决方案——被封装在最后一个“核心”方法 `_fit_to_distances` 中。
- en: “But wait” — you might think — “As the name implies, `_fit_to_distances` requires
    distances as input; isn't our goal to solve TSP problems using only *coordinates*,
    not *distances*?". Yes, that's where the `fit` method *fits* in. We pass *coordinates*
    to it, and we take advantage of `GeoAnalyzer` to construct the distance matrix,
    which is then processed normally by `_fit_to_distances`. In this way, if the user
    does not want to collect the distances himself, he can delegate the task by using
    `fit`. If, however, he prefers to use custom data, he can assemble it in a `df_distances`
    and pass it to `_fit_to_distances` instead.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: “但请稍等”——你可能会想——“如名字所示，`_fit_to_distances` 需要距离作为输入；我们的目标不是仅使用 *坐标* 来解决 TSP 问题吗，而不是
    *距离*？” 是的，这就是 `fit` 方法 *适配* 的地方。我们将 *坐标* 传递给它，并利用 `GeoAnalyzer` 构建距离矩阵，然后由 `_fit_to_distances`
    正常处理。这样，如果用户不想自己收集距离，他可以通过使用 `fit` 委派任务。然而，如果他更愿意使用自定义数据，他可以将其组装成 `df_distances`
    并传递给 `_fit_to_distances`。
- en: 4.2\. `TravelingSalesmanOptimizer` implementation
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2. `TravelingSalesmanOptimizer` 实现
- en: Let’s follow the design outlined above to incrementally build the optimizer.
    First, a minimalist version that just builds a model and solves it — without any
    solution parsing yet. Notice how the `__repr__` method allows us to know the name
    and number of sites the optimizer contains whenever we print it.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照上面概述的设计逐步构建优化器。首先是一个简化版本，只构建模型并解决它——尚未进行任何解决方案解析。注意 `__repr__` 方法如何在我们打印优化器时让我们知道它包含的站点的名称和数量。
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s quickly check how the optimizer behaves. Upon instantiation, the optimizer
    does not contain any number of sites, as the representation string shows, or an
    internal model, and it’s of course not fitted:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速检查优化器的行为。实例化时，优化器不包含任何站点数量，如表示字符串所示，也没有内部模型，并且当然没有进行适配。
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We now fit it to the distance data, and if we don’t get a warning, it means
    that it all went well. We can see that now the representation string tells us
    we provided 9 sites, there’s an internal model, and that the optimizer was fitted
    to the distance data:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将其适配到距离数据上，如果没有收到警告，意味着一切顺利。我们可以看到，现在表示字符串告诉我们我们提供了 9 个站点，存在一个内部模型，并且优化器已经适配到距离数据上：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'That the optimal solution was found is corroborated by the presence of definite
    values in the rank decision variables of the model:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最优解的发现通过模型的排名决策变量中的明确值得到了证实：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These rank variables represent the chronological order of the stops in the optimal
    tour. If you recall from [their definition](/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c#:~:text=rank%20variables%2C%20r%E1%B5%A2%3A%20to%20keep%20track%20of%20the%20order%20in%20which%20sites%20are%20visited%3A),
    they are defined over all sites except the initial one[⁵](#f9a3), and that’s why
    the hotel does not appear in them. Easy, we could add the hotel with rank 0, and
    there we would have **the answer to our problem**. We don’t need to extract 𝛿ᵢⱼ,
    the decision variables for the *individual* arcs of the tour, to know in which
    order we should visit the sites. Although that’s true, we’re still going to use
    the arc variables 𝛿ᵢⱼ to extract the exact sequence of stops from the solved model.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些排名变量表示最优旅行中的停靠点的时间顺序。如果你回忆一下 [它们的定义](/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c#:~:text=rank%20variables%2C%20r%E1%B5%A2%3A%20to%20keep%20track%20of%20the%20order%20in%20which%20sites%20are%20visited%3A)，它们在所有站点上定义，除了初始站点[⁵](#f9a3)，这就是为什么酒店没有出现在其中。很简单，我们可以将酒店添加为排名
    0，那么我们就有了 **问题的答案**。我们不需要提取 𝛿ᵢⱼ，即旅行的 *个别* 弧的决策变量，来知道我们应该以什么顺序访问站点。虽然这是真的，我们仍然会使用弧变量
    𝛿ᵢⱼ 来从解决的模型中提取确切的停靠顺序。
- en: '*💡* **Agile *doesn’t need to be* fragile**'
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*💡* **敏捷 *不必是* 脆弱的**'
- en: ''
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If our only aim were to solve the TSP, without looking to* extend *the model
    to encompass more details of our real-life problem, it would be enough to use
    the rank variables to extract the optimal tour. However, as the TSP is just* ***the
    initial prototype of what will become a more sophisticated model****, we’re better
    off extracting the solution from the arc decision variables 𝛿ᵢⱼ, as they will
    be present in any model that involves routing decisions. All other decision variables
    are auxiliary, and, when needed, their job is to represent states or indicate
    conditions dependant on the* true *decision variables, 𝛿ᵢⱼ. As you’ll see in the
    next articles, choosing the rank variables to extract the tour works for a pure
    TSP model, but won’t work for extensions of it that make it* optional *to visit
    some sites. Hence, if we extract the solution from 𝛿ᵢⱼ,* ***our approach will
    be general and re-usable, no matter how complex the model we’re using****.*'
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*如果我们的唯一目标是解决TSP问题，而不考虑* 扩展 *模型以涵盖我们实际问题的更多细节，使用排名变量来提取最优旅行路径就足够了。然而，由于TSP仅仅是*
    ***将成为更复杂模型的初始原型****，我们最好从弧决策变量𝛿ᵢⱼ中提取解决方案，因为任何涉及路由决策的模型中都会包含这些变量。其他决策变量是辅助的，当需要时，它们的作用是表示状态或指示依赖于*
    真实 *决策变量𝛿ᵢⱼ的条件。正如你将在接下来的文章中看到的，选择排名变量来提取旅行路径适用于纯TSP模型，但对于那些使访问某些站点* 可选 *的扩展则不适用。因此，如果我们从𝛿ᵢⱼ中提取解决方案，*
    ***我们的方法将是通用和可重复使用的，无论我们使用多么复杂的模型****。*'
- en: The benefits of this approach will become apparent in the following articles,
    where new requirements are added, and thus additional variables are needed inside
    the model. With the *why* covered, let’s jump into the *how*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的好处将在接下来的文章中显现出来，这些文章中增加了新的要求，因此模型中需要额外的变量。在*为什么*部分讲解完毕后，让我们进入*如何*部分。
- en: '**4.2.1 Extracting the optimal tour from the model**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**4.2.1 从模型中提取最优旅行路径**'
- en: '**We have** the variable 𝛿ᵢⱼ, indexed by possible arcs (i, j), where 𝛿ᵢⱼ=0
    means the arc is not selected and 𝛿ᵢⱼ=1 means the arc is selected.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们有**变量𝛿ᵢⱼ，按可能的弧（i, j）索引，其中𝛿ᵢⱼ=0表示弧未被选择，𝛿ᵢⱼ=1表示弧被选择。'
- en: '**We want** a dataframe where the sites are in the index (as in our input `df_sites`),
    and where the stop number is indicated in the column `"visit_order"`.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们想要**一个数据框，其中站点位于索引中（如我们的输入`df_sites`所示），并且停靠点编号在列 `"visit_order"`中指示。'
- en: '**We write** a method to extract such dataframe from the fitted optimizer.
    These are the steps we’ll follow, with each step encapsulated in its own helper
    method(s):'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们编写**一个方法从拟合的优化器中提取这样的数据框。以下是我们将遵循的步骤，每一步都封装在自己的辅助方法中：'
- en: Extract the selected arcs from 𝛿ᵢⱼ, which represents the tour. Done in `_get_selected_arcs_from_model`.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从𝛿ᵢⱼ中提取所选的弧，𝛿ᵢⱼ表示旅行路径。完成在`_get_selected_arcs_from_model`中。
- en: Convert the list of arcs (edges) into a list of stops (nodes). Done in `_get_stops_order_list`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将弧（边）列表转换为停靠点（节点）列表。完成在`_get_stops_order_list`中。
- en: Convert the list of stops into a dataframe with a consistent structure. Done
    in `_get_tour_stops_dataframe`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将停靠点列表转换为具有一致结构的数据框。完成在`_get_tour_stops_dataframe`中。
- en: As the selected arcs are mixed (*i.e.*, not in “traversing order”), getting
    a list of ordered stops is not that straight-forward. To avoid convoluted code,
    we exploit the fact that the arcs represent a *graph*, and we use the graph object
    `G_tour` to traverse the tour nodes in order, arriving at the list easily.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所选弧是混合的（*即*，不按“遍历顺序”），获得有序的停靠点列表并不那么直接。为了避免复杂的代码，我们利用弧表示*图*的事实，使用图对象`G_tour`按顺序遍历旅行路径节点，从而轻松地得到列表。
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s see what this new method gives us:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个新方法给了我们什么：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![](../Images/dc75bd513f652b2d63c68f741e8680e4.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/dc75bd513f652b2d63c68f741e8680e4.png)'
- en: '**Figure 4**. Solution (optimal tour) as ranked sites (Image by Author)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4**。解决方案（最优旅行路径）按排名站点（图由作者提供）'
- en: The `visit_order` column indicates we should go from the hotel to Notre Dame,
    then to the Louvre, and so on, until the last stop before closing the tour, Sacre
    Coeur. After that, it's trivial that one must return to the hotel. Good, now we
    have the solution in a format easy to interpret and work with. But the sequence
    of stops is not all we care about. **The value of the objective function is also
    an important metric to keep track of**, as it's the criterion guiding our decisions.
    For our particular case of the TSP, this means getting the total distance of the
    optimal tour.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`visit_order`列表明我们应该从酒店前往巴黎圣母院，然后到卢浮宫，依此类推，直到最后一个停靠点，蒙马特高地。之后，显然必须返回酒店。很好，现在我们有了一个易于解释和使用的解决方案格式。但停靠点的顺序并不是我们唯一关心的。**目标函数的值也是一个重要的指标**，因为它是指导我们决策的标准。对于我们特别的TSP问题，这意味着获取最优路线的总距离。'
- en: '**4.2.2 Extracting the optimal objective from the model**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**4.2.2 从模型中提取最优目标**'
- en: In the same manner that we didn’t use the rank variables to extract the sequence
    of stops because in more complex models their values wouldn’t coincide with the
    tour stops, we won’t use the objective function *directly* to obtain the total
    distance of the tour, even though, here too, both measures are equivalent. **In
    more complex models, the objective function will also incorporate other targets**,
    so this equivalence will no longer hold.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们没有使用排名变量来提取停靠点序列一样，因为在更复杂的模型中，它们的值不会与路线停靠点一致，我们也不会*直接*使用目标函数来获得路线的总距离，尽管在这里这两种测量都是等效的。**在更复杂的模型中，目标函数还会包含其他目标**，因此这种等效性将不再成立。
- en: 'For now, we’ll keep it simple and create a non-public method, `_get_tour_total_distance`,
    which clearly indicates the intent. The details of where this distance comes from
    are hidden, and will depend on the particular targets that more advanced models
    care about. For now, the details are simple: get the objective value of the solved
    model.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将保持简单，创建一个非公开方法`_get_tour_total_distance`，这明确表示了意图。这个距离来源的细节是隐藏的，并且会依赖于更高级模型关心的特定目标。目前，细节很简单：获取解决模型的目标值。
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It may look superfluous now, but it’ll serve as a reminder to our future selves
    that there is a design for grabbing objective values we’d better follow. Let’s
    check it:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看起来可能有些多余，但它将作为一个提醒，告诉我们未来的自己，应该遵循抓取目标值的设计。我们来看看：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It’s around 14.9 km. As both the optimal tour and its distance are important,
    let’s make the optimizer store them together whenever the `_fit_to_distances`
    method gets called, **and only when an optimal solution is found**.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 总距离约为14.9公里。由于最优路线及其距离都很重要，让我们使优化器在每次调用`_fit_to_distances`方法时，将它们一起存储，**并且只有在找到最优解时**。
- en: '**4.2.3 Storing the solution in attributes**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**4.2.3 将解决方案存储在属性中**'
- en: 'In the implementation of `_fit_to_distances` above, we just created a model
    and solved it, we didn''t do any parsing of the solution stored inside the model.
    Now, we''ll modify `_fit_to_distances` so that **when the model solution succeeds,
    two new attributes are created and made available** with the two relevant parts
    of the solution: the `tour_` and the `tour_distance_`. To make it simple, the
    `tour_` attribute won''t return the dataframe we did earlier, it will return the
    list with ordered stops. The new method `_store_solution_from_model` takes care
    of this.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的`_fit_to_distances`实现中，我们只是创建了一个模型并解决了它，没有对模型中存储的解决方案进行任何解析。现在，我们将修改`_fit_to_distances`，**以便当模型解决方案成功时，会创建并提供两个新的属性**，即解决方案的两个相关部分：`tour_`和`tour_distance_`。为了简单起见，`tour_`属性不会返回我们之前创建的数据框，而是返回一个按顺序排列的停靠点列表。新的方法`_store_solution_from_model`负责这个任务。
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s fit the optimizer again to the distance data and see how easy it is to
    get the solution now:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次将优化器拟合到距离数据上，看看现在获取解决方案有多容易：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Nice. But we can do even better. To further **increase the usability of this
    class**, let’s allow the user to solve the problem by only providing the dataframe
    of sites coordinates. As not everyone will be able to collect a distance matrix
    for their sites of interest, the class can take care of it and provide an approximate
    distance matrix. This was done above in section 3.2 with the `GeoAnalyzer`, here
    we just put it under the new `fit` method:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。但我们可以做得更好。为了进一步**提高这个类的可用性**，让我们允许用户仅提供站点坐标的数据框来解决问题。由于不是每个人都能为他们感兴趣的站点收集距离矩阵，类可以处理这个问题并提供一个近似的距离矩阵。这在第3.2节中通过`GeoAnalyzer`实现了，这里我们只是将其放在新的`fit`方法下：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And now we have achieved our goal: **find the optimal tour from just the sites
    locations** (and not from the distances as before):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们达到了我们的目标：**从仅仅是站点位置中找到最佳旅行路线**（而不是像以前那样从距离中找到）：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 4.3\. `TravelingSalesmanOptimizer` for dummies
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3. `TravelingSalesmanOptimizer` 简明指南
- en: 'Congratulations! We reached the point where the optimizer is very intuitive
    to use. For mere convenience, I’ll add another method that will be quite helpful
    later on when we do [sensitivity analysis] and compare the results of different
    models. The optimizer, as it is now, tells me the optimal visit order in a list,
    or in a separate dataframe returned by `get_tour_stops_dataframe()`, but I''d
    like it to tell me **the visit order by *transforming* the locations dataframe**
    that I give it directly—by returning the same dataframe with a new column having
    the optimal sequence of stops. The method `fit_prescribe` will be in charge of
    this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们已经达到了优化器非常直观的使用阶段。为了方便起见，我将添加另一种方法，这在我们做[敏感性分析]和比较不同模型的结果时会非常有用。优化器现在会以列表或由`get_tour_stops_dataframe()`返回的单独数据框的形式告诉我最佳的访问顺序，但我希望它能告诉我**通过*转换*我直接提供的位置数据框**的访问顺序——即返回具有最佳停靠顺序的新列的数据框。方法`fit_prescribe`将负责这一点：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we can solve any TSP in just **one line**:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以用**一行代码**解决任何 TSP 问题：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![](../Images/5d2606e413b5c613d32d084a580c17d1.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5d2606e413b5c613d32d084a580c17d1.png)'
- en: '**Figure 6**. Solution (optimal tour) appended to dataframe of sites (Image
    by Author)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6**。解决方案（最佳旅行路线）附加到站点数据框中（图像来源于作者）'
- en: 'If we’d like to conserve the original order of locations as they were in `df_sites`,
    we can do it by specifying `sort=False`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想保持位置的原始顺序，就像它们在`df_sites`中一样，我们可以通过指定`sort=False`来实现：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![](../Images/fba80c8ddb8a99700fb200517675ec64.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/fba80c8ddb8a99700fb200517675ec64.png)'
- en: '**Figure 7**. Solution appended to dataframe of sites, sites order preserved
    (Image by Author)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7**。解决方案附加到站点数据框中，站点顺序保持不变（图像来源于作者）'
- en: And if we’re curious we can also check the number of variables and constraints
    the internal model needed to solve our particular instance of the TSP. This will
    be handy when doing debugging or performance analysis.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们好奇的话，也可以检查内部模型在解决我们特定的 TSP 实例时所需的变量和约束数量。这在进行调试或性能分析时会很有用。
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '5\. Beyond the optimal solution: extracting insights with the optimizer'
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5. 超越最佳解决方案：利用优化器提取见解
- en: Before we close this article, I would like to show you some brief examples of
    how easy it is to use this class, **not just to solve TSP problems, but to also
    answer general questions that usually arise when planning a trip**.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本文之前，我想给你展示一些简短的例子，说明使用这个类是多么简单，**不仅可以解决 TSP 问题，还能回答规划旅行时通常会出现的一般问题**。
- en: 'For example, suppose you have already come up with a list of sites to visit
    in one day of your trip to Paris, and you have them in a dataframe called `df_sites`.
    You''d like to know *only* the total length of the optimal tour to traverse them
    all. You don''t have to go to *great lengths* to know that; this one-liner has
    you covered:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你已经制定了一份一天内在巴黎旅行中要访问的站点清单，并将它们放在名为`df_sites`的数据框中。你想知道*仅仅*是遍历它们的最佳旅行路线的总长度。你不需要去*极大地*了解这一点；这行代码就可以解决：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now suppose you’re not very sure of your set of sites, and are thinking of
    trimming it down a little. You are pondering over skipping the visit to *Arc de
    Triomphe*, as it is far from the hotel. **You may wonder: “How much does the optimal
    tour change if I don’t go to this site?”**. Thanks to the optimizer, getting the
    answer is straightforward:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你对你的站点集合不是很确定，考虑稍微缩减一下。你正在考虑跳过对*凯旋门*的访问，因为它离酒店很远。**你可能会想：“如果我不去这个站点，最佳旅行路线会变化多少？”**。感谢优化器，得到答案非常简单：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With this, you know that you would save around 768 m of walking if you skipped
    *Arc de Triomphe*. It’s up to you to decide whether that’s worth it or not.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个，你可以知道如果你跳过*凯旋门*，你将节省大约 768 米的步行距离。是否值得就由你来决定。
- en: '**It’s not just about optimal routes: we can find “optimal” hotels too!**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**这不仅仅是关于最佳路线：我们也可以找到“最佳”酒店！**'
- en: 'As another practical example, imagine that you have settled with a list of
    sites to visit, but haven’t picked a hotel yet. You have several options, and
    in order to decide better, **you would like to know how each choice of hotel impacts
    the total distance of the tour you’ll make**. Then it’s just a matter of **fitting
    another optimizer** with a sites dataframe containing the new candidate hotel,
    **and comparing the optimal distance with the optimal distance of using the initial
    hotel**:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个实际示例，假设你已经确定了要访问的景点列表，但还没有选择酒店。你有几个选择，为了更好地决策，**你想知道每个酒店选择对你将要进行的旅行总距离的影响**。然后，这只是**用包含新候选酒店的景点数据框拟合另一个优化器**，**并将最佳距离与使用初始酒店的最佳距离进行比较**：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The conclusion is that **if we choose “hotel 2”, we will have to *walk 2.8 km
    more* than if we chose “hotel 1”**, on a tour traversing the same set of sites.
    All other things being equal, this informs us that “hotel 1” is a better choice
    than “hotel 2” (*given* the sites we want to visit).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 结论是，**如果我们选择“酒店2”，那么我们将比选择“酒店1”多*步行2.8公里*，在穿越相同景点的旅游中**。在其他条件相同的情况下，这告诉我们“酒店1”比“酒店2”更佳选择（*考虑到*我们想参观的景点）。
- en: 6\. Conclusion (or planning for next sprint)
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6\. 结论（或计划下一个迭代）
- en: In this article, we have created two new classes (`BaseOptimizer` and `TravelingSalesmanOptimizer`).
    In future sprints, we'll be using them, extending them, and adding more advanced
    optimizers to the toolkit, so to do things cleanly, let's move them to a new module,
    `routimizers.py`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇文章中，我们创建了两个新类（`BaseOptimizer` 和 `TravelingSalesmanOptimizer`）。在未来的迭代中，我们将使用它们、扩展它们，并将更高级的优化器添加到工具包中，所以为了做到干净整洁，让我们将它们移动到一个新模块`routimizers.py`中。
- en: Now, one final thing to keep in mind is the scope of this MVP. This first optimizer
    gives us the answer to the question “in which **order** should I visit the sites?”,
    but it doesn’t tell us *how to go* from one site to the next. That is fine, as
    that’s the job of GIS applications like Google Maps, not of our humble optimizer.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最后一点需要记住的是这个MVP的范围。这个初始优化器给出了“**我应该以什么**顺序访问这些景点？”的问题的答案，但它没有告诉我们*如何从一个景点到下一个景点*。这没关系，因为这正是像Google
    Maps这样的GIS应用程序的工作，而不是我们谦逊的优化器。
- en: '***👁*** *Our optimizer solves the* ***tactical*** *problem of telling us the
    optimal* sequence of stops *on a tour, not the* ***operational*** *problem of
    guiding us along that tour. The latter problem is easily solvable by many great
    GIS applications, like Google Maps.*'
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '***👁*** *我们的优化器解决了* ***战术*** *问题，即告诉我们在旅游中最佳的* 停留顺序，*而不是* ***操作性*** *问题，即引导我们完成这次旅行。后者问题可以通过许多优秀的GIS应用程序轻松解决，例如Google
    Maps。*'
- en: 'If you’re happy with the result (the tour), and you’d like to actually implement
    it in *real life*, it’s easy: go straight to Google Maps and introduce these sites
    as stops in the *order specified by the optimizer*. Hit “go” and there you have
    your *operational* answer.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对结果（旅行）感到满意，并且想要在*现实生活中*实际实现它，那么很简单：直接去Google Maps，将这些景点按*优化器指定的顺序*输入为停留点。点击“开始”，你就能得到*操作性*答案。
- en: 'Nevertheless, it still feels like one should be able to *visualize* the results,
    not just be content with the numbers that the optimizer puts in a new column;
    if not for the implementation in real life, at least for a better understanding
    of the solutions. In sprint 3 we did [visualize the solution a bit](https://medium.com/@carlosjuribe/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c#:~:text=valuable%20final%20check.-,4.2.%20Plotting%20the%20augmented%20model%E2%80%99s%20solution,-Let%E2%80%99s%20solve%20the),
    even without having the coordinates. Now that we *do have* the coordinates of
    the sites, we can do much better and visualize the resulting optimal tours in
    a more realistic fashion. That is precisely the goal of [our next sprint](/visualizing-routes-on-interactive-maps-with-python-part-1-44f8d25d0761):
    **to create nice visuals that enable us to better understand the solutions** (tours)
    **provided by the optimizer**, and, in the process, ask and answer more and better
    questions that allow us to plan better trips. Grab a cup of coffee, and jump right
    in:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仍然感觉应该能够*可视化*结果，而不仅仅满足于优化器在新列中放置的数字；即使不是为了实际应用，也应该是为了更好地理解解决方案。在第三次冲刺中，我们确实[稍微可视化了一下解决方案](https://medium.com/@carlosjuribe/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c#:~:text=valuable%20final%20check.-,4.2.%20Plotting%20the%20augmented%20model%E2%80%99s%20solution,-Let%E2%80%99s%20solve%20the)，即使没有坐标。现在我们*确实有*了站点的坐标，我们可以做得更好，以更现实的方式可视化最终的最佳路线。这正是[我们下一次冲刺](/visualizing-routes-on-interactive-maps-with-python-part-1-44f8d25d0761)的目标：**创建出色的视觉效果，以便更好地理解优化器提供的解决方案**（路线），并在此过程中提出和回答更多、更好的问题，从而帮助我们规划更好的行程。拿一杯咖啡，直接开始吧：
- en: '[](/visualizing-routes-on-interactive-maps-with-python-part-1-44f8d25d0761?source=post_page-----dbb44e7d30b9--------------------------------)
    [## Visualizing Routes on Interactive Maps with Python: Part 1'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[](/visualizing-routes-on-interactive-maps-with-python-part-1-44f8d25d0761?source=post_page-----dbb44e7d30b9--------------------------------)
    [## 使用Python在互动地图上可视化路线：第一部分'
- en: A pragmatic guide to interactive data visualization for transportation problems
    with Folium
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一份有关运输问题的互动数据可视化的务实指南，使用Folium
- en: towardsdatascience.com](/visualizing-routes-on-interactive-maps-with-python-part-1-44f8d25d0761?source=post_page-----dbb44e7d30b9--------------------------------)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: towardsdatascience.com](/visualizing-routes-on-interactive-maps-with-python-part-1-44f8d25d0761?source=post_page-----dbb44e7d30b9--------------------------------)
- en: '*Footnotes*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*脚注*'
- en: The benefits of this separation will become apparent in future sprints for problems
    that extend the TSP. [↩](#7894)
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种分离的好处将在未来的冲刺中变得明显，特别是针对扩展TSP的问题。[↩](#7894)
- en: 'Because our class will optimize decisions, not estimate parameters. There’s
    a subtle difference. Granted, `scikit-learn` estimators do carry out an optimization
    under the hood during model training, but the distinction still matters because
    **optimization means different things in Machine Learning and in Operations Research**.
    An *estimator* uses optimization to ***estimate*** the unknown values of the *model
    parameters*, while an *optimizer* uses optimization to ***find*** the optimum
    values of the variables representing *decisions* we need to make. Inside estimators,
    the objective function is always a *loss function,* which measures **the extent
    to which a *predicted* outcome differs from a *true* outcome**. In optimizers
    (or more generally, in OR models) **the objective function** can be arbitrary,
    as it i**s a measure of *our* desired global state of the world**,dependent on
    our decisions. In other words: *in Machine Learning, we seek the* ***optimal model
    parameters*** *that produce the* ***best generalization*** *of the data* we have.
    *In Operations Research*, however, our possible actions are represented in the
    models, so *we seek the* ***optimal actions*** *that will produce the* ***best
    outcome*** *given the resources we have.* The key distinction is that there''s
    no such thing as "true decisions" that need to be "estimated from data" through
    optimization techniques. **Decisions are prescribed *given* the data, not estimated
    *from* the data**. [↩](#c61f)'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们的课程将优化决策，而不是估计参数。两者有微妙的差别。确实，`scikit-learn` 估算器在模型训练期间确实会进行优化，但这种区别仍然很重要，因为
    **优化在机器学习和运筹学中的意义不同**。一个 *估算器* 使用优化来 ***估计*** *模型参数* 的未知值，而一个 *优化器* 使用优化来 ***找到***
    代表我们需要做的 *决策* 的最佳值。在估算器中，目标函数始终是 *损失函数*，它衡量 **预测结果与真实结果之间的差异程度**。在优化器中（或更一般地，在运筹学模型中）**目标函数**
    可以是任意的，因为它 **是衡量我们所期望的全球状态的标准**，取决于我们的决策。换句话说：*在机器学习中，我们寻找* ***最佳模型参数*** *以产生*
    ***最佳泛化*** *的数据*。然而，*在运筹学中*，我们的可能行动被表示在模型中，因此 *我们寻找* ***最佳行动*** *以产生* ***最佳结果***
    *在我们拥有的资源下*。关键区别在于没有所谓的“真实决策”需要通过优化技术从数据中“估计”出来。**决策是根据数据给出的，而不是从数据中估计的**。[↩](#c61f)
- en: 'This can happen only due to [two reasons](https://en.wikipedia.org/wiki/Linear_programming#:~:text=An%20optimal%20solution%20need,of%20the%20objective%20function.):
    the model is *infeasible* (the most common), or the model is *unbounded* (less
    common, but possible). [↩](#97f0)'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '这只能因为 [两个原因](https://en.wikipedia.org/wiki/Linear_programming#:~:text=An%20optimal%20solution%20need,of%20the%20objective%20function.):
    模型是 *不可行*（最常见），或者模型是 *无界*（较少见，但可能）。[↩](#97f0)'
- en: That’s why, when reading the input coordinates into a dataframe, we read the
    coordinates of the hotel first. [↩](#d459)
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是为什么，在将输入坐标读入数据框时，我们首先读取酒店的坐标。[↩](#d459)
- en: It is a [technical requirement](https://medium.com/@carlosjuribe/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c#:~:text=It%E2%80%99s%20crucial%20that,variable%3A%20the%20hotel)
    that *exactly* one of the sites does not have an associated rank variable (it
    doesn’t matter which, but generally the “initial site” is picked). As the hotel
    was in the index of the first row of `df_distances`, it was considered the initial
    site and stored inside the Pyomo model (see attribute `tsp.model.initial_site`)
    without an associated rank variable. Remember that the job of the ranks rᵢ is
    *not* to indicate the order of visits (that's inherent in 𝛿ᵢⱼ), but only to prevent
    the formation of subtours. [↩](#7f87)
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个 [技术要求](https://medium.com/@carlosjuribe/plan-optimal-trips-automatically-with-python-and-operations-research-models-part-2-fc7ee8198b6c#:~:text=It%E2%80%99s%20crucial%20that,variable%3A%20the%20hotel)
    *准确* 地说，其中一个站点没有相关的排名变量（哪一个无关紧要，但通常选择“初始站点”）。由于酒店在 `df_distances` 的第一行的索引中，因此被认为是初始站点并存储在
    Pyomo 模型中（见属性 `tsp.model.initial_site`），没有相关的排名变量。请记住，排名 rᵢ 的工作是 *不是* 指示访问顺序（这在
    𝛿ᵢⱼ 中固有），而仅仅是防止形成子巡回。[↩](#7f87)
- en: Thanks for reading, and see you in [the next one](/visualizing-routes-on-interactive-maps-with-python-part-1-44f8d25d0761)!
    📈😊
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢阅读，下一篇文章见 [这里](/visualizing-routes-on-interactive-maps-with-python-part-1-44f8d25d0761)!
    📈😊
- en: Feel free to follow me, ask me questions, **give me feedback**, or contact me
    on [LinkedIn](https://www.linkedin.com/in/carlosjuribe/).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 随时可以关注我，向我提问，**给我反馈**，或通过 [LinkedIn](https://www.linkedin.com/in/carlosjuribe/)
    联系我。
