["```py\nconda install -y -c conda-forge pyomo=6.5.0 pandas networkx glpk\n```", "```py\nname: ttp  # traveling tourist problem\nchannels:\n  - conda-forge\ndependencies:\n  - python=3.9\n  - pyomo=6.5.0\n  - pandas\n  - networkx\n  - glpk  # external solver used to optimize models\n  - jupyterlab  # comment this line if you won't use Jupyter Lab as IDE\n```", "```py\nconda env create --file environment.yml\n```", "```py\n### =====  Code block 3.1  ===== ###\nimport pandas as pd\nimport pyomo.environ as pyo\nimport pyomo.version\nimport networkx as nx\n\nsolver = pyo.SolverFactory(\"glpk\")\nsolver_available = solver.available(exception_flag=False)\nprint(f\"Solver '{solver.name}' available: {solver_available}\")\n\nif solver_available:\n    print(f\"Solver version: {solver.version()}\")\n\nprint(\"pyomo version:\", pyomo.version.__version__)\nprint(\"networkx version:\", nx.__version__)\n```", "```py\nSolver 'glpk' available: True\nSolver version: (5, 0, 0, 0)\npyomo version: 6.5\nnetworkx version: 2.8.4\n```", "```py\n### =====  Code block 3.2  ===== ###\npath_data = (\n    \"https://raw.githubusercontent.com/carlosjuribe/\"\n    \"traveling-tourist-problem/main/\"\n    \"Paris_sites_spherical_distance_matrix.csv\"\n)\ndf_distances = pd.read_csv(path_data, index_col=\"site\")\n\ndf_distances\n```", "```py\nmodel = pyo.ConcreteModel(\"TSP\")\n```", "```py\n### =====  Code block 3.3  ===== ###\nlist_of_sites = df_distances.index.tolist()\n\nmodel.sites = pyo.Set(initialize=list_of_sites, \n                      domain=pyo.Any, \n                      doc=\"set of all sites to be visited (𝕊)\")\n```", "```py\n### =====  Code block 3.4  ===== ###\ndef _rule_domain_arcs(model, i, j):\n    \"\"\" All possible arcs connecting the sites (𝔸) \"\"\"\n    # only create pair (i, j) if site i and site j are different\n    return (i, j) if i != j else None \n\nrule = _rule_domain_arcs\nmodel.valid_arcs = pyo.Set(\n    initialize=model.sites * model.sites,  # 𝕊 × 𝕊\n    filter=rule, doc=rule.__doc__)\n```", "```py\n### =====  Code block 3.5  ===== ###\ndef _rule_distance_between_sites(model, i, j):\n    \"\"\" Distance between site i and site j (𝐷𝑖𝑗) \"\"\"\n    return df_distances.at[i, j]  # fetch the distance from dataframe\n\nrule = _rule_distance_between_sites\nmodel.distance_ij = pyo.Param(model.valid_arcs, \n                              initialize=rule, \n                              doc=rule.__doc__)\n```", "```py\nmodel.delta_ij = pyo.Var(model.valid_arcs, within=pyo.Binary, \n                         doc=\"Whether to go from site i to site j (𝛿𝑖𝑗)\")\n```", "```py\n### =====  Code block 3.6  ===== ###\ndef _rule_total_distance_traveled(model):\n    \"\"\" total distance traveled \"\"\"\n    return pyo.summation(model.distance_ij, model.delta_ij)\n\nrule = _rule_total_distance_traveled\nmodel.obj_total_distance = pyo.Objective(rule=rule, \n                                         sense=pyo.minimize, \n                                         doc=rule.__doc__)\n```", "```py\ndef _rule_site_is_entered_once(model, j):\n    \"\"\" each site j must be visited from exactly one other site \"\"\"\n    return sum(model.delta_ij[i, j] for i in model.sites if i != j) == 1\n\nrule = _rule_site_is_entered_once\nmodel.constr_each_site_is_entered_once = pyo.Constraint(\n                                          model.sites, \n                                          rule=rule, \n                                          doc=rule.__doc__)\n```", "```py\ndef _rule_site_is_exited_once(model, i):\n    \"\"\" each site i must departure to exactly one other site \"\"\"\n    return sum(model.delta_ij[i, j] for j in model.sites if j != i) == 1\n\nrule = _rule_site_is_exited_once\nmodel.constr_each_site_is_exited_once = pyo.Constraint(\n                                          model.sites, \n                                          rule=rule, \n                                          doc=rule.__doc__)\n```", "```py\ndef print_model_info(model):\n    print(f\"Name: {model.name}\", \n          f\"Num variables: {model.nvariables()}\",\n          f\"Num constraints: {model.nconstraints()}\", sep=\"\\n- \")\n\nprint_model_info(model)\n\n#[Out]:\n# Name: TSP\n#  - Num variables: 72\n#  - Num constraints: 18\n```", "```py\nres = solver.solve(model)  # optimize the model\nprint(f\"Optimal solution found: {pyo.check_optimal_termination(res)}\")\n# [Out]: Optimal solution found: True\n```", "```py\n### =====  Code block 3.7  ===== ###\ndef extract_solution_as_arcs(model):\n    \"\"\" Extract list of active (selected) arcs from the solved model,\n    by keeping only the arcs whose binary variables are 1 \"\"\"\n    active_arcs = [(i, j)\n                   for i, j in model.valid_arcs\n                   if model.delta_ij[i, j].value == 1]\n    return active_arcs\n\ndef plot_arcs_as_graph(tour_as_arcs):\n    \"\"\" Take in a list of tuples representing arcs, convert it \n    to a networkx graph and draw it\n    \"\"\"\n    G = nx.DiGraph()\n    G.add_edges_from(tour_as_arcs)  # store solution as graph\n\n    node_colors = ['red' if node == 'hotel' else 'skyblue' \n                   for node in G.nodes()]\n    nx.draw(G, node_color=node_colors, with_labels=True, font_size=6, \n            node_shape='o', arrowsize=5, style='solid')\n\ndef plot_solution_as_graph(model):\n    \"\"\" Plot the solution of the given model as a graph \"\"\"\n    print(f\"Total distance: {model.obj_total_distance()}\")\n\n    active_arcs = extract_solution_as_arcs(model)\n    plot_arcs_as_graph(active_arcs)\n```", "```py\nplot_solution_as_graph(model)\n```", "```py\nmodel.sites_except_hotel = pyo.Set(\n    initialize=model.sites - {'hotel'}, \n    domain=model.sites,\n    doc=\"Sites of interest, i.e., all sites except the hotel (𝕊*)\"\n)\n```", "```py\nmodel.M = pyo.Param(initialize=1 - len(model.sites_except_hotel),\n                    doc=\"big M to make some constraints redundant\")\n```", "```py\nmodel.rank_i = pyo.Var(\n    model.sites_except_hotel,  # i ∈ 𝕊* (index)\n    within=pyo.NonNegativeReals,  # rᵢ ∈ ℝ₊ (domain)\n    bounds=(1, len(model.sites_except_hotel)),  # 1 ≤ rᵢ ≤ |𝕊*|\n    doc=\"Rank of each site to track visit order\"\n)\n```", "```py\ndef _rule_path_is_single_tour(model, i, j):\n    \"\"\" For each pair of non-hotel sites (i, j), \n    if site j is visited from site i, the rank of j must be \n    strictly greater than the rank of i. \"\"\"\n    if i == j:  # if sites coincide, skip creating a constraint\n        return pyo.Constraint.Skip\n\n    r_i = model.rank_i[i]\n    r_j = model.rank_i[j]\n    delta_ij = model.delta_ij[i, j]\n    return r_j >= r_i + delta_ij + (1 - delta_ij) * model.M\n\n# cross product of non-hotel sites, to index the constraint\nnon_hotel_site_pairs = model.sites_except_hotel * model.sites_except_hotel\n\nrule = _rule_path_is_single_tour\nmodel.constr_path_is_single_tour = pyo.Constraint(\n    non_hotel_site_pairs,\n    rule=rule, \n    doc=rule.__doc__)\n```", "```py\nprint_model_info(model)\n# [Out]:\n# Name: TSP\n#  - Num variables: 80\n#  - Num constraints: 74\n```", "```py\nres = solver.solve(model)  # optimize the model\nsolution_found = pyo.check_optimal_termination(res)\nprint(f\"Optimal solution found: {solution_found}\")\n# [Out]: Optimal solution found: True\n\nif solution_found:\n    plot_solution_as_graph(model)\n```"]