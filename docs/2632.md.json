["```py\ndef search_top_k_merge_list(index, sets, q, k):\n    \"\"\"Search top-k Jaccard using inverted index.\n\n    Args:\n        index: an inverted index, key is set element\n        sets: a lookup table for sets, key is set ID\n        q: a query set\n        k: search parameter k\n\n    Returns:\n        list: at most k set IDs.\n    \"\"\"\n    # Intialize an empty lookup table for candidates.\n    candidates = defaultdict(0)\n\n    # Iterate over set elements in q.\n    for x in q:\n        ids = index[x]  # Get a list of set IDs from the index.\n        for id in ids:\n            candidates[id] += 1  # Increment count for intersection size.\n\n    # Now candidates[id] stores the intersection size of set with ID id.\n\n    # A simple routine for calculating Jaccard using intersection size and\n    # set sizes, based on Inclusion-Exclusion principle.\n    jaccard = lambda id: candidates[id] / (len(q) + len(sets(id) - candidates[id]))\n\n    # Find the top-k candidates order by Jaccard.\n    return sorted(list(candidates.keys()), key=jaccard, reverse=True)[:k]\n```", "```py\nimport heapq\n\ndef search_top_k_probe_set(index, sets, q, k):\n    # Initialize a priority heap to store the current top-k candidates.\n    heap = []\n\n    # Initialize a set for tracking probed candidates.\n    seen_ids = set()\n\n    # Iterate over elements in q from the least to the most frequent based\n    # on the lengths of their lists in the inverted index.\n    for i, x in enumerate(sorted(q, key=lambda x: len(index[x]))):\n        ids = index[x] # Get a list of set IDs from the index.\n        for id in ids:\n            if id in seen_ids:\n                continue  # Skip seen candidate.\n            s = sets[id]\n            intersect_size = len(q.intersection(s))\n            jaccard = intersect_size / (len(q) + len(s) - intersect_size)\n            # Add the candidate to the priority heap.\n            if len(heap) < k:\n                heapq.heappush(heap, (jaccard, id))\n            else:\n                # Only candidates with higher Jaccard than the k-th\n                # current candidate will be added in this operation.\n                heapq.heappushpop(heap, (jaccard, id))\n            seen_ids.add(id)\n        # If any new candidate from the remaining lists cannot have higher\n        # Jaccard than any of the current best k candidates, we do not need\n        # to do any more work.\n        if (len(q) - i - 1) / len(q) (<= min(heap)[0]:\n            break\n\n    # Return the best k candidates.\n    return [id for _, id in heapq.nlargest(k, heap)]\n```"]