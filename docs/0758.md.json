["```py\n# Import the required packages\nimport numpy as np\nfrom scipy.fft import fft, rfft\nfrom scipy.fft import fftfreq, rfftfreq\nimport plotly.graph_objs as go\nfrom plotly.subplots import make_subplots\nimport matplotlib.pyplot as plt\n%matplotlib inline\n```", "```py\n# Generate the three signals using Signal class and its method sine()\nsignal_1hz = Signal(amplitude=3, frequency=1, sampling_rate=200, duration=2)\nsine_1hz = signal_1hz.sine()\nsignal_20hz = Signal(amplitude=1, frequency=20, sampling_rate=200, duration=2)\nsine_20hz = signal_20hz.sine()\nsignal_10hz = Signal(amplitude=0.5, frequency=10, sampling_rate=200, duration=2)\nsine_10hz = signal_10hz.sine()\n\n# Sum the three signals to output the signal we want to analyze\nsignal = sine_1hz + sine_20hz + sine_10hz\n\n# Plot the signal\nplt.plot(signal_1hz.time_axis, signal, 'b')\nplt.xlabel('Time [sec]')\nplt.ylabel('Amplitude')\nplt.title('Sum of three signals')\nplt.show()\n```", "```py\n# Apply the FFT on the signal\nfourier = fft(signal)\n\n# Plot the result (the spectrum |Xk|)\nplt.plot(np.abs(fourier))\nplt.show()\n```", "```py\n# Calculate N/2 to normalize the FFT output\nN = len(signal)\nnormalize = N/2\n\n# Plot the normalized FFT (|Xk|)/(N/2)\nplt.plot(np.abs(fourier)/normalize)\nplt.ylabel('Amplitude')\nplt.xlabel('Samples')\nplt.title('Normalized FFT Spectrum')\nplt.show()\n```", "```py\n# Get the frequency components of the spectrum\nsampling_rate = 200.0 # It's used as a sample spacing\nfrequency_axis = fftfreq(N, d=1.0/sampling_rate)\nnorm_amplitude = np.abs(fourier)/normalize\n# Plot the results\nplt.plot(frequency_axis, norm_amplitude)\nplt.xlabel('Frequency[Hz]')\nplt.ylabel('Amplitude')\nplt.title('Spectrum')\nplt.show()\n```", "```py\n# Plot the frequency axis for more explanation\nplt.plot(frequency_axis)\nplt.ylabel('Frequency[Hz]')\nplt.title('Frequency Axis')\nplt.show()\n```", "```py\n# Calculate the time execution of (fft)\nprint('Execution time of fft function:')\n%timeit fft(signal)\n# Calculate the time execution of (rfft)\nprint('\\nExecution time of rfft function:')\n%timeit rfft(signal)\n```", "```py\nExecution time of fft function:\n13.5 µs ± 8.3 µs per loop (mean ± std. dev. of 7 runs, 100000 loops each)\n\nExecution time of rfft function:\n12.3 µs ± 3.55 µs per loop (mean ± std. dev. of 7 runs, 100000 loops each)\n```", "```py\n# Plot the actual spectrum of the signal\nplt.plot(rfftfreq(N, d=1/sampling_rate), 2*np.abs(rfft(signal))/N)\nplt.title('Spectrum')\nplt.xlabel('Frequency[Hz]')\nplt.ylabel('Amplitude')\nplt.show()\n```", "```py\n# Building a class Fourier for better use of Fourier Analysis.\nclass Fourier:\n  \"\"\"\n  Apply the Discrete Fourier Transform (DFT) on the signal using the Fast Fourier \n  Transform (FFT) from the scipy package.\n\n  Example:\n    fourier = Fourier(signal, sampling_rate=2000.0)\n  \"\"\"\n\n  def __init__(self, signal, sampling_rate):\n    \"\"\"\n    Initialize the Fourier class.\n\n    Args:\n        signal (np.ndarray): The samples of the signal\n        sampling_rate (float): The sampling per second of the signal\n\n    Additional parameters,which are required to generate Fourier calculations, are\n    calculated and defined to be initialized here too:\n        time_step (float): 1.0/sampling_rate\n        time_axis (np.ndarray): Generate the time axis from the duration and\n                              the time_step of the signal. The time axis is\n                              for better representation of the signal.\n        duration (float): The duration of the signal in seconds.\n        frequencies (numpy.ndarray): The frequency axis to generate the spectrum.\n        fourier (numpy.ndarray): The DFT using rfft from the scipy package.\n    \"\"\"\n    self.signal = signal\n    self.sampling_rate = sampling_rate\n    self.time_step = 1.0/self.sampling_rate\n    self.duration = len(self.signal)/self.sampling_rate\n    self.time_axis = np.arange(0, self.duration, self.time_step)\n    self.frequencies = rfftfreq(len(self.signal), d = self.time_step)\n    self.fourier = rfft(self.signal)\n\n  # Generate the actual amplitudes of the spectrum\n  def amplitude(self):\n    \"\"\"\n    Method of Fourier\n\n    Returns:\n        numpy.ndarray of the actual amplitudes of the sinusoids.\n    \"\"\"\n    return 2*np.abs(self.fourier)/len(self.signal)\n\n  # Generate the phase information from the output of rfft  \n  def phase(self, degree = False):\n    \"\"\"\n    Method of Fourier\n\n    Args:\n        degree: To choose the type of phase representation (Radian, Degree).\n                By default, it's in radian. \n\n    Returns:\n        numpy.ndarray of the phase information of the Fourier output.\n    \"\"\"\n    return np.angle(self.fourier, deg = degree)\n\n  # Plot the spectrum\n  def plot_spectrum(self, interactive=False):\n    \"\"\"\n    Plot the Spectrum (Frequency Domain) of the signal either using the matplotlib\n    package, or plot it interactive using the plotly package.\n\n    Args:\n        interactive: To choose if you want the plot interactive (True), or not\n        (False). The default is the spectrum non-interactive.\n\n    Retruns:\n        A plot of the spectrum.\n    \"\"\"\n    # When the argument interactive is set to True:\n    if interactive:\n      self.trace = go.Line(x=self.frequencies, y=self.amplitude())\n      self.data = [self.trace]\n      self.layout = go.Layout(title=dict(text='Spectrum',\n                                         x=0.5,\n                                         xanchor='center',\n                                         yanchor='top',\n                                         font=dict(size=25, family='Arial, bold')),\n                              xaxis=dict(title='Frequency[Hz]'),\n                              yaxis=dict(title='Amplitude'))\n      self.fig = go.Figure(data=self.data, layout=self.layout)\n      return self.fig.show()\n    # When the argument interactive is set to False:\n    else:\n      plt.figure(figsize = (10,6))\n      plt.plot(self.frequencies, self.amplitude())\n      plt.title('Spectrum')\n      plt.ylabel('Amplitude')\n      plt.xlabel('Frequency[Hz]')\n\n  # Plot the Signal and the Spectrum interactively\n  def plot_time_frequency(self, t_ylabel=\"Amplitude\", f_ylabel=\"Amplitude\",\n                          t_title=\"Signal (Time Domain)\",\n                          f_title=\"Spectrum (Frequency Domain)\"):\n    \"\"\"\n    Plot the Signal in Time Domain and Frequency Domain using plotly.\n\n    Args:\n        t_ylabel (String): Label of the y-axis in Time-Domain\n        f_ylabel (String): Label of the y-axis in Frequency-Domain\n        t_title (String): Title of the Time-Domain plot\n        f_title (String): Title of the Frequency-Domain plot \n\n    Returns:\n        Two figures: the first is the time-domain, and the second is the\n                     frequency-domain.\n    \"\"\"\n    # The Signal (Time-Domain)\n    self.time_trace = go.Line(x=self.time_axis, y=self.signal)\n    self.time_domain = [self.time_trace]\n    self.layout = go.Layout(title=dict(text=t_title,\n                                       x=0.5,\n                                       xanchor='center',\n                                       yanchor='top',\n                                       font=dict(size=25, family='Arial, bold')),\n                            xaxis=dict(title='Time[sec]'),\n                            yaxis=dict(title=t_ylabel),\n                            width=1000,\n                            height=400)\n    fig = go.Figure(data=self.time_domain, layout=self.layout)\n    fig.show()\n    # The Spectrum (Frequency-Domain)\n    self.freq_trace = go.Line(x=self.frequencies, y=self.amplitude())\n    self.frequency_domain = [self.freq_trace]\n    self.layout = go.Layout(title=dict(text=f_title,\n                                       x=0.5,\n                                       xanchor='center',\n                                       yanchor='top',\n                                       font=dict(size=25, family='Arial, bold')),\n                            xaxis=dict(title='Frequency[Hz]'),\n                            yaxis=dict(title=f_ylabel),\n                            width=1000,\n                            height=400)\n    fig = go.Figure(data=self.frequency_domain, layout=self.layout)\n    fig.show()\n```", "```py\n# Apply the DFT using the class Fourier\nfourier = Fourier(signal, sampling_rate=200)\n# Plot the spectrum interactively using the class Fourier\nfourier.plot_spectrum(interactive=True)\n```", "```py\n# Import the ECG signal from scipy package\nfrom scipy.misc import electrocardiogram\n# Built-in ECG signal\necg = electrocardiogram()\n# DFT using the class Fourier\necg_spectrum = Fourier(signal = ecg, sampling_rate = 360.0)\n# Plot the time-frequency domains of the ECG signal\necg_spectrum.plot_time_frequency(t_title=\"ECG Signal\", f_title=\"ECG Spectrum\",\n                                 t_ylabel=\"Amplitude[mV]\")\n```"]