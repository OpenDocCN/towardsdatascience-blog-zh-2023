- en: How Cypher changed in Neo4j v5
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/how-cypher-changed-in-neo4j-v5-d0f10cbb60bf?source=collection_archive---------10-----------------------#2023-01-17](https://towardsdatascience.com/how-cypher-changed-in-neo4j-v5-d0f10cbb60bf?source=collection_archive---------10-----------------------#2023-01-17)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What’s new and what’s been deprecated in Cypher in the latest release of Neo4j
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://bratanic-tomaz.medium.com/?source=post_page-----d0f10cbb60bf--------------------------------)[![Tomaz
    Bratanic](../Images/d5821aa70918fcb3fc1ff0013497b3d5.png)](https://bratanic-tomaz.medium.com/?source=post_page-----d0f10cbb60bf--------------------------------)[](https://towardsdatascience.com/?source=post_page-----d0f10cbb60bf--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----d0f10cbb60bf--------------------------------)
    [Tomaz Bratanic](https://bratanic-tomaz.medium.com/?source=post_page-----d0f10cbb60bf--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: ·
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F57f13c0ea39a&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-cypher-changed-in-neo4j-v5-d0f10cbb60bf&user=Tomaz+Bratanic&userId=57f13c0ea39a&source=post_page-57f13c0ea39a----d0f10cbb60bf---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----d0f10cbb60bf--------------------------------)
    ·9 min read·Jan 17, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fd0f10cbb60bf&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-cypher-changed-in-neo4j-v5-d0f10cbb60bf&user=Tomaz+Bratanic&userId=57f13c0ea39a&source=-----d0f10cbb60bf---------------------clap_footer-----------)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fd0f10cbb60bf&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-cypher-changed-in-neo4j-v5-d0f10cbb60bf&source=-----d0f10cbb60bf---------------------bookmark_footer-----------)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: A couple of weeks ago, Neo4j 5 was released. If you are like me and have ignored
    all the deprecation warnings during the later Neo4j 4 version, you might have
    to update your Cypher queries to work with the latest Neo4j version. Luckily,
    there are no significant differences in the new Cypher syntax, so the update process
    should not be difficult. However, I have decided to write this blog post to help
    you transition. Additionally, I will introduce some of the new Cypher syntax that
    could simplify your queries.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: The Cypher examples of this blog post are available as a [Jupyter Notebook on
    GitHub](https://github.com/tomasonjo/blogs/blob/master/dune/Cypher_v5.ipynb).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Neo4j environment setup
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need to set up a Neo4j environment to follow the code examples in this
    post. As always, you can set up a local environment by using the [Neo4j Desktop](https://neo4j.com/download/)
    application. On the other hand, you can use a free cloud instance available as
    [Neo4j Aura](https://neo4j.com/cloud/platform/aura-graph-database/). If you choose
    the Neo4j Aura route, use the free forever instance and start a blank project
    that doesn’t come with a pre-populated graph.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '*p.s. The free forever Neo4j Aura instance does not offer GDS support. Since
    this is a Cypher focused blog post, you won’t be using any algorithms from the
    GDS library.*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Dataset
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I have a special place in my heart for fantasy or superhero datasets. This time,
    I found a dataset describing characters in the Dune series.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://www.kaggle.com/datasets/bac3917/frank-herberts-dune-characters?source=post_page-----d0f10cbb60bf--------------------------------)
    [## Frank Herbert''s DUNE Characters'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Social networks in a fantastic world.... help build the dataset!
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: www.kaggle.com](https://www.kaggle.com/datasets/bac3917/frank-herberts-dune-characters?source=post_page-----d0f10cbb60bf--------------------------------)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: The Dune dataset is available on Kaggle under the CC0 license. To make it easier
    for you, I have copied the dataset to a GitHub repository, so you don’t have to
    download the dataset and can easily import it in either your local or cloud instance
    of Neo4j. Additionally, I have renamed the relationship types Parent-Child and
    Other Family to Family, and removed the Unknown relation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Graph Model
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/69e0591fd901d85c38e73fcbfe314b2e.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: Dune graph model. Image by the author.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'The graph model revolves around characters. The character nodes have multiple
    properties like the name, Culture, and when they were Born or Died. Additionally,
    their house allegiance is represented as a secondary node label. The main idea
    for using the secondary node label instead of a separate node is to demonstrate
    the new node label filtering options in Cypher. There are four types of relationships
    between characters:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: ALLIES
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ENEMIES,
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FAMILY
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MARRIAGE
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dataset import
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with most imports, you first want to define unique constraints in Neo4j.
    Unique constraints ensure that a given property is unique for every node with
    a particular label.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: The syntax for defining unique constraints has slightly changed in Neo4j v5.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/257dd08e5bcb1aa5a02b759bf6977287.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: Syntax change for UNIQUE CONSTRAINTS. Image by the author.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: The new syntax for unique constraints has two keywords replaced. The **ON**
    keyword is replaced with **FOR**, while the **ASSERT** is changed to **REQUIRE**.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The following Cypher statements define the unique constraint for **name** property
    of **Character** nodes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, you need to import the CSV file. Even though the Dune CSV file has only
    1000 rows, you will pretend you are dealing with a large CSV file with many thousands
    of rows. Therefore, you want to use batch import into multiple transactions. As
    **USING PERIODIC COMMIT** clause has been deprecated in Neo4j v5, you need to
    use the new batched transaction syntax.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要导入 CSV 文件。尽管 Dune CSV 文件只有 1000 行，但你将假设你正在处理一个具有数千行的大型 CSV 文件。因此，你希望将批量导入分成多个事务。由于
    Neo4j v5 中**USING PERIODIC COMMIT**子句已被弃用，你需要使用新的批处理事务语法。
- en: '![](../Images/7b8afdda43d5009b5e07a8bf3cd7691f.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7b8afdda43d5009b5e07a8bf3cd7691f.png)'
- en: Syntax change for importing large CSV files. Image by the author.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 导入大型 CSV 文件的语法更改。图片由作者提供。
- en: The subqueries were already introduced in Neo4j v4 but have taken on a more
    prominent role in v5\. The subqueries are instantiated with a **CALL** clause
    and wrapped with curly brackets **{}**. They are great for various functionalities
    like [post-union processing](https://neo4j.com/developer/kb/post-union-processing/),
    [limiting results per row](https://neo4j.com/developer/kb/limiting-match-results-per-row/),
    and [conditional execution](https://neo4j.com/developer/kb/conditional-cypher-execution/).
    Additionally, the Cypher subqueries are now the only native Cypher syntax (excluding
    APOC) to batch a single Cypher statement into multiple transactions. In order
    to specify that the Cypher subquery should be split into multiple transactions,
    you need to add **IN** **TRANSACTIONS OF x ROWS**, where the x represents the
    number of rows for each batch.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 子查询已经在 Neo4j v4 中引入，但在 v5 中发挥了更重要的作用。子查询通过**CALL**子句实例化，并用花括号**{}**包裹。它们非常适合各种功能，如[后联合处理](https://neo4j.com/developer/kb/post-union-processing/)、[限制每行结果](https://neo4j.com/developer/kb/limiting-match-results-per-row/)、以及[条件执行](https://neo4j.com/developer/kb/conditional-cypher-execution/)。此外，Cypher
    子查询现在是唯一的原生 Cypher 语法（不包括 APOC），可以将单个 Cypher 语句批处理成多个事务。为了指定 Cypher 子查询应拆分成多个事务，你需要添加**IN
    TRANSACTIONS OF x ROWS**，其中 x 代表每个批次的行数。
- en: The following Cypher statement contains two nested subqueries. The top-level
    subquery is used to batch the import into a new transaction for every 10 rows.
    On the other hand, you use the nested Cypher subquery as a conditional execution
    feature.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 Cypher 语句包含两个嵌套的子查询。顶层子查询用于将每10行的导入批处理到一个新事务中。另一方面，你可以将嵌套的 Cypher 子查询用作条件执行功能。
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The import query is a bit more complicated because I wanted to do the import
    in a single Cypher statement. It starts with the **LOAD CSV** clause that you
    might have seen before. In order to batch the import into multiple transactions,
    you need to initiate a Cypher subquery with the **CALL** clause. The top-level
    subquery ends with the **IN TRANSACTIONS OF x ROWS** clause, which specifies the
    transaction batching.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 导入查询稍微复杂一些，因为我希望在一个 Cypher 语句中完成导入。它以你可能见过的**LOAD CSV**子句开始。为了将导入批处理成多个事务，你需要使用**CALL**子句来启动
    Cypher 子查询。顶层子查询以**IN TRANSACTIONS OF x ROWS**子句结束，该子句指定了事务批处理。
- en: If you want to use any variable in the Cypher statement, you must explicitly
    import it with the **WITH** clause. First, the top-level subquery import the **row**
    variable from the outer query. Next, it merges the Character node and sets a couple
    of properties. Since adding dynamic secondary labels is not supported in plain
    Cypher, you can use the APOC’s procedure.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在 Cypher 语句中使用任何变量，你必须通过**WITH**子句显式导入它。首先，顶层子查询从外部查询中导入**row**变量。接着，它合并
    Character 节点并设置几个属性。由于纯 Cypher 中不支持动态的次级标签，你可以使用 APOC 的过程。
- en: Some of the Dune characters have additional relationships defined in the **to**
    and **relationship_type** columns of the CSV. On the other hand, the **to** and
    **relationship_type** columns are empty for several rows. The [FOREACH conditional
    execution trick](https://neo4j.com/developer/kb/conditional-cypher-execution/#_using_foreach_for_write_only_cypher)
    was my go-to option for the better part of my blog post. However, as the theme
    of this blog post are Cypher subqueries, I have decided to show you how to use
    Cypher subqueries for conditional execution. First, with the nested Cypher subquery,
    you need to import both the **row** and the **c** variables. Next, you need to
    filter out only rows where the **to** column is not null. However, you cannot
    filter variables in the same **WITH** clause used to import them. Therefore, you
    need to add a second **WITH** clause to filter rows. Lastly, you use the APOC’s
    procedure for merging relationships, as the plain Cypher syntax does not support
    creating properties with dynamic relationship types.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: You can check out the [documentation](https://neo4j.com/docs/cypher-manual/current/clauses/call-subquery)
    if this example was a bit too packed for you.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: New inline filtering options
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many new options available for inline filtering in Neo4j v5\. So what
    exactly is inline filtering? Essentially, it is the ability to filter a graph
    pattern directly in the **MATCH** clause.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: You will begin by learning the new syntax for filtering node labels. In Neo4j
    v5, the following logical expressions were introduced to allow more flexible node
    filtering.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '& — AND expression'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| — OR expression'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '! — NOT expression'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, if you want to match all nodes with either the **Fremen** or **Harkonnen**
    label, you can use the **|** expression.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: On the other hand, if you need to find all nodes with both the **Character**
    and **Harkonnen** labels, you can use the **&** expression.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The **!** expression allows you to negate node labels. For example, say that
    you want to match all nodes with **the Character** label but don’t have the **Harkonnen**
    label.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The Cypher now also supports nested expressions for filtering node labels. For
    example, the following Cypher statement matches all nodes that don’t have the
    **Fremen** or the **Harkonnen** labels.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The expressions are nested using the parenthesis ().
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Another feature added to Cypher is the option to include the **WHERE** clause
    within the **MATCH** clause. This allows you to apply all the flexibility of the
    Cypher filtering by node properties directly within the MATCH statement.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: For example, the following Cypher statement matches all characters where the
    **Culture** property starts with **Z** and the **Died** property is **not null**.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The same logical expressions used to filter nodes can also be used when filtering
    relationship types. For example, the **|** expression, which expresses the logical
    OR, has been in Cypher for quite some time.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: The following Cypher statement matches all **Character** nodes with the **Culture**
    property values of **Bene Gesserit** and expands their **ALLIES** or **FAMILY**
    relationships.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 Cypher 语句匹配所有**Character**节点，其**Culture**属性值为**Bene Gesserit**，并展开它们的**ALLIES**或**FAMILY**关系。
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using only the **&** expression does not really make sense as a single relationship
    cannot have more than one type. However, the combined with the negation **!**
    expression the **&** can come in handy.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用**&**表达式实际上没有什么意义，因为单个关系不能有多个类型。然而，与否定**!**表达式结合使用时，**&**可能会很有用。
- en: For example, the following Cypher statement expands all relationships that are
    not **ALLIES** or **FAMILY**.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下 Cypher 语句展开所有不是**ALLIES**或**FAMILY**的关系。
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Existential subqueries
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存在性子查询
- en: Next, you will learn how the syntax for existential subqueries changed. An existential
    subquery can be used to find graph patterns that are part of a specified pattern.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将了解存在性子查询的语法如何更改。存在性子查询可以用来查找属于指定模式的图模式。
- en: '![](../Images/cdda2ff1dd224d5ac59bca2ccae4347d.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/cdda2ff1dd224d5ac59bca2ccae4347d.png)'
- en: Syntax change for existential filters. Image by the author.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 存在性过滤器的语法更改。图片由作者提供。
- en: In this example, the existential subquery is used to find **Character** nodes
    that have either incoming or outgoing **FAMILY** relationships. I am a fan of
    existential subqueries as they offer the flexibility to filter nodes based on
    any graph patterns without having to expand them in the MATCH clause and worry
    about query cardinality (number of rows). In Neo4j v5, you have to add the **EXISTS**
    clause and wrap the specified graph pattern used for filtering with curly brackets
    in order to execute existential subqueries.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，存在性子查询用于查找具有进或出**FAMILY**关系的**Character**节点。我喜欢存在性子查询，因为它们提供了根据任何图模式过滤节点的灵活性，而无需在
    MATCH 子句中展开它们并担心查询基数（行数）。在 Neo4j v5 中，你必须添加**EXISTS**子句，并用大括号括起用于过滤的指定图模式以执行存在性子查询。
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Additionally, you can now introduce new reference variables in the existential
    subqueries. For example, the following existential subquery filters **Character**
    nodes with a **FAMILY** relationship. However, only the patterns where the end
    node of the **FAMILY** relationship has both the **ALLIES** and the **MARRIAGE**
    relationship are considered.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你现在可以在存在性子查询中引入新的引用变量。例如，以下存在性子查询过滤具有**FAMILY**关系的**Character**节点。然而，仅考虑**FAMILY**关系的终节点同时具有**ALLIES**和**MARRIAGE**关系的模式。
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You may also see examples of a **MATCH** clause used within the existential
    subquery. Based on my experience, the **MATCH** clause is entirely optional. However,
    it might make the existential subquery syntax more readable and intuitive.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可能看到在存在性子查询中使用的**MATCH**子句。根据我的经验，**MATCH**子句完全是可选的。然而，它可能使存在性子查询的语法更具可读性和直观性。
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Check out the documentation for more [examples of existential subqueries](https://neo4j.com/docs/cypher-manual/current/syntax/expressions/#existential-subqueries).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 查看文档以获取更多[存在性子查询的示例](https://neo4j.com/docs/cypher-manual/current/syntax/expressions/#existential-subqueries)。
- en: Count subqueries
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计数子查询
- en: The last category of subqueries in this post is the so-called count subqueries.
    They are used to count the number of defined graph patterns. For example, I frequently
    used them in my previous blog posts to count the number of relationships a node
    has.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 本文最后一类子查询是所谓的计数子查询。它们用于计数定义的图模式数量。例如，我在以前的博客文章中经常使用它们来计数一个节点拥有的关系数量。
- en: '![](../Images/def6f328a4442fb65901196efcc6b64e.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/def6f328a4442fb65901196efcc6b64e.png)'
- en: Syntax change for counting subqueries. Image by the author.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 计数子查询的语法更改。图片由作者提供。
- en: Previously, you could wrap a graph pattern with the **size()** in order to count
    the number of particular patterns. It is a handy syntax to count graph patterns
    without affecting the cardinality of the main query. Additionally, it might outperform
    other approaches to counting the number of relationships. In Neo4j v5, you need
    to replace the **size()** operator with the **count{}**.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，你可以使用**size()**函数来计数特定模式的数量。这是一种方便的语法，可以计数图模式而不影响主查询的基数。此外，它可能比其他计数关系数量的方法表现更好。在
    Neo4j v5 中，你需要用**count{}**替代**size()**操作符。
- en: The following Cypher statement returns the top five Character node ordered by
    their degree (relationship count).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 Cypher 语句返回按其度数（关系计数）排序的前五个 Character 节点。
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As before, you can filter nodes by using the counting subqueries in a **WHERE**
    clause. In this example, the Cypher statement filters nodes with more than relationships.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如之前一样，您可以使用**WHERE**子句中的计数子查询来过滤节点。在这个例子中，Cypher语句过滤了具有多个关系的节点。
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Summary
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The new version of Neo4j offers faster performance and more Cypher flexibility.
    However, you might have to refactor a few of your existing Cypher statements to
    work with Neo4j v5\. Hopefully, this blog post will help you with the upgrade
    process.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j的新版本提供了更快的性能和更多的Cypher灵活性。然而，您可能需要重构一些现有的Cypher语句，以便与Neo4j v5兼容。希望这篇博客文章能帮助您完成升级过程。
- en: As always, the code is available on [GitHub](https://github.com/tomasonjo/blogs/blob/master/dune/Cypher_v5.ipynb).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，代码可以在[GitHub](https://github.com/tomasonjo/blogs/blob/master/dune/Cypher_v5.ipynb)上找到。
