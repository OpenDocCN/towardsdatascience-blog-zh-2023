- en: How Cypher changed in Neo4j v5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/how-cypher-changed-in-neo4j-v5-d0f10cbb60bf?source=collection_archive---------10-----------------------#2023-01-17](https://towardsdatascience.com/how-cypher-changed-in-neo4j-v5-d0f10cbb60bf?source=collection_archive---------10-----------------------#2023-01-17)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What’s new and what’s been deprecated in Cypher in the latest release of Neo4j
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://bratanic-tomaz.medium.com/?source=post_page-----d0f10cbb60bf--------------------------------)[![Tomaz
    Bratanic](../Images/d5821aa70918fcb3fc1ff0013497b3d5.png)](https://bratanic-tomaz.medium.com/?source=post_page-----d0f10cbb60bf--------------------------------)[](https://towardsdatascience.com/?source=post_page-----d0f10cbb60bf--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----d0f10cbb60bf--------------------------------)
    [Tomaz Bratanic](https://bratanic-tomaz.medium.com/?source=post_page-----d0f10cbb60bf--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F57f13c0ea39a&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-cypher-changed-in-neo4j-v5-d0f10cbb60bf&user=Tomaz+Bratanic&userId=57f13c0ea39a&source=post_page-57f13c0ea39a----d0f10cbb60bf---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----d0f10cbb60bf--------------------------------)
    ·9 min read·Jan 17, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fd0f10cbb60bf&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-cypher-changed-in-neo4j-v5-d0f10cbb60bf&user=Tomaz+Bratanic&userId=57f13c0ea39a&source=-----d0f10cbb60bf---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fd0f10cbb60bf&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-cypher-changed-in-neo4j-v5-d0f10cbb60bf&source=-----d0f10cbb60bf---------------------bookmark_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: A couple of weeks ago, Neo4j 5 was released. If you are like me and have ignored
    all the deprecation warnings during the later Neo4j 4 version, you might have
    to update your Cypher queries to work with the latest Neo4j version. Luckily,
    there are no significant differences in the new Cypher syntax, so the update process
    should not be difficult. However, I have decided to write this blog post to help
    you transition. Additionally, I will introduce some of the new Cypher syntax that
    could simplify your queries.
  prefs: []
  type: TYPE_NORMAL
- en: The Cypher examples of this blog post are available as a [Jupyter Notebook on
    GitHub](https://github.com/tomasonjo/blogs/blob/master/dune/Cypher_v5.ipynb).
  prefs: []
  type: TYPE_NORMAL
- en: Neo4j environment setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need to set up a Neo4j environment to follow the code examples in this
    post. As always, you can set up a local environment by using the [Neo4j Desktop](https://neo4j.com/download/)
    application. On the other hand, you can use a free cloud instance available as
    [Neo4j Aura](https://neo4j.com/cloud/platform/aura-graph-database/). If you choose
    the Neo4j Aura route, use the free forever instance and start a blank project
    that doesn’t come with a pre-populated graph.
  prefs: []
  type: TYPE_NORMAL
- en: '*p.s. The free forever Neo4j Aura instance does not offer GDS support. Since
    this is a Cypher focused blog post, you won’t be using any algorithms from the
    GDS library.*'
  prefs: []
  type: TYPE_NORMAL
- en: Dataset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I have a special place in my heart for fantasy or superhero datasets. This time,
    I found a dataset describing characters in the Dune series.
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://www.kaggle.com/datasets/bac3917/frank-herberts-dune-characters?source=post_page-----d0f10cbb60bf--------------------------------)
    [## Frank Herbert''s DUNE Characters'
  prefs: []
  type: TYPE_NORMAL
- en: Social networks in a fantastic world.... help build the dataset!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: www.kaggle.com](https://www.kaggle.com/datasets/bac3917/frank-herberts-dune-characters?source=post_page-----d0f10cbb60bf--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: The Dune dataset is available on Kaggle under the CC0 license. To make it easier
    for you, I have copied the dataset to a GitHub repository, so you don’t have to
    download the dataset and can easily import it in either your local or cloud instance
    of Neo4j. Additionally, I have renamed the relationship types Parent-Child and
    Other Family to Family, and removed the Unknown relation.
  prefs: []
  type: TYPE_NORMAL
- en: Graph Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/69e0591fd901d85c38e73fcbfe314b2e.png)'
  prefs: []
  type: TYPE_IMG
- en: Dune graph model. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: 'The graph model revolves around characters. The character nodes have multiple
    properties like the name, Culture, and when they were Born or Died. Additionally,
    their house allegiance is represented as a secondary node label. The main idea
    for using the secondary node label instead of a separate node is to demonstrate
    the new node label filtering options in Cypher. There are four types of relationships
    between characters:'
  prefs: []
  type: TYPE_NORMAL
- en: ALLIES
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ENEMIES,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FAMILY
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MARRIAGE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dataset import
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with most imports, you first want to define unique constraints in Neo4j.
    Unique constraints ensure that a given property is unique for every node with
    a particular label.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax for defining unique constraints has slightly changed in Neo4j v5.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/257dd08e5bcb1aa5a02b759bf6977287.png)'
  prefs: []
  type: TYPE_IMG
- en: Syntax change for UNIQUE CONSTRAINTS. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: The new syntax for unique constraints has two keywords replaced. The **ON**
    keyword is replaced with **FOR**, while the **ASSERT** is changed to **REQUIRE**.
  prefs: []
  type: TYPE_NORMAL
- en: The following Cypher statements define the unique constraint for **name** property
    of **Character** nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Next, you need to import the CSV file. Even though the Dune CSV file has only
    1000 rows, you will pretend you are dealing with a large CSV file with many thousands
    of rows. Therefore, you want to use batch import into multiple transactions. As
    **USING PERIODIC COMMIT** clause has been deprecated in Neo4j v5, you need to
    use the new batched transaction syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7b8afdda43d5009b5e07a8bf3cd7691f.png)'
  prefs: []
  type: TYPE_IMG
- en: Syntax change for importing large CSV files. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: The subqueries were already introduced in Neo4j v4 but have taken on a more
    prominent role in v5\. The subqueries are instantiated with a **CALL** clause
    and wrapped with curly brackets **{}**. They are great for various functionalities
    like [post-union processing](https://neo4j.com/developer/kb/post-union-processing/),
    [limiting results per row](https://neo4j.com/developer/kb/limiting-match-results-per-row/),
    and [conditional execution](https://neo4j.com/developer/kb/conditional-cypher-execution/).
    Additionally, the Cypher subqueries are now the only native Cypher syntax (excluding
    APOC) to batch a single Cypher statement into multiple transactions. In order
    to specify that the Cypher subquery should be split into multiple transactions,
    you need to add **IN** **TRANSACTIONS OF x ROWS**, where the x represents the
    number of rows for each batch.
  prefs: []
  type: TYPE_NORMAL
- en: The following Cypher statement contains two nested subqueries. The top-level
    subquery is used to batch the import into a new transaction for every 10 rows.
    On the other hand, you use the nested Cypher subquery as a conditional execution
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The import query is a bit more complicated because I wanted to do the import
    in a single Cypher statement. It starts with the **LOAD CSV** clause that you
    might have seen before. In order to batch the import into multiple transactions,
    you need to initiate a Cypher subquery with the **CALL** clause. The top-level
    subquery ends with the **IN TRANSACTIONS OF x ROWS** clause, which specifies the
    transaction batching.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use any variable in the Cypher statement, you must explicitly
    import it with the **WITH** clause. First, the top-level subquery import the **row**
    variable from the outer query. Next, it merges the Character node and sets a couple
    of properties. Since adding dynamic secondary labels is not supported in plain
    Cypher, you can use the APOC’s procedure.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the Dune characters have additional relationships defined in the **to**
    and **relationship_type** columns of the CSV. On the other hand, the **to** and
    **relationship_type** columns are empty for several rows. The [FOREACH conditional
    execution trick](https://neo4j.com/developer/kb/conditional-cypher-execution/#_using_foreach_for_write_only_cypher)
    was my go-to option for the better part of my blog post. However, as the theme
    of this blog post are Cypher subqueries, I have decided to show you how to use
    Cypher subqueries for conditional execution. First, with the nested Cypher subquery,
    you need to import both the **row** and the **c** variables. Next, you need to
    filter out only rows where the **to** column is not null. However, you cannot
    filter variables in the same **WITH** clause used to import them. Therefore, you
    need to add a second **WITH** clause to filter rows. Lastly, you use the APOC’s
    procedure for merging relationships, as the plain Cypher syntax does not support
    creating properties with dynamic relationship types.
  prefs: []
  type: TYPE_NORMAL
- en: You can check out the [documentation](https://neo4j.com/docs/cypher-manual/current/clauses/call-subquery)
    if this example was a bit too packed for you.
  prefs: []
  type: TYPE_NORMAL
- en: New inline filtering options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many new options available for inline filtering in Neo4j v5\. So what
    exactly is inline filtering? Essentially, it is the ability to filter a graph
    pattern directly in the **MATCH** clause.
  prefs: []
  type: TYPE_NORMAL
- en: You will begin by learning the new syntax for filtering node labels. In Neo4j
    v5, the following logical expressions were introduced to allow more flexible node
    filtering.
  prefs: []
  type: TYPE_NORMAL
- en: '& — AND expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| — OR expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '! — NOT expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, if you want to match all nodes with either the **Fremen** or **Harkonnen**
    label, you can use the **|** expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, if you need to find all nodes with both the **Character**
    and **Harkonnen** labels, you can use the **&** expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The **!** expression allows you to negate node labels. For example, say that
    you want to match all nodes with **the Character** label but don’t have the **Harkonnen**
    label.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The Cypher now also supports nested expressions for filtering node labels. For
    example, the following Cypher statement matches all nodes that don’t have the
    **Fremen** or the **Harkonnen** labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The expressions are nested using the parenthesis ().
  prefs: []
  type: TYPE_NORMAL
- en: Another feature added to Cypher is the option to include the **WHERE** clause
    within the **MATCH** clause. This allows you to apply all the flexibility of the
    Cypher filtering by node properties directly within the MATCH statement.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the following Cypher statement matches all characters where the
    **Culture** property starts with **Z** and the **Died** property is **not null**.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The same logical expressions used to filter nodes can also be used when filtering
    relationship types. For example, the **|** expression, which expresses the logical
    OR, has been in Cypher for quite some time.
  prefs: []
  type: TYPE_NORMAL
- en: The following Cypher statement matches all **Character** nodes with the **Culture**
    property values of **Bene Gesserit** and expands their **ALLIES** or **FAMILY**
    relationships.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using only the **&** expression does not really make sense as a single relationship
    cannot have more than one type. However, the combined with the negation **!**
    expression the **&** can come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the following Cypher statement expands all relationships that are
    not **ALLIES** or **FAMILY**.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Existential subqueries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, you will learn how the syntax for existential subqueries changed. An existential
    subquery can be used to find graph patterns that are part of a specified pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/cdda2ff1dd224d5ac59bca2ccae4347d.png)'
  prefs: []
  type: TYPE_IMG
- en: Syntax change for existential filters. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the existential subquery is used to find **Character** nodes
    that have either incoming or outgoing **FAMILY** relationships. I am a fan of
    existential subqueries as they offer the flexibility to filter nodes based on
    any graph patterns without having to expand them in the MATCH clause and worry
    about query cardinality (number of rows). In Neo4j v5, you have to add the **EXISTS**
    clause and wrap the specified graph pattern used for filtering with curly brackets
    in order to execute existential subqueries.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, you can now introduce new reference variables in the existential
    subqueries. For example, the following existential subquery filters **Character**
    nodes with a **FAMILY** relationship. However, only the patterns where the end
    node of the **FAMILY** relationship has both the **ALLIES** and the **MARRIAGE**
    relationship are considered.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You may also see examples of a **MATCH** clause used within the existential
    subquery. Based on my experience, the **MATCH** clause is entirely optional. However,
    it might make the existential subquery syntax more readable and intuitive.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Check out the documentation for more [examples of existential subqueries](https://neo4j.com/docs/cypher-manual/current/syntax/expressions/#existential-subqueries).
  prefs: []
  type: TYPE_NORMAL
- en: Count subqueries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last category of subqueries in this post is the so-called count subqueries.
    They are used to count the number of defined graph patterns. For example, I frequently
    used them in my previous blog posts to count the number of relationships a node
    has.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/def6f328a4442fb65901196efcc6b64e.png)'
  prefs: []
  type: TYPE_IMG
- en: Syntax change for counting subqueries. Image by the author.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, you could wrap a graph pattern with the **size()** in order to count
    the number of particular patterns. It is a handy syntax to count graph patterns
    without affecting the cardinality of the main query. Additionally, it might outperform
    other approaches to counting the number of relationships. In Neo4j v5, you need
    to replace the **size()** operator with the **count{}**.
  prefs: []
  type: TYPE_NORMAL
- en: The following Cypher statement returns the top five Character node ordered by
    their degree (relationship count).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As before, you can filter nodes by using the counting subqueries in a **WHERE**
    clause. In this example, the Cypher statement filters nodes with more than relationships.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The new version of Neo4j offers faster performance and more Cypher flexibility.
    However, you might have to refactor a few of your existing Cypher statements to
    work with Neo4j v5\. Hopefully, this blog post will help you with the upgrade
    process.
  prefs: []
  type: TYPE_NORMAL
- en: As always, the code is available on [GitHub](https://github.com/tomasonjo/blogs/blob/master/dune/Cypher_v5.ipynb).
  prefs: []
  type: TYPE_NORMAL
