- en: Using Polars Plugins for a 14x Speed Boost with Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/using-polars-plugins-for-a-14x-speed-boost-with-rust-ce80bcc13d94?source=collection_archive---------0-----------------------#2023-11-09](https://towardsdatascience.com/using-polars-plugins-for-a-14x-speed-boost-with-rust-ce80bcc13d94?source=collection_archive---------0-----------------------#2023-11-09)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Achieving high speed outside the native Polars library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@nelsongriffiths123?source=post_page-----ce80bcc13d94--------------------------------)[![Nelson
    Griffiths](../Images/9c8267aa6b9a3b73ccbc6c69b7804d1f.png)](https://medium.com/@nelsongriffiths123?source=post_page-----ce80bcc13d94--------------------------------)[](https://towardsdatascience.com/?source=post_page-----ce80bcc13d94--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----ce80bcc13d94--------------------------------)
    [Nelson Griffiths](https://medium.com/@nelsongriffiths123?source=post_page-----ce80bcc13d94--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F7278fd01858d&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fusing-polars-plugins-for-a-14x-speed-boost-with-rust-ce80bcc13d94&user=Nelson+Griffiths&userId=7278fd01858d&source=post_page-7278fd01858d----ce80bcc13d94---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----ce80bcc13d94--------------------------------)
    ·8 min read·Nov 9, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fce80bcc13d94&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fusing-polars-plugins-for-a-14x-speed-boost-with-rust-ce80bcc13d94&user=Nelson+Griffiths&userId=7278fd01858d&source=-----ce80bcc13d94---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fce80bcc13d94&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fusing-polars-plugins-for-a-14x-speed-boost-with-rust-ce80bcc13d94&source=-----ce80bcc13d94---------------------bookmark_footer-----------)![](../Images/700dc7427382e497ce6db147b1710bd3.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Generated by DALL-E 3
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Polars](https://www.pola.rs/) is taking the world by storm thanks to it’s
    speed, memory efficiency, and beautiful API. If you want to know how powerful
    it is, look no further than the [DuckDB Benchmarks](https://duckdb.org/2023/04/14/h2oai.html#results).
    And these aren’t even using the most recent version of Polars.'
  prefs: []
  type: TYPE_NORMAL
- en: For all the amazing things Polars can do though, it has not traditionally been
    a better solution than Pandas to do ALL the calculations you might want to do.
    There are a few exceptions where Polars has not outperformed. With the recent
    release of the Polars plugin system for Rust though, that may no longer be the
    case.
  prefs: []
  type: TYPE_NORMAL
- en: Polars Plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What exactly is a polars plugin? It is simply a way to create your own Polars
    Expressions using native Rust and exposing those to expressions using a custom
    namespace. It allows you to take the speed of Rust, and apply it to your Polars
    DataFrame to perform calculations in a way that takes advantage of the speed and
    built-in tooling Polars provides.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at some concrete examples.
  prefs: []
  type: TYPE_NORMAL
- en: Sequential Calculations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One area that Polars seems to lack some functionality is operations that require
    a knowledge of the previous value of a DataFrame. Calculations that are sequential
    in nature are not always super easy or efficient to write in native Polars expressions.
    Let’s take a look at one specific example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the following algorithm to calculate the cumulative value of an array
    of numbers for a given run, defined as a set of numbers that have the same sign.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: So we want to have a cumulative sum of a column which resets every time the
    sign of the value switches from either positive to negative or negative to positive.
  prefs: []
  type: TYPE_NORMAL
- en: Lets start with a baseline version written in pandas.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We iterate over a series, calculating the current value of the run at each position,
    and returning a new Pandas Series.
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before moving on, we are going to set up a few benchmarks. We are going to measure
    both execution speed and memory consumption using [pytest-benchmark](https://pypi.org/project/pytest-benchmark/)
    and [pytest-memray](https://pytest-memray.readthedocs.io/en/latest/). We will
    set up the problem such that we have an entity column, a time column, and a feature
    column. The goal is to calculate the run values for each entity in the data across
    time. We will set the number of entities and time stamps each to 1,000, giving
    us a DataFrame with 1,000,000 rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run our Pandas implementation against our benchmark using Pandas’ groupby
    apply functionality we get the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d90373ff8fef0522195c4de0d467db82.png)'
  prefs: []
  type: TYPE_IMG
- en: Pandas Apply Pytest-Benchmark (Image by Author)
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e4a6902c3af4b49c9f0682a7b0d516ff.png)'
  prefs: []
  type: TYPE_IMG
- en: Memray Output for Pandas Apply (Image by Author)
  prefs: []
  type: TYPE_NORMAL
- en: Polars Naive Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Okay, so now we have our benchmark. Let’s look at implementing this same functionality
    in Polars now. We will start with a very similar looking version that will be
    applied by mapping the function across a Polars GroupBy object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s see how this compares to our original Pandas benchmark.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c5be090a944c78c64dd6821b473264d1.png)'
  prefs: []
  type: TYPE_IMG
- en: Pandas Apply vs Polars Apply Pytest-Benchmark (Image by Author)
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6824a7646d8f840556de38010cea796a.png)'
  prefs: []
  type: TYPE_IMG
- en: Memray Output for Polars Apply (Image by Author)
  prefs: []
  type: TYPE_NORMAL
- en: Well, that didn’t work very well. That shouldn’t come as a surprise though.
    The writers of Polars have made it very clear that the very common groupby apply
    approach in Pandas is not an efficient way to do computations in Polars. Here
    it shows. Both the speed and memory consumption are worse than our original Pandas
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Polars Expression Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s write this same function as native Polars expressions now. This is the
    preferred and optimized way to work with Polars. The algorithm will look a little
    different. But here is what I came up with to calculate the same output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'A quick explanation for what we are doing here:'
  prefs: []
  type: TYPE_NORMAL
- en: Find all the rows where the feature is positive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find all the rows where the `__is_positive` column is different from the previous
    row.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take a cumulative sum of `__change_sides` to mark each distinct run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take a cumulative sum of the value over each distinct run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So now we have our native Polars function. Let’s do our benchmark again.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/205b9090889f88141aa8ca95d998d531.png)'
  prefs: []
  type: TYPE_IMG
- en: Pandas Apply vs Polars Apply vs Polars Native Pytest-Benchmark (Image by Author)
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c78fb98fb76fe3663f1def0e2772ce56.png)'
  prefs: []
  type: TYPE_IMG
- en: Memray Output for Polars Native (Image by Author)
  prefs: []
  type: TYPE_NORMAL
- en: We unfortunately did not see an improvement in the execution speed of our function.
    This is likely due to the number of `over` statements we have to do in order to
    calculate the run values. We did however, see an expected memory reduction. There
    may be an even better way to implement this with Polars expressions, but I am
    not going to worry about it right now.
  prefs: []
  type: TYPE_NORMAL
- en: Polars Plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So now let’s take a look at the new Polars plugins. If you want a tutorial on
    setting these up, take a look at [the documentation here.](https://pola-rs.github.io/polars/user-guide/expressions/plugins/)
    Here I am mostly going to show a specific implementation of a plugin. First we
    are going to write our algorithm in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You will notice this looks pretty similar to the algorithm we wrote in Python.
    We aren’t doing any fancy Rust magic here! We denote the output type using a macro
    that polars provides and that is it. We can then register our new function as
    an expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And then we can run it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Okay now lets check out the results!
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/59b180693a66aea9b1ade466a9cc308f.png)'
  prefs: []
  type: TYPE_IMG
- en: All Implementations Pytest-Benchmark (Image by Author)
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f5545fced9f7c5092e7f9d6846843c58.png)'
  prefs: []
  type: TYPE_IMG
- en: Memory Output for Polars Plugin (Image by Author)
  prefs: []
  type: TYPE_NORMAL
- en: Now that is more like it! We got a 14x speed improvement and dropped from ~57MiB
    to ~8MiB of memory allocated.
  prefs: []
  type: TYPE_NORMAL
- en: When to Use Polars Plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that I have shown the power of using plugins, let’s talk about when you
    shouldn’t use them. A few reasons I might not use plugins (each with it’s own
    caveats):'
  prefs: []
  type: TYPE_NORMAL
- en: '**If you can easily write a really fast version of your calculation using native
    Polars expressions.** The Polars developers are really smart. I would not bet
    money on myself writing a function significantly faster than they can. The tools
    for Polars are there. Take advantage of what they are good at!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**If there is no natural parallelization for your calculation**. For example,
    if we were not running the above problem over multiple entities, our speedup would
    likely have been significantly less. We benefitted both from the speed of Rust,
    and the natural ability of Polars to apply our Rust function over multiple groups
    at once.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**If you don’t need top notch speed or memory performance.** Many people will
    agree that writing Rust is much more difficult and time consuming than writing
    Python. So if you don’t care if your function takes 2 seconds to run instead of
    200 ms, you may not need to use plugins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Keeping the things above in mind, here are now a few requirements that I feel
    pull me towards using plugins sometimes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Speed and memory matter a lot.** I recently rewrote a lot of a data pipeline’s
    functionality in a Polars plugin because we were switching back and forth between
    Polars and other tools and the memory allocations were getting too big. It was
    getting hard to run the pipeline on the infrastructure we wanted to with the amount
    of data we wanted to. The plugins made it easy to run the same pipeline in much
    less time and on a much smaller machine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**You have a unique use case.** Polars provides so many built in functions.
    But it is a generic toolset that is broadly applicable to a lot of problems. Sometimes
    that toolset is not specifically applicable to the problem you are trying to solve.
    In this case, a plugin might be exactly what you want. Two of the most common
    examples of this that I have run into are more intense mathematical calculations,
    such as applying a cross-sectional linear regression, or sequential (row-based)
    calculations as we showed here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new plugin system is the perfect compliment to all of the columnar-based
    calculations that Polars already supports out of the box. With this addition,
    Polars is allowing for a beautiful extensibility to its capabilities. On top of
    writing your own plugins, watch out for some cool Polars plugin packages being
    developed that you can use to extend your capabilities without having to write
    plugins yourself!
  prefs: []
  type: TYPE_NORMAL
- en: Polars is moving fast and making waves. Check out the project, start using it,
    watch out for what other awesome features they will be releasing, and maybe start
    learning a little Rust while you are at it!
  prefs: []
  type: TYPE_NORMAL
