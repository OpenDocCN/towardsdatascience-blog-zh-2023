- en: 'More than Just Reptiles: Exploring the Iguanas Toolkit for XAI Beyond Black
    Box Models'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/iguanas-more-than-just-reptiles-exploring-the-iguanas-toolkit-for-xai-beyond-black-box-models-4330ad69029?source=collection_archive---------10-----------------------#2023-08-25](https://towardsdatascience.com/iguanas-more-than-just-reptiles-exploring-the-iguanas-toolkit-for-xai-beyond-black-box-models-4330ad69029?source=collection_archive---------10-----------------------#2023-08-25)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/b5cdab4ddf12010f2ca6dd033103cc41.png)'
  prefs: []
  type: TYPE_IMG
- en: '“AI thinking” Source: Created by author using [Dall-E](https://openai.com/dall-e-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Balancing complexity and transparency for effective decision making
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@vflovik?source=post_page-----4330ad69029--------------------------------)[![Vegard
    Flovik](../Images/6ebc40cb800e33b4df161f7a152b1ee2.png)](https://medium.com/@vflovik?source=post_page-----4330ad69029--------------------------------)[](https://towardsdatascience.com/?source=post_page-----4330ad69029--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----4330ad69029--------------------------------)
    [Vegard Flovik](https://medium.com/@vflovik?source=post_page-----4330ad69029--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F17ff8967433&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Figuanas-more-than-just-reptiles-exploring-the-iguanas-toolkit-for-xai-beyond-black-box-models-4330ad69029&user=Vegard+Flovik&userId=17ff8967433&source=post_page-17ff8967433----4330ad69029---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----4330ad69029--------------------------------)
    ·14 min read·Aug 25, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F4330ad69029&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Figuanas-more-than-just-reptiles-exploring-the-iguanas-toolkit-for-xai-beyond-black-box-models-4330ad69029&user=Vegard+Flovik&userId=17ff8967433&source=-----4330ad69029---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F4330ad69029&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Figuanas-more-than-just-reptiles-exploring-the-iguanas-toolkit-for-xai-beyond-black-box-models-4330ad69029&source=-----4330ad69029---------------------bookmark_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: 'As more and more industries adopt machine learning as part of their decision-making
    processes, an important question arises: How can we trust models where we cannot
    understand their reasoning, and how can we confidently make high-stakes decisions
    based on such information?'
  prefs: []
  type: TYPE_NORMAL
- en: For applications within safety-critical heavy-asset industries, where errors
    can lead to disastrous outcomes, lack of transparency can be a major roadblock
    for adoption. This is where model interpretability and [explainability](https://en.wikipedia.org/wiki/Explainable_artificial_intelligence)
    is becoming increasingly important.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of models along a spectrum of understandability: complex [deep neural
    networks](https://en.wikipedia.org/wiki/Deep_learning) occupy one end, while transparent
    [rule-based systems](https://en.wikipedia.org/wiki/Rule-based_system) reside on
    the other. In many cases, it’s equally important for a model’s output to be interpretable
    as to be perfectly accurate.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a4ffa2208ead88ae092d51c81b21eab8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Interpretability vs. Accuracy. Source: created by author'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this blog post, we’ll explore a method for automatically generating rule
    sets directly from data, which enables building a decision support system that
    is fully transparent and interpretable. It’s important to note that not all cases
    can be satisfactorily solved by such basic models though. However, initiating
    any modeling endeavor with a simple baseline model offers several key advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Swift Implementation:** Quick setup to initiate a foundational mode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Comparative Reference:** A benchmark for evaluating more advanced techniques'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Human-Understandable Insights:** Basic explainable models yield valuable
    human-interpretable insights'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To my fellow Data Science practitioners reading this post: I acknowledge the
    resemblance of this method to simply fitting a [decision tree model](https://en.wikipedia.org/wiki/Decision_tree_learning).
    However, as you continue reading, you’ll see that this method is tailored to mimic
    human rule creation, which makes it easier to interpret compared to the output
    from a typical decision tree model (which can often prove difficult in practice).'
  prefs: []
  type: TYPE_NORMAL
- en: Automated rule generation, as here showcased through the [Iguanas framework](https://github.com/paypal/Iguanas),
    illustrates how we can extract insightful (and human interpretable) rules directly
    from raw data. While the example in this blog post covers a specific case, the
    rule generation algorithms are in general adaptable also to other classification
    challenges.
  prefs: []
  type: TYPE_NORMAL
- en: '**Introduction to the example case:**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To illustrate the process of automatic rule generation, let’s use a hypothetical
    industry relevant case of pipeline integrity inspection. Ensuring the structual
    integrity of pipelines is a task that demands rigorous scrutiny, and is crucial
    to e.g. prevent environmental disasters. As such, our case represents a relevant
    example where model interpretability and explainability is of key importance.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/280d83e6d7f11a24e4acc59f63e53ba0.png)'
  prefs: []
  type: TYPE_IMG
- en: Integrity inspection. Photo by [Paul Teysen](https://unsplash.com/@hooverpaul55?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: In this case study, we begin by defining a dataset that emulates diverse pipeline
    attributes. These include parameters like length, diameter, wall thickness, number
    of welds, number of bends and corrosion level. In addition, we include a binary
    “violation” status that signifies whether a violation occurred based on a specific
    attribute combination. In essence, our dataset represents a [binary classification](https://en.wikipedia.org/wiki/Binary_classification)
    problem, which should be a familiar type of case for most data scientists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first step is to create a synthetic dataset containing the various attributes
    listed below for our inspected pipeline, accompanied by the corresponding violation
    status (categorized as “True” or “False”):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pipe length: interval 1–20 m'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pipe diameter: interval 1–10 cm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Measured pipe-wall thickness (e.g. from inspection): interval 1–10 mm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Number of welds: interval 0–10\. (all pipes consists of pipe segments of max
    length 10 m each. For total pipe length > 10m they would thus have to be joined/welded
    to another pipe, which means “num welds” > 0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Number of bends: Interval 0–5: number of bends of pipeline, where 0 represents
    a normal straight pipe segment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Corrosion: Categorical variable, either “None”, “Light” or “Severe” (e.g. from
    inspection).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Violation: Binary variable, “True” or “False” representing whether those set
    of attributes should result in a violation or not.’'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can then generate our synthetic dataset, where each row represents a set
    of pipeline attributes and the corresponding violation status. The attributes
    are defined within the specified intervals above, and the “violation” status is
    determined based on a predefined set of rules explained in more detail in the
    following section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Manual Rule Generation**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before diving into the automated rule generation, let’s first establish a baseline
    by manually defining a set of rules used to generate our initial dataset. We can
    then define some example rules for a violation, such as e.g:'
  prefs: []
  type: TYPE_NORMAL
- en: If the pipe diameter is greater than 8 cm and wall thickness measures 2 mm or
    less.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If pipe exhibits severe corrosion and the wall thickness measures 5 mm or less.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the total length of the pipeline exceeds 10 meters and no welds are present
    (since pipelines consist of segments with a maximum length of 10 meters, requiring
    welding for pipelines that surpass this length).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For pipe diameters exceeding 5 centimeters, if bends are present but no welds
    are detected (considering that pipes of this diameter are generally provided as
    straight segments and require subsequent welding with bent segments).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If any of these rules are broken, this should then be reported as a violation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Our synthetic dataset now encapsulates our “pipeline inspection”, featuring
    a collection of attributes for each pipe, along with the binary variable indicating
    whether this should be reported as a violation. The code block above also displays
    selected rows from our dataset, highlighting some examples where violations are
    reported:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/20cd17c13a3226b9bb8fd39b6c0c1247.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Example rows from the dataset: No violations'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2211da035fcd947f329ba6de445e39fc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Example rows from the dataset: Reported violations'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automated Rule Generation with Iguanas**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, the crucial question arises: Can we automatically derive an appropriate
    set of “integrity inspection rules” from the dataset above? It’s worth noting
    that these rule-generating algorithms have no knowledge of the specific rules
    we defined in the section above. This is where [Iguanas](https://github.com/paypal/Iguanas)
    enters the scene (the python package for building Rule-Based systems though, not
    actual iguanas).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/efa4901332798bd8feb4330ac17410ca.png)'
  prefs: []
  type: TYPE_IMG
- en: Iguana. Photo by [David Clode](https://unsplash.com/@davidclode?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Iguanas offers a suite of tools designed for generating and fine-tuning rules
    based on data. In our example case, we want to make use of this framework to see
    whether we can automatically generate meaningful rules interpretable by humans,
    while relying only on the information present in the dataset itself.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dataset Splitting and Preprocessing**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before applying any rule generation techniques, we first need to split the dataset
    into training and test sets. The training set will be used to build and optimize
    our rule-based system, while the test set will be used to evaluate its performance
    on unseen data. We here use a random split where we select 20% of the data for
    testing the rules on unseen data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to convert categorical variables (like corrosion) using [one-hot
    encoding](https://en.wikipedia.org/wiki/One-hot) to make them compatible with
    the rule generation algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Generating Rules with Iguanas**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Within the framework of [Iguanas](https://github.com/paypal/Iguanas), you’ll
    find two main rule generator algorithms to choose from: [*RuleGeneratorDT*](https://paypal.github.io/Iguanas/api/api/iguanas.rule_generation.RuleGeneratorDT.html)
    and [*RuleGeneratorOpt*](https://paypal.github.io/Iguanas/api/api/iguanas.rule_generation.RuleGeneratorOpt.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '*RuleGeneratorDT*: Generates rules by extracting the highest performing branches
    from a tree ensemble model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*RuleGeneratorOpt*: Generate rules by optimising the thresholds of single features
    and combining these one condition rules with AND conditions to create more complex
    rules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the example below we used *RuleGeneratorDT* as our chosen algorithm, although
    we could also have used the *RuleGeneratorOpt* alternative. We then define metrics
    like [F-score](https://en.wikipedia.org/wiki/F-score) and [precision](https://en.wikipedia.org/wiki/Precision_and_recall),
    and configure parameters for the rule generator. We here chose to generate rules
    with a max number of 4 conditions/statements to avoid overly complicated and long
    rules. We also made use of a [random forest classifier](https://en.wikipedia.org/wiki/Random_forest)
    as the base model for extracting rules. After defining these parameters, we can
    then fit the rule generator to our training data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Rule Filtering and Optimization**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The generated set of rules might contain redundancies or low-performing rules.
    To mitigate this issue, we use a series of filters to improve the resulting rule
    set:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we apply the [*SimpleFilter*](https://paypal.github.io/Iguanas/api/api/iguanas.rule_selection.SimpleFilter.html)
    to remove rules with F-scores below a certain threshold.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then use the [*CorrelatedFilter*](https://paypal.github.io/Iguanas/api/api/iguanas.rule_selection.CorrelatedFilter.html)
    with [*AgglomerativeClusteringReducer*](https://paypal.github.io/Iguanas/api/api/iguanas.correlation_reduction.AgglomerativeClusteringReducer.html?highlight=agglomerativeclusteringreducer#iguanas.correlation_reduction.AgglomerativeClusteringReducer)
    to further reduce correlated rules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we use the [*GreedyFilter*](https://paypal.github.io/Iguanas/api/api/iguanas.rule_selection.GreedyFilter.html)
    to select a subset of rules that maximizes a specific metric (e.g., [precision](https://en.wikipedia.org/wiki/Precision_and_recall)).
    Here, we’ll sort the rules by precision, then calculate the F1 score of the top
    n combined rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The code block above also plot the combined performance of the “top n” rules
    on the training set, as illustrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/dcd182cf02676bfdb192e4d66baf1826.png)'
  prefs: []
  type: TYPE_IMG
- en: '“Top n” Performance. Source: created by author'
  prefs: []
  type: TYPE_NORMAL
- en: What we see here, is that for a set of the top 4 rules we get a perfect match
    to our training data (which makes sense, as that is the same number of rules we
    used to generate our synthetic dataset).
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating an RBS Pipeline**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s set up our [*RBS Pipeline*](https://paypal.github.io/Iguanas/api/api/iguanas.rbs.RBSPipeline.html)
    using this combined, filtered rule set. In this case, we’ll go for a simple approach:'
  prefs: []
  type: TYPE_NORMAL
- en: If any rules trigger, mark violation as “True”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If no rules trigger, mark violation as “False”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To set up the pipeline using the logic above, we first need to create the config
    parameter. This is just a list which outlines the stages of the pipeline, where
    each stage should be defined using a tuple of two elements:'
  prefs: []
  type: TYPE_NORMAL
- en: The first element should be an integer which corresponds to the decision made
    at that stage (either 0 or 1).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second element should be a list that dictates which rules should trigger
    for that decision to be made.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also define the final decision if no rules trigger. This pipeline is then
    optimized using [*RBSOptimiser*](https://paypal.github.io/Iguanas/api/api/iguanas.rbs.RBSOptimiser.html).
    Here, we just pass the instantiated pipeline class to the pipeline parameter,
    and during this optimization it will also check whether it can further reduce
    the set of generated rules. We then run the [*fit_transform*](https://paypal.github.io/Iguanas/api/api/iguanas.pipeline.LinearPipeline.html?highlight=fit_transform#iguanas.pipeline.LinearPipeline.fit_transform)
    method to optimize our pipeline using the given training data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Performance Evaluation**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We evaluate the optimized pipeline’s performance on the training data through
    the resulting [classification_repor](https://scikit-learn.org/stable/modules/generated/sklearn.metrics.classification_report.html)t
    and by plotting the resulting [confusion matrix](https://en.wikipedia.org/wiki/Confusion_matrix).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As illustrated in the figure below, we see that for our training data we are
    able to perfectly predict the inspection status (Violation or not) for all datapoints.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/46a7b435f981852991ab868a63ea47f1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Metrics and confusion matrix for predicted violations. Source: created by author'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automatically Generated Set of Rules**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After completing the optimization steps above, we have finally obtained a set
    of rules that can be used for our “violation classifier”. We can then have a closer
    look at the corresponding rule strings to inspect whether they are indeed human
    interpretable (which was the main goal of building a rule-based classifier rather
    than a black-box machine learning model).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the printout below. If we compare that with our manually defined
    rules (appended below), we see that we actually ended up with the exact same set
    of rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If pipe exhibits severe corrosion and the wall thickness measures 5 mm or less.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For pipe diameters exceeding 5 centimeters, if bends are present but no welds
    are detected
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the pipe diameter is greater than 8 cm and wall thickness measures 2 mm or
    less.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the total length of the pipeline exceeds 10 meters and no welds are present
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Using Generated Rules on Test Data**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have already shown that the generated set of rules perfectly matched
    the rules we used to generate our dataset, we know that they will also work for
    the unseen data in the test set. However, in a more realistic case we would only
    have the dataset itself and not an original set of rules to compare with. To make
    sure that we have generated rules that generalize well also to unseen data, we
    would thus need to verify them on the test set as well:'
  prefs: []
  type: TYPE_NORMAL
- en: We then make use of the optimized RBS Pipeline to predict violations for the
    test set. As in the previous example, we evaluate its performance using the [classification_report](https://scikit-learn.org/stable/modules/generated/sklearn.metrics.classification_report.html)
    and by plotting the resulting [confusion matrix](https://en.wikipedia.org/wiki/Confusion_matrix).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/9287f56348a883f195a8602ee7f491bc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Metrics and confusion matrix for predicted violations. Source: created by author'
  prefs: []
  type: TYPE_NORMAL
- en: The results above demonstrate perfect accuracy and precision on the test data,
    indicating that the generated rules generalize well (as we in this case already
    knew).
  prefs: []
  type: TYPE_NORMAL
- en: '**Realistic Use-Case Scenarios**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned, in a real use-case we would not necessarily have a set of established
    rules to compare our output with. In most cases where we aim to build a classification
    model, we would be presented solely with a dataset of attributes/features and
    a corresponding target variable (such as e.g. “Violation” or “Non-violation”).
    The task would then be to use that dataset to automatically generate a set of
    rules that would give us insight into how those classifications are made.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively: Another way of using these algorithms are cases where you already
    have a set of manually defined rules (e.g. by domain experts). Yet, changes in
    the data distribution could render these rules suboptimal over time. In such cases,
    you can run this kind of algorithm with regular intervals to automatically recalibrate
    the rule set in line with these changes.'
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, this step-by-step approach is an effective way of incorporating
    the expertise of domain specialists into your solution. As they review the “violation”
    reports generated, they might notice situations where the flagged violations are
    actually not a problem. Once they validate the reports, the system can learn from
    their input and autonomously adjust the initial rule set. This continuous process
    ensures that the rules remain aligned with shifting data and insights from experts,
    allowing the solution to maintain (or even enhance) its performance over time.
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Utilizing automated rule generation, using e.g. the [Iguanas](https://paypal.github.io/Iguanas/index.html)
    framework, allows us to extract meaningful rules directly from the data. This
    stands in contrast to building a [black-box](https://en.wikipedia.org/wiki/Black_box)
    classification model for the same purpose. The transparency of a rule-based system
    enhances the interpretability of the decision-making process, which is often a
    crucial aspect of adopting such solutions in safety critical industries.
  prefs: []
  type: TYPE_NORMAL
- en: While the case we examined was quite specific, the rule generation process is
    also generalizable to various other classification challenges. While a rule-based
    approach might not be the optimal choice for more challenging problems, it could
    still provide valuable (human interpretable) insights to the problem at hand.
    Moreover, it would serve as a good foundational model, allowing us to compare
    and evaluate more advanced techniques against it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In conclusion, I’d like to leave you with this important takeaway: Before diving
    into complex state-of-the-art models, always take a moment to set up a quick baseline
    model. Whether that means utilizing a rule-based (or tree-based) approach for
    classification, as demonstrated in this case, or employing a simple [linear regression](https://en.wikipedia.org/wiki/Linear_regression)
    for regression tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, I’d like to emphasize the [“KISS” principle](https://en.wikipedia.org/wiki/KISS_principle),
    or “Keep It Simple, Stupid”. In other words, prioritize simplicity over unnecessary
    complexity when approaching problem-solving. The most effective solutions often
    emerge from the simplest strategies. So, remember, when in doubt, opt for simplicity!
  prefs: []
  type: TYPE_NORMAL
- en: In case you are interested in learning more about topics related to AI/Machine
    Learning and Data Science, you can also have a look at some of the other articles
    I have written. You will find all of them listed on my medium author profile,
    [which you can find here.](https://medium.com/@vflovik)
  prefs: []
  type: TYPE_NORMAL
- en: If you have found my previous articles interesting and want to get notified
    when new content is published, you can also sign up to the mailing list below
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/subscribe/@vflovik?source=post_page-----4330ad69029--------------------------------)
    [## Get an email whenever Vegard Flovik publishes.'
  prefs: []
  type: TYPE_NORMAL
- en: Get an email whenever Vegard Flovik publishes. By signing up, you will create
    a Medium account if you don't already…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/subscribe/@vflovik?source=post_page-----4330ad69029--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 'And, if you would like to become a Medium member to access all material on
    the platform freely, you can do so using my referral link below. (Note: If you
    sign up using this link, I will also receive a portion of the membership fee)'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/@vflovik/membership?source=post_page-----4330ad69029--------------------------------)
    [## Join Medium with my referral link - Vegard Flovik'
  prefs: []
  type: TYPE_NORMAL
- en: As a Medium member, a portion of your membership fee goes to writers you read,
    and you get full access to every story…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/@vflovik/membership?source=post_page-----4330ad69029--------------------------------)
  prefs: []
  type: TYPE_NORMAL
