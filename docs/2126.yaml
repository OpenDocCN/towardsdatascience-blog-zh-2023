- en: Developing Scientific Software
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/developing-scientific-software-d023a96188a3?source=collection_archive---------4-----------------------#2023-07-01](https://towardsdatascience.com/developing-scientific-software-d023a96188a3?source=collection_archive---------4-----------------------#2023-07-01)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Part 2: Practical Aspects with Python'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@cdacostaf?source=post_page-----d023a96188a3--------------------------------)[![Carlos
    Costa, Ph.D.](../Images/fc5e03e455f11b963086355fe0ccc077.png)](https://medium.com/@cdacostaf?source=post_page-----d023a96188a3--------------------------------)[](https://towardsdatascience.com/?source=post_page-----d023a96188a3--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----d023a96188a3--------------------------------)
    [Carlos Costa, Ph.D.](https://medium.com/@cdacostaf?source=post_page-----d023a96188a3--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fc1d045b63ee9&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fdeveloping-scientific-software-d023a96188a3&user=Carlos+Costa%2C+Ph.D.&userId=c1d045b63ee9&source=post_page-c1d045b63ee9----d023a96188a3---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----d023a96188a3--------------------------------)
    ·14 min read·Jul 1, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fd023a96188a3&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fdeveloping-scientific-software-d023a96188a3&user=Carlos+Costa%2C+Ph.D.&userId=c1d045b63ee9&source=-----d023a96188a3---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fd023a96188a3&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fdeveloping-scientific-software-d023a96188a3&source=-----d023a96188a3---------------------bookmark_footer-----------)![](../Images/5bdfc44e42db7093048e6fc163c86a15.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Photo by [Elton Luz](https://unsplash.com/@eltonluz?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: In this article we will follow the tenets of TDD for developing Scientific Software
    as laid out in [the first installment of this series](https://medium.com/@cdacostaf/developing-of-scientific-software-c8e89f6ade7)
    to develop an edge detection filter known as the Sobel filter.
  prefs: []
  type: TYPE_NORMAL
- en: In the first article, we talked about how important — and tricky — it can be
    to develop reliable testing methods for software which the complex problems often
    found in scientific software. We also saw how to overcome those issues by following
    a development cycle inspired by TDD, but adapted for scientific computing. I reproduce
    a shortened version of these instructions below.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Gather requirements
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sketch the design
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement initial tests
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement your alpha version
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build an oracle library
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Revisit tests
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement profiling
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optimization cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Optimize
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reimplement
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: New method cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implement new method
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Validate against previous curated oracles
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Getting Started: The Sobel Filter'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this article, we will follow the above instructions to develop a function
    which applies the [Sobel filter](https://en.wikipedia.org/wiki/Sobel_operator).
    The Sobel filter is a commonly used computer vision tool to detect or enhance
    edges in images. Keep reading to see some examples!
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/cfbc96a259c3e52a657bdb93cb6ffc7e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1\. Kernels for the Sobel–Feldman operator. Credit: own work.'
  prefs: []
  type: TYPE_NORMAL
- en: Starting with the first step, we gather some requirements. We will follow the
    standard formulation of the Sobel filter [described in this article](https://homepages.inf.ed.ac.uk/rbf/HIPR2/sobel.htm).
    Simply put, the Sobel operator consists of convolving image A with the following
    two 3 × 3 kernels, squaring each pixel in the resulting images, summing them and
    taking the point-by-point square root. If Ax and Ay are the images resulting from
    the convolutions, the result of the Sobel filter S is √(Ax² + Ay²).
  prefs: []
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want this function to take any 2D array and generate another 2D array. We
    might want it to operate on any two axes of an ndarray. We might even want it
    to work on more (or less) than two axes. We might have specifications for how
    to handle the edges of the array.
  prefs: []
  type: TYPE_NORMAL
- en: For now let’s remember to keep it simple, and start with a 2D implementation.
    But before we do that, let’s sketch the design.
  prefs: []
  type: TYPE_NORMAL
- en: Sketch the Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We start with a simple design, leveraging Python’s annotations. I highly recommend
    annotating as much as possible, and using [mypy](https://mypy-lang.org/) as a
    linter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Implement Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This function doesn’t do much. But it is documented, annotated, and its current
    limitations are baked into it. Now that we have a design, we immediately pivot
    to tests.
  prefs: []
  type: TYPE_NORMAL
- en: First, we notice that empty images (all zeroes) have no edges. So they must
    output zeroes as well. In fact, any constant image should also return zeros. Let’s
    bake that into out first tests. We will also see how we can use monkey testing
    to test many arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet can be run from the command-line with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Alpha Version
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course our tests will currently fail, but they are enough for now. Let’s
    implement a first version.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With this new function, all our tests should pass, and we should get an output
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We have so far:'
  prefs: []
  type: TYPE_NORMAL
- en: Gathered requirements of our problem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sketched an initial design.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implemented some tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implemented the alpha version, which passes these tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These tests provide *verification* for future versions, as well as a very rudimentary
    *oracle library*. But while unit tests are great at capturing minute deviations
    from expected results, they are not great at differentiating wrong results from
    quantitatively different — but still correct — results. Suppose tomorrow we want
    to implement another Sobel-type operator, which has a longer kernel. We don’t
    expect the results to match exactly to our current version, but we do expect the
    outputs of both functions to be qualitatively very similar.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, it is excellent practice to try many different inputs to our functions
    to get a sense of how they behave for different inputs. This ensures that we scientifically
    validate the results.
  prefs: []
  type: TYPE_NORMAL
- en: '[Scikit-image](https://scikit-image.org/) has an excellent library of images,
    which we can use to create oracles.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Once we have the data, we can plot it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/de4b988a164f8358ce0be4f820e561b3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2\. "Binary blobs" dataset before (left) and after (right) Sobel filtering.
    Credit: own work.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0f81e0b5a1e993918b4e395d54c7bad5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3\. "Text" dataset before (left) and after (right) Sobel filtering.
    Credit: own work.'
  prefs: []
  type: TYPE_NORMAL
- en: These look really good! I would recommend storing these, both as arrays and
    as figures which I can quickly check against for a new version. I highly recommend
    [HD5F](https://docs.h5py.org/en/stable/) for array storage. You can also set up
    a [Sphinx Gallery](https://sphinx-gallery.github.io/stable/index.html) to directly
    generate the figures them when updating documentation, that way you have a reproducible
    figure build that you can use to check against previous versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the results have been validated, you can store them on disk and use them
    as part of your unit testing. Something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Profiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computing the Sobel filter for these datasets took a while! So the next step
    is to profile the code. I recommend creating a `benchmark_xyz.py` file for each
    test, and re-run them regularly to probe for performance regressions. This can
    even be part of your unit testing, but we won’t go so far in this example. Another
    idea is to use the oracles above for benchmarking.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways of timing code execution. To get the system-wide, “real”
    elapsed time, use `perf_counter_ns` from the built-in `time` module to measure
    time in nanoseconds. In a Jupyter notebook, the built-in `[%%timeit](https://ipython.readthedocs.io/en/stable/interactive/magics.html#cell-magics)`
    [cell magic](https://ipython.readthedocs.io/en/stable/interactive/magics.html#cell-magics)
    times a certain cell execution. The decorator below is inspired by this cell magic
    and can be used to time any function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Putting our function to the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Not too fast :(
  prefs: []
  type: TYPE_NORMAL
- en: 'When investigating slowness or performance regressions, it is also possible
    to track the runtime of each line. The `[line_profiler](https://github.com/pyutils/line_profiler)`
    [library](https://github.com/pyutils/line_profiler) is an excellent resource for
    this. It can be used via [Jupyter cell magic](https://ipython-books.github.io/43-profiling-your-code-line-by-line-with-line_profiler/),
    or using the API. Here is an API example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Lot’s of time is spend inside the innermost loop. NumPy prefers vectorized math,
    as it can then rely on compiled code. Since we are using explicit for loops, it
    makes sense that this function is very slow.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, it is important to be smart about memory allocations inside of
    loops. NumPy is somewhat smart about allocating small amounts of memory inside
    loops, so the lines defining `s1` or `s2` might not be allocating new memory.
    But they also could be, or there could be some other memory allocation that is
    happening under the hood that we are not aware of. I therefore recommend also
    profiling memory. I like using [Memray](https://bloomberg.github.io/memray/) for
    that, but there are others like [Fil](https://pythonspeed.com/fil/docs/) and [Sciagraph](https://www.sciagraph.com/).
    I would also avoid [memory_profiler](https://github.com/pythonprofilers/memory_profiler)
    which (very unfortunately!) is no longer maintained. Also Memray is much more
    powerful. Here is an example of Memray in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/2b106bd52126ee51a1ea2a70056455bf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4\. Memray flamegraph for the alpha version. Credit: own work.'
  prefs: []
  type: TYPE_NORMAL
- en: Beta Version and a Bug
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a working alpha and some profiling functions, we will leverage
    the [SciPy library](https://scipy.org/) to obtain a much faster version.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Much better! But is it right?
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d91418b7e9c4454f28cdec7c5a290f17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5\. “Microaneurysms” dataset before (left) and after (center and right)
    Sobel filtering using both versions. Credit: own work.'
  prefs: []
  type: TYPE_NORMAL
- en: The images look very similar, but if you notice the color scale, they are not
    the same. Running the tests flags a small mean average error. Thankfully, we are
    now well-equipped at detecting quantitative and qualitative differences.
  prefs: []
  type: TYPE_NORMAL
- en: After investigating this bug, we attribute it to the different boundary conditions.
    Looking into `[convolve2d](https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.convolve2d.html)`
    [documentation](https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.convolve2d.html)
    tells us that the input array is padded with zeroes before applying the kernel.
    In the alpha, we padded the *output*!
  prefs: []
  type: TYPE_NORMAL
- en: 'Which one is right? Arguably the SciPy implementation makes more sense. In
    this case we should adopt the new version as the oracle, and if required, fix
    the alpha version to match it. This is common in scientific software development:
    new information of how to do things better changes the oracles and the tests.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the fix is easy, pad the array with zeros prior to processing
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Once we corrected out function, we can update the oracles and tests which rely
    on them.
  prefs: []
  type: TYPE_NORMAL
- en: Final Thoughts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw how to put in practice some of the software development ideas explored
    in [this article](https://medium.com/@cdacostaf/developing-of-scientific-software-c8e89f6ade7).
    We also saw some tools which you can use to develop high-quality, high-performance
    code.
  prefs: []
  type: TYPE_NORMAL
- en: I suggest you try some of these ideas on your own projects. In particular, practice
    profiling code and improving it. The Sobel filter function we coded is very inefficient,
    I suggest trying to improve it.
  prefs: []
  type: TYPE_NORMAL
- en: For example, try CPU parallelization with a JIT compiler such as [Numba](https://numba.readthedocs.io/en/stable/user/5minguide.html),
    porting the inner loop into [Cython](https://cython.readthedocs.io/en/latest/src/tutorial/cython_tutorial.html),
    or implementing a CUDA GPU function with [Numba](https://numba.readthedocs.io/en/stable/cuda/index.html)
    or [CuPy](https://docs.cupy.dev/en/stable/user_guide/basic.html). Feel free to
    check out [my series on coding CUDA kernels with Numba](/cuda-by-numba-examples-1-4-e0d06651612f).
  prefs: []
  type: TYPE_NORMAL
