- en: Developing Scientific Software
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/developing-scientific-software-d023a96188a3?source=collection_archive---------4-----------------------#2023-07-01](https://towardsdatascience.com/developing-scientific-software-d023a96188a3?source=collection_archive---------4-----------------------#2023-07-01)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Part 2: Practical Aspects with Python'
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@cdacostaf?source=post_page-----d023a96188a3--------------------------------)[![Carlos
    Costa, Ph.D.](../Images/fc5e03e455f11b963086355fe0ccc077.png)](https://medium.com/@cdacostaf?source=post_page-----d023a96188a3--------------------------------)[](https://towardsdatascience.com/?source=post_page-----d023a96188a3--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----d023a96188a3--------------------------------)
    [Carlos Costa, Ph.D.](https://medium.com/@cdacostaf?source=post_page-----d023a96188a3--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: ·
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fc1d045b63ee9&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fdeveloping-scientific-software-d023a96188a3&user=Carlos+Costa%2C+Ph.D.&userId=c1d045b63ee9&source=post_page-c1d045b63ee9----d023a96188a3---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----d023a96188a3--------------------------------)
    ·14 min read·Jul 1, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Fd023a96188a3&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fdeveloping-scientific-software-d023a96188a3&user=Carlos+Costa%2C+Ph.D.&userId=c1d045b63ee9&source=-----d023a96188a3---------------------clap_footer-----------)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fd023a96188a3&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fdeveloping-scientific-software-d023a96188a3&source=-----d023a96188a3---------------------bookmark_footer-----------)![](../Images/5bdfc44e42db7093048e6fc163c86a15.png)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Photo by [Elton Luz](https://unsplash.com/@eltonluz?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: In this article we will follow the tenets of TDD for developing Scientific Software
    as laid out in [the first installment of this series](https://medium.com/@cdacostaf/developing-of-scientific-software-c8e89f6ade7)
    to develop an edge detection filter known as the Sobel filter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: In the first article, we talked about how important — and tricky — it can be
    to develop reliable testing methods for software which the complex problems often
    found in scientific software. We also saw how to overcome those issues by following
    a development cycle inspired by TDD, but adapted for scientific computing. I reproduce
    a shortened version of these instructions below.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Implementation cycle
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Gather requirements
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sketch the design
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement initial tests
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement your alpha version
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build an oracle library
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Revisit tests
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement profiling
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optimization cycle
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Optimize
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reimplement
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: New method cycle
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implement new method
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Validate against previous curated oracles
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Getting Started: The Sobel Filter'
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this article, we will follow the above instructions to develop a function
    which applies the [Sobel filter](https://en.wikipedia.org/wiki/Sobel_operator).
    The Sobel filter is a commonly used computer vision tool to detect or enhance
    edges in images. Keep reading to see some examples!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/cfbc96a259c3e52a657bdb93cb6ffc7e.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1\. Kernels for the Sobel–Feldman operator. Credit: own work.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Starting with the first step, we gather some requirements. We will follow the
    standard formulation of the Sobel filter [described in this article](https://homepages.inf.ed.ac.uk/rbf/HIPR2/sobel.htm).
    Simply put, the Sobel operator consists of convolving image A with the following
    two 3 × 3 kernels, squaring each pixel in the resulting images, summing them and
    taking the point-by-point square root. If Ax and Ay are the images resulting from
    the convolutions, the result of the Sobel filter S is √(Ax² + Ay²).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Requirements
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want this function to take any 2D array and generate another 2D array. We
    might want it to operate on any two axes of an ndarray. We might even want it
    to work on more (or less) than two axes. We might have specifications for how
    to handle the edges of the array.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: For now let’s remember to keep it simple, and start with a 2D implementation.
    But before we do that, let’s sketch the design.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Sketch the Design
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We start with a simple design, leveraging Python’s annotations. I highly recommend
    annotating as much as possible, and using [mypy](https://mypy-lang.org/) as a
    linter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Implement Tests
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This function doesn’t do much. But it is documented, annotated, and its current
    limitations are baked into it. Now that we have a design, we immediately pivot
    to tests.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: First, we notice that empty images (all zeroes) have no edges. So they must
    output zeroes as well. In fact, any constant image should also return zeros. Let’s
    bake that into out first tests. We will also see how we can use monkey testing
    to test many arrays.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code snippet can be run from the command-line with
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Alpha Version
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course our tests will currently fail, but they are enough for now. Let’s
    implement a first version.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With this new function, all our tests should pass, and we should get an output
    like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We have so far:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Gathered requirements of our problem.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sketched an initial design.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implemented some tests.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implemented the alpha version, which passes these tests.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These tests provide *verification* for future versions, as well as a very rudimentary
    *oracle library*. But while unit tests are great at capturing minute deviations
    from expected results, they are not great at differentiating wrong results from
    quantitatively different — but still correct — results. Suppose tomorrow we want
    to implement another Sobel-type operator, which has a longer kernel. We don’t
    expect the results to match exactly to our current version, but we do expect the
    outputs of both functions to be qualitatively very similar.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: In addition, it is excellent practice to try many different inputs to our functions
    to get a sense of how they behave for different inputs. This ensures that we scientifically
    validate the results.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[Scikit-image](https://scikit-image.org/) has an excellent library of images,
    which we can use to create oracles.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once we have the data, we can plot it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![](../Images/de4b988a164f8358ce0be4f820e561b3.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2\. "Binary blobs" dataset before (left) and after (right) Sobel filtering.
    Credit: own work.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0f81e0b5a1e993918b4e395d54c7bad5.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3\. "Text" dataset before (left) and after (right) Sobel filtering.
    Credit: own work.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: These look really good! I would recommend storing these, both as arrays and
    as figures which I can quickly check against for a new version. I highly recommend
    [HD5F](https://docs.h5py.org/en/stable/) for array storage. You can also set up
    a [Sphinx Gallery](https://sphinx-gallery.github.io/stable/index.html) to directly
    generate the figures them when updating documentation, that way you have a reproducible
    figure build that you can use to check against previous versions.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'After the results have been validated, you can store them on disk and use them
    as part of your unit testing. Something like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Profiling
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computing the Sobel filter for these datasets took a while! So the next step
    is to profile the code. I recommend creating a `benchmark_xyz.py` file for each
    test, and re-run them regularly to probe for performance regressions. This can
    even be part of your unit testing, but we won’t go so far in this example. Another
    idea is to use the oracles above for benchmarking.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways of timing code execution. To get the system-wide, “real”
    elapsed time, use `perf_counter_ns` from the built-in `time` module to measure
    time in nanoseconds. In a Jupyter notebook, the built-in `[%%timeit](https://ipython.readthedocs.io/en/stable/interactive/magics.html#cell-magics)`
    [cell magic](https://ipython.readthedocs.io/en/stable/interactive/magics.html#cell-magics)
    times a certain cell execution. The decorator below is inspired by this cell magic
    and can be used to time any function.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Putting our function to the test:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Not too fast :(
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'When investigating slowness or performance regressions, it is also possible
    to track the runtime of each line. The `[line_profiler](https://github.com/pyutils/line_profiler)`
    [library](https://github.com/pyutils/line_profiler) is an excellent resource for
    this. It can be used via [Jupyter cell magic](https://ipython-books.github.io/43-profiling-your-code-line-by-line-with-line_profiler/),
    or using the API. Here is an API example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在调查慢速或性能回归时，还可以跟踪每一行的运行时间。`[line_profiler](https://github.com/pyutils/line_profiler)`
    [库](https://github.com/pyutils/line_profiler) 是一个很好的资源。它可以通过 [Jupyter 单元魔法](https://ipython-books.github.io/43-profiling-your-code-line-by-line-with-line_profiler/)
    或使用 API 来使用。以下是一个 API 示例：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here is an example output:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例输出：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Lot’s of time is spend inside the innermost loop. NumPy prefers vectorized math,
    as it can then rely on compiled code. Since we are using explicit for loops, it
    makes sense that this function is very slow.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 大量时间花费在最内层的循环中。NumPy 更喜欢矢量化数学，因为这样可以依赖编译的代码。由于我们使用显式的 for 循环，因此这个函数非常慢是合理的。
- en: 'In addition, it is important to be smart about memory allocations inside of
    loops. NumPy is somewhat smart about allocating small amounts of memory inside
    loops, so the lines defining `s1` or `s2` might not be allocating new memory.
    But they also could be, or there could be some other memory allocation that is
    happening under the hood that we are not aware of. I therefore recommend also
    profiling memory. I like using [Memray](https://bloomberg.github.io/memray/) for
    that, but there are others like [Fil](https://pythonspeed.com/fil/docs/) and [Sciagraph](https://www.sciagraph.com/).
    I would also avoid [memory_profiler](https://github.com/pythonprofilers/memory_profiler)
    which (very unfortunately!) is no longer maintained. Also Memray is much more
    powerful. Here is an example of Memray in action:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，明智地处理循环中的内存分配非常重要。NumPy 对于在循环中分配小量内存有一定的智能，因此定义` s1 `或` s2 `的行可能并未分配新的内存。但它们也可能分配了，或者可能在幕后有一些我们未察觉的内存分配。因此，我建议也进行内存分析。我喜欢使用
    [Memray](https://bloomberg.github.io/memray/)，但还有其他工具，如 [Fil](https://pythonspeed.com/fil/docs/)
    和 [Sciagraph](https://www.sciagraph.com/)。我还会避免使用 [memory_profiler](https://github.com/pythonprofilers/memory_profiler)，因为（非常不幸的是！）它不再维护。此外，Memray
    更强大。以下是 Memray 使用中的一个示例：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![](../Images/2b106bd52126ee51a1ea2a70056455bf.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2b106bd52126ee51a1ea2a70056455bf.png)'
- en: 'Figure 4\. Memray flamegraph for the alpha version. Credit: own work.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4\. Memray 火焰图（alpha 版本）。来源：自制作品。
- en: Beta Version and a Bug
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Beta 版本和一个 Bug
- en: Now that we have a working alpha and some profiling functions, we will leverage
    the [SciPy library](https://scipy.org/) to obtain a much faster version.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个可用的 alpha 版本和一些性能分析函数，我们将利用 [SciPy 库](https://scipy.org/) 来获得一个更快的版本。
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Much better! But is it right?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 好得多！但它是正确的吗？
- en: '![](../Images/d91418b7e9c4454f28cdec7c5a290f17.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d91418b7e9c4454f28cdec7c5a290f17.png)'
- en: 'Figure 5\. “Microaneurysms” dataset before (left) and after (center and right)
    Sobel filtering using both versions. Credit: own work.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5\. “微动脉瘤” 数据集在使用两个版本的 Sobel 滤波前（左）和后（中间和右）。来源：自制作品。
- en: The images look very similar, but if you notice the color scale, they are not
    the same. Running the tests flags a small mean average error. Thankfully, we are
    now well-equipped at detecting quantitative and qualitative differences.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图像看起来非常相似，但如果注意颜色比例，它们并不相同。运行测试时标记了一个小的平均误差。幸运的是，我们现在可以很好地检测定量和定性差异。
- en: After investigating this bug, we attribute it to the different boundary conditions.
    Looking into `[convolve2d](https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.convolve2d.html)`
    [documentation](https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.convolve2d.html)
    tells us that the input array is padded with zeroes before applying the kernel.
    In the alpha, we padded the *output*!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在调查这个 Bug 后，我们将其归因于不同的边界条件。查看 `[convolve2d](https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.convolve2d.html)`
    [文档](https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.convolve2d.html)
    告诉我们，输入数组在应用卷积核之前会用零填充。在 alpha 版本中，我们填充了*输出*！
- en: 'Which one is right? Arguably the SciPy implementation makes more sense. In
    this case we should adopt the new version as the oracle, and if required, fix
    the alpha version to match it. This is common in scientific software development:
    new information of how to do things better changes the oracles and the tests.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 哪一个是正确的？可以说 SciPy 实现更有意义。在这种情况下，我们应该采用新版本作为标准，如果需要，修复 alpha 版本以匹配它。这在科学软件开发中很常见：如何更好地做事的新信息会改变标准和测试。
- en: In this case, the fix is easy, pad the array with zeros prior to processing
    it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，修复很简单，在处理之前用零填充数组即可。
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Once we corrected out function, we can update the oracles and tests which rely
    on them.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们修正了函数，就可以更新依赖于它们的测试和预期结果。
- en: Final Thoughts
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后的思考
- en: We saw how to put in practice some of the software development ideas explored
    in [this article](https://medium.com/@cdacostaf/developing-of-scientific-software-c8e89f6ade7).
    We also saw some tools which you can use to develop high-quality, high-performance
    code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了如何在[这篇文章](https://medium.com/@cdacostaf/developing-of-scientific-software-c8e89f6ade7)中探讨的一些软件开发理念中付诸实践。我们还介绍了一些工具，你可以使用它们来开发高质量、高性能的代码。
- en: I suggest you try some of these ideas on your own projects. In particular, practice
    profiling code and improving it. The Sobel filter function we coded is very inefficient,
    I suggest trying to improve it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你在自己的项目中尝试这些想法。特别是，练习代码分析和改进。我们编写的Sobel滤波器函数非常低效，我建议尝试改进它。
- en: For example, try CPU parallelization with a JIT compiler such as [Numba](https://numba.readthedocs.io/en/stable/user/5minguide.html),
    porting the inner loop into [Cython](https://cython.readthedocs.io/en/latest/src/tutorial/cython_tutorial.html),
    or implementing a CUDA GPU function with [Numba](https://numba.readthedocs.io/en/stable/cuda/index.html)
    or [CuPy](https://docs.cupy.dev/en/stable/user_guide/basic.html). Feel free to
    check out [my series on coding CUDA kernels with Numba](/cuda-by-numba-examples-1-4-e0d06651612f).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以尝试使用如[Numba](https://numba.readthedocs.io/en/stable/user/5minguide.html)的JIT编译器进行CPU并行化，将内部循环移植到[Cython](https://cython.readthedocs.io/en/latest/src/tutorial/cython_tutorial.html)，或者使用[Numba](https://numba.readthedocs.io/en/stable/cuda/index.html)或[CuPy](https://docs.cupy.dev/en/stable/user_guide/basic.html)实现CUDA
    GPU函数。欢迎查看[我关于用Numba编写CUDA内核的系列文章](/cuda-by-numba-examples-1-4-e0d06651612f)。
