- en: How I Created Generative Art with Python That 10000 DALL-E Credits Could Not
    Buy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/how-i-created-generative-art-with-python-that-10000-dall-e-credits-could-not-buy-fcf804b61437?source=collection_archive---------1-----------------------#2023-07-19](https://towardsdatascience.com/how-i-created-generative-art-with-python-that-10000-dall-e-credits-could-not-buy-fcf804b61437?source=collection_archive---------1-----------------------#2023-07-19)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[](https://borach.medium.com/?source=post_page-----fcf804b61437--------------------------------)[![Borach
    Jansema](../Images/02280890ed87239c75cbcbfa7c5d686c.png)](https://borach.medium.com/?source=post_page-----fcf804b61437--------------------------------)[](https://towardsdatascience.com/?source=post_page-----fcf804b61437--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----fcf804b61437--------------------------------)
    [Borach Jansema](https://borach.medium.com/?source=post_page-----fcf804b61437--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·
  prefs: []
  type: TYPE_NORMAL
- en: '[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F26c634bbd08&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-i-created-generative-art-with-python-that-10000-dall-e-credits-could-not-buy-fcf804b61437&user=Borach+Jansema&userId=26c634bbd08&source=post_page-26c634bbd08----fcf804b61437---------------------post_header-----------)
    Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page-----fcf804b61437--------------------------------)
    ·11 min read·Jul 19, 2023[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2Ffcf804b61437&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-i-created-generative-art-with-python-that-10000-dall-e-credits-could-not-buy-fcf804b61437&user=Borach+Jansema&userId=26c634bbd08&source=-----fcf804b61437---------------------clap_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Ffcf804b61437&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fhow-i-created-generative-art-with-python-that-10000-dall-e-credits-could-not-buy-fcf804b61437&source=-----fcf804b61437---------------------bookmark_footer-----------)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python and Pillow: How to Code Something DALL-E Cannot Do'
  prefs: []
  type: TYPE_NORMAL
- en: In this blog post, I will showcase some of the generative art I created using
    the Python programming language, specifically utilizing the Pillow and Torch libraries.
    The inspiration for my artwork came from the visual compositions of Roman Haubenstock-Ramati,
    an Austrian music composer and visual artist.
  prefs: []
  type: TYPE_NORMAL
- en: In early 2021 I was frequently browsing Catawiki because I wanted to buy some
    art to decorate my home office. When I came across Haubenstock-Ramati’s creations
    on Catawiki in early 2021, I was immediately captivated by the intricate and beautiful
    nature of his parametric art. I had been wanting to do something creative with
    my coding skills for a while, I was inspired to develop code that could produce
    similar output. The image below is an example of one of the images that inspired
    me, created by Roman Haubenstock-Ramati.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f0d763fe94d9d99a05ffa139f53c29b8.png)'
  prefs: []
  type: TYPE_IMG
- en: '[Konstellationen](https://www.mutualart.com/Artwork/-Konstellationen-/9D3C9F0000BAC080),
    1970/1971 by Roman Haubenstock-Ramati'
  prefs: []
  type: TYPE_NORMAL
- en: After the release of Dall-E 2 in April 2022, I explored using the model to generate
    artwork that should resemble Haubenstock-Ramati’s work. Asking the model to do
    this is a controversial topic as there are valid concerns about the capacity of
    AI models being able to produce output that is so similar to the work of an artist
    that the output can be considered as a copyright infringement on the original
    work. This discussion is beyond the scope of this blogpost but I want to make
    clear that the prompts I fed into Dall-E were not intended to produce exact copies
    of Haubenstock-Ramati’s work or to devalue his works. The same goes for the code
    I have written they are not intended to distribute copies of his work but merely
    a demonstration of how you can use Python to create visual geometric compositions.
  prefs: []
  type: TYPE_NORMAL
- en: The output of DALL-E was interesting, but it did not quite capture the essence
    of his original pieces. The output lacked the precise constraints and intricacies
    present in Haubenstock-Ramati’s art. I tried many variations of prompts but could
    never get close to what I wanted.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/cf1d05296b01dbbdc4e8e52b47dad8a3.png)![](../Images/db2e5d309d0197d7951a6b0786d86f2a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Some of the outputs generated by Dall-E given my prompt: “Create a painting
    composition in the style of Roman Haubenstock-Ramati that incorporates elements
    of graphic notation and experimental musical composition. The painting should
    be predominantly black and white with bold lines and geometric shapes, and should
    include a central motif that represents the theme of the piece.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'In an attempt to simplify the process, I posed a simpler request to Dall-E:
    “Draw a vertical line connected to a rectangle, connect a square to the line,
    and connect the square with another vertical line to another rectangle, and finally
    connect the rectangle to a circle with another vertical line.” Surprisingly, the
    results were unexpected. Despite the simplicity of the prompt, Dall-E struggled
    to understand the intended relationships between the shapes, yielding unexpected
    outcomes.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5dd1084d4055b0477b078be052210bf0.png)![](../Images/1823a60e74cfde60397f932c321880ce.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Images generated by Dall-E given the prompt: “Draw a vertical line connected
    to a rectangle, connect a square to the line, and connect the square with another
    vertical line to another rectangle, and finally connect the rectangle to a circle
    with another vertical line.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'It became clear to me Dall-E does not have the capacity to process geometrically
    constrained prompts, I tried an even simpler prompt: “Create a drawing that only
    shows two orthogonal lines”. This also proved to be too difficult.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e15c859898a59c0013db60450f0a5031.png)![](../Images/7df3731a890e4d049fb72a539fa977b7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Images generated by Dall-E give the prompt: “Create a drawing that only shows
    two orthogonal lines”'
  prefs: []
  type: TYPE_NORMAL
- en: This inability of Dall-E surprised me, but when thinking about how a model like
    Dall-E works, this is not surprising. It is based on latent diffusion which is
    inherently a noisy process and not optimised for constraint-based exact prompts.
  prefs: []
  type: TYPE_NORMAL
- en: Next, I will show the images I generated and talk in more detail about how to
    code something like this.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/51e8c59fd457abd3d68e79bd9add5169.png)'
  prefs: []
  type: TYPE_IMG
- en: Single example of an image generated by my code.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/58e5a69a4e133c2e19b5e292681dd20c.png)'
  prefs: []
  type: TYPE_IMG
- en: A gif showing different images created by my code, showing the diversity of
    images created by the same parameters.
  prefs: []
  type: TYPE_NORMAL
- en: I made these images using Python and Pillow, devoid of any machine learning.
    The images produced by my code have elements of randomness introduced via Torch,
    a versatile package that I utilized for its familiarity and convenience. It is
    normally a package used in Machine Learning (ML). But again these images are not
    made using Machine Learning (ML).
  prefs: []
  type: TYPE_NORMAL
- en: You might wonder where the diversity of the images comes from, I personally
    love how my code is able to generate images that give a similar vibe but are all
    so different if you look closely. The diversity in outputs was an essential characteristic
    to achieve. The variance of the images my code produces stems from an intricate
    use of random variables. A random variable, in the realm of probability theory
    and statistics, is a variable whose possible values are outcomes of a random phenomenon.
  prefs: []
  type: TYPE_NORMAL
- en: Now I will describe the generation process of the images made by my code and
    show some examples in Python of how this generation process looks like from a
    high level perspective.
  prefs: []
  type: TYPE_NORMAL
- en: We can divide the generation process into 3 steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: The centerpiece is generated. This is done by sampling a rectangle,
    a line, a rectangle, a square, a line, and a circle. These are placed in a fixed
    position and the size of the shapes are determined by random variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Step 2: Three clusters with lines and adjacent are sampled from three different
    distributions. In each cluster a number of vertical lines with various starting
    and ending points are placed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Step 3: Circles and rectangles are sampled and drawn within the clusters of
    lines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/8ca93965e4c1b962b68be02f9a5e2595.png)'
  prefs: []
  type: TYPE_IMG
- en: Gif showing the step-by-step generation process of a single image.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the role of random variables in my code, consider the first step
    in our image creation process: forming a portrait-style rectangle, characterized
    by its greater height than its width. This rectangle, although seemingly simple,
    is an embodiment of random variables in action.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A rectangle can be dissected into four principal elements: a starting x and
    y coordinate, and an ending x and y coordinate. Now, these points, when chosen
    from a specific distribution, transform into random variables. But how do we decide
    the range of these points, or more specifically, the distribution they come from?
    The answer lies in one of the most common and crucial distributions in statistics:
    The Normal Distribution.'
  prefs: []
  type: TYPE_NORMAL
- en: Defined by two parameters — the mean (μ) and standard deviation (σ), the Normal
    Distribution plays a pivotal role in our image generation process. The mean, μ,
    signifies the center of the distribution, thus acting as the point around which
    the values of our random variables gravitate. The standard deviation, σ, quantifies
    the degree of dispersion in the distribution. It decides the range of values the
    random variables could potentially take. In essence, a larger standard deviation
    would result in greater diversity in the images created.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Sampling a square looks very similar we only have to sample the height or the
    width as they are the same. Sampling a circle is even easier as we only have to
    sample the radius.
  prefs: []
  type: TYPE_NORMAL
- en: 'Drawing a rectangle in Python is a straightforward process, especially when
    utilizing the Pillow library. Here’s how you can do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Step 2**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the context of the vertical lines in these images, we consider three random
    variables, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: The beginning y-coordinate of the line (y_start)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ending y-coordinate of the line (y_end)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The x-coordinate of the line (x)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we are dealing with vertical lines, only one x-coordinate needs to be
    sampled for each line. The width of the line is constant, controlled by the size
    of the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Some additional logic was needed to ensure the lines didn’t intersect. To do
    this basically, we need to keep account of the image as a grid and keep track
    of the occupied positions. Let's disregard that for the sake of simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example of how this looks like in Python.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This however only gives you lines. Another part of the cluster is the circles
    at the end of the lines, I called these adjacent circles. Random variables also
    determine their process. First, the fact that there will be an adjacent circle
    is sampled from a Bernoulli distribution, and the position (left, middle, right)
    of the shape is sampled from a uniform distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'A circle can be defined entirely by a single parameter: its radius. We can
    consider the length of a line as a condition that influences the radius of the
    circle. This forms a conditional probability model where the radius (R) of the
    circle is dependent on the length of the line (L). We use a conditional Gaussian
    distribution. The mean (μ) of this distribution is a function of the square root
    of the line length, while the standard deviation (σ) is a constant.'
  prefs: []
  type: TYPE_NORMAL
- en: We initially suggest that the radius R, given the line length L, follows a normal
    distribution. This is denoted as R | L ~ N(μ(L), σ²), where N is the normal (Gaussian)
    distribution and σ is the standard deviation.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this has a small problem: the normal distribution includes the possibility
    of sampling a negative value. This outcome is not physically possible in our scenario,
    as a radius cannot be negative.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To circumvent this issue, we can use the half-normal distribution. This distribution,
    much like the normal distribution, is defined by a scale parameter σ, but crucially,
    it is constrained to non-negative values. The radius given the line length follows
    a half-normal distribution: R | L ~ HN(σ), where HN denotes the half-normal distribution.
    This way, σ is determined by the desired mean as σ = √(2L) / √(2/π), ensuring
    that all sampled radii are non-negative and that the mean of the distribution
    is √(2L)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Step 3**'
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 in our process is a combination of elements from Steps 1 and 2\. In Step
    1, we tackled the task of sampling and drawing rectangles in set positions. In
    Step 2, we learned how to use the normal distribution to draw lines on a portion
    of your canvas. Additionally, we acquired knowledge on how to sample and draw
    circles.
  prefs: []
  type: TYPE_NORMAL
- en: As we transition to Step 3, we are going to repurpose the techniques from the
    previous steps. Our aim is to distribute squares and circles harmoniously around
    the lines that we sampled earlier. The normal distribution, will once again come
    in handy for this task.
  prefs: []
  type: TYPE_NORMAL
- en: We will re-use the parameters used to create clusters of lines. However, to
    enhance the visual appeal and avoid overlaps, we introduce some noise to the mean
    (mu) and standard deviation values.
  prefs: []
  type: TYPE_NORMAL
- en: In this step, instead of positioning lines, our task is to place sampled rectangles
    and circles. I encourage you to play around with these techniques and try if you
    can add circles and rectangles to your cluster of lines.
  prefs: []
  type: TYPE_NORMAL
- en: In this blog post, I’ve dissected and simplified the processes underpinning
    my code to enable a deeper understanding of how it operates. I’ve shown the difficulty
    for generative AI models like Dall-E to follow precise constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the code that produced these images was a great experience for me. Seeing
    the image progress with each line of code I wrote was so cool to witness. I hope
    that this blog post has piqued your interest in the intersection of art and coding.
    I encourage you to use your coding skills and bring your imagination alive using
    code. There’s no need to exhaust your Dall-E credits; the power to create is right
    at your fingertips.
  prefs: []
  type: TYPE_NORMAL
