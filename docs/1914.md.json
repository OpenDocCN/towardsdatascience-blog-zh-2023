["```py\nimport numpy as np\nimport torch\nimport torch.nn\nimport torch.optim\nimport torch.profiler\nimport torch.utils.data\nimport torchvision.datasets\nimport torchvision.models\nimport torchvision.transforms as T\nfrom torchvision.datasets.vision import VisionDataset\nfrom PIL import Image\n\nclass FakeCIFAR(VisionDataset):\n    def __init__(self, transform):\n        super().__init__(root=None, transform=transform)\n        self.data = np.random.randint(low=0,high=256,size=(10000,32,32,3),dtype=np.uint8)\n        self.targets = np.random.randint(low=0,high=10,size=(10000),dtype=np.uint8).tolist()\n\n    def __getitem__(self, index):\n        img, target = self.data[index], self.targets[index]\n        img = Image.fromarray(img)\n        if self.transform is not None:\n            img = self.transform(img)\n        return img, target\n\n    def __len__(self) -> int:\n        return len(self.data)\n\ntransform = T.Compose(\n    [T.Resize(224),\n     T.ToTensor(),\n     T.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))])\n\ntrain_set = FakeCIFAR(transform=transform)\ntrain_loader = torch.utils.data.DataLoader(train_set, batch_size=32, \n                                           shuffle=True)\n\ndevice = torch.device(\"cuda:0\")\nmodel = torchvision.models.resnet18(weights='IMAGENET1K_V1').cuda(device)\ncriterion = torch.nn.CrossEntropyLoss().cuda(device)\noptimizer = torch.optim.SGD(model.parameters(), lr=0.001, momentum=0.9)\nmodel.train()\n\n# train step\ndef train(data):\n    inputs, labels = data[0].to(device=device), data[1].to(device=device)\n    outputs = model(inputs)\n    loss = criterion(outputs, labels)\n    optimizer.zero_grad()\n    loss.backward()\n    optimizer.step()\n\n# training loop wrapped with profiler object\nwith torch.profiler.profile(\n        schedule=torch.profiler.schedule(wait=1, warmup=4, active=3, repeat=1),\n        on_trace_ready=torch.profiler.tensorboard_trace_handler('./log/resnet18'),\n        record_shapes=True,\n        profile_memory=True,\n        with_stack=True\n) as prof:\n    for step, batch_data in enumerate(train_loader):\n        if step >= (1 + 4 + 3) * 1:\n            break\n        train(batch_data)\n        prof.step()  # Need to call this at the end of each step \n```", "```py\ntrain_loader = torch.utils.data.DataLoader(train_set, batch_size=32, \n                               shuffle=True, num_workers=8)\n```", "```py\ntrain_loader = torch.utils.data.DataLoader(train_set, batch_size=32, \n                          shuffle=True, num_workers=8, pin_memory=True)\n```", "```py\ninputs, labels = data[0].to(device=device, non_blocking=True), \\\n                 data[1].to(device=device, non_blocking=True)\n```", "```py\n# maintain the image input as an 8-bit uint8 tensor\ntransform = T.Compose(\n    [T.Resize(224),\n     T.PILToTensor()\n     ])\ntrain_set = FakeCIFAR(transform=transform)\ntrain_loader = torch.utils.data.DataLoader(train_set, batch_size=1024, \n                                           shuffle=True, num_workers=8,\n                                           pin_memory=True)\n\ndevice = torch.device(\"cuda:0\")\nmodel = torchvision.models.resnet18(weights='IMAGENET1K_V1').cuda(device)\ncriterion = torch.nn.CrossEntropyLoss().cuda(device)\noptimizer = torch.optim.SGD(model.parameters(), lr=0.001, momentum=0.9)\nmodel.train()\n\n# train step\ndef train(data):\n    inputs, labels = data[0].to(device=device, non_blocking=True), \\\n                     data[1].to(device=device, non_blocking=True)\n    # convert to float32 and normalize\n    inputs = (inputs.to(torch.float32) / 255\\. - 0.5) / 0.5\n    outputs = model(inputs)\n    loss = criterion(outputs, labels)\n    optimizer.zero_grad()\n    loss.backward()\n    optimizer.step()\n```", "```py\noptimizer.zero_grad(set_to_none=True)\n```", "```py\ndef train(data):\n    inputs, labels = data[0].to(device=device, non_blocking=True), \\\n                     data[1].to(device=device, non_blocking=True)\n    inputs = (inputs.to(torch.float32) / 255\\. - 0.5) / 0.5\n    with torch.autocast(device_type='cuda', dtype=torch.float16):\n        outputs = model(inputs)\n        loss = criterion(outputs, labels)\n    # Note - torch.cuda.amp.GradScaler() may be required  \n    optimizer.zero_grad(set_to_none=True)\n    loss.backward()\n    optimizer.step()\n```", "```py\nmodel = torchvision.models.resnet18(weights='IMAGENET1K_V1').cuda(device)\nmodel = torch.compile(model)\n```"]