["```py\n> str( cars )\n'data.frame': 50 obs. of  2 variables:\n $ speed: num  4 4 7 7 8 9 10 10 10 11 ...\n $ dist : num  2 10 4 22 16 10 18 26 34 17 ...\n```", "```py\n# Assign dependent variable to the response vector\ny_vec <- cars$dist\n```", "```py\n# Create a design matrix with the single independent variable\nx_mat <- model.matrix( dist ~ speed, data = cars )\n```", "```py\n> head(x_mat)\n  (Intercept) speed\n1           1     4\n2           1     4\n3           1     7\n4           1     7\n5           1     8\n6           1     9\n```", "```py\n# Compute cross-product of the design matrix\nA  <- t( x_mat ) %*% x_mat\n```", "```py\n> A\n            (Intercept) speed\n(Intercept)          50   770\nspeed               770 13228\n```", "```py\n> sum( cars$speed )\n[1] 770\n```", "```py\n> sum( cars$speed ^ 2 )\n[1] 13228\n```", "```py\n# Inverting the matrix A\nA_inv <- solve( A )\n```", "```py\n# Shifting the elements in A\nn_obs <- nrow( cars )\nA_rev <- with(cars, matrix( c(sum( speed ^ 2), -sum( speed ), -sum( speed ), n_obs), nrow = 2))\n> A_rev\n      [,1] [,2]\n[1,] 13228 -770\n[2,]  -770   50\n```", "```py\n# Computing the scalar constant for matrix inversion\nc <- (n_obs * with( cars, sum( (speed - mean(speed)) ^ 2) )) ^ -1\n```", "```py\n# Computation of the matrix inverse\n> c * A_rev\n            [,1]         [,2]\n[1,]  0.19310949 -0.011240876\n[2,] -0.01124088  0.000729927\n```", "```py\n# Print output from solve() function\n> A_inv\n            (Intercept)        speed\n(Intercept)  0.19310949 -0.011240876\nspeed       -0.01124088  0.000729927\n```", "```py\n> round( A %*% A_inv )\n            (Intercept) speed\n(Intercept)           1     0\nspeed                 0     1\n```", "```py\n# Matrix multiplying the design matrix and response vector\nB <- t( x_mat ) %*% y_vec\n```", "```py\n# Compute vector and compare with B\n> with( cars, matrix( c( sum( dist ), sum( speed * dist) ) , ncol = 1 ))\n      [,1]\n[1,]  2149\n[2,] 38482\n>\n> B\n             [,1]\n(Intercept)  2149\nspeed       38482\n```", "```py\n# Estimate the parameter values using solution to normal equation\nb_vec <- A_inv %*% B\n```", "```py\n> b_vec\n                  [,1]\n(Intercept) -17.579095\nspeed         3.932409\n```", "```py\n> coef( lm( dist ~ speed, data = cars ) )\n(Intercept)       speed \n -17.579095    3.932409 \n```", "```py\n# The slope parameter\nb_1 <- with(cars, cov(speed, dist) / var(speed) )\n\n# The intercept parameter\nb_0 <- with(cars, mean(dist) - mean(speed) * b_1 )\n```", "```py\n> c( \"intercept\" = b_0, \"slope\" = b_1 )\n intercept      slope \n-17.579095   3.932409\n```", "```py\n# Compute the fitted values\ny_hat <- x_mat %*% b_vec\n\n# Compute the residuals\ne_vec <- y_hat - y_vec\n```"]