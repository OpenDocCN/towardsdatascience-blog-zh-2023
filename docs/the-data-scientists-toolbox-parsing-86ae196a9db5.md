# 数据科学家的工具箱：解析

> 原文：[https://towardsdatascience.com/the-data-scientists-toolbox-parsing-86ae196a9db5?source=collection_archive---------7-----------------------#2023-11-11](https://towardsdatascience.com/the-data-scientists-toolbox-parsing-86ae196a9db5?source=collection_archive---------7-----------------------#2023-11-11)

## 如果您有合适的工具，解析复杂文档将会变得很容易

[](https://medium.com/@doug.blank?source=post_page-----86ae196a9db5--------------------------------)[![Douglas Blank, PhD](../Images/b2fa86b9fe63a8bcb4f218ef5a6791e9.png)](https://medium.com/@doug.blank?source=post_page-----86ae196a9db5--------------------------------)[](https://towardsdatascience.com/?source=post_page-----86ae196a9db5--------------------------------)[![向数据科学迈进](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page-----86ae196a9db5--------------------------------) [Douglas Blank, PhD](https://medium.com/@doug.blank?source=post_page-----86ae196a9db5--------------------------------)

·

[阅读更多](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F66e2bac7e7d8&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fthe-data-scientists-toolbox-parsing-86ae196a9db5&user=Douglas+Blank%2C+PhD&userId=66e2bac7e7d8&source=post_page-66e2bac7e7d8----86ae196a9db5---------------------post_header-----------) 发表在[向数据科学迈进](https://towardsdatascience.com/?source=post_page-----86ae196a9db5--------------------------------) ·9分钟读·2023年11月11日[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Ftowards-data-science%2F86ae196a9db5&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fthe-data-scientists-toolbox-parsing-86ae196a9db5&user=Douglas+Blank%2C+PhD&userId=66e2bac7e7d8&source=-----86ae196a9db5---------------------clap_footer-----------)

--

[](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F86ae196a9db5&operation=register&redirect=https%3A%2F%2Ftowardsdatascience.com%2Fthe-data-scientists-toolbox-parsing-86ae196a9db5&source=-----86ae196a9db5---------------------bookmark_footer-----------)![](../Images/38272ce6f7419e699fcc02d3a16f4b5c.png)

本文讨论的基于Python的新rd2md解析器和转换器的源代码。图片由作者提供。

对于许多数据科学家来说，将复杂文档转换为可用数据是一个常见问题。让我们看看一个复杂的文档，并探讨不同的转换数据的方法。

**简介；**

我们将在开发复杂解析器的过程中探索这些规则：

**Rule 1: Be lazy; don’t do any more than is what is needed**

Rule 2: Start with the easy parts of the problem.

Rule 3: Don’t be afraid to throw away code and start over!

Rule 4: Use the simplest method possible to get the job done.

**问题**

作为一家机器学习公司的研究主管，我经常面临各种问题，需要进行探索和解决方案设计。上周出现了一个有趣的小问题：我们需要一种方法来为我们的[开源 R SDK](https://github.com/comet-ml/cometr)生成 markdown 文档，以便机器学习实验记录重要细节。我们需要一个快速的解决方案，而不花费太多时间。

这个问题可能比数据科学家每天遇到的稍微复杂一些，但它将作为一个很好的示例，展示如何使用不同的解析方法。而且作为额外奖励，我们将得到一个填补特定领域的[开源项目](https://github.com/comet-ml/rd2md/)。让我们深入了解一下吧！

在听到这个问题后，我的第一个研发规则开始起作用：

**规则 1：要懒惰；只做必要的事情**（懒惰被拉里·沃尔认为是[程序员的三大美德](https://thethreevirtues.com/)之一）。

所以我开始查看将 R 代码转换为 markdown 是否已经解决了。看来确实解决了！然而，在尝试了我能找到的所有可用程序（如 R 的旧版[ Rd2md](https://cran.r-project.org/web/packages/Rd2md/index.html)）之后，它们都无法工作，且 git 仓库也不再活跃。好吧，我只能靠自己了。如果我是一名更好的 R 程序员，我可能会尝试修复现有的解决方案。但我更喜欢 Python，认为它是一个很好的解析示例。所以，是的，我们将用 Python 解析 R 文档。

所以，我开始编写一些代码。这让我想起了我的下一个研发规则：

**规则 2：从问题的简单部分开始。**

规则 2 可能只是我满足需要一些即时反馈的方式。但它也解决了一个更重要的问题：如果你从简单的部分开始，也许困难的部分就不会那么难。它还作为一个热身，开始解决一个问题。我通常在编码解决方案时有一两个错误的开始。这导致了我的下一个规则：

**规则 3：不要害怕丢弃代码并重新开始！**

最后，当你走在正确的道路上时，最后一个规则是：

**规则 4：使用最简单的方法完成工作。**

好的，那么将 R 文档文件转换为 markdown 的最简单方法是什么？首先，什么是 R 文档文件？R 文档直接从 R 代码转换为类似于[LaTeX](https://en.wikipedia.org/wiki/LaTeX)的东西。这是一个示例（文件以 .Rd 结尾）：

```py
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/experiment.R
\name{Experiment}
\alias{Experiment}
\title{A Comet Experiment object}
\description{
A comet experiment object can be used to modify or get information about an active
experiment. All methods documented here are the different ways to interact with an
experiment. Use \code{\link[=create_experiment]{create_experiment()}} to create or \code{\link[=get_experiment]{get_experiment()}} to
retrieve a Comet experiment object.
}
```

目标是将 LaTeX 转换为看起来像这样的 markdown：

```py
## Description

A comet experiment object can be used to modify or get information about an active
experiment. All methods documented here are the different ways to interact with an
experiment. Use [`create_experiment()`](../create_experiment) to create or [`get_experiment()`](../get_experiment) to
retrieve a Comet experiment object.
```

渲染效果如下：

![](../Images/97565b6721fff6562a8d318ea6f63f61.png)

示例的 markdown 输出。图片由作者提供。

好吧，我们从一个非常简单的开始。我们将逐行分析 Rd 文件，像这样：

```py
doc = Documentation()
...
for line in lines:
    if line.startswith("%"):
        pass
    elif line.startswith("\\name{"):
        matches = re.search("{(.*)}", line)
        groups = groups()
        name = groups[0]
        doc.set_name(name)
    ...
```

在这段代码中，我们查看一行是否以“%”开头，如果是，我们就跳过它（它只是 Rd 文件中的注释）。同样，如果它以“\name”开头，那么我们就设置当前文档名称。请注意，如果我们不使用“raw” Python 字符串，则需要转义反斜杠。代码**re.search(“{(.*)}”, line)**假设这一行会包含结束的大括号。在我们的 SDK 中所有示例中，这一假设都是成立的，所以按照规则 3，我不会让这段代码变得更复杂。

请注意，我们在处理文件中的行之前构造了一个**Documentation()** 实例。我们这样做是为了收集所有部分，然后在最后调用**doc.generate()**。我们这样做（而不是实时生成 markdown）是因为我们解析的一些项在 markdown 中的顺序可能会不同。

我们可以以完全相同的方式处理一些 R 代码：在 Rd 文件中查找模式，并立即处理它。然而，让我们来看一下下一个无法以这种方式处理的部分：

```py
\usage{
create_experiment(
  experiment_name = NULL,
  project_name = NULL,
  workspace_name = NULL,
  api_key = NULL,
  keep_active = TRUE,
  log_output = TRUE,
  log_error = FALSE,
  log_code = TRUE,
  log_system_details = TRUE,
  log_git_info = FALSE
)
}
```

使用部分总是以**\usage{** 开头，并以单个 **}** 结束。由于是这样，我们可以利用这些事实创建一个稍微复杂一点的解析器：

```py
...
for line in lines:
    ....
    elif line.startswith("\\usage{"):
        usage = ""
        line = fp_in.readline().rstrip()
        while line != "}":
            usage += line + "\n"
            line = fp_in.readline().rstrip()
        doc.set_usage(usage)
```

这将逐行读取，收集**\usage{}**部分中的所有文本。

当我们转到下一个最复杂的部分时，我们必须开始变得有点聪明，并且首次使用“状态”这一概念。

考虑这段 LaTeX 代码：

```py
\item{log_error}{If \code{TRUE}, all output from 'stderr' (which includes errors,
warnings, and messages) will be redirected to the Comet servers to display as message
logs for the experiment. Note that unlike \code{auto_log_output}, if this option is on then
these messages will not be shown in the console and instead they will only be logged
to the Comet experiment. This option is set to \code{FALSE} by default because of this
behavior.}
```

这很棘手。顶层格式是：

```py
\item{NAME}{DESCRIPTION}
```

然而，DESCRIPTION 本身可以包含大括号项。如果你有这一段代码作为字符串（即使包含换行），你可以使用 Python 的 re（正则表达式）模块，如下所示：

```py
text = """\item{log_error}{If \code{TRUE}, all output from 'stderr' (which includes errors,
warnings, and messages) will be redirected to the Comet servers to display as message
logs for the experiment. Note that unlike \code{auto_log_output}, if this option is on then
these messages will not be shown in the console and instead they will only be logged
to the Comet experiment. This option is set to \code{FALSE} by default because of this
behavior.}"""

matches = re.search("{(.*)}{(.*)}", text, re.DOTALL)
```

你可以通过**matches.groups()** 获取 NAME 和 DESCRIPTION。正则表达式模式**“{(.*)}{(.*)}”**中的括号表示匹配两个组：第一个组位于第一个大括号集之间，第二个组位于下一个大括号集之间。这很好用，前提是**text** 只是那个部分。为了能够在不先拆分该部分的情况下进行解析，我们实际上必须逐个字符地解析文本。但这并不难。

这是一个小函数，它将在给定文件指针的情况下获取多个大括号部分（在现代 Python 行话中也称为“类文件”）：

```py
def get_curly_contents(number, fp):
    retval = []
    count = 0
    current = ""
    while True:
        char = fp.read(1)
        if char == "}":
            count -= 1
            if count == 0:
                if current.startswith("{"):
                    retval.append(current[1:])
                elif current.startswith("}{"):
                    retval.append(current[2:])
                else:
                    raise Exception("malformed?", current)
                current = ""
        elif char == "{":
            count += 1
        if len(retval) == number:
            return retval
        current += char
```

在函数**get_curly_contents()**中，你需要传入大括号部分的数量和一个文件指针。因此，要从文件中获取 2 个大括号部分，你可以这样做：

```py
fp = open(FILENAME)
name, description = get_curly_contents(2, fp)
```

**get_curly_contents()** 是这个项目中几乎最复杂的部分。它有三个状态变量：**retval**、**count** 和 **current**。**retval** 是已解析部分的列表。**count** 是当前大括号项的深度。**current** 是当前正在处理的内容。这个函数实际上在一些地方非常有用，正如我们将看到的那样。

最后，还有一个更复杂的层面。问题区域是 R 类定义中的**Method**子章节。这是一个简化的示例：

```py
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Experiment-new"></a>}}
\if{latex}{\out{\hypertarget{method-Experiment-new}{}}}
\subsection{Method \code{new()}}{
Do not call this function directly. Use \code{create_experiment()} or \code{get_experiment()} instead.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Experiment$new(
  experiment_key,
  project_name = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{experiment_key}}{The key of the \code{Experiment}.}

\item{\code{project_name}}{The project name (can also be specified using the \code{COMET_PROJECT_NAME}
parameter as an environment variable or in a comet config file).}
}
\if{html}{\out{</div>}}
}
}
```

这很复杂，因为我们有嵌套的部分：**Usage** 和 **Arguments** 在 **Method** 里面。我们将为这次解析拿出全部的解析工具。

为了简化这个过程，我们首先要做的是“分词”**Method**子章节。这是一个将文本拆分成相关字符串的 fancy 词汇。例如，考虑这个 LaTeX 文本：

```py
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Experiment$new(
  experiment_key,
  project_name = NULL
)}\if{html}{\out{</div>}}
}
```

它可以被分解成一个字符串列表，如下：

```py
[
 "\\", "subsection", "{", "Usage", "}", "\\", "if",
 "{", "html", "}", "{", "\\", "out", "{", "<", "div", 
 " ",  "class", "=", "\"r\"", ">", "}", "}", "\\", 
 "preformatted", "{", "Experiment$new", "(", "experiment_key",
 "project_name", "=", "NULL", ")", "}", "\\", "if",
 "{", "html", "}", "{", "\\", "out", "{", "<", "/", "div",
 ">", "}", "}", "}"
]
```

一组分词字符串使你能够轻松地将其处理成子部分。此外，你还可以轻松地“前瞻”一个或多个标记，以查看接下来会发生什么。这对于正则表达式或处理单个字符而非标记时可能很困难。以下是解析分词部分的一个示例：

```py
doc = Documentation()
...
method = Method()
position = 0
preamble = ""
tokens = tokenize(text)
while position < len(tokens):
    token = tokens[position]
    if token == "\\":
        if tokens[position + 1] == "subsection":
            in_preamble = False
            if tokens[position + 3] == "Usage":
                position, usage = get_tokenized_section(
                    position + 5, tokens
                ) 
                method.set_usage(usage)
            elif tokens[position + 3] == "Arguments":
                # skip this, we'll get with describe
                position += 5
            elif tokens[position + 3] == "Examples":
                position, examples = get_tokenized_section(
                    position + 5, tokens
                )
                method.set_examples(examples)
            elif tokens[position + 3] == "Returns":
                position, returns = get_tokenized_section(
                    position + 5, tokens
                ) 
                method.set_returns(returns)
            else:
                raise Exception("unkown subsection:", tokens[position + 3])
        elif tokens[position + 1] == "describe":
            position, describe = get_tokenized_section(position + 2, tokens)  # noqa
            method.set_describe(describe)
        else:
            # \html
            position += 1
    else:
        if in_preamble:
            preamble += token
        position += 1

method.set_preamble(preamble)
doc.add_method(method)
```

就是这样！要查看完成的项目，请查看新的基于 Python 的 [rd2md](https://github.com/comet-ml/rd2md/)。它是一个 [pip-installable](https://pypi.org/project/rd2md/)，开源的 Python 库，用于从 R 的 Rd 文件生成 markdown。我们在这里使用了它的 R 文档：

[https://www.comet.com/docs/v2/api-and-sdk/r-sdk/overview/](https://www.comet.com/docs/v2/api-and-sdk/r-sdk/overview/)

这是一个下午的临时小项目吗？是的。它由不低于 4 种不同的解析方法组成。但它能完成任务，而且据我所知，它是唯一有效的 Rd 到 markdown 转换器。如果我要重构它，我可能会先分词整个文件，然后使用上面展示的最后一种方法进行处理。记住规则 3：**不要害怕丢弃代码并重新开始！**

如果你想为 GitHub 仓库做贡献，请随意。如果你有问题，请在 [Issues](https://github.com/comet-ml/rd2md/issues) 中告诉我们。

***对人工智能、机器学习和数据科学感兴趣？考虑点赞和关注一下吧。Doug 是*** [***comet.com***](https://www.comet.com/)***的研究主管，该公司专注于机器学习实验跟踪和模型监控。***
